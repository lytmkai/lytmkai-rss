<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[多模态推理新范式！DiffThinker：用扩散模型「画」出推理和答案]]></title>    <link>https://juejin.cn/post/7592432859862745122</link>    <guid>https://juejin.cn/post/7592432859862745122</guid>    <pubDate>2026-01-07T12:24:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592432859862745122" data-draft-id="7592432859862728738" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="多模态推理新范式！DiffThinker：用扩散模型「画」出推理和答案"/> <meta itemprop="keywords" content="人工智能,OpenAI"/> <meta itemprop="datePublished" content="2026-01-07T12:24:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="机器之心"/> <meta itemprop="url" content="https://juejin.cn/user/1873223543167902"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            多模态推理新范式！DiffThinker：用扩散模型「画」出推理和答案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1873223543167902/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    机器之心
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T12:24:47.000Z" title="Wed Jan 07 2026 12:24:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在多模态大模型（MLLMs）领域，思维链（CoT）一直被视为提升推理能力的核心技术。然而，面对复杂的长程、视觉中心任务，这种基于文本生成的推理方式正面临瓶颈：文本难以精确追踪视觉信息的变化。形象地说，模型不知道自己想到哪一步了，对应图像是什么状态。</p>
<p>尽管近期的「Thinking with Image」范式可以通过工具等对图像进行操作，但它们难以扩展到更复杂的长程任务，且在多轮交互中本身开销巨大。</p>
<p>近日，来自上海人工智能实验室、南京大学、香港中文大学和上海交通大学的研究团队提出了一种全新的生成式多模态推理（Generative Multimodal Reasoning）范式，并发布了模型 <strong>DiffThinker</strong>。</p>
<p>DiffThinker 彻底打破了「多模态输入 -&gt; 文本输出」的传统定式，将推理过程重构为图像到图像（Image-to-Image）的生成任务。通过扩散模型（Diffusion Models），DiffThinker 能够在视觉空间中直接生成推理路径。</p>
<p>实验结果令人惊讶：在包含长程规划、组合优化、约束满足、空间推理等 7 项视觉中心的复杂任务中，DiffThinker 的表现显著优于包括 GPT-5 (+314.2%) 和 Gemini-3-Flash (+111.6%) 在内的顶尖闭源模型，以及经过相同数据微调的 Qwen3-VL-32B 基线 (+39.0%)。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb4417ae72074fcf9d1118ee24b6dc29~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768393487&amp;x-signature=moVIA8MMmI3d0Ue5vl%2BYD093Dpk%3D" alt="图片" loading="lazy"/></p>
<ul>
<li>
<p><strong>论文标题：DiffThinker: Towards Generative Multimodal Reasoning with Diffusion Models</strong></p>
</li>
<li>
<p><strong>论文地址</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2512.24165" target="_blank" title="https://arxiv.org/abs/2512.24165" ref="nofollow noopener noreferrer">arxiv.org/abs/2512.24…</a></p>
</li>
<li>
<p><strong>项目主页</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdiffthinker-project.github.io" target="_blank" title="https://diffthinker-project.github.io" ref="nofollow noopener noreferrer">diffthinker-project.github.io</a></p>
</li>
<li>
<p><strong>代码仓库</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flcqysl%2FDiffThinker" target="_blank" title="https://github.com/lcqysl/DiffThinker" ref="nofollow noopener noreferrer">github.com/lcqysl/Diff…</a></p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd535b274cfc4cccbea1a19e97a4ae79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768393487&amp;x-signature=5dKPHGIMhMZyPzDrX88aBm0GS7Q%3D" alt="图片" loading="lazy"/></p>
<h4 data-id="heading-0">01 从「以文思考」到「以图思考」</h4>
<h4 data-id="heading-1"/>
<p>现有的多模态大模型在处理视觉推理任务时，难以追踪视觉信息的变化。比如在空间导航任务（VSP、Maze 等）中，模型仅靠语言分析路径，但输入图像不变，路径一长就很容易「看走眼」，不知道自己已经走到了哪。又比如拼图任务，模型如果不能直接对拼图操作，很难凭空想象出答案。即便是最新的「Thinking with Image」范式，也往往依赖于多轮对话和工具调用，导致推理链路极长，难以扩展到复杂场景。</p>
<p>研究团队还在项目主页提供了几个小游戏，以直观理解人与 MLLM 的思维范式差异。</p>
<p>那么，为什么不能让模型直接「看」着问题，把答案「画」出来？</p>
<p>DiffThinker 提出的核心理念正是如此。研究团队认为，多模态推理不应局限于符号空间，而应回归视觉空间，利用扩散模型直接生成答案。具体来说，DiffThinker 基于 Qwen-Image-Edit，配合 Flow Matching 训练直接用图像生产答案。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4f5d457b9c674fb888bf9a3ab8e832a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768393487&amp;x-signature=jtMLT1k%2BniBDQtRVjCg4mIKZHVk%3D" alt="图片" loading="lazy"/></p>
<h4 data-id="heading-2">02 DiffThinker 的四大核心特性</h4>
<h4 data-id="heading-3"/>
<p>作为全新的生成式推理范式，DiffThinker 展现出了传统 MLLM 难以企及的四大特性：</p>
<ul>
<li><strong>高效推理（Efficient Reasoning）</strong> 相比于 MLLM 动辄生成数千个 Token 的长思维链，DiffThinker 在训练和推理效率上均表现出色，且准确率更高。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f1ecd1a19924de7b0e311205c10d58f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768393487&amp;x-signature=G5G3KIO6QxWwj4GwhkWbGaMdkeo%3D" alt="图片" loading="lazy"/></p>
<ul>
<li>
<p><strong>可控推理（Controllable Reasoning）</strong> MLLM 的输出长度不可预测，常出现过长思维链甚至输出崩溃导致死循环。而 DiffThinker 通过固定步数的欧拉求解器，能够以确定的计算预算完成推理，不受任务逻辑复杂度的干扰。</p>
</li>
<li>
<p><strong>原生并行推理（Native Parallel Reasoning）</strong> 这是扩散模型独有的优势。在推理时，DiffThinker 能够在视觉空间中同时探索多条潜在路径，并随着去噪过程逐步收敛到最优解。这使得模型可以「边画边推理」，更直观。</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d3aa9dbcd05d4f14b2fc7bcc73babc55~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768393487&amp;x-signature=0nsJhTCpGXFe6nK0FEIZXvaokVc%3D" alt="图片" loading="lazy"/></p>
<ul>
<li><strong>协同推理（Collaborative Reasoning）</strong> DiffThinker 还可以与 MLLM 合作。它生成多个候选视觉解，再由 MLLM 进行逻辑验证。实验显示，这种「DiffThinker 生成 + MLLM 验证」的组合，性能实现「1+1&gt;2」，超越了任何单一模型。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ce9a52c2d3c4ea7b09efae18c518f02~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768393487&amp;x-signature=YeU5mc7V6efM4ebWqzV7VuKTbLA%3D" alt="图片" loading="lazy"/></p>
<h4 data-id="heading-4">03 实验结果：碾压级的性能</h4>
<h4 data-id="heading-5"/>
<p>研究团队在四个领域的七大任务上进行了系统评测，包括：</p>
<ul>
<li>
<p><strong>序列规划</strong>：VSP，VSP-Super，Maze（迷宫）</p>
</li>
<li>
<p><strong>组合优化</strong>：TSP（旅行商问题）</p>
</li>
<li>
<p><strong>约束满足</strong>：Sudoku（数独）</p>
</li>
<li>
<p><strong>空间配置</strong>：Jigsaw（拼图），VisPuzzle</p>
</li>
</ul>
<p>主要结果如下： </p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4aa35037206f46adbcbfc9538e7d7ef2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768393487&amp;x-signature=P14puYPy5f%2FAr%2Bh%2F%2Bm5ZKIVG4Hc%3D" alt="图片" loading="lazy"/></p>
<p>DiffThinker 在所有任务上的平均得分高达 87.4，而 GPT-5 仅为 21.1，Gemini-3-Flash 为 41.3。同数据训练的 Qwen3-VL-32B 也只有 62.9。</p>
<h4 data-id="heading-6">04 视频生成 vs 图像生成</h4>
<h4 data-id="heading-7"/>
<p>既然是视觉推理，用视频模型（Video Generation）会不会更好？</p>
<p>团队基于 Wan2.2-TI2V-5B 开发了 DiffThinker-Video 版本。结果发现，虽然视频能展示动态过程，但在推理准确率上反而不如图像生成模型，且推理时间增加了近一倍（1.1s vs 2.0s）。这表明，在当前的算力与模型架构下，「以图思考」仍是比「以视频思考」更高效的路径。</p>
<h4 data-id="heading-8">05 结语</h4>
<h4 data-id="heading-9"/>
<p>DiffThinker 的出现，标志着 <strong>生成式多模态推理（Generative Multimodal Reasoning）</strong>  时代的开启。它证明了扩散模型不仅能画画，还能进行严密的逻辑推理。</p>
<p>对于长程、视觉中心的复杂任务，将推理过程从「文本流」转变为「视觉流」，或许正是通往下一代通用人工智能的关键一步。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[日志输出优化实战：从“能用”到“好用”的全攻略]]></title>    <link>https://juejin.cn/post/7591806035758923818</link>    <guid>https://juejin.cn/post/7591806035758923818</guid>    <pubDate>2026-01-06T07:59:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591806035758923818" data-draft-id="7591806035758907434" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="日志输出优化实战：从“能用”到“好用”的全攻略"/> <meta itemprop="keywords" content="后端,分布式"/> <meta itemprop="datePublished" content="2026-01-06T07:59:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="回家路上绕了弯"/> <meta itemprop="url" content="https://juejin.cn/user/536217404587134"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            日志输出优化实战：从“能用”到“好用”的全攻略
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/536217404587134/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    回家路上绕了弯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T07:59:54.000Z" title="Tue Jan 06 2026 07:59:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    21
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">日志输出优化实战：从“能用”到“好用”的全攻略</h2>
<p>在日常开发中，日志是开发者的“眼睛”——排查问题、定位故障、监控系统状态，都离不开日志。但实际项目里，很多日志输出却处于“能用但不好用”的状态：要么级别混乱（ debug 日志充斥生产环境），要么内容残缺（缺少关键上下文），要么格式杂乱（难以解析），甚至因日志输出不当导致系统性能下降。今天，我们就从“为什么要优化日志”“优化什么”“怎么优化”三个维度，全面掌握日志输出的优化技巧，让日志真正成为系统运维的得力助手。</p>
<h3 data-id="heading-1">一、先搞懂：为什么要优化日志输出？</h3>
<p>很多开发者觉得“日志只要能打出来就行”，但在生产环境中，劣质日志的代价远超想象：</p>
<ul>
<li><strong>排查问题效率低</strong>：日志缺少请求ID、用户ID等上下文，面对海量日志无法快速定位某一次请求的完整链路；级别混乱导致关键错误日志被淹没在 debug 日志中；</li>
<li><strong>系统性能损耗大</strong>：无节制输出大量日志（尤其是 debug 级），会占用大量磁盘IO和网络带宽；同步日志写入在高并发场景下，还会拖慢接口响应速度；</li>
<li><strong>安全风险高</strong>：日志中明文输出用户密码、手机号、银行卡号等敏感信息，违反数据安全规范，可能引发合规风险；</li>
<li><strong>日志解析困难</strong>：非结构化日志（如自由文本）无法被ELK等日志分析工具高效解析，无法实现自动化监控告警，只能靠人工检索，效率极低。</li>
</ul>
<p>而优化后的日志，能实现“快速定位问题、低性能损耗、安全合规、可自动化分析”的目标，这也是分布式系统运维的基础要求。</p>
<h3 data-id="heading-2">二、日志输出优化的核心方向：6个“必须搞定”的关键点</h3>
<p>日志优化不是“炫技”，而是围绕“实用、高效、安全”展开的系统性优化。核心聚焦以下6个关键点，覆盖从输出规范到性能、安全的全维度：</p>
<h4 data-id="heading-3">1. 规范日志级别：不滥用、不混淆</h4>
<p>日志级别是日志的“优先级标签”，不同级别对应不同的使用场景，滥用级别会直接导致日志失效。主流日志框架（SLF4J+Logback/Log4j2）的级别从高到低分为：<code>ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE</code>，每个级别都有明确的使用边界：</p>
<ul>
<li><strong>ERROR</strong>：系统核心流程异常，必须人工介入处理。例如：数据库连接失败、第三方服务调用超时（无法重试）、核心业务逻辑异常（如订单创建失败）； 注意：只记录“异常事实”，不记录“预期内的失败”（如用户输入参数错误），且必须附带异常堆栈信息；</li>
<li><strong>WARN</strong>：系统出现非核心流程异常，但不影响主流程运行，需关注后续趋势。例如：缓存击穿、非核心接口调用超时（已重试成功）、配置项缺失（使用默认值）；</li>
<li><strong>INFO</strong>：系统核心流程的关键节点，用于追踪业务链路。例如：用户登录成功、订单支付完成、服务启动成功； 注意：INFO级别日志应“少而精”，避免每一步操作都打INFO，否则会导致日志冗余；</li>
<li><strong>DEBUG</strong>：开发/测试环境用于定位问题的详细信息，生产环境必须关闭。例如：方法入参出参、循环内的中间结果、第三方接口的详细响应；</li>
<li><strong>TRACE</strong>：比DEBUG更细致的调试信息（如框架内部调用细节），一般仅在框架调试时使用，业务代码尽量不使用。</li>
</ul>
<p>反例与正例对比：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 反例1：用ERROR记录预期内的失败（用户输入错误）</span>
if (StringUtils.isEmpty(userId)) {
    log<span class="hljs-selector-class">.error</span>("用户ID为空，无法查询订单"); <span class="hljs-comment">// 错误：用户输入错误属于预期内，应使用WARN</span>
    return Result<span class="hljs-selector-class">.fail</span>("用户ID不能为空");
}

<span class="hljs-comment">// 反例2：用INFO记录调试信息</span>
log<span class="hljs-selector-class">.info</span>("查询订单入参：orderNo={}", orderNo); <span class="hljs-comment">// 错误：入参记录属于调试信息，应使用DEBUG</span>
<span class="hljs-attribute">Order</span> <span class="hljs-attribute">order</span> = orderService<span class="hljs-selector-class">.getByOrderNo</span>(orderNo);

<span class="hljs-comment">// 正例</span>
if (StringUtils.isEmpty(userId)) {
    log<span class="hljs-selector-class">.warn</span>("用户ID为空，拒绝查询订单，请求参数：{}", requestParams); <span class="hljs-comment">// WARN记录预期内异常，附带参数</span>
    return Result<span class="hljs-selector-class">.fail</span>("用户ID不能为空");
}

try {
    <span class="hljs-attribute">Order</span> <span class="hljs-attribute">order</span> = orderService<span class="hljs-selector-class">.getByOrderNo</span>(orderNo);
    log<span class="hljs-selector-class">.info</span>("订单查询成功，orderNo={}, userId={}", orderNo, userId); <span class="hljs-comment">// INFO记录核心流程节点</span>
} catch (Exception e) {
    log<span class="hljs-selector-class">.error</span>("订单查询失败，orderNo={}, userId={}", orderNo, userId, e); <span class="hljs-comment">// ERROR记录异常，附带堆栈</span>
    return Result<span class="hljs-selector-class">.fail</span>("查询失败");
}
</code></pre>
<h4 data-id="heading-4">2. 结构化日志：让日志“可解析、可检索”</h4>
<p>传统的“文本日志”（如 <code>2024-05-20 10:30:00.123 INFO [main] c.d.OrderController - 订单创建成功</code>）虽然人类可读，但机器难以解析，无法快速提取关键信息（如订单号、用户ID）。而<strong>结构化日志</strong>（如JSON格式）能将日志字段标准化，完美适配ELK（Elasticsearch+Logstash+Kibana）等日志分析工具，实现快速检索、过滤和可视化。</p>
<p>Spring Boot默认使用SLF4J+Logback，实现JSON结构化日志只需简单配置：</p>
<h5 data-id="heading-5">（1）引入依赖（若使用Logback）</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 日志JSON格式化依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.logstash.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h5 data-id="heading-6">（2）配置logback-spring.xml</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 上下文名称：区分不同服务 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>order-service<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 定义日志输出格式：JSON格式 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CONSOLE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"net.logstash.logback.encoder.LogstashEncoder"</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- 固定字段：服务名、日志级别、时间戳等 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">includeMdcKeyName</span>&gt;</span>requestId<span class="hljs-tag">&lt;/<span class="hljs-name">includeMdcKeyName</span>&gt;</span> <span class="hljs-comment">&lt;!-- 包含请求ID（链路追踪） --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">includeMdcKeyName</span>&gt;</span>userId<span class="hljs-tag">&lt;/<span class="hljs-name">includeMdcKeyName</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 包含用户ID --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">customFields</span>&gt;</span>"service":"order-service","env":"prod"<span class="hljs-tag">&lt;/<span class="hljs-name">customFields</span>&gt;</span> <span class="hljs-comment">&lt;!-- 自定义固定字段 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">fieldNames</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">timestamp</span>&gt;</span>timestamp<span class="hljs-tag">&lt;/<span class="hljs-name">timestamp</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>level<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>message<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">logger</span>&gt;</span>logger<span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">thread</span>&gt;</span>thread<span class="hljs-tag">&lt;/<span class="hljs-name">thread</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">stack_trace</span>&gt;</span>stackTrace<span class="hljs-tag">&lt;/<span class="hljs-name">stack_trace</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">fieldNames</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 根日志级别：生产环境设为INFO --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"INFO"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 自定义包日志级别：如mapper层设为WARN，减少冗余 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.demo.mapper"</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"WARN"</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">"false"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"CONSOLE"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
</code></pre>
<h5 data-id="heading-7">（3）输出效果（JSON格式）</h5>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"service"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"order-service"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"env"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"prod"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"requestId"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"req-20240520103000123"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"userId"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1001"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"timestamp"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2024-05-20T10:30:00.123+08:00"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"level"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"INFO"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"message"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"订单创建成功，orderNo=ORDER20240520001"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"logger"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"com.demo.controller.OrderController"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"thread"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"http-nio-8080-exec-2"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>优势：可通过Kibana快速检索“requestId=req-20240520103000123”的所有日志，还原完整请求链路；也可按“userId”“orderNo”等字段过滤，定位特定用户的操作日志。</p>
<h4 data-id="heading-8">3. 日志内容要素：让每一条日志都“有价值”</h4>
<p>一条有价值的日志，必须包含“谁（用户/请求）在什么时候做了什么，结果如何，关键参数是什么”。核心要素应包括：</p>
<ul>
<li><strong>链路标识</strong>：requestId（请求ID），用于串联一次请求的全链路日志（分布式系统必备）；</li>
<li><strong>主体标识</strong>：userId（用户ID）、tenantId（租户ID），用于定位特定用户/租户的操作；</li>
<li><strong>业务参数</strong>：核心业务ID（如orderNo、productId），便于定位具体业务场景；</li>
<li><strong>操作描述</strong>：清晰说明当前操作（如“订单创建”“支付回调处理”）；</li>
<li><strong>结果状态</strong>：成功/失败，失败时需包含异常信息（堆栈或错误码）。</li>
</ul>
<p>实战技巧：使用MDC（Mapped Diagnostic Context）传递链路/主体标识，避免在每个日志语句中重复拼接参数。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.slf4j.MDC;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;
<span class="hljs-keyword">import</span> java.util.UUID;

<span class="hljs-comment">// 自定义拦截器：生成requestId并放入MDC</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 生成唯一requestId</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">requestId</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().replace(<span class="hljs-string">"-"</span>, <span class="hljs-string">""</span>);
        MDC.put(<span class="hljs-string">"requestId"</span>, requestId);
        <span class="hljs-comment">// 从请求头获取userId（如登录后放入）</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">"userId"</span>);
        <span class="hljs-keyword">if</span> (userId != <span class="hljs-literal">null</span>) {
            MDC.put(<span class="hljs-string">"userId"</span>, userId);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 清除MDC，避免线程复用导致的参数污染</span>
        MDC.clear();
    }
}

<span class="hljs-comment">// 配置拦截器</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> {
        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogInterceptor</span>()).addPathPatterns(<span class="hljs-string">"/**"</span>);
    }
}

<span class="hljs-comment">// 业务代码中使用（无需拼接requestId和userId）</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(OrderController.class);

    <span class="hljs-meta">@PostMapping("/order/create")</span>
    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrderCreateDTO dto)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">String</span> <span class="hljs-variable">orderNo</span> <span class="hljs-operator">=</span> orderService.create(dto);
            <span class="hljs-comment">// 日志自动包含MDC中的requestId和userId</span>
            log.info(<span class="hljs-string">"订单创建成功，orderNo={}, 商品ID列表={}"</span>, orderNo, dto.getProductIds());
            <span class="hljs-keyword">return</span> Result.success(orderNo);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(<span class="hljs-string">"订单创建失败，请求参数={}"</span>, dto, e);
            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">"创建失败"</span>);
        }
    }
}
</code></pre>
<h4 data-id="heading-9">4. 性能优化：减少日志对系统的损耗</h4>
<p>日志输出本质是IO操作，高并发场景下，不恰当的日志输出会严重影响系统性能。核心优化手段包括：</p>
<h5 data-id="heading-10">（1）避免无效日志拼接</h5>
<p>使用SLF4J的占位符 <code>{} </code>而非字符串拼接（<code>+</code>），避免在日志级别不满足时产生无效的字符串拼接开销。</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-comment">// 反例：即使日志级别是WARN，也会执行字符串拼接，产生性能损耗</span>
<span class="hljs-built_in">log</span>.debug(<span class="hljs-string">"订单查询，orderNo="</span> + orderNo + <span class="hljs-string">", userId="</span> + userId);

<span class="hljs-comment">// 正例：使用占位符，日志级别不满足时不会执行参数拼接</span>
<span class="hljs-built_in">log</span>.debug(<span class="hljs-string">"订单查询，orderNo={}, userId={}"</span>, orderNo, userId);
</code></pre>
<h5 data-id="heading-11">（2）高并发场景使用异步日志</h5>
<p>同步日志会阻塞业务线程，直到日志写入完成；异步日志则通过独立线程写入日志，不阻塞业务线程，适合高并发场景。Logback配置异步日志示例：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 异步日志配置 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ASYNC_FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">discardingThreshold</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">discardingThreshold</span>&gt;</span> <span class="hljs-comment">&lt;!-- 不丢弃日志（关键业务建议） --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">queueSize</span>&gt;</span>1024<span class="hljs-tag">&lt;/<span class="hljs-name">queueSize</span>&gt;</span> <span class="hljs-comment">&lt;!-- 队列大小：根据并发量调整 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"FILE"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 关联文件输出appender --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>
</code></pre>
<h5 data-id="heading-12">（3）控制日志输出量</h5>
<ul>
<li>生产环境关闭DEBUG/TRACE级别日志；</li>
<li>避免在循环内输出日志（如遍历1000条数据时，每条都打日志）；</li>
<li>对高频接口的日志进行抽样输出（如每100次请求输出1次日志）。</li>
</ul>
<h5 data-id="heading-13">（4）合理设置日志滚动策略</h5>
<p>避免单个日志文件过大，导致检索缓慢。通过日志滚动策略按时间/大小分割日志，例如：按天滚动，每天一个日志文件；单个文件超过100MB时强制滚动。Logback配置示例：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FILE"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>logs/order-service.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>logs/order-service.%d{yyyy-MM-dd}.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span> <span class="hljs-comment">&lt;!-- 保留30天日志 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">totalSizeCap</span>&gt;</span>10GB<span class="hljs-tag">&lt;/<span class="hljs-name">totalSizeCap</span>&gt;</span> <span class="hljs-comment">&lt;!-- 日志总大小限制 --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span> <span class="hljs-comment">&lt;!-- 单个文件最大100MB --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="hljs-symbol">&amp;lt;</span>/pattern<span class="hljs-symbol">&amp;gt;</span>
    <span class="hljs-symbol">&amp;lt;</span>/encoder<span class="hljs-symbol">&amp;gt;</span>
<span class="hljs-symbol">&amp;lt;</span>/appender<span class="hljs-symbol">&amp;gt;</span>
</code></pre>
<h4 data-id="heading-14">5. 安全脱敏：保护敏感信息不泄露</h4>
<p>日志中若包含用户密码、手机号、身份证号、银行卡号等敏感信息，会违反《个人信息保护法》等合规要求。核心脱敏策略：“能不输出就不输出，必须输出则脱敏”。</p>
<h5 data-id="heading-15">（1）常见脱敏场景与方法</h5>
<ul>
<li><strong>接口入参/出参脱敏</strong>：对包含敏感信息的DTO字段进行脱敏，可通过自定义JSON序列化器实现；</li>
<li><strong>日志语句脱敏</strong>：对关键敏感参数手动脱敏（如手机号保留前3后4位）；</li>
<li><strong>全局拦截脱敏</strong>：通过Logback的自定义转换器，对日志中的敏感信息自动拦截脱敏。</li>
</ul>
<h5 data-id="heading-16">（2）实战：自定义JSON序列化器脱敏</h5>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-keyword">import</span> com.fasterxml.jackson.core.<span class="hljs-type">JsonGenerator</span>;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.<span class="hljs-type">JsonSerializer</span>;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.<span class="hljs-type">SerializerProvider</span>;
<span class="hljs-keyword">import</span> java.io.<span class="hljs-type">IOException</span>;

<span class="hljs-comment">// 手机号脱敏序列化器</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileDesensitizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonSerializer&lt;String&gt;</span> </span>{
    <span class="hljs-meta">@Override</span>
    public void serialize(<span class="hljs-type">String</span> mobile, <span class="hljs-type">JsonGenerator</span> gen, <span class="hljs-type">SerializerProvider</span> serializers) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> {
        <span class="hljs-keyword">if</span> (mobile != <span class="hljs-literal">null</span> &amp;&amp; mobile.length() == <span class="hljs-number">11</span>) {
            gen.writeString(mobile.replaceAll(<span class="hljs-string">"(\d{3})\d{4}(\d{4})"</span>, <span class="hljs-string">"$1****$2"</span>));
        } <span class="hljs-keyword">else</span> {
            gen.writeString(mobile);
        }
    }
}

<span class="hljs-comment">// 在DTO中使用</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDTO</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> userId;
    
    <span class="hljs-meta">@JsonSerialize</span>(<span class="hljs-keyword">using</span> = <span class="hljs-type">MobileDesensitizer</span>.<span class="hljs-keyword">class</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> mobile; <span class="hljs-comment">// 序列化时自动脱敏</span>
    
    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> username;
    <span class="hljs-comment">// 省略getter/setter</span>
}

<span class="hljs-comment">// 日志输出效果：mobile=138****1234</span>
log.info(<span class="hljs-string">"用户登录成功，用户信息={}"</span>, userDTO);
</code></pre>
<h5 data-id="heading-17">（3）实战：Logback全局脱敏转换器</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> ch.qos.logback.classic.pattern.ClassicConverter;
<span class="hljs-keyword">import</span> ch.qos.logback.classic.spi.ILoggingEvent;
<span class="hljs-keyword">import</span> java.util.regex.Pattern;

<span class="hljs-comment">// 日志全局脱敏转换器：匹配手机号、身份证号</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogDesensitizerConverter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassicConverter</span> {
    <span class="hljs-comment">// 手机号正则：11位数字</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">MOBILE_PATTERN</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">"1[3-9]\d{9}"</span>);
    <span class="hljs-comment">// 身份证号正则：18位（含X）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">ID_CARD_PATTERN</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">"\d{17}[0-9Xx]"</span>);

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(ILoggingEvent event)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> event.getMessage();
        <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
        }
        <span class="hljs-comment">// 手机号脱敏</span>
        message = MOBILE_PATTERN.matcher(message).replaceAll(<span class="hljs-string">"****"</span>);
        <span class="hljs-comment">// 身份证号脱敏（保留前6后4）</span>
        message = ID_CARD_PATTERN.matcher(message).replaceAll(<span class="hljs-string">"$1****$2"</span>);
        <span class="hljs-keyword">return</span> message;
    }
}

<span class="hljs-comment">// 在logback-spring.xml中配置</span>
&lt;conversionRule conversionWord=<span class="hljs-string">"msg"</span> converterClass=<span class="hljs-string">"com.demo.log.LogDesensitizerConverter"</span> /&gt;
</code></pre>
<h4 data-id="heading-18">6. 日志监控告警：让日志“主动说话”</h4>
<p>优化后的日志不仅要“可检索”，还要能“主动告警”——当系统出现异常时，通过日志监控工具及时触发告警，避免故障扩大。核心实现方案：ELK栈 + 告警插件（如Elastic Alert）。</p>
<h5 data-id="heading-19">（1）ELK栈日志流转流程</h5>
<ol>
<li>Logback将结构化日志输出到文件；</li>
<li>Logstash读取日志文件，过滤、解析日志（如提取字段）；</li>
<li>Logstash将处理后的日志写入Elasticsearch；</li>
<li>Kibana对接Elasticsearch，实现日志检索、可视化；</li>
<li>配置告警规则（如ERROR日志5分钟内超过10条、出现“数据库连接失败”日志），触发钉钉/短信/邮件告警。</li>
</ol>
<h5 data-id="heading-20">（2）关键告警规则建议</h5>
<ul>
<li>ERROR级别日志数量突增（如5分钟内超过阈值）；</li>
<li>出现特定错误日志（如“数据库连接超时”“NPE”“服务熔断”）；</li>
<li>核心业务日志缺失（如10分钟内无“订单支付成功”日志，可能支付服务异常）；</li>
<li>接口响应时间异常（通过日志中的耗时字段监控，如耗时超过5秒）。</li>
</ul>
<h3 data-id="heading-21">三、日志输出优化的“避坑指南”</h3>
<p>在日志优化过程中，容易陷入一些误区，以下是常见坑点及规避方法：</p>
<ul>
<li><strong>坑点1：日志级别“一刀切”</strong> ：所有包都使用相同的日志级别（如根日志设为DEBUG），导致生产环境日志爆炸。 规避：根日志设为INFO，对特定包（如mapper、第三方框架）单独设为WARN；</li>
<li><strong>坑点2：日志内容“越详细越好”</strong> ：输出完整的请求体、响应体，包含大量冗余信息。 规避：只输出核心业务参数，敏感信息脱敏，避免输出大文本（如JSON数组、文件内容）；</li>
<li><strong>坑点3：异步日志“滥用”</strong> ：所有日志都用异步输出，导致日志丢失（队列满时可能丢弃日志）。 规避：关键业务日志（如支付、订单）使用同步日志或配置不丢弃的异步日志；非关键日志可使用异步；</li>
<li><strong>坑点4：忽略日志清理</strong>：日志无保留期限，导致磁盘空间被占满。 规避：配置日志保留期限（如30天）和总大小限制，定期清理过期日志；</li>
<li><strong>坑点5：MDC未清理</strong>：线程池复用导致MDC中的参数污染（如前一个请求的requestId被后续请求复用）。 规避：在请求结束后（拦截器afterCompletion）清除MDC；线程池使用时，手动传递MDC参数。</li>
</ul>
<h3 data-id="heading-22">四、总结：日志优化的核心原则</h3>
<p>日志输出优化的核心不是“追求复杂的配置”，而是围绕“<strong>规范、实用、安全、高效</strong>”四个关键词：</p>
<ul>
<li>规范：按场景使用日志级别，统一日志格式；</li>
<li>实用：日志内容包含关键要素，能快速定位问题；</li>
<li>安全：敏感信息脱敏，符合合规要求；</li>
<li>高效：减少日志对系统性能的损耗，实现自动化监控告警。</li>
</ul>
<p>其实日志优化没有“银弹”，需要结合业务场景不断调整。建议从“规范日志级别”“添加链路标识”“结构化输出”这三个基础点入手，逐步落地性能优化和安全脱敏，让日志真正成为系统稳定性的“守护者”。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[TRAE 国际版 SOLO 模式下的模型选择指南]]></title>    <link>https://juejin.cn/post/7592068193419542537</link>    <guid>https://juejin.cn/post/7592068193419542537</guid>    <pubDate>2026-01-06T09:45:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592068193419542537" data-draft-id="7591986565855248430" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="TRAE 国际版 SOLO 模式下的模型选择指南"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2026-01-06T09:45:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="TRAE_ai"/> <meta itemprop="url" content="https://juejin.cn/user/3048259110571032"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            TRAE 国际版 SOLO 模式下的模型选择指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3048259110571032/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    TRAE_ai
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T09:45:47.000Z" title="Tue Jan 06 2026 09:45:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae941bc5b84447eb9b8c3fbeeb10fded~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768297546&amp;x-signature=NDECseIzJLciZpHyxLk6xOkKvno%3D" alt="" loading="lazy"/></p>
<p>TRAE 国际版 SOLO 模式已内置 3 种模型——<strong>Gemini-3-Pro-Preview</strong>、<strong>GPT-5-medium</strong> 和 <strong>Kimi-K2-0905</strong>。不同模型在开发过程中的不同环节各有所长，选择模型的核心并非 “哪款模型最优”，而是<strong>哪款模型最适配你要交付的任务。</strong></p>
<p>以下是我们为你提供的一种模型选择思路：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4479ede51bd442ffb04ce9d9b36368b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768297546&amp;x-signature=zI%2BUwxucEy4TOIpzgO3%2B9TP8fdg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0"><strong>Gemini-3-Pro-Preview：适用于智能体驱动、长周期、多模态任务</strong></h2>
<p>当任务场景宽泛、各环节相互关联，且需要在上下文里统筹多个动态模块时，Gemini-3-Pro-Preview 的优势最为突出：</p>
<ul>
<li>
<p>擅长智能体驱动的编码流程 —— 相比单次指令调用，通过命令行界面 / 工具调用流程运行时表现更佳</p>
</li>
<li>
<p>具备出色的多模态理解能力（涵盖文本、代码、设计规范、UI 设计），非常适合全栈开发工作</p>
</li>
<li>
<p>长周期任务表现稳定可靠 —— 可胜任大型代码库的迁移、架构调整以及全局调试工作</p>
</li>
</ul>
<h3 data-id="heading-1"><strong>国际版 SOLO + Gemini-3-Pro-Preview 适用场景示例：</strong></h3>
<p>当任务属于 “牵一发而动全身” 的类型时，Gemini-3-Pro-Preview 通常是优选方案。</p>
<ul>
<li>
<p>Gemini-3-Pro-Preview 智能体可充当 UI 工程师，基于多模态输入的设计规范生成界面并持续迭代优化</p>
</li>
<li>
<p>智能体可并行处理后端逻辑、应用程序接口（API）或数据模型的开发工作</p>
</li>
<li>
<p>TRAE 国际版 SOLO 模式负责统筹协调各智能体，Gemini-3-Pro-Preview 则保障各层级的一致性</p>
</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76b7ffeb89ee46afa11120face703d49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768297546&amp;x-signature=A%2BclyRnjo1eIl9i4PYNz8ms3k54%3D" alt="gemini-3-use-case (1).gif" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7648d7d46b0c413a9314c5ddbc6a4e4b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768297546&amp;x-signature=3KeZkFO2YrC4pDiOr1ytVPtTudk%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2"><strong>GPT-5-medium：适用于结构化迭代与生产级别的代码修改</strong></h2>
<p>GPT-5-medium 就像一位经验丰富的资深工程师，你可以放心地将需要严谨思考、周密规划的修改任务交付给它：</p>
<ul>
<li>
<p>擅长重构、调试循环、测试框架搭建等迭代式编码流程</p>
</li>
<li>
<p>兼顾强大的通用推理能力与编码能力，给出的方案更适用于生产环境</p>
</li>
<li>
<p>拥有超大上下文窗口（最高 272k），能够应对复杂的实际项目需求</p>
</li>
<li>
<p>配套工具生态成熟，在各类编辑器、应用程序接口（API）和插件中表现稳定</p>
</li>
</ul>
<h3 data-id="heading-3"><strong>国际版 SOLO + GPT-5-medium 适用场景示例：</strong></h3>
<p><strong>1. 系统重构</strong></p>
<ul>
<li>
<p>将大规模重构任务拆解为清晰的步骤，逐步推进</p>
</li>
<li>
<p>确保重构过程中各模块的核心约束条件始终有效</p>
</li>
</ul>
<p><strong>2. 遗留代码调试</strong></p>
<ul>
<li>
<p>跨文件追踪业务逻辑，定位问题根源</p>
</li>
<li>
<p>遵循 “先写测试，再改代码” 的流程，降低修改风险</p>
</li>
</ul>
<p>GPT-5-medium 与 TRAE 国际版 SOLO 模式的 <strong>Plan</strong> 尤为契合，可以生成清晰的方案、有条理地执行任务并生成高度准确的结果。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fbeccdfb227b4945ae184ebeb1b70276~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768297546&amp;x-signature=gtHBAic6mnjwMyAwR3nag1OpoUo%3D" alt="gpt-5-use-case (1).gif" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/26ea123f7c2c409d96267dfa8bc5dcf2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768297546&amp;x-signature=vov8JF3%2BeqGXYoaq3IKP6lmA93Q%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4"><strong>Kimi-K2-0905：适用于执行高效自动化、高性价比的任务</strong></h2>
<p>Kimi-K2-0905 决策果断、响应迅速，能够高效推进任务，是无需人工干预的自动化任务的理想选择：它擅长多步骤逻辑处理与自主化工作流，尤其适用于研发调研或自动化脚本开发任务；单 token 使用成本远低于多数商用闭源模型，性价比突出，在日常开发工作中运行速度极快，延迟低，能够实现快速迭代。</p>
<h3 data-id="heading-5"><strong>国际版 SOLO + Kimi-K2-0905 适用场景示例：</strong></h3>
<p><strong>1. 处理重复性或机械性开发工作：</strong> 清理冗余代码、生成通用模板代码、转换数据格式、统一重构代码语言风格</p>
<p><strong>2. 作为子智能体执行辅助任务：</strong> Kimi-K2-0905 可以自主运行处理后台辅助任务，你就能专注于更顶层的决策工作</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/82f5c208a50e404bbffc204aeb1ed935~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgVFJBRV9haQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768297546&amp;x-signature=05fGP964ypi7GZlSWIBAMTl5S3A%3D" alt="kimi-k2-use-case (1).gif" loading="lazy"/></p>
<p><strong>SOLO 模式模型选型核心思路总结</strong></p>
<p>在 TRAE 国际版 SOLO 模式下，如何选择最合适的模型？你可以像带领一支真实的工程师团队一样，根据任务特点灵活调度、合理分工，让每个模型发挥其最大优势。</p>
<ul>
<li>
<p><strong>Gemini-3-Pro-Preview：</strong> 擅长广度覆盖、上下文统筹、多模态融合与系统化思考。</p>
</li>
<li>
<p><strong>GPT-5-medium：</strong> 以稳定可靠见长，善于结构化推进和生产级迭代优化。</p>
</li>
<li>
<p><strong>Kimi-K2-0905：</strong> 追求极速执行和自主运行，具备高性价比，专注落地执行。</p>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[应对 Nginx Ingress 退役，是时候理清这些易混淆的概念了]]></title>    <link>https://juejin.cn/post/7591767753850650666</link>    <guid>https://juejin.cn/post/7591767753850650666</guid>    <pubDate>2026-01-06T03:45:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591767753850650666" data-draft-id="7591672090790248467" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="应对 Nginx Ingress 退役，是时候理清这些易混淆的概念了"/> <meta itemprop="keywords" content="云原生"/> <meta itemprop="datePublished" content="2026-01-06T03:45:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            应对 Nginx Ingress 退役，是时候理清这些易混淆的概念了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:45:36.000Z" title="Tue Jan 06 2026 03:45:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：望宸</p>
<p>本文希望提供一种更简单的方式，来理解这些容易混淆的技术概念：Nginx、Ingress、Ingress Controller、Ingress API、Nginx Ingress、Higress、Gateway API。</p>
<h2 data-id="heading-0">Nginx 和 Kubernetes</h2>
<p>我们先按和 Kubernetes 是否有关，分为两类：</p>
<p>Nginx 是在没有 Kubernetes 的年代，流量入口上的事实标准，是独立运行在任何 Linux/Windows 服务器上的 Web 服务器。提供以下主要功能：</p>
<ul>
<li>接收请求；</li>
<li>转发请求；</li>
<li>负载均衡；</li>
<li>简单的流量治理，例如限流、缓存、重写。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5dd7062a881f4a6d9cc2ada7cc8512a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=uzoRWXoxMs7FDMj2Vy22eEFCS9I%3D" alt="图片" loading="lazy"/></p>
<p>而 Ingress API、Ingress Controller、Nginx Ingress、Higress、Gateway API 都依赖 Kubernetes，Kubernetes 出现后，才有了这些概念。其中，Ingress API 是 Kubernetes 管理流量的规范，Ingress Controller 是规范的实现组件，Nginx Ingress 和 Higress 都是规范的完整实现和功能扩展，Gateway API 则是 Ingress API 的升级和下一代。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d12816faa7a4342b1ff8495770e6e81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=UbK6IYYkyOT4E0JO0hyRiUMuFa0%3D" alt="图片" loading="lazy"/></p>
<p>需要注意的是，Ingress 经常单独出现，需要基于语境来判断，有可能是指 Ingress API，也有可能是指 Ingress 资源，即用户编写的具体配置对象（YAML），遵循 Ingress API。</p>
<h2 data-id="heading-1">Ingress API 和 Ingress Controller</h2>
<p>Ingress API 和 Ingress Controller 分别是 Kubernetes 流量管理的规范和执行器。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/70e786088cf74b80ad3fe085eff71744~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=IUxS0SpEqn1id8D5XVsSuNDgL6M%3D" alt="图片" loading="lazy"/></p>
<p><strong>Ingress API</strong>：用声明式的方式，描述外部流量如何进入集群里的 Service，包括：</p>
<ul>
<li>如何通过域名访问服务；</li>
<li>如何根据 URL 路径路由到不同后端服务；</li>
<li>后端服务是谁；</li>
<li>是否启用 HTTPS 加密。</li>
</ul>
<p>形象地说，Ingress API 可以理解位 Kubernetes 中管理流量的说明书。</p>
<p><strong>Ingress Controller</strong>：是 Ingress API 的实现组件，即执行者，包括：</p>
<ul>
<li>监听 Ingress 资源变化；</li>
<li>将 Ingress 规则转换为实际的反向代理配置；</li>
<li>接收外部流量并按规则路由；</li>
<li>处理 TLS 终止（HTTPS 解密）；</li>
<li>提供健康检查、负载均衡、重试等流量治理能力。</li>
</ul>
<p>通过以上能力，Ingress Controller 就实现了 Kubernetes 入口流量的管理。</p>
<h2 data-id="heading-2">Nginx Ingress 和 Higress</h2>
<p>Nginx Ingress 和 Higress 都是 Ingress API 的完整实现和功能扩展。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cdf9b79f58a34f3c98776a7ff13cfc0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=r7HDDeYxrZL2F3%2FB47YddrB0Ibk%3D" alt="图片" loading="lazy"/></p>
<p>Nginx Ingress：用 Nginx 作为底层实现的 Ingress API，控制面和数据面耦合在同一个进程/容器中。优点是简单、易用、社区广泛。</p>
<p><strong>缺点是：</strong></p>
<ul>
<li>不是原生的 Ingress API，Ingress API 语义偏弱；</li>
<li>扩展靠 Annotation（工程噩梦）；</li>
<li>生成 nginx.conf + reload，动态配置能力弱（频繁 reload 影响性能）。</li>
</ul>
<p>适用于简单、稳定、小规模的场景。</p>
<p>Higress：数据面是基于 Enovy，控制面给基于 istio，是原生的 Ingress API。</p>
<p><strong>优点是：</strong></p>
<ul>
<li>控制面与数据面解耦，可独立扩缩容；</li>
<li>基于 xDS 协议，实现真正的动态配置（无 reload，零中断）；</li>
<li>原生支持插件扩展：Wasm、Lua、Go 插件由控制面统一管理并下发；</li>
<li><strong>兼容多协议 &amp; 多标准：同时支持 Ingress API 和 Gateway API。</strong></li>
</ul>
<p>缺点是，相比 Nginx 广泛的社区基础，Higress 为代表的原生 Ingress API，部署和维护存在学习成本。</p>
<p>适用于高性能、高扩展、企业级的场景。</p>
<h2 data-id="heading-3">Nginx Ingress 退役</h2>
<p>11月，Kubernetes SIG Network 和安全响应委员会宣布 Ingress NGINX 退役。（⚠️ NGINX 并未退役。）</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb08cd46ccda4305bddddd7ad9805fb4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=PFongHPha%2BYCvUwdh4n8D0w6o8s%3D" alt="图片" loading="lazy"/></p>
<p><strong>意味着：</strong></p>
<ul>
<li>Ingress NGINX 尽力维护服务至 2026 年 3 月；</li>
<li>不再发布任何新版本；</li>
<li>不再修复任何漏洞；</li>
<li>也不会更新任何可能发现的安全漏洞；</li>
<li>GitHub 代码库将设置为只读，仅供参考；</li>
<li>现有的 Ingress NGINX 部署将继续运行，安装文件也将继续可用。</li>
</ul>
<p>引发退役的根本原因：：</p>
<ul>
<li>多年来，该项目只有一两个人利用业余时间，在工作之余进行开发工作；</li>
<li>尝试和 Gateway API 社区合作开发一个替代控制器，但未能激发更多人参与 Ingress NGINX 的维护。</li>
</ul>
<h2 data-id="heading-4">Higress：Nginx Ingress 退役的替代优先方案</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a54f7fbf0fc4243a9779926978f1659~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=NKPqzNS5csEVsz%2BQSxagvB963no%3D" alt="图片" loading="lazy"/></p>
<ul>
<li>Kubernetes 官方推荐，即官方社区文档中进行了说明；</li>
<li>对 Nginx Ingress 的 Annotation 兼容度最高，支持 51 种，覆盖 90% 的用户场景，这意味着现有的 K8s Ingress YAML 文件无需大量修改即可完成迁移；</li>
<li>长期投入，并提供企业版服务，即阿里云 API 网关；</li>
<li>提供监听 K8s Ingress（Ingress 模式），适用于希望保持 K8s 原生工作流（如GitOps）的团队；和控制台配置 API（API 管理模式），适用于需要集中治理和精细化管理的场景。</li>
</ul>
<h2 data-id="heading-5">Gateway API 和 Ingress API</h2>
<p>Gateway API 是 Ingress API 规范的超集和下一代。他的出现，是为了解决 Ingress API 自身无法搞定的问题。其中，Higress 已经支持 Gateway API 标准，用户可从 Ingress API 平滑迁移至 Gateway API。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de4cb0684f4a4544b910ef82aef57fe3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275936&amp;x-signature=FhslJ6330cnp%2FjzVpgK4s7yRLKw%3D" alt="图片" loading="lazy"/></p>
<p>Ingress API 存在的问题，Gateway API 这样去解决：</p>
<p>职责不清，后果是 Ingress 是“一人写全”，没有权限边界。<strong>-&gt; Gateway API 通过角色分离解决，定义基础设施提供者、集群管理员、应用开发者。</strong></p>
<p>功能表达能力弱，依赖 Controller 特有扩展，后果是不标准、不同实现之间迁移成本高。<strong>-&gt; Gateway API 通过 Wasm、插件、服务网格集成解决扩展的标准化。</strong></p>
<p>仅支持 HTTP/HTTPS，无法处理 TCP/UDP/gRPC 等协议。<strong>-&gt; 云原生应用早已不只是 Web 服务，Gateway API 通过统一的 API，管理所有南北向流量。</strong></p>
<p>无法表达复杂路由逻辑，微服务治理需求远超 Ingress 能力。<strong>-&gt; Gateway API 支持 Wasm、插件、服务网格集成，通过标准化的高级路由解决。</strong></p>
<p>一个 Ingress Controller 全局共享，缺乏多租户隔离，多租户场景下存在安全和配置冲突风险。<strong>-&gt; Gateway API 提供了独立 Gateway 的实例。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI Agent 核心策略：如何判断 Agent 应该停止]]></title>    <link>https://juejin.cn/post/7592017365140308020</link>    <guid>https://juejin.cn/post/7592017365140308020</guid>    <pubDate>2026-01-06T00:32:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592017365140308020" data-draft-id="7591702898080759823" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI Agent 核心策略：如何判断 Agent 应该停止"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2026-01-06T00:32:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="潘锦"/> <meta itemprop="url" content="https://juejin.cn/user/730549110707431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI Agent 核心策略：如何判断 Agent 应该停止
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/730549110707431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    潘锦
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T00:32:34.000Z" title="Tue Jan 06 2026 00:32:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    16
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>简单来讲，AI Agent 实现的的大逻辑就是一个大的循环 + 获取上下文 + 不停的 LLM 调用 + 工具的调用。</p>
<p>那么一个关键问题就出现了：这个循环什么时候应该停止？如果处理不当，Agent 可能会陷入无限循环，浪费计算资源，或者过早停止而无法完成任务。本文将深入探讨 AI Agent 停止策略的核心设计思路。</p>
<h2 data-id="heading-0">常用停止策略</h2>
<p>AI Agent 停止策略无外乎以下几种情况：</p>
<ol>
<li>硬性限制</li>
</ol>
<p>最简单粗暴的方法：</p>
<ul>
<li>最大步数限制（比如最多循环 30 次）</li>
<li>执行时间限制（比如最多跑 5 分钟）</li>
<li>API 调用次数限制（比如最多调 100 次）</li>
<li>API 调用 Token 数限制</li>
</ul>
<p>这种方法简单有效，但用户体验很差。经常出现任务做到一半被强制停止的情况。</p>
<ol start="2">
<li>任务完成检测</li>
</ol>
<p>让 LLM 判断任务是否完成：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 每次循环后问 LLM</span>
<span class="hljs-attr">response</span> = llm.ask(<span class="hljs-string">"任务是否已经完成？"</span>)
if <span class="hljs-attr">response</span> == <span class="hljs-string">"是"</span>:
    stop()
</code></pre>
<ol start="3">
<li>显式停止信号</li>
</ol>
<p>给 Agent 一个专门的"停止"工具：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">tools</span> = [
    <span class="hljs-string">"search"</span>,
    <span class="hljs-string">"calculate"</span>, 
    <span class="hljs-string">"terminate"</span>  <span class="hljs-comment"># 专门用来停止</span>
]
</code></pre>
<p>当 Agent 调用 terminate 工具时就停止。这个方法不错，但需要在 prompt 里教会 Agent 什么时候该调用它。</p>
<ol start="4">
<li>循环检测</li>
</ol>
<p>检测 Agent 是否在做重复的事：</p>
<ul>
<li>连续多次调用同一个工具</li>
<li>动作序列出现循环模式（A→B→A→B...）</li>
<li>输出内容高度相似</li>
</ul>
<ol start="5">
<li>错误累积</li>
</ol>
<p>连续失败多次就放弃：</p>
<pre><code class="hljs language-css" lang="css">if consecutive_errors &gt; <span class="hljs-number">3</span>:
    <span class="hljs-built_in">stop</span>(<span class="hljs-string">"连续失败太多次"</span>)
</code></pre>
<ol start="6">
<li>用户中断</li>
</ol>
<p>让用户能随时喊停。</p>
<p>下面我们以 OpenManus 和 Gemini CLI 的源码来看一下他们是怎么做的。</p>
<h2 data-id="heading-1">OpenManus 的停止逻辑</h2>
<p>OpenManus 的停止机制设计得比较完整，它用了一个多层防护的思路。</p>
<h2 data-id="heading-2">核心：terminate 工具</h2>
<p>OpenManus 给每个 Agent 都配了一个 terminate 工具：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Terminate</span>(<span class="hljs-title class_ inherited__">BaseTool</span>):
    name: <span class="hljs-built_in">str</span> = <span class="hljs-string">"terminate"</span>
    description = <span class="hljs-string">"""当请求已满足或无法继续时终止交互。
    完成所有任务后，调用此工具结束工作。"""</span>
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, status: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"交互已完成，状态：<span class="hljs-subst">{status}</span>"</span>
        
以上为示例，原始代码：
<span class="hljs-keyword">from</span> app.tool.base <span class="hljs-keyword">import</span> BaseTool


_TERMINATE_DESCRIPTION = <span class="hljs-string">"""Terminate the interaction when the request is met OR if the assistant cannot proceed further with the task.
When you have finished all the tasks, call this tool to end the work."""</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Terminate</span>(<span class="hljs-title class_ inherited__">BaseTool</span>):
    name: <span class="hljs-built_in">str</span> = <span class="hljs-string">"terminate"</span>
    description: <span class="hljs-built_in">str</span> = _TERMINATE_DESCRIPTION
    parameters: <span class="hljs-built_in">dict</span> = {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"object"</span>,
        <span class="hljs-string">"properties"</span>: {
            <span class="hljs-string">"status"</span>: {
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,
                <span class="hljs-string">"description"</span>: <span class="hljs-string">"The finish status of the interaction."</span>,
                <span class="hljs-string">"enum"</span>: [<span class="hljs-string">"success"</span>, <span class="hljs-string">"failure"</span>],
            }
        },
        <span class="hljs-string">"required"</span>: [<span class="hljs-string">"status"</span>],
    }

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, status: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">"""Finish the current execution"""</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"The interaction has been completed with status: <span class="hljs-subst">{status}</span>"</span>
</code></pre>
<p>OpenManus 使用的是方案 3，把「何时停止」的决策权交给了 LLM。prompt 里会明确告诉 Agent：任务完成了就调用 terminate。</p>
<h2 data-id="heading-3">状态机管理</h2>
<p>OpenManus 用状态机来管理 Agent 的生命周期：</p>
<pre><code class="hljs language-ini" lang="ini">class AgentState(Enum):
    <span class="hljs-attr">IDLE</span> = <span class="hljs-string">"idle"</span>
    <span class="hljs-attr">RUNNING</span> = <span class="hljs-string">"running"</span>  
    <span class="hljs-attr">FINISHED</span> = <span class="hljs-string">"finished"</span>
    <span class="hljs-attr">ERROR</span> = <span class="hljs-string">"error"</span>
</code></pre>
<p>当检测到特殊工具（如 terminate）被调用时，会触发状态转换：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_handle_special_tool</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span>, result: <span class="hljs-type">Any</span></span>):
    <span class="hljs-keyword">if</span> name.lower() == <span class="hljs-string">"terminate"</span>:
        self.state = AgentState.FINISHED
        logger.info(<span class="hljs-string">"🏁 任务完成！"</span>)
</code></pre>
<h2 data-id="heading-4">步数限制</h2>
<p>不同类型的 Agent 有不同的步数上限：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ToolCallAgent: 30 步</span>
<span class="hljs-comment"># SWEAgent: 20 步</span>
<span class="hljs-comment"># PlanningFlow: 可配置</span>

<span class="hljs-keyword">while</span> self.current_step &lt; self.max_steps <span class="hljs-keyword">and</span> self.state != AgentState.FINISHED:
    self.current_step += <span class="hljs-number">1</span>
    <span class="hljs-keyword">await</span> self.step()

<span class="hljs-keyword">if</span> self.current_step &gt;= self.max_steps:
    results.append(<span class="hljs-string">f"达到最大步数限制 (<span class="hljs-subst">{self.max_steps}</span>)"</span>)
</code></pre>
<p>这是一个保底机制，防止 Agent 无限运行。</p>
<h2 data-id="heading-5">卡死检测</h2>
<p>OpenManus 还会检测 Agent 是否卡住了：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_stuck</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-comment"># 检查是否有重复的 assistant 消息</span>
    <span class="hljs-comment"># 如果最近的回复都一样，说明卡住了</span>
    recent_messages = self.get_recent_assistant_messages()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(recent_messages)) == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>
<h2 data-id="heading-6">Planning Agent 的结束逻辑</h2>
<h3 data-id="heading-7">1. 计划完成的判断机制</h3>
<p>PlanningFlow 的结束判断并不是简单检查所有步骤是否完成：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 在主执行循环中</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    <span class="hljs-comment"># 获取当前需要执行的步骤</span>
    self.current_step_index, step_info = <span class="hljs-keyword">await</span> self._get_current_step_info()
    
    <span class="hljs-comment"># 如果没有更多活跃步骤，则结束计划</span>
    <span class="hljs-keyword">if</span> self.current_step_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        result += <span class="hljs-keyword">await</span> self._finalize_plan()
        <span class="hljs-keyword">break</span>
</code></pre>
<h3 data-id="heading-8">2. 步骤状态检查逻辑</h3>
<p>_get_current_step_info() 方法负责判断是否还有未完成的步骤：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 查找第一个非完成状态的步骤</span>
<span class="hljs-keyword">for</span> i, step <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(steps):
    <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(step_statuses):
        status = PlanStepStatus.NOT_STARTED.value
    <span class="hljs-keyword">else</span>:
        status = step_statuses[i]
    
    <span class="hljs-comment"># 如果步骤状态为活跃状态（未开始或进行中），返回该步骤</span>
    <span class="hljs-keyword">if</span> status <span class="hljs-keyword">in</span> PlanStepStatus.get_active_statuses():
        <span class="hljs-keyword">return</span> i, step_info

<span class="hljs-comment"># 如果没找到活跃步骤，返回 None</span>
<span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>
</code></pre>
<p>其中 get_active_statuses() 返回 ["not_started", "in_progress"]，意味着只有当所有步骤都是 "completed" 或 "blocked" 状态时，计划才会结束。</p>
<h3 data-id="heading-9">3. 计划结束处理</h3>
<p>当没有更多活跃步骤时，会调用 _finalize_plan() 方法：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_finalize_plan</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">"""使用 LLM 生成计划完成总结"""</span>
    plan_text = <span class="hljs-keyword">await</span> self._get_plan_text()
    
    <span class="hljs-comment"># 使用 LLM 生成总结</span>
    system_message = Message.system_message(
        <span class="hljs-string">"You are a planning assistant. Your task is to summarize the completed plan."</span>
    )
    
    user_message = Message.user_message(
        <span class="hljs-string">f"The plan has been completed. Here is the final plan status:\n\n<span class="hljs-subst">{plan_text}</span>\n\nPlease provide a summary of what was accomplished and any final thoughts."</span>
    )
    
    response = <span class="hljs-keyword">await</span> self.llm.ask(messages=[user_message], system_msgs=[system_message])
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"Plan completed:\n\n<span class="hljs-subst">{response}</span>"</span>
</code></pre>
<h2 data-id="heading-10">Gemini CLI 的停止逻辑</h2>
<p>Gemini CLI 的设计思路完全不同，它用了一个更优雅但也更复杂的方案。</p>
<h2 data-id="heading-11">subagent 的停止逻辑</h2>
<h3 data-id="heading-12">1. 达到最大轮次（MAX_TURNS）</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.runConfig.max_turns &amp;&amp; turnCounter &gt;= <span class="hljs-keyword">this</span>.runConfig.max_turns) {
    <span class="hljs-keyword">this</span>.output.terminate_reason = SubagentTerminateMode.MAX_TURNS;
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>这是最简单的保护机制，防止无限循环。</p>
<h3 data-id="heading-13">2. 执行超时（TIMEOUT）</h3>
<pre><code class="hljs language-ini" lang="ini">let <span class="hljs-attr">durationMin</span> = (Date.now() - startTime) / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)<span class="hljs-comment">;</span>
if (durationMin &gt;= this.runConfig.max_time_minutes) {
    <span class="hljs-attr">this.output.terminate_reason</span> = SubagentTerminateMode.TIMEOUT<span class="hljs-comment">;</span>
    break<span class="hljs-comment">;</span>
}
</code></pre>
<p>注意这里检查了两次超时：</p>
<ul>
<li>在调用 LLM 之前检查一次</li>
<li>在调用 LLM 之后又检查一次</li>
</ul>
<p>这是因为 LLM 调用可能很耗时，要确保不会超时太多。</p>
<h3 data-id="heading-14">3. 用户中断（通过 AbortSignal）</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">if</span> (abortController.signal.aborted) <span class="hljs-keyword">return</span>;
</code></pre>
<p>这个检查出现在 stream 处理循环里，确保能及时响应用户的取消操作。</p>
<h3 data-id="heading-15">4. 错误异常（ERROR）</h3>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-keyword">catch</span> (<span class="hljs-keyword">error</span>) {
    console.<span class="hljs-keyword">error</span>(<span class="hljs-comment">'Error during subagent execution:', error);</span>
    this.output.terminate_reason = SubagentTerminateMode.<span class="hljs-keyword">ERROR</span>;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">error</span>;
}
</code></pre>
<p>任何未捕获的异常都会导致停止。</p>
<h3 data-id="heading-16">5. 目标完成（GOAL）</h3>
<p>目标完成的判断分两种情况：</p>
<p>情况A：没有预定输出要求</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.outputConfig || Object.keys(<span class="hljs-keyword">this</span>.outputConfig.outputs).length === <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// 没有要求特定输出，LLM 不调用工具就认为完成了</span>
    <span class="hljs-keyword">if</span> (functionCalls.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>.output.terminate_reason = SubagentTerminateMode.GOAL;
        <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
<p>情况B：有预定输出要求</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 检查是否所有要求的变量都已输出</span>
<span class="hljs-keyword">const</span> remainingVars = Object.keys(<span class="hljs-keyword">this</span>.outputConfig.outputs).filter(
    (key) =&gt; !(key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.output.emitted_vars)
);

<span class="hljs-keyword">if</span> (remainingVars.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>.output.terminate_reason = SubagentTerminateMode.GOAL;
    <span class="hljs-keyword">break</span>;
}
</code></pre>
<h2 data-id="heading-17">声明式输出系统的实现</h2>
<p>声明式输出系统的核心是 outputConfig：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 预先声明需要什么输出</span>
<span class="hljs-keyword">this</span>.outputConfig = {
    outputs: {
        <span class="hljs-string">"summary"</span>: <span class="hljs-string">"string"</span>,
        <span class="hljs-string">"recommendations"</span>: <span class="hljs-string">"array"</span>, 
        <span class="hljs-string">"risk_score"</span>: <span class="hljs-string">"number"</span>
    }
};

<span class="hljs-comment">// Agent 通过 self.emitvalue 工具来产生输出</span>
<span class="hljs-comment">// 每次调用会把值存到 this.output.emitted_vars 里</span>
<span class="hljs-keyword">this</span>.output.emitted_vars = {
    <span class="hljs-string">"summary"</span>: <span class="hljs-string">"这是总结..."</span>,
    <span class="hljs-string">"recommendations"</span>: [<span class="hljs-string">"建议1"</span>, <span class="hljs-string">"建议2"</span>]
    <span class="hljs-comment">// risk_score 还没输出</span>
};
</code></pre>
<p>系统会不断检查 emitted_vars 是否包含了所有 outputs 中声明的变量。只有全部输出了才认为目标完成。</p>
<h2 data-id="heading-18">Nudge 机制</h2>
<p>Nudge（轻推）机制代码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (functionCalls.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {  <span class="hljs-comment">// LLM 停止调用工具了</span>
    <span class="hljs-comment">// 检查是否还有变量没输出</span>
    <span class="hljs-keyword">const</span> remainingVars = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">outputConfig</span>.<span class="hljs-property">outputs</span>).<span class="hljs-title function_">filter</span>(
        <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> !(key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">output</span>.<span class="hljs-property">emitted_vars</span>)
    );
    
    <span class="hljs-keyword">if</span> (remainingVars.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 还有变量没输出，"推"它一下</span>
        <span class="hljs-keyword">const</span> nudgeMessage = <span class="hljs-string">`You have stopped calling tools but have not emitted 
        the following required variables: <span class="hljs-subst">${remainingVars.join(<span class="hljs-string">', '</span>)}</span>. 
        Please use the 'self.emitvalue' tool to emit them now, 
        or continue working if necessary.`</span>;
        
        <span class="hljs-comment">// 把提醒作为新的用户消息发给 LLM</span>
        currentMessages = [{
            <span class="hljs-attr">role</span>: <span class="hljs-string">'user'</span>,
            <span class="hljs-attr">parts</span>: [{ <span class="hljs-attr">text</span>: nudgeMessage }]
        }];
        
        <span class="hljs-comment">// 继续循环，不退出</span>
    }
}
</code></pre>
<h2 data-id="heading-19">完整的 subagent 执行流程</h2>
<pre><code class="hljs language-arduino" lang="arduino">开始
  ↓
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  检查是否超时/超轮次 → 是 → 退出
    ↓ 否
  调用 LLM
    ↓
  LLM 返回工具调用？
    ├─ 是 → 执行工具 → 检查目标是否完成
    │         ├─ 是 → 退出
    │         └─ 否 → 继续循环
    │
    └─ 否（LLM 停止调用工具）
         ↓
       有预定输出要求吗？
         ├─ 没有 → 退出（认为完成）
         └─ 有 → 检查是否都输出了
                   ├─ 是 → 退出
                   └─ 否 → Nudge 提醒 → 继续循环
}
</code></pre>
<h2 data-id="heading-20">三层循环检测机制</h2>
<h3 data-id="heading-21">第一层：工具调用重复检测</h3>
<p>这是最简单直接的检测，针对 Agent 反复调用相同工具的情况。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> checkToolCallLoop(toolCall: { name: string; args: <span class="hljs-keyword">object</span> }): boolean {
    <span class="hljs-comment">// 把工具名和参数一起哈希，生成唯一标识</span>
    <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">this</span>.getToolCallKey(toolCall);
    
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lastToolCallKey === key) {
        <span class="hljs-comment">// 和上次调用完全一样，计数+1</span>
        <span class="hljs-keyword">this</span>.toolCallRepetitionCount++;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 不一样，重置计数</span>
        <span class="hljs-keyword">this</span>.lastToolCallKey = key;
        <span class="hljs-keyword">this</span>.toolCallRepetitionCount = <span class="hljs-number">1</span>;
    }
    
    <span class="hljs-comment">// 连续5次调用相同工具+相同参数 = 循环</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.toolCallRepetitionCount &gt;= TOOL_CALL_LOOP_THRESHOLD) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>触发条件：连续 5 次调用完全相同的工具（包括参数）。</p>
<p>这种检测很严格——必须是连续的、完全相同的调用。如果中间插入了其他工具调用，计数就会重置。</p>
<h3 data-id="heading-22">第二层：内容重复检测（"咒语"检测）</h3>
<p>这是最复杂的部分，用来检测 LLM 输出重复内容的情况，就像在念咒语一样。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> checkContentLoop(content: string): boolean {
    <span class="hljs-comment">// 1. 先检查是否在特殊内容块中（代码块、表格、列表等）</span>
    <span class="hljs-keyword">const</span> numFences = (content.match(/```/g) ?? []).length;
    <span class="hljs-keyword">const</span> hasTable = /(^|\n)\s*(|.*||[|+-]{<span class="hljs-number">3</span>,})/.test(content);
    <span class="hljs-comment">// ... 检查各种格式</span>
    
    <span class="hljs-comment">// 在代码块中不检测循环（代码本来就可能有重复）</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.inCodeBlock) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// 2. 把新内容加入历史</span>
    <span class="hljs-keyword">this</span>.streamContentHistory += content;
    
    <span class="hljs-comment">// 3. 保持历史在 1000 字符以内</span>
    <span class="hljs-keyword">this</span>.truncateAndUpdate();
    
    <span class="hljs-comment">// 4. 分析内容块是否重复</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.analyzeContentChunksForLoop();
}
</code></pre>
<p>核心算法是滑动窗口 + 哈希检测：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> analyzeContentChunksForLoop(): boolean {
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.hasMoreChunksToProcess()) {
        <span class="hljs-comment">// 提取 50 字符的块</span>
        <span class="hljs-keyword">const</span> currentChunk = <span class="hljs-keyword">this</span>.streamContentHistory.substring(
            <span class="hljs-keyword">this</span>.lastContentIndex,
            <span class="hljs-keyword">this</span>.lastContentIndex + CONTENT_CHUNK_SIZE  <span class="hljs-comment">// 50</span>
        );
        
        <span class="hljs-comment">// 计算哈希</span>
        <span class="hljs-keyword">const</span> chunkHash = createHash(<span class="hljs-string">'sha256'</span>).update(currentChunk).digest(<span class="hljs-string">'hex'</span>);
        
        <span class="hljs-comment">// 检查这个块是否重复出现</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isLoopDetectedForChunk(currentChunk, chunkHash)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        
        <span class="hljs-comment">// 滑动窗口向前移动 1 个字符</span>
        <span class="hljs-keyword">this</span>.lastContentIndex++;
    }
}
</code></pre>
<p>判断循环的条件：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">private</span> isLoopDetectedForChunk(chunk: string, hash: string): boolean {
    <span class="hljs-keyword">const</span> existingIndices = <span class="hljs-keyword">this</span>.contentStats.<span class="hljs-keyword">get</span>(hash);
    
    <span class="hljs-keyword">if</span> (!existingIndices) {
        <span class="hljs-comment">// 第一次见到这个块，记录位置</span>
        <span class="hljs-keyword">this</span>.contentStats.<span class="hljs-keyword">set</span>(hash, [<span class="hljs-keyword">this</span>.lastContentIndex]);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// 验证内容确实相同（防止哈希碰撞）</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isActualContentMatch(chunk, existingIndices[<span class="hljs-number">0</span>])) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    
    existingIndices.push(<span class="hljs-keyword">this</span>.lastContentIndex);
    
    <span class="hljs-comment">// 需要出现至少 10 次</span>
    <span class="hljs-keyword">if</span> (existingIndices.length &lt; CONTENT_LOOP_THRESHOLD) {  <span class="hljs-comment">// 10</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// 关键：这 10 次必须距离很近（平均距离 ≤ 75 字符）</span>
    <span class="hljs-keyword">const</span> recentIndices = existingIndices.slice(-CONTENT_LOOP_THRESHOLD);
    <span class="hljs-keyword">const</span> totalDistance = recentIndices[recentIndices.length - <span class="hljs-number">1</span>] - recentIndices[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">const</span> averageDistance = totalDistance / (CONTENT_LOOP_THRESHOLD - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> maxAllowedDistance = CONTENT_CHUNK_SIZE * <span class="hljs-number">1.5</span>;  <span class="hljs-comment">// 75</span>
    
    <span class="hljs-keyword">return</span> averageDistance &lt;= maxAllowedDistance;
}
</code></pre>
<p>触发条件：同一个 50 字符的内容块，在很短的距离内重复出现 10 次。</p>
<h3 data-id="heading-23">第三层：LLM 智能检测</h3>
<p>这是最高级的检测，用 AI 来判断 AI 是否陷入循环。</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">private</span> async <span class="hljs-title function_ invoke__">checkForLoopWithLLM</span>(<span class="hljs-attr">signal</span>: AbortSignal) {
    <span class="hljs-comment">// 取最近 20 轮对话</span>
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">recentHistory</span> = this.config
        .<span class="hljs-title function_ invoke__">getGeminiClient</span>()
        .<span class="hljs-title function_ invoke__">getHistory</span>()
        .<span class="hljs-title function_ invoke__">slice</span>(-LLM_LOOP_CHECK_HISTORY_COUNT);  <span class="hljs-comment">// 20</span>
    
    <span class="hljs-comment">// 清理历史（去掉悬空的函数调用等）</span>
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">trimmedHistory</span> = this.<span class="hljs-title function_ invoke__">trimRecentHistory</span>(recentHistory);
    
    <span class="hljs-comment">// 让 Gemini Flash 模型分析</span>
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = await this.config.<span class="hljs-title function_ invoke__">getBaseLlmClient</span>().<span class="hljs-title function_ invoke__">generateJson</span>({
        <span class="hljs-attr">contents</span>: [...trimmedHistory, { <span class="hljs-attr">role</span>: <span class="hljs-string">'user'</span>, <span class="hljs-attr">parts</span>: [{ <span class="hljs-attr">text</span>: taskPrompt }] }],
        <span class="hljs-attr">schema</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'object'</span>,
            <span class="hljs-attr">properties</span>: {
                <span class="hljs-attr">reasoning</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span> },
                <span class="hljs-attr">confidence</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'number'</span> }  // <span class="hljs-number">0</span>-<span class="hljs-number">1</span> 之间
            }
        },
        <span class="hljs-attr">model</span>: DEFAULT_GEMINI_FLASH_MODEL,
        <span class="hljs-attr">systemInstruction</span>: LOOP_DETECTION_SYSTEM_PROMPT
    });
    
    <span class="hljs-keyword">if</span> (result[<span class="hljs-string">'confidence'</span>] &gt; <span class="hljs-number">0.9</span>) {
        <span class="hljs-comment">// 高置信度认为是循环</span>
        console.<span class="hljs-title function_ invoke__">warn</span>(result[<span class="hljs-string">'reasoning'</span>]);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>触发时机：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">async turnStarted(signal: AbortSignal) {
    <span class="hljs-keyword">this</span>.turnsInCurrentPrompt++;
    
    <span class="hljs-keyword">if</span> (
        <span class="hljs-keyword">this</span>.turnsInCurrentPrompt &gt;= LLM_CHECK_AFTER_TURNS &amp;&amp;  <span class="hljs-comment">// 至少 30 轮</span>
        <span class="hljs-keyword">this</span>.turnsInCurrentPrompt - <span class="hljs-keyword">this</span>.lastCheckTurn &gt;= <span class="hljs-keyword">this</span>.llmCheckInterval
    ) {
        <span class="hljs-keyword">this</span>.lastCheckTurn = <span class="hljs-keyword">this</span>.turnsInCurrentPrompt;
        <span class="hljs-keyword">return</span> await <span class="hljs-keyword">this</span>.checkForLoopWithLLM(signal);
    }
}
</code></pre>
<ul>
<li>必须执行超过 30 轮才开始检查（避免误判）</li>
<li>不是每轮都检查，有间隔（默认 3 轮）</li>
<li>间隔会根据置信度动态调整（5-15 轮）</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 动态调整检查频率</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">llmCheckInterval</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(
    <span class="hljs-variable constant_">MIN_LLM_CHECK_INTERVAL</span> +  <span class="hljs-comment">// 5</span>
    (<span class="hljs-variable constant_">MAX_LLM_CHECK_INTERVAL</span> - <span class="hljs-variable constant_">MIN_LLM_CHECK_INTERVAL</span>) * (<span class="hljs-number">1</span> - result[<span class="hljs-string">'confidence'</span>])
    <span class="hljs-comment">// 置信度越高，检查越频繁</span>
);
</code></pre>
<h2 data-id="heading-24">三种循环类型</h2>
<p>系统定义了三种循环类型：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">LoopType</span> {
    CONSECUTIVE_IDENTICAL_TOOL_CALLS,  <span class="hljs-comment">// 连续相同工具调用</span>
    CHANTING_IDENTICAL_SENTENCES,      <span class="hljs-comment">// 重复输出相同内容</span>
    LLM_DETECTED_LOOP                  <span class="hljs-comment">// LLM 检测到的逻辑循环</span>
}
</code></pre>
<p>每种都有不同的检测方法和触发条件。</p>
<p>这比较适合处理长对话场景，既能有效检测循环，又不会因为过于敏感而误判正常的迭代操作。</p>
<h2 data-id="heading-25">小结</h2>
<p>AI Agent 的停止策略是一个容易被忽视但极其重要的技术问题。从原理上看，Agent 就是一个大循环，不断调用 LLM 和工具来完成任务，但如果没有合理的停止机制，就会出现无限循环浪费资源，或者过早停止无法完成任务的问题。常见的停止方案包括硬性限制（步数、时间、API调用次数）、任务完成检测、显式停止信号、循环检测、错误累积和用户中断等，实际应用中需要组合使用多种策略。</p>
<p>OpenManus 采用了相对简单直接的设计：给每个 Agent 配备 terminate 工具，让 LLM 自己决定何时停止，同时用状态机管理生命周期，配合步数限制作为保底，并确保无论如何停止都会正确清理资源。</p>
<p>而 Gemini CLI 的设计更加精巧，核心是声明式输出系统——预先定义需要什么输出，只有全部输出才算完成，如果 Agent 停止调用工具但还有变量未输出，系统会通过 Nudge 机制温和提醒；在循环检测上，Gemini 实现了三层防护：工具调用重复检测（连续5次相同调用）、内容重复检测（滑动窗口+哈希算法检测"咒语"现象）、以及用 LLM 分析对话历史判断是否陷入逻辑循环。</p>
<p>实践中的关键是不要依赖单一停止机制，要组合使用多种策略形成多层防护，给 LLM 明确的停止指引，为不同类型的停止原因提供清晰的用户反馈，并确保资源能够可靠清理。停止策略的本质是在"让 Agent 完成任务"和"防止失控"之间找到平衡点。</p>
<p>以上。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SpringBoot 原理专题]]></title>    <link>https://juejin.cn/post/7592088192506134582</link>    <guid>https://juejin.cn/post/7592088192506134582</guid>    <pubDate>2026-01-06T05:17:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592088192506134582" data-draft-id="7590961898399203366" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SpringBoot 原理专题"/> <meta itemprop="keywords" content="Spring Boot,Java,Spring"/> <meta itemprop="datePublished" content="2026-01-06T05:17:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哪里的破水瓶"/> <meta itemprop="url" content="https://juejin.cn/user/4394111849466414"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SpringBoot 原理专题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4394111849466414/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哪里的破水瓶
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T05:17:41.000Z" title="Tue Jan 06 2026 05:17:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#444;background-image:linear-gradient(90deg,rgba(59,59,59,.1) 3%,transparent 0),linear-gradient(1turn,rgba(122,120,121,.1) 3%,transparent 0);background-size:30px 30px;background-position:50%;letter-spacing:1px;word-spacing:1px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position:relative;margin-top:34px;margin-bottom:16px;font-weight:700;line-height:1.3;cursor:text;color:#444;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body h1{font-size:41px;margin-bottom:34px;line-height:1.5}.markdown-body h1:before{content:""}.markdown-body h2{font-size:30px;padding-left:.4em;border-left:.4em solid #5e5e5e;border-bottom:1px solid #444}.markdown-body h2:after{content:"🕛";position:absolute;top:0;right:0;transition:all;animation:rotate 10s linear infinite}@keyframes rotate{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.markdown-body h3{border-left:.4em solid #8d8d8d;font-size:24px;padding-left:.4em}.markdown-body h4{font-size:20px}.markdown-body h5{font-size:16px}.markdown-body h6{font-size:14px}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body table,.markdown-body ul{margin:.8em 0}.markdown-body strong{font-weight:1000;position:relative;color:#444;padding:0 3px}.markdown-body em{font-weight:inherit}.markdown-body a{box-sizing:border-box;color:grey;position:relative}.markdown-body a:before{position:absolute;box-sizing:border-box;content:"Go -&gt;";left:0;width:100%;max-width:0;color:#fff;background-color:hsla(0,0%,50.2%,.8);white-space:nowrap;transition:.2s ease;pointer-events:none;overflow:hidden}.markdown-body a:after{content:"";position:absolute;bottom:0;left:0;width:100%;height:1px;background-color:grey}.markdown-body a:active:before,.markdown-body a:hover:before{max-width:100%;padding-left:8px;border-radius:5px}.markdown-body hr{position:relative;width:100%;height:1px;border:none;margin-top:36px;margin-bottom:36px;background:linear-gradient(90deg,grey,#f1f1f1,#444,#444,#f1f1f1,grey);overflow:visible}.markdown-body ol,.markdown-body ul{padding-left:32px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px;list-style:inherit}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol{counter-reset:my-counter}.markdown-body ol&gt;li{padding-left:6px;list-style:none;counter-increment:my-counter;position:relative}.markdown-body ol&gt;li:before{position:absolute;left:-1.5em;content:counter(my-counter);font-weight:700}.markdown-body ol&gt;li:first-child:before{content:"1️⃣"}.markdown-body ol&gt;li:nth-child(2):before{content:"2️⃣"}.markdown-body ol&gt;li:nth-child(3):before{content:"3️⃣"}.markdown-body ol&gt;li:nth-child(4):before{content:"4️⃣"}.markdown-body ol&gt;li:nth-child(5):before{content:"5️⃣"}.markdown-body ol&gt;li:nth-child(6):before{content:"6️⃣"}.markdown-body ol&gt;li:nth-child(7):before{content:"7️⃣"}.markdown-body ol&gt;li:nth-child(8):before{content:"8️⃣"}.markdown-body ol&gt;li:nth-child(9):before{content:"9️⃣"}.markdown-body ol&gt;li:nth-child(10):before{content:"🔟"}.markdown-body ul&gt;li{list-style:none;position:relative}.markdown-body ul&gt;li:before{z-index:10;position:absolute;left:-1.57em;content:"🔹";margin-right:12px}.markdown-body ul&gt;li input{margin-left:8px!important}.markdown-body blockquote{position:relative;background-color:#d3d3d3;padding:5px 10px;border-left:.2em solid #000;border-radius:3px;transition:all .8s ease}.markdown-body blockquote:hover{opacity:.7}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(69,69,77,.8);color:#fff;font-size:.87em;padding:.07em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:7px;overflow:hidden}.markdown-body pre:before{z-index:10;position:absolute;top:14px;left:14px;width:12px;height:12px;border-radius:50%;background:#fc625d;-webkit-box-shadow:20px 0 #fdbc40,40px 0 #35cd4b;box-shadow:20px 0 #fdbc40,40px 0 #35cd4b;content:" "}.markdown-body pre:after{z-index:9;content:"";position:absolute;width:100%;height:40px;top:0;background-color:#1a1a1a}.markdown-body pre&gt;code{display:block;font-family:Menlo,Monaco,Consolas,Courier New,monospace;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#171717;color:#bababa;font-size:14px;padding:40px 20px 20px}.markdown-body del{color:grey}.markdown-body table{margin-bottom:1.25rem;border-collapse:collapse}.markdown-body table td,.markdown-body table th{margin:0;padding:8px;line-height:20px;vertical-align:middle;border:1px solid #ddd}.markdown-body table thead,.markdown-body table tr:nth-child(2n){background-color:#fcfcfc}.markdown-body table thead th,.markdown-body table tr:nth-child(2n) th{font-weight:700;vertical-align:middle;color:#444}.markdown-body table tbody tr td{font-weight:400;color:#444}.markdown-body table tbody tr:hover{background-color:#d3d3d3}.markdown-body table tbody tr:hover td{color:#fff}.markdown-body img{max-width:100%;margin:0 12px}@media (max-width:720px){.markdown-body h1{font-size:32.8px}.markdown-body h2{font-size:24px}.markdown-body h3{font-size:19.2px}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:12.8px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">优先级与打包</h2>
<ol>
<li>命令行参数</li>
<li>系统环境</li>
<li>properties</li>
<li>yml</li>
<li>yaml</li>
</ol>
<blockquote>
<p>打包插件</p>
</blockquote>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring-boot.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.example.DemoApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">skip</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skip</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<blockquote>
<p>打包后运行，带额外参数</p>
</blockquote>
<pre><code class="hljs language-bash" lang="bash">java -Dserver.port=9000 -jar dd.jar
</code></pre>
<h2 data-id="heading-1">Bean 作用域</h2>





























<table><thead><tr><th>作用域</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>容器内同 名称 的 bean 只有一个实例（单例）（默认）</td></tr><tr><td>prototype</td><td>每次使用该 bean 时会创建新的实例（非单例/多例）</td></tr><tr><td>request</td><td>每个请求范围内会创建新的实例（web环境中，了解）</td></tr><tr><td>session</td><td>每个会话范围内会创建新的实例（web环境中，了解）</td></tr><tr><td>application</td><td>每个应用范围内会创建新的实例（web环境中，了解）</td></tr></tbody></table>
<blockquote>
<p>配置 Scope 注解，选择单例</p>
</blockquote>
<ul>
<li>Lazy 表示延迟加载，默认是启动时加载，配置后表示延迟到第一次使用加载</li>
<li>SCOPE_SINGLETON 单例</li>
<li>SCOPE_PROTOTYPE 非单例</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Lazy</span>
<span class="hljs-meta">@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicController</span> {}
</code></pre>
<p>注意：</p>
<ol>
<li>单例是无状态的，多例是有状态的。</li>
<li>单例是节约资源，提升性能</li>
<li>单例bean：如果是无状态的bean，内部不保存任何状态信息，则是线程安全的。</li>
<li>单例bean：如果是有状态的bean，内部会保存状态信息，多个线程会同时操作该bean时，可能会出现数据不一致的问题，这样的bean则是线程不安全的。</li>
</ol>
<h2 data-id="heading-2">起步依赖</h2>
<p>依赖，具有传递性。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4724f85fadbb4fdc8fa7ef6d32531cbc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768282100&amp;x-signature=toz%2BAjKy9M%2FMpFsJJX1HOGbduuo%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e08b52d87ac486fa565654983cad758~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768282100&amp;x-signature=gSjphezX%2ByiC0AJKK%2Fj4rvUwD94%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-3">自动配置</h2>
<p>SpringBoot的自动配置就是当spring项目启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。</p>
<blockquote>
<p>比如：引入了redis依赖，可以直接注入Redis使用。</p>
</blockquote>
<p>实现方案一</p>
<p>加入另一个项目的依赖，引入依赖，并在主类上加上包扫描，扫描该依赖的包，不推荐，<strong>原因是操作麻烦+性能低</strong></p>
<p>实现方案二</p>
<p>类不需要加任何注解，直接使用 Import 导入，或者使用Imort 导入一个配置类。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Import(TokenService.class)</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> {
</code></pre>
<blockquote>
<p>配置类代码</p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> {

    <span class="hljs-comment">// 返回多个类的全限定命名</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{<span class="hljs-string">"com.example.aop.RecordTimeAspect2"</span>};
    }
}

</code></pre>
<p>实现方案三：加注解的方式，最实用</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 核心还是用方式二</span>
<span class="hljs-meta">@Import(MyImportSelector.class)</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableHeaderConfig {
}

</code></pre>
<h2 data-id="heading-4">条件判断 / 自动配置</h2>
<p>有时候我们经常需要判断该类应不应该注入到IOC容器中。</p>
<ul>
<li>
<p>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring IOC容器中。</p>
</li>
<li>
<p>位置：方法、类</p>
</li>
<li>
<p>@Conditional 本身是一个父注解，派生出大量的子注解：</p>
</li>
<li>
<p>@ConditionalOnClass：判断环境中是否有对应字节码文件，才注册bean到IOC容器。</p>
</li>
<li>
<p>@ConditionalOnMissingBean：判断环境中没有对应的bean（类型 或 名称） ，才注册bean到IOC容器。</p>
</li>
<li>
<p>@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。</p>
</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-comment">// 判断环境中是否存在io.jsonwebtoken.Jwts，如果有就创建该Bean</span>
<span class="hljs-meta">@ConditionalOnClass(name = "io.jsonwebtoken.Jwts")</span>
<span class="hljs-comment">// 判断环境中是否存在该类，如果没有就创建该Bean</span>
<span class="hljs-meta">@ConditionalOnMissingBean</span>
<span class="hljs-comment">// 判断属性值是否为true,在配置文件中</span>
<span class="hljs-meta">@ConditionalOnProperty(name = "enable", havingValue = "true")</span>
<span class="hljs-keyword">public</span> RecordTimeAspect2 <span class="hljs-title function_">recordTimeAspect2</span><span class="hljs-params">()</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecordTimeAspect2</span>();
}
</code></pre>
<blockquote>
<p>自己定义自动配置类的核心是什么? 如何完成自动配置？</p>
</blockquote>
<ol>
<li>定义自动配置类</li>
<li>将自动配置类配置在 META-INF/spring/</li>
<li>org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中</li>
</ol>
<h2 data-id="heading-5">自定义Starter</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c64e0497e1dd44f2bbf70cec02697ff6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768282100&amp;x-signature=gUvg2PstGvemeg%2BcwsxvkHJtkuk%3D" alt="image.png" loading="lazy"/></p>
<p>需求：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类 AliyunOSSOperator 的自动配置。</p>
<p>目标：引入起步依赖引入之后，要想使用阿里云OSS，注入 AliyunOSSOperator 直接使用即可。</p>
<p>步骤：</p>
<ol>
<li>创建aliyun-oss-spring-boot-starter模块</li>
<li>创建aliyun-oss-spring-boot-autoconfigure模块，在starter中引入该模块</li>
<li>在aliyun-oss-spring-boot-autoconfigure模块中的定义自动配置功能，并定义自动配置文件 META-INF/spring/xxxx.imports</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/394d2c5291894d1590ce164173b56718~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768282100&amp;x-signature=5JWr0ECT7kmrzFmW0ityFVo%2Bl18%3D" alt="image.png" loading="lazy"/></p>
<blockquote>
<p>注意：选择一个版本，无需要选依赖</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f69e841e347b46b38a91e476c10033f2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOq6YeM55qE56C05rC055O2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768282100&amp;x-signature=lhLVPCRXLPQ1DLTTPdfyymuTxrE%3D" alt="image.png" loading="lazy"/></p>
<p>只需要依赖是 spring-boot-starter 就可以。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--    帮助yaml提示    --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableConfigurationProperties(OSSProperties.class)</span> <span class="hljs-comment">// 引入配置类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OSSConfig</span> {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> OSS <span class="hljs-title function_">endpoint</span><span class="hljs-params">(OSSProperties ossProperties)</span> {
        <span class="hljs-type">DefaultCredentialProvider</span> <span class="hljs-variable">defaultCredentialProvider</span> <span class="hljs-operator">=</span>
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultCredentialProvider</span>(ossProperties.getAccessKeyId(), ossProperties.getSecretAccessKey());
        <span class="hljs-type">ClientBuilderConfiguration</span> <span class="hljs-variable">clientBuilderConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientBuilderConfiguration</span>();
        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);
        <span class="hljs-keyword">return</span> OSSClientBuilder.create()
                .endpoint(<span class="hljs-string">"https://"</span> + ossProperties.getEndpoint())
                .credentialsProvider(defaultCredentialProvider)
                .clientConfiguration(clientBuilderConfiguration)
                .region(extractRegion(ossProperties.getEndpoint()))
                .build();
    }

    <span class="hljs-comment">/**
     * 获取 region
     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">extractRegion</span><span class="hljs-params">(String endpoint)</span> {
        <span class="hljs-keyword">if</span> (endpoint == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> endpoint.indexOf(<span class="hljs-string">"oss-"</span>);
        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> endpoint.indexOf(<span class="hljs-string">".aliyuncs.com"</span>);
        <span class="hljs-keyword">if</span> (start == -<span class="hljs-number">1</span> || end == -<span class="hljs-number">1</span> || start + <span class="hljs-number">4</span> &gt;= end)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Invalid endpoint: "</span> + endpoint);
        <span class="hljs-keyword">return</span> endpoint.substring(start + <span class="hljs-number">4</span>, end);
    }

}

</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@ConfigurationProperties(prefix = "aliun.oss")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OSSProperties</span> {

    <span class="hljs-keyword">private</span> String endpoint;
    <span class="hljs-keyword">private</span> String accessKeyId;
    <span class="hljs-keyword">private</span> String secretAccessKey;
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[this调用会导致事务失效？还是没搞明白啊！]]></title>    <link>https://juejin.cn/post/7592119218029559842</link>    <guid>https://juejin.cn/post/7592119218029559842</guid>    <pubDate>2026-01-06T12:13:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592119218029559842" data-draft-id="7591350620189343750" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="this调用会导致事务失效？还是没搞明白啊！"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-01-06T12:13:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="提前退休的java猿"/> <meta itemprop="url" content="https://juejin.cn/user/465848660928872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            this调用会导致事务失效？还是没搞明白啊！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/465848660928872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    提前退休的java猿
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T12:13:02.000Z" title="Tue Jan 06 2026 12:13:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    92
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<blockquote>
<p>我是[<a href="https://juejin.cn/user/465848660928872" title="https://juejin.cn/user/465848660928872" target="_blank">提前退休的java猿</a>]，一名7年java开发经验的开发组长，分享工作中的各种问题！（需要模拟面试、简历优化也可找我）</p>
</blockquote>
<p>前一两周，公司的业务出了重大问题。数据库的服务器<code>CPU 100%</code>然后一些重要的抽奖业务竟然出现物品超领的情况。</p>
<p>同事的反馈就是 一个事务里面 只执行了后半部分，也就是领取记录插入（<code>B操作</code>）成功了，库存扣减（<code>A操作</code>）是没有问题的。</p>
<p><strong>核心代码如下（大家看一下事务是否失效🤶）：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//----------------------------------------controller代码---------------------------------------</span>
<span class="hljs-meta">@RedisRateLimiter(value = 100,limit = 1)</span>
<span class="hljs-meta">@PostMapping(value = "/grabCoupon")</span>
<span class="hljs-keyword">public</span> Res&lt;?&gt; equityClaim(<span class="hljs-meta">@RequestBody</span> GrabCouponReqEx req) {
    .........service 使用<span class="hljs-meta">@Resource</span> 注入..... 
    <span class="hljs-keyword">return</span> service.grabCouponTrans(req);
}
    
    
---------------------------------------service impl代码----------------------------------------
<span class="hljs-meta">@Transactional(rollbackFor = RuntimeException.class)</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Result&lt;?&gt; grabCouponTrans(GrabCouponReqEx req) {
       <span class="hljs-comment">// 对所有代码进行 try，然后抛出RuntimException 让框架回滚</span>
       <span class="hljs-keyword">try</span>{
       .............................
        <span class="hljs-comment">//✅ A操作：库存扣减，这个地方对库存-1，如果更新行数大与0返回true </span>
        <span class="hljs-comment">//UPDATE t SET num =  num -1  WHERE id = #{id} AND num &gt; 0;</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">isok</span> <span class="hljs-operator">=</span> reduceInventory(id);
        <span class="hljs-keyword">if</span> (isok) {
            <span class="hljs-comment">// ✅B操作：插入领取记录，插入成功返回 true</span>
            <span class="hljs-type">Boolean</span> <span class="hljs-variable">insetSuc</span> <span class="hljs-operator">=</span> insertRecord(record);
            <span class="hljs-keyword">if</span> (!insetSuc) {
               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"领取失败！"</span>);
            }
            <span class="hljs-keyword">return</span> result;
        } 
    }<span class="hljs-keyword">catch</span> (Exception e){
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"xxxx"</span>);
    }
}
</code></pre>
<p>🧔：很多网友都说this调用了<code>reduceInventory、insertRecord</code>方法事物不会生效</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c4464aa6bbe42da89307602f692718f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o-Q5YmN6YCA5LyR55qEamF2YeeMvw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768393316&amp;x-signature=YlSIwmf4XV4khQT8BxkCTSGx%2FnY%3D" alt="e9415f300e26bac81e2e9599d1a096a4.jpg" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d730201350a46ca8a0fbb5e9c9efb5d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5o-Q5YmN6YCA5LyR55qEamF2YeeMvw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768393316&amp;x-signature=68zS8pvZVwWpPyJF%2FIa%2BwvyPoaE%3D" alt="a9753e917f19a33cfe906f84c83b2110.jpg" loading="lazy"/></p>
<blockquote>
<p>✔这种理解肯定是不对的，this调用的外层方法是加了事物注解，并且是@Resource注入调用，是能被代理的。外层方法都被拦截了代理了，方法内部再this调用也是没有问题的，默认就加入当前事务了，如果内部方法通过容器对象获取，并且有事物注解这时候就是看事物的传播机制了。</p>
</blockquote>
<h2 data-id="heading-1">事务源码分析</h2>
<p>下面就是事务拦截器主要的代码逻辑 <code>TransactionAspectSupport.invokeWithinTransaction</code>:</p>
<ul>
<li>创建或获取事务</li>
<li>执行业务方法</li>
<li>捕捉异常：有异常处理回滚、没有匹配到回滚异常则提交事务</li>
<li>清理事务信息</li>
<li>提交事务</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">invokeWithinTransaction</span><span class="hljs-params">(Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass,
       <span class="hljs-keyword">final</span> InvocationCallback invocation)</span> <span class="hljs-keyword">throws</span> Throwable {

    <span class="hljs-comment">// If the transaction attribute is null, the method is non-transactional.</span>
    <span class="hljs-type">TransactionAttributeSource</span> <span class="hljs-variable">tas</span> <span class="hljs-operator">=</span> getTransactionAttributeSource();
    <span class="hljs-keyword">final</span> <span class="hljs-type">TransactionAttribute</span> <span class="hljs-variable">txAttr</span> <span class="hljs-operator">=</span> (tas != <span class="hljs-literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">final</span> <span class="hljs-type">TransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> determineTransactionManager(txAttr);
    
    <span class="hljs-comment">// 处理响应式事务（Spring 5.2+）</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.reactiveAdapterRegistry != <span class="hljs-literal">null</span> &amp;&amp; tm <span class="hljs-keyword">instanceof</span> ReactiveTransactionManager) {
       ............................
       <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-type">PlatformTransactionManager</span> <span class="hljs-variable">ptm</span> <span class="hljs-operator">=</span> asPlatformTransactionManager(tm);
    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">joinpointIdentification</span> <span class="hljs-operator">=</span> methodIdentification(method, targetClass, txAttr);

    <span class="hljs-keyword">if</span> (txAttr == <span class="hljs-literal">null</span> || !(ptm <span class="hljs-keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) {
        
       <span class="hljs-comment">// ✅关键步骤1：创建或获取事务（创建新事务还是沿用使用就看传播机制了）</span>
       <span class="hljs-comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span>
       <span class="hljs-type">TransactionInfo</span> <span class="hljs-variable">txInfo</span> <span class="hljs-operator">=</span> createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);

       Object retVal;
       <span class="hljs-keyword">try</span> {
          <span class="hljs-comment">// ✅关键步骤2：执行业务方法（AOP链的下一个拦截器或目标方法） </span>
          (执行目标方法：内部调用的方法使用<span class="hljs-built_in">this</span>指向默认也是被拦截的，
          如果有事务注解并且通过容器对象调用，执行的时候就会再次被拦截，此时事务的传播机制的作用就体现出来了)
          <span class="hljs-comment">// This is an around advice: Invoke the next interceptor in the chain.</span>
          <span class="hljs-comment">// This will normally result in a target object being invoked.</span>
          retVal = invocation.proceedWithInvocation();
       }
       <span class="hljs-keyword">catch</span> (Throwable ex) {
          <span class="hljs-comment">// ✅关键步骤3：异常处理回滚</span>
          <span class="hljs-comment">// target invocation exception</span>
          completeTransactionAfterThrowing(txInfo, ex);
          <span class="hljs-keyword">throw</span> ex;
       }
       <span class="hljs-keyword">finally</span> {
          <span class="hljs-comment">//✅关键步骤4：清理事务信息</span>
          cleanupTransactionInfo(txInfo);
       }

       <span class="hljs-keyword">if</span> (retVal != <span class="hljs-literal">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) {
          <span class="hljs-comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span>
          <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> txInfo.getTransactionStatus();
          <span class="hljs-keyword">if</span> (status != <span class="hljs-literal">null</span> &amp;&amp; txAttr != <span class="hljs-literal">null</span>) {
             retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);
          }
       }
       <span class="hljs-comment">// ✅关键步骤5：提交事务</span>
       commitTransactionAfterReturning(txInfo);
       <span class="hljs-keyword">return</span> retVal;
    }

    <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">//**JTA（Java Transaction API）**  或需要回调机制的事务管理器</span>
      <span class="hljs-comment">//...........................................................</span>
    }
}
</code></pre>
<h3 data-id="heading-2">一、创建获取事务</h3>
<p>创建事务信息<code>createTransactionIfNecessary</code>，如果之前已经存在事务就走需要判断事务的传播机制了</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> TransactionInfo <span class="hljs-title function_">createTransactionIfNecessary</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> PlatformTransactionManager tm,
        <span class="hljs-meta">@Nullable</span> TransactionAttribute txAttr, <span class="hljs-keyword">final</span> String joinpointIdentification)</span> {
    
    <span class="hljs-comment">// 如果没有指定名称，使用方法标识作为事务名称</span>
    <span class="hljs-keyword">if</span> (txAttr != <span class="hljs-literal">null</span> &amp;&amp; txAttr.getName() == <span class="hljs-literal">null</span>) {
        txAttr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingTransactionAttribute</span>(txAttr) {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
                <span class="hljs-keyword">return</span> joinpointIdentification;
            }
        };
    }
    
    <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (txAttr != <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// ✅关键：根据传播行为获取事务状态</span>
        <span class="hljs-keyword">if</span> (tm != <span class="hljs-literal">null</span>) {
            status = tm.getTransaction(txAttr);  <span class="hljs-comment">// 这里处理PROPAGATION_REQUIRED等</span>
        }
        <span class="hljs-comment">// ...</span>
    }
    
    <span class="hljs-comment">// ✅准备事务信息</span>
    <span class="hljs-keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
}
</code></pre>
<p>这是核心中的核心，在 <code>AbstractPlatformTransactionManager.getTransaction()</code> 中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition definition)</span> <span class="hljs-keyword">throws</span> TransactionException {
    <span class="hljs-comment">// 1. 获取事务定义</span>
    <span class="hljs-type">TransactionDefinition</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> (definition != <span class="hljs-literal">null</span> ? definition : TransactionDefinition.withDefaults());
    
    <span class="hljs-comment">// 2. 获取现有事务（处理传播行为）</span>
    <span class="hljs-type">Object</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> doGetTransaction();
    
    <span class="hljs-comment">// 3. 检查当前是否存在事务</span>
    <span class="hljs-keyword">if</span> (isExistingTransaction(transaction)) {
        <span class="hljs-comment">// 已存在事务：根据传播行为处理</span>
        <span class="hljs-keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);
    }
    
    <span class="hljs-comment">// 4. 没有现有事务：检查超时等设置</span>
    <span class="hljs-keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidTimeoutException</span>(<span class="hljs-string">"Invalid transaction timeout"</span>, def.getTimeout());
    }
    
    <span class="hljs-comment">// 5. 需要新事务：PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW, PROPAGATION_NESTED</span>
    <span class="hljs-keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalTransactionStateException</span>(<span class="hljs-string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
        
        <span class="hljs-comment">// 挂起现有资源（如果有）</span>
        <span class="hljs-type">SuspendedResourcesHolder</span> <span class="hljs-variable">suspendedResources</span> <span class="hljs-operator">=</span> suspend(<span class="hljs-literal">null</span>);
        
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">boolean</span> <span class="hljs-variable">newSynchronization</span> <span class="hljs-operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
            <span class="hljs-type">DefaultTransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> newTransactionStatus(
                def, transaction, <span class="hljs-literal">true</span>, newSynchronization, debugEnabled, suspendedResources);
            
            <span class="hljs-comment">// 关键：开始新事务</span>
            doBegin(transaction, def);
            prepareSynchronization(status, def);
            <span class="hljs-keyword">return</span> status;
        }
        <span class="hljs-keyword">catch</span> (RuntimeException | Error ex) {
            resume(<span class="hljs-literal">null</span>, suspendedResources);
            <span class="hljs-keyword">throw</span> ex;
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 6. 空事务：PROPAGATION_SUPPORTS, PROPAGATION_NOT_SUPPORTED, PROPAGATION_NEVER</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">newSynchronization</span> <span class="hljs-operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        <span class="hljs-keyword">return</span> prepareTransactionStatus(def, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, newSynchronization, debugEnabled, <span class="hljs-literal">null</span>);
    }
}
</code></pre>
<h3 data-id="heading-3">二、异常回滚</h3>
<p>执行回滚 ： 匹配指定设置的异常，匹配不到就匹配 RuntimeException 或 Error</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completeTransactionAfterThrowing</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> {
    <span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// 关键：根据回滚规则决定是否回滚</span>
        <span class="hljs-keyword">if</span> (txInfo.transactionAttribute != <span class="hljs-literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 执行回滚 ： 匹配指定设置的异常，匹配不到就匹配 RuntimeException 或 Error</span>
                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
            }
            <span class="hljs-keyword">catch</span> (TransactionSystemException ex2) {
                <span class="hljs-comment">// 记录错误但不抛出</span>
                logger.error(<span class="hljs-string">"Application exception overridden by rollback exception"</span>, ex);
                ex2.initApplicationException(ex);
                <span class="hljs-keyword">throw</span> ex2;
            }
            <span class="hljs-keyword">catch</span> (RuntimeException | Error ex2) {
                logger.error(<span class="hljs-string">"Application exception overridden by rollback exception"</span>, ex);
                <span class="hljs-keyword">throw</span> ex2;
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 不满足回滚条件，提交事务</span>
            <span class="hljs-keyword">try</span> {
                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
            }
            <span class="hljs-keyword">catch</span> (TransactionSystemException ex2) {
                <span class="hljs-comment">// ... 异常处理</span>
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-4">三、为什么清理事务信息后才提交事务</h3>
<p>在标准事务分支执行逻辑如下，没有发生异常的情况就是先清理事务信息然后提交事务：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">try</span> {
    retVal = invocation.proceedWithInvocation();  <span class="hljs-comment">// 执行业务方法</span>
}
<span class="hljs-keyword">catch</span> (Throwable ex) {
    completeTransactionAfterThrowing(txInfo, ex);  <span class="hljs-comment">// 异常回滚</span>
    <span class="hljs-keyword">throw</span> ex;
}
<span class="hljs-keyword">finally</span> {
    cleanupTransactionInfo(txInfo);  <span class="hljs-comment">// 清理事务信息</span>
}

commitTransactionAfterReturning(txInfo);  <span class="hljs-comment">// 提交事务</span>
</code></pre>
<h4 data-id="heading-5">1.事务信息与事务状态分离</h4>
<p>首先理解两个关键概念：</p>
<ul>
<li><strong>TransactionInfo</strong>：线程绑定的事务上下文信息</li>
<li><strong>TransactionStatus</strong>：实际的事务状态（包含数据库连接、回滚标记等）</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionInfo</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PlatformTransactionManager transactionManager;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionAttribute transactionAttribute;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String joinpointIdentification;
    <span class="hljs-keyword">private</span> TransactionStatus transactionStatus;  <span class="hljs-comment">// 实际事务状态</span>
    <span class="hljs-keyword">private</span> TransactionInfo oldTransactionInfo;   <span class="hljs-comment">// 旧的事务信息（用于嵌套事务）</span>
}
</code></pre>
<p><strong>关键点</strong>：提交事务需要的是 <code>TransactionStatus</code>，而不是 <code>TransactionInfo</code>。清理的是线程绑定的上下文信息，而不是实际的事务状态。</p>
<h4 data-id="heading-6">2. cleanupTransactionInfo 实际做了什么？</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanupTransactionInfo</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionInfo txInfo)</span> {
    <span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// 恢复线程的事务状态到之前的状态</span>
        txInfo.restoreThreadLocalStatus();
    }
}

<span class="hljs-comment">// TransactionInfo.restoreThreadLocalStatus()</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreThreadLocalStatus</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 将线程绑定恢复到旧的事务信息（如果有的话）</span>
    TransactionSynchronizationManager.bindResource(
        <span class="hljs-built_in">this</span>.transactionManager, <span class="hljs-built_in">this</span>.oldTransactionInfo);
}
</code></pre>
<p><strong>重点</strong>：<code>cleanupTransactionInfo</code> 只是恢复线程的 ThreadLocal 状态，<strong>并不影响实际事务的连接和状态</strong>。</p>
<h4 data-id="heading-7">3. 详细执行时序分析</h4>
<p>可以看一下面事务嵌套的案例</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 事务A开始</span>
        userRepository.updateA();
        
        <span class="hljs-comment">// 调用 methodB（REQUIRES_NEW）</span>
        userServiceProxy.methodB();  <span class="hljs-comment">// 通过代理调用</span>
        
        <span class="hljs-comment">// 事务A继续</span>
        userRepository.updateA2();
    }
    
    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 事务B开始（挂起事务A）</span>
        logRepository.save();
        <span class="hljs-comment">// 事务B提交</span>
    }
}
</code></pre>
<p><strong>执行时序：</strong> 大概的逻辑就是，执行完一个事务就需要立即把当前事务方法的外层方法的事务给恢复（存在的话）。</p>
<pre><code class="hljs language-text" lang="text">时间轴：
│
├─ 进入 methodA()
│   ├─ 创建 TransactionInfo_A（绑定到 ThreadLocal）
│   ├─ 开始事务A
│   │
│   ├─ 调用 methodB()（通过代理）
│   │   ├─ 创建 TransactionInfo_B（绑定到 ThreadLocal，保存旧的 TransactionInfo_A）
│   │   ├─ 挂起事务A
│   │   ├─ 开始事务B
│   │   ├─ 执行业务逻辑
│   │   │
│   │   ├─ 清理阶段：
│   │   │   ├─ cleanupTransactionInfo(TransactionInfo_B) 
│   │   │   │   └─ 恢复 ThreadLocal 到 TransactionInfo_A ✓
│   │   │   │
│   │   │   ├─ 提交事务B ✓
│   │   │   │   └─ 需要事务B的 TransactionStatus，但不需要 ThreadLocal 的 TransactionInfo_B
│   │   │   │
│   │   │   └─ 恢复事务A
│   │   └─ 返回
│   │
│   └─ methodA 继续执行
│       ├─ 使用 TransactionInfo_A（已恢复）
│       ├─ 提交事务A
│       └─ 清理 TransactionInfo_A
└─ 结束
</code></pre>
<h4 data-id="heading-8">4. 提交事务不需要 ThreadLocal 绑定</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// AbstractPlatformTransactionManager.commit()</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException {
    <span class="hljs-comment">// 直接从 TransactionStatus 获取实际事务对象</span>
    <span class="hljs-type">DefaultTransactionStatus</span> <span class="hljs-variable">defStatus</span> <span class="hljs-operator">=</span> (DefaultTransactionStatus) status;
    
    <span class="hljs-comment">// 检查是否需要回滚</span>
    <span class="hljs-keyword">if</span> (defStatus.isLocalRollbackOnly() || defStatus.isGlobalRollbackOnly()) {
        processRollback(defStatus, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-comment">// 实际提交</span>
    processCommit(defStatus);
}

<span class="hljs-comment">// DataSourceTransactionManager.doCommit()</span>
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doCommit</span><span class="hljs-params">(DefaultTransactionStatus status)</span> {
    <span class="hljs-type">DataSourceTransactionObject</span> <span class="hljs-variable">txObject</span> <span class="hljs-operator">=</span> (DataSourceTransactionObject) status.getTransaction();
    <span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> txObject.getConnectionHolder().getConnection();
    
    <span class="hljs-comment">// 直接使用连接提交</span>
    con.commit();  <span class="hljs-comment">// 不需要 ThreadLocal 信息</span>
}
</code></pre>
<p><strong>关键</strong>：提交操作只需要：</p>
<ol>
<li>数据库连接（从 TransactionStatus 获取）</li>
<li>事务状态（是否标记为回滚）</li>
</ol>
<blockquote>
<p>❗明白事务传播机制以及事务的相关信息是绑定到ThreadLocal中之后，用异步的时候就要注意事务失效的问题了</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🔥 数据库表还可以这样用——你真的只用它存数据吗？]]></title>    <link>https://juejin.cn/post/7591744411739160576</link>    <guid>https://juejin.cn/post/7591744411739160576</guid>    <pubDate>2026-01-06T01:37:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591744411739160576" data-draft-id="7588098335790874624" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🔥 数据库表还可以这样用——你真的只用它存数据吗？"/> <meta itemprop="keywords" content="后端,MySQL,SQL"/> <meta itemprop="datePublished" content="2026-01-06T01:37:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Sailing"/> <meta itemprop="url" content="https://juejin.cn/user/307518988100237"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🔥 数据库表还可以这样用——你真的只用它存数据吗？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/307518988100237/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Sailing
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T01:37:33.000Z" title="Tue Jan 06 2026 01:37:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>很多开发者习惯把数据库表当“存储桶”：存数据、查数据、删数据就完事了。</p>
<p>但如果你还停留在这个认知，你可能<strong>错过了数据库真正的价值</strong>——一张设计合理的表，完全可以成为 <strong>动态配置、业务策略和系统运营的秘密武器</strong>。学会这一点，你的系统灵活度和可维护性能立刻翻倍。</p>
<p>本文就以 <strong>系统配置表（system_config）</strong> 为例，聊聊数据库表还能这样用。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0609f81aed0a47829af4ab0d87f5328c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2FpbGluZw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768268253&amp;x-signature=rRiAJaahrka263GcKhowFNcoqMg%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-0">传统用途 vs 潜在用途</h2>
<h3 data-id="heading-1">传统用途</h3>
<p>大多数开发者的第一印象是这样：用数据库表存储业务数据，比如用户信息、订单、日志等。典型场景是：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users (
  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,
  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),
  email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),
  created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
);
</code></pre>
<p>存储、查询、统计——没错，但这只是数据库表的最基础用途。</p>
<h3 data-id="heading-2">潜在用途（系统配置表）</h3>
<p>如果我们稍微跳出思路，一张表完全可以承担 <strong>系统配置、功能开关、规则参数</strong> 等动态可配置的角色：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建库表</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> system_config (
  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,
  config_key <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">'配置键'</span>,
  config_value <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">500</span>) COMMENT <span class="hljs-string">'配置值'</span>,
  description <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">'配置说明'</span>,
  created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,
  updated_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">'系统配置表'</span>;
</code></pre>
<p>这意味着你可以：</p>
<ul>
<li>即时开启/关闭功能：<code>enable_ai_hackathon = true</code></li>
<li>调整业务参数：<code>max_team_member = 5</code></li>
<li>变更文案链接：<code>hackathon_rule_url = https://...</code></li>
</ul>
<p><strong>插入与更新示例：</strong></p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 新增配置</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> system_config (config_key, config_value, description)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'enable_ai'</span>, <span class="hljs-string">'true'</span>, <span class="hljs-string">'是否开启 AI'</span>);

<span class="hljs-comment">-- 调整参数</span>
<span class="hljs-keyword">UPDATE</span> system_config
<span class="hljs-keyword">SET</span> config_value <span class="hljs-operator">=</span> <span class="hljs-string">'false'</span>
<span class="hljs-keyword">WHERE</span> config_key <span class="hljs-operator">=</span> <span class="hljs-string">'enable_ai'</span>;
</code></pre>
<blockquote>
<p>小技巧：这样做，你就能在不改代码的情况下，动态调整系统行为。</p>
</blockquote>
<h2 data-id="heading-3">为什么用表做配置比环境变量更灵活</h2>
<p>很多人第一反应：<code>env</code> 文件或者 Redis 更方便啊！</p>
<p>表格帮你对比一下：</p>









































<table><thead><tr><th>维度</th><th>数据库配置</th><th>环境变量</th><th>Redis</th></tr></thead><tbody><tr><td>持久化</td><td>✅</td><td>✅</td><td>⚠️</td></tr><tr><td>动态修改</td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td>重启生效</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>后台管理</td><td>✅</td><td>❌</td><td>⚠️</td></tr><tr><td>审计 &amp; 历史</td><td>✅</td><td>❌</td><td>⚠️</td></tr></tbody></table>
<p>数据库配置表是 <strong>业务配置的“真源”</strong> ，支持动态调整、后台管理，还能保留审计记录。</p>
<p>Redis 可以做缓存加速，env 文件管理启动级配置和敏感信息，三者结合就是成熟的<strong>三层配置体系</strong>。</p>
<h2 data-id="heading-4">延伸玩法：让表不仅存数据</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f16d49d6f574e1b9a61f24b5b8464aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2FpbGluZw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768268253&amp;x-signature=E5dHZR1%2FdJuQE2QnvxGRlivppD4%3D" alt="image.png" loading="lazy"/></p>
<p>除了配置表，数据库表还有其他“不只是存数据”的玩法。下面用 SQL 示例说明：</p>
<h3 data-id="heading-5">1.  <strong>灰度策略表</strong></h3>
<p>用来存 AB 测试或实验参数，比如新功能只给部分用户看到。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建库表</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> feature_flag (
  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,
  feature_key <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">'功能标识'</span>,
  group_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">'分组，例如 A/B 测试分组'</span>,
  enabled <span class="hljs-type">BOOLEAN</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">FALSE</span> COMMENT <span class="hljs-string">'是否启用'</span>,
  updated_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
);

<span class="hljs-comment">-- 新增数据</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> feature_flag (feature_key, group_name, enabled)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'new_ui'</span>, <span class="hljs-string">'group_A'</span>, <span class="hljs-literal">TRUE</span>);
</code></pre>
<h3 data-id="heading-6">2. <strong>功能开关表</strong></h3>
<p>控制系统某个功能是否开启，无需改代码重新部署。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建库表</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> feature_switch (
  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,
  switch_key <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">'开关标识'</span>,
  is_on <span class="hljs-type">BOOLEAN</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">FALSE</span> COMMENT <span class="hljs-string">'开关状态'</span>,
  updated_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
);

<span class="hljs-comment">-- 调整参数</span>
<span class="hljs-keyword">UPDATE</span> feature_switch
<span class="hljs-keyword">SET</span> is_on <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span>
<span class="hljs-keyword">WHERE</span> switch_key <span class="hljs-operator">=</span> <span class="hljs-string">'enable_ai'</span>;
</code></pre>
<h3 data-id="heading-7">3. <strong>审计日志表</strong></h3>
<p>不参与系统动态行为，它仅仅是记录操作历史，方便排查。举例：<code>user_id=123, action='delete', target_id=456</code>。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建库表</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> audit_log (
  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,
  user_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  action <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  target_id <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">'操作对象'</span>,
  created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
);

<span class="hljs-comment">-- 新增数据</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> audit_log (user_id, action, target_id)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-number">123</span>, <span class="hljs-string">'delete'</span>, <span class="hljs-number">456</span>);
</code></pre>
<h3 data-id="heading-8">4.  <strong>临时任务表</strong></h3>
<p>存定时任务或状态信息，让系统按照表里的数据自动执行操作。举例：任务队列 <code>task_name='send_email', status='pending'</code>，系统会定期检查并执行。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 创建库表</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> scheduled_task (
  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,
  task_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  status <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'pending'</span> COMMENT <span class="hljs-string">'任务状态: pending/running/done'</span>,
  execute_at <span class="hljs-type">TIMESTAMP</span> COMMENT <span class="hljs-string">'计划执行时间'</span>
);

<span class="hljs-comment">-- 新增数据</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> scheduled_task (task_name, status, execute_at)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'send_email'</span>, <span class="hljs-string">'pending'</span>, <span class="hljs-string">'2025-12-28 10:00:00'</span>);
</code></pre>
<blockquote>
<p>核心思想：把“<strong>动态、可调整、系统关键信息</strong>”放在表里，而不是写死在代码里或配置文件里，这样系统更灵活、更可控。</p>
</blockquote>
<h2 data-id="heading-9">总结</h2>
<p>数据库表不仅是存数据的容器，它还是<strong>动态配置中心</strong>等。帮助我们提升项目的灵活度、运维、风控，如果你也是将系统配置放到环境变量，不妨试试放到数据库表中。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[手写Spring IoC：注解+反射打造轻量级容器]]></title>    <link>https://juejin.cn/post/7591871204567810074</link>    <guid>https://juejin.cn/post/7591871204567810074</guid>    <pubDate>2026-01-06T03:45:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591871204567810074" data-draft-id="7591694511244787750" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="手写Spring IoC：注解+反射打造轻量级容器"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2026-01-06T03:45:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            手写Spring IoC：注解+反射打造轻量级容器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:45:36.000Z" title="Tue Jan 06 2026 03:45:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">手写Spring IoC：注解+反射打造轻量级容器</h2>
<blockquote>
<p>深入理解Spring IoC核心原理，通过注解和反射机制手写一个简易版IoC容器，掌握依赖注入的本质。</p>
</blockquote>
<h3 data-id="heading-1">1. 引言：Spring IoC的魔力</h3>
<p>在Spring框架中，IoC（控制反转）和DI（依赖注入）是最核心的概念。只需一个<code>@Autowired</code>注解，Spring就能自动帮我们注入依赖对象，这背后的原理是什么？</p>
<p>本文将通过<strong>注解+反射</strong>的方式，手写一个简易版Spring IoC容器，让你深入理解：</p>
<ul>
<li>注解是如何被扫描和解析的</li>
<li>Bean是如何被创建和管理的</li>
<li>依赖注入是如何实现的</li>
<li>Spring容器的运行机制</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8973d982964b4b1eab85947f180db86b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=psXeyOKXMKmYg1GutFFHZ0z9dnU%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-2">1.1 为什么要手写IoC？</h4>
<ul>
<li><strong>理解原理</strong> - 知其然更知其所以然</li>
<li><strong>面试必备</strong> - Spring IoC是面试高频考点</li>
<li><strong>提升能力</strong> - 掌握反射、注解等核心技术</li>
<li><strong>框架选型</strong> - 理解框架设计思想</li>
</ul>
<hr/>
<h3 data-id="heading-3">2. 核心概念：IoC、DI、注解、反射</h3>
<h4 data-id="heading-4">2.1 控制反转（IoC）</h4>
<p><strong>传统方式</strong>：对象自己创建依赖</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>(); <span class="hljs-comment">// 主动创建</span>
}
</code></pre>
<p><strong>IoC方式</strong>：对象由容器创建和注入</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDao userDao; <span class="hljs-comment">// 被动接收</span>
}
</code></pre>
<p><strong>控制反转</strong>就是把对象创建和依赖管理的控制权，从应用代码转移到IoC容器。</p>
<h4 data-id="heading-5">2.2 依赖注入（DI）</h4>
<p>依赖注入是IoC的实现方式，有三种注入方式：</p>
<p><strong>① 构造器注入</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDao userDao;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">(UserDao userDao)</span> {
        <span class="hljs-built_in">this</span>.userDao = userDao;
    }
}
</code></pre>
<p><strong>② Setter注入</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> UserDao userDao;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> {
        <span class="hljs-built_in">this</span>.userDao = userDao;
    }
}
</code></pre>
<p><strong>③ 字段注入</strong>（最常用）</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDao userDao;
}
</code></pre>
<h4 data-id="heading-6">2.3 Java注解</h4>
<p>注解是Java 5引入的元数据标记机制。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 定义注解</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 运行时保留</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>           <span class="hljs-comment">// 作用于类</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Component {
    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">""</span>;
}

<span class="hljs-comment">// 使用注解</span>
<span class="hljs-meta">@Component("userService")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
}
</code></pre>
<h4 data-id="heading-7">2.4 Java反射</h4>
<p>反射允许程序在运行时动态获取类信息并操作对象。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 加载类</span>
Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.example.UserService"</span>);

<span class="hljs-comment">// 检查注解</span>
<span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(Component.class)) {
    <span class="hljs-type">Component</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> clazz.getAnnotation(Component.class);
    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> component.value();
}

<span class="hljs-comment">// 创建实例</span>
<span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor().newInstance();

<span class="hljs-comment">// 获取字段</span>
Field[] fields = clazz.getDeclaredFields();

<span class="hljs-comment">// 设置字段值</span>
field.setAccessible(<span class="hljs-literal">true</span>);
field.set(instance, value);
</code></pre>
<hr/>
<h3 data-id="heading-8">3. 第一步：定义核心注解</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ddbd78b7e934e5182131b248e56cc9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=ra%2BrLzOTjz6FwTJdqvPd3hTz0z4%3D" alt="" loading="lazy"/></p>
<p>首先定义我们自己的注解，模拟Spring的核心注解。</p>
<h4 data-id="heading-9">3.1 @Component注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * 标记组件类，类似Spring的<span class="hljs-doctag">@Component</span>
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Component {
    <span class="hljs-comment">/**
     * Bean名称，默认为类名首字母小写
     */</span>
    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">""</span>;
}
</code></pre>
<h4 data-id="heading-10">3.2 @Autowired注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * 自动注入依赖，类似Spring的<span class="hljs-doctag">@Autowired</span>
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired {
    <span class="hljs-comment">/**
     * 是否必须注入
     */</span>
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<h4 data-id="heading-11">3.3 @Qualifier注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * 指定要注入的Bean名称
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target({ElementType.FIELD, ElementType.PARAMETER})</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Qualifier {
    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;
}
</code></pre>
<h4 data-id="heading-12">3.4 @Scope注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * 指定Bean的作用域
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Scope {
    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">"singleton"</span>;
}
</code></pre>
<hr/>
<h3 data-id="heading-13">4. 第二步：实现包扫描器</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4af5705699904ec59afb178a2de40530~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=hGjQnrutKn0W7I6011yrjaXuUkg%3D" alt="" loading="lazy"/></p>
<p>包扫描器负责扫描指定包下的所有类，找出带有<code>@Component</code>注解的类。</p>
<h4 data-id="heading-14">4.1 ClassScanner类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> com.myspring.annotation.Component;
<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.net.URL;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-comment">/**
 * 类扫描器：扫描指定包下的所有类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassScanner</span> {

    <span class="hljs-comment">/**
     * 扫描指定包下带有<span class="hljs-doctag">@Component</span>注解的类
     *
     * <span class="hljs-doctag">@param</span> basePackage 基础包路径，如"com.example"
     * <span class="hljs-doctag">@return</span> 带有<span class="hljs-doctag">@Component</span>注解的Class列表
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Class&lt;?&gt;&gt; scanComponents(String basePackage) {
        List&lt;Class&lt;?&gt;&gt; classList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 将包名转换为路径</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">packagePath</span> <span class="hljs-operator">=</span> basePackage.replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>);

            <span class="hljs-comment">// 获取包的URL路径</span>
            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();
            <span class="hljs-type">URL</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> classLoader.getResource(packagePath);

            <span class="hljs-keyword">if</span> (resource == <span class="hljs-literal">null</span>) {
                System.out.println(<span class="hljs-string">"包路径不存在: "</span> + basePackage);
                <span class="hljs-keyword">return</span> classList;
            }

            <span class="hljs-comment">// 获取包的文件路径</span>
            <span class="hljs-type">File</span> <span class="hljs-variable">packageDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(resource.getFile());

            <span class="hljs-comment">// 递归扫描所有类文件</span>
            scanClasses(packageDir, basePackage, classList);

        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }

        <span class="hljs-keyword">return</span> classList;
    }

    <span class="hljs-comment">/**
     * 递归扫描目录下的所有类文件
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scanClasses</span><span class="hljs-params">(File dir, String packageName, List&lt;Class&lt;?&gt;&gt; classList)</span> {
        <span class="hljs-keyword">if</span> (!dir.exists() || !dir.isDirectory()) {
            <span class="hljs-keyword">return</span>;
        }

        File[] files = dir.listFiles();
        <span class="hljs-keyword">if</span> (files == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">for</span> (File file : files) {
            <span class="hljs-keyword">if</span> (file.isDirectory()) {
                <span class="hljs-comment">// 递归扫描子目录</span>
                scanClasses(file, packageName + <span class="hljs-string">"."</span> + file.getName(), classList);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">".class"</span>)) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 获取类名</span>
                    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> packageName + <span class="hljs-string">"."</span> +
                        file.getName().replace(<span class="hljs-string">".class"</span>, <span class="hljs-string">""</span>);

                    <span class="hljs-comment">// 加载类</span>
                    Class&lt;?&gt; clazz = Class.forName(className);

                    <span class="hljs-comment">// 检查是否有@Component注解</span>
                    <span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(Component.class)) {
                        classList.add(clazz);
                        System.out.println(<span class="hljs-string">"扫描到组件: "</span> + className);
                    }

                } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-15">5. 第三步：创建Bean工厂</h3>
<p>Bean工厂负责存储和管理所有的Bean实例。</p>
<h4 data-id="heading-16">5.1 BeanDefinition类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-comment">/**
 * Bean定义信息
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanDefinition</span> {
    <span class="hljs-keyword">private</span> String beanName;
    <span class="hljs-keyword">private</span> Class&lt;?&gt; beanClass;
    <span class="hljs-keyword">private</span> String scope;
    <span class="hljs-keyword">private</span> Object singletonInstance;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BeanDefinition</span><span class="hljs-params">(String beanName, Class&lt;?&gt; beanClass, String scope)</span> {
        <span class="hljs-built_in">this</span>.beanName = beanName;
        <span class="hljs-built_in">this</span>.beanClass = beanClass;
        <span class="hljs-built_in">this</span>.scope = scope;
    }

    <span class="hljs-comment">// Getter和Setter方法</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBeanName</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> beanName; }
    <span class="hljs-keyword">public</span> Class&lt;?&gt; getBeanClass() { <span class="hljs-keyword">return</span> beanClass; }
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getScope</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> scope; }
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingletonInstance</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> singletonInstance; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSingletonInstance</span><span class="hljs-params">(Object instance)</span> {
        <span class="hljs-built_in">this</span>.singletonInstance = instance;
    }
}
</code></pre>
<h4 data-id="heading-17">5.2 BeanFactory类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> com.myspring.annotation.Component;
<span class="hljs-keyword">import</span> com.myspring.annotation.Scope;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;

<span class="hljs-comment">/**
 * Bean工厂：创建和管理Bean实例
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanFactory</span> {

    <span class="hljs-comment">// 存储Bean定义信息</span>
    <span class="hljs-keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();

    <span class="hljs-comment">/**
     * 注册Bean定义
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> {
        <span class="hljs-comment">// 获取Bean名称</span>
        <span class="hljs-type">Component</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> clazz.getAnnotation(Component.class);
        <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> component.value();
        <span class="hljs-keyword">if</span> (beanName.isEmpty()) {
            <span class="hljs-comment">// 默认使用类名首字母小写</span>
            beanName = toLowerFirstCase(clazz.getSimpleName());
        }

        <span class="hljs-comment">// 获取作用域</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-string">"singleton"</span>;
        <span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(Scope.class)) {
            <span class="hljs-type">Scope</span> <span class="hljs-variable">scopeAnnotation</span> <span class="hljs-operator">=</span> clazz.getAnnotation(Scope.class);
            scope = scopeAnnotation.value();
        }

        <span class="hljs-comment">// 创建BeanDefinition并注册</span>
        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinition</span>(beanName, clazz, scope);
        beanDefinitionMap.put(beanName, beanDefinition);

        System.out.println(<span class="hljs-string">"注册Bean: "</span> + beanName + <span class="hljs-string">", 作用域: "</span> + scope);
    }

    <span class="hljs-comment">/**
     * 获取Bean实例
     */</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> {
        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> beanDefinitionMap.get(beanName);
        <span class="hljs-keyword">if</span> (beanDefinition == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Bean不存在: "</span> + beanName);
        }

        <span class="hljs-comment">// 单例模式</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"singleton"</span>.equals(beanDefinition.getScope())) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> beanDefinition.getSingletonInstance();
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) {
                instance = createBean(beanDefinition);
                beanDefinition.setSingletonInstance(instance);
            }
            <span class="hljs-keyword">return</span> instance;
        }

        <span class="hljs-comment">// 原型模式：每次都创建新实例</span>
        <span class="hljs-keyword">return</span> createBean(beanDefinition);
    }

    <span class="hljs-comment">/**
     * 根据类型获取Bean
     */</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> {
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanDefinitionMap.values()) {
            <span class="hljs-keyword">if</span> (clazz.isAssignableFrom(bd.getBeanClass())) {
                <span class="hljs-keyword">return</span> getBean(bd.getBeanName());
            }
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"Bean不存在: "</span> + clazz.getName());
    }

    <span class="hljs-comment">/**
     * 创建Bean实例
     */</span>
    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(BeanDefinition beanDefinition)</span> {
        <span class="hljs-keyword">try</span> {
            Class&lt;?&gt; clazz = beanDefinition.getBeanClass();
            <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor().newInstance();
            System.out.println(<span class="hljs-string">"创建Bean实例: "</span> + beanDefinition.getBeanName());
            <span class="hljs-keyword">return</span> instance;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"创建Bean失败: "</span> +
                beanDefinition.getBeanName(), e);
        }
    }

    <span class="hljs-comment">/**
     * 首字母小写
     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">toLowerFirstCase</span><span class="hljs-params">(String str)</span> {
        <span class="hljs-type">char</span>[] chars = str.toCharArray();
        chars[<span class="hljs-number">0</span>] += <span class="hljs-number">32</span>;
        <span class="hljs-keyword">return</span> String.valueOf(chars);
    }

    <span class="hljs-comment">/**
     * 获取所有Bean名称
     */</span>
    <span class="hljs-keyword">public</span> Map&lt;String, BeanDefinition&gt; <span class="hljs-title function_">getBeanDefinitions</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> beanDefinitionMap;
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-18">6. 第四步：实现依赖注入</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95a946239e474c49afa084fedc306c28~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=DVcfiJ9%2B0hiocLdWCI52ymbIc6o%3D" alt="" loading="lazy"/></p>
<p>依赖注入是IoC容器的核心功能，通过反射自动为Bean注入依赖。</p>
<h4 data-id="heading-19">6.1 DependencyInjector类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> com.myspring.annotation.Autowired;
<span class="hljs-keyword">import</span> com.myspring.annotation.Qualifier;
<span class="hljs-keyword">import</span> java.lang.reflect.Field;

<span class="hljs-comment">/**
 * 依赖注入器：为Bean注入依赖
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyInjector</span> {

    <span class="hljs-keyword">private</span> BeanFactory beanFactory;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DependencyInjector</span><span class="hljs-params">(BeanFactory beanFactory)</span> {
        <span class="hljs-built_in">this</span>.beanFactory = beanFactory;
    }

    <span class="hljs-comment">/**
     * 为所有Bean执行依赖注入
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">injectDependencies</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanFactory.getBeanDefinitions().values()) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanFactory.getBean(bd.getBeanName());
            injectBean(bean);
        }
    }

    <span class="hljs-comment">/**
     * 为单个Bean注入依赖
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">injectBean</span><span class="hljs-params">(Object bean)</span> {
        Class&lt;?&gt; clazz = bean.getClass();

        <span class="hljs-comment">// 获取所有字段</span>
        Field[] fields = clazz.getDeclaredFields();

        <span class="hljs-keyword">for</span> (Field field : fields) {
            <span class="hljs-comment">// 检查是否有@Autowired注解</span>
            <span class="hljs-keyword">if</span> (!field.isAnnotationPresent(Autowired.class)) {
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-type">Autowired</span> <span class="hljs-variable">autowired</span> <span class="hljs-operator">=</span> field.getAnnotation(Autowired.class);

            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 确定要注入的Bean</span>
                <span class="hljs-type">Object</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

                <span class="hljs-comment">// 检查是否有@Qualifier指定Bean名称</span>
                <span class="hljs-keyword">if</span> (field.isAnnotationPresent(Qualifier.class)) {
                    <span class="hljs-type">Qualifier</span> <span class="hljs-variable">qualifier</span> <span class="hljs-operator">=</span> field.getAnnotation(Qualifier.class);
                    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> qualifier.value();
                    dependency = beanFactory.getBean(beanName);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 根据类型查找Bean</span>
                    dependency = beanFactory.getBean(field.getType());
                }

                <span class="hljs-comment">// 反射设置字段值</span>
                field.setAccessible(<span class="hljs-literal">true</span>);
                field.set(bean, dependency);

                System.out.println(<span class="hljs-string">"注入依赖: "</span> + clazz.getSimpleName() +
                    <span class="hljs-string">"."</span> + field.getName());

            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-keyword">if</span> (autowired.required()) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"依赖注入失败: "</span> +
                        clazz.getSimpleName() + <span class="hljs-string">"."</span> + field.getName(), e);
                }
            }
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-20">7. 第五步：完善生命周期</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b1c98c1e6b1400dab18685675fd8503~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=o%2BpKs8o%2Fd4yWCSXFgxEllUuttSg%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-21">7.1 生命周期注解</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * Bean初始化后调用
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.METHOD)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> PostConstruct {
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.annotation;

<span class="hljs-keyword">import</span> java.lang.annotation.*;

<span class="hljs-comment">/**
 * Bean销毁前调用
 */</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.METHOD)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> PreDestroy {
}
</code></pre>
<h4 data-id="heading-22">7.2 生命周期管理器</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> com.myspring.annotation.PostConstruct;
<span class="hljs-keyword">import</span> com.myspring.annotation.PreDestroy;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;

<span class="hljs-comment">/**
 * Bean生命周期管理器
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleManager</span> {

    <span class="hljs-comment">/**
     * 执行初始化方法
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeInitMethod</span><span class="hljs-params">(Object bean)</span> {
        Class&lt;?&gt; clazz = bean.getClass();
        Method[] methods = clazz.getDeclaredMethods();

        <span class="hljs-keyword">for</span> (Method method : methods) {
            <span class="hljs-keyword">if</span> (method.isAnnotationPresent(PostConstruct.class)) {
                <span class="hljs-keyword">try</span> {
                    method.setAccessible(<span class="hljs-literal">true</span>);
                    method.invoke(bean);
                    System.out.println(<span class="hljs-string">"执行初始化方法: "</span> +
                        clazz.getSimpleName() + <span class="hljs-string">"."</span> + method.getName());
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">"初始化方法执行失败"</span>, e);
                }
            }
        }
    }

    <span class="hljs-comment">/**
     * 执行销毁方法
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeDestroyMethod</span><span class="hljs-params">(Object bean)</span> {
        Class&lt;?&gt; clazz = bean.getClass();
        Method[] methods = clazz.getDeclaredMethods();

        <span class="hljs-keyword">for</span> (Method method : methods) {
            <span class="hljs-keyword">if</span> (method.isAnnotationPresent(PreDestroy.class)) {
                <span class="hljs-keyword">try</span> {
                    method.setAccessible(<span class="hljs-literal">true</span>);
                    method.invoke(bean);
                    System.out.println(<span class="hljs-string">"执行销毁方法: "</span> +
                        clazz.getSimpleName() + <span class="hljs-string">"."</span> + method.getName());
                } <span class="hljs-keyword">catch</span> (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-23">8. 完整示例：使用手写IoC</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7225b7399aa845969344a1bd35e85acc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768275935&amp;x-signature=9f5E7fmFFl60d8nQ0ZgahrLKiw8%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-24">8.1 创建ApplicationContext</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.myspring.core;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-comment">/**
 * 应用上下文：整合所有功能
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContext</span> {

    <span class="hljs-keyword">private</span> BeanFactory beanFactory;
    <span class="hljs-keyword">private</span> DependencyInjector injector;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ApplicationContext</span><span class="hljs-params">(String basePackage)</span> {
        <span class="hljs-comment">// 1. 创建Bean工厂</span>
        beanFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactory</span>();

        <span class="hljs-comment">// 2. 扫描组件</span>
        System.out.println(<span class="hljs-string">"========== 开始扫描组件 =========="</span>);
        List&lt;Class&lt;?&gt;&gt; componentClasses = ClassScanner.scanComponents(basePackage);

        <span class="hljs-comment">// 3. 注册Bean定义</span>
        System.out.println(<span class="hljs-string">"\n========== 注册Bean定义 =========="</span>);
        <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : componentClasses) {
            beanFactory.registerBeanDefinition(clazz);
        }

        <span class="hljs-comment">// 4. 实例化所有单例Bean</span>
        System.out.println(<span class="hljs-string">"\n========== 实例化单例Bean =========="</span>);
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanFactory.getBeanDefinitions().values()) {
            <span class="hljs-keyword">if</span> (<span class="hljs-string">"singleton"</span>.equals(bd.getScope())) {
                beanFactory.getBean(bd.getBeanName());
            }
        }

        <span class="hljs-comment">// 5. 依赖注入</span>
        System.out.println(<span class="hljs-string">"\n========== 执行依赖注入 =========="</span>);
        injector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyInjector</span>(beanFactory);
        injector.injectDependencies();

        <span class="hljs-comment">// 6. 执行初始化方法</span>
        System.out.println(<span class="hljs-string">"\n========== 执行初始化方法 =========="</span>);
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanFactory.getBeanDefinitions().values()) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanFactory.getBean(bd.getBeanName());
            LifecycleManager.invokeInitMethod(bean);
        }

        System.out.println(<span class="hljs-string">"\n========== IoC容器启动完成 ==========\n"</span>);
    }

    <span class="hljs-comment">/**
     * 获取Bean
     */</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> {
        <span class="hljs-keyword">return</span> beanFactory.getBean(beanName);
    }

    <span class="hljs-comment">/**
     * 根据类型获取Bean
     */</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> {
        <span class="hljs-keyword">return</span> (T) beanFactory.getBean(clazz);
    }

    <span class="hljs-comment">/**
     * 关闭容器
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"\n========== 关闭IoC容器 =========="</span>);
        <span class="hljs-keyword">for</span> (BeanDefinition bd : beanFactory.getBeanDefinitions().values()) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanFactory.getBean(bd.getBeanName());
            LifecycleManager.invokeDestroyMethod(bean);
        }
    }
}
</code></pre>
<h4 data-id="heading-25">8.2 编写测试类</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.dao;

<span class="hljs-keyword">import</span> com.myspring.annotation.Component;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"UserDao: 保存用户数据"</span>);
    }
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.service;

<span class="hljs-keyword">import</span> com.example.dao.UserDao;
<span class="hljs-keyword">import</span> com.myspring.annotation.Autowired;
<span class="hljs-keyword">import</span> com.myspring.annotation.Component;
<span class="hljs-keyword">import</span> com.myspring.annotation.PostConstruct;
<span class="hljs-keyword">import</span> com.myspring.annotation.PreDestroy;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDao userDao;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String username)</span> {
        System.out.println(<span class="hljs-string">"UserService: 注册用户 "</span> + username);
        userDao.save();
    }

    <span class="hljs-meta">@PostConstruct</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"UserService初始化完成"</span>);
    }

    <span class="hljs-meta">@PreDestroy</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"UserService准备销毁"</span>);
    }
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example;

<span class="hljs-keyword">import</span> com.example.service.UserService;
<span class="hljs-keyword">import</span> com.myspring.core.ApplicationContext;

<span class="hljs-comment">/**
 * 测试类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 创建IoC容器</span>
        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContext</span>(<span class="hljs-string">"com.example"</span>);

        <span class="hljs-comment">// 获取Bean并使用</span>
        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> context.getBean(UserService.class);
        userService.register(<span class="hljs-string">"张三"</span>);

        <span class="hljs-comment">// 关闭容器</span>
        context.close();
    }
}
</code></pre>
<h4 data-id="heading-26">8.3 运行输出</h4>
<pre><code class="hljs language-makefile" lang="makefile">========== 开始扫描组件 ==========
<span class="hljs-section">扫描到组件: com.example.dao.UserDao</span>
<span class="hljs-section">扫描到组件: com.example.service.UserService</span>

========== 注册Bean定义 ==========
<span class="hljs-section">注册Bean: userDao, 作用域: singleton</span>
<span class="hljs-section">注册Bean: userService, 作用域: singleton</span>

========== 实例化单例Bean ==========
<span class="hljs-section">创建Bean实例: userDao</span>
<span class="hljs-section">创建Bean实例: userService</span>

========== 执行依赖注入 ==========
<span class="hljs-section">注入依赖: UserService.userDao</span>

========== 执行初始化方法 ==========
<span class="hljs-section">执行初始化方法: UserService.init</span>
UserService初始化完成

========== IoC容器启动完成 ==========

<span class="hljs-section">UserService: 注册用户 张三</span>
<span class="hljs-section">UserDao: 保存用户数据</span>

========== 关闭IoC容器 ==========
<span class="hljs-section">执行销毁方法: UserService.destroy</span>
UserService准备销毁
</code></pre>
<hr/>
<h3 data-id="heading-27">9. 总结</h3>
<h4 data-id="heading-28">9.1 核心要点</h4>
<p>通过手写IoC容器，我们深入理解了：</p>
<ol>
<li><strong>注解机制</strong> - 使用<code>@Retention</code>、<code>@Target</code>定义注解</li>
<li><strong>反射技术</strong> - 类加载、实例创建、字段注入</li>
<li><strong>扫描解析</strong> - 递归扫描包路径，解析注解信息</li>
<li><strong>Bean管理</strong> - 单例/原型模式，Bean定义存储</li>
<li><strong>依赖注入</strong> - 自动查找和注入依赖对象</li>
<li><strong>生命周期</strong> - 初始化和销毁回调方法</li>
</ol>
<h4 data-id="heading-29">9.2 与Spring IoC的对比</h4>








































<table><thead><tr><th>功能</th><th>手写版本</th><th>Spring IoC</th></tr></thead><tbody><tr><td>注解扫描</td><td>简单递归</td><td>高性能ASM字节码扫描</td></tr><tr><td>Bean管理</td><td>Map存储</td><td>多级缓存+循环依赖处理</td></tr><tr><td>依赖注入</td><td>字段注入</td><td>字段+构造器+Setter</td></tr><tr><td>作用域</td><td>singleton/prototype</td><td>更多作用域</td></tr><tr><td>AOP支持</td><td>无</td><td>完整AOP框架</td></tr><tr><td>性能优化</td><td>基础</td><td>大量优化策略</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用填充表格法-吃透01背包及其变形]]></title>    <link>https://juejin.cn/post/7591788451029565483</link>    <guid>https://juejin.cn/post/7591788451029565483</guid>    <pubDate>2026-01-06T05:43:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591788451029565483" data-draft-id="7591948263859863590" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用填充表格法-吃透01背包及其变形"/> <meta itemprop="keywords" content="前端,后端,算法"/> <meta itemprop="datePublished" content="2026-01-06T05:43:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用填充表格法-吃透01背包及其变形
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T05:43:08.000Z" title="Tue Jan 06 2026 05:43:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读29分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">用填充表格法吃透01背包及其变形</h2>
<p>01背包问题是动态规划（Dynamic Programming, DP）领域最经典、最基础的模型之一，后续很多复杂的DP问题都可看作是它的变形或延伸。本文将从"表格可视化"核心思路出发，先通过空表格建立解题框架，再用DP解题5步"万能钥匙"逐步填充表格，最终覆盖基础01背包解法、空间优化技巧，以及4类经典变形的完整拆解（含代码实现），帮你彻底吃透01背包问题。</p>
<p>动态规划零基础的话，推荐先看<a href="https://juejin.cn/post/7591207451778875418" target="_blank" title="https://juejin.cn/post/7591207451778875418">从经典问题入手，吃透动态规划核心（DP五部曲实战）</a></p>
<p>核心前置认知：01背包的本质是"选或不选"的二选一决策——有n个物品，每个物品有重量和价值，背包有固定容量，要求选择若干物品放入背包，使得总重量不超过容量的前提下，总价值最大（基础模型）。后续所有变形都围绕"选或不选"的核心逻辑展开，只是"物品""容量""目标"的具体含义不同。</p>
<p>动态规划（Dynamic Programming, DP）解决问题的核心逻辑，本质是通过<strong>填充表格</strong>逐步推导最优解——把复杂的多阶段决策问题，转化为按规则填充表格的可视化过程。以01背包问题（最经典的DP模型）为例，我们先明确最终要填充的核心表格形态，后续所有解题步骤都是为了按规则完成这张表格，表格填完之时，就是问题解决之日。</p>
<p>01背包问题核心表格（空表，后续逐步填充）：</p>





















































<table><thead><tr><th>前i个物品\背包容量j</th><th>0（容量为0）</th><th>1（容量为1）</th><th>2（容量为2）</th><th>...（容量递增）</th><th>C（背包最大容量）</th></tr></thead><tbody><tr><td>0（无物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>1（第1个物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>2（第2个物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>...（物品递增）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>n（第n个物品）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充（最终答案）</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[i][j]</code>代表「前i个物品放入容量为j的背包的最大价值」，我们的目标就是按规则填充所有单元格，最终右下角<code>dp[n][C]</code>即为01背包问题的最优解。</p>
<p>要有序、正确地填充这张表格，需要遵循DP解题的5步「万能钥匙」——这是贯穿所有DP问题的通用拆解思路，每一步都对应表格填充的关键环节：</p>
<ol>
<li>
<p><strong>确定dp数组及下标的含义</strong>：定义表格中每个单元格的核心意义（即<code>dp[i][j]</code>代表什么），这是填充表格的基础；</p>
</li>
<li>
<p><strong>确定递推公式</strong>：明确单元格<code>dp[i][j]</code>的数值如何通过其他已填充单元格推导得出（即"选或不选"的决策逻辑），这是表格填充的核心规则；</p>
</li>
<li>
<p><strong>dp数组如何初始化</strong>：确定表格的初始状态（如无物品、容量为0时的单元格值），这是表格填充的起点；</p>
</li>
<li>
<p><strong>确定遍历顺序（表格填充顺序）</strong>：明确按什么顺序逐个填写表格中的单元格（如先逐行填、再逐列填），确保推导时依赖的单元格已提前填充；</p>
</li>
<li>
<p><strong>打印dp数组（验证）</strong>：通过逐步填充表格、打印中间结果，验证填充规则的正确性，避免逻辑偏差。</p>
</li>
</ol>
<p>后续所有01背包及变形问题的分析，都将围绕这5步「万能钥匙」展开，本质就是用这5步规则完成对应表格的填充，最终通过表格得到问题答案。</p>
<h3 data-id="heading-1">一、基础01背包（二维DP解法）</h3>
<p>我们先从最直观的二维DP解法入手，严格按照5步「万能钥匙」拆解，完整演示基础表格的填充过程。</p>
<p>示例：有4个物品，重量数组<code>weights = [2,3,4,5]</code>，价值数组<code>values = [3,4,5,6]</code>，背包最大容量<code>capacity = 8</code>，求能放入背包的最大价值。</p>
<h4 data-id="heading-2">1.1 步骤1：确定dp数组及下标的含义</h4>
<p>定义二维数组<code>dp[i][j]</code>：表示「前i个物品放入容量为j的背包中，能获得的最大价值」。</p>
<p>对应表格维度：i（行）表示物品数量（从0到4，0代表无物品），j（列）表示背包容量（从0到8，0代表容量为0），表格共5行9列（i:0-4，j:0-8）。</p>
<h4 data-id="heading-3">1.2 步骤2：确定递推公式</h4>
<p>对于第i个物品（重量<code>weights[i-1]</code>、价值<code>values[i-1]</code>，注意数组索引从0开始，i从1开始），有两种核心决策：选或不选。</p>
<ol>
<li>
<p><strong>不选第i个物品</strong>：前i个物品的最大价值 = 前i-1个物品的最大价值，即<code>dp[i][j] = dp[i-1][j]</code>；</p>
</li>
<li>
<p><strong>选第i个物品</strong>：需保证背包容量j ≥ 第i个物品的重量，此时最大价值 = 前i-1个物品放入容量j-weights[i-1]的背包的最大价值 + 第i个物品的价值，即<code>dp[i][j] = dp[i-1][j - weights[i-1]] + values[i-1]</code>。</p>
</li>
</ol>
<p>最终递推公式（取两种决策的最大值）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (j &lt; weights[i - <span class="hljs-number">1</span>]) {
  <span class="hljs-comment">// 容量不足，无法选第i个物品</span>
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 容量充足，选或不选取最大值</span>
  dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]);
}
</code></pre>
<p>这就是表格中每个单元格的填充规则——每个单元格的值要么继承上一行同列的值，要么继承上一行左侧对应容量的的值并加上当前物品价值，取两者最大。</p>
<h4 data-id="heading-4">1.3 步骤3：dp数组如何初始化</h4>
<p>初始化的核心是确定表格的“边界条件”，即无需推导就能直接确定的单元格值。</p>
<ol>
<li>
<p><strong>i=0（无物品）</strong>：无论背包容量j多大，放入0个物品的最大价值都是0，因此<code>dp[0][j] = 0</code>（表格第0行全为0）；</p>
</li>
<li>
<p><strong>j=0（容量为0）</strong>：无论有多少物品，都无法放入背包，最大价值都是0，因此<code>dp[i][0] = 0</code>（表格第0列全为0）。</p>
</li>
</ol>
<p>初始化后的表格（第0行、第0列已填充）：</p>













































































<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>0（无物品）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1（物品1：w=2,v=3）</td><td>0</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>2（物品2：w=3,v=4）</td><td>0</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>3（物品3：w=4,v=5）</td><td>0</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>4（物品4：w=5,v=6）</td><td>0</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr></tbody></table>
<h4 data-id="heading-5">1.4 步骤4：确定遍历顺序（表格填充顺序）</h4>
<p>遍历顺序直接对应二维表格的填充顺序——即「按什么顺序逐个填写表格中的单元格」，这里有两种可行方式：</p>
<ol>
<li>
<p><strong>先遍历物品（i从1到n），再遍历容量（j从1到C）</strong>：逐行填充表格，先填完第1个物品对应的所有容量（第1行），再填第2个物品对应的所有容量（第2行），直到填完所有物品；</p>
</li>
<li>
<p><strong>先遍历容量（j从1到C），再遍历物品（i从1到n）</strong>：逐列填充表格，先填完容量1对应的所有物品数量（第1列），再填容量2对应的所有物品数量（第2列），直到填完所有容量。</p>
</li>
</ol>
<p>两种顺序都可行，因为计算<code>dp[i][j]</code>时，只依赖上一行（<code>i-1</code>行）的结果，无论先填行还是先填列，上一行的对应位置都已提前计算完成。这就像填充一张二维表格：先遍历物品再遍历容量，是<strong>逐行填充</strong>（每一行对应一个物品的决策，填完一行再处理下一个物品）；先遍历容量再遍历物品，是<strong>逐列填充</strong>（每一列对应一个固定容量，先确定所有物品在该容量下的最优解）。实际解题中更常用「先遍历物品，再遍历容量」的顺序，符合我们「逐个考虑物品是否放入」的思考逻辑。</p>
<h4 data-id="heading-6">1.5 步骤5：打印dp数组（验证）</h4>
<p>这一步是直接验证表格填充结果的正确性——通过逐步填充表格、打印中间状态，确认每一步都符合递推规则，避免因规则理解偏差导致填充错误。以示例<code>weights = [2,3,4,5]</code>、<code>values = [3,4,5,6]</code>、<code>capacity = 8</code>为例，逐步填充核心表格验证逻辑：</p>
<ol>
<li>
<p><strong>填充第1行（i=1，物品1：w=2,v=3）</strong>：</p>
<p>填充后第1行：[0,0,3,3,3,3,3,3,3]</p>
<ul>
<li>
<p>j=1：容量&lt;2，无法选，dp[1][1] = dp[0][1] = 0；</p>
</li>
<li>
<p>j=2：容量≥2，选则价值=dp[0][0]+3=3，不选则0，取max=3；</p>
</li>
<li>
<p>j=3-8：选则价值=dp[0][j-2]+3=3，不选则0，取max=3；</p>
</li>
</ul>
</li>
<li>
<p><strong>填充第2行（i=2，物品2：w=3,v=4）</strong>：</p>
<p>填充后第2行：[0,0,3,4,4,7,7,7,7]</p>
<ul>
<li>
<p>j=1-2：容量&lt;3，dp[2][j] = dp[1][j]（0,3）；</p>
</li>
<li>
<p>j=3：选则dp[1][0]+4=4，不选则3，取max=4；</p>
</li>
<li>
<p>j=4：选则dp[1][1]+4=4，不选则3，取max=4；</p>
</li>
<li>
<p>j=5：选则dp[1][2]+4=3+4=7，不选则3，取max=7；</p>
</li>
<li>
<p>j=6-8：选则dp[1][j-3]+4=3+4=7，不选则3，取max=7；</p>
</li>
</ul>
</li>
<li>
<p><strong>填充第3行（i=3，物品3：w=4,v=5）</strong>：</p>
<p>填充后第3行：[0,0,3,4,5,5,8,9,9]</p>
<ul>
<li>
<p>j=1-3：容量&lt;4，dp[3][j] = dp[2][j]（0,0,3）；</p>
</li>
<li>
<p>j=4：选则dp[2][0]+5=5，不选则4，取max=5；</p>
</li>
<li>
<p>j=5：选则dp[2][1]+5=5，不选则4，取max=5；</p>
</li>
<li>
<p>j=6：选则dp[2][2]+5=3+5=8，不选则7，取max=8；</p>
</li>
<li>
<p>j=7：选则dp[2][3]+5=4+5=9，不选则7，取max=9；</p>
</li>
<li>
<p>j=8：选则dp[2][4]+5=4+5=9，不选则7，取max=9；</p>
</li>
</ul>
</li>
<li>
<p><strong>填充第4行（i=4，物品4：w=5,v=6）</strong>：</p>
<p>填充后第4行：[0,0,3,4,5,6,8,9,10]</p>
<ul>
<li>
<p>j=1-4：容量&lt;5，dp[4][j] = dp[3][j]（0,0,3,4）；</p>
</li>
<li>
<p>j=5：选则dp[3][0]+6=6，不选则5，取max=6；</p>
</li>
<li>
<p>j=6：选则dp[3][1]+6=6，不选则8，取max=8；</p>
</li>
<li>
<p>j=7：选则dp[3][2]+6=3+6=9，不选则9，取max=9；</p>
</li>
<li>
<p>j=8：选则dp[3][3]+6=4+6=10，不选则9，取max=10；</p>
</li>
</ul>
</li>
</ol>
<p>最终填充完成的表格：</p>













































































<table><thead><tr><th>前i个物品\背包容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>0（无物品）</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1（物品1：w=2,v=3）</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>2（物品2：w=3,v=4）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td>3（物品3：w=4,v=5）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>5</td><td>8</td><td>9</td><td>9</td></tr><tr><td>4（物品4：w=5,v=6）</td><td>0</td><td>0</td><td>3</td><td>4</td><td>5</td><td>6</td><td>8</td><td>9</td><td>10</td></tr></tbody></table>
<p>表格右下角<code>dp[4][8] = 10</code>，即该示例的最大价值为10，与预期结果一致。</p>
<h4 data-id="heading-7">1.6 基础二维DP完整代码（JavaScript）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 基础01背包（二维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">weights</span> - 物品重量数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">values</span> - 物品价值数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">capacity</span> - 背包最大容量
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 背包能容纳的最大价值
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">knapsack_2d</span>(<span class="hljs-params">weights, values, capacity</span>) {
  <span class="hljs-keyword">const</span> n = weights.<span class="hljs-property">length</span>;
  <span class="hljs-comment">// 1. 初始化二维dp数组：dp[i][j]表示前i个物品放入容量j的背包的最大价值</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(capacity + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));

  <span class="hljs-comment">// 2. 遍历顺序：先遍历物品（i从1到n），再遍历容量（j从1到capacity）（逐行填充）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= capacity; j++) {
      <span class="hljs-comment">// 3. 递推公式：容量不足则不选，容量充足则选或不选取最大值</span>
      <span class="hljs-keyword">if</span> (j &lt; weights[i - <span class="hljs-number">1</span>]) {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
      } <span class="hljs-keyword">else</span> {
        dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]);
      }
    }
  }

  <span class="hljs-comment">// 打印完整dp数组（表格）验证</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'基础01背包二维DP数组（表格）：'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp[i].<span class="hljs-title function_">join</span>(<span class="hljs-string">'\t'</span>));
  }

  <span class="hljs-comment">// 最终答案：前n个物品放入容量capacity的背包的最大价值</span>
  <span class="hljs-keyword">return</span> dp[n][capacity];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> weights = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> values = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-keyword">const</span> capacity = <span class="hljs-number">8</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最大价值：'</span>, <span class="hljs-title function_">knapsack_2d</span>(weights, values, capacity)); <span class="hljs-comment">// 输出：10</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/04007b9c90c043c08f458d6e98a0ef72~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aKc6YWx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768283152&amp;x-signature=9HKFGSi7y2mDqtD19DMDLI%2BtfWQ%3D" alt="dp2.png" loading="lazy"/></p>
<h4 data-id="heading-8">2.3 步骤3：dp数组如何初始化</h4>
<p>初始化逻辑与二维一致：容量为0时，最大价值为0，因此<code>dp[0] = 0</code>；其他容量的初始值也为0（因为初始无物品可放，最大价值为0），即<code>dp = new Array(capacity + 1).fill(0)</code>。</p>
<p>初始化后的单行表格：[0,0,0,0,0,0,0,0,0]（j从0到8）</p>
<h4 data-id="heading-9">2.4 步骤4：确定遍历顺序（表格填充顺序）</h4>
<p>一维DP的遍历顺序有严格要求，核心是「倒序遍历容量」，对应单行表格的「从右往左填充」——明确单行表格的填充顺序是避免重复选择物品的关键：</p>
<ol>
<li>
<p><strong>必须先遍历物品，再遍历容量</strong>：逐个处理每个物品，每次处理时更新整个单行表格（覆盖上一行结果）；</p>
</li>
<li>
<p><strong>容量必须倒序遍历（j从C到weights[i-1]）</strong>：从最大容量往小容量填充，确保计算<code>dp[j]</code>时，<code>dp[j - weights[i-1]]</code>仍是上一行（未处理当前物品）的旧值，避免同一物品被多次选择。</p>
</li>
</ol>
<p>关键原因：一维DP的核心是用单行表格复用二维表格的空间，表格中每个位置的数值都依赖“上一轮未更新的旧值”（对应二维的<code>dp[i-1][j - w[i]]</code>）。若正序遍历容量，<code>dp[j - w[i]]</code>会被提前更新（相当于二维的<code>dp[i][j - w[i]]</code>），导致同一个物品被多次选择（变成完全背包）；倒序遍历能保证计算<code>dp[j]</code>时，<code>dp[j - w[i]]</code>仍是上一行（未选当前物品）的结果，对应<strong>单行表格从右往左填充</strong>，完美契合01背包「每个物品选一次」的规则。</p>
<p>反例（正序遍历容量）：若j从weights[i-1]到C正序遍历，处理物品1（w=2,v=3）时，j=2会更新dp[2]=3，j=4时会用到dp[2]的新值（3），计算dp[4] = dp[4] + 3 = 3，相当于把物品1放入了两次，违背01背包规则。</p>
<h4 data-id="heading-10">2.5 步骤5：打印dp数组（验证）</h4>
<p>通过打印单行表格的滚动更新过程，验证填充规则的正确性。仍用测试用例 <code>weights = [2,3,4,5]</code>、<code>values = [3,4,5,6]</code>、<code>capacity = 8</code>，演示一维DP数组（单行表格）的填充变化：</p>
<ol>
<li>
<p><strong>初始状态</strong>：dp = [0,0,0,0,0,0,0,0,0]</p>
</li>
<li>
<p><strong>处理物品1（w=2,v=3），j从8到2倒序</strong>：</p>
<p>更新后：dp = [0,0,3,3,3,3,3,3,3]</p>
<ul>
<li>
<p>j=8：dp[8] = max(0, dp[8-2]+3) = max(0,0+3)=3；</p>
</li>
<li>
<p>j=7：dp[7] = max(0, dp[5]+3)=3；</p>
</li>
<li>
<p>...（j=2到6同理）；</p>
</li>
<li>
<p>j=2：dp[2] = max(0, dp[0]+3)=3；</p>
</li>
</ul>
</li>
<li>
<p><strong>处理物品2（w=3,v=4），j从8到3倒序</strong>：</p>
<p>更新后：dp = [0,0,3,4,4,7,7,7,7]</p>
<ul>
<li>
<p>j=8：max(3, dp[5]+4)=max(3,3+4)=7；</p>
</li>
<li>
<p>j=7：max(3, dp[4]+4)=max(3,3+4)=7；</p>
</li>
<li>
<p>j=6：max(3, dp[3]+4)=max(3,3+4)=7；</p>
</li>
<li>
<p>j=5：max(3, dp[2]+4)=max(3,3+4)=7；</p>
</li>
<li>
<p>j=4：max(3, dp[1]+4)=max(3,0+4)=4；</p>
</li>
<li>
<p>j=3：max(3, dp[0]+4)=max(3,0+4)=4；</p>
</li>
</ul>
</li>
<li>
<p><strong>处理物品3（w=4,v=5），j从8到4倒序</strong>：</p>
<p>更新后：dp = [0,0,3,4,5,5,8,9,9]</p>
<ul>
<li>
<p>j=8：max(7, dp[4]+5)=max(7,4+5)=9；</p>
</li>
<li>
<p>j=7：max(7, dp[3]+5)=max(7,4+5)=9；</p>
</li>
<li>
<p>j=6：max(7, dp[2]+5)=max(7,3+5)=8；</p>
</li>
<li>
<p>j=5：max(7, dp[1]+5)=max(7,0+5)=7；</p>
</li>
<li>
<p>j=4：max(4, dp[0]+5)=max(4,0+5)=5；</p>
</li>
</ul>
</li>
<li>
<p><strong>处理物品4（w=5,v=6），j从8到5倒序</strong>：</p>
<p>更新后：dp = [0,0,3,4,5,6,8,9,10]</p>
<ul>
<li>
<p>j=8：max(9, dp[3]+6)=max(9,4+6)=10；</p>
</li>
<li>
<p>j=7：max(9, dp[2]+6)=max(9,3+6)=9；</p>
</li>
<li>
<p>j=6：max(8, dp[1]+6)=max(8,0+6)=8；</p>
</li>
<li>
<p>j=5：max(5, dp[0]+6)=max(5,0+6)=6；</p>
</li>
</ul>
</li>
</ol>
<p>最终单行表格<code>dp[8] = 10</code>，与二维DP结果一致，验证了优化的正确性。</p>
<h4 data-id="heading-11">2.6 一维DP空间优化完整代码（JavaScript）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 基础01背包（一维DP空间优化解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">weights</span> - 物品重量数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">values</span> - 物品价值数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">capacity</span> - 背包最大容量
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 背包能容纳的最大价值
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">knapsack_1d</span>(<span class="hljs-params">weights, values, capacity</span>) {
  <span class="hljs-keyword">const</span> n = weights.<span class="hljs-property">length</span>;
  <span class="hljs-comment">// 1. 初始化一维dp数组：dp[j]表示容量j的背包的最大价值，初始值0</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(capacity + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// 2. 遍历顺序：先遍历物品（i从0到n-1），再倒序遍历容量（j从capacity到weights[i]）（从右往左填充）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-comment">// 倒序遍历避免重复选择当前物品</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = capacity; j &gt;= weights[i]; j--) {
      <span class="hljs-comment">// 3. 递推公式：不选当前物品的最大价值 vs 选当前物品的最大价值</span>
      dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j], dp[j - weights[i]] + values[i]);
    }
    <span class="hljs-comment">// 打印每次处理物品后的dp数组（单行表格更新过程）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理完物品<span class="hljs-subst">${i + <span class="hljs-number">1</span>}</span>后，dp数组：`</span>, [...dp]);
  }

  <span class="hljs-comment">// 最终答案：容量为capacity的背包的最大价值</span>
  <span class="hljs-keyword">return</span> dp[capacity];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> weights1 = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> values1 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-keyword">const</span> capacity1 = <span class="hljs-number">8</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最大价值：'</span>, <span class="hljs-title function_">knapsack_1d</span>(weights1, values1, capacity1)); <span class="hljs-comment">// 输出：10</span>
</code></pre>
<h3 data-id="heading-12">三、01背包的经典变形</h3>
<p>01背包的核心是「选/不选」，实际考题中很少直接考查基础模型，更多是结合具体场景转化为变形问题。但无论场景如何变化，只要抓住「每个物品最多选一次」的本质，就能用DP解题5步「万能钥匙」轻松破解。以下是4类最经典的01背包变形：</p>
<h4 data-id="heading-13">3.1 变形1：目标和（分割子集和/是否能装满背包）</h4>
<p><strong>LeetCode 链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Ftarget-sum%2F" target="_blank" title="https://leetcode.cn/problems/target-sum/" ref="nofollow noopener noreferrer">494. 目标和</a></p>
<p><strong>问题描述</strong>：给定一个非负整数数组<code>nums</code>和一个目标数<code>target</code>，向数组中每个整数前添加<code>+</code>或<code>-</code>，使得所有整数的和等于<code>target</code>，求有多少种不同的添加符号的方法。</p>
<p>核心转化：设添加<code>+</code>的数的和为<code>left</code>，添加<code>-</code>的数的和为<code>right</code>，则有：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-attribute">left</span> - <span class="hljs-attribute">right</span> = target
<span class="hljs-attribute">left</span> + <span class="hljs-attribute">right</span> = <span class="hljs-built_in">sum</span>(nums)
两式相加得：<span class="hljs-attribute">left</span> = (target + sum(nums)) / <span class="hljs-number">2</span>
</code></pre>
<p>问题转化为：从<code>nums</code>中选择若干元素，使得其和恰好为<code>left</code>，求这样的选择方案数——这是「01背包求方案数」的典型场景（每个元素选或不选，选则计入和，不选则不计）。</p>
<p>目标和问题核心表格（空表，后续逐步填充）：</p>





































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>...（和递增）</th><th>left（目标和）</th></tr></thead><tbody><tr><td>初始状态</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第1个元素</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第2个元素</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[i][j]</code>代表「处理前i个元素后，能凑出和为j的方案数」，最终右下角<code>dp[n][left]</code>即为目标和的解法总数（n为nums数组长度）。</p>
<h5 data-id="heading-14">3.1.1 步骤1：确定dp数组及下标的含义</h5>
<p>定义二维数组<code>dp[i][j]</code>：表示「处理前i个元素，能凑出和为j的方案数」。后续可优化为一维数组<code>dp[j]</code>（空间优化思路与基础01背包一致），这里先从直观的二维数组入手。</p>
<p>对应表格维度：i（行）表示处理的元素个数（从0到n，0代表未处理任何元素），j（列）表示要凑的和（从0到left，0代表和为0），表格共n+1行、left+1列。</p>
<h5 data-id="heading-15">3.1.2 步骤2：确定递推公式</h5>
<p>对于第i个元素（值为<code>nums[i-1]</code>，数组索引从0开始，i从1开始），核心决策仍是「选或不选」，方案数为两种决策的总和：</p>
<ol>
<li>
<p><strong>不选第i个元素</strong>：凑出和为j的方案数 = 处理前i-1个元素凑出和为j的方案数，即<code>dp[i][j] += dp[i-1][j]</code>；</p>
</li>
<li>
<p><strong>选第i个元素</strong>：需保证j ≥ nums[i-1]（当前元素值不大于目标和j），此时方案数 = 处理前i-1个元素凑出和为j-nums[i-1]的方案数，即<code>dp[i][j] += dp[i-1][j - nums[i-1]]</code>。</p>
</li>
</ol>
<p>最终递推公式（两种决策方案数相加）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) {
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];
} <span class="hljs-keyword">else</span> {
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
}
</code></pre>
<h5 data-id="heading-16">3.1.3 步骤3：dp数组如何初始化</h5>
<p>初始化核心是确定边界条件，即无需推导就能直接确定的方案数：</p>
<ol>
<li>
<p><strong>i=0（未处理任何元素），j=0（和为0）</strong>：不选任何元素即可凑出和为0，因此方案数为1，即<code>dp[0][0] = 1</code>；</p>
</li>
<li>
<p><strong>i=0（未处理任何元素），j&gt;0（和大于0）</strong>：没有元素可选，无法凑出任何正和，方案数为0，即<code>dp[0][j] = 0</code>（j&gt;0）；</p>
</li>
<li>
<p><strong>j=0（和为0），i&gt;0（处理过元素）</strong>：初始时可先设为1（后续通过递推更新），表示不选当前及之前元素的基础方案。</p>
</li>
</ol>
<p>结合示例理解：假设nums = [1,1,1,1]，target = 2，先计算sum(nums) = 4，left = (2 + 4)/2 = 3。初始化后的表格（第0行已填充）：</p>















































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>初始状态（i=0）</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>处理第1个元素（1）</td><td>1</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第2个元素（1）</td><td>1</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第3个元素（1）</td><td>1</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第4个元素（1）</td><td>1</td><td>待填</td><td>待填</td><td>待填</td></tr></tbody></table>
<h5 data-id="heading-17">3.1.4 步骤4：确定遍历顺序（表格填充顺序）</h5>
<p>与基础01背包二维解法一致：先遍历元素（i从1到n），再遍历和（j从0到left），即<strong>逐行填充表格</strong>。原因：计算<code>dp[i][j]</code>时，仅依赖上一行（i-1行）的<code>dp[i-1][j]</code>和<code>dp[i-1][j - nums[i-1]]</code>，逐行填充可确保依赖的单元格已提前计算完成。</p>
<h5 data-id="heading-18">3.1.5 步骤5：打印dp数组（验证）</h5>
<p>以示例<code>nums = [1,1,1,1]</code>、<code>target = 2</code>（left=3）为例，逐步填充表格验证逻辑：</p>
<ol>
<li>
<p><strong>填充第1行（i=1，元素1：1）</strong>：</p>
<ul>
<li>j=0：不选元素1，方案数=dp[0][0]=1；</li>
<li>j=1：j≥1，方案数=dp[0][1]（不选）+ dp[0][0]（选）=0+1=1；</li>
<li>j=2：j&gt;1，无法选，方案数=dp[0][2]=0；</li>
<li>j=3：j&gt;1，无法选，方案数=dp[0][3]=0；</li>
</ul>
</li>
<li>
<p><strong>填充第2行（i=2，元素2：1）</strong>：</p>
<ul>
<li>j=0：方案数=dp[1][0]=1；</li>
<li>j=1：j≥1，方案数=dp[1][1]（不选）+ dp[1][0]（选）=1+1=2；</li>
<li>j=2：j≥1，方案数=dp[1][2]（不选）+ dp[1][1]（选）=0+1=1；</li>
<li>j=3：j&gt;1，无法选，方案数=dp[1][3]=0；</li>
</ul>
</li>
<li>
<p><strong>填充第3行（i=3，元素3：1）</strong>：</p>
<ul>
<li>j=0：方案数=dp[2][0]=1；</li>
<li>j=1：j≥1，方案数=dp[2][1]（不选）+ dp[2][0]（选）=2+1=3；</li>
<li>j=2：j≥1，方案数=dp[2][2]（不选）+ dp[2][1]（选）=1+2=3；</li>
<li>j=3：j≥1，方案数=dp[2][3]（不选）+ dp[2][2]（选）=0+1=1；</li>
</ul>
</li>
<li>
<p><strong>填充第4行（i=4，元素4：1）</strong>：</p>
<ul>
<li>j=0：方案数=dp[3][0]=1；</li>
<li>j=1：j≥1，方案数=dp[3][1]（不选）+ dp[3][0]（选）=3+1=4；</li>
<li>j=2：j≥1，方案数=dp[3][2]（不选）+ dp[3][1]（选）=3+3=6；</li>
<li>j=3：j≥1，方案数=dp[3][3]（不选）+ dp[3][2]（选）=1+3=4；</li>
</ul>
</li>
</ol>
<p>最终填充完成的表格：</p>















































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>初始状态（i=0）</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>处理第1个元素（1）</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>处理第2个元素（1）</td><td>1</td><td>2</td><td>1</td><td>0</td></tr><tr><td>处理第3个元素（1）</td><td>1</td><td>3</td><td>3</td><td>1</td></tr><tr><td>处理第4个元素（1）</td><td>1</td><td>4</td><td>6</td><td>4</td></tr></tbody></table>
<p>表格右下角<code>dp[4][3] = 4</code>，即该示例的目标和解法总数为4，与实际情况一致（+1+1+1-1、+1+1-1+1、+1-1+1+1、-1+1+1+1）。</p>
<h5 data-id="heading-19">3.1.6 目标和问题完整代码（二维+一维优化）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 目标和（二维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 非负整数数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span> - 目标和
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 不同的添加符号方法数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findTargetSumWays_2d</span>(<span class="hljs-params">nums, target</span>) {
  <span class="hljs-keyword">const</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-comment">// 边界条件：target的绝对值大于sum，或(target + sum)为奇数，均无可行方案</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(target) &gt; sum || (target + sum) % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> left = (target + sum) / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;
  <span class="hljs-comment">// 初始化二维dp数组：dp[i][j]表示处理前i个元素凑出和为j的方案数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(left + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));
  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 未处理元素时，凑出和为0的方案数为1</span>

  <span class="hljs-comment">// 遍历顺序：先遍历元素，再遍历和（逐行填充）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= left; j++) {
      <span class="hljs-comment">// 递推公式</span>
      <span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];
      } <span class="hljs-keyword">else</span> {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
      }
    }
  }

  <span class="hljs-comment">// 打印dp数组验证</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'目标和二维DP数组（表格）：'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp[i].<span class="hljs-title function_">join</span>(<span class="hljs-string">'\t'</span>));
  }

  <span class="hljs-keyword">return</span> dp[n][left];
}

<span class="hljs-comment">/**
 * 目标和（一维DP空间优化解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 非负整数数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">target</span> - 目标和
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 不同的添加符号方法数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findTargetSumWays_1d</span>(<span class="hljs-params">nums, target</span>) {
  <span class="hljs-keyword">const</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(target) &gt; sum || (target + sum) % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> left = (target + sum) / <span class="hljs-number">2</span>;
  <span class="hljs-comment">// 初始化一维dp数组：dp[j]表示凑出和为j的方案数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(left + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 基础方案：不选任何元素凑出和为0</span>

  <span class="hljs-comment">// 遍历顺序：先遍历元素，再倒序遍历和（避免重复选择）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = left; j &gt;= num; j--) {
      dp[j] += dp[j - num]; <span class="hljs-comment">// 递推公式简化（复用数组）</span>
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理完元素<span class="hljs-subst">${num}</span>后，dp数组：`</span>, [...dp]);
  }

  <span class="hljs-keyword">return</span> dp[left];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>];
<span class="hljs-keyword">const</span> target = <span class="hljs-number">2</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'二维DP解法：'</span>, <span class="hljs-title function_">findTargetSumWays_2d</span>(nums, target)); <span class="hljs-comment">// 输出：4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'一维DP解法：'</span>, <span class="hljs-title function_">findTargetSumWays_1d</span>(nums, target)); <span class="hljs-comment">// 输出：4</span>
</code></pre>
<h4 data-id="heading-20">3.2 变形2：分割等和子集（是否能装满背包）</h4>
<p><strong>LeetCode 链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fpartition-equal-subset-sum%2F" target="_blank" title="https://leetcode.cn/problems/partition-equal-subset-sum/" ref="nofollow noopener noreferrer">416. 分割等和子集</a></p>
<p><strong>问题描述</strong>：给定一个只包含正整数的非空数组<code>nums</code>，判断是否可以将这个数组分割成两个子集，使得两个子集的和相等。</p>
<p>核心转化：两个子集和相等，即每个子集的和为数组总和的一半（记为<code>target</code>）。问题转化为：从<code>nums</code>中选择若干元素，使得其和恰好为<code>target</code>——这是「01背包判断可行性」的典型场景（每个元素选或不选，判断是否能装满容量为target的背包）。</p>
<p>核心表格（空表）：</p>





































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>...（和递增）</th><th>target（目标和）</th></tr></thead><tbody><tr><td>初始状态</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第1个元素</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第2个元素</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[i][j]</code>代表「处理前i个元素后，能否凑出和为j」（布尔值），最终右下角<code>dp[n][target]</code>即为问题答案。</p>
<h5 data-id="heading-21">3.2.1 步骤1：确定dp数组及下标的含义</h5>
<p>定义二维布尔数组<code>dp[i][j]</code>：表示「处理前i个元素，能否凑出和为j」。可优化为一维布尔数组<code>dp[j]</code>，空间复杂度从<code>O(n*target)</code>降至<code>O(target)</code>。</p>
<p>对应表格维度：i（行）表示处理的元素个数（从0到n，0代表未处理任何元素），j（列）表示要凑的和（从0到target，0代表和为0），表格共n+1行、target+1列。</p>
<h5 data-id="heading-22">3.2.2 步骤2：确定递推公式</h5>
<p>对于第i个元素（值为<code>nums[i-1]</code>），决策为「选或不选」，可行性为两种决策的或运算：</p>
<ol>
<li>
<p><strong>不选第i个元素</strong>：能否凑出j = 处理前i-1个元素能否凑出j，即<code>dp[i][j] = dp[i-1][j]</code>；</p>
</li>
<li>
<p><strong>选第i个元素</strong>：需j ≥ nums[i-1]，能否凑出j = 处理前i-1个元素能否凑出j-nums[i-1]，即<code>dp[i][j] = dp[i-1][j - nums[i-1]]</code>。</p>
</li>
</ol>
<p>最终递推公式（两种决策有一个可行则整体可行）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) {
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];
} <span class="hljs-keyword">else</span> {
  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
}
</code></pre>
<h5 data-id="heading-23">3.2.3 步骤3：dp数组如何初始化</h5>
<p>初始化核心是确定边界条件，即无需推导就能直接确定的可行性：</p>
<ol>
<li>
<p><strong>i=0（未处理任何元素），j=0（和为0）</strong>：不选任何元素可凑出和为0，因此<code>dp[0][0] = true</code>；</p>
</li>
<li>
<p><strong>i=0（未处理任何元素），j&gt;0（和大于0）</strong>：没有元素可选，无法凑出任何正和，可行性为<code>false</code>，即<code>dp[0][j] = false</code>（j&gt;0）；</p>
</li>
<li>
<p><strong>j=0（和为0），i&gt;0（处理过元素）</strong>：初始时可先设为<code>true</code>（后续通过递推更新），表示不选当前及之前元素的基础方案。</p>
</li>
</ol>
<p>结合示例理解：假设nums = [1,5,11,5]，sum = 22，target = 11。初始化后的表格（第0行已填充）：</p>



























































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>...（和递增）</th><th>11（目标和）</th></tr></thead><tbody><tr><td>初始状态（i=0）</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>处理第1个元素（1）</td><td>true</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第2个元素（5）</td><td>true</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第3个元素（11）</td><td>true</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr><tr><td>处理第4个元素（5）</td><td>true</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td><td>待填</td></tr></tbody></table>
<h5 data-id="heading-24">3.2.4 步骤4：确定遍历顺序（表格填充顺序）</h5>
<p>与基础01背包二维解法一致：先遍历元素（i从1到n），再遍历和（j从0到target），即<strong>逐行填充表格</strong>。原因：计算<code>dp[i][j]</code>时，仅依赖上一行（i-1行）的<code>dp[i-1][j]</code>和<code>dp[i-1][j - nums[i-1]]</code>，逐行填充可确保依赖的单元格已提前计算完成。</p>
<p>一维解法：先遍历元素，再倒序遍历和（避免重复选择），与基础01背包空间优化逻辑一致。</p>
<h5 data-id="heading-25">3.2.5 步骤5：打印dp数组（验证）</h5>
<p>以示例<code>nums = [1,5,11,5]</code>、<code>sum = 22</code>、<code>target = 11</code>为例，逐步填充表格验证逻辑：</p>
<ol>
<li>
<p><strong>填充第1行（i=1，元素1：1）</strong>：</p>
<ul>
<li>j=0：不选元素1，dp[1][0] = dp[0][0] = true；</li>
<li>j=1：j≥1，dp[1][1] = dp[0][1]（不选）|| dp[0][0]（选）= false || true = true；</li>
<li>j=2-11：j&lt;1，无法选，dp[1][j] = dp[0][j] = false；</li>
</ul>
</li>
<li>
<p><strong>填充第2行（i=2，元素2：5）</strong>：</p>
<ul>
<li>j=0：dp[2][0] = dp[1][0] = true；</li>
<li>j=1-4：j&lt;5，无法选，dp[2][j] = dp[1][j]（继承上一行）；</li>
<li>j=5：j≥5，dp[2][5] = dp[1][5]（不选）|| dp[1][0]（选）= false || true = true；</li>
<li>j=6：j≥5，dp[2][6] = dp[1][6]（不选）|| dp[1][1]（选）= false || true = true；</li>
<li>j=7-11：j≥5，dp[2][j] = dp[1][j]（不选）|| dp[1][j-5]（选），其中j=11时，dp[2][11] = false || false = false；</li>
</ul>
</li>
<li>
<p><strong>填充第3行（i=3，元素3：11）</strong>：</p>
<ul>
<li>j=0-10：j&lt;11，无法选，dp[3][j] = dp[2][j]（继承上一行）；</li>
<li>j=11：j≥11，dp[3][11] = dp[2][11]（不选）|| dp[2][0]（选）= false || true = true；</li>
</ul>
</li>
<li>
<p><strong>填充第4行（i=4，元素4：5）</strong>：</p>
<ul>
<li>j=0-4：j&lt;5，无法选，dp[4][j] = dp[3][j]（继承上一行）；</li>
<li>j=5-11：j≥5，dp[4][j] = dp[3][j]（不选）|| dp[3][j-5]（选），其中j=11时，dp[4][11] = true || false = true；</li>
</ul>
</li>
</ol>
<p>最终填充完成的表格：</p>































































































<table><thead><tr><th>处理阶段\和为j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>初始状态（i=0）</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>处理第1个元素（1）</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>处理第2个元素（5）</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td></tr><tr><td>处理第3个元素（11）</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>true</td></tr><tr><td>处理第4个元素（5）</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td><td>true</td></tr></tbody></table>
<p>表格右下角<code>dp[4][11] = true</code>，即该示例可以分割成两个和相等的子集（子集[1,5,5]和[11]），与预期结果一致。</p>
<h5 data-id="heading-26">3.2.6 分割等和子集完整代码</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 分割等和子集（二维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 正整数数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} - 是否可以分割成两个和相等的子集
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">canPartition_2d</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 总和为奇数，无法分割</span>
  <span class="hljs-keyword">const</span> target = sum / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;
  <span class="hljs-comment">// 初始化二维dp数组：dp[i][j]表示处理前i个元素能否凑出和为j</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(target + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));
  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 边界条件</span>

  <span class="hljs-comment">// 遍历顺序：先遍历元素，再遍历和</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= target; j++) {
      <span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];
      } <span class="hljs-keyword">else</span> {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
      }
    }
  }

  <span class="hljs-comment">// 打印dp数组验证</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'分割等和子集二维DP数组（表格）：'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp[i].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> (val ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>)).<span class="hljs-title function_">join</span>(<span class="hljs-string">'\t'</span>));
  }

  <span class="hljs-keyword">return</span> dp[n][target];
}

<span class="hljs-comment">/**
 * 分割等和子集（一维DP空间优化解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">nums</span> - 正整数数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} - 是否可以分割成两个和相等的子集
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">canPartition_1d</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">const</span> sum = nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">const</span> target = sum / <span class="hljs-number">2</span>;
  <span class="hljs-comment">// 初始化一维dp数组：dp[j]表示能否凑出和为j</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(target + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);
  dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 边界条件</span>

  <span class="hljs-comment">// 遍历顺序：先遍历元素，再倒序遍历和</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = target; j &gt;= num; j--) {
      dp[j] = dp[j] || dp[j - num];
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
      <span class="hljs-string">`处理完元素<span class="hljs-subst">${num}</span>后，dp数组：`</span>,
      dp.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> (val ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>))
    );
  }

  <span class="hljs-keyword">return</span> dp[target];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> nums1 = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'二维DP解法：'</span>, <span class="hljs-title function_">canPartition_2d</span>(nums1)); <span class="hljs-comment">// 输出：true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'一维DP解法：'</span>, <span class="hljs-title function_">canPartition_1d</span>(nums1)); <span class="hljs-comment">// 输出：true</span>

<span class="hljs-keyword">const</span> nums2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'二维DP解法：'</span>, <span class="hljs-title function_">canPartition_2d</span>(nums2)); <span class="hljs-comment">// 输出：false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'一维DP解法：'</span>, <span class="hljs-title function_">canPartition_1d</span>(nums2)); <span class="hljs-comment">// 输出：false</span>
</code></pre>
<h4 data-id="heading-27">3.3 变形3：最后一块石头的重量II（最小背包剩余容量）</h4>
<p><strong>LeetCode 链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Flast-stone-weight-ii%2F" target="_blank" title="https://leetcode.cn/problems/last-stone-weight-ii/" ref="nofollow noopener noreferrer">1049. 最后一块石头的重量 II</a></p>
<p><strong>问题描述</strong>：有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为x和y，且x ≤ y。那么粉碎的可能结果如下：如果x == y，那么两块石头都会被完全粉碎；如果x != y，那么重量为x的石头会被完全粉碎，而重量为y的石头会变成y - x的重量。最后，最多只会剩下一块石头。返回此石头的最小可能重量。</p>
<p>核心转化：要使最后剩余石头重量最小，需将石头尽可能分成两堆重量接近的石头——两堆重量差越小，剩余重量越小。设总重量为sum，目标是找到一堆石头的最大重量<code>maxWeight</code>（≤ sum/2），则剩余重量为<code>sum - 2*maxWeight</code>。问题转化为：从石头重量数组中选择若干元素，使得其和不超过sum/2的最大值——这是「01背包求最大价值（重量即价值）」的场景（背包容量为sum/2，物品重量和价值均为石头重量）。</p>
<p>最后一块石头的重量II核心表格（空表，后续逐步填充）：</p>





































<table><thead><tr><th>处理阶段\容量j</th><th>0</th><th>1</th><th>2</th><th>...（容量递增）</th><th>target（sum/2）</th></tr></thead><tbody><tr><td>初始状态</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第1块石头</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>处理第2块石头</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[j]</code>代表「容量为j的背包能容纳的最大重量」（一维DP），最终<code>dp[target]</code>即为不超过sum/2的最大子集重量，剩余重量 = sum - 2*dp[target]。</p>
<h5 data-id="heading-28">3.3.1 步骤1：确定dp数组及下标的含义</h5>
<p>定义一维数组<code>dp[j]</code>：表示「容量为j的背包，能容纳的最大重量」（即选若干石头的最大和）。</p>
<p>对应表格维度：仅保留"容量j"这一列维度（j从0到target，target = sum/2向下取整），形成单行表格，每次遍历石头时，滚动更新这一行的数值（覆盖上一行的结果）。</p>
<h5 data-id="heading-29">3.3.2 步骤2：确定递推公式</h5>
<p>对于第i块石头（重量<code>stones[i]</code>，价值也为<code>stones[i]</code>），有两种核心决策：选或不选。</p>
<ol>
<li>
<p><strong>不选第i块石头</strong>：容量为j的最大重量 = 不选当前石头时的最大重量，即<code>dp[j] = dp[j]</code>（保持不变）；</p>
</li>
<li>
<p><strong>选第i块石头</strong>：需保证背包容量j ≥ 第i块石头的重量，此时最大重量 = 容量j-stones[i]的最大重量 + 第i块石头的重量，即<code>dp[j] = dp[j - stones[i]] + stones[i]</code>。</p>
</li>
</ol>
<p>最终递推公式（取两种决策的最大值）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (j &gt;= stones[i]) {
  dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j], dp[j - stones[i]] + stones[i]);
} <span class="hljs-keyword">else</span> {
  dp[j] = dp[j]; <span class="hljs-comment">// 容量不足，无法选</span>
}
</code></pre>
<p>简化后（因为容量不足时dp[j]不变）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = target; j &gt;= stones[i]; j--) {
  dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j], dp[j - stones[i]] + stones[i]);
}
</code></pre>
<h5 data-id="heading-30">3.3.3 步骤3：dp数组如何初始化</h5>
<p>初始化逻辑与基础01背包一维DP一致：容量为0时，最大重量为0，因此<code>dp[0] = 0</code>；其他容量的初始值也为0（因为初始无石头可放，最大重量为0），即<code>dp = new Array(target + 1).fill(0)</code>。</p>
<p>初始化后的单行表格：[0,0,0,0,...]（j从0到target）</p>
<p>结合示例理解：假设stones = [2,7,4,1,8,1]，sum = 23，target = Math.floor(23/2) = 11。初始化后的表格：</p>



































<table><thead><tr><th>容量j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>初始</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<h5 data-id="heading-31">3.3.4 步骤4：确定遍历顺序（表格填充顺序）</h5>
<p>一维DP的遍历顺序有严格要求，核心是「倒序遍历容量」，对应单行表格的「从右往左填充」：</p>
<ol>
<li>
<p><strong>必须先遍历石头，再遍历容量</strong>：逐个处理每块石头，每次处理时更新整个单行表格（覆盖上一行结果）；</p>
</li>
<li>
<p><strong>容量必须倒序遍历（j从target到stones[i]）</strong>：从最大容量往小容量填充，确保计算<code>dp[j]</code>时，<code>dp[j - stones[i]]</code>仍是上一行（未处理当前石头）的旧值，避免同一石头被多次选择。</p>
</li>
</ol>
<h5 data-id="heading-32">3.3.5 步骤5：打印dp数组（验证）</h5>
<p>通过打印单行表格的滚动更新过程，验证填充规则的正确性。仍用测试用例 <code>stones = [2,7,4,1,8,1]</code>、<code>sum = 23</code>、<code>target = 11</code>，演示一维DP数组（单行表格）的填充变化：</p>
<ol>
<li>
<p><strong>初始状态</strong>：dp = [0,0,0,0,0,0,0,0,0,0,0,0]</p>
</li>
<li>
<p><strong>处理石头1（w=2），j从11到2倒序</strong>：更新后：dp = [0,0,2,2,2,2,2,2,2,2,2,2]</p>
<ul>
<li>j=11：dp[11] = max(0, dp[9]+2) = max(0,0+2)=2；</li>
<li>j=10：dp[10] = max(0, dp[8]+2)=2；</li>
<li>...（j=2到9同理）；</li>
<li>j=2：dp[2] = max(0, dp[0]+2)=2；</li>
</ul>
</li>
<li>
<p><strong>处理石头2（w=7），j从11到7倒序</strong>：更新后：dp = [0,0,2,2,2,2,2,7,7,9,9,9]</p>
<ul>
<li>j=11：max(2, dp[4]+7)=max(2,2+7)=9；</li>
<li>j=10：max(2, dp[3]+7)=max(2,2+7)=9；</li>
<li>j=9：max(2, dp[2]+7)=max(2,2+7)=9；</li>
<li>j=8：max(2, dp[1]+7)=max(2,0+7)=7；</li>
<li>j=7：max(2, dp[0]+7)=max(2,0+7)=7；</li>
</ul>
</li>
<li>
<p><strong>处理石头3（w=4），j从11到4倒序</strong>：更新后：dp = [0,0,2,2,4,4,6,7,7,9,9,11]</p>
<ul>
<li>j=11：max(9, dp[7]+4)=max(9,7+4)=11；</li>
<li>j=10：max(9, dp[6]+4)=max(9,2+4)=9；</li>
<li>j=9：max(9, dp[5]+4)=max(9,2+4)=9；</li>
<li>j=8：max(7, dp[4]+4)=max(7,2+4)=7；</li>
<li>j=7：max(7, dp[3]+4)=max(7,2+4)=7；</li>
<li>j=6：max(2, dp[2]+4)=max(2,2+4)=6；</li>
<li>j=5：max(2, dp[1]+4)=max(2,0+4)=4；</li>
<li>j=4：max(2, dp[0]+4)=max(2,0+4)=4；</li>
</ul>
</li>
<li>
<p><strong>处理石头4（w=1），j从11到1倒序</strong>：更新后：dp = [0,1,2,3,4,5,6,7,8,9,10,11]</p>
<ul>
<li>j=11：max(11, dp[10]+1)=max(11,9+1)=11；</li>
<li>j=10：max(9, dp[9]+1)=max(9,9+1)=10；</li>
<li>...（其他位置类似更新）；</li>
</ul>
</li>
<li>
<p><strong>处理石头5（w=8），j从11到8倒序</strong>：更新后：dp = [0,1,2,3,4,5,6,7,8,9,10,11]</p>
<ul>
<li>j=11：max(11, dp[3]+8)=max(11,3+8)=11；</li>
<li>j=10：max(10, dp[2]+8)=max(10,2+8)=10；</li>
<li>j=9：max(9, dp[1]+8)=max(9,1+8)=9；</li>
<li>j=8：max(8, dp[0]+8)=max(8,0+8)=8；</li>
</ul>
</li>
<li>
<p><strong>处理石头6（w=1），j从11到1倒序</strong>：最终：dp = [0,1,2,3,4,5,6,7,8,9,10,11]</p>
</li>
</ol>
<p>最终单行表格<code>dp[11] = 11</code>，剩余重量 = 23 - 2*11 = 1，与预期结果一致。</p>
<h5 data-id="heading-33">3.3.6 最后一块石头的重量II完整代码（一维DP）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 最后一块石头的重量II（一维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number[]</span>} <span class="hljs-variable">stones</span> - 石头重量数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 最后剩余石头的最小可能重量
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">lastStoneWeightII</span>(<span class="hljs-params">stones</span>) {
  <span class="hljs-keyword">const</span> sum = stones.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">2</span>);
  <span class="hljs-comment">// 初始化一维dp数组：dp[j]表示容量为j的背包能容纳的最大重量</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(target + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// 遍历顺序：先遍历石头，再倒序遍历容量</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> stone <span class="hljs-keyword">of</span> stones) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = target; j &gt;= stone; j--) {
      dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j], dp[j - stone] + stone);
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理完石头<span class="hljs-subst">${stone}</span>后，dp数组：`</span>, [...dp]);
  }

  <span class="hljs-comment">// 剩余重量 = 总重量 - 2*最大子集重量</span>
  <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[target];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> stones = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最后剩余石头的最小重量：'</span>, <span class="hljs-title function_">lastStoneWeightII</span>(stones)); <span class="hljs-comment">// 输出：1</span>
</code></pre>
<h4 data-id="heading-34">3.4 变形4：一和零（二维背包容量）</h4>
<p><strong>LeetCode 链接</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fones-and-zeroes%2F" target="_blank" title="https://leetcode.cn/problems/ones-and-zeroes/" ref="nofollow noopener noreferrer">474. 一和零</a></p>
<p><strong>问题描述</strong>：给你一个二进制字符串数组<code>strs</code>和两个整数<code>m</code>和<code>n</code>。请你找出并返回<code>strs</code>的最大子集的长度，该子集中最多有<code>m</code>个0和<code>n</code>个1。</p>
<p>核心转化：每个字符串是一个"物品"，选择该物品会消耗"0的数量"和"1的数量"两种容量，目标是在两种容量均不超过限制（m、n）的前提下，选择最多的物品——这是「二维容量01背包求最大物品数」的场景（背包有两个维度的容量限制，价值为1，求最大价值即最大物品数）。</p>
<p>一和零问题核心表格（空表，后续逐步填充）：</p>













































<table><thead><tr><th>0的数量\1的数量j</th><th>0</th><th>1</th><th>2</th><th>...（1的数量递增）</th><th>n（最大1的数量）</th></tr></thead><tbody><tr><td>0（0的数量为0）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>1（0的数量为1）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>...（0的数量递增）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td></tr><tr><td>m（最大0的数量）</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充</td><td>待填充（最终答案：最多字符串数量）</td></tr></tbody></table>
<p>表格说明：表格中每个单元格<code>dp[i][j]</code>代表「最多使用i个0和j个1时，能选择的最大字符串数量」，我们的目标是按规则填充表格，最终右下角<code>dp[m][n]</code>即为一和零问题的答案。</p>
<h5 data-id="heading-35">3.4.1 步骤1：确定dp数组及下标的含义</h5>
<p>定义二维数组<code>dp[i][j]</code>：表示「最多用i个0和j个1能选择的最大字符串数量」。</p>
<p>对应表格维度：i（行）表示0的数量（从0到m，0代表0个0），j（列）表示1的数量（从0到n，0代表0个1），表格共m+1行、n+1列。</p>
<h5 data-id="heading-36">3.4.2 步骤2：确定递推公式</h5>
<p>对于每个字符串（含zero个0、one个1），有两种核心决策：选或不选。</p>
<ol>
<li>
<p><strong>不选当前字符串</strong>：最多用i个0和j个1的最大字符串数量 = 不选当前字符串时的最大数量，即<code>dp[i][j] = dp[i][j]</code>（保持不变）；</p>
</li>
<li>
<p><strong>选当前字符串</strong>：需保证i ≥ zero且j ≥ one（0和1的数量都足够），此时最大数量 = 用i-zero个0和j-one个1的最大数量 + 1（当前字符串），即<code>dp[i][j] = dp[i - zero][j - one] + 1</code>。</p>
</li>
</ol>
<p>最终递推公式（取两种决策的最大值）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (i &gt;= zero &amp;&amp; j &gt;= one) {
  dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i][j], dp[i - zero][j - one] + <span class="hljs-number">1</span>);
} <span class="hljs-keyword">else</span> {
  dp[i][j] = dp[i][j]; <span class="hljs-comment">// 容量不足，无法选</span>
}
</code></pre>
<p>简化后（因为容量不足时dp[i][j]不变，且使用倒序遍历）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = m; i &gt;= zero; i--) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = n; j &gt;= one; j--) {
    dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i][j], dp[i - zero][j - one] + <span class="hljs-number">1</span>);
  }
}
</code></pre>
<h5 data-id="heading-37">3.4.3 步骤3：dp数组如何初始化</h5>
<p>初始化逻辑：初始无字符串可选，无论有多少0和1，最大字符串数量都为0，因此<code>dp[i][j] = 0</code>（所有单元格初始化为0），即<code>dp = new Array(m+1).fill(0).map(() =&gt; new Array(n+1).fill(0))</code>。</p>
<p>初始化后的表格（所有单元格为0）：</p>













































<table><thead><tr><th>0的数量\1的数量j</th><th>0</th><th>1</th><th>2</th><th>...</th><th>n</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>...</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>m</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<p>结合示例理解：假设strs = ["10","0001","111001","1","0"]，m = 5，n = 3。初始化后的表格（5+1行，3+1列）：</p>






















































<table><thead><tr><th>0的数量\1的数量j</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>3</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>4</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>5</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
<h5 data-id="heading-38">3.4.4 步骤4：确定遍历顺序（表格填充顺序）</h5>
<p>二维容量01背包的遍历顺序有严格要求：</p>
<ol>
<li>
<p><strong>必须先遍历字符串（物品），再遍历0的数量，最后遍历1的数量</strong>：逐个处理每个字符串，每次处理时更新整个二维表格；</p>
</li>
<li>
<p><strong>0和1的数量都必须倒序遍历</strong>：</p>
<ul>
<li>0的数量倒序遍历（i从m到zero）：确保计算<code>dp[i][j]</code>时，<code>dp[i - zero][j - one]</code>仍是上一轮（未处理当前字符串）的旧值；</li>
<li>1的数量倒序遍历（j从n到one）：同样确保依赖的单元格是旧值。</li>
</ul>
</li>
</ol>
<p>倒序遍历避免同一字符串被多次选择，完美契合01背包「每个物品选一次」的规则。</p>
<h5 data-id="heading-39">3.4.5 步骤5：打印dp数组（验证）</h5>
<p>以示例<code>strs = ["10","0001","111001","1","0"]</code>、<code>m = 5</code>、<code>n = 3</code>为例，逐步填充表格验证逻辑：</p>
<ol>
<li>
<p><strong>处理字符串1（"10"：zero=1, one=1）</strong>：</p>
<ul>
<li>更新dp[1][1]到dp[5][3]范围内所有满足i≥1且j≥1的位置</li>
<li>dp[1][1] = max(0, dp[0][0]+1) = max(0,0+1) = 1</li>
<li>dp[2][2] = max(0, dp[1][1]+1) = max(0,1+1) = 2</li>
<li>...（其他位置类似）</li>
</ul>
</li>
<li>
<p><strong>处理字符串2（"0001"：zero=3, one=1）</strong>：</p>
<ul>
<li>更新dp[3][1]到dp[5][3]范围内所有满足i≥3且j≥1的位置</li>
<li>dp[3][1] = max(dp[3][1], dp[0][0]+1) = max(0,0+1) = 1</li>
<li>dp[4][2] = max(dp[4][2], dp[1][1]+1) = max(0,1+1) = 2</li>
<li>...（其他位置类似）</li>
</ul>
</li>
<li>
<p><strong>处理字符串3（"111001"：zero=2, one=4）</strong>：</p>
<ul>
<li>由于one=4 &gt; n=3，无法选择此字符串，dp数组不变</li>
</ul>
</li>
<li>
<p><strong>处理字符串4（"1"：zero=0, one=1）</strong>：</p>
<ul>
<li>更新dp[0][1]到dp[5][3]范围内所有满足j≥1的位置</li>
<li>dp[0][1] = max(0, dp[0][0]+1) = max(0,0+1) = 1</li>
<li>dp[1][2] = max(dp[1][2], dp[1][1]+1) = max(0,1+1) = 2</li>
<li>...（其他位置类似）</li>
</ul>
</li>
<li>
<p><strong>处理字符串5（"0"：zero=1, one=0）</strong>：</p>
<ul>
<li>更新dp[1][0]到dp[5][3]范围内所有满足i≥1的位置</li>
<li>dp[1][0] = max(0, dp[0][0]+1) = max(0,0+1) = 1</li>
<li>dp[2][1] = max(dp[2][1], dp[1][1]+1) = max(0,1+1) = 2</li>
<li>...（其他位置类似）</li>
</ul>
</li>
</ol>
<p>最终填充完成的表格（简化展示关键部分）：</p>






















































<table><thead><tr><th>0的数量\1的数量j</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>2</td><td>1</td><td>2</td><td>3</td><td>3</td></tr><tr><td>3</td><td>1</td><td>2</td><td>3</td><td>3</td></tr><tr><td>4</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>5</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table>
<p>表格右下角<code>dp[5][3] = 4</code>，即该示例的最大子集长度为4，与预期结果一致。</p>
<h5 data-id="heading-40">3.4.6 一和零完整代码（二维DP）</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 一和零（二维DP解法）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string[]</span>} <span class="hljs-variable">strs</span> - 二进制字符串数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">m</span> - 最多允许的0的数量
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">n</span> - 最多允许的1的数量
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 最大子集长度
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">findMaxForm</span>(<span class="hljs-params">strs, m, n</span>) {
  <span class="hljs-comment">// 初始化二维dp数组：dp[i][j]表示i个0和j个1能选的最大字符串数</span>
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));

  <span class="hljs-comment">// 遍历每个字符串（物品）</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> str <span class="hljs-keyword">of</span> strs) {
    <span class="hljs-comment">// 统计当前字符串的0和1的数量</span>
    <span class="hljs-keyword">let</span> zero = <span class="hljs-number">0</span>,
      one = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> str) {
      c === <span class="hljs-string">'0'</span> ? zero++ : one++;
    }

    <span class="hljs-comment">// 倒序遍历0的数量，再倒序遍历1的数量（避免重复选择）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = m; i &gt;= zero; i--) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = n; j &gt;= one; j--) {
        dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i][j], dp[i - zero][j - one] + <span class="hljs-number">1</span>);
      }
    }

    <span class="hljs-comment">// 打印每次处理后的dp数组（简化打印，只打印部分关键行）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理完字符串"<span class="hljs-subst">${str}</span>"后，dp数组（前5行前5列）：`</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(m, <span class="hljs-number">5</span>); i++) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp[i].<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(n, <span class="hljs-number">5</span>)).<span class="hljs-title function_">join</span>(<span class="hljs-string">'\t'</span>));
    }
  }

  <span class="hljs-keyword">return</span> dp[m][n];
}

<span class="hljs-comment">// 测试用例</span>
<span class="hljs-keyword">const</span> strs = [<span class="hljs-string">'10'</span>, <span class="hljs-string">'0001'</span>, <span class="hljs-string">'111001'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'0'</span>];
<span class="hljs-keyword">const</span> m = <span class="hljs-number">5</span>,
  n = <span class="hljs-number">3</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'最大子集长度：'</span>, <span class="hljs-title function_">findMaxForm</span>(strs, m, n)); <span class="hljs-comment">// 输出：4</span>
</code></pre>
<h3 data-id="heading-41">四、01背包问题总结</h3>
<p>01背包的核心是「选或不选」的二选一决策，所有变形都围绕这一核心逻辑，通过转化「物品」「容量」「目标」的含义，适配不同的实际场景。掌握以下关键点，可轻松破解所有01背包相关问题：</p>
<ol>
<li>
<p><strong>表格可视化核心</strong>：DP解题的本质是填充表格，先明确表格形态（dp数组含义），再按规则填充，表格填完即得答案；</p>
</li>
<li>
<p><strong>5步万能钥匙</strong>：确定dp含义→递推公式→初始化→遍历顺序→验证，这是所有DP问题的通用拆解思路，尤其适用于背包问题；</p>
</li>
<li>
<p><strong>空间优化技巧</strong>：二维DP可通过「倒序遍历容量」优化为一维DP，核心是复用数组空间，避免重复选择物品；</p>
</li>
<li>
<p><strong>变形转化逻辑</strong>：无论场景如何变化，只要每个物品最多选一次，都可转化为01背包模型——关键是找到「物品」（待选择的元素/字符串等）、「容量」（限制条件，如重量、和、0/1数量等）、「目标」（最大价值、可行性、方案数等）。</p>
</li>
</ol>
<p>通过基础模型+变形练习，熟练掌握表格填充逻辑和5步拆解方法，就能将复杂的DP问题转化为有序的表格填充过程，彻底攻克01背包这一DP核心模型。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MyBatis插件模块详解]]></title>    <link>https://juejin.cn/post/7591728734984028187</link>    <guid>https://juejin.cn/post/7591728734984028187</guid>    <pubDate>2026-01-06T01:01:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591728734984028187" data-draft-id="7591635567588818990" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MyBatis插件模块详解"/> <meta itemprop="keywords" content="MyBatis"/> <meta itemprop="datePublished" content="2026-01-06T01:01:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MyBatis插件模块详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T01:01:24.000Z" title="Tue Jan 06 2026 01:01:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">MyBatis插件模块详解</h2>
<h3 data-id="heading-1">一、MyBatis整体架构与插件模块</h3>
<p>在深入插件模块之前，我们先了解MyBatis的整体架构，以及插件模块在其中的重要地位。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/04f81476a5ed4bc7a342e2a2119e8d83~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768266084&amp;x-signature=XL6Cg%2BcL9%2B%2FYLn30lMDPeXelbB4%3D" alt="" loading="lazy"/></p>
<p>从上图可以看出，MyBatis采用了分层架构设计，而插件模块（Plugin）通过动态代理机制横切整个框架，能够在核心组件的执行过程中插入自定义逻辑。它为MyBatis提供了强大的扩展能力，使得开发者可以在不修改源码的情况下增强框架功能。</p>
<h4 data-id="heading-2">1.1 插件模块的核心职责</h4>
<p>插件模块主要承担以下核心职责：</p>
<ol>
<li><strong>扩展框架功能</strong>：在不动源码的情况下增强MyBatis功能</li>
<li><strong>拦截核心组件</strong>：拦截Executor、StatementHandler、ParameterHandler、ResultSetHandler</li>
<li><strong>实现AOP功能</strong>：通过动态代理实现面向切面编程</li>
<li><strong>统一权限控制</strong>：实现数据权限过滤</li>
<li><strong>性能监控</strong>：记录SQL执行时间和性能指标</li>
<li><strong>分页查询</strong>：实现物理分页功能</li>
</ol>
<h4 data-id="heading-3">1.2 为什么需要插件</h4>
<p>在实际开发中，我们经常有这些需求：</p>
<pre><code class="hljs language-sql" lang="sql">需求场景：
├── <span class="hljs-keyword">SQL</span>性能监控：记录慢查询
├── 数据权限控制：根据用户权限过滤数据
├── 分页查询：自动实现物理分页
├── 乐观锁：自动更新版本号
├── 审计日志：记录操作日志
└── 加密解密：敏感数据加密存储
</code></pre>
<p>如果没有插件机制，我们需要修改MyBatis源码或编写大量重复代码。插件机制让我们可以优雅地实现这些功能。</p>
<h4 data-id="heading-4">1.3 插件的实现原理</h4>
<p>MyBatis的插件基于<strong>动态代理</strong>实现：</p>
<pre><code class="hljs language-scss" lang="scss">目标对象
    ↓
使用Plugin<span class="hljs-selector-class">.wrap</span>()包装
    ↓
生成代理对象
    ↓
调用<span class="hljs-built_in">intercept</span>()方法
    ↓
执行自定义逻辑
    ↓
调用目标方法或继续传递
</code></pre>
<h3 data-id="heading-5">二、插件拦截机制</h3>
<p>MyBatis的插件机制基于Java动态代理和责任链模式。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/376d0f3b8bdd4bf2aab8036be24069cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768266084&amp;x-signature=IjvaLOW%2FLiZ5HKC7PF1fbGuAqNk%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-6">2.1 Interceptor接口</h4>
<p>MyBatis插件的核心是Interceptor接口：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-comment">/**
     * 拦截方法，在这里实现自定义逻辑
     * <span class="hljs-doctag">@param</span> invocation 代理调用对象
     * <span class="hljs-doctag">@return</span> 方法执行结果
     * <span class="hljs-doctag">@throws</span> Throwable 异常
     */</span>
    Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;

    <span class="hljs-comment">/**
     * 包装目标对象，生成代理对象
     * <span class="hljs-doctag">@param</span> target 目标对象
     * <span class="hljs-doctag">@return</span> 代理对象
     */</span>
    <span class="hljs-keyword">default</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> {
        <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>);
    }

    <span class="hljs-comment">/**
     * 设置插件属性
     * <span class="hljs-doctag">@param</span> properties 配置属性
     */</span>
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> {
        <span class="hljs-comment">// NOP</span>
    }
}
</code></pre>
<h4 data-id="heading-7">2.2 Invocation类</h4>
<p>Invocation封装了方法调用的相关信息：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invocation</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;      <span class="hljs-comment">// 目标对象</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;      <span class="hljs-comment">// 目标方法</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] args;      <span class="hljs-comment">// 方法参数</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Invocation</span><span class="hljs-params">(Object target, Method method, Object[] args)</span> {
        <span class="hljs-built_in">this</span>.target = target;
        <span class="hljs-built_in">this</span>.method = method;
        <span class="hljs-built_in">this</span>.args = args;
    }

    <span class="hljs-comment">// 执行目标方法</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException {
        <span class="hljs-keyword">return</span> method.invoke(target, args);
    }

    <span class="hljs-comment">// Getter方法</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getTarget</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> target; }
    <span class="hljs-keyword">public</span> Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> method; }
    <span class="hljs-keyword">public</span> Object[] getArgs() { <span class="hljs-keyword">return</span> args; }
}
</code></pre>
<h4 data-id="heading-8">2.3 Plugin类</h4>
<p>Plugin是代理对象的InvocationHandler：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Plugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Interceptor interceptor;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;

    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Plugin</span><span class="hljs-params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap)</span> {
        <span class="hljs-built_in">this</span>.target = target;
        <span class="hljs-built_in">this</span>.interceptor = interceptor;
        <span class="hljs-built_in">this</span>.signatureMap = signatureMap;
    }

    <span class="hljs-comment">// 静态工厂方法，包装目标对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">wrap</span><span class="hljs-params">(Object target, Interceptor interceptor)</span> {
        <span class="hljs-comment">// 获取拦截的类和方法签名</span>
        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);
        Class&lt;?&gt; type = target.getClass();

        <span class="hljs-comment">// 获取需要拦截的接口</span>
        Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);

        <span class="hljs-keyword">if</span> (interfaces.length &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 创建代理对象</span>
            <span class="hljs-keyword">return</span> Proxy.newProxyInstance(
                type.getClassLoader(),
                interfaces,
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plugin</span>(target, interceptor, signatureMap)
            );
        }
        <span class="hljs-keyword">return</span> target;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 获取需要拦截的方法集合</span>
            Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());
            <span class="hljs-keyword">if</span> (methods != <span class="hljs-literal">null</span> &amp;&amp; methods.contains(method)) {
                <span class="hljs-comment">// 执行拦截器的intercept方法</span>
                <span class="hljs-keyword">return</span> interceptor.intercept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Invocation</span>(target, method, args));
            }
            <span class="hljs-comment">// 不需要拦截，直接执行</span>
            <span class="hljs-keyword">return</span> method.invoke(target, args);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(e);
        }
    }

    <span class="hljs-comment">// 获取签名映射</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) {
        <span class="hljs-type">Intercepts</span> <span class="hljs-variable">interceptsAnnotation</span> <span class="hljs-operator">=</span> interceptor.getClass().getAnnotation(Intercepts.class);
        <span class="hljs-keyword">if</span> (interceptsAnnotation == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PluginException</span>(<span class="hljs-string">"No @Intercepts annotation was found in interceptor "</span> + interceptor.getClass().getName());
        }

        Signature[] sigs = interceptsAnnotation.value();
        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (Signature sig : sigs) {
            Set&lt;Method&gt; methods = signatureMap.computeIfAbsent(sig.type(), k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());
            <span class="hljs-keyword">try</span> {
                <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> sig.type().getMethod(sig.method(), sig.args());
                methods.add(method);
            } <span class="hljs-keyword">catch</span> (NoSuchMethodException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PluginException</span>(<span class="hljs-string">"Could not find method on "</span> + sig.type() + <span class="hljs-string">" named "</span> + sig.method() + <span class="hljs-string">". Cause: "</span> + e, e);
            }
        }
        <span class="hljs-keyword">return</span> signatureMap;
    }

    <span class="hljs-comment">// 获取所有需要拦截的接口</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) {
        Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        <span class="hljs-keyword">while</span> (type != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) {
                <span class="hljs-keyword">if</span> (signatureMap.containsKey(c)) {
                    interfaces.add(c);
                }
            }
            type = type.getSuperclass();
        }
        <span class="hljs-keyword">return</span> interfaces.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[interfaces.size()]);
    }
}
</code></pre>
<h3 data-id="heading-9">三、四大核心拦截点</h3>
<p>MyBatis允许拦截四个核心组件。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b57dd653d6da47859ffb044ca5505fe8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768266084&amp;x-signature=fBdirpJeiVsdEgFWq%2BY1B60fac0%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-10">3.1 Executor（执行器）</h4>
<p>Executor是MyBatis的核心执行器，负责SQL的执行。</p>
<p><strong>可拦截方法：</strong></p>
<ul>
<li><code>update(MappedStatement ms, Object parameter)</code> - 执行增删改</li>
<li><code>query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</code> - 查询</li>
<li><code>query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</code> - 查询（带缓存）</li>
<li><code>flushStatements()</code> - 刷新批处理</li>
<li><code>commit()</code> - 提交事务</li>
<li><code>rollback()</code> - 回滚事务</li>
<li><code>getTransaction()</code> - 获取事务</li>
<li><code>close()</code> - 关闭会话</li>
<li><code>isClosed()</code> - 是否关闭</li>
</ul>
<p><strong>示例：性能监控插件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(type = Executor.class,
               method = "update",
               args = {MappedStatement.class, Object.class}),
    @Signature(type = Executor.class,
               method = "query",
               args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceMonitorPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> threshold; <span class="hljs-comment">// 慢查询阈值</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> (MappedStatement) invocation.getArgs()[<span class="hljs-number">0</span>];
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 执行目标方法</span>
            <span class="hljs-keyword">return</span> invocation.proceed();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
            <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> end - start;

            <span class="hljs-keyword">if</span> (time &gt; threshold) {
                <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> ms.getBoundSql(<span class="hljs-literal">null</span>).getSql();
                System.out.println(<span class="hljs-string">"慢查询警告: "</span> + ms.getId() + <span class="hljs-string">" 耗时: "</span> + time + <span class="hljs-string">"ms"</span>);
                System.out.println(<span class="hljs-string">"SQL: "</span> + sql);
            }
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> {
        <span class="hljs-built_in">this</span>.threshold = Long.parseLong(properties.getProperty(<span class="hljs-string">"threshold"</span>, <span class="hljs-string">"1000"</span>));
    }
}
</code></pre>
<h4 data-id="heading-11">3.2 StatementHandler（语句处理器）</h4>
<p>StatementHandler负责创建Statement对象并设置参数。</p>
<p><strong>可拦截方法：</strong></p>
<ul>
<li><code>prepare(Connection connection)</code> - 准备Statement</li>
<li><code>parameterize(Statement statement)</code> - 设置参数</li>
<li><code>batch(Statement statement)</code> - 批处理</li>
<li><code>update(Statement statement)</code> - 执行更新</li>
<li><code>query(Statement statement, ResultHandler resultHandler)</code> - 执行查询</li>
<li><code>getBoundSql()</code> - 获取BoundSql</li>
<li><code>getParameterHandler()</code> - 获取ParameterHandler</li>
<li><code>getResultHandler()</code> - 获取ResultSetHandler</li>
</ul>
<p><strong>示例：SQL重写插件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(type = StatementHandler.class,
               method = "prepare",
               args = {Connection.class, Integer.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SQLRewritePlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">StatementHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (StatementHandler) invocation.getTarget();
        <span class="hljs-type">BoundSql</span> <span class="hljs-variable">boundSql</span> <span class="hljs-operator">=</span> handler.getBoundSql();
        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> boundSql.getSql();

        <span class="hljs-comment">// 重写SQL：添加数据权限过滤</span>
        <span class="hljs-keyword">if</span> (sql.toLowerCase().startsWith(<span class="hljs-string">"select"</span>)) {
            sql = rewriteSQL(sql);
            <span class="hljs-comment">// 使用反射修改sql字段</span>
            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> boundSql.getClass().getDeclaredField(<span class="hljs-string">"sql"</span>);
            field.setAccessible(<span class="hljs-literal">true</span>);
            field.set(boundSql, sql);
        }

        <span class="hljs-keyword">return</span> invocation.proceed();
    }

    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">rewriteSQL</span><span class="hljs-params">(String sql)</span> {
        <span class="hljs-comment">// 添加数据权限过滤条件</span>
        <span class="hljs-keyword">return</span> sql + <span class="hljs-string">" AND tenant_id = '"</span> + getCurrentTenantId() + <span class="hljs-string">"'"</span>;
    }

    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getCurrentTenantId</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 获取当前租户ID</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"1001"</span>;
    }
}
</code></pre>
<h4 data-id="heading-12">3.3 ParameterHandler（参数处理器）</h4>
<p>ParameterHandler负责设置PreparedStatement的参数。</p>
<p><strong>可拦截方法：</strong></p>
<ul>
<li><code>getParameterObject()</code> - 获取参数对象</li>
<li><code>setParameters(PreparedStatement ps)</code> - 设置参数</li>
</ul>
<p><strong>示例：参数加密插件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(type = ParameterHandler.class,
               method = "setParameters",
               args = {PreparedStatement.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParameterEncryptPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">ParameterHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (ParameterHandler) invocation.getTarget();
        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> (PreparedStatement) invocation.getArgs()[<span class="hljs-number">0</span>];

        <span class="hljs-comment">// 获取参数对象</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">parameterObject</span> <span class="hljs-operator">=</span> handler.getParameterObject();

        <span class="hljs-keyword">if</span> (parameterObject <span class="hljs-keyword">instanceof</span> User) {
            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) parameterObject;
            <span class="hljs-comment">// 加密敏感字段</span>
            <span class="hljs-keyword">if</span> (user.getPassword() != <span class="hljs-literal">null</span>) {
                user.setPassword(encrypt(user.getPassword()));
            }
        }

        <span class="hljs-comment">// 继续执行</span>
        <span class="hljs-keyword">return</span> invocation.proceed();
    }

    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String plainText)</span> {
        <span class="hljs-comment">// Base64简单加密</span>
        <span class="hljs-keyword">return</span> Base64.getEncoder().encodeToString(plainText.getBytes());
    }
}
</code></pre>
<h4 data-id="heading-13">3.4 ResultSetHandler（结果集处理器）</h4>
<p>ResultSetHandler负责将ResultSet映射为Java对象。</p>
<p><strong>可拦截方法：</strong></p>
<ul>
<li><code>handleResultSets(Statement stmt)</code> - 处理结果集</li>
<li><code>handleOutputParameters(CallableStatement cs)</code> - 处理存储过程输出参数</li>
</ul>
<p><strong>示例：结果解密插件</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(type = ResultSetHandler.class,
               method = "handleResultSets",
               args = {Statement.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultDecryptPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-comment">// 执行查询</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();

        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> List) {
            List&lt;?&gt; list = (List&lt;?&gt;) result;
            <span class="hljs-keyword">for</span> (Object obj : list) {
                <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> User) {
                    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) obj;
                    <span class="hljs-comment">// 解密敏感字段</span>
                    <span class="hljs-keyword">if</span> (user.getIdCard() != <span class="hljs-literal">null</span>) {
                        user.setIdCard(decrypt(user.getIdCard()));
                    }
                }
            }
        }

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">decrypt</span><span class="hljs-params">(String cipherText)</span> {
        <span class="hljs-comment">// Base64解密</span>
        <span class="hljs-type">byte</span>[] decoded = Base64.getDecoder().decode(cipherText);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(decoded);
    }
}
</code></pre>
<h3 data-id="heading-14">四、插件实现流程</h3>
<p>理解插件的实现和配置流程非常重要。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/63ec6d601cf04e6195e137b7161c2de0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768266084&amp;x-signature=PfgiCJnROyaWkBgfLlldqLCtG%2BM%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-15">4.1 实现自定义插件</h4>
<p><strong>步骤1：实现Interceptor接口</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(type = Executor.class,
               method = "query",
               args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-comment">// 前置逻辑</span>
        System.out.println(<span class="hljs-string">"Before: "</span> + invocation.getMethod().getName());

        <span class="hljs-comment">// 执行目标方法</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();

        <span class="hljs-comment">// 后置逻辑</span>
        System.out.println(<span class="hljs-string">"After: "</span> + invocation.getMethod().getName());

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> {
        <span class="hljs-comment">// 使用Plugin.wrap包装目标对象</span>
        <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> {
        <span class="hljs-comment">// 读取配置属性</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">propertyName</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">"propertyName"</span>);
        System.out.println(<span class="hljs-string">"Property: "</span> + propertyName);
    }
}
</code></pre>
<h4 data-id="heading-16">4.2 配置插件</h4>
<p><strong>方式1：XML配置</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 性能监控插件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"com.example.plugin.PerformanceMonitorPlugin"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"threshold"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1000"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 分页插件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"helperDialect"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mysql"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 自定义插件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"com.example.plugin.CustomPlugin"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"propertyName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"propertyValue"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
</code></pre>
<p><strong>方式2：代码配置</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 创建Configuration</span>
<span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();

<span class="hljs-comment">// 添加插件</span>
configuration.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceMonitorPlugin</span>());
configuration.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInterceptor</span>());
configuration.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomPlugin</span>());

<span class="hljs-comment">// 创建SqlSessionFactory</span>
<span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(configuration);
</code></pre>
<p><strong>方式3：Spring配置</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisConfig</span> {

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> PerformanceMonitorPlugin <span class="hljs-title function_">performanceMonitorPlugin</span><span class="hljs-params">()</span> {
        <span class="hljs-type">PerformanceMonitorPlugin</span> <span class="hljs-variable">plugin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceMonitorPlugin</span>();
        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
        properties.setProperty(<span class="hljs-string">"threshold"</span>, <span class="hljs-string">"1000"</span>);
        plugin.setProperties(properties);
        <span class="hljs-keyword">return</span> plugin;
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span>();
        sessionFactory.setDataSource(dataSource);

        <span class="hljs-comment">// 添加插件</span>
        sessionFactory.setPlugins(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Interceptor</span>[]{
                performanceMonitorPlugin(),
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInterceptor</span>()
            }
        );

        <span class="hljs-keyword">return</span> sessionFactory.getObject();
    }
}
</code></pre>
<h4 data-id="heading-17">4.3 插件链的执行顺序</h4>
<p>当配置了多个插件时，它们会形成责任链：</p>
<pre><code class="hljs language-markdown" lang="markdown">原始Executor
<span class="hljs-code">    ↓
被Plugin1包装
    ↓
被Plugin2包装
    ↓
被Plugin3包装
    ↓
最终代理对象
</span></code></pre>
<p><strong>执行顺序：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 配置顺序</span>
&lt;plugin interceptor=<span class="hljs-string">"Plugin1"</span>/&gt;
&lt;plugin interceptor=<span class="hljs-string">"Plugin2"</span>/&gt;
&lt;plugin interceptor=<span class="hljs-string">"Plugin3"</span>/&gt;

<span class="hljs-comment">// 执行顺序</span>
Plugin3.intercept() → Plugin2.intercept() → Plugin1.intercept() → 目标方法

<span class="hljs-comment">// 返回顺序</span>
目标方法 → Plugin1处理 → Plugin2处理 → Plugin3处理 → 最终结果
</code></pre>
<h3 data-id="heading-18">五、动态代理链</h3>
<p>多个插件会形成多层代理。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65d91917add24b7c9d1b12ec97a4f0c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768266084&amp;x-signature=AY2EduC0AhBumeu08NMzLTLZ%2Bz8%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-19">5.1 代理链的构建</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 原始对象</span>
<span class="hljs-type">Executor</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleExecutor</span>();

<span class="hljs-comment">// 第一次包装</span>
<span class="hljs-type">Executor</span> <span class="hljs-variable">proxy1</span> <span class="hljs-operator">=</span> (Executor) Plugin.wrap(target, plugin1);

<span class="hljs-comment">// 第二次包装（包装的是代理对象）</span>
<span class="hljs-type">Executor</span> <span class="hljs-variable">proxy2</span> <span class="hljs-operator">=</span> (Executor) Plugin.wrap(proxy1, plugin2);

<span class="hljs-comment">// 第三次包装</span>
<span class="hljs-type">Executor</span> <span class="hljs-variable">proxy3</span> <span class="hljs-operator">=</span> (Executor) Plugin.wrap(proxy2, plugin3);

<span class="hljs-comment">// proxy3是最外层的代理</span>
</code></pre>
<h4 data-id="heading-20">5.2 代理链的执行</h4>
<pre><code class="hljs language-scss" lang="scss">调用 proxy3<span class="hljs-selector-class">.query</span>()
    ↓
Plugin3<span class="hljs-selector-class">.invoke</span>()
    ↓
Plugin3<span class="hljs-selector-class">.intercept</span>()
    ↓
invocation<span class="hljs-selector-class">.proceed</span>() 调用 proxy2<span class="hljs-selector-class">.query</span>()
    ↓
Plugin2<span class="hljs-selector-class">.invoke</span>()
    ↓
Plugin2<span class="hljs-selector-class">.intercept</span>()
    ↓
invocation<span class="hljs-selector-class">.proceed</span>() 调用 proxy1<span class="hljs-selector-class">.query</span>()
    ↓
Plugin1<span class="hljs-selector-class">.invoke</span>()
    ↓
Plugin1<span class="hljs-selector-class">.intercept</span>()
    ↓
invocation<span class="hljs-selector-class">.proceed</span>() 调用 target<span class="hljs-selector-class">.query</span>()
    ↓
执行真正的查询
    ↓
返回结果
    ↓
Plugin1处理返回值
    ↓
Plugin2处理返回值
    ↓
Plugin3处理返回值
    ↓
最终返回
</code></pre>
<h4 data-id="heading-21">5.3 代理链示例代码</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts(@Signature(type = Executor.class, method = "query",
        args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}))</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Plugin1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        System.out.println(<span class="hljs-string">"Plugin1 Before"</span>);
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();
        System.out.println(<span class="hljs-string">"Plugin1 After"</span>);
        <span class="hljs-keyword">return</span> result;
    }
}

<span class="hljs-meta">@Intercepts(@Signature(type = Executor.class, method = "query",
        args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}))</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Plugin2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        System.out.println(<span class="hljs-string">"Plugin2 Before"</span>);
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();
        System.out.println(<span class="hljs-string">"Plugin2 After"</span>);
        <span class="hljs-keyword">return</span> result;
    }
}

<span class="hljs-comment">// 输出结果：</span>
<span class="hljs-comment">// Plugin2 Before</span>
<span class="hljs-comment">// Plugin1 Before</span>
<span class="hljs-comment">// 执行查询</span>
<span class="hljs-comment">// Plugin1 After</span>
<span class="hljs-comment">// Plugin2 After</span>
</code></pre>
<h3 data-id="heading-22">六、典型应用场景</h3>
<p>插件在实际开发中有很多应用场景。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c52ee22080dd483fa7c4b17fcca0ecd7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768266084&amp;x-signature=EKTNHFhLLi5vOlDQxI1OM8RA4g8%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-23">6.1 分页插件</h4>
<p><strong>PageHelper是最著名的MyBatis分页插件：</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p><strong>配置：</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"helperDialect"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mysql"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"reasonable"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p><strong>使用：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 查询前调用分页</span>
PageHelper.startPage(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);
List&lt;User&gt; users = userMapper.selectAll();

<span class="hljs-comment">// 获取分页信息</span>
PageInfo&lt;User&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(users);
System.out.println(<span class="hljs-string">"总数: "</span> + pageInfo.getTotal());
System.out.println(<span class="hljs-string">"页数: "</span> + pageInfo.getPages());
</code></pre>
<h4 data-id="heading-24">6.2 性能监控插件</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(type = Executor.class,
               method = "update",
               args = {MappedStatement.class, Object.class}),
    @Signature(type = Executor.class,
               method = "query",
               args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SlowQueryMonitorPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SlowQueryMonitorPlugin.class);
    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> slowQueryThreshold;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> (MappedStatement) invocation.getArgs()[<span class="hljs-number">0</span>];
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> invocation.proceed();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-type">long</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;
            <span class="hljs-keyword">if</span> (cost &gt; slowQueryThreshold) {
                <span class="hljs-type">BoundSql</span> <span class="hljs-variable">boundSql</span> <span class="hljs-operator">=</span> ms.getBoundSql(invocation.getArgs()[<span class="hljs-number">1</span>]);
                <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> boundSql.getSql();
                logger.warn(<span class="hljs-string">"慢查询: {} 耗时: {}ms\nSQL: {}"</span>, ms.getId(), cost, sql);
            }
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> {
        <span class="hljs-built_in">this</span>.slowQueryThreshold = Long.parseLong(properties.getProperty(<span class="hljs-string">"threshold"</span>, <span class="hljs-string">"1000"</span>));
    }
}
</code></pre>
<h4 data-id="heading-25">6.3 数据权限插件</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(type = StatementHandler.class,
               method = "prepare",
               args = {Connection.class, Integer.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataPermissionPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">StatementHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (StatementHandler) invocation.getTarget();
        <span class="hljs-type">BoundSql</span> <span class="hljs-variable">boundSql</span> <span class="hljs-operator">=</span> handler.getBoundSql();
        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> boundSql.getSql();

        <span class="hljs-comment">// 获取当前用户的数据权限</span>
        Set&lt;Long&gt; deptIds = getCurrentUserDeptIds();

        <span class="hljs-comment">// 重写SQL，添加数据权限过滤</span>
        <span class="hljs-keyword">if</span> (sql.toLowerCase().startsWith(<span class="hljs-string">"select"</span>) &amp;&amp; !deptIds.isEmpty()) {
            <span class="hljs-type">String</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> <span class="hljs-string">"dept_id IN ("</span> + String.join(<span class="hljs-string">","</span>, deptIds.toString()) + <span class="hljs-string">")"</span>;
            sql = addDataPermission(sql, condition);

            <span class="hljs-comment">// 使用反射修改SQL</span>
            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> boundSql.getClass().getDeclaredField(<span class="hljs-string">"sql"</span>);
            field.setAccessible(<span class="hljs-literal">true</span>);
            field.set(boundSql, sql);
        }

        <span class="hljs-keyword">return</span> invocation.proceed();
    }

    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">addDataPermission</span><span class="hljs-params">(String sql, String condition)</span> {
        <span class="hljs-comment">// 简单实现：在WHERE后添加条件</span>
        <span class="hljs-keyword">if</span> (sql.toLowerCase().contains(<span class="hljs-string">"where"</span>)) {
            <span class="hljs-keyword">return</span> sql + <span class="hljs-string">" AND "</span> + condition;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> sql + <span class="hljs-string">" WHERE "</span> + condition;
        }
    }

    <span class="hljs-keyword">private</span> Set&lt;Long&gt; <span class="hljs-title function_">getCurrentUserDeptIds</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 从上下文获取当前用户的数据权限</span>
        <span class="hljs-keyword">return</span> SecurityContextHolder.getCurrentUserDataPermission();
    }
}
</code></pre>
<h4 data-id="heading-26">6.4 乐观锁插件</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(type = Executor.class,
               method = "update",
               args = {MappedStatement.class, Object.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimisticLockPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">Object</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> invocation.getArgs()[<span class="hljs-number">1</span>];

        <span class="hljs-keyword">if</span> (parameter <span class="hljs-keyword">instanceof</span> BaseEntity) {
            <span class="hljs-type">BaseEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> (BaseEntity) parameter;
            <span class="hljs-comment">// 自动设置版本号</span>
            <span class="hljs-keyword">if</span> (entity.getVersion() == <span class="hljs-literal">null</span>) {
                entity.setVersion(<span class="hljs-number">0</span>);
            } <span class="hljs-keyword">else</span> {
                entity.setVersion(entity.getVersion() + <span class="hljs-number">1</span>);
            }
        }

        <span class="hljs-keyword">return</span> invocation.proceed();
    }
}
</code></pre>
<h4 data-id="heading-27">6.5 审计日志插件</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Intercepts({
    @Signature(type = Executor.class,
               method = "update",
               args = {MappedStatement.class, Object.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuditLogPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> (MappedStatement) invocation.getArgs()[<span class="hljs-number">0</span>];
        <span class="hljs-type">Object</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> invocation.getArgs()[<span class="hljs-number">1</span>];

        <span class="hljs-comment">// 记录操作日志</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">operation</span> <span class="hljs-operator">=</span> ms.getId();
        <span class="hljs-type">String</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> getCurrentUser();
        <span class="hljs-type">Date</span> <span class="hljs-variable">operateTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();

        System.out.println(<span class="hljs-string">"操作人: "</span> + operator);
        System.out.println(<span class="hljs-string">"操作时间: "</span> + operateTime);
        System.out.println(<span class="hljs-string">"操作类型: "</span> + operation);
        System.out.println(<span class="hljs-string">"操作数据: "</span> + parameter);

        <span class="hljs-comment">// 执行目标方法</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();

        <span class="hljs-comment">// 记录操作结果</span>
        System.out.println(<span class="hljs-string">"影响行数: "</span> + result);

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getCurrentUser</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 获取当前登录用户</span>
        <span class="hljs-keyword">return</span> SecurityContextHolder.getCurrentUser().getUsername();
    }
}
</code></pre>
<h3 data-id="heading-28">七、最佳实践</h3>
<h4 data-id="heading-29">7.1 插件设计原则</h4>
<ol>
<li><strong>最小侵入</strong>：尽量不修改原有逻辑</li>
<li><strong>可配置性</strong>：通过属性配置开关</li>
<li><strong>性能考虑</strong>：避免在插件中执行耗时操作</li>
<li><strong>异常处理</strong>：妥善处理异常，避免影响正常流程</li>
<li><strong>日志记录</strong>：记录关键操作日志</li>
</ol>
<h4 data-id="heading-30">7.2 性能优化</h4>
<ol>
<li><strong>减少反射使用</strong>：缓存Field/Method对象</li>
<li><strong>避免复杂计算</strong>：插件逻辑要简单高效</li>
<li><strong>使用缓存</strong>：缓存常用数据</li>
<li><strong>异步处理</strong>：日志等操作异步执行</li>
</ol>
<h4 data-id="heading-31">7.3 常见问题解决</h4>
<h5 data-id="heading-32">问题1：插件不生效</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 原因：@Signature配置错误</span>
<span class="hljs-comment">// 错误：方法签名不匹配</span>
<span class="hljs-meta">@Signature(type = Executor.class,
           method = "query",
           args = {MappedStatement.class, Object.class})</span> <span class="hljs-comment">// 缺少参数</span>

<span class="hljs-comment">// 正确：完整的方法签名</span>
<span class="hljs-meta">@Signature(type = Executor.class,
           method = "query",
           args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})</span>
</code></pre>
<h5 data-id="heading-33">问题2：修改SQL失败</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 原因：直接修改sql字段不生效</span>
boundSql.setSql(newSql); <span class="hljs-comment">// BoundSql没有setSql方法</span>

<span class="hljs-comment">// 正确：使用反射修改</span>
<span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> boundSql.getClass().getDeclaredField(<span class="hljs-string">"sql"</span>);
field.setAccessible(<span class="hljs-literal">true</span>);
field.set(boundSql, newSql);
</code></pre>
<h5 data-id="heading-34">问题3：插件顺序混乱</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 建议：按执行顺序配置 --&gt;</span>
<span class="hljs-comment">&lt;!-- 分页插件应该先执行 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"PageInterceptor"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 数据权限插件后执行 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"DataPermissionPlugin"</span>/&gt;</span>
</code></pre>
<h4 data-id="heading-35">7.4 插件开发模板</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 插件开发模板
 */</span>
<span class="hljs-meta">@Intercepts({
    @Signature(type = Executor.class,
               method = "query",
               args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplatePlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(TemplatePlugin.class);

    <span class="hljs-comment">// 配置属性</span>
    <span class="hljs-keyword">private</span> String configProperty;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-comment">// 1. 前置处理</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> invocation.getTarget();
        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> invocation.getMethod();
        Object[] args = invocation.getArgs();

        logger.debug(<span class="hljs-string">"Before intercept: {}"</span>, method.getName());

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 2. 执行目标方法</span>
            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();

            <span class="hljs-comment">// 3. 后置处理</span>
            logger.debug(<span class="hljs-string">"After intercept: {}"</span>, method.getName());

            <span class="hljs-keyword">return</span> result;
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// 4. 异常处理</span>
            logger.error(<span class="hljs-string">"Plugin error"</span>, e);
            <span class="hljs-keyword">throw</span> e;
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> {
        <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> {
        <span class="hljs-built_in">this</span>.configProperty = properties.getProperty(<span class="hljs-string">"configProperty"</span>, <span class="hljs-string">"defaultValue"</span>);
        logger.info(<span class="hljs-string">"Plugin initialized with property: {}"</span>, configProperty);
    }
}
</code></pre>
<h3 data-id="heading-36">八、总结</h3>
<p>MyBatis的插件模块提供了强大的扩展能力，使得开发者可以在不修改源码的情况下增强框架功能。</p>
<h4 data-id="heading-37">核心要点</h4>
<ol>
<li><strong>Interceptor接口</strong>：定义插件的核心接口</li>
<li><strong>四大拦截点</strong>：Executor、StatementHandler、ParameterHandler、ResultSetHandler</li>
<li><strong>动态代理</strong>：基于JDK动态代理实现</li>
<li><strong>责任链模式</strong>：多个插件形成责任链</li>
<li><strong>应用场景</strong>：分页、监控、权限、加密、日志等</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让 JSON 数据可视化：两款 Vue 组件实战解析]]></title>    <link>https://juejin.cn/post/7591801024009830409</link>    <guid>https://juejin.cn/post/7591801024009830409</guid>    <pubDate>2026-01-06T03:23:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591801024009830409" data-draft-id="7591800417255358473" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让 JSON 数据可视化：两款 Vue 组件实战解析"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2026-01-06T03:23:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端大鱼"/> <meta itemprop="url" content="https://juejin.cn/user/395479916219517"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让 JSON 数据可视化：两款 Vue 组件实战解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/395479916219517/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端大鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:23:41.000Z" title="Tue Jan 06 2026 03:23:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近的项目中正好遇到JSON格式化展示的需求，需要在前端清晰美观的展示JSON数据结构。</p>
<p>调研了下Vue生态中有两款出色的组件：vue-json-pretty和vue-json-viewer，它们都能将JSON数据变得直观易读。</p>
<h2 data-id="heading-0">组件定位与核心差异</h2>
<p><strong>vue-json-pretty</strong>更像是<strong>功能全面的JSON编辑器</strong>。它采用树形结构展示数据，支持节点编辑、虚拟滚动和深度自定义。如果你需要用户交互或处理大型数据集，这是更好的选择。</p>
<p><strong>vue-json-viewer</strong>则定位为<strong>简洁高效的查看器</strong>。它专注于快速展示和便捷复制，API简单直接。对于只需展示不需编辑的场景，它更加轻量实用。</p>
<p>实际选择时，问问自己：需要编辑功能吗？数据量有多大？需要多深的自定义？回答这些问题后，选择就清晰了。</p>
<h2 data-id="heading-1">vue-json-pretty：美观实用的JSON编辑器</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17eda1a282704bd7b9a616d1a89c8db7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5aSn6bG8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768274620&amp;x-signature=ghgMp6mFBsBdtWOeO2auxP4shcg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-2">基础使用</h3>
<p>安装很简单：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Vue 3</span>
npm install vue-json-pretty --save

<span class="hljs-comment"># Vue 2</span>
npm install vue-json-pretty@v1-latest --save
</code></pre>
<p>基本集成：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">vue-json-pretty</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">"apiResponse"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> <span class="hljs-title class_">VueJsonPretty</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-json-pretty'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'vue-json-pretty/lib/styles.css'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: { <span class="hljs-title class_">VueJsonPretty</span> },
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">apiResponse</span>: {
        <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">123</span> },
        <span class="hljs-attr">status</span>: <span class="hljs-string">'active'</span>,
        <span class="hljs-attr">permissions</span>: [<span class="hljs-string">'read'</span>, <span class="hljs-string">'write'</span>]
      }
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-3">核心优势</h3>
<p><strong>树形结构清晰</strong>：缩进和连接线让嵌套数据一目了然。数组和对象会显示长度，快速掌握数据结构。</p>
<p><strong>编辑功能实用</strong>：开启编辑模式后，用户可以直接修改数值（ps：所以我最后选了它）：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">vue-json-pretty</span>
  <span class="hljs-attr">:data</span>=<span class="hljs-string">"configData"</span>
  <span class="hljs-attr">:editable</span>=<span class="hljs-string">"true"</span>
  @<span class="hljs-attr">data-change</span>=<span class="hljs-string">"handleConfigUpdate"</span>
/&gt;</span>
</code></pre>
<p>这对于配置编辑器、主题定制器等场景特别有用。</p>
<p><strong>虚拟滚动处理大数据</strong>：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">vue-json-pretty</span>
  <span class="hljs-attr">:data</span>=<span class="hljs-string">"largeDataset"</span>
  <span class="hljs-attr">:virtual</span>=<span class="hljs-string">"true"</span>
  <span class="hljs-attr">:item-height</span>=<span class="hljs-string">"24"</span>
/&gt;</span>
</code></pre>
<p>即使渲染数千节点，依然保持流畅。</p>
<p><strong>高度可定制</strong>：控制展示细节的选项丰富：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">vue-json-pretty</span>
  <span class="hljs-attr">:data</span>=<span class="hljs-string">"complexData"</span>
  <span class="hljs-attr">:show-length</span>=<span class="hljs-string">"true"</span>
  <span class="hljs-attr">:show-line</span>=<span class="hljs-string">"true"</span>
  <span class="hljs-attr">:deep</span>=<span class="hljs-string">"3"</span>
  <span class="hljs-attr">:highlight-selected</span>=<span class="hljs-string">"true"</span>
  <span class="hljs-attr">:custom-value</span>=<span class="hljs-string">"renderTimestamp"</span>
/&gt;</span>
</code></pre>
<h3 data-id="heading-4">实战：API调试面板</h3>
<p>在实际开发中，我常用它构建API调试工具：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"api-debugger"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"request-panel"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>请求参数<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">vue-json-pretty</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">"requestParams"</span> <span class="hljs-attr">:deep</span>=<span class="hljs-string">"2"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"response-panel"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>响应数据<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">vue-json-pretty</span> 
        <span class="hljs-attr">:data</span>=<span class="hljs-string">"responseData"</span>
        <span class="hljs-attr">:highlight-selected</span>=<span class="hljs-string">"true"</span>
        @<span class="hljs-attr">node-click</span>=<span class="hljs-string">"copyNodeValue"</span>
      /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<h2 data-id="heading-5">vue-json-viewer：轻量高效的查看利器</h2>
<h3 data-id="heading-6">快速集成</h3>
<p>按Vue版本选择安装：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Vue 2</span>
npm install vue-json-viewer@2 --save

<span class="hljs-comment"># Vue 3  </span>
npm install vue-json-viewer@3 --save
</code></pre>
<p>基本使用：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">json-viewer</span> 
    <span class="hljs-attr">:value</span>=<span class="hljs-string">"logData"</span>
    <span class="hljs-attr">:expand-depth</span>=<span class="hljs-string">"2"</span>
    <span class="hljs-attr">copyable</span>
    <span class="hljs-attr">boxed</span>
  /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> <span class="hljs-title class_">JsonViewer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-json-viewer'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'vue-json-viewer/style.css'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: { <span class="hljs-title class_">JsonViewer</span> },
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">logData</span>: {
        <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
        <span class="hljs-attr">level</span>: <span class="hljs-string">'error'</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'数据库连接失败'</span>,
        <span class="hljs-attr">details</span>: { <span class="hljs-attr">retryCount</span>: <span class="hljs-number">3</span> }
      }
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-7">设计特点</h3>
<p><strong>极简但实用</strong>：没有多余功能，但复制、折叠、主题切换都做得很好。默认样式清爽，颜色区分明显。</p>
<p><strong>一键复制</strong>：添加<code>copyable</code>属性，每个值旁都会出现复制按钮，调试时特别方便。</p>
<p><strong>性能优化好</strong>：采用延迟加载策略，大文件初始加载快。但要注意，这会影响浏览器的全局搜索功能（Ctrl+F可能找不到未渲染内容）。</p>
<p><strong>主题支持</strong>：轻松切换明暗主题：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">json-viewer</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"data"</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">"dark"</span> /&gt;</span>
</code></pre>
<h3 data-id="heading-8">实战：系统日志查看器</h3>
<p>对于日志查看场景，vue-json-viewer非常合适：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"log-viewer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(log, index) in filteredLogs"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"log-meta"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"level-tag"</span>&gt;</span>{{ log.level }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"time"</span>&gt;</span>{{ formatTime(log.timestamp) }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">json-viewer</span> 
        <span class="hljs-attr">:value</span>=<span class="hljs-string">"log.data"</span>
        <span class="hljs-attr">:expand-depth</span>=<span class="hljs-string">"log.level === 'error' ? 3 : 1"</span>
        <span class="hljs-attr">copyable</span>
      /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<h2 data-id="heading-9">决策指南：如何选择？</h2>
<p>根据我的使用经验，选择建议如下：</p>
<p><strong>选vue-json-pretty当：</strong></p>
<ul>
<li>需要编辑JSON数据</li>
<li>处理超大型数据集（&gt;5MB）</li>
<li>要求深度自定义样式和交互</li>
<li>构建开发者工具或管理后台</li>
</ul>
<p><strong>选vue-json-viewer当：</strong></p>
<ul>
<li>只需查看不可编辑</li>
<li>需要频繁复制字段值</li>
<li>项目对包体积敏感</li>
<li>快速集成，最小配置</li>
</ul>
<h2 data-id="heading-10">实用技巧</h2>
<p><strong>处理循环引用</strong>：两个组件遇到循环引用都会出错。传递数据前先处理：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">safeStringify</span>(<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj, <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(value)) <span class="hljs-keyword">return</span> <span class="hljs-string">'[Circular]'</span>
      cache.<span class="hljs-title function_">add</span>(value)
    }
    <span class="hljs-keyword">return</span> value
  })
}
</code></pre>
<p><strong>自定义样式</strong>：使用深度选择器覆盖默认样式：</p>
<pre><code class="hljs language-css" lang="css">::v-deep .vjs-tree {
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Monaco'</span>, <span class="hljs-string">'Menlo'</span>, monospace;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">13px</span>;
}
</code></pre>
<h2 data-id="heading-11">总结</h2>
<p>vue-json-pretty和vue-json-viewer都是优秀的Vue JSON组件，选择取决于具体需求。
需要功能全面、支持编辑、处理大数据？选vue-json-pretty。只需简单展示、快速集成、便捷复制？选vue-json-viewer。</p>
<hr/>
<p>你是否有更好的JSON展示组件推荐？欢迎评论区留言。</p>
<p>关注微信公众号" <strong>大前端历险记</strong>"，掌握更多前端开发干货姿势！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C++ 程序员一定要会的 RPC 框架：gRPC 从原理到实战，一次写通服务端和客户端]]></title>    <link>https://juejin.cn/post/7591993600389726259</link>    <guid>https://juejin.cn/post/7591993600389726259</guid>    <pubDate>2026-01-06T06:07:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591993600389726259" data-draft-id="7591792747776376842" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C++ 程序员一定要会的 RPC 框架：gRPC 从原理到实战，一次写通服务端和客户端"/> <meta itemprop="keywords" content="后端,gRPC,C++"/> <meta itemprop="datePublished" content="2026-01-06T06:07:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="GetcharZp"/> <meta itemprop="url" content="https://juejin.cn/user/4328150938692264"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C++ 程序员一定要会的 RPC 框架：gRPC 从原理到实战，一次写通服务端和客户端
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4328150938692264/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    GetcharZp
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T06:07:42.000Z" title="Tue Jan 06 2026 06:07:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    37
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px}.markdown-body a:active,.markdown-body a:hover{text-decoration:none;border-bottom:1.5px solid #3eaf7c}.markdown-body a[href^=http]:after{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px}.markdown-body a[href^="#"]:before{content:"#"}.markdown-body table{display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:4px 8px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0}.markdown-body blockquote:before{display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none;padding-left:10px}.markdown-body ul li::marker{content:"•";color:#3eaf7c}.markdown-body ul li.task-list-item:before{content:"";margin-right:0}.markdown-body input[type=checkbox]{vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff}.markdown-body input[type=checkbox]:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}.markdown-body input[type=checkbox]:checked:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="monokai">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#272822;color:#ddd}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-strong,.hljs-tag{color:#f92672}.hljs-code{color:#66d9ef}.hljs-class .hljs-title{color:#fff}.hljs-attribute,.hljs-link,.hljs-regexp,.hljs-symbol{color:#bf79db}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-emphasis,.hljs-section,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string,.hljs-subst,.hljs-template-tag,.hljs-template-variable,.hljs-title,.hljs-type,.hljs-variable{color:#a6e22e}.hljs-comment,.hljs-deletion,.hljs-meta,.hljs-quote{color:#75715e}.hljs-doctag,.hljs-keyword,.hljs-literal,.hljs-section,.hljs-selector-id,.hljs-selector-tag,.hljs-title,.hljs-type{font-weight:700}</style><blockquote>
<p>在分布式系统里，服务之间到底是怎么“像函数调用一样通信”的？<br/>
本文从 gRPC 的设计思想讲起，系统梳理它的能力、优缺点和真实使用场景，并用 <strong>C++ 实现一个完整可跑的 gRPC 服务端和客户端</strong>，一步到位，帮你真正理解 gRPC 在工程中的价值。</p>
<p>Github: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgrpc%2Fgrpc" target="_blank" title="https://github.com/grpc/grpc" ref="nofollow noopener noreferrer">github.com/grpc/grpc</a></p>
<p>官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgrpc.io%2Fdocs%2Flanguages%2Fcpp%2Fquickstart%2F" target="_blank" title="https://grpc.io/docs/languages/cpp/quickstart/" ref="nofollow noopener noreferrer">grpc.io/docs/langua…</a></p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/985f6f97eb504f3ca0e9b9179dac48fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768313344&amp;x-signature=8xPmRz1Fc%2FBOZyGxA2pnsrNgImI%3D" alt="b1a13da1e5769bb8721984afde9b99b1.png" loading="lazy"/></p>
<h3 data-id="heading-0">为什么越来越多的系统在用 gRPC？</h3>
<p>在早期的服务通信中，我们最常见的方案无非两种：<br/>
一种是 <strong>HTTP + JSON</strong>，简单直观，但性能和规范性始终是瓶颈；<br/>
另一种是自己造 RPC 轮子，成本高、维护难、协议混乱。</p>
<p>gRPC 的出现，本质上就是在解决一个问题：<br/>
<strong>如何让跨进程、跨机器的服务调用，像本地函数调用一样自然？</strong></p>
<p>gRPC 是 Google 开源的一套高性能 RPC 框架，核心特点有三个：</p>
<ul>
<li>基于 <strong>HTTP/2</strong></li>
<li>使用 <strong>Protocol Buffers</strong> 作为接口描述和序列化协议</li>
<li>强约束的接口定义</li>
</ul>
<p>这三个设计，决定了 gRPC 天生就不是“写给小脚本用的”，而是面向<strong>中大型系统、微服务架构</strong>的通信基础设施。</p>
<h3 data-id="heading-1">优点和缺点</h3>
<p><strong>优点：</strong></p>
<ul>
<li>性能好，延迟低</li>
<li>接口规范清晰，适合团队协作</li>
<li>工具链成熟，自动生成代码</li>
<li>对微服务非常友好</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>学习成本高于 REST</li>
<li>调试不如 HTTP 直观</li>
<li>对浏览器不友好（需要 gRPC-Web）</li>
<li>protobuf 一旦设计不好，后期改动成本高</li>
</ul>
<p>一句话总结：<br/>
<strong>gRPC 非常适合“服务与服务之间”，但并不适合“直接暴露给人类使用”。</strong></p>
<h3 data-id="heading-2">C++ gRPC 实战：从 0 到跑起来</h3>
<p>下面用一个最简单的 <strong>HelloService</strong>，演示完整流程。</p>
<h4 data-id="heading-3">安装 gRPC 环境</h4>
<pre><code class="hljs language-bash" lang="bash">sudo apt-get update
sudo apt-get install -y build-essential autoconf libtool pkg-config
<span class="hljs-comment"># 安装 protobuf 编译器</span>
sudo apt-get install -y libprotobuf-dev protobuf-compiler
<span class="hljs-comment"># 安装 gRPC 库和插件</span>
sudo apt-get install -y libgrpc++-dev libgrpc-dev
</code></pre>
<h4 data-id="heading-4">定义 proto 文件（hello.proto）</h4>
<pre><code class="hljs language-proto" lang="proto">syntax = "proto3";

package hello;

service HelloService {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
</code></pre>
<p>生成 C++ 代码：</p>
<pre><code class="hljs language-bash" lang="bash">protoc --grpc_out=. --plugin=protoc-gen-grpc=`<span class="hljs-built_in">which</span> grpc_cpp_plugin` hello.proto
protoc --cpp_out=. hello.proto
</code></pre>
<h4 data-id="heading-5">C++ 服务端实现</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grpcpp/grpcpp.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"hello.grpc.pb.h"</span></span>

<span class="hljs-keyword">using</span> grpc::Server;
<span class="hljs-keyword">using</span> grpc::ServerBuilder;
<span class="hljs-keyword">using</span> grpc::ServerContext;
<span class="hljs-keyword">using</span> grpc::Status;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceImpl</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> hello::HelloService::Service {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Status <span class="hljs-title">SayHello</span><span class="hljs-params">(ServerContext* context,
                    <span class="hljs-type">const</span> hello::HelloRequest* request,
                    hello::HelloReply* reply)</span> <span class="hljs-keyword">override</span> </span>{
        reply-&gt;<span class="hljs-built_in">set_message</span>(<span class="hljs-string">"Hello, "</span> + request-&gt;<span class="hljs-built_in">name</span>());
        <span class="hljs-keyword">return</span> Status::OK;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">std::string <span class="hljs-title">server_address</span><span class="hljs-params">(<span class="hljs-string">"0.0.0.0:50051"</span>)</span></span>;
    HelloServiceImpl service;

    ServerBuilder builder;
    builder.<span class="hljs-built_in">AddListeningPort</span>(server_address, grpc::<span class="hljs-built_in">InsecureServerCredentials</span>());
    builder.<span class="hljs-built_in">RegisterService</span>(&amp;service);

    <span class="hljs-function">std::unique_ptr&lt;Server&gt; <span class="hljs-title">server</span><span class="hljs-params">(builder.BuildAndStart())</span></span>;
    std::cout &lt;&lt; <span class="hljs-string">"Server listening on "</span> &lt;&lt; server_address &lt;&lt; std::endl;

    server-&gt;<span class="hljs-built_in">Wait</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>编译并启动服务</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 单文件编译</span>
g++ -std=c++11 main.cpp hello.pb.cc hello.grpc.pb.cc \
-o hello_server \
`pkg-config --cflags --libs grpc++ grpc protobuf` \
-lgrpc++_reflection \
-lpthread

<span class="hljs-comment"># 运行</span>
./hello_server
</code></pre>
<h4 data-id="heading-6">C++ 客户端调用测试</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grpcpp/grpcpp.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"hello.grpc.pb.h"</span></span>

<span class="hljs-keyword">using</span> grpc::Channel;
<span class="hljs-keyword">using</span> grpc::ClientContext;
<span class="hljs-keyword">using</span> grpc::Status;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloClient</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">HelloClient</span>(std::shared_ptr&lt;Channel&gt; channel)
        : <span class="hljs-built_in">stub_</span>(hello::HelloService::<span class="hljs-built_in">NewStub</span>(channel)) {}

    <span class="hljs-function">std::string <span class="hljs-title">SayHello</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>{
        hello::HelloRequest request;
        request.<span class="hljs-built_in">set_name</span>(name);

        hello::HelloReply reply;
        ClientContext context;

        Status status = stub_-&gt;<span class="hljs-built_in">SayHello</span>(&amp;context, request, &amp;reply);
        <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>()) {
            <span class="hljs-keyword">return</span> reply.<span class="hljs-built_in">message</span>();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"RPC failed"</span>;
        }
    }

<span class="hljs-keyword">private</span>:
    std::unique_ptr&lt;hello::HelloService::Stub&gt; stub_;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">HelloClient <span class="hljs-title">client</span><span class="hljs-params">(
        grpc::CreateChannel(<span class="hljs-string">"localhost:50051"</span>,
                             grpc::InsecureChannelCredentials()))</span></span>;

    std::cout &lt;&lt; client.<span class="hljs-built_in">SayHello</span>(<span class="hljs-string">"gRPC C++"</span>) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>编译并运行</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 单文件编译</span>
g++ -std=c++11 main.cpp hello.pb.cc hello.grpc.pb.cc \
-o hello_client \
`pkg-config --cflags --libs grpc++ grpc protobuf` \
-lgrpc++_reflection \
-lpthread

<span class="hljs-comment"># 运行</span>
./hello_client
</code></pre>
<p>启动服务端，再运行客户端，你会看到：</p>
<pre><code class="hljs language-txt" lang="txt">Hello, gRPC C++
</code></pre>
<h3 data-id="heading-7">写在最后</h3>
<p>很多人学 gRPC，卡在“看懂文档，却不知道怎么落地”。<br/>
真正跑通一次 C++ 服务端和客户端，你会发现：</p>
<p>gRPC 并不神秘，它只是把“服务调用”这件事，做得更像工程，而不是脚本。</p>
<p>如果你正在做 <strong>分布式系统、微服务、基础设施</strong>，gRPC 值得你认真掌握。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[1分钟了解响应式编程 | dubbo框架下响应式官例]]></title>    <link>https://juejin.cn/post/7591786340321591330</link>    <guid>https://juejin.cn/post/7591786340321591330</guid>    <pubDate>2026-01-06T03:29:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591786340321591330" data-draft-id="7591778827308056616" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="1分钟了解响应式编程 | dubbo框架下响应式官例"/> <meta itemprop="keywords" content="后端,Java,RxJava"/> <meta itemprop="datePublished" content="2026-01-06T03:29:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Mars酱"/> <meta itemprop="url" content="https://juejin.cn/user/1714893869821278"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            1分钟了解响应式编程 | dubbo框架下响应式官例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1714893869821278/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Mars酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:29:50.000Z" title="Tue Jan 06 2026 03:29:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>作者：Mars酱</p>
<p>声明：本文章由Mars酱编写，部分内容来源于网络，如有疑问请联系本人。</p>
<p>转载：欢迎转载，转载前先请联系我！</p>
</blockquote>
<h2 data-id="heading-0">前言</h2>
<p>上篇搜了一堆概念，拼凑了一些例子，现今我们的应用已经不是单例架构，一般都是分布式微服务架构，微服务架构情况下框架也很多，SpringCloud、Dubbo等等</p>
<p>我的工程是dubbo的，那我们看看Dubbo官方示例给出的响应式编程的例子，毕竟我看Dubbo官文说天然支持流式编程，好了，继续。</p>
<h2 data-id="heading-1">Dubbo对流式处理的支持</h2>









































<table><thead><tr><th>协议</th><th>性能</th><th>网关友好</th><th>流式通信</th><th>多语言支持</th><th>编程API</th><th>说明</th></tr></thead><tbody><tr><td><strong>triple</strong></td><td><strong>高</strong></td><td><strong>高</strong></td><td><strong>支持，客户端流、服务端流、双向流</strong></td><td><strong>支持（Java、Go、Node.js、JavaScript、Rust）</strong></td><td><strong>Java Interface、Protobuf(IDL)</strong></td><td><strong>在多语言兼容、性能、网关、Streaming、gRPC 等方面最均衡的协议实现，官方推荐。</strong></td></tr><tr><td>dubbo</td><td>高</td><td>低</td><td>不支持</td><td>支持（Java、Go）</td><td>Java Interface</td><td>性能最高的私有协议，但前端流量接入、多语言支持等成本较高</td></tr><tr><td>rest</td><td>低</td><td>高</td><td>不支持</td><td>支持</td><td>Java Interface</td><td>rest 协议在前端接入、互通等方面具备最高的灵活性，但对比 rpc 存在性能、弱类型等缺点。<strong>注意，rest 在 dubbo3 中仅是 triple 协议的一种发布形式</strong></td></tr></tbody></table>
<p>从官方的文档中找到，Dubbo是支持流式编程的，但是需要使用triple协议，而不是其他协议。</p>
<h2 data-id="heading-2">从git上下载Dubbo Samples</h2>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 从git上下载 dubbo的官方示例，这是示例的git地址</span>
https://github.com/apache/dubbo-samples.git
</code></pre>
<p>下载之后，导入到你的idea中，知道了triple协议支持流式通信，那么从导入好的idea中找到triple的stream相关的代码，如下图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ebafe011a20403891943f968c009eb4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWFyc-mFsQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768274990&amp;x-signature=RqaQwYaCNL5u1lvakhpyA%2FfIsPw%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">Dubbo服务端支持的两种流式处理</h2>
<p>Dubbo通过triple协议支持了两种流式处理，一种是服务端流，另一种是双向流。</p>
<h3 data-id="heading-4">服务端流</h3>
<p>首先我们看服务端流的示例代码，代码位置在dubbo-samples-triple-streaming工程中的GreeterImpl这个文件，我抽取了服务端流的方式，如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serverStream</span><span class="hljs-params">(GreeterRequest request, StreamObserver&lt;GreeterReply&gt; responseObserver)</span> {
	LOGGER.info(<span class="hljs-string">"receive request: {}"</span>, request.getName());
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
		<span class="hljs-type">GreeterReply</span> <span class="hljs-variable">reply</span> <span class="hljs-operator">=</span> GreeterReply.newBuilder().setMessage(<span class="hljs-string">"reply from serverStream. "</span> + i).build();
		responseObserver.onNext(reply);
	}
	responseObserver.onCompleted();
}
</code></pre>
<p>可以看到serversStream方法是没有void，没有返回值的，它通过GreeterRequest对象传递参数，然后把业务逻辑数据依次循环写入到StreamObserver对像中。</p>
<p>GreeterRequest对象可以是我们自己定义的业务请求对象，StreamObserver对象是dubbo框架对于流式处理的接口定义，如图：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9e97c531cbb94373882d449c85504650~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWFyc-mFsQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768274990&amp;x-signature=gRilyZC%2BM2Wpa%2F3fRZKESIhio2U%3D" alt="" loading="lazy"/></p>
<p>响应结果被封装在这个接口对象中，实现了流式数据写入到消费者端的业务场景。</p>
<h3 data-id="heading-5">双向流</h3>
<p>这是双向流的官方示例：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> StreamObserver&lt;GreeterRequest&gt; <span class="hljs-title function_">biStream</span><span class="hljs-params">(StreamObserver&lt;GreeterReply&gt; responseObserver)</span> {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamObserver</span>&lt;GreeterRequest&gt;() {
		<span class="hljs-meta">@Override</span>
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(GreeterRequest data)</span> {
			<span class="hljs-type">GreeterReply</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> GreeterReply.newBuilder().setMessage(<span class="hljs-string">"reply from biStream "</span> + data.getName()).build();
			responseObserver.onNext(resp);
		}

		<span class="hljs-meta">@Override</span>
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Throwable throwable)</span> {

		}

		<span class="hljs-meta">@Override</span>
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompleted</span><span class="hljs-params">()</span> {

		}
	};
}
</code></pre>
<p>可以看到，双向流方法 binStream 的参数和返回值都是 StreamObserver 类型。</p>
<p>但需要注意的是，它与我们传统方法定义中参数是请求值、返回值是响应的理解是反过来的，在这里，函数的入参 StreamObserver responseObserver 是响应，跟之前一样，是在业务逻辑中不停的写数据到 回响应中。</p>
<p>这个函数也通过new了一个 StreamObserver 不断的在onNext函数中写入了请求流数据，而且这里 请求流 与 响应流 是独立的，我们在写回响应流数据的过程时，随时可能有请求流到达，对于每个流而言，值都是有序的。</p>
<h2 data-id="heading-6">Dubbo客户端的调用示例</h2>
<p>dubbo对于两种流的处理方式是不同的调用实现</p>
<h3 data-id="heading-7">服务端流的客户端调用</h3>
<p>调用 serverStream() 传入能够处理流式响应的 SampleStreamObserver 对象，调用发起后即快速返回，之后流式响应会不停的发送到 SampleStreamObserver 。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serverStream</span><span class="hljs-params">(Greeter greeter)</span> {
	<span class="hljs-type">GreeterRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> GreeterRequest.newBuilder().setName(<span class="hljs-string">"server stream request."</span>).build();
	greeter.serverStream(request, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SampleStreamObserver</span>());
}

<span class="hljs-comment">// 声名上面调用类的SampleStreamObserver实现</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SampleStreamObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StreamObserver</span>&lt;GreeterReply&gt; {

	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(GreeterReply data)</span> {
		LOGGER.info(<span class="hljs-string">"stream &lt;- reply:{}"</span>, data);
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Throwable throwable)</span> {
		LOGGER.error(<span class="hljs-string">"stream onError"</span>, throwable);
		throwable.printStackTrace();
	}

	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCompleted</span><span class="hljs-params">()</span> {
		LOGGER.info(<span class="hljs-string">"stream completed"</span>);
	}
}
</code></pre>
<h3 data-id="heading-8">双向流的客户端调用</h3>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">biStream</span><span class="hljs-params">(Greeter greeter)</span> {
	<span class="hljs-comment">// SampleStreamObserver的定义在 ‘服务端流的客户端调用示例’ 中已经给出</span>
	StreamObserver&lt;GreeterRequest&gt; requestStreamObserver = greeter.biStream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SampleStreamObserver</span>());
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
		<span class="hljs-type">GreeterRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> GreeterRequest.newBuilder().setName(<span class="hljs-string">"name-"</span> + i).build();
		requestStreamObserver.onNext(request);
	}
	requestStreamObserver.onCompleted();
}
</code></pre>
<p>调用 greeter.biStream() 方法会立即返回一个请求流 requestStreamObserver 对象，同时，需要为方法传入一个能处理响应的 observer 对象new SampleStreamObserver()。</p>
<p>接下来，我们就可以用才刚才返回值中得到的 requestStreamObserver 持续发送请求 requestStreamObserver .onNext(reqeust)， 此时，如果有响应返回，则会由 SampleStreamObserver 对象接收处理，</p>
<h2 data-id="heading-9">官例好像有问题</h2>
<p>其实没有任何问题，只是dubbo支持的是observer的流式处理，这是一种无背压方式的流式处理。背压是一种<strong>流控机制</strong>，dubbo 的 StreamObserver <strong>不提供内置背压支持</strong></p>
<ul>
<li>它的 onNext 方法是通过官方的示例就知道它属于阅后即焚风格；</li>
<li>调用 onNext 会立即把数据写入网络缓冲区（或本地队列），<strong>不会等待消费者处理完成</strong>；</li>
<li>如果消费者消费得太慢，而 producer 持续高速发送，有没有可能 <strong>导致 OOM 或者其他问题？没试过，存疑</strong></li>
</ul>
<p>这与 <strong>Reactive Streams 规范</strong> 貌似不同，并没有背压特征，但是RxJava框架不也是支持背压、无背压方式的吗？所以，应该根据自己的场景来选择是否需要背压方式，超时了，下个1分钟看怎么用dubbo处理背压特征的响应式编程吧。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React 19 时代的 StrictMode：原理、未来准备与最佳实践]]></title>    <link>https://juejin.cn/post/7591871204568186906</link>    <guid>https://juejin.cn/post/7591871204568186906</guid>    <pubDate>2026-01-06T05:58:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591871204568186906" data-draft-id="7591948263859896358" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React 19 时代的 StrictMode：原理、未来准备与最佳实践"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2026-01-06T05:58:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="皮蛋小精灵"/> <meta itemprop="url" content="https://juejin.cn/user/219558056559278"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React 19 时代的 StrictMode：原理、未来准备与最佳实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/219558056559278/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    皮蛋小精灵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T05:58:14.000Z" title="Tue Jan 06 2026 05:58:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    35
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">什么是 StrictMode？</h2>
<p><code>StrictMode</code> 是 React 提供的开发者工具，它不渲染任何可见的 UI，而是通过为后代组件提供额外的检查来帮助开发者编写高质量代码。它的核心目标是：</p>
<ul>
<li><strong>识别不安全的生命周期</strong>：为并发模式扫清障碍。</li>
<li><strong>警告过时的 API 使用</strong>：确保代码能平滑升级到新版本。</li>
<li><strong>检测意外的副作用</strong>：通过故意重复调用来暴露 Bug。</li>
</ul>
<h2 data-id="heading-1">StrictMode 的“反直觉”行为</h2>
<p>在开发模式下（仅限开发环境，生产环境不生效），<code>StrictMode</code> 会强制执行以下操作：</p>
<ol>
<li><strong>重复渲染（Double Render）</strong> ：组件函数体会被执行两次。</li>
<li><strong>重复 Effect（Double Effect）</strong> ：执行 <code>Mount</code> → <code>Unmount</code> → <code>Mount</code> 的完整周期。</li>
</ol>
<h2 data-id="heading-2">核心解密：为什么要“卸载再挂载”？</h2>
<p>很多开发者认为重复请求是 StrictMode 的“副作用”，但实际上这是 React 为了<strong>未来特性</strong>所做的强制演习。</p>
<h3 data-id="heading-3">1. 为 React 19+ 的 Activity (Offscreen) API 做准备</h3>
<p>React 正在引入一种能力（即将在 React 19 及后续版本完善的 <code>&lt;Activity&gt;</code>），允许组件在切换页面时<strong>不被销毁，而是“休眠”在后台</strong>。</p>
<ul>
<li><strong>场景</strong>：用户从 Tab A 切到 Tab B，再切回 Tab A。</li>
<li><strong>目标</strong>：Tab A 的状态（滚动位置、表单内容）瞬间恢复，无需重新请求。</li>
<li><strong>StrictMode 的良苦用心</strong>：现在的 <code>Mount -&gt; Unmount -&gt; Mount</code> 就是在模拟“休眠 -&gt; 唤醒”的过程。如果你的组件在 <code>Unmount</code> 时清理不彻底（如未取消订阅），这种 Bug 在 StrictMode 下会立即暴露，防止未来上线 Activity 功能时页面崩溃。</li>
</ul>
<h3 data-id="heading-4">2. 确保并发渲染（Concurrent Rendering）的稳定性</h3>
<p>React 19 全面拥抱并发。渲染过程可能会被中断、暂停或废弃。如果不保证渲染函数的“纯度”（Idempotency），多次计算可能会导致 UI 状态不一致。StrictMode 的重复执行正是为了确保无论渲染多少次，结果都是确定的。</p>
<h2 data-id="heading-5">典型的“重复请求”现象</h2>
<pre><code class="hljs language-TypeScript" lang="TypeScript">&lt;<span class="hljs-title class_">StrictMode</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterProvider</span> <span class="hljs-attr">router</span>=<span class="hljs-string">{router}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">StrictMode</span>&gt;
</code></pre>
<p>在 <code>StrictMode</code> 下，常见的请求流程是：</p>
<ol>
<li>组件首次挂载 → 执行 <code>useEffect</code> → <strong>发起第 1 次网络请求</strong></li>
<li>React 立即卸载组件 → 执行 <code>cleanup</code></li>
<li>React 重新挂载组件 → 再次执行 <code>useEffect</code> → <strong>发起第 2 次网络请求（内容相同）</strong></li>
</ol>
<h2 data-id="heading-6">最佳实践与解决方案</h2>
<p>在 React 19 时代，我们<strong>强烈建议保留 StrictMode</strong>。与其关掉它，不如优化你的数据获取策略。</p>
<h3 data-id="heading-7">方案 1：使用数据请求库（React 19 推荐）</h3>
<p>这是现代 React 开发的“标准答案”。使用 <strong>TanStack Query (React Query)</strong> 、<strong>SWR</strong> 或 React 19 的 <strong>Server Components (RSC)</strong> 。</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-comment">// 使用 React Query，库内部会自动处理去重和缓存</span>
<span class="hljs-comment">// StrictMode 下的多次挂载不会导致重复的网络请求</span>
<span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useQuery</span>({
  <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">'todos'</span>],
  <span class="hljs-attr">queryFn</span>: fetchTodos,
});
</code></pre>
<ul>
<li><strong>优势</strong>：直接物理隔离了 <code>useEffect</code> 的副作用问题，代码更声明式，完美适配 StrictMode。</li>
</ul>
<h3 data-id="heading-8">方案 2：使用 AbortController（手动挡推荐）</h3>
<p>如果你必须在 <code>useEffect</code> 中请求，请使用 <code>AbortController</code> 进行竞态处理和取消。这不仅解决了 StrictMode 的视觉干扰，更防止了网络竞态条件（Race Condition）。</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> abortController = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> apiClient.<span class="hljs-title function_">request</span>({
        <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
        <span class="hljs-attr">url</span>: <span class="hljs-string">'/get/data'</span>,
        <span class="hljs-attr">signal</span>: abortController.<span class="hljs-property">signal</span> <span class="hljs-comment">// 绑定信号</span>
      });
      <span class="hljs-comment">// 处理成功逻辑</span>
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> !== <span class="hljs-string">'AbortError'</span>) {
        <span class="hljs-comment">// 真正的错误处理</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);
      }
    }
  };

  <span class="hljs-title function_">fetchData</span>();

  <span class="hljs-comment">// Cleanup: 第一次卸载时取消请求 A，保留请求 B</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    abortController.<span class="hljs-title function_">abort</span>();
  };
}, []);
</code></pre>
<h3 data-id="heading-9">避坑：慎用 useRef 标记</h3>
<p>一种常见的“歪门邪道”是使用 <code>useRef</code> 拦截请求：</p>
<pre><code class="hljs language-TypeScript" lang="TypeScript"><span class="hljs-comment">// ❌ 不推荐：可能导致依赖更新失效</span>
<span class="hljs-keyword">const</span> hasRequested = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">false</span>);
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (hasRequested.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span>;
  hasRequested.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span>;
  <span class="hljs-title function_">fetchData</span>();
}, [userId]); <span class="hljs-comment">// 如果 userId 变化，ref 依然是 true，会导致请求被拦截</span>
</code></pre>
<p>这种方法虽然能在这个场景下生效，但如果依赖项数组（Dependency Array）不为空，很容易导致后续合法的请求被错误拦截，增加维护成本。</p>
<h2 data-id="heading-10">总结</h2>
<p>在 React 19 中，<code>StrictMode</code> 不仅仅是一个调试工具，它是<strong>代码质量的体检员</strong>。</p>
<ol>
<li><strong>不要移除它</strong>：它帮助你确保代码兼容未来的“后台保活”特性和并发渲染。</li>
<li><strong>正确处理副作用</strong>：重复请求不是 Bug，而是提示你需要清理副作用（Cleanup）或使用更现代的数据流方案（如 React Query 或 RSC）。</li>
<li><strong>拥抱标准</strong>：适应 <code>StrictMode</code> 的检查，意味着你的代码已经做好了迎接 React 未来新特性的准备。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[监控不是日志：Prometheus 高基数避坑指南]]></title>    <link>https://juejin.cn/post/7591715454135238719</link>    <guid>https://juejin.cn/post/7591715454135238719</guid>    <pubDate>2026-01-06T02:21:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591715454135238719" data-draft-id="7591730714140950570" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="监控不是日志：Prometheus 高基数避坑指南"/> <meta itemprop="keywords" content="后端,算法,监控"/> <meta itemprop="datePublished" content="2026-01-06T02:21:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="踏浪无痕"/> <meta itemprop="url" content="https://juejin.cn/user/2834988091055719"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            监控不是日志：Prometheus 高基数避坑指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2834988091055719/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    踏浪无痕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T02:21:47.000Z" title="Tue Jan 06 2026 02:21:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>从 TSDB 原理到实战案例，帮助你理解为什么不能使用高基数标签，以及如何正确设计监控指标。一次性解决 Prometheus 查询慢、内存爆炸的根本问题。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">一、先问一个问题：为什么查询会变慢？</h2>
<p>想象一个场景：</p>
<pre><code class="hljs language-ini" lang="ini">你的电商系统监控突然变慢了：
- 以前查询 sum(order_total) 只要 10ms
- 现在需要 30 秒，经常超时
- Prometheus 内存从 2GB 涨到 16GB
- 告警延迟，运维半夜被叫醒

罪魁祸首：
order_total{<span class="hljs-attr">user_id</span>=<span class="hljs-string">"10086"</span>}  <span class="hljs-comment"># 给每个用户都创建了独立时序</span>
order_total{<span class="hljs-attr">user_id</span>=<span class="hljs-string">"10087"</span>}
...
<span class="hljs-comment"># 100万用户 = 100万条时序！</span>
</code></pre>
<p><strong>核心问题：为什么加个 user_id 标签就炸了？</strong></p>
<p>要理解这个问题，我们先用大白话讲清楚 Prometheus 是怎么存储数据的。</p>
<hr/>
<h2 data-id="heading-1">二、大白话类比：超市运作模型</h2>
<h3 data-id="heading-2">2.1 Prometheus = 一家超市</h3>
<p>把 Prometheus TSDB 想象成一家超市，就很好理解了：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    subgraph Frontend["前台 (内存)"]
        CAT["商品目录册
        可乐在B2货架"]
        SHELF["货架陈列区
        热销商品摆前面"]
    end
    
    subgraph Backend["后台 (磁盘)"]
        WAREHOUSE["大仓库
        整箱压缩存放"]
        LOG["出入库记录
        防止断电丢失"]
    end
    
    Frontend -.定期入库.-&gt; Backend
    
    style Frontend fill:#e8f5e9,stroke:#4caf50,stroke-width:3px
    style Backend fill:#fff3e0,stroke:#ff9800,stroke-width:3px
    style CAT fill:#c8e6c9,stroke:#4caf50
    style SHELF fill:#c8e6c9,stroke:#4caf50
    style WAREHOUSE fill:#ffe0b2,stroke:#ff9800
    style LOG fill:#ffe0b2,stroke:#ff9800
</code></pre>
<p><strong>为什么这样设计？</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">场景：顾客要买可乐

方案A（全放仓库）：
顾客：<span class="hljs-string">"要可乐"</span>
店员：<span class="hljs-string">"稍等，我去仓库找..."</span> → <span class="hljs-number">10</span>分钟
结果：顾客不买了 ✗

方案B（前台+后台）：
顾客：<span class="hljs-string">"要可乐"</span>
店员：<span class="hljs-string">"货架上有"</span> → <span class="hljs-number">10</span>秒
结果：立刻成交 ✓
</code></pre>
<p><strong>对应到监控：</strong></p>
<ul>
<li>告警需要实时查询（&lt;100ms）→ 必须用内存</li>
<li>历史分析可以慢点（几秒）→ 磁盘足够</li>
</ul>
<pre><code class="hljs language-mermaid" lang="mermaid">%%{init: {'theme':'base', 'themeVariables': { 'fontSize':'16px'}}}%%
graph TB
    subgraph Prometheus["Prometheus Server"]
        subgraph Memory["内存层 Head Block (最近2小时热数据)"]
            SI["Series 索引表
            标签→ID映射"]
            PL["Posting Lists
            倒排索引"]
            AC["Active Chunks
            压缩数据块"]
        end
        
        Compress["定期压缩 (每2小时)"]
        
        subgraph Disk["磁盘层 Persistent Blocks (长期存储)"]
            IDX["index 文件
            倒排索引持久化"]
            CHK["chunks 文件
            XOR 压缩数据"]
            META["meta.json
            块元数据"]
        end
        
        Memory --&gt;|压缩| Compress
        Compress --&gt;|持久化| Disk
    end
    
    style Memory fill:#e1f5ff,stroke:#0288d1,stroke-width:3px
    style Disk fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style Compress fill:#f0f0f0,stroke:#666,stroke-width:2px
    style SI fill:#bbdefb,stroke:#0288d1
    style PL fill:#bbdefb,stroke:#0288d1
    style AC fill:#bbdefb,stroke:#0288d1
    style IDX fill:#ffe0b2,stroke:#f57c00
    style CHK fill:#ffe0b2,stroke:#f57c00
    style META fill:#ffe0b2,stroke:#f57c00
</code></pre>
<hr/>
<h2 data-id="heading-3">三、揭秘真实架构：TSDB 的技术实现</h2>
<p>好，理解了超市模型后，我们来看看 Prometheus 真实的技术架构。有了前面的铺垫，这张图你就能看懂了：</p>
<h3 data-id="heading-4">3.1 宏观架构图</h3>
<p>Prometheus 采用<strong>内存+磁盘</strong>的分层存储，核心设计思想是：<strong>热数据快速访问，冷数据压缩存储</strong>。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">%%{init: {'theme':'base', 'themeVariables': { 'fontSize':'16px'}}}%%
graph TB
    subgraph Prometheus["Prometheus Server"]
        subgraph Memory["内存层 Head Block (最近2小时热数据)"]
            SI["Series 索引表
            标签→ID映射"]
            PL["Posting Lists
            倒排索引"]
            AC["Active Chunks
            压缩数据块"]
        end
        
        Compress["定期压缩 (每2小时)"]
        
        subgraph Disk["磁盘层 Persistent Blocks (长期存储)"]
            IDX["index 文件
            倒排索引持久化"]
            CHK["chunks 文件
            XOR 压缩数据"]
            META["meta.json
            块元数据"]
        end
        
        Memory --&gt;|压缩| Compress
        Compress --&gt;|持久化| Disk
    end
    
    style Memory fill:#e1f5ff,stroke:#0288d1,stroke-width:3px
    style Disk fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style Compress fill:#f0f0f0,stroke:#666,stroke-width:2px
    style SI fill:#bbdefb,stroke:#0288d1
    style PL fill:#bbdefb,stroke:#0288d1
    style AC fill:#bbdefb,stroke:#0288d1
    style IDX fill:#ffe0b2,stroke:#f57c00
    style CHK fill:#ffe0b2,stroke:#f57c00
    style META fill:#ffe0b2,stroke:#f57c00
</code></pre>
<p><strong>对应到超市：</strong></p>
<ul>
<li><strong>Series 索引表</strong> = 商品目录册（"可乐在B2货架"）</li>
<li><strong>Posting Lists</strong> = 分类标签墙（"饮料类：可乐、雪碧..."）</li>
<li><strong>Active Chunks</strong> = 前台货架（最近进货的商品）</li>
<li><strong>index/chunks 文件</strong> = 后台大仓库（整箱压缩存放）</li>
</ul>
<h3 data-id="heading-5">3.2 关键数据：什么放内存，什么放磁盘？</h3>









































<table><thead><tr><th>数据类型</th><th>存储位置</th><th>大小估算</th><th>高基数影响</th></tr></thead><tbody><tr><td>Series 索引</td><td>内存</td><td>每时序 2-4 KB</td><td>直接膨胀</td></tr><tr><td>倒排索引</td><td>内存</td><td>随标签值增长</td><td>急剧增长</td></tr><tr><td>最新数据（2小时内）</td><td>内存</td><td>每时序 ~1 KB</td><td>线性增长</td></tr><tr><td>历史数据</td><td>磁盘</td><td>压缩后 1:10</td><td>碎片化</td></tr><tr><td>WAL日志</td><td>磁盘</td><td>未压缩</td><td>写入放大</td></tr></tbody></table>
<p><strong>核心公式：</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">内存占用</span> <span class="hljs-string">≈</span> <span class="hljs-string">时序总数</span> <span class="hljs-string">×</span> <span class="hljs-number">3</span> <span class="hljs-string">KB</span>
<span class="hljs-string">推荐上限：单实例</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">1000</span> <span class="hljs-string">万时序</span>
</code></pre>
<p><strong>现在再看开头的问题：</strong></p>
<pre><code class="hljs language-ini" lang="ini">order_total{<span class="hljs-attr">user_id</span>=<span class="hljs-string">"10086"</span>}  <span class="hljs-comment"># 100万用户 = 100万个 Series</span>
↓
Series 索引表：100万 × <span class="hljs-attr">3KB</span> = <span class="hljs-number">3</span>GB（仅索引就爆了！）
查询时要遍历 100万个货架位 → 30秒超时
</code></pre>
<h3 data-id="heading-6">3.4 内存结构详解</h3>
<p><strong>Series 索引表 = 商品总目录</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Normal["正常商品目录"]
        N1["可乐(瓶装) → B2货架
        对应: (method='GET') → ID:1"]
        N2["可乐(罐装) → B3货架
        对应: (method='POST') → ID:2"]
    end
    
    subgraph HighCard["❌ 高基数问题"]
        H1["张三的可乐 → A1货架
        对应: (user_id='10086') → ID:1"]
        H2["李四的可乐 → A2货架
        对应: (user_id='10087') → ID:2"]
        H3["王五的可乐 → A3货架
        对应: (user_id='10088') → ID:3"]
        H4["... 100万个顾客"]
    end
    
    style Normal fill:#c8e6c9,stroke:#4caf50,stroke-width:3px
    style HighCard fill:#ffcdd2,stroke:#f44336,stroke-width:3px
    style N1 fill:#a5d6a7,stroke:#2e7d32
    style N2 fill:#a5d6a7,stroke:#2e7d32
    style H1 fill:#ef9a9a,stroke:#c62828
    style H2 fill:#ef9a9a,stroke:#c62828
    style H3 fill:#ef9a9a,stroke:#c62828
    style H4 fill:#ef9a9a,stroke:#c62828
</code></pre>
<p><strong>Posting Lists = 分类标签墙</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    subgraph Drink["饮料类"]
        D1[可乐]
        D2[雪碧]
        D3[牛奶]
    end
    
    subgraph Snack["零食类"]
        S1[薯片]
        S2[饼干]
        S3[巧克力]
    end
    
    subgraph HighCard["❌ 高基数: 用户标签"]
        U1["user_id=10086
        SeriesID:100001"]
        U2["user_id=10087
        SeriesID:100002"]
        U3["user_id=10088
        SeriesID:100003"]
        U4["... 100万个标签"]
    end
    
    style Drink fill:#e1f5ff,stroke:#0288d1,stroke-width:2px
    style Snack fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
    style HighCard fill:#ffcdd2,stroke:#f44336,stroke-width:3px
    style D1 fill:#bbdefb,stroke:#0288d1
    style D2 fill:#bbdefb,stroke:#0288d1
    style D3 fill:#bbdefb,stroke:#0288d1
    style S1 fill:#e1bee7,stroke:#9c27b0
    style S2 fill:#e1bee7,stroke:#9c27b0
    style S3 fill:#e1bee7,stroke:#9c27b0
    style U1 fill:#ef9a9a,stroke:#c62828
    style U2 fill:#ef9a9a,stroke:#c62828
    style U3 fill:#ef9a9a,stroke:#c62828
    style U4 fill:#ef9a9a,stroke:#c62828
</code></pre>
<hr/>
<h2 data-id="heading-7">四、电商场景：好与坏的指标设计</h2>
<h3 data-id="heading-8">4.1 订单监控</h3>
<h4 data-id="heading-9">反面案例：每个用户、每个订单都是独立时序</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 错误设计
order_created{
  user_id="10086",           # 100万个用户
  order_id="20240501001",    # 每天50万订单
  product_id="SKU12345"      # 10万个商品
}

问题分析：
├─ 时序数量：100万用户 × 1个指标 = 100万时序
├─ 内存占用：100万 × 3KB = 3GB（仅索引）
├─ 查询延迟：sum(order_created) → 30秒超时
└─ 存储浪费：大部分订单只有1个样本点
</code></pre>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Bad["❌ 错误设计: 高基数"]
        B1["user_id='10086'
        100万个用户"]
        B2["order_id='ABC123'
        每天50万订单"]
        B3["product_id='SKU001'
        10万个商品"]
        
        Result1["时序数: 100万+
        内存: 3GB
        查询: 30秒超时"]
    end
    
    B1 &amp; B2 &amp; B3 --&gt; Result1
    
    style Bad fill:#ffcdd2,stroke:#f44336,stroke-width:3px
    style B1 fill:#ef9a9a,stroke:#c62828
    style B2 fill:#ef9a9a,stroke:#c62828
    style B3 fill:#ef9a9a,stroke:#c62828
    style Result1 fill:#ffebee,stroke:#c62828,stroke-width:2px
</code></pre>
<p><strong>为什么错？</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    Problem[超市类比] --&gt; P1["每个顾客的
    每件商品都单独上架"]
    P1 --&gt; P2["张三的可乐
    李四的可乐
    王五的可乐..."]
    P2 --&gt; P3["商品目录1000页
    货架爆满"]
    
    style Problem fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style P1 fill:#ffccbc,stroke:#ff5722
    style P2 fill:#ffccbc,stroke:#ff5722
    style P3 fill:#ffcdd2,stroke:#f44336,stroke-width:3px
</code></pre>
<h4 data-id="heading-10">正面案例：聚合维度</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 正确设计
order_created_total{
  source="app|web|miniprogram",      # 3个值
  payment_method="alipay|wechat",    # 5个值
  product_category="electronics"     # 20个一级类目
}

优势：
├─ 时序数量：3 × 5 × 20 = 300时序
├─ 内存占用：300 × 3KB = 900KB
├─ 查询延迟：sum(order_created_total) → 10ms
└─ 存储效率：样本点密集，压缩率高
</code></pre>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Good["✓ 正确设计: 低基数"]
        G1["source
        3个值"]
        G2["payment_method
        5个值"]
        G3["product_category
        20个类目"]
        
        Result2["时序数: 300
        内存: 900KB
        查询: 10ms"]
    end
    
    G1 &amp; G2 &amp; G3 --&gt; Result2
    
    style Good fill:#c8e6c9,stroke:#4caf50,stroke-width:3px
    style G1 fill:#a5d6a7,stroke:#2e7d32
    style G2 fill:#a5d6a7,stroke:#2e7d32
    style G3 fill:#a5d6a7,stroke:#2e7d32
    style Result2 fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
</code></pre>
<p><strong>为什么对？</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    Solution[超市类比] --&gt; S1[按商品类型分类]
    S1 --&gt; S2["瓶装可乐
    罐装可乐
    ..."]
    S2 --&gt; S3["商品目录1页
    清晰明了"]
    
    style Solution fill:#e8f5e9,stroke:#4caf50,stroke-width:2px
    style S1 fill:#c8e6c9,stroke:#66bb6a
    style S2 fill:#c8e6c9,stroke:#66bb6a
    style S3 fill:#a5d6a7,stroke:#2e7d32,stroke-width:3px
</code></pre>
<h3 data-id="heading-11">4.2 接口性能监控</h3>
<h4 data-id="heading-12">反面案例：动态URL路径</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 错误设计
api_request_duration{
  path="/api/order/10086/detail",    # 每个订单号一个路径
  path="/api/order/10087/detail",
  path="/api/user/20001/profile",    # 每个用户ID一个路径
  ...
}

问题：
├─ URL数量：每天几十万个不同路径
├─ 时序爆炸：每个路径一条时序
└─ 无法聚合：sum() 毫无意义
</code></pre>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    URL1["api/order/10086/detail"] --&gt; TS1["时序1"]
    URL2["api/order/10087/detail"] --&gt; TS2["时序2"]
    URL3["api/order/10088/detail"] --&gt; TS3["时序3"]
    URL4["... 每天50万个URL"] --&gt; TS4["... 50万时序"]
    
    TS1 &amp; TS2 &amp; TS3 &amp; TS4 --&gt; Problem["❌ 无法聚合
    查询超时"]
    
    style URL1 fill:#ffccbc,stroke:#ff5722
    style URL2 fill:#ffccbc,stroke:#ff5722
    style URL3 fill:#ffccbc,stroke:#ff5722
    style URL4 fill:#ffccbc,stroke:#ff5722
    style TS1 fill:#ef9a9a,stroke:#c62828
    style TS2 fill:#ef9a9a,stroke:#c62828
    style TS3 fill:#ef9a9a,stroke:#c62828
    style TS4 fill:#ef9a9a,stroke:#c62828
    style Problem fill:#ffcdd2,stroke:#f44336,stroke-width:3px
</code></pre>
<h4 data-id="heading-13">正面案例：路径归一化</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 正确设计
api_request_duration{
  path="/api/order/{id}/detail",     # 模板化
  method="GET",
  status="200|500"
}

实现方式：
在应用代码或网关层做路径归一化：
/api/order/10086/detail  → /api/order/{id}/detail
/api/user/20001/profile  → /api/user/{id}/profile
</code></pre>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TD
    URL1["api/order/10086/detail"] --&gt; Normalize
    URL2["api/order/10087/detail"] --&gt; Normalize
    URL3["api/order/10088/detail"] --&gt; Normalize
    
    Normalize["路径归一化"] --&gt; Template["api/order/{id}/detail"]
    Template --&gt; TS["✓ 1个聚合时序
    查询快速"]
    
    style URL1 fill:#bbdefb,stroke:#0288d1
    style URL2 fill:#bbdefb,stroke:#0288d1
    style URL3 fill:#bbdefb,stroke:#0288d1
    style Normalize fill:#fff9c4,stroke:#fbc02d,stroke-width:2px
    style Template fill:#c8e6c9,stroke:#4caf50,stroke-width:2px
    style TS fill:#a5d6a7,stroke:#2e7d32,stroke-width:3px
</code></pre>
<h3 data-id="heading-14">4.3 库存监控</h3>
<h4 data-id="heading-15">反面案例：商品级别监控</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 错误设计
inventory_level{
  product_id="SKU001",      # 10万个SKU
  warehouse_id="WH001",     # 100个仓库
  location="A-01-05"        # 1万个货位
}

时序数：10万 × 100 × 1万 = 1000亿（理论值）
实际：即使只有部分组合，也有百万级时序
</code></pre>
<h4 data-id="heading-16">正面案例：分层监控</h4>
<pre><code class="hljs language-prometheus" lang="prometheus"># 宏观监控（低基数）
inventory_health{
  category="electronics",       # 20个类目
  warehouse_region="south",     # 5个大区
  stock_status="low|normal|high" # 3个状态
}

# 详细监控（仅Top商品）
inventory_detail{
  product_id="SKU001",          # 仅监控Top 1000商品
  warehouse_id="WH001"
}
</code></pre>
<h3 data-id="heading-17">4.4 对比总结</h3>



































<table><thead><tr><th>维度</th><th>反面案例</th><th>正面案例</th><th>差距</th></tr></thead><tbody><tr><td>时序数量</td><td>100万+</td><td>300-1000</td><td>1000倍</td></tr><tr><td>内存占用</td><td>3GB+</td><td>&lt;5MB</td><td>600倍</td></tr><tr><td>查询延迟</td><td>30秒+</td><td>10-50ms</td><td>3000倍</td></tr><tr><td>告警响应</td><td>经常超时</td><td>实时</td><td>-</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-18">五、告警场景的共性抽取</h2>
<h3 data-id="heading-19">5.1 告警的本质需求</h3>
<p>Prometheus 作为告警系统，核心需求是：</p>
<pre><code class="hljs">快速回答：系统出了什么问题？
而不是：谁在什么时候做了什么？
</code></pre>
<p><strong>实际案例：</strong></p>
<pre><code class="hljs language-java" lang="java">告警需求                        需要的维度              不需要的维度
─────────────────────────────────────────────────────────
订单支付失败率超<span class="hljs-number">5</span>%              payment_method          user_id, order_id
                               error_type              
                               
API延迟P99超<span class="hljs-number">1</span>秒                 service_name            request_id
                               <span class="hljs-title function_">endpoint</span> <span class="hljs-params">(归一化)</span>        user_id
                               
库存水位低于阈值                category                product_id
                               warehouse_region        具体货位
</code></pre>
<h3 data-id="heading-20">5.2 告警指标的设计规律</h3>
<h4 data-id="heading-21">规律1：聚合维度，而非明细维度</h4>
<pre><code class="hljs language-ini" lang="ini">思考：你需要知道"哪些订单失败了"，还是"为什么失败"？

错误：
alert: order_failed{<span class="hljs-attr">order_id</span>=<span class="hljs-string">"xxx"</span>} &gt; <span class="hljs-number">0</span>
→ 每个订单都告警，无法处理

正确：
alert: rate(order_failed_total{<span class="hljs-attr">reason</span>=<span class="hljs-string">"timeout"</span>}[<span class="hljs-number">5</span>m]) &gt; <span class="hljs-number">0.05</span>
→ 超时导致的失败率超5%，立刻修复
</code></pre>
<h4 data-id="heading-22">规律2：技术维度比业务明细重要</h4>
<p><strong>必选维度（技术运维）：</strong></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">service</span>=<span class="hljs-string">"order-service"</span>     <span class="hljs-comment"># 哪个服务</span>
<span class="hljs-attr">instance</span>=<span class="hljs-string">"10.0.1.5:9090"</span>   <span class="hljs-comment"># 哪台机器</span>
<span class="hljs-attr">environment</span>=<span class="hljs-string">"production"</span>    <span class="hljs-comment"># 哪个环境</span>
</code></pre>
<p><strong>可选维度（业务聚合）：</strong></p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">payment_method</span>=<span class="hljs-string">"alipay"</span>    <span class="hljs-comment"># 支付方式</span>
<span class="hljs-attr">category</span>=<span class="hljs-string">"electronics"</span>     <span class="hljs-comment"># 商品类目</span>
<span class="hljs-attr">region</span>=<span class="hljs-string">"华南"</span>              <span class="hljs-comment"># 地域</span>
</code></pre>
<p><strong>禁用维度（业务明细）：</strong></p>
<pre><code class="hljs language-bash" lang="bash">user_id                    <span class="hljs-comment"># 用户ID → 放日志</span>
order_id                   <span class="hljs-comment"># 订单号 → 放日志</span>
product_id                 <span class="hljs-comment"># 商品ID → 放日志（除非Top商品）</span>
</code></pre>
<h4 data-id="heading-23">规律3：状态聚合，而非状态穷举</h4>
<pre><code class="hljs language-ini" lang="ini">反面：
<span class="hljs-attr">order_status</span>=<span class="hljs-string">"created|paid|shipped|delivered|cancelled|refunded|..."</span>
→ 10+ 种状态，组合爆炸

正面：
<span class="hljs-attr">order_status</span>=<span class="hljs-string">"success|failed"</span>
<span class="hljs-attr">order_stage</span>=<span class="hljs-string">"processing|completed"</span>
→ 2-3 种状态，清晰明了
</code></pre>
<h3 data-id="heading-24">5.3 典型告警规则模板</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 订单成功率告警</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">OrderSuccessRateLow</span>
  <span class="hljs-attr">expr:</span> <span class="hljs-string">|
    rate(order_success_total{env="prod"}[5m]) 
    / 
    rate(order_total{env="prod"}[5m]) &lt; 0.95
</span>  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">summary:</span> <span class="hljs-string">"订单成功率低于95%"</span>
    
<span class="hljs-comment"># API延迟告警</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">APILatencyHigh</span>
  <span class="hljs-attr">expr:</span> <span class="hljs-string">|
    histogram_quantile(0.99, 
      rate(api_duration_bucket{service="order"}[5m])
    ) &gt; 1
</span>  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">severity:</span> <span class="hljs-string">warning</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">summary:</span> <span class="hljs-string">"API P99延迟超过1秒"</span>

<span class="hljs-comment"># 库存水位告警</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">InventoryLow</span>
  <span class="hljs-attr">expr:</span> <span class="hljs-string">|
    inventory_level{status="low"} &gt; 100
</span>  <span class="hljs-attr">labels:</span>
    <span class="hljs-attr">severity:</span> <span class="hljs-string">warning</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">summary:</span> <span class="hljs-string">"<span class="hljs-template-variable">{{$labels.category}}</span> 类目库存不足"</span>
</code></pre>
<h3 data-id="heading-25">5.4 告警维度设计清单</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7a6a22dc6f914c2daa2b7cfe23da43e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LiP5rWq5peg55eV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270907&amp;x-signature=aOB1xfnKfOnAioSfmVtEpM43B2s%3D" alt="2.jpg" loading="lazy"/></p>
<p><strong>具体示例：</strong></p>
<pre><code class="hljs language-mermaid" lang="mermaid">graph LR
    subgraph Good["✓ 推荐使用"]
        G1["service_name
        知道哪个服务"]
        G2["error_type
        知道失败原因"]
        G3["payment_method
        5-10种"]
    end
    
    subgraph Bad["❌ 不要使用"]
        B1["user_id
        不关心是谁"]
        B2["request_id
        无限增长"]
        B3["order_id
        放日志即可"]
    end
    
    style Good fill:#c8e6c9,stroke:#4caf50,stroke-width:3px
    style Bad fill:#ffcdd2,stroke:#f44336,stroke-width:3px
    style G1 fill:#a5d6a7,stroke:#2e7d32
    style G2 fill:#a5d6a7,stroke:#2e7d32
    style G3 fill:#a5d6a7,stroke:#2e7d32
    style B1 fill:#ef9a9a,stroke:#c62828
    style B2 fill:#ef9a9a,stroke:#c62828
    style B3 fill:#ef9a9a,stroke:#c62828
</code></pre>
<hr/>
<h2 data-id="heading-26">六、操作指引与总结</h2>
<h3 data-id="heading-27">6.1 标签设计黄金法则</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">graph TB
    subgraph Rule1["原则1: 基数控制"]
        R1A["单个标签 &lt; 100个值"]
        R1B["标签组合 &lt; 10,000时序"]
    end
    
    subgraph Rule2["原则2: 三不原则"]
        R2A["❌ 不用唯一标识
        user_id, order_id"]
        R2B["❌ 不用动态值
        完整URL, 堆栈"]
        R2C["❌ 不过度细化
        省市区 → 大区"]
    end
    
    subgraph Rule3["原则3: 分层存储"]
        R3A["聚合指标 → Prometheus
        用于告警"]
        R3B["明细数据 → ELK/ClickHouse
        用于分析"]
        R3C["链路追踪 → Jaeger
        用于调试"]
    end
    
    Rule1 --&gt; Rule2
    Rule2 --&gt; Rule3
    
    style Rule1 fill:#e1f5ff,stroke:#0288d1,stroke-width:3px
    style Rule2 fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style Rule3 fill:#f3e5f5,stroke:#9c27b0,stroke-width:3px
    style R1A fill:#bbdefb,stroke:#0288d1
    style R1B fill:#bbdefb,stroke:#0288d1
    style R2A fill:#ffe0b2,stroke:#f57c00
    style R2B fill:#ffe0b2,stroke:#f57c00
    style R2C fill:#ffe0b2,stroke:#f57c00
    style R3A fill:#e1bee7,stroke:#9c27b0
    style R3B fill:#e1bee7,stroke:#9c27b0
    style R3C fill:#e1bee7,stroke:#9c27b0
</code></pre>
<h3 data-id="heading-28">6.2 快速诊断清单</h3>
<p>发现查询变慢或内存飙升？按以下步骤检查：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    Start([发现性能问题]) --&gt; Step1
    
    Step1["Step 1: 查看 TSDB Status
    访问 /tsdb-status"] --&gt; Check1{时序总数 &gt; 500万?}
    
    Check1 --&gt;|是| Step2A["找出高基数指标
    Top 10 series count"]
    Check1 --&gt;|否| Step2B[检查查询复杂度]
    
    Step2A --&gt; Step3["Step 2: 执行基数分析
    topk查询"]
    Step3 --&gt; Analyze{哪类标签值最多?}
    
    Analyze --&gt;|user_id等唯一ID| Fix1["移除标签
    改为日志记录"]
    Analyze --&gt;|URL动态路径| Fix2["路径归一化
    使用模板"]
    Analyze --&gt;|省市区等细化| Fix3["聚合为大区
    降低维度"]
    
    Fix1 &amp; Fix2 &amp; Fix3 --&gt; Step4["Step 3: 应用修复
    使用 relabel_configs"]
    Step4 --&gt; Verify["验证效果
    监控时序数变化"]
    
    style Start fill:#e1f5ff,stroke:#0288d1,stroke-width:2px
    style Step1 fill:#fff9c4,stroke:#fbc02d
    style Check1 fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style Analyze fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style Fix1 fill:#c8e6c9,stroke:#4caf50,stroke-width:2px
    style Fix2 fill:#c8e6c9,stroke:#4caf50,stroke-width:2px
    style Fix3 fill:#c8e6c9,stroke:#4caf50,stroke-width:2px
    style Step4 fill:#bbdefb,stroke:#0288d1
    style Verify fill:#a5d6a7,stroke:#2e7d32,stroke-width:3px
</code></pre>
<p><strong>Step 1: 查看 TSDB Status</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 访问 Prometheus UI</span>
http://localhost:9090/tsdb-status

重点关注：
• Head Cardinality Stats
• Top 10 label names with value count
• Top 10 series count by metric names

找出：哪个标签有10万+个值？哪个指标有10万+时序？
</code></pre>
<p><strong>Step 2: 执行基数分析查询</strong></p>
<pre><code class="hljs language-promql" lang="promql"># 查看时序总数
count({__name__=~".+"})

# 找出高基数指标（Top 10）
topk(10, count by (__name__)({__name__=~".+"}))

# 找出高基数标签
# 在 TSDB Status 页面查看 "label names with value count"
</code></pre>
<p><strong>Step 3: 对症下药</strong></p>
<pre><code class="hljs language-bash" lang="bash">问题类型                    解决方案
─────────────────────────────────────────
user_id 等唯一ID            移除标签，改为日志记录

URL 动态路径                路径归一化：
                           /api/order/123 → /api/order/{<span class="hljs-built_in">id</span>}

过度细化（省市区）          聚合为大区

历史遗留高基数指标          使用 relabel_configs 丢弃
</code></pre>
<h3 data-id="heading-29">6.3 Relabel 配置示例</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># prometheus.yml</span>
<span class="hljs-attr">scrape_configs:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">'order-service'</span>
    <span class="hljs-attr">relabel_configs:</span>
      <span class="hljs-comment"># 丢弃高基数标签</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">action:</span> <span class="hljs-string">labeldrop</span>
        <span class="hljs-attr">regex:</span> <span class="hljs-string">'user_id|order_id|request_id'</span>
      
      <span class="hljs-comment"># URL 路径归一化</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__path__</span>]
        <span class="hljs-attr">target_label:</span> <span class="hljs-string">path</span>
        <span class="hljs-attr">regex:</span> <span class="hljs-string">'/api/order/[0-9]+/(.*)'</span>
        <span class="hljs-attr">replacement:</span> <span class="hljs-string">'/api/order/{id}/$1'</span>
</code></pre>
<h3 data-id="heading-30">6.4 核心要点回顾</h3>
<p><strong>存储分层原则：</strong></p>
<ul>
<li>索引和最新数据存储在内存，保证查询速度</li>
<li>历史数据存储在磁盘，通过压缩节省空间</li>
<li>热数据（2小时内）用于实时告警，冷数据用于历史分析</li>
</ul>
<p><strong>标签设计原则：</strong></p>
<ul>
<li>标签应该是可聚合的维度，而非唯一标识</li>
<li>用户ID、订单号等明细信息应该放在日志系统</li>
<li>控制标签基数是保证查询性能的关键</li>
</ul>
<p><strong>监控与追踪的分工：</strong></p>
<ul>
<li>监控系统关注整体趋势和异常模式，用于告警</li>
<li>追踪系统关注个体行为和详细路径，用于排查</li>
<li>Prometheus 负责"发生了什么"，日志/追踪负责"谁做了什么"</li>
</ul>
<h3 data-id="heading-31">6.5 总结</h3>
<p><strong>Prometheus 的设计哲学：</strong></p>
<blockquote>
<p>监控系统应该回答"发生了什么"（What happened），
而不是"谁做了什么"（Who did what）。</p>
</blockquote>
<p><strong>两个维度的数据分离：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/953e4d21fb32468fb546dfacca3ba947~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LiP5rWq5peg55eV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768270907&amp;x-signature=A6VpvJiUFG8CADDqBBEGbpav20A%3D" alt="1.jpg" loading="lazy"/></p>
<p><strong>最后的建议：</strong></p>
<ol>
<li><strong>新指标上线前</strong>：先评估基数，计算 <code>时序数 = 各标签基数的乘积</code></li>
<li><strong>定期巡检</strong>：每周查看 TSDB Status，关注时序增长趋势</li>
<li><strong>告警优先</strong>：记住 Prometheus 主要用于告警，不是万能分析工具</li>
<li><strong>工具组合</strong>：Prometheus + ELK + Jaeger 才是完整的可观测性方案</li>
</ol>
<hr/>
<p><strong>参考资源：</strong></p>
<ul>
<li>Prometheus 官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fprometheus.io%2Fdocs%2F" target="_blank" title="https://prometheus.io/docs/" ref="nofollow noopener noreferrer">prometheus.io/docs/</a></li>
<li>TSDB 设计论文：<a href="https://link.juejin.cn?target=https%3A%2F%2Ffabxc.org%2Ftsdb%2F" target="_blank" title="https://fabxc.org/tsdb/" ref="nofollow noopener noreferrer">fabxc.org/tsdb/</a></li>
<li>基数分析工具：promtool tsdb analyze</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🔥Angular高效开发秘籍：掌握这些新特性，项目交付速度翻倍]]></title>    <link>https://juejin.cn/post/7591788451030990891</link>    <guid>https://juejin.cn/post/7591788451030990891</guid>    <pubDate>2026-01-06T11:17:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591788451030990891" data-draft-id="7592059801883983915" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🔥Angular高效开发秘籍：掌握这些新特性，项目交付速度翻倍"/> <meta itemprop="keywords" content="前端,TypeScript,Angular.js"/> <meta itemprop="datePublished" content="2026-01-06T11:17:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="DevUI团队"/> <meta itemprop="url" content="https://juejin.cn/user/712139267650141"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🔥Angular高效开发秘籍：掌握这些新特性，项目交付速度翻倍
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/712139267650141/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    DevUI团队
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T11:17:20.000Z" title="Tue Jan 06 2026 11:17:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    67
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>感谢贡献者 <a href="https://juejin.cn/user/1227513033920989" target="_blank" title="https://juejin.cn/user/1227513033920989">12点睡觉</a> 提供的优质好文！</p>
</blockquote>
<h2 data-id="heading-0">一、为什么要学习 Angular 新特性</h2>
<h3 data-id="heading-1">1.1 旧版 Angular 开发痛点</h3>
<ul>
<li>配置冗余：NgModule 套娃，组件复用需导入多个模块</li>
<li>性能瓶颈：首屏加载慢（RTTI 长），非必要资源打包进首屏</li>
<li>开发低效：模板嵌套复杂（*ngIf/*ngFor），响应式编程学习成本高（RxJS）</li>
<li>稳定性差：输入空值 Bug 多，缺乏编译时校验</li>
</ul>
<h2 data-id="heading-2">二、核心新特性介绍</h2>
<h3 data-id="heading-3">2.1 独立组件（Standalone Components）</h3>
<h4 data-id="heading-4">2.1.1 特性介绍​</h4>
<p>独立组件通过在 @Component 装饰器中配置 <code>standalone: true</code>，将「依赖管理能力」从 NgModule 下沉到组件本身，可直接通过 imports 数组导入所需的组件、指令、管道，无需封装到 NgModule 中，本质是简化项目层级、提升组件复用性。</p>
<h4 data-id="heading-5">2.1.2 基础实践：独立组件的使用</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 1. 独立组件定义（无需关联 NgModule)</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CommonModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MyPipe</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./my.pipe'</span>; <span class="hljs-comment">// 直接导入管道/指令</span>

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-demo'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>, 
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">CommonModule</span>, <span class="hljs-title class_">MyPipe</span>], <span class="hljs-comment">// 组件内直接导入依赖</span>
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;{{ 'test' | myPipe }}&lt;/div&gt;`</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoComponent</span> {}

<span class="hljs-comment">// 传统 NgModule 组件（冗余）</span>
<span class="hljs-meta">@NgModule</span>({
  <span class="hljs-attr">declarations</span>: [<span class="hljs-title class_">DemoComponent</span>, <span class="hljs-title class_">MyPipe</span>], <span class="hljs-comment">// 声明组件/管道</span>
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">CommonModule</span>],
  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">DemoComponent</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoModule</span> {}
</code></pre>
<h4 data-id="heading-6">2.1.3 进阶实践：独立组件共享依赖（避免重复导入）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// shared-directives.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CommonModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CustomInputDirective</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./custom-input.directive'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">FormatDatePipe</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./format-date.pipe'</span>;

<span class="hljs-comment">// 导出共享依赖，供其他独立组件批量导入</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">SharedDirectives</span> = [
  <span class="hljs-title class_">CommonModule</span>,
  <span class="hljs-title class_">CustomInputDirective</span>,
  <span class="hljs-title class_">FormatDatePipe</span>
];


<span class="hljs-comment">// user-form.component.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SharedDirectives</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shared-directives'</span>; <span class="hljs-comment">// 批量导入共享依赖</span>

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-user-form'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">imports</span>: <span class="hljs-title class_">SharedDirectives</span>, <span class="hljs-comment">// 无需逐个导入指令/管道</span>
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;input [appCustomInput]="true" placeholder="用户名"&gt;
    &lt;p&gt;注册时间：{{ registerTime | formatDate }}&lt;/p&gt;
  `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFormComponent</span> {
  registerTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
}
</code></pre>
<h4 data-id="heading-7">2.1.4 独立组件路由配置</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Routes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/router"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">HomeComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./home.component"</span>; <span class="hljs-comment">// 独立组件​</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">""</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">HomeComponent</span> }, <span class="hljs-comment">// 直接使用独立组件​</span>
  <span class="hljs-comment">// 懒加载独立组件（无需包装 NgModule）​</span>
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">"user/:id"</span>,
    <span class="hljs-attr">loadComponent</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./user-profile.component"</span>),
  },
  <span class="hljs-comment">// 独立组件下还存在子路由时，可直接引入路由配置常量​</span>
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">"user"</span>,
    <span class="hljs-attr">loadChildren</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./user.route.ts"</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> m.<span class="hljs-property">UserRoutes</span>),
  },
];
</code></pre>
<h4 data-id="heading-8">2.1.5 优缺点分析</h4>





















<table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1. 简化项目结构：减少冗余的 NgModule 文件</td><td>1. 需手动管理组件间的导入关系，无 NgModule 统一视角</td></tr><tr><td>2. 提升组件复用性：独立组件可直接跨项目导入（无需携带关联模块）</td><td>2. 旧项目兼容成本：需为旧模块组件补充 <code>imports: [CommonModule]</code> 适配新语法</td></tr><tr><td>3. 优化懒加载性能：loadComponent 比 loadChildren 轻量（减少模块包装开销）</td><td>3. 部分第三方库适配滞后：少数旧库仍依赖 NgModule，需通过 <code>imports: [LegacyModule]</code> 兼容</td></tr></tbody></table>
<h3 data-id="heading-9">2.2 新控制流语法</h3>
<h4 data-id="heading-10">2.2.1 特性介绍​</h4>
<p>控制流是一种将流程控制直接写入模板的新声明性语法，从而无须使用 <code>*ngIf</code>、<code>*ngFor</code> 和 <code>*ngSwitch</code> 这种基于指令（Directive）的控制流</p>
<h4 data-id="heading-11">2.2.2 场景 1：@if 语法（含 as 字符、@error 捕获）</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 1. @if + else if + else（替代嵌套 *ngIf） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"order-status"</span>&gt;</span>
  @if (order.status === 'pending') {
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"status-pending"</span>&gt;</span>待支付<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"payOrder()"</span>&gt;</span>立即支付<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  } @else if (order.status === 'paid') {
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"status-paid"</span>&gt;</span>已支付<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"viewLogistics()"</span>&gt;</span>查看物流<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  } @else if (order.status === 'shipped') {
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"status-shipped"</span>&gt;</span>已发货<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  } @else {
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"status-completed"</span>&gt;</span>已完成<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  }
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 data-id="heading-12">2.2.3 场景 2：@for 语法（含 track、@empty）</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 1. 基础用法：track 配置（替代 trackBy 函数） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"product-list"</span>&gt;</span>
  @for (product of products; track product.id;let i = $index, let even = $even) {
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"product-item"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"product.image"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"{{ product.name }}"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>{{ product.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"price"</span>&gt;</span>¥{{ product.price }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  } @empty {
    <span class="hljs-comment">&lt;!-- 列表为空时显示，替代 *ngIf="products.length === 0" --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"empty"</span>&gt;</span>暂无商品数据<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  }
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<p>支持原*ngFor中的变量</p>
<ul>
<li>$index 获取当前项的索引</li>
<li>$first 当前项是否是第一个</li>
<li>$last 当前项是否是最后一项</li>
<li>$even 当前项是否处于偶数索引</li>
<li>$odd 当前项是否处于奇数索引</li>
<li>$count 获取集合的长度</li>
</ul>
<h4 data-id="heading-13">2.2.4 场景 3：@error语法</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- @error 仅作用于 @if/@for 结合 async 管道的上下文--&gt;</span>
@if (user$ | async; as user; loading isLoading; error errorInfo) {
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ 数据变量名.属性 }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
} @loading {
  <span class="hljs-comment">&lt;!-- 可选：异步流未完成时的加载状态
  &lt;div&gt;加载中...&lt;/div&gt;
} @error {
  &lt;!-- @error 语义：渲染失败时的兜底逻辑 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>错误：{{ errorInfo.message }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
}
</code></pre>
<p><strong>可监听的错误类型</strong></p>
<ul>
<li>
<p>异步流自身抛出的错误</p>

























<table><thead><tr><th>HTTP 请求错误</th><th>接口返回 404/403/500 状态码、网络中断、CORS 配置错误</th></tr></thead><tbody><tr><td>异步操作超时</td><td><code>data$.pipe(timeout(3000))</code> 超时触发 <code>TimeoutError</code></td></tr><tr><td>Promise 执行错误</td><td><code>new Promise((_, reject) =&gt; reject(new Error('执行失败')))</code></td></tr><tr><td>业务逻辑主动抛错</td><td><code>data$.pipe(map(res =&gt; { if (!res.id) throw new Error('ID缺失'); }))</code></td></tr><tr><td>流取消 / 终止错误</td><td>异步流被手动 <code>unsubscribe</code> 且抛错、流内部未捕获的执行错误</td></tr></tbody></table>
</li>
<li>
<p>异步数据解析 / 转换错误</p>





















<table><thead><tr><th>子类型</th><th>触发示例</th></tr></thead><tbody><tr><td>数据格式不匹配</td><td>期望数组却返回对象：<code>list$ = of({ name: 'test' })</code> + <code>@for</code> 渲染</td></tr><tr><td>JSON 解析错误</td><td><code>data$ = http.get('/api/data').pipe(map(res =&gt; JSON.parse(res)))</code>（非 JSON 字符串）</td></tr><tr><td>类型转换错误</td><td>异步返回字符串却做数字运算：<code>{{ data * 2 }}</code>（<code>data$ = of('abc')</code>）</td></tr></tbody></table>
</li>
<li>
<p>模板渲染异步数据的运行时错误</p>

























<table><thead><tr><th>子类型</th><th>触发示例</th></tr></thead><tbody><tr><td>空值 / 未定义访问</td><td><code>data$ = of(null)</code> + 模板中 <code>{{ data.name }}</code></td></tr><tr><td>数组方法调用错误</td><td><code>data$ = of(123)</code> + 模板中 <code>{{ data.filter(item =&gt; item &gt; 0) }}</code></td></tr><tr><td>管道执行错误</td><td><code>data$ = of('2025-13-01')</code> + 模板中 <code>{{ data | date }}</code>（非法日期）</td></tr><tr><td>模板内函数调用错误</td><td><code>data$ = of('test')</code> + 模板中 <code>{{ formatData(data) }}</code>（formatData 抛错）</td></tr></tbody></table>
</li>
</ul>
<h4 data-id="heading-14">2.2.5 场景 4：@switch 语法（替代 *ngSwitch）</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"role-container"</span>&gt;</span>
  @switch (user.role) {
    @case ('admin') {
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"role-tag admin"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>管理员<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"showAdminMenu()"</span>&gt;</span>管理菜单<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    }
    @case ('editor') {
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"role-tag editor"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>编辑<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"showEditorTools()"</span>&gt;</span>编辑工具<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    }
    @case ('viewer') {
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"role-tag viewer"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>查看者<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    }
    @default {
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"role-tag guest"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>访客<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"goToLogin()"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    }
  }
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 data-id="heading-15">2.2.6 优缺点分析</h4>





















<table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1. 性能提升：编译后减少 DOM 操作次数，比旧指令快 15%-20%</td><td>1. 迁移成本：旧项目需批量修改模板，复杂嵌套逻辑需手动适配</td></tr><tr><td>2. 语法直观：支持 @else if/@empty，减少嵌套层级（如替代 *ngIf 嵌套）</td><td>2. IDE 支持滞后：部分旧版 IDE 语法高亮不完整</td></tr><tr><td>3. 减少错误：@for 强制要求 track，避免因忘记 trackBy 导致的列表重渲染性能问题</td><td>3. 兼容性限制：仅 Angular17+ 支持，无法降级到旧版本</td></tr></tbody></table>
<h3 data-id="heading-16">2.3 信号（Signals）</h3>
<h4 data-id="heading-17">2.3.1 核心概念与基础 API 总览​</h4>
<p>Signals 是 Angular17 推出的轻量级响应式状态管理方案，核心解决传统 BehaviorSubject 需手动订阅、变更检测冗余的问题，API 分为三类：</p>















































<table><thead><tr><th>API 类型</th><th>具体 API</th><th>作用</th><th>适用场景</th></tr></thead><tbody><tr><td>基础信号操作</td><td>signal(initialValue)</td><td>创建基础信号（初始值不可变）</td><td>定义组件内 / Service 内状态</td></tr><tr><td/><td>set(newValue)</td><td>全量替换信号值（覆盖旧值）</td><td>直接赋值（如表单输入、状态重置）</td></tr><tr><td/><td>update(prev =&gt; new)</td><td>基于旧值计算新值（函数式更新）</td><td>累加、过滤、修改部分属性</td></tr><tr><td/><td><del>mutate(prev =&gt; void) （NG18已废弃删除）</del></td><td><del>直接修改引用类型内部值（不创建新引用）</del></td><td><del>数组 push/pop、对象属性修改</del></td></tr><tr><td>计算信号</td><td>computed(() =&gt; value)</td><td>依赖其他信号的衍生值（自动响应变化）</td><td>计算总价、筛选列表、格式转换</td></tr><tr><td>副作用监听</td><td>effect(() =&gt; void)</td><td>信号变化时执行副作用（如日志、请求）</td><td>状态变化后触发 API、更新 DOM</td></tr></tbody></table>
<h4 data-id="heading-18">2.3.2 基础 API 实战</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span>, signal } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-counter'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;div class="counter"&gt;
      &lt;h3&gt;当前计数：{{ count() }}&lt;/h3&gt;
      &lt;button (click)="resetCount()"&gt;重置为 0&lt;/button&gt;
      &lt;button (click)="increment()"&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  `</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterComponent</span> {
  <span class="hljs-comment">// 创建基础信号（初始值为 0）</span>
  count = <span class="hljs-title function_">signal</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// 计算信号</span>
  totalCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> ()*<span class="hljs-number">2</span>);

  <span class="hljs-comment">// set：全量替换信号值</span>
  <span class="hljs-title function_">resetCount</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>);
  }

  <span class="hljs-comment">// update：基于旧值累加 1</span>
  <span class="hljs-title function_">increment</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>.<span class="hljs-title function_">update</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);
  }
}
</code></pre>
<h4 data-id="heading-19">2.3.4  effect 副作用清理（避免内存泄漏）</h4>
<p>当effect中包含订阅（如定时器、API 订阅）时，需通过<strong>清理函数</strong>释放资源，避免组件销毁后仍执行：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span>, signal, effect, <span class="hljs-title class_">OnDestroy</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { interval } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-timer'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;p&gt;当前计数：{{ count() }}&lt;/p&gt;`</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OnDestroy</span> {
  count = <span class="hljs-title function_">signal</span>(<span class="hljs-number">0</span>);
  <span class="hljs-comment">// 存储effect清理函数（用于组件销毁时调用）</span>
  <span class="hljs-keyword">private</span> effectCleanup?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// effect返回清理函数，用于释放资源</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">effectCleanup</span> = <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 场景：当count&gt;5时，启动定时器（需清理）</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">count</span>() &gt; <span class="hljs-number">5</span>) {
        <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">interval</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>.<span class="hljs-title function_">update</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);
        });
        <span class="hljs-comment">// 清理函数：组件销毁时取消订阅</span>
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> timer.<span class="hljs-title function_">unsubscribe</span>();
      }
    });
  }

  <span class="hljs-comment">// 组件销毁时执行清理</span>
  <span class="hljs-title function_">ngOnDestroy</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">effectCleanup</span>?.();
  }

  <span class="hljs-comment">// 外部触发count增加</span>
  <span class="hljs-title function_">increment</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>.<span class="hljs-title function_">update</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);
  }
}
</code></pre>
<h4 data-id="heading-20">2.3.5 signal 与 Observable 互转（适配异步场景）</h4>
<p>通过toSignal()（Observable 转信号）和fromSignal()（信号转 Observable），适配既有 RxJS 代码：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { signal, toSignal } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { fromSignal } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core/rxjs-interop'</span>;
<span class="hljs-keyword">import</span> { interval, switchMap, debounceTime } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-signal-observable'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;p&gt;当前用户：{{ user()?.name }}&lt;/p&gt;
    &lt;input [(ngModel)]="searchInput()" placeholder="搜索..."&gt;
    &lt;p&gt;搜索结果：{{ searchResult()?.length || 0 }} 条&lt;/p&gt;
  `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SignalObservableComponent</span> {
  <span class="hljs-comment">// 1. Observable转信号：适配API请求（如HttpClient返回Observable）</span>
  userId = <span class="hljs-title function_">signal</span>(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// 当userId变化时，自动重新请求用户信息（switchMap切换请求）</span>
  user$ = <span class="hljs-title function_">fromSignal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">userId</span>).<span class="hljs-title function_">pipe</span>(
    <span class="hljs-title function_">switchMap</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/user/<span class="hljs-subst">${id}</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>()))
  );
  <span class="hljs-comment">// 将Observable转为信号，供模板使用（initialValue避免undefined）</span>
  user = <span class="hljs-title function_">toSignal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">user$</span>, { <span class="hljs-attr">initialValue</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'默认用户'</span> } });

  <span class="hljs-comment">// 2. 信号转Observable：适配RxJS操作符（如debounceTime）</span>
  searchInput = <span class="hljs-title function_">signal</span>(<span class="hljs-string">''</span>);
  <span class="hljs-comment">// 将信号转为Observable，添加防抖</span>
  searchResult$ = <span class="hljs-title function_">fromSignal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">searchInput</span>).<span class="hljs-title function_">pipe</span>(
    <span class="hljs-title function_">debounceTime</span>(<span class="hljs-number">300</span>), <span class="hljs-comment">// 输入停止300ms后执行搜索</span>
    <span class="hljs-title function_">switchMap</span>(<span class="hljs-function"><span class="hljs-params">keyword</span> =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/search?kw=<span class="hljs-subst">${keyword}</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>()))
  );
  <span class="hljs-comment">// 转为信号供模板使用</span>
  searchResult = <span class="hljs-title function_">toSignal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">searchResult$</span>, { <span class="hljs-attr">initialValue</span>: [] });
}
</code></pre>
<h4 data-id="heading-21">2.3.6 信号（Signals）与 Observable 订阅的场景对比</h4>








































<table><thead><tr><th>适用场景</th><th>选择信号（Signals）</th><th>选择 Observable 订阅</th></tr></thead><tbody><tr><td>组件内简单状态管理</td><td>✅ 优先选择：计数器、弹窗显隐、表单输入状态</td><td>❌ 不推荐：语法繁琐，需手动管理订阅</td></tr><tr><td>多依赖衍生值计算</td><td>✅ 优先选择：购物车总价、筛选列表、格式转换</td><td>❌ 不推荐：需用 combineLatest 等操作符，语法复杂</td></tr><tr><td>跨组件共享简单状态</td><td>✅ 优先选择：主题切换、登录状态、全局开关</td><td>❌ 不推荐：需用 Subject 封装，内存管理复杂</td></tr><tr><td>复杂异步流（多请求合并）</td><td>❌ 不推荐：需通过 toSignal() 适配，无原生操作符</td><td>✅ 优先选择：switchMap/forkJoin 等操作符原生支持</td></tr><tr><td>高频事件处理（防抖 / 节流）</td><td>❌ 不推荐：需转 Observable 后使用操作符</td><td>✅ 优先选择：debounceTime/throttleTime 原生支持</td></tr><tr><td>实时数据流（WebSocket）</td><td>❌ 不推荐：需转 Observable 处理持续事件流</td><td>✅ 优先选择：原生支持 next/complete 事件</td></tr></tbody></table>
<h3 data-id="heading-22">2.4 延迟加载模板（@defer）- 全场景覆盖</h3>
<h4 data-id="heading-23">2.4.1 语法原理</h4>
<p>@defer 是 Angular17 新增的<strong>模板级延迟加载语法</strong>，核心是 “按需加载非首屏内容”（如弹窗、折叠面板内组件），避免首屏加载冗余的 JS/CSS 资源。支持四大核心能力：​</p>
<ol>
<li>触发条件：on（用户交互）、when（条件满足）；​</li>
<li>状态提示：<code>@placeholder</code>（加载中）、<code>@loading</code>（加载中）、<code>@error</code>（加载失败）、<code>@empty</code>（内容为空）；​</li>
<li>预加载：prefetch（提前加载即将用到的资源）；​</li>
<li>性能优化：加载完成后自动替换占位内容，无闪烁。</li>
</ol>
<h4 data-id="heading-24">2.4.2 基础用法（默认触发：组件初始化后延迟加载）</h4>
<p>适用于 “首屏非关键内容”（如页面底部的推荐列表）：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 首屏优先加载核心内容（用户信息） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"user-info"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{{ user.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ user.email }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 延迟加载非关键内容（推荐列表） --&gt;</span>
@defer {
  <span class="hljs-tag">&lt;<span class="hljs-name">app-recommended-list</span> [<span class="hljs-attr">userId</span>]=<span class="hljs-string">"user.id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-recommended-list</span>&gt;</span>
} @placeholder (minimum 500ms){
  <span class="hljs-comment">&lt;!-- 加载前状态：占位内容 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"comment-skeleton"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"skeleton-line"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"skeleton-line"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"skeleton-avatar"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
} @loading {
  <span class="hljs-comment">&lt;!-- 加载中状态：替代ngIf+loading变量 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"skeleton"</span>&gt;</span>推荐内容加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
}
</code></pre>
<h4 data-id="heading-25">2.4.3 on 触发（用户交互时加载）</h4>
<p>适用于 “用户主动触发才显示的内容”（如点击按钮显示的详情面板）：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 按钮触发：点击后加载详情组件 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> #<span class="hljs-attr">detailBtn</span>&gt;</span>查看订单详情<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

@defer (on click(detailBtn)) { <span class="hljs-comment">&lt;!-- 点击按钮时触发加载 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">app-order-detail</span> [<span class="hljs-attr">orderId</span>]=<span class="hljs-string">"currentOrderId"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-order-detail</span>&gt;</span>
} @loading {
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"loading-spinner"</span>&gt;</span>加载详情中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
} @error {
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"error"</span>&gt;</span>详情加载失败，请重试<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
}

<span class="hljs-comment">&lt;!-- 其他触发事件：hover/focus --&gt;</span>
@defer (on hover(detailCard)) { <span class="hljs-comment">&lt;!-- 鼠标悬浮时加载 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-tooltip"</span>&gt;</span>订单创建时间：{{ order.createTime }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
}

<span class="hljs-comment">&lt;!-- 其他触发事件：scroll --&gt;</span>
@defer (on scroll(detailCard, 200px)) {​
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"loading-more"</span>&gt;</span>加载更多商品中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>​
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"moreProducts$ | async as more"</span>&gt;</span>​
    @for (item of more; track item.id) {​
      <span class="hljs-tag">&lt;<span class="hljs-name">app-product-card</span> [<span class="hljs-attr">product</span>]=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-product-card</span>&gt;</span>​
    }​
  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>​
}
</code></pre>
<h4 data-id="heading-26">2.4.4 when 触发（条件满足时加载）</h4>
<p>适用于 “数据就绪 / 状态变化时加载”（如筛选条件选择后加载表格）：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 条件触发：筛选条件选中后加载表格 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"selectedType"</span> (<span class="hljs-attr">change</span>)=<span class="hljs-string">"onTypeChange()"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span>请选择订单类型<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"all"</span>&gt;</span>全部订单<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"paid"</span>&gt;</span>已支付<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>

@defer (when selectedType !== '') { <span class="hljs-comment">&lt;!-- 当selectedType非空时加载 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">app-order-table</span> [<span class="hljs-attr">type</span>]=<span class="hljs-string">"selectedType"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-order-table</span>&gt;</span>
} @loading {
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table-skeleton"</span>&gt;</span>表格加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
} @empty {
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>暂无{{ selectedType === 'paid' ? '已支付' : '全部' }}订单<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
}
</code></pre>
<h4 data-id="heading-27">2.4.5 prefetch 预加载（提前加载即将用到的内容）</h4>
<p>适用于 “即将触发加载” 的场景（如滚动到接近位置时预加载），减少用户等待时间：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 预加载：当用户滚动到距离组件500px时，提前加载 --&gt;</span>
@defer (on scroll(container, 500px); prefetch on scroll(container, 1000px)) {
  <span class="hljs-comment">&lt;!-- 滚动到距离组件1000px时预加载资源，滚动到500px时显示 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">app-long-list</span> [<span class="hljs-attr">page</span>]=<span class="hljs-string">"currentPage"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-long-list</span>&gt;</span>
}

<span class="hljs-comment">&lt;!-- 容器滚动监听：指定scroll的参考容器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> #<span class="hljs-attr">container</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"scroll-container"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: 500px; overflow-y: auto;"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 其他内容 --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 data-id="heading-28">2.4.6 @error语法</h4>
<p>专为「<code>defer</code> 懒加载全流程」设计的错误捕获块，仅作用于 <code>defer</code> 块内部，捕获从「懒加载资源下载」到「组件初始化 / 渲染」的全链路错误，属于「资源加载层错误兜底」。</p>
<pre><code class="hljs language-html" lang="html">@defer
<span class="hljs-comment">&lt;!-- 懒加载目标组件 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">app-lazy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-lazy</span>&gt;</span>
} @placeholder {
<span class="hljs-comment">&lt;!-- 触发前占位：点击按钮加载 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击加载懒组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
} @loading {
<span class="hljs-comment">&lt;!-- 加载中状态 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
} @error {
<span class="hljs-comment">&lt;!-- 懒加载错误捕获：$error 是内置错误对象 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>❌ 懒加载失败：{{ $error.message }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
}
</code></pre>
<p><strong>可监听的错误类型</strong></p>
<ul>
<li>懒加载资源下载错误</li>
</ul>





























<table><thead><tr><th>类型</th><th>触发示例</th></tr></thead><tbody><tr><td>JS/CSS chunk 404</td><td>打包后的懒加载 chunk 路径错误、CDN 缓存失效、文件名哈希变更</td></tr><tr><td>网络层错误</td><td>下载 chunk 时断网、网络超时、DNS 解析失败</td></tr><tr><td>跨域 / 安全限制</td><td>chunk 资源违反 CORS/CSP 策略，浏览器拦截下载</td></tr><tr><td>混合内容错误</td><td>HTTPS 页面加载 HTTP 协议的懒加载 JS chunk（浏览器阻止）</td></tr><tr><td>资源大小超限</td><td>chunk 体积超过服务器 / 浏览器限制（如 nginx <code>client_max_body_size</code> 限制）</td></tr></tbody></table>
<ul>
<li>懒加载组件编译 / 解析错误</li>
</ul>

























<table><thead><tr><th>类型</th><th>触发示例</th></tr></thead><tbody><tr><td>组件代码语法错误</td><td>懒加载组件的 TS 代码有语法错误（如少分号、变量未定义）</td></tr><tr><td>模板语法错误</td><td>懒加载组件的模板有语法错误（如 <code>{{ data..name }}</code> 双点、指令拼写错误）</td></tr><tr><td>组件元数据错误</td><td>懒加载组件的 <code>@Component</code> 元数据错误（如 <code>selector</code> 重复、<code>imports</code> 漏写）</td></tr><tr><td>二进制 chunk 损坏</td><td>下载的 JS chunk 二进制数据不完整（如网络中断导致下载一半）</td></tr></tbody></table>
<ul>
<li>懒加载组件初始化错误</li>
</ul>





















<table><thead><tr><th>类型</th><th>触发示例</th></tr></thead><tbody><tr><td>生命周期抛错</td><td>懒加载组件 <code>ngOnInit</code> 中调用接口抛错、<code>ngAfterViewInit</code> 操作 DOM 抛错</td></tr><tr><td>组件状态初始化错误</td><td>懒加载组件的 Signal / 变量初始化抛错（如 <code>count = signal(1/0)</code>）</td></tr><tr><td>模板渲染初始化错误</td><td>组件首次渲染时，同步模板表达式错误（如 <code>{{ undefined.name }}</code>）</td></tr></tbody></table>
<ul>
<li>懒加载组件依赖注入错误</li>
</ul>





















<table><thead><tr><th>类型</th><th>触发示例</th></tr></thead><tbody><tr><td>服务未提供</td><td>懒加载组件依赖 <code>UserService</code>，但未在 <code>providers</code>/ 根注入器中配置</td></tr><tr><td>依赖循环引用</td><td>懒加载组件依赖的服务与其他服务形成循环引用，导致注入失败</td></tr><tr><td>管道 / 指令未导入</td><td>懒加载组件模板使用 <code>myPipe</code>，但组件 <code>imports</code> 未导入该管道</td></tr></tbody></table>
<h4 data-id="heading-29">2.4.7 优缺点分析</h4>

























<table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1. 首屏加载提速：减少首屏 JS/CSS 体积（非关键组件延迟加载）</td><td>1. 触发时机需谨慎：滥用可能导致用户交互时卡顿（如点击后才加载大组件）</td></tr><tr><td>2. 简化状态管理：内置 <code>@loading/@error</code>，无需手动维护 loading/error 变量</td><td>2. 调试成本：需通过 Angular DevTools 查看延迟加载状态，无法直接断点调试</td></tr><tr><td>3. 预加载优化：prefetch 可平衡加载时机与用户体验，减少等待时间</td><td>3. 兼容性限制：仅 Angular17+ 支持，无法降级到旧版本</td></tr><tr><td>4. 语法直观：无需手动写 ngIf 控制显隐，模板逻辑更简洁</td><td>4. 复杂场景适配难：动态组件加载（如 ComponentFactoryResolver）需额外处理</td></tr></tbody></table>
<h3 data-id="heading-30">2.5 指令组合 API</h3>
<h4 data-id="heading-31">2.5.1 核心定义</h4>
<p>组件通过<code>hostDirectives</code>配置，直接 “继承” 其他指令的逻辑（属性、方法、生命周期）</p>
<h4 data-id="heading-32">2.5.2 解决痛点</h4>
<p>旧版用 mixin（混入）复用逻辑，代码冗余且类型不安全；模板中重复绑定指令</p>
<h4 data-id="heading-33">2.5.3 实战代码</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 1. 定义独立指令（封装通用逻辑）</span>
<span class="hljs-meta">@Directive</span>({ <span class="hljs-attr">selector</span>: <span class="hljs-string">'[appAuth]'</span>, <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span> })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthDirective</span> {
  <span class="hljs-meta">@Input</span>() appAuth!: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 接收权限标识</span>
  <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'校验权限：'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">appAuth</span>); <span class="hljs-comment">// 通用权限校验逻辑</span>
  }
}

<span class="hljs-comment">// 2. 组件集成指令（无需模板绑定）</span>
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-admin-panel'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">hostDirectives</span>: [
    { <span class="hljs-attr">directive</span>: <span class="hljs-title class_">AuthDirective</span>, <span class="hljs-attr">inputs</span>: [<span class="hljs-string">'appAuth'</span>] } <span class="hljs-comment">// 集成指令，映射输入</span>
  ],
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;管理员面板&lt;/div&gt;`</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminPanelComponent</span> { }

<span class="hljs-comment">// 3. 使用组件（直接传递指令输入）</span>
&lt;app-admin-panel appAuth=<span class="hljs-string">"admin"</span>&gt;&lt;/app-admin-panel&gt;
</code></pre>
<h3 data-id="heading-34">2.6 NgOptimizedImage</h3>
<h4 data-id="heading-35">2.6.1 核心定义</h4>
<p>Angular 15 + 稳定的图片优化指令，替代原生<code>img</code>，一站式解决图片加载性能问题</p>
<h4 data-id="heading-36">2.6.2 解决痛点</h4>
<p>原生图片易导致布局偏移（CLS）、加载慢、格式不优化、缺乏优先级控制</p>
<h4 data-id="heading-37">2.6.3 核心能力</h4>
<p>强制宽高比（防 CLS）、自动懒加载、自动格式转换（WebP/AVIF）、优先级控制</p>
<h4 data-id="heading-38">2.6.4 实战代码</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 1. 首屏核心图片（优先加载，禁用懒加载） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> 
  <span class="hljs-attr">ngSrc</span>=<span class="hljs-string">"home-banner.jpg"</span> 
  <span class="hljs-attr">width</span>=<span class="hljs-string">"1200"</span> 
  <span class="hljs-attr">height</span>=<span class="hljs-string">"400"</span> 
  <span class="hljs-attr">priority</span> &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">核心</span>：<span class="hljs-attr">首屏优先加载</span> <span class="hljs-attr">--</span>&gt;</span>
  alt="首页Banner"
&gt;

<span class="hljs-comment">&lt;!-- 2. 非首屏图片（自动懒加载，优化格式） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> 
  <span class="hljs-attr">ngSrc</span>=<span class="hljs-string">"user-avatar.jpg"</span> 
  <span class="hljs-attr">width</span>=<span class="hljs-string">"80"</span> 
  <span class="hljs-attr">height</span>=<span class="hljs-string">"80"</span> 
  <span class="hljs-attr">loading</span>=<span class="hljs-string">"lazy"</span> &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">默认懒加载</span>，<span class="hljs-attr">可省略</span> <span class="hljs-attr">--</span>&gt;</span>
  alt="用户头像"
&gt;

<span class="hljs-comment">&lt;!-- 3. 响应式图片（适配不同设备） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> 
  <span class="hljs-attr">ngSrc</span>=<span class="hljs-string">"product-{{size}}.jpg"</span> 
  [<span class="hljs-attr">width</span>]=<span class="hljs-string">"size === 'sm' ? 300 : 600"</span>
  [<span class="hljs-attr">height</span>]=<span class="hljs-string">"size === 'sm' ? 200 : 400"</span>
  [<span class="hljs-attr">size</span>]=<span class="hljs-string">"'(max-width: 640px) 300px, 600px'"</span>
  <span class="hljs-attr">alt</span>=<span class="hljs-string">"商品图片"</span>
&gt;</span>
</code></pre>
<h3 data-id="heading-39">2.7 canMatch 路由守卫</h3>
<h4 data-id="heading-40">2.7.1 核心定义</h4>
<p>Angular 15 + 稳定的路由守卫，在 “路由匹配阶段” 筛选路由，决定是否将路由纳入候选</p>
<h4 data-id="heading-41">2.7.2 解决痛点</h4>
<p>旧版<code>canActivate</code>在路由匹配后执行，失败则拒绝访问，无法实现 “同路径多组件” 动态匹配（如多租户）</p>
<h4 data-id="heading-42">2.7.3 核心差异（vs canActivate）</h4>
<ul>
<li>canActivate：匹配后准入控制 → 失败 = 拒绝访问</li>
<li>canMatch：匹配中筛选 → 失败 = 跳过当前路由，继续匹配下一个</li>
</ul>
<h4 data-id="heading-43">2.7.4 执行顺序</h4>
<ol>
<li>​<strong>matcher</strong>​：匹配 URL 规则；</li>
<li>​<strong>canMatch</strong>​：校验是否允许匹配该路由；</li>
<li>​<strong>canLoad</strong>​：校验是否允许加载懒加载模块；</li>
<li>加载模块（若 canLoad 通过）；</li>
<li>​<strong>canActivate</strong>​：校验是否允许激活路由；</li>
<li>激活路由，渲染组件。</li>
</ol>
<h4 data-id="heading-44">2.7.5 实战代码（多租户场景）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 1. 定义canMatch守卫</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">tenantMatchGuard</span>: <span class="hljs-title class_">CanMatchFn</span> = <span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> tenantService = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">TenantService</span>);
  <span class="hljs-keyword">return</span> tenantService.<span class="hljs-title function_">getCurrentTenant</span>() === route.<span class="hljs-property">data</span>.<span class="hljs-property">tenantId</span>;
};

<span class="hljs-comment">// 2. 路由配置（同路径匹配不同租户组件）</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
  { 
    <span class="hljs-attr">path</span>: <span class="hljs-string">'dashboard'</span>, 
    <span class="hljs-attr">canMatch</span>: [tenantMatchGuard], 
    <span class="hljs-attr">data</span>: { <span class="hljs-attr">tenantId</span>: <span class="hljs-string">'tenant1'</span> }, 
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Tenant1DashboardComponent</span> 
  },
  { 
    <span class="hljs-attr">path</span>: <span class="hljs-string">'dashboard'</span>, 
    <span class="hljs-attr">canMatch</span>: [tenantMatchGuard], 
    <span class="hljs-attr">data</span>: { <span class="hljs-attr">tenantId</span>: <span class="hljs-string">'tenant2'</span> }, 
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Tenant2DashboardComponent</span> 
  },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'dashboard'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">FallbackDashboardComponent</span> } <span class="hljs-comment">// 兜底</span>
];
</code></pre>
<h3 data-id="heading-45">2.8 依赖注入（DI）增强：更灵活的注入方式</h3>
<h4 data-id="heading-46">2.8.1 核心定义</h4>
<p>Angular 16 + 优化的 DI 系统，支持<code>inject</code>函数在构造函数外使用，增强环境区分能力</p>
<h4 data-id="heading-47">2.8.2 解决痛点</h4>
<p>旧版<code>inject</code>仅能在构造函数 / 工厂函数中使用，静态方法、第三方库回调中无法注入</p>
<h4 data-id="heading-48">2.8.3 实战代码（常用场景）</h4>
<h5 data-id="heading-49">场景 1：类内任意位置注入</h5>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-meta">@Injectable</span>({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigService</span> {
  <span class="hljs-keyword">private</span> http = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">HttpClient</span>); <span class="hljs-comment">// 类内直接注入，无需构造函数</span>

  <span class="hljs-title function_">loadConfig</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/config'</span>);
  }
}
</code></pre>
<h5 data-id="heading-50">场景 2：静态方法中注入</h5>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-meta">@Injectable</span>({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TenantService</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getCurrentTenant</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> configService = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">ConfigService</span>); <span class="hljs-comment">// 静态方法注入</span>
    <span class="hljs-keyword">return</span> configService.<span class="hljs-title function_">loadConfig</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">tenantId</span>);
  }
}
</code></pre>
<h3 data-id="heading-51">2.9 Required Inputs：编译时校验的必填输入</h3>
<h4 data-id="heading-52">2.9.1 核心定义</h4>
<p>Angular 16 + 稳定的输入属性校验特性，通过<code>@Input({ required: true })</code>标记必填，编译时 + 运行时双校验</p>
<h4 data-id="heading-53">2.9.2 解决痛点</h4>
<p>旧版需手动在<code>ngOnInit</code>中判空，易遗漏导致空值 Bug；错误反馈滞后（运行时才报错）</p>
<h4 data-id="heading-54">2.9.3 实战代码</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 1. 标记必填输入</span>
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-user-card'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;{{user.name}}&lt;/div&gt;`</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCardComponent</span> {
  <span class="hljs-meta">@Input</span>({ <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> }) user!: { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> }; <span class="hljs-comment">// 核心：required: true</span>
}

<span class="hljs-comment">// 2. 使用组件（未传user时编译报错）</span>
&lt;app-user-card [user]=<span class="hljs-string">"userData"</span>&gt;&lt;/app-user-card&gt; &lt;!-- 正确 --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">app-user-card</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-user-card</span>&gt;</span></span> &lt;!-- 错误：编译时报错 <span class="hljs-title class_">NG8007</span> --&gt;
</code></pre>
<h2 data-id="heading-55">三、优秀实践——懒加载</h2>
<p>学完上述 9 个实用特性，我们不妨把它们串联起来落地实践。这一节，我们聚焦性能优化的高频需求 —— 懒加载，详细讲讲如何通过 ​<strong>独立组件与 defer 延迟加载语法的结合</strong>​，实现高效的按需加载方案。</p>
<h3 data-id="heading-56">3.1 必要条件</h3>
<p>相信不少开发者刚接触 <code>@defer</code> 延迟加载语法时，都会遇到一个共性问题 —— 明明写了语法，懒加载却始终不生效。其实这背后，是因为我们忽略了几个关键的必要条件。</p>
<p>假设组件 A 是与 <code>@defer</code> 指令处于<strong>同一层级</strong>的组件，而组件 B 是被 <code>@defer</code> 指令包裹、需要实现懒加载的目标组件。</p>
<p><strong>必要条件：</strong></p>
<ul>
<li>组件A必须是独立组件：<code>standalone: true</code>;</li>
<li>组件B必须是独立组件：<code>standalone: true</code>;</li>
<li>组件A需显式导入组件B: <code>imports:[RepoEchartComponent]</code>;</li>
</ul>
<h3 data-id="heading-57">3.2 实战代码</h3>
<h4 data-id="heading-58">3.2.1 场景一：评论区懒加载（用户滚动到区域才加载）</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>商品详情<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 其他内容 --&gt;</span>

  @defer (on viewport; prefetch on idle) {
    <span class="hljs-tag">&lt;<span class="hljs-name">app-comments</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-comments</span>&gt;</span>
  } @loading {
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>评论加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  }
<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>

</code></pre>
<h4 data-id="heading-59">3.2.1 场景二：结合 <code>@switch</code> 实现 Tab 懒加载</h4>
<pre><code class="hljs language-html" lang="html">@switch (activeTab) {
  @case ('profile') {
    @defer (on viewport) {
      <span class="hljs-tag">&lt;<span class="hljs-name">app-profile</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-profile</span>&gt;</span>
    }
  }
  @case ('settings') {
    @defer (on interaction) {
      <span class="hljs-tag">&lt;<span class="hljs-name">app-settings</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-settings</span>&gt;</span>
    }
  }
}
</code></pre>
<h3 data-id="heading-60">3.3 注意事项</h3>
<ul>
<li>
<p><code>@defer</code>​<strong>不能嵌套</strong>​（截至 Angular 18）</p>
</li>
<li>
<p>不要过度使用：每个 defer 块会生成独立 chunk，过多可能导致 HTTP 请求爆炸</p>
</li>
<li>
<p><code>prefetch</code> 为实验性功能，需启用 <code>deferBlockPrefetching</code></p>
</li>
<li>
<p>已在其他场景引用或注册的组件无法被懒加载</p>
</li>
<li>
<p>继承的父组件类无法被懒加载，需改造成非组件类</p>
<p><strong>错误示例：</strong></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-meta">@Component</span>({
    <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">'./basic.component.html'</span>,
    <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">'./basic.component.scss'</span>],
    <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">imports</span>: <span class="hljs-title class_">BasicModules</span>,
 }）
<span class="hljs-comment">//这是一个组件基类</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicComponent</span>{}

<span class="hljs-comment">//这是期望懒加载的组件Demo</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BasicComponent</span>{}
</code></pre>
<p><strong>修改方案</strong></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">//将组件基类改造为非组件类</span>
<span class="hljs-meta">@Injectable</span>({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'any'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicComponent</span>{}
</code></pre>
</li>
</ul>
<p>以上就是懒加载的实现方案和踩坑经验啦，希望能帮到正在折腾 <code>@defer</code> 的小伙伴～</p>
<h2 data-id="heading-61">四、总结</h2>
<p>Angular的新特性围绕 “​<strong>性能优化</strong>​”“​<strong>开发效率</strong>​”“​<strong>场景适配</strong>​” 三大核心：延迟加载模版（@defer） 降低首屏加载成本，独立组件与新控制流语法简化代码结构，信号（Signals）完善响应式能力。通过熟练掌握这些新语法，可显著提升项目性能与可维护性。</p>
<p>若想了解Angular新特性底层原理，请参考掘金文章 <a href="https://juejin.cn/post/7339686366311792676?searchId=202512182210541AE2D44ED7587BA97846" target="_blank" title="https://juejin.cn/post/7339686366311792676?searchId=202512182210541AE2D44ED7587BA97846">juejin.cn/post/733968…</a></p>
<h2 data-id="heading-62">五、 加入我们</h2>
<p>MateChat 正在快速发展，我们欢迎更多开发者加入：</p>
<ul>
<li>💬 DevUI微信小助手：devui-official（添加时请备注MateChat）</li>
<li>🌟 代码仓库地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FDevCloudFE%2FMateChat%2Freleases%3FpresetConfig%3D%257B%2522tags%2522%3A12%2C%2522release%2522%3A11%257D" target="_blank" title="https://gitcode.com/DevCloudFE/MateChat/releases?presetConfig=%7B%22tags%22:12,%22release%22:11%7D" ref="nofollow noopener noreferrer">gitcode.com/DevCloudFE/…</a></li>
</ul>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/21f25f459a984f3f864807f5ced93d6c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGV2VUnlm6LpmJ8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768361394&amp;x-signature=aT1%2BDnE16Qu6ls5YBQcHVkx%2FdRc%3D" height="150px" loading="lazy"/> 
<blockquote>
<p>广纳贤士：AI赋能各行各业，MateChat期待更多感兴趣的小伙伴加入我们~</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FDevCloudFE%2FMateChat%2Fissues" target="_blank" title="https://gitcode.com/DevCloudFE/MateChat/issues" ref="nofollow noopener noreferrer">欢迎大家前来提交Issue，认领Issue；</a></li>
</ul>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[分布式边缘推理正在改变一切]]></title>    <link>https://juejin.cn/post/7592432859862794274</link>    <guid>https://juejin.cn/post/7592432859862794274</guid>    <pubDate>2026-01-07T12:50:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592432859862794274" data-draft-id="7592432859862777890" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="分布式边缘推理正在改变一切"/> <meta itemprop="keywords" content="分布式,人工智能,云计算"/> <meta itemprop="datePublished" content="2026-01-07T12:50:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AKAMAI"/> <meta itemprop="url" content="https://juejin.cn/user/829502942352628"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            分布式边缘推理正在改变一切
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/829502942352628/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AKAMAI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T12:50:41.000Z" title="Wed Jan 07 2026 12:50:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我们正见证着AI的第三次巨大规模化浪潮，这要求我们对关键基础设施进行根本性的重新思考。当业界仍痴迷于构建越来越大的前沿模型的竞赛，企业初步努力寻找杀手级应用和投资回报时，企业AI价值创造的真实战场已经转向了边缘。</p>
<hr/>
<p>如您所在的企业也在考虑采购云服务或进行云迁移，</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.akamai.com%2Fzh%2Flp%2Fakamai-cloud-computing-freetrial%3Futm_campaign%3Df-mc-65893%26utm_id%3Dapj_cc%26utm_source%3Djuejin%26utm_medium%3Darticle_advertorial%26utm_content%3Djuejin_260107_blogarticles240" target="_blank" title="https://www.akamai.com/zh/lp/akamai-cloud-computing-freetrial?utm_campaign=f-mc-65893&amp;utm_id=apj_cc&amp;utm_source=juejin&amp;utm_medium=article_advertorial&amp;utm_content=juejin_260107_blogarticles240" ref="nofollow noopener noreferrer">点击链接</a>了解Akamai Linode解决方案，现在申请试用可得高达5000美元专属额度</p>
<hr/>
<h4 data-id="heading-0"><strong><strong>AI规模化浪潮的演进</strong></strong></h4>
<p>为何称之为“浪潮”？因为浪潮是一种积聚力量、达到顶峰并重塑地貌的力量——其势头、必然性和连锁效应将触发下一波浪潮。这三股浪潮是不可阻挡的力量，正在重塑整个行业，它们包括：</p>
<ul>
<li>第一波浪潮：大规模预训练</li>
<li>第二波浪潮：后训练与精调</li>
<li>第三波浪潮：多步推理与思考</li>
</ul>
<p>让我来阐述为什么这一决策对当下每一位正在规划AI基础设施的企业领导者都至关重要。</p>
<p><strong><strong>第一波浪潮</strong></strong></p>
<p>第一波浪潮——大规模预训练，为我们带来了GPT-4、Claude以及让企业认识到AI变革潜力的前沿模型。这些模型成为了我们的生产力副驾驶、头脑风暴伙伴，也让我们首次窥见通用人工智能的可能性。</p>
<p>然而，它们也伴随着一些附带条件：天文数字般的计算成本、全球用户面临的高延迟，以及集中式处理的固有局限。</p>
<p>作为行业一员，我们过去一直忽略这种延迟，因为流式生成令牌是一种新鲜的交互方式——看啊，AI正在思考呢。</p>
<p><strong><strong>第二波浪潮</strong></strong></p>
<p>第二波浪潮——后训练与精调，让AI更贴近商业现实。企业学会了使用专有数据和机构知识，将基础模型适配到其特定领域。</p>
<p>这波浪潮带来了首批真正的投资回报故事：真正理解上下文的客户服务自动化、遵循公司规范的代码生成，以及与现有应用浑然一体的对话式界面。</p>
<p>然而，即便是这些专用模型，仍然与集中式云服务绑定在一起。随着使用场景的发展，这种集中式将为实时、对延迟敏感的场景（例如需要毫秒级而非秒级或分钟级响应的个性化推荐、自动驾驶汽车与制造、物理AI与机器人技术）造成瓶颈。</p>
<p><strong><strong>分布式能力的缺失尚未成为瓶颈，只是因为真正需要它的场景……尚未大规模普及。</strong></strong></p>
<p><strong><strong>第三波浪潮</strong></strong></p>
<p>现在，我们正在进入第三波浪潮。这要求模型能够对复杂工作流进行推理思考，在长时间交互中保持上下文连贯，并在全球范围内实时交付响应。</p>
<p>这不仅关乎让模型变得更大——更关乎让它们更努力地工作、更长久地思考，并在用户所在的任何地方运行。要让AI在大规模应用中真正有用，它必须快速、安全、准确且引人入胜。</p>
<p><strong><strong>分布式推理将使我们能够在边缘汇聚这些关键要素，并将彻底改变我们参与业务、实现盈利和促进增长的方式。</strong></strong></p>
<h4 data-id="heading-1"><strong><strong>尚无人提及的基础设施挑战</strong></strong></h4>
<p>以下是大多数基础设施提供商不会告诉你的：对于大规模的实时场景，集中式AI推理的经济模型会灾难性地崩塌。当每一次推理请求都需要往返于遥远的数据中心时，你面临的不仅是延迟，更是由带宽、排队延迟和距离的纯粹物理特性带来的叠加成本。</p>
<p>试想，当一个AI智能体执行多步推理时会发生什么。每一步都可能需要多次模型调用、向量数据库查询和API集成。在集中式架构下，每个环节的延迟可能高达数百毫秒，这些细小的滞后在实际应用中层层累积，最终导致响应时间超出可接受范围。</p>
<p>现在，想象一下这样的场景：将其乘以成千上万遍布不同地区的并发用户——你就不难理解，为什么依赖超大规模云厂商的集中式方案会行不通了。</p>
<h4 data-id="heading-2"><strong><strong>Akamai推理云：为实时分布式AI而生</strong></strong></h4>
<p>这正是我们构建<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.akamai.com%2Fzh%2Fproducts%2Fakamai-inference-cloud-platform%3Futm_campaign%3Df-mc-65893%26utm_id%3Dapj_cc%26utm_source%3Djuejin%26utm_medium%3Darticle_advertorial%26utm_content%3Djuejing_260107_external1_blogarticles240" target="_blank" title="https://www.akamai.com/zh/products/akamai-inference-cloud-platform?utm_campaign=f-mc-65893&amp;utm_id=apj_cc&amp;utm_source=juejin&amp;utm_medium=article_advertorial&amp;utm_content=juejing_260107_external1_blogarticles240" ref="nofollow noopener noreferrer">Akamai推理云</a>的原因。我们并非试图与超大规模厂商竞争，看谁能在某个小区域建造最大的集群。我们是在解决企业面临的实际问题：如何在行星级规模上，交付具备本地化性能的AI推理。</p>
<p>我们的方法利用了只有Akamai才能提供的三大关键优势：</p>
<ol>
<li>边缘基础设施</li>
<li>平台原生的AI运维</li>
<li>理解AI的安全体系</li>
</ol>
<p><strong><strong>边缘基础设施</strong></strong></p>
<p>我们正在将NVIDIA Blackwell RTX PRO 6000服务器版GPU部署到我们的全球网络中——不是集中在少数几个巨型数据中心，而是<strong><strong>分布在你的用户实际所在的位置</strong></strong>。这并非试验性质，而是生产就绪的基础设施，构建在已经承载约30%网络流量的同一网络上。</p>
<p><strong><strong>平台原生的AI运维</strong></strong></p>
<p>通过在我们Linode Kubernetes Engine (LKE)上运行的NVIDIA推理微服务 (NIM)，我们让AI工作负载的部署、扩展和管理变得简单。你的团队可以获得用于实现检索增强生成 (RAG) 的集成向量数据库、用于存储模型制品的对象存储，以及能够自动将推理请求路由至最佳位置的全局负载均衡。</p>
<p>这不是生硬拼接的AI——而是AI原生的平台设计。</p>
<p><strong><strong>理解AI的安全体系</strong></strong></p>
<p>这尤其有趣的地方。传统安全体系并非为AI工作负载而建。我们开发了横跨各层的针对性保护措施，包括：</p>
<ul>
<li><strong><strong>应用安全</strong></strong>：主动发现经AI增强的应用与API，持续监测其安全态势，并部署智能防护策略。</li>
<li><strong><strong>AI防火墙能力</strong></strong>：专门设计用于保护提示词免受注入攻击，保护模型免受提取尝试。</li>
<li><strong><strong>工作负载安全</strong></strong>：利用AI自身分析东西向流量模式，自动生成最优分段策略，并持续适应新出现的威胁。</li>
<li><strong><strong>访问安全</strong></strong>：通过我们的安全企业浏览器控制员工与LLM界面的交互并防止数据外泄，同时结合<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.akamai.com%2Fzh%2Fglossary%2Fwhat-is-ztna%3Futm_campaign%3Df-mc-65893%26utm_id%3Dapj_cc%26utm_source%3Djuejin%26utm_medium%3Darticle_advertorial%26utm_content%3Djuejing_260107_external2_blogarticles240" target="_blank" title="https://www.akamai.com/zh/glossary/what-is-ztna?utm_campaign=f-mc-65893&amp;utm_id=apj_cc&amp;utm_source=juejin&amp;utm_medium=article_advertorial&amp;utm_content=juejing_260107_external2_blogarticles240" ref="nofollow noopener noreferrer">零信任网络访问</a>和<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.akamai.com%2Fzh%2Fglossary%2Fwhat-is-multifactor-authentication%3Futm_campaign%3Df-mc-65893%26utm_id%3Dapj_cc%26utm_source%3Djuejin%26utm_medium%3Darticle_advertorial%26utm_content%3Djuejing_260107_external3_blogarticles240" target="_blank" title="https://www.akamai.com/zh/glossary/what-is-multifactor-authentication?utm_campaign=f-mc-65893&amp;utm_id=apj_cc&amp;utm_source=juejin&amp;utm_medium=article_advertorial&amp;utm_content=juejing_260107_external3_blogarticles240" ref="nofollow noopener noreferrer">多重身份验证</a>来保护基础设施访问。</li>
<li><strong><strong>基础设施安全</strong></strong>：提供实时的DNS和网络状况评估，并给出AI驱动的策略建议。</li>
<li><strong><strong>生成式SIEM界面</strong></strong>：使安全运营中心团队能够通过对话方式访问海量遥测数据，从而变革安全运营。</li>
</ul>
<p>当推理从集中式云端移至边缘时，延迟显著降低（让实时AI交互真正做到即时响应），带宽成本得到节约（数据就地处理，无需长途传输），合规性也更易于掌控（可确保数据处理严格限定于指定地域）。更重要的是，通过构建真正分布式的冗余架构，系统可靠性大幅提升——这不仅依赖单一区域内的多可用区部署，更得益于广泛分布的处理能力。</p>
<p>但真正的变革发生在应用层面。以往难以实现的场景突然变得触手可及，需要复杂协调的多智能体工作流如今可以轻松部署，大规模实时个性化服务也具备了经济上的可行性。</p>
<h4 data-id="heading-3"><strong><strong>这对你的AI战略意味着什么</strong></strong></h4>
<p>如果你依然将AI基础设施仅仅理解为训练集群和模型托管，那么你解决的只是昨天的问题。在这场第三波浪潮中胜出的企业，会是那些意识到推理（而非训练）正成为关键瓶颈，并将分布式边缘基础设施视作破局之道的先行者。</p>
<p>问题不在于你是否需要分布式推理基础设施，而在于你选择如何获取它：是自己投入构建（祝你好运）、等待超大规模云厂商最终跟进（而你的竞争对手已抢占先机），还是直接采用已经实现行星级规模化运行的成熟平台。</p>
<p>在Akamai，我们用25年时间深耕分布式计算、安全与全球规模化技术。Akamai推理云，正是互联网基础设施面向AI时代的自然演进。</p>
<p>AI的第三波浪潮已至。支撑它的基础设施也已就位。唯一的问题是：你，准备好乘风破浪了吗？</p>
<p><strong><strong>了解更多</strong></strong></p>
<p>要了解更多关于Akamai推理云如何改变你的AI基础设施战略，请访问我们的网站或在LinkedIn上与我联系。</p>
<hr/>
<p>如您所在的企业也在考虑采购云服务或进行云迁移，</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.akamai.com%2Fzh%2Flp%2Fakamai-cloud-computing-freetrial%3Futm_campaign%3Df-mc-65893%26utm_id%3Dapj_cc%26utm_source%3Djuejin%26utm_medium%3Darticle_advertorial%26utm_content%3Djuejin_260107_blogarticles240_end" target="_blank" title="https://www.akamai.com/zh/lp/akamai-cloud-computing-freetrial?utm_campaign=f-mc-65893&amp;utm_id=apj_cc&amp;utm_source=juejin&amp;utm_medium=article_advertorial&amp;utm_content=juejin_260107_blogarticles240_end" ref="nofollow noopener noreferrer">点击链接</a>了解Akamai Linode解决方案，现在申请试用可得高达5000美元专属额度</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2026 年程序员自救指南]]></title>    <link>https://juejin.cn/post/7592432859862810658</link>    <guid>https://juejin.cn/post/7592432859862810658</guid>    <pubDate>2026-01-07T12:53:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592432859862810658" data-draft-id="7592410399917047849" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2026 年程序员自救指南"/> <meta itemprop="keywords" content="程序员,人工智能,掘金技术征文"/> <meta itemprop="datePublished" content="2026-01-07T12:53:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="何贤"/> <meta itemprop="url" content="https://juejin.cn/user/277499952247869"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2026 年程序员自救指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/277499952247869/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    何贤
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T12:53:12.000Z" title="Wed Jan 07 2026 12:53:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">2026 年程序员自救指南</h2>
<h3 data-id="heading-1">引言：谁在抽谁的鞭子？</h3>
<p>所有与 AI 共事的开发者都害怕遇到这样的情形：同样的模型，同样的时间，同样的项目，甚至同样复杂度的问题，不同用户却得到截然不同的结果。有人得到伴随着幻觉的差强人意的答案，有人却收获超出预期的产出。</p>
<p>Hacker News 上曾有一篇高赞帖子提到：<strong>"<a href="https://link.juejin.cn?target=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D44747634" target="_blank" title="https://news.ycombinator.com/item?id=44747634" ref="nofollow noopener noreferrer">AI is a floor raiser, not a ceiling raiser.</a>"</strong>（AI 提升的是底线，而不是天花板。）这意味着随着大模型能力的提升，即使在不健全的上下文或模糊的提问下，AI 也能提供越来越好的产出。</p>
<p><strong>但这是一把双刃剑——不同使用水平的用户在使用同一模型时，产出结果的差距会随着模型水平的提升而越来越大。</strong></p>
<p>我时常跟我同事打趣的说</p>
<blockquote>
<p>与其说是我拿着鞭子去抽 AI，
不如说是 AI 拿着鞭子在抽我——
逼着我学会如何更清晰、更高质量地提供信息。</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79aba2cd1e524effb971b0e013742df9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768395192&amp;x-signature=G9hYFlm8ppXezoIHEDilEvwXB4I%3D" alt="02.png" loading="lazy"/></p>
<p>在下半年我用的比较常见的提示词只有两个，一个是<code>给我用中文解释！！</code>，另外就是就是以下这一段：</p>
<blockquote>
<p>查看本次 / 上次 / 历史会话中
我的思路、决策、判断、输入方式
有哪些亮点？有哪些可以改进和优化？</p>
</blockquote>
<p>这背后反映的并不是“玄学调参”，而是一个现实：<strong>AI 受限于你赋予它的Context(背景|上下文)。</strong></p>
<h3 data-id="heading-2">AI-native 时代：我们必须适应的现实</h3>
<p>说起来前段时间我了解到一个很有趣的词，叫<code>AI-native</code>,他的对应面是<code>Human-native</code>。</p>
<p>作为程序员，我更像是在通过代码与 AI 协作——就像两个人共同操控一台机器。
在 <strong>AI-native</strong> 的协作模式中，AI 是主控执行者，而人的角色并非直接操作系统，而是为 AI 提供完备的信息、清晰的问题边界与可推理的上下文。整个过程的核心成本，在于人是否能够将真实但混乱的问题，整理成 AI 可接受、可计算的表达形式，本质上是<strong>人去适应 AI 的认知与归纳方式</strong>。</p>
<p>相对地，<strong>Human-native</strong> 系统则反其道而行之：它们原生支持人的倾诉式表达，通过自然语言理解、需求挖掘与语义推断，将模糊的“大白话”逐步转化为有效产出。其目标并不是要求人学会如何精确表达问题，而是让系统具备足够的能力，去理解低质量输入背后的真实需求，从而使<strong>即使是经验较少的操作者，也能获得高质量的结果</strong>。</p>
<p><strong>现阶段仍处于各大模型厂商的军备竞赛中，<a href="https://link.juejin.cn?target=https%3A%2F%2Fartificialanalysis.ai%2Fleaderboards%2Fmodels" target="_blank" title="https://artificialanalysis.ai/leaderboards/models" ref="nofollow noopener noreferrer">LLM Leaderboard</a> 的排名风水轮流转。在这种背景下，现在大多数成功的产品，本质上都还是 <code>AI-native</code> 的</strong> 。相信以下的梗图大家应该都经常看到过。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ac380062750340b1b00c012252c83fe4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768395192&amp;x-signature=hAvdBgiDYqYm3G3TauhkgDln%2BpE%3D" alt="01.png" loading="lazy"/>
也许未来会出现更多 <strong>Human-native</strong> 产品，它们能够接受人们的倾诉，通过大白话发掘和确定需求，并转换为有效产出。</p>
<p>但对于奋斗在一线的开发者和 vibe coding 实践者来说，我们等不到那个时候——<strong>我们需要在当下养活自己</strong>。</p>
<p>那个 Human-native 的时代也许我们等不到，甚至某一天到来时我们已无法适应。但在此之前，我们需要进化出配合 <code>AI-native</code>产品所需的能力。（有时候真的很羡慕那些不以<code>code</code>为生的职业）</p>
<h3 data-id="heading-3">幻觉的本质：向量的“平权”陷阱</h3>
<p>为什么同一个模型，有时候是神，有时候是人工智障？</p>
<p>答案通常在于 <strong>Context 的缺失</strong>。</p>
<p>以我们常用的 Cursor 为例，它的<a href="https://link.juejin.cn?target=https%3A%2F%2Fcursor.com%2Fcn%2Fdocs%2Fcontext%2Fcodebase-indexing" target="_blank" title="https://cursor.com/cn/docs/context/codebase-indexing" ref="nofollow noopener noreferrer">索引机制 (Codebase Indexing)</a> 这里简单抽象为 3 步：</p>
<ol>
<li><strong>分片 (Chunking):</strong> 把你的代码拆成函数、类、逻辑块。</li>
<li><strong>向量化 (Embedding):</strong> 用模型生成语义“指纹”。</li>
<li><strong>存储与检索:</strong> 当你提问时，它去向量数据库里捞取“长得最像”的代码片段。</li>
</ol>
<p>问题就出在这里：<strong>在向量数据库的视角里，代码没有"层级"，只有"相似度"，所有的代码片段在架构层级上是“平权”的。无论是核心架构设计，还是边缘的工具函数，在Cursor 眼里只是距离长短不同的向量而已。建立完索引库后，Cursor 对所有模块一视同仁</strong></p>
<p>在不提供特殊信息的情况下，隐藏的上下文太多，Agent 面对问题容易陷入幻觉。我们经常需要不断迭代——<code>@files</code> 或 <code>@某个特定的代码片段</code>——直到 AI 明白我们的意图。对于刚接手大型项目的新人，这样的过程可能重复 3-5 次甚至更多。</p>
<p>更有趣的是"向量权重"现象：在 AI 合作的过程中，它会利用嵌入模型不断增加某一模块的向量权重。这会让你在频繁操作某模块时有"越用越顺"的感觉，但突然篡改一个已有模块时，却感知它"降智"了。这都可归纳为 <strong>Context 缺失产生幻觉的结果</strong>。</p>
<h3 data-id="heading-4">真正的差距，不在工具，而在你脑中的那张图</h3>
<p>这是一张各家旗舰模型的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fartificialanalysis.ai%2Fleaderboards%2Fmodels" target="_blank" title="https://artificialanalysis.ai/leaderboards/models" ref="nofollow noopener noreferrer">LLM Leaderboard</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5cbfaa91429c43dd8626f6b2333dd348~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768395192&amp;x-signature=MG5zElv6v4yljSWzHrd9r03zUuE%3D" alt="04.png" loading="lazy"/></p>
<p>可能有人会说，我是用的是 XXX 模型，他就是不如 XXX。但实际上各家旗舰模型在各个测试环节并没有被拉开太大的差距</p>
<p>AI 对每个人的提升效果非常割裂：</p>
<p>有人觉得 AI 只能加快一点 coding 速度，而面对复杂项目时的代码产出则是：一杯茶、一包烟，一段代码 agent 跑一天。</p>
<p>而有的人已经在考虑将大众提交的 feedback（issue、feature request）经过审核和规范输入后，一键转发到 Claude Code 去做自动化实现——构建一种可以被命名为「许愿式开发」的工作流。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/883f8231f3bd49d1a52d23508e5cbcb7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768395192&amp;x-signature=BRx3sgnltlb%2Bupc1pp%2Ba4dEhhKQ%3D" alt="03.png" loading="lazy"/></p>
<p>但这并不代表前者不够优秀。我遇到过很多优秀的程序员，他们对自己构建和维护的项目有一份存在大脑中的 <strong>HIGH LEVEL VIEW</strong>（知道哪些模块负责哪些功能、承担哪些责任、存在哪些隐秘雷点）。但他们难以将这份内容在文档中构建并阐述给模型。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b793cc2d79404ff58b4fc7d9ae3a45bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768395192&amp;x-signature=Wv3Y1yQTfLP9KPdYtdZHH8%2FPj%2BI%3D" alt="05.png" loading="lazy"/></p>
<p>更糟的是，仅仅通过类似对 AI 提问："帮我总结出这个项目结构并输出 md 文档"，有时反而会加重模型的幻觉——这些对 AI 来说莫名其妙的文档最终成为噪声，干扰着解决问题的进度。</p>
<p>这就是为什么在维护代码时，<strong>将脑中的<code>HIGH LEVEL VIEW</code>转换为一份清晰的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.intent-systems.com%2Flearn%2Fintent-layer" target="_blank" title="https://www.intent-systems.com/learn/intent-layer" ref="nofollow noopener noreferrer">Intent Layer</a> 至关重要</strong>。（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.intent-systems.com%2Flearn%2Fintent-layer" target="_blank" title="https://www.intent-systems.com/learn/intent-layer" ref="nofollow noopener noreferrer">Intent Layer</a> 是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.intent-systems.com%2Flearn" target="_blank" title="https://www.intent-systems.com/learn" ref="nofollow noopener noreferrer">Intent-system</a>提出的概念，帮助解决程序员如何将脑内图景转换为可被 AI 接受的信息，我就不做搬运工了，感觉把别人文章翻译一下粘过来怪怪的)。这里给大家推荐两个地址</p>
<ul>
<li>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.intent-systems.com%2Flearn%2Fintent-layer" target="_blank" title="https://www.intent-systems.com/learn/intent-layer" ref="nofollow noopener noreferrer">The Intent Layer</a>:<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.intent-systems.com%2Flearn%2Fintent-layer" target="_blank" title="https://www.intent-systems.com/learn/intent-layer" ref="nofollow noopener noreferrer">www.intent-systems.com/learn/inten…</a></p>
</li>
<li>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgithub%2Fspec-kit%2Fblob%2Fmain%2Fspec-driven.md%23the-nine-articles-of-development" target="_blank" title="https://github.com/github/spec-kit/blob/main/spec-driven.md#the-nine-articles-of-development" ref="nofollow noopener noreferrer">规范驱动开发（SDD）</a>:<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgithub%2Fspec-kit%2Fblob%2Fmain%2Fspec-driven.md%23the-nine-articles-of-development" target="_blank" title="https://github.com/github/spec-kit/blob/main/spec-driven.md#the-nine-articles-of-development" ref="nofollow noopener noreferrer">github.com/github/spec…</a></p>
</li>
</ul>
<h3 data-id="heading-5">不再卷框架，而是去读“说明书”</h3>
<p>回想 2023 年之前，作为一个合格的前端或全栈工程师，我们的学习精力分配大致是这样的：</p>
<ul>
<li><strong>40%</strong>：研究框架的新特性
（React Hooks、Vue Composition API、Server Components）</li>
<li><strong>40%</strong>：各种生态与工具链
（状态管理、路由、构建工具）</li>
<li><strong>20%</strong>：业务逻辑与算法</li>
</ul>
<p>这一套逻辑在当时是完全成立的——<strong>个人对框架源码的掌控度 ≈ 个人生产力上限</strong>。</p>
<h4 data-id="heading-6">现在的游戏规则变了</h4>
<p>现在的 AI 模型（例如 Claude  Opus 4.5、GPT 5.2）,在配合 <code>Context7</code> MCP Server 对主流框架和 API 的熟悉程度，已经远远超过绝大多数开发者。
当我想让它写一个「带 Virtual Scroll 的 Vue 3 表格组件」，它不仅写得比我快，很多时候还更规范。</p>
<p>于是，真正的分水岭出现了：</p>
<blockquote>
<p><strong>个人的竞争力，不再是他记得多少 API，
而是这个人能否让他的 IDE 发挥出上限。</strong></p>
</blockquote>
<p>而这件事，远不只是“会不会写提示词”。</p>
<h4 data-id="heading-7">理解手中的工具</h4>
<p>当我们开始依赖 Claude、Cursor、Trae 这类工具时，本质上已经进入了一个新的抽象层：</p>
<blockquote>
<p><strong>你不再是直接写代码的人，而是在配置一个“智能体运行环境”。</strong></p>
</blockquote>
<p>这时再去无休止地追逐新框架，性价比已经极低。
那部分精力，更值得投入到比如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.claude.com%2Fdocs%2Fen%2Fskills" target="_blank" title="https://code.claude.com/docs/en/skills" ref="nofollow noopener noreferrer"><strong>Claude Docs</strong></a>、<strong><a href="https://www.trae.ai/blog/trae_tutorial_0825" target="_blank" title="https://www.trae.ai/blog/trae_tutorial_0825" ref="nofollow noopener noreferrer">Trae Blog</a></strong>、各类 Agent / <a href="https://link.juejin.cn?target=https%3A%2F%2Fagentskills.io%2Fhome" target="_blank" title="https://agentskills.io/home" ref="nofollow noopener noreferrer">Skill</a> / Subagent 的设计说明。</p>
<p>这件事本身其实并不陌生。</p>
<p>以前我们写 JavaScript，本质上是：
JS → 编译 → C / LLVM → 浏览器执行</p>
<p>现在只是换了一条链路：
<strong>自然语言 → IDE Agent → 代码 → 编译 → 执行</strong></p>
<p>中间多出来的，是一个你必须理解的“黑箱”。</p>
<p><strong>Claude 的 Subagent 与 Skill</strong></p>
<p>以 Claude 为例：
虽然我个人并不认同 Anthropic 对国区的态度，也不喜欢他们的行事风格，但不得不承认：<strong>他们在生态设计上提出了一些非常超前、且极具通用性的概念。</strong></p>
<p>其中最关键的两个是：</p>
<ul>
<li><strong>Subagent</strong>：用于隔离上下文</li>
<li><strong>Skill</strong>：通过逐步披露，节省并保护上下文</li>
</ul>
<p><code>Subagent</code>以极为有效的方式隔离上下文，而 <code>Skill</code>依靠逐步披露的方式进一步简单粗暴的保护 &amp; 节省上下文。</p>
<p>在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.claude.com%2Fdocs%2Fen%2Fskills" target="_blank" title="https://code.claude.com/docs/en/skills" ref="nofollow noopener noreferrer">Claude docs</a> 文档中明确表示，最初 <code>Skill</code> 仅仅展示给 <code>Claude</code> 的内容只有如:</p>
<pre><code class="hljs language-bash" lang="bash">---
name: code-reviewer
description: Review code <span class="hljs-keyword">for</span> quality and best practices
skills: pr-review, security-check
---
</code></pre>
<p>这意味着什么？</p>
<ul>
<li>Context 并不是一次性灌给模型的</li>
<li>能力是按需、逐步“解锁”的</li>
<li>单个 Subagent 可以在特定场景下，被临时“放大”为一种近似 <strong>MoE（Mixture of Experts）</strong> 的行为模式</li>
</ul>
<p>我非常确信：
这种机制在不久的将来，会引发大量开发者参与，形成一个类似早期 MCP Server 的 Skill 生态，甚至与 MCP 联动。</p>
<p>而且几乎可以确定——
<strong>Cursor、Trae 很快都会出现类似的设计。</strong></p>
<p><strong>它们解决的，其实是同一个问题</strong></p>
<p>无论是 Subagent、Skill，还是 MCP，本质上都在做一件事：</p>
<blockquote>
<p><strong>帮助我们更高效地，把 High-Level View
映射到可执行的 Intent Layer。</strong></p>
</blockquote>
<p><strong>2026年的自救，本质上是一场职能跃迁： 我们必须从“代码工人”转型为“配置智能体运行环境的架构师”。</strong></p>
<h3 data-id="heading-8">写在最后</h3>
<p>本文并不是在希望之后每个人都是 24 小时盯着各家模型厂商的文档更新过日子。</p>
<p>但至少，值得问自己一个问题：</p>
<blockquote>
<p><strong>我是真的理解“现在正在发生什么”， 还是只是在短视频里听过一个模糊的概念？</strong></p>
</blockquote>
<p>很多时候，<strong>没有什么比那些正在维护、正在研发这些系统的人亲自写下的文档，更能准确描述当下的现实。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Gson 很好，但在Kotlin上有更合适的序列化工具「Kotlin Serialization」]]></title>    <link>https://juejin.cn/post/7592451049233104942</link>    <guid>https://juejin.cn/post/7592451049233104942</guid>    <pubDate>2026-01-07T11:08:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592451049233104942" data-draft-id="7574322843049230386" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Gson 很好，但在Kotlin上有更合适的序列化工具「Kotlin Serialization」"/> <meta itemprop="keywords" content="Android,Gson,Kotlin"/> <meta itemprop="datePublished" content="2026-01-07T11:08:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="PuddingSama"/> <meta itemprop="url" content="https://juejin.cn/user/4152181101706967"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Gson 很好，但在Kotlin上有更合适的序列化工具「Kotlin Serialization」
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4152181101706967/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    PuddingSama
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T11:08:17.000Z" title="Wed Jan 07 2026 11:08:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我们来看看 Gson 的官方介绍：</p>
<p>Gson是一个Java库，可用于将Java对象转换为其JSON表示形式。它还可以用于将JSON字符串转换为等效的Java对象。Gson能够处理任意Java对象，包括那些你没有源代码的现有对象。</p>
<p><strong>Gson 的主要关注点是 Java。在很多情况下，将其与 Kotlin 或 Scala 等其他 JVM 语言一起使用可能效果很好，但不支持特定于语言的特性，例如 Kotlin 的非<code>null</code>类型或带有默认参数的构造函数。这可能会导致令人困惑的错误行为。</strong></p>
<p><strong>使用 Java 以外的语言时，优先选择对该语言有明确支持的 JSON 库。</strong></p>
<p><strong>如果您的应用程序或库可能在Android上运行，请考虑使用 Kotlin序列化或Moshi的代码生成器</strong>，它们使用代码生成而非反射。这样可以避免Gson在应用优化时（通常是由于字段缺失或被混淆）出现运行时崩溃，并能在Android设备上带来更快的性能。对于已经熟悉Gson的用户来说，Moshi的API可能更容易上手。如果您仍然想使用Gson并尝试避免这些崩溃，可以在此处了解具体方法。</p>
<p>以上是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgoogle%2Fgson" target="_blank" title="https://github.com/google/gson" ref="nofollow noopener noreferrer">Gson</a>官方介绍，上面直接告知用户在 Android 开发 Kotlin 时代不推荐使用 Gson 而应该使用 Kotlin Serialization。但是我估计相当一大部分 Android 开发者并没有看到过这些描述。为什么？因为 Gson 诞生于 Android Java 语言时代，Kotlin 与 Java 兼容，所以在转移到Kotlin语言开发时，旧时代的优秀工具被继承了下来，并且在多数时候使用，并不会有任何问题，所有 Gson 依旧活跃在 Kotlin 时代的 Andorid 开发中。</p>
<p>那么 Gson 在 Kotlin 上有什么问题呢？我们来看一个例子：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> name: String = <span class="hljs-string">""</span>, <span class="hljs-keyword">val</span> age: String = <span class="hljs-string">""</span>)
</code></pre>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span> <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Tom"</span> <span class="hljs-punctuation">}</span>
</code></pre>
<p>Student类有两个非空字段 <code>val name: String, val age: String</code>, Json 只有一个 <code>name</code> 字段。我们期望如果Json string 没有某个字段则应该使用 Student类字段的默认值，很朴素的期望，对吧？</p>
<p>但实际当你用 Gson 反序列化之后，你会得到一个 <code>name=="Tom" age==null</code> 的 Student 对象，<strong>空安全不再安全，同时默认值也一起失效</strong>。</p>
<h2 data-id="heading-0">那么问题来了，这是为什么呢？</h2>
<p>Gson创建因对象类型的不同，分为4种情况：</p>
<ul>
<li>
<p>基础类型、以及基础类型的包装类型等由Gson提供的TypeAdapter通过 new 关键字创建</p>
</li>
<li>
<p>枚举类型在EnumTypeAdapter中只是通过枚举名称切换不同的枚举常量，不涉及对象的创建</p>
</li>
<li>
<p>集合和map等容器类型通过Gson内置的对象创建工厂，调用 new 关键字进行创建</p>
</li>
<li>
<p>Java Bean对象的创建比较复杂，分为3种情况，优先级由上到下依次降低:</p>
<ul>
<li>开发者定义了对象创建工厂<code>InstanceCreator</code>，则使用该工厂创建；</li>
<li>存在默认的无参构造函数，通过反射构造函数创建；</li>
<li>使用<code>Unsafe API</code> 创建。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-java" lang="java">#ConstructorConstructor.java
<span class="hljs-keyword">public</span> &lt;T&gt; ObjectConstructor&lt;T&gt; <span class="hljs-title function_">get</span><span class="hljs-params">(TypeToken&lt;T&gt; typeToken)</span> {
	<span class="hljs-comment">// 1.获取TypeToken对应的类型(Type)和原始类型(Class&lt;? super T&gt;）</span>
	<span class="hljs-keyword">final</span> <span class="hljs-type">Type</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> typeToken.getType();
	Class&lt;? <span class="hljs-built_in">super</span> T&gt; rawType = typeToken.getRawType();
	<span class="hljs-comment">// 2.从instanceCreators中根据类型(Type)获取对应的实例创建器(InstanceCreator)</span>
	<span class="hljs-comment">//   如果存在，则创建并返回一个新的对象构造器，该构造器使用该实例创建器来创建对象</span>
	<span class="hljs-keyword">final</span> InstanceCreator&lt;T&gt; typeCreator = (InstanceCreator)<span class="hljs-built_in">this</span>.instanceCreators.get(type);
	<span class="hljs-keyword">if</span> (typeCreator != <span class="hljs-literal">null</span>) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectConstructor</span>&lt;T&gt;() {
			<span class="hljs-keyword">public</span> T <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> {
				<span class="hljs-keyword">return</span> typeCreator.createInstance(type);
			}
		};
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-comment">// 3.如果步骤2中没有获取到实例创建器，则尝试根据原始类型(rawType)从instanceCreators中获取实例创建器</span>
		<span class="hljs-comment">// 如果存在，则创建并返回一个新的对象构造器，该构造器使用该实例创建器来创建对象。</span>
		<span class="hljs-keyword">final</span> InstanceCreator&lt;T&gt; rawTypeCreator = (InstanceCreator)<span class="hljs-built_in">this</span>.instanceCreators.get(rawType);
		<span class="hljs-keyword">if</span> (rawTypeCreator != <span class="hljs-literal">null</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectConstructor</span>&lt;T&gt;() {
				<span class="hljs-keyword">public</span> T <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> {
					<span class="hljs-keyword">return</span> rawTypeCreator.createInstance(type);
				}
			};
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-comment">// 4.如果步骤2和步骤3都没有获取到实例创建器，则尝试调用newDefaultConstructor方法创建一个默认构造器，如果存在，则返回该构造器（无参构造函数）</span>
			ObjectConstructor&lt;T&gt; defaultConstructor = <span class="hljs-built_in">this</span>.newDefaultConstructor(rawType);
			<span class="hljs-keyword">if</span> (defaultConstructor != <span class="hljs-literal">null</span>) {
				<span class="hljs-keyword">return</span> defaultConstructor;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-comment">// 5.如果步骤4中没有创建到默认构造器，则尝试调用newDefaultImplementationConstructor方法创建一个默认实现构造器，如果存在，则返回该构造器（容器类型）</span>
				ObjectConstructor&lt;T&gt; defaultImplementation = <span class="hljs-built_in">this</span>.newDefaultImplementationConstructor(type, rawType);
				<span class="hljs-comment">// 6.如果步骤5中没有创建到默认实现构造器，则尝试调用newUnsafeAllocator方法创建一个不安全的分配器构造器，最后返回该构造器（Unsafe）</span>
				<span class="hljs-keyword">return</span> defaultImplementation != <span class="hljs-literal">null</span> ? defaultImplementation : <span class="hljs-built_in">this</span>.newUnsafeAllocator(type, rawType);
			}
		}
	}
}

</code></pre>
<p>通过上文我们分析可知，当Java类未提供默认的无参构造函数时，Gson会使用 Unsafe API 来创建对象，这种创建对象的方式不会调用构造函数，因此会导致以下几个可能的问题：</p>
<ul>
<li>默认值丢失；</li>
<li>Kotlin 非空类型失效；</li>
<li>初始化块可能不会正常执行</li>
</ul>
<p>具体源码阅读可以参考：<a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">「赏码」更优雅的使用Gson解析</a></p>
<h2 data-id="heading-1">Kotlin Serialization VS Gson</h2>
<p>为了解决此问题，官方推出了 kotlin serialization库，让你的 <code>data class</code>能保持它的特性，不会丢失数据。使用也很简单，只需要加一个注解<code>@Serializable</code></p>
<h3 data-id="heading-2">默认值</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Serializable</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: String = <span class="hljs-string">"10"</span>)

<span class="hljs-keyword">val</span> jsonString = <span class="hljs-string">"""{ "name": "Tom" }"""</span> 
<span class="hljs-keyword">val</span> objByGson = 
    Gson().fromJson(jsonString, Student::<span class="hljs-keyword">class</span>.java) <span class="hljs-comment">// 结果 Student(name=Tom, age=null)</span>
<span class="hljs-keyword">val</span> objByKotlinxSerialization = 
    Json.decodeFromString&lt;Student&gt;(jsonString)<span class="hljs-comment">// 结果 Student(name=Tom, age=10)</span>
</code></pre>
<p>可以看到 kotlinx.serialization 正确的处理了默认值，而Gson忽略了默认值</p>
<h3 data-id="heading-3">空安全</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Serializable</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: String)

<span class="hljs-keyword">val</span> jsonString = <span class="hljs-string">"""{ "name": "Tom" }"""</span> 
<span class="hljs-keyword">val</span> objByGson = 
    Gson().fromJson(jsonString, Student::<span class="hljs-keyword">class</span>.java) <span class="hljs-comment">// 结果 Student(name=Tom, age=null)</span>
<span class="hljs-keyword">val</span> objByKotlinxSerialization = 
    Json.decodeFromString&lt;Student&gt;(jsonString)<span class="hljs-comment">// 结果 抛出异常</span>
</code></pre>
<p>为保证 kotlin 的空安全特性，kotlinx.serialization 在反序列化时，如果某个不可空类型的字段在 json 字符串中缺失则会抛出异常：<code>kotlinx.serialization.MissingFieldException: Field 'age' is required for type with serial name 'Student'</code>,而Gson 则会序列化成功，但是 data class 的不可空类型定义便被突破，这违背了开发者的期望。<strong>这其实是 Gson 在 kotlin 中反序列化遇到最麻烦的问题，在程序运行时，明明定义的类型是不可空，但是为什么会抛出 NullPointerException 呢？</strong></p>
<p>kotlinx.serialization 的这一特性会让我们在声明data class时更加严谨，你需要对字段的可空与否有自己的一番思考 —— 这显然比无脑将字段声明为可空类型要好的多得多。当然，如果你还是担心由此引发的崩溃问题，同时又不想后续的使用上加上一堆?.的可空调用判断，你可以给其赋上默认值：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Serializable</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: String)
</code></pre>
<h3 data-id="heading-4">序列化三方库</h3>
<p>不少同学看到这边就想到一点，如果使用注解，那如何学历噩耗三方库的类呢？是个好问题，这确实是 Kotlinx.serialization 不如 Gson 方便的地方。不过官方也提供了相关支持，相对而言麻烦了点。
以下是AI给出的答案：</p>
<hr/>
<h4 data-id="heading-5">🌰 示例：序列化 <code>java.time.LocalDateTime</code></h4>
<p>由于你不能给第三方类加 <code>@Serializable</code>，必须：</p>
<ol>
<li>
<p><strong>为该类型编写一个 <code>KSerializer&lt;T&gt;</code> 实现</strong></p>
</li>
<li>
<p><strong>在使用处显式指定这个 serializer</strong>（通过 <code>@Serializable(with = YourSerializer::class)</code>）</p>
<ul>
<li>或通过 <code>SerializersModule</code> 全局注册为 <strong>contextual serializer</strong></li>
</ul>
</li>
</ol>
<p>假设你要序列化 JDK8 的 <code>LocalDateTime</code>（你无法修改它）。</p>
<h5 data-id="heading-6">步骤 1：编写 <code>KSerializer</code></h5>
<pre><code class="hljs">Kotlin

</code></pre>
<blockquote>
<p>💡 使用 <code>object</code> 单例，避免重复创建。</p>
</blockquote>
<hr/>
<h5 data-id="heading-7">步骤 2：在你的数据类中使用（显式绑定）</h5>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">object</span> LocalDateTimeSerializer : KSerializer&lt;LocalDateTime&gt; {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> descriptor = PrimitiveSerialDescriptor(<span class="hljs-string">"LocalDateTime"</span>, kotlinx.serialization.descriptors.PrimitiveKind.STRING)

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">serialize</span><span class="hljs-params">(encoder: <span class="hljs-type">Encoder</span>, value: <span class="hljs-type">LocalDateTime</span>)</span></span> {
        encoder.encodeString(value.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME))
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(decoder: <span class="hljs-type">Decoder</span>)</span></span>: LocalDateTime {
        <span class="hljs-keyword">return</span> LocalDateTime.parse(decoder.decodeString(), DateTimeFormatter.ISO_LOCAL_DATE_TIME)
    }
}
</code></pre>
<p>✅ 这样就能正常编解码：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">val</span> event = Event(<span class="hljs-string">"Meeting"</span>, LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">14</span>, <span class="hljs-number">30</span>))
<span class="hljs-keyword">val</span> json = Json.encodeToString(event)
<span class="hljs-comment">// {"title":"Meeting","timestamp":"2025-01-10T14:30"}</span>

<span class="hljs-keyword">val</span> decoded = Json.decodeFromString&lt;Event&gt;(json)
</code></pre>
<hr/>
<h4 data-id="heading-8">🔁 替代方案：全局注册为 Contextual Serializer</h4>
<p>如果你<strong>多处使用 <code>LocalDateTime</code></strong>，不想每个字段都写 <code>@Serializable(with = ...)</code>，可以全局注册：</p>
<h5 data-id="heading-9">步骤 1：创建 <code>SerializersModule</code></h5>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">val</span> appModule = SerializersModule {
    contextual(LocalDateTime::<span class="hljs-keyword">class</span>, LocalDateTimeSerializer)
}
</code></pre>
<h5 data-id="heading-10">步骤 2：构建带 module 的 <code>Json</code> 实例</h5>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">val</span> JsonWithTime = Json {
    serializersModule = appModule
    <span class="hljs-comment">// 可选：ignoreUnknownKeys = true 等</span>
}
</code></pre>
<h5 data-id="heading-11">步骤 3：在数据类中<strong>不要加 <code>with</code></strong>，直接使用类型</h5>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-meta">@Serializable</span>
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span>(
    <span class="hljs-keyword">val</span> title: String,
    <span class="hljs-keyword">val</span> timestamp: LocalDateTime  <span class="hljs-comment">// ✅ 自动使用 contextual serializer</span>
)
</code></pre>
<h5 data-id="heading-12">使用时必须用配置好的 <code>Json</code> 实例：</h5>
<pre><code class="hljs language-ini" lang="ini">Kotlin
编辑
1val <span class="hljs-attr">jsonStr</span> = JsonWithTime.encodeToString(event)
2val <span class="hljs-attr">event2</span> = JsonWithTime.decodeFromString&lt;Event&gt;(jsonStr)
</code></pre>
<blockquote>
<p>⚠️ 注意：如果使用默认的 <code>Json.encodeToString()</code>（无 module），会报错：<br/>
<code>Serializer for class 'LocalDateTime' is not found.</code></p>
</blockquote>
<hr/>
<h2 data-id="heading-13">❗ 重要限制与注意事项</h2>

























<table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td><strong>不能自动发现</strong></td><td><code>kotlinx.serialization</code> <strong>不会自动为未注解的类型生成 serializer</strong>，必须显式提供</td></tr><tr><td><strong>泛型支持需小心</strong></td><td>对于 <code>List&lt;Point&gt;</code>，你需要： <code>ListSerializer(PointSerializer)</code> 或在 module 中注册 <code>Point</code> 后使用 <code>serializer&lt;List&lt;Point&gt;&gt;()</code></td></tr><tr><td><strong>必须用正确的 <code>Json</code> 实例</strong></td><td>如果用了 <code>contextual</code>，务必使用带 <code>serializersModule</code> 的 <code>Json</code> 对象</td></tr><tr><td><strong>不支持运行时反射</strong></td><td>所有序列化逻辑必须在编译期确定，无法像 Gson 那样动态解析任意类</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-14">✅ 最佳实践建议</h2>
<ol>
<li><strong>优先使用 <code>@Serializable(with = ...)</code></strong><br/>
适用于局部、明确的场景，代码清晰。</li>
<li><strong>多处使用 → 用 <code>SerializersModule</code> + <code>contextual</code></strong><br/>
避免重复注解，但要确保所有编解码都走同一个 <code>Json</code> 实例。</li>
<li><strong>为常用类型封装工具</strong><br/>
比如创建 <code>CommonSerializers.kt</code> 集中管理 <code>LocalDateTime</code>、<code>Uri</code>、<code>UUID</code> 等。</li>
<li><strong>避免直接序列化第三方类</strong><br/>
更安全的做法：创建自己的 <code>@Serializable</code> DTO，内部转换第三方类（解耦 + 控制字段）。</li>
</ol>
<h3 data-id="heading-15">其他替代库 Moshi</h3>
<p>Moshi 也是官方推荐的 kotlin 序列化工具库，本文就不详细介绍了，想了解的同学可以访问<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fmoshi" target="_blank" title="https://github.com/square/moshi" ref="nofollow noopener noreferrer">Moshi</a>,其来自于大名鼎鼎的 <strong>Suqare</strong> 开源。</p>
<h2 data-id="heading-16">总结</h2>
<p>工具就是工具，不一定是最完美的，我们需要根据当前项目需求选择合适开发者自己的工具，不是说一定要用哪个。很显然，如果你的项目Gson 已经存在了很久，想现在替换掉也不现实。但如果你在当前的 Kotlin 项目中使用 Gson，你必须要知道当前存在的风险点，并去规避它。如果你需要在新项目中序列化，那么毫不犹豫，Kotlinx.serialization 或者 Moshi 是你更好的选择！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（27）Hibernate的查询策略是什么？]]></title>    <link>https://juejin.cn/post/7592148975848996907</link>    <guid>https://juejin.cn/post/7592148975848996907</guid>    <pubDate>2026-01-07T11:53:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592148975848996907" data-draft-id="7592255257348112425" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（27）Hibernate的查询策略是什么？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-07T11:53:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（27）Hibernate的查询策略是什么？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T11:53:01.000Z" title="Wed Jan 07 2026 11:53:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">Hibernate的查询策略</h3>
<p>Hibernate的查询策略决定了如何从数据库中检索数据。它包括多种策略，如即时加载（Eager Loading）、延迟加载（Lazy Loading）和批量检索（Batch Fetching）等。这些策略可以显著影响应用程序的性能和内存使用，因此了解和选择合适的查询策略非常重要。</p>
<h3 data-id="heading-1">主要查询策略</h3>
<ol>
<li><strong>即时加载（Eager Loading）</strong>：在加载实体时，同时加载其关联的实体。</li>
<li><strong>延迟加载（Lazy Loading）</strong>：只有在访问关联实体时，才加载该实体。</li>
<li><strong>批量检索（Batch Fetching）</strong>：在一次查询中加载多个关联的实体。</li>
</ol>
<h3 data-id="heading-2">配置查询策略的方式</h3>
<ol>
<li><strong>在映射文件或注解中配置</strong>。</li>
<li><strong>在查询中指定（如HQL或Criteria查询）</strong>。</li>
</ol>
<h3 data-id="heading-3">示例代码</h3>
<h4 data-id="heading-4">配置文件 <code>hibernate.cfg.xml</code></h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span>
        <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span>
        <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 数据库连接配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/your_database<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>your_username<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>your_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Hibernate 属性配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.format_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 映射类 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Person"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Address"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h4 data-id="heading-5">实体类 <code>Person</code> 和 <code>Address</code></h4>
<h5 data-id="heading-6">Person类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "person")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "name")</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@Column(name = "age")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-meta">@OneToMany(mappedBy = "person", fetch = FetchType.LAZY, cascade = CascadeType.ALL)</span>
    <span class="hljs-keyword">private</span> Set&lt;Address&gt; addresses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-comment">// Getters 和 Setters</span>
    
    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> Set&lt;Address&gt; <span class="hljs-title function_">getAddresses</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> addresses;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddresses</span><span class="hljs-params">(Set&lt;Address&gt; addresses)</span> {
        <span class="hljs-built_in">this</span>.addresses = addresses;
    }
}
</code></pre>
<h5 data-id="heading-7">Address类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "address")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "street")</span>
    <span class="hljs-keyword">private</span> String street;

    <span class="hljs-meta">@ManyToOne</span>
    <span class="hljs-meta">@JoinColumn(name = "person_id", nullable = false)</span>
    <span class="hljs-keyword">private</span> Person person;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String street, Person person)</span> {
        <span class="hljs-built_in">this</span>.street = street;
        <span class="hljs-built_in">this</span>.person = person;
    }

    <span class="hljs-comment">// Getters 和 Setters</span>
    
    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStreet</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> street;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStreet</span><span class="hljs-params">(String street)</span> {
        <span class="hljs-built_in">this</span>.street = street;
    }

    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">getPerson</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> person;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPerson</span><span class="hljs-params">(Person person)</span> {
        <span class="hljs-built_in">this</span>.person = person;
    }
}
</code></pre>
<h3 data-id="heading-8">即时加载和延迟加载示例</h3>
<h5 data-id="heading-9">HibernateUtil类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateUtil</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SessionFactory sessionFactory;

    <span class="hljs-keyword">static</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 从配置文件创建SessionFactory</span>
            sessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate.cfg.xml"</span>).buildSessionFactory();
        } <span class="hljs-keyword">catch</span> (Throwable ex) {
            <span class="hljs-comment">// 记录启动失败的错误</span>
            System.err.println(<span class="hljs-string">"Initial SessionFactory creation failed."</span> + ex);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionInInitializerError</span>(ex);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SessionFactory <span class="hljs-title function_">getSessionFactory</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> sessionFactory;
    }
}
</code></pre>
<h4 data-id="heading-10">即时加载示例</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateEagerLoadingExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 插入示例数据</span>
        insertData(sessionFactory);

        <span class="hljs-comment">// 即时加载示例</span>
        eagerLoadingExample(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertData</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"John Doe"</span>, <span class="hljs-number">30</span>);
            <span class="hljs-type">Address</span> <span class="hljs-variable">address1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">"123 Street"</span>, person);
            <span class="hljs-type">Address</span> <span class="hljs-variable">address2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">"456 Avenue"</span>, person);
            person.getAddresses().add(address1);
            person.getAddresses().add(address2);

            session.save(person);
            transaction.commit();
            System.out.println(<span class="hljs-string">"Inserted Person and Addresses"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eagerLoadingExample</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 获取Person实体，并同时加载其关联的Address实体（即时加载）</span>
            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> session.get(Person.class, <span class="hljs-number">1L</span>);
            <span class="hljs-keyword">if</span> (person != <span class="hljs-literal">null</span>) {
                System.out.println(<span class="hljs-string">"Person: "</span> + person.getName());
                <span class="hljs-keyword">for</span> (Address address : person.getAddresses()) {
                    System.out.println(<span class="hljs-string">"Address: "</span> + address.getStreet());
                }
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"No Person found with ID 1"</span>);
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-11">延迟加载示例</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateLazyLoadingExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 插入示例数据</span>
        insertData(sessionFactory);

        <span class="hljs-comment">// 延迟加载示例</span>
        lazyLoadingExample(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertData</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"John Doe"</span>, <span class="hljs-number">30</span>);
            <span class="hljs-type">Address</span> <span class="hljs-variable">address1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">"123 Street"</span>, person);
            <span class="hljs-type">Address</span> <span class="hljs-variable">address2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">"456 Avenue"</span>, person);
            person.getAddresses().add(address1);
            person.getAddresses().add(address2);

            session.save(person);
            transaction.commit();
            System.out.println(<span class="hljs-string">"Inserted Person and Addresses"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyLoadingExample</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 获取Person实体，此时不会立即加载其关联的Address实体（延迟加载）</span>
            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> session.get(Person.class, <span class="hljs-number">1L</span>);
            <span class="hljs-keyword">if</span> (person != <span class="hljs-literal">null</span>) {
                System.out.println(<span class="hljs-string">"Person: "</span> + person.getName());
                <span class="hljs-comment">// 访问关联的Address实体时才会触发加载</span>
                <span class="hljs-keyword">for</span> (Address address : person.getAddresses()) {
                    System.out.println(<span class="hljs-string">"Address: "</span> + address.getStreet());
                }
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"No Person found with ID 1"</span>);
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-12">批量检索示例</h3>
<p>批量检索通过在查询中使用<code>@BatchSize</code>注解或Hibernate的配置文件中的相应属性来实现。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> org.hibernate.annotations.BatchSize;

<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "person")</span>
<span class="hljs-meta">@BatchSize(size = 10)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {

 
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（28）Hibernate的级联操作是什么？]]></title>    <link>https://juejin.cn/post/7592148975849013291</link>    <guid>https://juejin.cn/post/7592148975849013291</guid>    <pubDate>2026-01-07T11:53:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592148975849013291" data-draft-id="7592159803411005476" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（28）Hibernate的级联操作是什么？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-07T11:53:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（28）Hibernate的级联操作是什么？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T11:53:40.000Z" title="Wed Jan 07 2026 11:53:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">Hibernate的级联操作</h3>
<p>级联操作（Cascade Operations）是Hibernate提供的一种机制，通过它可以在父实体上执行操作时，自动对其关联的子实体执行相应的操作。这样可以简化代码，避免手动管理关联实体的状态。</p>
<p>级联操作的主要类型包括：</p>
<ul>
<li><strong>CascadeType.PERSIST</strong>：在保存（persist）父实体时，自动保存关联的子实体。</li>
<li><strong>CascadeType.MERGE</strong>：在合并（merge）父实体时，自动合并关联的子实体。</li>
<li><strong>CascadeType.REMOVE</strong>：在删除（remove）父实体时，自动删除关联的子实体。</li>
<li><strong>CascadeType.DETACH</strong>：在分离（detach）父实体时，自动分离关联的子实体。</li>
<li><strong>CascadeType.REFRESH</strong>：在刷新（refresh）父实体时，自动刷新关联的子实体。</li>
<li><strong>CascadeType.ALL</strong>：包括以上所有级联操作。</li>
</ul>
<h3 data-id="heading-1">示例代码</h3>
<h4 data-id="heading-2">配置文件 <code>hibernate.cfg.xml</code></h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span>
        <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span>
        <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 数据库连接配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/your_database<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>your_username<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>your_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Hibernate 属性配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.format_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- 映射类 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Person"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Address"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h4 data-id="heading-3">实体类 <code>Person</code> 和 <code>Address</code></h4>
<h5 data-id="heading-4">Person类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "person")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "name")</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-meta">@Column(name = "age")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;

    <span class="hljs-meta">@OneToMany(mappedBy = "person", cascade = CascadeType.ALL, orphanRemoval = true)</span>
    <span class="hljs-keyword">private</span> Set&lt;Address&gt; addresses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-comment">// Getters 和 Setters</span>
    
    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> Set&lt;Address&gt; <span class="hljs-title function_">getAddresses</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> addresses;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddresses</span><span class="hljs-params">(Set&lt;Address&gt; addresses)</span> {
        <span class="hljs-built_in">this</span>.addresses = addresses;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAddress</span><span class="hljs-params">(Address address)</span> {
        addresses.add(address);
        address.setPerson(<span class="hljs-built_in">this</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAddress</span><span class="hljs-params">(Address address)</span> {
        addresses.remove(address);
        address.setPerson(<span class="hljs-literal">null</span>);
    }
}
</code></pre>
<h5 data-id="heading-5">Address类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.domain;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "address")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Column(name = "street")</span>
    <span class="hljs-keyword">private</span> String street;

    <span class="hljs-meta">@ManyToOne</span>
    <span class="hljs-meta">@JoinColumn(name = "person_id", nullable = false)</span>
    <span class="hljs-keyword">private</span> Person person;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">()</span> {}

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String street, Person person)</span> {
        <span class="hljs-built_in">this</span>.street = street;
        <span class="hljs-built_in">this</span>.person = person;
    }

    <span class="hljs-comment">// Getters 和 Setters</span>
    
    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> {
        <span class="hljs-built_in">this</span>.id = id;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStreet</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> street;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStreet</span><span class="hljs-params">(String street)</span> {
        <span class="hljs-built_in">this</span>.street = street;
    }

    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">getPerson</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> person;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPerson</span><span class="hljs-params">(Person person)</span> {
        <span class="hljs-built_in">this</span>.person = person;
    }
}
</code></pre>
<h3 data-id="heading-6">级联操作示例</h3>
<h5 data-id="heading-7">HibernateUtil类</h5>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateUtil</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SessionFactory sessionFactory;

    <span class="hljs-keyword">static</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 从配置文件创建SessionFactory</span>
            sessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate.cfg.xml"</span>).buildSessionFactory();
        } <span class="hljs-keyword">catch</span> (Throwable ex) {
            <span class="hljs-comment">// 记录启动失败的错误</span>
            System.err.println(<span class="hljs-string">"Initial SessionFactory creation failed."</span> + ex);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionInInitializerError</span>(ex);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SessionFactory <span class="hljs-title function_">getSessionFactory</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> sessionFactory;
    }
}
</code></pre>
<h4 data-id="heading-8">级联保存示例</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateCascadeSaveExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 插入数据</span>
        insertPersonWithAddresses(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertPersonWithAddresses</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"John Doe"</span>, <span class="hljs-number">30</span>);
            <span class="hljs-type">Address</span> <span class="hljs-variable">address1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">"123 Street"</span>, person);
            <span class="hljs-type">Address</span> <span class="hljs-variable">address2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">"456 Avenue"</span>, person);

            person.addAddress(address1);
            person.addAddress(address2);

            <span class="hljs-comment">// 保存Person对象时，级联保存Address对象</span>
            session.save(person);
            transaction.commit();
            System.out.println(<span class="hljs-string">"Inserted Person with Addresses"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-9">级联删除示例</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateCascadeDeleteExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 删除数据</span>
        deletePersonWithAddresses(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deletePersonWithAddresses</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 获取Person对象</span>
            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> session.get(Person.class, <span class="hljs-number">1L</span>);
            <span class="hljs-keyword">if</span> (person != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 删除Person对象时，级联删除Address对象</span>
                session.delete(person);
                transaction.commit();
                System.out.println(<span class="hljs-string">"Deleted Person with Addresses"</span>);
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"No Person found with ID 1"</span>);
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-10">级联更新示例</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateCascadeUpdateExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 获取SessionFactory</span>
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory();

        <span class="hljs-comment">// 更新数据</span>
        updatePersonWithAddresses(sessionFactory);

        <span class="hljs-comment">// 关闭SessionFactory</span>
        sessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePersonWithAddresses</span><span class="hljs-params">(SessionFactory sessionFactory)</span> {
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 获取Person对象</span>
            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> session.get(Person.class, <span class="hljs-number">1L</span>);
            <span class="hljs-keyword">if</span> (person != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 更新Person对象</span>
                person.setName(<span class="hljs-string">"Jane Doe"</span>);
                person.setAge(<span class="hljs-number">35</span>);

                <span class="hljs-comment">// 级联更新Address对象</span>
                <span class="hljs-keyword">for</span> (Address address : person.getAddresses()) {
                    address.setStreet(address.getStreet() + <span class="hljs-string">" Updated"</span>);
                }

                session.update(person);
                transaction.commit();
                System.out.println(<span class="hljs-string">"Updated Person with Addresses"</span>);
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"No Person found with ID 1"</span>);
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">if</span> (transaction != <span class="hljs-literal">null</span>) {
                transaction.rollback();
            }
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) {
                session.close();
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-11">级联操作的详细解释</h3>
<ol>
<li>
<p><strong>配置文件 <code>hibernate.cfg.xml</code></strong>：定义数据库连接信息、Hibernate属性配置以及实体类映射配置。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Person"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapping</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.example.domain.Address"</span>/&gt;</span>
</code></pre>
</li>
<li>
<p><strong>实体类 <code>Person</code> 和 <code>Address</code></strong>：</p>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深度解析官方 Spring Boot 稳定版本及 JDK 配套策略]]></title>    <link>https://juejin.cn/post/7592438587389427750</link>    <guid>https://juejin.cn/post/7592438587389427750</guid>    <pubDate>2026-01-07T11:55:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592438587389427750" data-draft-id="7592455394062139430" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深度解析官方 Spring Boot 稳定版本及 JDK 配套策略"/> <meta itemprop="keywords" content="后端,Java,架构"/> <meta itemprop="datePublished" content="2026-01-07T11:55:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜淡慕潇"/> <meta itemprop="url" content="https://juejin.cn/user/4494459266678318"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深度解析官方 Spring Boot 稳定版本及 JDK 配套策略
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4494459266678318/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜淡慕潇
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T11:55:31.000Z" title="Wed Jan 07 2026 11:55:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a6ed70f618f45f18c78afc916df4789~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aKc5reh5oWV5r2H:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768391730&amp;x-signature=r0nd5%2BhiI8LfkroRZgNV7Y8KmNA%3D" alt="Spring boot-1.png" loading="lazy"/></p>
<h2 data-id="heading-0">一、引言</h2>
<p>Spring Boot 自 2014 年问世以来，已成为 Java 企业级开发的核心框架之一。它的核心价值在于“约定优于配置”和自动化配置，使开发者可以在最短时间内构建可运行的生产级应用。随着 Java 生态和云原生环境的快速发展，Spring Boot 也在不断演进，从 2.x 系列到 3.x 系列，再到最新 4.x 系列，每一次版本迭代都伴随着 API 调整、模块化优化及对新 JDK 特性的支持。</p>
<p>在实际生产环境中，选择合适的 Spring Boot 版本不仅关乎功能，还直接影响系统的<strong>稳定性、长期维护成本以及生态兼容性</strong>。因此，深入分析官方稳定版本、JDK 支持和升级策略，对于企业级应用的技术决策至关重要。</p>
<hr/>
<h2 data-id="heading-1">二、Spring Boot 版本演进与官方支持现状</h2>
<h3 data-id="heading-2">2.1 版本语义与发布策略</h3>
<p>Spring Boot 采用 <strong>语义化版本号</strong>：</p>
<pre><code class="hljs">MAJOR.MINOR.PATCH
</code></pre>
<ul>
<li><strong>MAJOR（主版本）</strong> ：重大架构变更，可能不向下兼容；</li>
<li><strong>MINOR（次版本）</strong> ：新增功能与改进，同时保持大部分向后兼容；</li>
<li><strong>PATCH（补丁）</strong> ：修复 bug、提升稳定性，不引入新特性。</li>
</ul>
<p>官方的版本支持策略明确：</p>
<ul>
<li>每个版本的社区支持约 13 个月；</li>
<li>企业商业支持可延长生命周期，尤其是长期维护的 LTS 版本；</li>
<li>版本升级会提供迁移指南，以降低不可兼容风险。</li>
</ul>
<hr/>
<h3 data-id="heading-3">2.2 Spring Boot 主要版本概览</h3>











































































<table><thead><tr><th>版本</th><th>发布日期</th><th>JDK 支持</th><th>稳定类型</th><th>官方支持状态</th><th>社区 / OSS</th><th>商业支持</th><th>备注 / 最适合 JDK</th></tr></thead><tbody><tr><td><strong>4.0.1</strong></td><td>2025-12-18</td><td>17–25</td><td>主线稳定</td><td>社区支持 ~2026-12</td><td>OSS</td><td>商业支持 ~2027-12</td><td>最新模块化与 API，推荐 JDK 21/25 LTS</td></tr><tr><td><strong>4.0.0</strong></td><td>2025-11-30</td><td>17–25</td><td>主版本</td><td>社区支持 ~2026-12</td><td>OSS</td><td>商业支持延长</td><td>初始 4.0 基线版本，建议补丁升级到 4.0.1</td></tr><tr><td><strong>3.5.9</strong></td><td>2025-12-18</td><td>17–25</td><td>3.x 最后稳定版</td><td>社区支持 ~2026-06</td><td>OSS</td><td>商业支持 ~2032-06</td><td>最成熟稳定版本，推荐生产使用 JDK 17/21</td></tr><tr><td><strong>3.5.0</strong></td><td>2025-05-31</td><td>17–25</td><td>次要稳定</td><td>社区支持 ~2026-06</td><td>OSS</td><td>商业支持延长</td><td>3.5 系列桥梁版本，兼容性高</td></tr><tr><td><strong>3.4.x / 3.3.x</strong></td><td>2024-05 / 2023-11</td><td>17–24</td><td>过时</td><td>OSS 已终止或即将结束</td><td>OSS</td><td>商业短期</td><td>适合旧系统维护</td></tr><tr><td><strong>2.7.x</strong></td><td>2022-05</td><td>8–21</td><td>历史 LTS</td><td>OSS 已结束</td><td>OSS</td><td>商业短期</td><td>适合老旧项目，需逐步升级</td></tr></tbody></table>
<blockquote>
<p>⚠️ 结论：在生产环境中，3.5.x 系列是当前最成熟、兼容性最强的选择，而 4.0.1 代表未来主线，需要更多验证和测试。</p>
</blockquote>
<hr/>
<h2 data-id="heading-4">三、JDK 支持及最佳搭配策略</h2>
<h3 data-id="heading-5">3.1 各版本 JDK 支持情况</h3>






























<table><thead><tr><th>Spring Boot</th><th>支持 JDK 范围</th><th>推荐最优 JDK</th></tr></thead><tbody><tr><td>4.0.x</td><td>17–25</td><td><strong>JDK 21 / 25</strong>（长期支持 &amp; 新特性）</td></tr><tr><td>3.5.x</td><td>17–25</td><td><strong>JDK 17 / 21</strong>（稳定可靠）</td></tr><tr><td>3.4.x / 3.3.x</td><td>17–24</td><td><strong>JDK 17 / 21</strong></td></tr><tr><td>2.7.x</td><td>8–21</td><td><strong>JDK 11 / 17</strong>（兼容旧生态）</td></tr></tbody></table>
<h3 data-id="heading-6">3.2 选择建议</h3>
<ol>
<li><strong>追求稳定性</strong> → Spring Boot 3.5.x + JDK 17/21 LTS</li>
<li><strong>面向未来</strong> → Spring Boot 4.0.1 + JDK 21/25 LTS</li>
<li><strong>老旧系统维持</strong> → Spring Boot 2.7.x + JDK 11</li>
</ol>
<blockquote>
<p>小结：选择 JDK 时应兼顾长期支持、性能优化和生态兼容性。对于企业生产系统，LTS 版本（17/21/25）是首选。</p>
</blockquote>
<hr/>
<h2 data-id="heading-7">四、版本稳定性分析</h2>
<h3 data-id="heading-8">4.1 API 稳定性</h3>
<ul>
<li><strong>3.5.x</strong>：经过多轮补丁和社区验证，向后兼容性极强，适合生产环境；</li>
<li><strong>4.0.x</strong>：模块化与新特性增加，部分 API 不兼容，升级需参考官方迁移指南。</li>
</ul>
<h3 data-id="heading-9">4.2 生产环境安全性</h3>
<ul>
<li>补丁发布频繁，修复漏洞、优化性能；</li>
<li>商业支持可延长生命周期，确保长期运行安全。</li>
</ul>
<h3 data-id="heading-10">4.3 生态兼容性</h3>
<ul>
<li>Spring Cloud 与 3.5.x 完美匹配，4.0.x 需测试依赖版本；</li>
<li>大多数第三方库（Kafka、Redis、GRPC 等）对 3.5.x 兼容成熟。</li>
</ul>
<h3 data-id="heading-11">4.4 升级成本</h3>
<ul>
<li><strong>3.x → 3.5</strong>：风险低，主要为次要版本更新；</li>
<li><strong>3.x → 4.x</strong>：风险中高，需迁移代码、验证自动配置和模块化变更；</li>
<li><strong>JDK 升级</strong>：需确保依赖库支持新版本 JDK。</li>
</ul>
<hr/>
<h2 data-id="heading-12">五、版本选择策略</h2>

























<table><thead><tr><th>场景</th><th>推荐版本</th><th>备注</th></tr></thead><tbody><tr><td>企业级长期维护系统</td><td>3.5.x 最新 Patch + JDK 17/21</td><td>最成熟稳定，社区和商业支持最长</td></tr><tr><td>新项目 / 前沿技术</td><td>4.0.1 + JDK 21/25</td><td>新特性、模块化优化，但需测试依赖兼容</td></tr><tr><td>旧项目 / 逐步升级</td><td>2.7.x + JDK 8/11/17 → 3.5.x</td><td>确保平滑迁移，降低风险</td></tr></tbody></table>
<blockquote>
<p>核心原则：优先选择 <strong>LTS JDK + 最新 Patch 的稳定主线版本</strong>，再根据项目需求评估是否采用新版本功能。</p>
</blockquote>
<hr/>
<h2 data-id="heading-13">六、结论</h2>
<p>通过对 Spring Boot 各个版本的深度分析，可以得出以下结论：</p>
<ol>
<li><strong>3.5.x 系列</strong> 是目前生产环境最安全、生态最成熟的版本，推荐搭配 JDK 17/21；</li>
<li><strong>4.0.1</strong> 是未来主线，支持最新 JDK 和模块化功能，适合新项目，但升级需谨慎；</li>
<li><strong>版本选择应结合 JDK 支持、生态兼容性、生命周期及生产风险</strong>，以形成稳定、可维护的长期架构；</li>
<li><strong>升级策略</strong>：老项目逐步升级 → 桥梁版本（3.5.x） → 新主线（4.x），同时保持严格测试和依赖验证。</li>
</ol>
<hr/>
<h3 data-id="heading-14">参考链接</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fspring.io%2Fblog%3Futm_source%3Dchatgpt.com" target="_blank" title="https://spring.io/blog?utm_source=chatgpt.com" ref="nofollow noopener noreferrer">Spring Boot 官方博客</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fspring.io%2Fsupport-policy%3Futm_source%3Dchatgpt.com" target="_blank" title="https://spring.io/support-policy?utm_source=chatgpt.com" ref="nofollow noopener noreferrer">Spring Boot 支持策略</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fendoflife.date%2Fspring-boot%3Futm_source%3Dchatgpt.com" target="_blank" title="https://endoflife.date/spring-boot?utm_source=chatgpt.com" ref="nofollow noopener noreferrer">End of Life 官方统计</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-boot%2Fwiki%2FSupported-Versions%3Futm_source%3Dchatgpt.com" target="_blank" title="https://github.com/spring-projects/spring-boot/wiki/Supported-Versions?utm_source=chatgpt.com" ref="nofollow noopener noreferrer">Spring Boot GitHub Wiki 版本支持</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[学习一些常用的混合模式之BlendMode.srcOut]]></title>    <link>https://juejin.cn/post/7592255257348161577</link>    <guid>https://juejin.cn/post/7592255257348161577</guid>    <pubDate>2026-01-07T12:00:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592255257348161577" data-draft-id="7592255257348046889" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="学习一些常用的混合模式之BlendMode.srcOut"/> <meta itemprop="keywords" content="Flutter"/> <meta itemprop="datePublished" content="2026-01-07T12:00:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="火柴就是我"/> <meta itemprop="url" content="https://juejin.cn/user/272334614705575"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            学习一些常用的混合模式之BlendMode.srcOut
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/272334614705575/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    火柴就是我
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T12:00:52.000Z" title="Wed Jan 07 2026 12:00:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>srcOut</p>
<p><code>Keeps the source pixels that do not cover destination pixels. Discards source pixels that cover destination pixels. Discards all destination pixels.</code></p>
<p>计算公式:</p>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bdd28db3859345d88f728c2263188d5e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Gr5p-05bCx5piv5oiR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768392052&amp;x-signature=NZZDf4SvHMScYxdnJdhODRKaT74%3D" alt="image.png" width="30%" loading="lazy"/>
<p>当dst.a = 1 的时候 a = 0 c = 0 也就是完全透明.也就是上面那段英文的意思保留非重叠部分的src和dst,移除重叠部分的src和dst。换句话就是如果你想在dst上清除某部分的内容，就可以使用srcOut.</p>
<p>例子:</p>
<pre><code class="hljs language-js" lang="js">  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span>(<span class="hljs-params">Canvas canvas, Size size</span>) {
    <span class="hljs-keyword">var</span> width = size.<span class="hljs-property">width</span>;
    <span class="hljs-keyword">var</span> height = size.<span class="hljs-property">height</span>;

    canvas.<span class="hljs-title function_">saveLayer</span>(<span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), <span class="hljs-title class_">Paint</span>());
    <span class="hljs-title class_">Paint</span> dstPaint = <span class="hljs-title class_">Paint</span>()..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">red</span>;
    dstPaint.<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">20</span>;
    dstPaint.<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span>;

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">10</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">50</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">90</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">130</span>, dstPaint);

    <span class="hljs-keyword">var</span> srcPaint = <span class="hljs-title class_">Paint</span>()
      ..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">blue</span> <span class="hljs-comment">// 源颜色：蓝色</span>
      ..<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span> <span class="hljs-comment">// 填充模式</span>
      ..<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">70</span>
      ..<span class="hljs-property">blendMode</span> = <span class="hljs-title class_">BlendMode</span>.<span class="hljs-property">srcOut</span>; <span class="hljs-comment">// 混合模式</span>
    <span class="hljs-comment">// canvas.drawRect(Rect.fromLTWH(0, 0, width, height), srcPaint);</span>
    canvas.<span class="hljs-title function_">drawImageRect</span>(image!, <span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, image!.<span class="hljs-property">width</span>.<span class="hljs-title function_">toDouble</span>(), image!.<span class="hljs-property">height</span>.<span class="hljs-title function_">toDouble</span>()), <span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), srcPaint);

    canvas.<span class="hljs-title function_">restore</span>();
  }
</code></pre>
<p>效果图:</p>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/adef80d04bd54943bc38f2f82c9e3ad6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Gr5p-05bCx5piv5oiR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768392052&amp;x-signature=EtBzq2LzYY1fvvQQw5jj797fP0E%3D" alt="image.png" width="30%" loading="lazy"/>
<p>环形跟图片重叠的部分变成透明的，src未重叠部分保留了下来。</p>
<p>例子2:</p>
<pre><code class="hljs language-js" lang="js">  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span>(<span class="hljs-params">Canvas canvas, Size size</span>) {
    <span class="hljs-keyword">var</span> width = size.<span class="hljs-property">width</span>;
    <span class="hljs-keyword">var</span> height = size.<span class="hljs-property">height</span>;

    canvas.<span class="hljs-title function_">saveLayer</span>(<span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), <span class="hljs-title class_">Paint</span>());
    <span class="hljs-title class_">Paint</span> dstPaint = <span class="hljs-title class_">Paint</span>()..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">red</span>;
    dstPaint.<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">20</span>;
    dstPaint.<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span>;

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">10</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">50</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">90</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">130</span>, dstPaint);

    <span class="hljs-keyword">var</span> clipPath = ui.<span class="hljs-title class_">Path</span>();
    clipPath.<span class="hljs-title function_">addOval</span>(<span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromCenter</span>(<span class="hljs-attr">center</span>: <span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-attr">width</span>: <span class="hljs-number">240</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">240</span>));
    canvas.<span class="hljs-title function_">clipPath</span>(clipPath);
    <span class="hljs-keyword">var</span> srcPaint = <span class="hljs-title class_">Paint</span>()
      ..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">blue</span> <span class="hljs-comment">// 源颜色：蓝色</span>
      ..<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span> <span class="hljs-comment">// 填充模式</span>
      ..<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">70</span>
      ..<span class="hljs-property">blendMode</span> = <span class="hljs-title class_">BlendMode</span>.<span class="hljs-property">srcOut</span>; <span class="hljs-comment">// 混合模式</span>
    <span class="hljs-comment">// canvas.drawRect(Rect.fromLTWH(0, 0, width, height), srcPaint);</span>
    canvas.<span class="hljs-title function_">drawImageRect</span>(image!, <span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, image!.<span class="hljs-property">width</span>.<span class="hljs-title function_">toDouble</span>(), image!.<span class="hljs-property">height</span>.<span class="hljs-title function_">toDouble</span>()), <span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), srcPaint);

    canvas.<span class="hljs-title function_">restore</span>();
  }
</code></pre>
<p>效果图：</p>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8bf55563f9d546edb32e8ef1ca83f787~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Gr5p-05bCx5piv5oiR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768392052&amp;x-signature=w2C4kIZ6akgypumeH7UL3OBSeBw%3D" alt="image.png" width="30%" loading="lazy"/>
<p>环形跟图片重叠的部分变成透明的，src未重叠部分保留了下来，dst未重叠部分保留了下来。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Solidity智能合约快速入门]]></title>    <link>https://juejin.cn/post/7592148975848554539</link>    <guid>https://juejin.cn/post/7592148975848554539</guid>    <pubDate>2026-01-07T09:46:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592148975848554539" data-draft-id="7590724064522256447" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Solidity智能合约快速入门"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-07T09:46:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员鸡皮"/> <meta itemprop="url" content="https://juejin.cn/user/3092298256613837"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Solidity智能合约快速入门
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3092298256613837/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员鸡皮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:46:30.000Z" title="Wed Jan 07 2026 09:46:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">什么是智能合约？</h2>
<p>智能合约是运行在链上的程序，合约开发者可以通过智能合约实现与链上资产、数据进行交互。用户可以通过自己的链上账户来调用合约，访问资产与数据。</p>
<p><strong>与一般程序的差异</strong></p>
<p>原生支持资产流动，部署与后续写入需要一定的费用，存储数据的成本更高，部署后无法更改（可升级合约？）</p>
<h2 data-id="heading-1">Solidity是什么？</h2>
<p>一门面向合约的，为实现智能合约而创建的高级编程语言，在EVM虚拟机上运行，语法整体类似于JavaScript，是目前最流行的智能合约语言，也是入门区块链和web3所必须掌握的语言。</p>
<h2 data-id="heading-2">如何部署合约？</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/784dcc8393824763ab2c0357643aa7c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bih55qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383990&amp;x-signature=BBlJ6NPaIIkOu6CPsCux1UvK0zs%3D" alt="image.png" loading="lazy"/></p>
<p>Solidity合约是以.sol为后缀的文件，无法直接执行，需要编译为EVM（Ｅｔｈｅｒｅｕｍ　Ｖｉｒｔｕａｌ　Machine）可识别的字节码才能在链上运行。</p>
<h2 data-id="heading-3">开发框架&amp;工具有哪些？</h2>
<p>框架有：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/07d08417f3094c9192b97e5f0ddee541~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bih55qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383990&amp;x-signature=YwRMQngg5dsq8gMXs1FntZ%2F9AD8%3D" alt="image.png" loading="lazy"/></p>
<p>工具有：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/70dbc19648e84b4dab4b1da6e6c05b6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bih55qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383990&amp;x-signature=xgXktOQPL5Iqa75CP3tX5cM6xVc%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-4">Solidity核心语法有哪些？</h2>
<h3 data-id="heading-5">基本数据类型</h3>
<p>１.　Boolean
２.　ｉｎｔ
３.　ｕｉｎｔ
４.　address
５.　bytes
．．．</p>
<h3 data-id="heading-6">枚举类型</h3>
<pre><code class="hljs language-js" lang="js">enum <span class="hljs-title class_">Status</span>{
    <span class="hljs-title class_">Unknown</span>,
    <span class="hljs-title class_">Start</span>,
    <span class="hljs-title class_">End</span>,
    <span class="hljs-title class_">Pause</span>
}
<span class="hljs-comment">// 实例化枚举类型</span>
<span class="hljs-title class_">Status</span> public status；
<span class="hljs-comment">// 更新枚举值</span>
<span class="hljs-keyword">function</span> pause public {
    status = <span class="hljs-title class_">Status</span>.<span class="hljs-property">Pause</span>;
}
<span class="hljs-comment">// 初始化枚举值</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params"/>) public{
   <span class="hljs-keyword">return</span> status;
}
</code></pre>
<h3 data-id="heading-7">数组类型</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 定义数组类型</span>
uint[<span class="hljs-number">7</span>] public arr;
<span class="hljs-comment">// 添加数据</span>
arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">7</span>);
<span class="hljs-comment">// 删除最后一个数据</span>
arr.<span class="hljs-title function_">pop</span>();
<span class="hljs-comment">// 删除某个索引值数据</span>
<span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>];
<span class="hljs-comment">// 获取数组长度</span>
uint len = arr.<span class="hljs-property">length</span>;
</code></pre>
<h3 data-id="heading-8">mapping类型</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 定义嵌套mapping类型</span>
<span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">string</span>=&gt;</span>string)) nestedMap;
<span class="hljs-comment">// 设置值</span>
nestedMap[id][key] = <span class="hljs-string">"0707"</span>;
<span class="hljs-comment">// 读取值</span>
string value = nestedMap[id][key];
<span class="hljs-comment">// 删除值</span>
<span class="hljs-keyword">delete</span> nestMap[id][key];
</code></pre>
<h3 data-id="heading-9">结构体类型（struct）</h3>
<pre><code class="hljs language-js" lang="js">contract <span class="hljs-title class_">Struct</span>{
    struct <span class="hljs-title class_">Data</span>{
        string id;
        string hash;
    }
    <span class="hljs-title class_">Data</span> public data;
    
    <span class="hljs-comment">// 添加数据</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">string calldata _id</span>) public {
        data = <span class="hljs-title class_">Data</span>{<span class="hljs-attr">id</span>:_id,<span class="hljs-attr">hash</span>:<span class="hljs-string">"111222"</span>};
    }
    
    <span class="hljs-comment">// 更新数据</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">string _id</span>) public {
        <span class="hljs-comment">// 查询数据</span>
        string id = data.<span class="hljs-property">id</span>
        <span class="hljs-comment">// 更新</span>
        data.<span class="hljs-property">hash</span> = <span class="hljs-string">"222333"</span>
    }
}
</code></pre>
<h2 data-id="heading-10">变量类型有哪些？</h2>
<p><strong>类型</strong>：local state global
<strong>关键字声明</strong>：storage  memory calldata</p>
<h2 data-id="heading-11">常量有哪些？</h2>
<p>constant ： 值不可变，节约gas fee
immutable：可以在constructor中初始化，但不可以再次改变。</p>
<h2 data-id="heading-12">函数的可见性和关键字有哪些？</h2>
<p>可见性：public  private internal external</p>
<p>关键字：view pure</p>
<h2 data-id="heading-13">函数修饰符modifier</h2>
<pre><code class="hljs language-js" lang="js">modifier  onlyOwner{
    <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">sender</span> == owner,<span class="hljs-string">"Not owner"</span>);
}

modifier <span class="hljs-title function_">validAddress</span>(<span class="hljs-params">address _addr</span>){
    <span class="hljs-built_in">require</span>(_addr != <span class="hljs-title function_">address</span>(<span class="hljs-number">0</span>),<span class="hljs-string">"Not valid address"</span>);
    _;
}

modifier <span class="hljs-title function_">noReentrancy</span>(<span class="hljs-params"/>){
    <span class="hljs-built_in">require</span>(!locked,<span class="hljs-string">"No reentrancy"</span>);
    locked = <span class="hljs-literal">true</span>;
    _;
    locked = <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">changeOwner</span>(<span class="hljs-params">address _newOwner</span>) public onlyOwner <span class="hljs-title function_">validAddress</span>(<span class="hljs-params">_newOwner</span>){
    owner = _newOwner;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">decrement</span>(<span class="hljs-params">uint i</span>) public noReentrancy{
    x -= i;
    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">1</span>){
        <span class="hljs-title function_">decrement</span>(i - <span class="hljs-number">1</span>);
    }
}
</code></pre>
<h2 data-id="heading-14">函数选择器是什么？</h2>
<pre><code class="hljs language-js" lang="js">addr.<span class="hljs-title function_">call</span>(abi.<span class="hljs-title function_">encodeWithSignature</span>(<span class="hljs-string">"transfer(address,uint256)"</span>,0xSomeAddress,<span class="hljs-number">123</span>))

contract  <span class="hljs-title class_">FunctionSelector</span>{
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSelector</span>(<span class="hljs-params">string calldata _func</span>) external pure returns (bytes4){
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">bytes4</span>(<span class="hljs-title function_">keccak256</span>(<span class="hljs-title function_">bytes</span>(_func)));
    }
}
</code></pre>
<h2 data-id="heading-15">条件判断是什么？</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">10</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">20</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}<span class="hljs-keyword">else</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
}

x &lt; <span class="hljs-number">20</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span> <span class="hljs-comment">// 三元运算符</span>
</code></pre>
<h2 data-id="heading-16">循环有哪些？</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">for</span>(uint i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++){
    <span class="hljs-comment">// 业务逻辑</span>

}
uint j;
<span class="hljs-keyword">while</span> (j &lt; <span class="hljs-number">10</span>){
    j++;
}
</code></pre>
<h2 data-id="heading-17">合约的概念（constructor）</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">string memory _name</span>){
    name = _name;
}
</code></pre>
<h3 data-id="heading-18">先定义接口，然后由合约实现接口。</h3>
<pre><code class="hljs language-js" lang="js">contract <span class="hljs-title class_">Counter</span>{
  uint public  count;
  <span class="hljs-keyword">function</span>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"/>) external{
      count+<span class="hljs-number">1</span>;
  }
}

interface <span class="hljs-title class_">ICounter</span>{
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"/>) external view returns (uint);
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"/>) external;
}

contract <span class="hljs-title class_">MyContract</span> {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">incrementCounter</span>(<span class="hljs-params">address _counter</span>) external {
        <span class="hljs-title class_">ICounter</span>(_counter).<span class="hljs-title function_">increment</span>();
    }
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCount</span>(<span class="hljs-params">address _counter</span>) external view returns (uint){
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ICounter</span>(_counter).<span class="hljs-title function_">count</span>();
    }
}
</code></pre>
<h2 data-id="heading-19">合约如何继承呢？</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 定义父合约 A</span>
contract A{
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) public pure virtual returns (string memory){
        <span class="hljs-keyword">return</span> <span class="hljs-string">"A"</span>;
    }
}

<span class="hljs-comment">// B合约继承A合约并重写函数</span>
contract B is A{
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) public pure virtual override returns (string memory){
        <span class="hljs-keyword">return</span> <span class="hljs-string">"B"</span>;
    }
}

<span class="hljs-comment">// D合约继承B，C并重写函数</span>
contract D is B,C{
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) public pure <span class="hljs-title function_">override</span>(B,C) returns (string memory){
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">foo</span>();
    }
} 

contract B is A{
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) public virtual override{
        <span class="hljs-comment">// 直接调用</span>
        A.<span class="hljs-title function_">foo</span>();
    }
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"/>) public virtual override{
        <span class="hljs-comment">// 通过supper关键字调用</span>
        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">bar</span>();
    }
}
</code></pre>
<h2 data-id="heading-20">如何在合约里面创建合约？</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">address _owner,string memory _model</span>) public {
    <span class="hljs-title class_">Car</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(_owner,_model);
    cars.<span class="hljs-title function_">push</span>(car);
}
</code></pre>
<p>在0.8.0之后支持以下写法</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create2</span>(<span class="hljs-params">address _owner,string memory _model,bytes32 _salt</span>) public{
    <span class="hljs-title class_">Car</span> car = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>){<span class="hljs-attr">salt</span>:_salt}(_owner,_model);
    cars.<span class="hljs-title function_">push</span>(car);
}
</code></pre>
<h2 data-id="heading-21">如何导入合约呢？</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 本地导入</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./Foo.sol'</span>;
<span class="hljs-comment">// 外部导入</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'https://github.com/owner/repo/blob/branch/path/to/Contract.sol'</span>; 
</code></pre>
<h2 data-id="heading-22">导入如何导入库？</h2>
<pre><code class="hljs language-js" lang="js">library <span class="hljs-title class_">SafeMath</span>{
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">uint x, uint y</span>) internal pure returns (uint){
        uint z = x+y;
        <span class="hljs-built_in">require</span>(z&gt;=x,<span class="hljs-string">"uint overflow"</span>);
    }
}

contract <span class="hljs-title class_">TestSafeMath</span>{
    using <span class="hljs-title class_">SafeMath</span> <span class="hljs-keyword">for</span> uint;
}
</code></pre>
<h2 data-id="heading-23">事件怎么实现?</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 定义事件</span>
event <span class="hljs-title class_">Log</span>(address indexed sender,string message);
event <span class="hljs-title class_">AnotherLog</span>();

<span class="hljs-comment">// 抛出事件</span>
emit <span class="hljs-title class_">Log</span>(msg.<span class="hljs-property">sender</span>,<span class="hljs-string">"Hello World!"</span>);
emit <span class="hljs-title class_">Log</span>(msg.<span class="hljs-property">sender</span>,<span class="hljs-string">"Hello EVM!"</span>);
emit <span class="hljs-title class_">AnotherLog</span>();
</code></pre>
<h2 data-id="heading-24">错误处理如何使用？</h2>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">testRequire</span>(<span class="hljs-params">uint _i</span>) public pure {
        <span class="hljs-built_in">require</span>(_i &gt; <span class="hljs-number">10</span>,<span class="hljs-string">"Input must be greater than 10"</span>);
    }
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">testRevert</span>(<span class="hljs-params">uint _i</span>) public pure{
        <span class="hljs-keyword">if</span>(i &lt;= <span class="hljs-number">10</span>){
            <span class="hljs-title function_">revert</span>(<span class="hljs-string">"Input must be greater than 10"</span>);
        }
    }
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAssert</span>(<span class="hljs-params"/>) public view{
        <span class="hljs-title function_">assert</span>(num == <span class="hljs-number">10</span>);
    }
</code></pre>
<h3 data-id="heading-25">try/catch捕捉错误</h3>
<pre><code class="hljs language-js" lang="js">event <span class="hljs-title class_">Log</span>(string message);
event <span class="hljs-title class_">Log</span>(bytes data);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">tryCatchNewContract</span>(<span class="hljs-params">address _owner</span>) public {
    <span class="hljs-keyword">try</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(_owner) returns (<span class="hljs-title class_">Foo</span> foo){
        emit <span class="hljs-title class_">Log</span>(<span class="hljs-string">"Foo created"</span>);
    }<span class="hljs-keyword">catch</span> <span class="hljs-title class_">Error</span>(string memory reason){
        emit <span class="hljs-title class_">Log</span>(reason);
    }<span class="hljs-keyword">catch</span>(bytes memory reason){
        emit <span class="hljs-title class_">LogBytes</span>(reason);
    }
}
</code></pre>
<h2 data-id="heading-26">资产（payable）</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 地址类型可以声明 payable</span>
address payable public owner;

<span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) payable {
  owner = <span class="hljs-title function_">payable</span>(msg.<span class="hljs-property">sender</span>);
}

<span class="hljs-comment">// 方法声明  payable 来接收 Ether</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deposit</span>(<span class="hljs-params"/>)  public payable{}

</code></pre>
<h3 data-id="heading-27">资产如何发送？</h3>
<pre><code class="hljs language-js" lang="js">contract <span class="hljs-title class_">SendEnter</span>{
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendViaCall</span>(<span class="hljs-params">address payable _to</span>) public payable{
        (bool sent,bytes memory data) = _to.<span class="hljs-property">call</span>{<span class="hljs-attr">value</span>:msg.<span class="hljs-property">value</span>}(<span class="hljs-string">""</span>);
        <span class="hljs-built_in">require</span>(sent,<span class="hljs-string">"Failed to send Ether"</span>);
    }
}
</code></pre>
<h3 data-id="heading-28">资产如何接受？</h3>
<pre><code class="hljs language-js" lang="js">contract <span class="hljs-title class_">ReceiveEther</span>{
    <span class="hljs-comment">// 当msg.data为空时</span>
    <span class="hljs-title function_">receive</span>() external payable{}
    <span class="hljs-comment">// 当msg.data非空时</span>
    <span class="hljs-title function_">fallback</span>() external payable{}
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getBalance</span>(<span class="hljs-params"/>) public view returns (uint) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">address</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">balance</span>;
    }
}
</code></pre>
<h2 data-id="heading-29">如何节约Gas费用？</h2>
<p><strong>参数</strong></p>
<ol>
<li><code>gas spent</code></li>
<li><code>gas price</code></li>
<li><code>gas limit</code></li>
<li><code>block gas limit</code></li>
</ol>
<p><strong>技巧</strong></p>
<ol>
<li>使用<code>calldata</code>代替<code>memory</code></li>
<li>将状态变量载入内存</li>
<li>使用<code>i++</code>而不是使用<code>++i</code></li>
<li>缓存数组元素</li>
</ol>
<h2 data-id="heading-30">其他学习网址：</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a554e93f03f406488fca14edb7c025d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6bih55qu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383990&amp;x-signature=xw0IqF8kL393DqUm0Kop03OnTV8%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-31">使用forge test来测试项目是否成功！</h2>
<p>web3博主博客：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.pseudoyu.com%2F" target="_blank" title="https://www.pseudoyu.com/" ref="nofollow noopener noreferrer">链接</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[langchain学习总结：Python + OpenAI 原生 SDK 实现记忆功能]]></title>    <link>https://juejin.cn/post/7592455394061598758</link>    <guid>https://juejin.cn/post/7592455394061598758</guid>    <pubDate>2026-01-07T09:48:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592455394061598758" data-draft-id="7592455394061582374" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="langchain学习总结：Python + OpenAI 原生 SDK 实现记忆功能"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-07T09:48:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="心在飞扬AI"/> <meta itemprop="url" content="https://juejin.cn/user/1556564194366823"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            langchain学习总结：Python + OpenAI 原生 SDK 实现记忆功能
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1556564194366823/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    心在飞扬AI
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:48:38.000Z" title="Wed Jan 07 2026 09:48:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Python + OpenAI 原生 SDK 实现记忆功能</h2>
<h3 data-id="heading-1">一、这是什么</h3>
<p>这是一个使用 <strong>Python</strong> 和 <strong>OpenAI 原生 SDK</strong> 从零实现的对话记忆系统，采用了<strong>摘要缓存混合记忆</strong>（ConversationSummaryBufferMemory）的策略。</p>
<p>它不依赖 LangChain 等高级框架，而是通过原生代码实现了类似于 LangChain 的记忆管理功能。</p>
<h3 data-id="heading-2">二、核心原理</h3>
<h4 data-id="heading-3">摘要缓存混合记忆（Summary Buffer Memory）</h4>
<p>这是一种将<strong>摘要记忆</strong>和<strong>缓冲窗口记忆</strong>结合的混合策略：</p>
<pre><code class="hljs language-css" lang="css">┌─────────────────────────────────────────────────┐
│  摘要部分（<span class="hljs-selector-tag">Summary</span>）                             │
│  存储早期对话的提炼总结                           │
│  例如：用户叫张三，喜欢编程...                    │
└─────────────────────────────────────────────────┘
              ↓ 随对话增长动态生成
┌─────────────────────────────────────────────────┐
│  缓冲部分（Buffer）                              │
│  存储最近的完整对话记录                           │
│  例如：最近<span class="hljs-number">3</span>轮的完整问答                          │
└─────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-4">工作流程</h4>
<ol>
<li><strong>初始阶段</strong>：所有对话存储在缓存中</li>
<li><strong>触发摘要</strong>：当缓存中的 token 数量超过 <code>max_tokens</code> 阈值时</li>
<li><strong>生成摘要</strong>：将最早的对话与现有摘要合并，生成新的摘要</li>
<li><strong>移除旧对话</strong>：将已摘要的对话从缓存中删除</li>
<li><strong>循环进行</strong>：保持对话历史的可控性</li>
</ol>
<h3 data-id="heading-5">三、核心组件</h3>
<h4 data-id="heading-6">ConversationSummaryBufferMemory 类</h4>
<p>这个类实现了完整的记忆管理功能：</p>









































<table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><code>summary</code></td><td>存储对话摘要信息</td></tr><tr><td><code>chat_histories</code></td><td>存储历史对话列表</td></tr><tr><td><code>max_tokens</code></td><td>触发摘要生成的 token 阈值</td></tr><tr><td><code>get_num_tokens()</code></td><td>计算文本的 token 数量</td></tr><tr><td><code>save_content()</code></td><td>保存新的对话到缓存</td></tr><tr><td><code>get_buffer_string()</code></td><td>将历史对话转换为字符串</td></tr><tr><td><code>load_memory_variables()</code></td><td>加载记忆变量供模型使用</td></tr><tr><td><code>summary_text()</code></td><td>使用 LLM 生成新的摘要</td></tr></tbody></table>
<h4 data-id="heading-7">关键方法说明</h4>
<h5 data-id="heading-8">1. <code>save_content()</code> - 保存对话并触发摘要</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_content</span>(<span class="hljs-params">self, human_query: <span class="hljs-built_in">str</span>, ai_content: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># 1. 保存新对话</span>
    <span class="hljs-comment"># 2. 检查 token 数量</span>
    <span class="hljs-comment"># 3. 超过阈值则生成摘要并移除旧对话</span>
</code></pre>
<h5 data-id="heading-9">2. <code>summary_text()</code> - 生成新摘要</h5>
<p>使用精心设计的 Prompt 让 LLM 将旧摘要和新对话合并成新摘要，并保留关键信息（姓名、爱好、重要事件等）。</p>
<h5 data-id="heading-10">3. <code>load_memory_variables()</code> - 加载记忆</h5>
<p>返回格式化的上下文，包含摘要和缓存中的历史对话。</p>
<h3 data-id="heading-11">四、有什么用</h3>
<h4 data-id="heading-12">1. 实现长期对话记忆</h4>
<ul>
<li>AI 可以记住之前的对话内容</li>
<li>跨会话保持上下文连贯性</li>
<li>记住用户的重要信息（姓名、偏好等）</li>
</ul>
<h4 data-id="heading-13">2. 控制 Token 成本</h4>
<ul>
<li>不会无限制地发送所有历史对话</li>
<li>通过摘要减少早期对话的 token 占用</li>
<li>只保留最近对话的完整内容</li>
</ul>
<h4 data-id="heading-14">3. 平衡信息完整性与成本</h4>
<ul>
<li><strong>摘要部分</strong>：保留关键信息，占用 token 少</li>
<li><strong>缓存部分</strong>：保留完整细节，确保近期对话准确</li>
</ul>
<h4 data-id="heading-15">4. 学习价值</h4>
<ul>
<li>理解大语言模型应用中记忆管理的核心概念</li>
<li>学习如何从零实现复杂的对话状态管理</li>
<li>掌握提示词工程在摘要生成中的应用</li>
</ul>
<h3 data-id="heading-16">五、应用场景</h3>





























<table><thead><tr><th>场景</th><th>优势</th></tr></thead><tbody><tr><td><strong>智能客服</strong></td><td>记住用户问题和历史投诉</td></tr><tr><td><strong>个性化助手</strong></td><td>记住用户偏好和习惯</td></tr><tr><td><strong>教育辅导</strong></td><td>跟踪学习进度和知识点</td></tr><tr><td><strong>心理咨询</strong></td><td>保持长期咨询的连贯性</td></tr><tr><td><strong>游戏 NPC</strong></td><td>记住与玩家的交互历史</td></tr></tbody></table>
<h3 data-id="heading-17">六、实现亮点</h3>
<ol>
<li><strong>原生实现</strong>：不依赖框架，理解底层原理</li>
<li><strong>动态摘要</strong>：自动触发摘要生成，无需手动管理</li>
<li><strong>关键信息保留</strong>：精心设计的 Prompt 确保重要信息不丢失</li>
<li><strong>流式输出</strong>：支持 OpenAI 的流式响应，提升用户体验</li>
<li><strong>模块化设计</strong>：各个功能独立，易于扩展</li>
</ol>
<h3 data-id="heading-18">七、技术栈</h3>
<ul>
<li><strong>Python 3.x</strong></li>
<li><strong>OpenAI SDK</strong>（兼容 Moonshot 等 OpenAI 格式 API）</li>
<li><strong>dotenv</strong>（环境变量管理）</li>
<li><strong>大语言模型</strong>：Moonshot-v1-8k</li>
</ul>
<h3 data-id="heading-19">八、完整代码实现</h3>
<h4 data-id="heading-20">8.1 核心类实现</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span>
<span class="hljs-keyword">import</span> dotenv
<span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI

dotenv.load_dotenv()

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConversationSummaryBufferMemory</span>:
    <span class="hljs-string">"""
    摘要缓存混合记忆类
    结合了摘要记忆和缓冲窗口记忆的优点
    """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, summary: <span class="hljs-built_in">str</span> = <span class="hljs-string">''</span>, chat_histories: <span class="hljs-built_in">list</span> = <span class="hljs-literal">None</span>, max_tokens: <span class="hljs-built_in">int</span> = <span class="hljs-number">300</span></span>):
        <span class="hljs-string">"""
        初始化记忆组件

        Args:
            summary: 初始摘要内容
            chat_histories: 历史对话列表
            max_tokens: 触发摘要生成的最大token数
        """</span>
        self.summary = summary  <span class="hljs-comment"># 存储摘要</span>
        self.chat_histories = [] <span class="hljs-keyword">if</span> chat_histories <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> chat_histories  <span class="hljs-comment"># 存储对话缓存</span>
        self.max_tokens = max_tokens  <span class="hljs-comment"># token阈值</span>
        self.client = OpenAI(base_url=<span class="hljs-string">'https://api.moonshot.cn/v1'</span>)  <span class="hljs-comment"># LLM客户端</span>
</code></pre>
<h4 data-id="heading-21">8.2 工具方法</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num_tokens</span>(<span class="hljs-params">cls, query: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-string">"""
        计算文本的token数量
        这里简化为字符长度，实际可以使用tiktoken精确计算
        """</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(query)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_buffer_string</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">"""
        将历史对话列表转换为字符串格式
        格式: human: xxx\nai: xxx\n
        """</span>
        buffer_string = <span class="hljs-string">''</span>
        <span class="hljs-keyword">for</span> chat <span class="hljs-keyword">in</span> self.chat_histories:
            buffer_string += <span class="hljs-string">f"human: <span class="hljs-subst">{chat.get(<span class="hljs-string">'human'</span>)}</span>\nai: <span class="hljs-subst">{chat.get(<span class="hljs-string">'ai'</span>)}</span>\n"</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"buffer_string: <span class="hljs-subst">{buffer_string}</span>"</span>)
        <span class="hljs-keyword">return</span> buffer_string.strip()
</code></pre>
<h4 data-id="heading-22">8.3 核心方法：保存对话</h4>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_content</span>(<span class="hljs-params">self, human_query: <span class="hljs-built_in">str</span>, ai_content: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
        <span class="hljs-string">"""
        保存新的对话到缓存，并检查是否需要生成摘要

        工作流程：
        1. 将新对话添加到缓存
        2. 计算缓存的token数量
        3. 如果超过阈值，则生成摘要并移除最早的对话
        """</span>
        <span class="hljs-comment"># 1. 保存新对话</span>
        self.chat_histories.append({
            <span class="hljs-string">'human'</span>: human_query,
            <span class="hljs-string">'ai'</span>: ai_content,
        })

        <span class="hljs-comment"># 2. 检查token数量</span>
        buffer_string = self.get_buffer_string()
        tokens = self.get_num_tokens(buffer_string)

        <span class="hljs-comment"># 3. 超过阈值则生成摘要</span>
        <span class="hljs-keyword">if</span> tokens &gt; self.max_tokens:
            first_chat = self.chat_histories[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取最早的对话</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"生成新的摘要中"</span>)

            <span class="hljs-comment"># 生成新的摘要（旧摘要 + 最早对话）</span>
            self.summary = self.summary_text(
                self.summary,
                <span class="hljs-string">f"human: <span class="hljs-subst">{human_query}</span>\nai: <span class="hljs-subst">{first_chat.get(<span class="hljs-string">'ai'</span>)}</span>"</span>
            )
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"新的摘要: <span class="hljs-subst">{self.summary}</span>"</span>)

            <span class="hljs-comment"># 移除已摘要的对话</span>
            <span class="hljs-keyword">del</span> self.chat_histories[<span class="hljs-number">0</span>]
</code></pre>
<h4 data-id="heading-23">8.4 核心方法：生成摘要</h4>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">summary_text</span>(<span class="hljs-params">self, original_summary: <span class="hljs-built_in">str</span>, new_chat: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">"""
        使用LLM生成新的摘要

        关键点：
        1. 将旧摘要和新对话合并
        2. 保留关键信息（姓名、爱好、性别、重要事件等）
        3. 尽可能还原对话记录

        Args:
            original_summary: 旧的摘要
            new_chat: 新的对话内容

        Returns:
            新生成的摘要
        """</span>
        prompt = <span class="hljs-string">f"""你是一个强大的聊天机器人，请根据用户提供的谈话内容，总结摘要，并将其添加到先前提供的摘要中，返回一个新的摘要，除了新摘要其他任何数据都不要生成，如果用户的对话信息里有一些关键的信息，比方说姓名、爱好、性别、重要事件等等，这些全部都要包括在生成的摘要中，摘要尽可能要还原用户的对话记录。

请不要将&lt;example&gt;标签里的数据当成实际的数据，这里的数据只是一个示例数据，告诉你该如何生成新摘要。

&lt;example&gt;
当前摘要：人类会问人工智能对人工智能的看法，人工智能认为人工智能是一股向善的力量。

新的对话：
Human：为什么你认为人工智能是一股向善的力量？
AI：因为人工智能会帮助人类充分发挥潜力。

新摘要：人类会问人工智能对人工智能的看法，人工智能认为人工智能是一股向善的力量，因为它将帮助人类充分发挥潜力。
&lt;/example&gt;

=====================以下的数据是实际需要处理的数据=====================

当前摘要：<span class="hljs-subst">{original_summary}</span>

新的对话：
<span class="hljs-subst">{new_chat}</span>

请帮用户将上面的信息生成新摘要。"""</span>

        completion = self.client.chat.completions.create(
            model=<span class="hljs-string">"moonshot-v1-8k"</span>,
            messages=[{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: prompt}]
        )
        <span class="hljs-keyword">return</span> completion.choices[<span class="hljs-number">0</span>].message.content
</code></pre>
<h4 data-id="heading-24">8.5 核心方法：加载记忆变量</h4>
<pre><code class="hljs language-python" lang="python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_memory_variables</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:
        <span class="hljs-string">"""
        加载记忆变量，返回格式化的上下文

        Returns:
            包含chat_history的字典，格式为：
            {
                "chat_history": "摘要: xxx\n历史信息: xxx"
            }
        """</span>
        buffer_string = self.get_buffer_string()
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"chat_history"</span>: <span class="hljs-string">f"摘要: <span class="hljs-subst">{self.summary}</span>\n历史信息:<span class="hljs-subst">{buffer_string}</span>"</span>,
        }
</code></pre>
<h4 data-id="heading-25">8.6 完整使用示例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 创建客户端和记忆对象</span>
client = OpenAI(base_url=<span class="hljs-string">'https://api.moonshot.cn/v1'</span>)
memory = ConversationSummaryBufferMemory(summary=<span class="hljs-string">""</span>, chat_histories=[], max_tokens=<span class="hljs-number">300</span>)

<span class="hljs-comment"># 对话循环</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    <span class="hljs-comment"># 1. 获取用户输入</span>
    human_query = <span class="hljs-built_in">input</span>(<span class="hljs-string">"请输入: "</span>)
    <span class="hljs-keyword">if</span> human_query == <span class="hljs-string">'q'</span>:
        <span class="hljs-keyword">break</span>

    <span class="hljs-comment"># 2. 加载历史记忆</span>
    memory_variables = memory.load_memory_variables()

    <span class="hljs-comment"># 3. 构建包含历史的提示词</span>
    answer_prompt = (
        <span class="hljs-string">"你是一个强大的聊天机器人，请根据对应的上下文和用户提问解决问题。\n\n"</span>
        <span class="hljs-string">f"<span class="hljs-subst">{memory_variables.get(<span class="hljs-string">'chat_history'</span>)}</span>\n\n"</span>
        <span class="hljs-string">f"用户的提问是: <span class="hljs-subst">{human_query}</span>"</span>
    )

    <span class="hljs-comment"># 4. 调用LLM（流式输出）</span>
    response = client.chat.completions.create(
        model=<span class="hljs-string">"moonshot-v1-8k"</span>,
        messages=[{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: answer_prompt}],
        stream=<span class="hljs-literal">True</span>
    )

    <span class="hljs-comment"># 5. 打印AI响应</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"AI: "</span>, end=<span class="hljs-string">""</span>)
    ai_content = <span class="hljs-string">""</span>
    <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> response:
        content = chunk.choices[<span class="hljs-number">0</span>].delta.content
        <span class="hljs-keyword">if</span> content <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">break</span>
        ai_content += content
        <span class="hljs-built_in">print</span>(content, end=<span class="hljs-string">""</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span>)

    <span class="hljs-comment"># 6. 保存对话到记忆</span>
    memory.save_content(human_query, ai_content)
</code></pre>
<h4 data-id="heading-26">8.7 代码执行流程图</h4>
<pre><code class="hljs language-scss" lang="scss">用户输入
   ↓
加载历史记忆 (load_memory_variables)
   ↓
构建提示词 (包含摘要 + 缓存对话)
   ↓
调用LLM API (流式输出)
   ↓
保存新对话 (save_content)
   ↓
检查token数 → 超过阈值？
   ↓                    ↓
 否                   是
   ↓                    ↓
  结束          生成新摘要 (summary_text)
                      ↓
                 移除最早对话
                      ↓
                    结束
</code></pre>
<h4 data-id="heading-27">8.8 关键代码说明</h4>



































<table><thead><tr><th>代码片段</th><th>作用</th><th>关键点</th></tr></thead><tbody><tr><td><code>self.chat_histories.append()</code></td><td>添加新对话</td><td>使用字典存储 human/ai 对</td></tr><tr><td><code>get_num_tokens()</code></td><td>计算token数</td><td>简化为字符长度，生产环境可用tiktoken</td></tr><tr><td><code>summary_text()</code></td><td>生成摘要</td><td>精心设计的prompt确保保留关键信息</td></tr><tr><td><code>del self.chat_histories[0]</code></td><td>移除旧对话</td><td>FIFO（先进先出）策略</td></tr><tr><td><code>stream=True</code></td><td>流式输出</td><td>提升用户体验，类似打字效果</td></tr></tbody></table>
<h4 data-id="heading-28">8.9 优化建议</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 1. 使用tiktoken精确计算token数</span>
<span class="hljs-keyword">import</span> tiktoken

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num_tokens</span>(<span class="hljs-params">cls, query: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:
    encoding = tiktoken.encoding_for_model(<span class="hljs-string">"gpt-3.5-turbo"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(encoding.encode(query))

<span class="hljs-comment"># 2. 添加持久化存储（JSON/数据库）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">save_to_disk</span>(<span class="hljs-params">self, filepath: <span class="hljs-built_in">str</span></span>):
    data = {
        <span class="hljs-string">'summary'</span>: self.summary,
        <span class="hljs-string">'chat_histories'</span>: self.chat_histories
    }
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath, <span class="hljs-string">'w'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:
        json.dump(data, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">2</span>)

<span class="hljs-comment"># 3. 添加清空记忆功能</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_memory</span>(<span class="hljs-params">self</span>):
    self.summary = <span class="hljs-string">""</span>
    self.chat_histories = []

<span class="hljs-comment"># 4. 添加异常处理</span>
<span class="hljs-keyword">try</span>:
    self.summary = self.summary_text(self.summary, new_chat)
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"生成摘要失败: <span class="hljs-subst">{e}</span>"</span>)
    <span class="hljs-comment"># 保留原摘要，不删除对话</span>
</code></pre>
<h3 data-id="heading-29">九、总结</h3>
<p>这个学习案例展示了如何使用 OpenAI 原生 SDK 实现一个生产级的对话记忆系统。通过摘要缓存混合策略，既保证了对话的连贯性，又控制了 API 调用成本，是构建长期对话 AI 应用的核心技术之一。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从Hive函数collect到MySQL函数group_concat]]></title>    <link>https://juejin.cn/post/7592166340382326799</link>    <guid>https://juejin.cn/post/7592166340382326799</guid>    <pubDate>2026-01-07T10:14:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592166340382326799" data-draft-id="7592166340382310415" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从Hive函数collect到MySQL函数group_concat"/> <meta itemprop="keywords" content="MySQL"/> <meta itemprop="datePublished" content="2026-01-07T10:14:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="吊睛白额鼠"/> <meta itemprop="url" content="https://juejin.cn/user/1093394692846532"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从Hive函数collect到MySQL函数group_concat
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1093394692846532/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    吊睛白额鼠
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:14:30.000Z" title="Wed Jan 07 2026 10:14:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">问题背景：</h3>
<p>在工作中遇到数据分析时对结果展示的要求。需求如下：
查询在关注时间窗口下（7日）公司相同账户与不同交易对手账户之间的交易行为。
原本预计的展示结果为：</p>











































































<table><thead><tr><th>公司账户</th><th>公司信息</th><th>交易对手账户</th><th>交易对手信息</th><th>交易信息（日期等）</th></tr></thead><tbody><tr><td>66666666</td><td>AAA</td><td>99999991</td><td>BBB1</td><td>2025-11-04</td></tr><tr><td>66666666</td><td>AAA</td><td>99999992</td><td>BBB2</td><td>2025-11-06</td></tr><tr><td>66666666</td><td>AAA</td><td>99999993</td><td>BBB3</td><td>2025-11-15</td></tr><tr><td>66666666</td><td>AAA</td><td>99999994</td><td>BBB4</td><td>2025-11-22</td></tr><tr><td>88888888</td><td>AAA</td><td>99999995</td><td>BBB5</td><td>2025-11-26</td></tr><tr><td>88888888</td><td>AAA</td><td>99999996</td><td>BBB6</td><td>2025-12-01</td></tr><tr><td>88888888</td><td>AAA</td><td>99999997</td><td>BBB7</td><td>2025-12-30</td></tr><tr><td>88888888</td><td>AAA</td><td>99999998</td><td>BBB8</td><td>2026-01-01</td></tr><tr><td>88888888</td><td>AAA</td><td>99999999</td><td>BBB9</td><td>2026-01-04</td></tr></tbody></table>
<p>由于重复数据太多不便于业务人员查看数据之间的关系，经与业务人员讨论后决定调整为如下展示方式：</p>






























<table><thead><tr><th>公司账户</th><th>公司信息</th><th>相关数据</th></tr></thead><tbody><tr><td>66666666</td><td>AAA</td><td>交易对手账户:99999991 交易对手信息:BBB1 交易信息（日期等）:2025-11-04<br/>交易对手账户:99999992 交易对手信息:BBB2 交易信息（日期等）:2025-11-06</td></tr><tr><td>66666666</td><td>AAA</td><td>交易对手账户:99999993 交易对手信息:BBB3 交易信息（日期等）:2025-11-15<br/>交易对手账户:99999994 交易对手信息:BBB4 交易信息（日期等）:2025-11-22</td></tr><tr><td>88888888</td><td>AAA</td><td>交易对手账户:99999995 交易对手信息:BBB5 交易信息（日期等）:2025-11-26<br/>交易对手账户:99999996 交易对手信息:BBB6 交易信息（日期等）:2025-12-01</td></tr><tr><td>88888888</td><td>AAA</td><td>交易对手账户:99999997 交易对手信息:BBB7 交易信息（日期等）:2025-12-30<br/>交易对手账户:99999998 交易对手信息:BBB8 交易信息（日期等）:2026-01-01<br/>交易对手账户:99999999 交易对手信息:BBB9 交易信息（日期等）:2026-01-04</td></tr></tbody></table>
<h3 data-id="heading-1">解决方法：</h3>
<p>这样的展示方式就需要一个合适的聚合函数来进行数据内容汇总。
之前常使用Hive开发这种情况多用collect，但是本次使用的MySQL使用的时候发现没有这个函数。后面决定使用group_concat。
group_concat嵌套concat_ws可以很好的达到上面的效果:</p>
<pre><code class="hljs language-sql" lang="sql">    ,group_concat(concat_ws(<span class="hljs-string">''</span>  
         <span class="hljs-string">' 交易对手账户：'</span>,account  
        ,<span class="hljs-string">' 交易对手信息：'</span>,account_info  
        ,<span class="hljs-string">' 交易信息（日期等）：'</span>,trade_date  
  ) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> trade_date SEPARATOR <span class="hljs-string">';\n'</span>) <span class="hljs-keyword">as</span> 相关数据
</code></pre>
<p>但是使用起来发现如果数据太长会有数据截断的问题。因此如果数据量比较大需要注意以下设置：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 查看和设置 GROUP_CONCAT 相关参数</span>
<span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'group_concat_max_len'</span>;

<span class="hljs-comment">-- 临时设置最大长度（默认1024字节） 会话级配置</span>
<span class="hljs-keyword">SET</span> SESSION group_concat_max_len <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;

<span class="hljs-comment">-- 在查询中设置</span>
<span class="hljs-keyword">SET</span> @<span class="hljs-variable">@group</span>_concat_max_len <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;
</code></pre>
<p>以上就是对于数据汇总展示的一个总结。希望能帮助到需要<strong>展示思路</strong>与需要<strong>聚合思路</strong>的朋友。</p>
<h3 data-id="heading-2">番外：</h3>
<p>后面了解到也可以通过json的方式来展示这部分数据：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-built_in">JSON_ARRAYAGG</span>(  
    <span class="hljs-built_in">JSON_OBJECT</span>(  
         <span class="hljs-string">'交易对手账户'</span>,account  
        ,<span class="hljs-string">'交易对手信息'</span>,account_info  
        ,<span class="hljs-string">'交易信息（日期等）'</span>,trade_date 
    )  
) <span class="hljs-keyword">as</span> 相关数据
</code></pre>
<p>不过问题是展示的字段顺序不可控。这个问题还没有解决的好办法，如果有大佬看到请多做指点。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[记一次Vue 2主应用集成Vue 3子项目的Monorepo迁移踩坑指南]]></title>    <link>https://juejin.cn/post/7592438587388772390</link>    <guid>https://juejin.cn/post/7592438587388772390</guid>    <pubDate>2026-01-07T09:35:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592438587388772390" data-draft-id="7592423411562561562" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="记一次Vue 2主应用集成Vue 3子项目的Monorepo迁移踩坑指南"/> <meta itemprop="keywords" content="前端工程化"/> <meta itemprop="datePublished" content="2026-01-07T09:35:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="user8615818578154"/> <meta itemprop="url" content="https://juejin.cn/user/3549647826599133"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            记一次Vue 2主应用集成Vue 3子项目的Monorepo迁移踩坑指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3549647826599133/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    user8615818578154
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:35:34.000Z" title="Wed Jan 07 2026 09:35:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>最近在进行Monorepo架构调整，需要将一个现有的Vue 3(Vite)项目作为一个子应用 (<code>apps/wj</code>) 迁移到由Vue 2(Webpack)主导的大仓中。本以为只是简单的“文件夹移动”，结果在依赖管理、网络代理和端口映射上踩了一圈坑。</p>
<p>本文记录了从迁移到跑通全流程遇到的4个典型问题及解决方案。</p>
<h2 data-id="heading-1">坑点一：pnpm 严格模式下的“幽灵依赖”</h2>
<h3 data-id="heading-2">💥 现象</h3>
<p>将项目移入大仓后，执行 <code>dev</code> 脚本报错：</p>
<pre><code class="hljs language-Bash" lang="Bash"><span class="hljs-string">'vite'</span> 不是内部或外部命令，也不是可运行的程序
</code></pre>
<p>或者启动后报错找不到 <code>unplugin-auto-import</code>、<code>vue-request</code> 等插件。</p>
<h3 data-id="heading-3">🔍 原因</h3>
<p>原项目可能使用 npm/yarn，存在<strong>依赖提升 (Hoisting)</strong> ，即 <code>devDependencies</code> 即使没写在 <code>package.json</code> 里，依靠根目录 <code>node_modules</code> 也能跑。 但迁移到 <strong>pnpm Monorepo</strong> 后，pnpm 的严格机制要求<strong>所有使用的包必须显式声明</strong>。</p>
<h3 data-id="heading-4">✅ 解决</h3>
<p>在根目录通过 <code>--filter</code> 为子应用补全依赖：</p>
<pre><code class="hljs language-Bash" lang="Bash"><span class="hljs-comment"># 补全构建工具</span>
pnpm add vite @vitejs/plugin-vue vue-tsc -D --filter wj

<span class="hljs-comment"># 补全缺失的业务/构建插件</span>
pnpm add unplugin-auto-import unplugin-vue-components -D --filter wj
pnpm add vue-request --filter wj
</code></pre>
<hr/>
<h2 data-id="heading-5">坑点二：Workspace 内部包的正确引用</h2>
<h3 data-id="heading-6">💥 现象</h3>
<p>Vite 启动报错：</p>
<pre><code class="hljs language-Bash" lang="Bash">Error [ERR_MODULE_NOT_FOUND]: Cannot find package <span class="hljs-string">'configs'</span> imported from ...
</code></pre>
<p>子应用试图引用大仓共享的配置包（<code>packages/configs</code>），但找不到模块。</p>
<h3 data-id="heading-7">🔍 原因</h3>
<p>子应用虽然物理上在 monorepo 里，但 <code>package.json</code> 里没有声明对内部包的依赖，导致软链接未建立。</p>
<h3 data-id="heading-8">✅ 解决</h3>
<p>使用 <code>--workspace</code> 协议建立软链：</p>
<pre><code class="hljs language-Bash" lang="Bash"><span class="hljs-comment"># 将内部包链接给子应用</span>
pnpm add configs --workspace --filter wj
</code></pre>
<p><em>注意：如果共享包内部也用了某些插件（如 <code>@vitejs/plugin-vue</code>），共享包自己也必须安装该插件，否则会报“父级依赖缺失”。</em></p>
<hr/>
<h2 data-id="heading-9">坑点三：Node 高版本 localhost 解析陷阱 (IPv6)</h2>
<h3 data-id="heading-10">💥 现象</h3>
<p>主应用配置了代理转发到子应用，但在浏览器访问时报 <strong>HTTP 500</strong>，终端报错：</p>
<pre><code class="hljs language-Bash" lang="Bash">Error: connect EACCES ::1:5192
</code></pre>
<h3 data-id="heading-11">🔍 原因</h3>
<ul>
<li><strong>环境：</strong> Node.js v17+</li>
<li><strong>机制：</strong> 主应用代理配置写了 <code>target: 'http://localhost:5192'</code>。Node 默认将 <code>localhost</code> 解析为 IPv6 地址 <code>::1</code>。</li>
<li><strong>冲突：</strong> 子应用 (Vite) 默认只监听 IPv4 (<code>127.0.0.1</code>)。主应用去 IPv6 端口找人，自然连不上。</li>
</ul>
<h3 data-id="heading-12">✅ 解决</h3>
<p><strong>方案A（推荐）：</strong> 修改主应用代理配置，强制使用 IPv4 IP。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-comment">// 主应用 vite.config.ts / vue.config.js</span>
<span class="hljs-attr">proxy</span>: {
  <span class="hljs-string">'/wj'</span>: {
    <span class="hljs-attr">target</span>: <span class="hljs-string">'http://127.0.0.1:5192'</span>, <span class="hljs-comment">// 👈 不要写 localhost</span>
    <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<p><strong>方案B：</strong> 让子应用监听所有地址。启动命令改为 <code>vite --host</code>。</p>
<hr/>
<h2 data-id="heading-13">坑点四：主应用代理“漏气” (接口返回 HTML)</h2>
<h3 data-id="heading-14">💥 现象</h3>
<p>页面加载成功，但业务接口（如 <code>/cmisp/api/xxx</code>）报 <strong>304</strong> 或 <strong>200</strong>，查看 Response 内容竟然是 <code>index.html</code> 的代码，导致 JSON 解析失败。</p>
<h3 data-id="heading-15">🔍 原因</h3>
<p>主应用只代理了页面路由 <code>/wj</code>，但子应用发出的 API 请求是 <code>/cmisp</code> 开头的。 主应用不认识 <code>/cmisp</code>，将其当成了前端路由处理，直接返回了 <code>index.html</code>。</p>
<h3 data-id="heading-16">✅ 解决</h3>
<p>在主应用中补全 API 的代理转发规则：</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript"><span class="hljs-comment">// 主应用 vite.config.ts</span>
<span class="hljs-attr">server</span>: {
  <span class="hljs-attr">proxy</span>: {
    <span class="hljs-comment">// 1. 子应用页面资源</span>
    <span class="hljs-string">'/wj'</span>: {
      <span class="hljs-attr">target</span>: <span class="hljs-string">'http://127.0.0.1:5192'</span>,
      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-comment">// 2. 子应用 API 请求 (新增)</span>
    <span class="hljs-string">'/cmisp'</span>: {
      <span class="hljs-attr">target</span>: <span class="hljs-string">'http://127.0.0.1:5192'</span>, <span class="hljs-comment">// 如果是 mock 数据走这里；如果是真实后端填后端 IP</span>
      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
    }
  }
}
</code></pre>
<h2 data-id="heading-17">总结</h2>
<p>Monorepo 迁移不仅仅是文件搬运，核心在于：</p>
<ol>
<li><strong>依赖边界</strong>：pnpm 下必须“谁用谁装”。</li>
<li><strong>网络互通</strong>：Node 高版本下 <code>localhost</code> 的 IPv6 坑需要格外注意。</li>
<li><strong>路由接管</strong>：主应用作为网关，必须接管子应用的所有请求（包括静态资源和 API）。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[提升工作效率的Utils]]></title>    <link>https://juejin.cn/post/7592410399916752937</link>    <guid>https://juejin.cn/post/7592410399916752937</guid>    <pubDate>2026-01-07T09:46:01.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592410399916752937" data-draft-id="7592134330313703467" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="提升工作效率的Utils"/> <meta itemprop="keywords" content="前端,JavaScript,TypeScript"/> <meta itemprop="datePublished" content="2026-01-07T09:46:01.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="王林不想说话"/> <meta itemprop="url" content="https://juejin.cn/user/2963939079754030"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            提升工作效率的Utils
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2963939079754030/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    王林不想说话
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:46:01.000Z" title="Wed Jan 07 2026 09:46:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>总结一些工作中常用到的utils，希望能帮助到大家，增加摸鱼时间</p>
<h3 data-id="heading-0">getHidePhone</h3>
<p>获取脱敏号码</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 隐藏手机号
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} content 内容
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} hideLen 要隐藏的长度，默认为4
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} symbol 符号，默认为*
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} padStartOrEnd 如果平分的长度为奇数，多出的一位填充的位置，默认为end
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Boolean</span>} removeNan 是否移除非数字，默认为true
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">String</span>} 隐藏后的内容
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getHidePhone</span> = (<span class="hljs-params">
  content: <span class="hljs-built_in">string</span>,
  hideLen = <span class="hljs-number">4</span>,
  <span class="hljs-built_in">symbol</span> = <span class="hljs-string">'*'</span>,
  padStartOrEnd: <span class="hljs-string">'start'</span> | <span class="hljs-string">'end'</span> = <span class="hljs-string">'end'</span>,
  removeNan = <span class="hljs-literal">true</span>,
</span>) =&gt; {
  <span class="hljs-comment">// 如果需要先移除非数字</span>
  <span class="hljs-keyword">if</span> (removeNan) {
    content = content.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[^\d]/g</span>, <span class="hljs-string">''</span>)
  }

  <span class="hljs-keyword">const</span> contentLen = content.<span class="hljs-property">length</span>

  <span class="hljs-comment">// 不是字符串、空字符串、要隐藏的长度为0直接返回原始字符串</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getTypeOf</span>(content) !== <span class="hljs-string">'String'</span> || !contentLen || !hideLen) <span class="hljs-keyword">return</span> content
  <span class="hljs-comment">// 隐藏长度大于等于内容长度，直接返回原始字符串长度的符号</span>
  <span class="hljs-keyword">if</span> (contentLen &lt;= hideLen)
    <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">replace</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`\\d{1}`</span>, <span class="hljs-string">'g'</span>), <span class="hljs-string">'*'</span>)

  <span class="hljs-keyword">const</span> remainingLen = contentLen - hideLen
  <span class="hljs-keyword">const</span> splitLen = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(remainingLen / <span class="hljs-number">2</span>)
  <span class="hljs-keyword">let</span> start = splitLen
  <span class="hljs-keyword">let</span> end = splitLen
  <span class="hljs-keyword">if</span> (remainingLen % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (padStartOrEnd === <span class="hljs-string">'start'</span>) {
      start += <span class="hljs-number">1</span>
    } <span class="hljs-keyword">else</span> {
      end += <span class="hljs-number">1</span>
    }
  }

  <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">replace</span>(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^(\\d{<span class="hljs-subst">${start}</span>})\\d{<span class="hljs-subst">${hideLen}</span>}(\\d{<span class="hljs-subst">${end}</span>})$`</span>),
    <span class="hljs-string">`$1<span class="hljs-subst">${<span class="hljs-built_in">symbol</span>.repeat(hideLen)}</span>$2`</span>,
  )
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'15108324289'</span>)) <span class="hljs-comment">// 151****4289</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'151'</span>)) <span class="hljs-comment">// ***</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'1510'</span>)) <span class="hljs-comment">// ***0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">''</span>)) <span class="hljs-comment">// ''</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'15108324289'</span>, <span class="hljs-number">6</span>)) <span class="hljs-comment">// 15******289</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'15108324289'</span>, <span class="hljs-number">40</span>)) <span class="hljs-comment">// ***********</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'15108324289'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">'-'</span>)) <span class="hljs-comment">// 151----4289</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'15108324289'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">'start'</span>)) <span class="hljs-comment">// 1510****289</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'15108324289'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">'end'</span>)) <span class="hljs-comment">// 151****4289</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'151-083%#2  4289'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// 151****4289</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
<span class="hljs-title function_">getHidePhone</span>(<span class="hljs-string">'151-083%#2  4289'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">false</span>),
) <span class="hljs-comment">// 151-083%#2  4289</span>
</code></pre>
<h3 data-id="heading-1">formateContentBySymbol</h3>
<p>格式化内容，根据符号进行格式化，常用于千分位分割</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 格式化内容，根据符号进行格式化
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} content 内容
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} symbol 符号
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} gap 符号之间的间距，默认3个空格
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">String</span>} 格式化后的内容
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">formateContentBySymbol</span> = (<span class="hljs-params">
  content: <span class="hljs-built_in">string</span>,
  <span class="hljs-built_in">symbol</span>: <span class="hljs-built_in">string</span>,
  gap = <span class="hljs-number">3</span>,
</span>) =&gt; {
  <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">replace</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`(\\d{<span class="hljs-subst">${gap}</span>})(?=\\d)`</span>, <span class="hljs-string">'g'</span>), <span class="hljs-string">`$1<span class="hljs-subst">${<span class="hljs-built_in">symbol</span>}</span>`</span>)
}

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 格式化内容，根据符号进行格式化
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} content 内容
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} symbol 符号
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} gap 符号之间的间距，默认3个空格
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">String</span>} 格式化后的内容
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">formateContentBySymbol2</span> = (<span class="hljs-params">
  content: <span class="hljs-built_in">string</span>,
  <span class="hljs-built_in">symbol</span>: <span class="hljs-built_in">string</span>,
  gap = <span class="hljs-number">3</span>,
</span>) =&gt; {
  <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">replace</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`\\B(?=(\\d{<span class="hljs-subst">${gap}</span>})+$)`</span>, <span class="hljs-string">'g'</span>), <span class="hljs-built_in">symbol</span>)
}

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 格式化内容，根据符号进行格式化
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} content 内容
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} symbol 符号
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} gap 符号之间的间距，默认3个空格
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">String</span>} 格式化后的内容
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">formateContentBySymbol3</span> = (<span class="hljs-params">
  content: <span class="hljs-built_in">string</span>,
  <span class="hljs-built_in">symbol</span>: <span class="hljs-built_in">string</span>,
  gap = <span class="hljs-number">3</span>,
</span>) =&gt; {
  <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">replace</span>(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`(\\d)(?=(\\d{<span class="hljs-subst">${gap}</span>})+$)`</span>, <span class="hljs-string">'g'</span>),
    <span class="hljs-string">`$1<span class="hljs-subst">${<span class="hljs-built_in">symbol</span>}</span>`</span>,
  )
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">formateContentBySymbol</span>(<span class="hljs-string">'235789075433254321'</span>, <span class="hljs-string">','</span>)) <span class="hljs-comment">// 235,789,075,433,254,321</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">formateContentBySymbol2</span>(<span class="hljs-string">'235789075433254321'</span>, <span class="hljs-string">','</span>, <span class="hljs-number">7</span>)) <span class="hljs-comment">// 2357,8907543,3254321</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">formateContentBySymbol3</span>(<span class="hljs-string">'235789075433254321'</span>, <span class="hljs-string">','</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 23,57,89,07,54,33,25,43,21</span>
</code></pre>
<h3 data-id="heading-2">zeroNDigitMDecimalReg</h3>
<p>0或者n位的数字，最多m位小数正则</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@desc</span> 0或者n位的数字，最多m位小数
 * <span class="hljs-doctag">@param</span> n n位的数字
 * <span class="hljs-doctag">@param</span> m 最多m位小数
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">RegExp</span>} 返回正则表达式
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> zeroNDigitMDecimalReg = (n = <span class="hljs-number">4</span>, m = <span class="hljs-number">2</span>): <span class="hljs-function"><span class="hljs-params">RegExp</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (!m) {
    <span class="hljs-comment">// 没有小数位的情况</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^(0|([1-9][0-9]{0,<span class="hljs-subst">${n - <span class="hljs-number">1</span>}</span>}))$`</span>)
  }

  <span class="hljs-comment">// 一位小数位的情况</span>
  <span class="hljs-keyword">if</span> (m === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^(0(\\.[1-9])?|([1-9][0-9]{0,<span class="hljs-subst">${n - <span class="hljs-number">1</span>}</span>}(\\.[1-9])?))$`</span>)
  }

  <span class="hljs-comment">// 二位小数位的情况</span>
  <span class="hljs-keyword">if</span> (m === <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(
      <span class="hljs-string">`^(0(\\.(([1-9]{1,2})|0[1-9]))?|([1-9][0-9]{0,<span class="hljs-subst">${
        n - <span class="hljs-number">1</span>
      }</span>}(\\.(([1-9]{1,2})|0[1-9]))?))$`</span>,
    )
  }

  <span class="hljs-comment">// 二位以上小数位的情况</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(
    <span class="hljs-string">`^(0(\\.(([1-9]{1,<span class="hljs-subst">${m - <span class="hljs-number">1</span>}</span>})|([0-9]{1,<span class="hljs-subst">${m - <span class="hljs-number">1</span>}</span>}[1-9]?)))?|([1-9][0-9]{0,<span class="hljs-subst">${
      n - <span class="hljs-number">1</span>
    }</span>}(\\.(([1-9]{1,<span class="hljs-subst">${m - <span class="hljs-number">1</span>}</span>})|([0-9]{1,<span class="hljs-subst">${m - <span class="hljs-number">1</span>}</span>}[1-9]?)))?))$`</span>,
  )
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zeroNDigitMDecimalReg</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'123456789.123456789'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zeroNDigitMDecimalReg</span>(<span class="hljs-number">4</span>, <span class="hljs-number">10</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'1232.123456789'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zeroNDigitMDecimalReg</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.1'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zeroNDigitMDecimalReg</span>(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'13323234.000001'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zeroNDigitMDecimalReg</span>(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'13323234.0000001'</span>)) <span class="hljs-comment">// false</span>
</code></pre>
<h3 data-id="heading-3">nDigitReg</h3>
<p>0或者n位的整数正则</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@desc</span> 0或者n位的整数正则
 * <span class="hljs-doctag">@param</span> n 最多n位的数字
 * <span class="hljs-doctag">@param</span> with0 是否包含0
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">RegExp</span>} 返回正则表达式
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">nDigitReg</span> = (<span class="hljs-params">n = <span class="hljs-number">4</span>, with0?: <span class="hljs-built_in">boolean</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (with0) {
    <span class="hljs-comment">// 包含0的情况</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^(0|([1-9][0-9]{0,<span class="hljs-subst">${n - <span class="hljs-number">1</span>}</span>}))$`</span>)
  }

  <span class="hljs-comment">// 不包含0的情况</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^[1-9][0-9]{0,<span class="hljs-subst">${n - <span class="hljs-number">1</span>}</span>}$`</span>)
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">nDigitReg</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">nDigitReg</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">nDigitReg</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'123456789'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">nDigitReg</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.56789'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">nDigitReg</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'0'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">nDigitReg</span>(<span class="hljs-literal">undefined</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'0'</span>)) <span class="hljs-comment">// false</span>
</code></pre>
<h3 data-id="heading-4">onetonnine</h3>
<p>1-9xxxx  n个9</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@desc</span> 1-9xxxx  n个9
 * <span class="hljs-doctag">@param</span> n n位，一共多少位数字
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">onetonnine</span> = (<span class="hljs-params">n = <span class="hljs-number">3</span></span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^[1-9][0-9]{0,<span class="hljs-subst">${n - <span class="hljs-number">1</span>}</span>}$`</span>)
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'123'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'12343'</span>)) <span class="hljs-comment">// false</span>
</code></pre>
<h3 data-id="heading-5">zerotonnine</h3>
<p>0-9xxxx  n个9</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@desc</span> 0-9xxxx  n个9
 * <span class="hljs-doctag">@param</span> n n位，一共多少位数字
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">zerotonnine</span> = (<span class="hljs-params">n = <span class="hljs-number">3</span></span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^(0|([1-9][0-9]{0,<span class="hljs-subst">${n - <span class="hljs-number">1</span>}</span>}))$`</span>)
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'123'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'12343'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'0'</span>)) <span class="hljs-comment">// true</span>
</code></pre>
<h3 data-id="heading-6">zerotonnine2Decimal</h3>
<p>0-9xxxx n个9, 最多两位小数</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 0-9xxxx n个9, 最多两位小数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} n n位，一共多少位数字，默认4位数
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">RegExp</span>} 正则
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">zerotonnine2Decimal</span> = (<span class="hljs-params">n = <span class="hljs-number">4</span></span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(
    <span class="hljs-string">`^(0(\\.(([1-9]{1,2})|0[1-9]))?|([1-9][0-9]{0,<span class="hljs-subst">${
      n - <span class="hljs-number">1</span>
    }</span>}(\\.(([1-9]{1,2})|0[1-9]))?))$`</span>,
  )
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.00'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.01'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.1'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.10'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.001'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'123456789'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'0'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">zerotonnine2Decimal</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'0.01'</span>)) <span class="hljs-comment">// true</span>
</code></pre>
<h3 data-id="heading-7">onetonnine2Decimal</h3>
<p>1-9xxxx n个9, 最多两位小数</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 1-9xxxx n个9, 最多两位小数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} n n位，一共多少位数字，默认4位数
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">RegExp</span>} 正则
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">onetonnine2Decimal</span> = (<span class="hljs-params">n = <span class="hljs-number">4</span></span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^[1-9][0-9]{0,<span class="hljs-subst">${n - <span class="hljs-number">1</span>}</span>}(\\.(([1-9]{1,2})|0[1-9]))?$`</span>)
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.00'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.01'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.1'</span>)) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.10'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>().<span class="hljs-title function_">test</span>(<span class="hljs-string">'1234.001'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'123456789'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'0'</span>)) <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">onetonnine2Decimal</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">test</span>(<span class="hljs-string">'0.01'</span>)) <span class="hljs-comment">// false</span>
</code></pre>
<h3 data-id="heading-8">setCliboardContent</h3>
<p>复制文本的通用函数</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 复制文本的通用函数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} content 要复制的内容
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">setCliboardContent</span>(<span class="hljs-params">content?: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">if</span> (!content) <span class="hljs-keyword">return</span>

  <span class="hljs-keyword">const</span> selection = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getSelection</span>()
  <span class="hljs-keyword">if</span> (selection?.<span class="hljs-property">rangeCount</span>) {
    selection?.<span class="hljs-title function_">removeAllRanges</span>()
  }
  <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'textarea'</span>)
  el.<span class="hljs-property">value</span> = content || <span class="hljs-string">''</span>
  el.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'readonly'</span>, <span class="hljs-string">''</span>)
  el.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">'absolute'</span>
  el.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">'-9999px'</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(el)
  el.<span class="hljs-title function_">select</span>()
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">execCommand</span>(<span class="hljs-string">'copy'</span>)
  el.<span class="hljs-title function_">remove</span>()
}
</code></pre>
<h3 data-id="heading-9">getCliboardValue</h3>
<p>获取剪切板中的内容</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 获取剪切板中的内容
 * <span class="hljs-doctag">@returns</span> 剪切板内容
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCliboardValue</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'input'</span>)
  el.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">'absolute'</span>
  el.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">'-9999px'</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(el)
  el.<span class="hljs-title function_">select</span>()
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">execCommand</span>(<span class="hljs-string">'paste'</span>)
  <span class="hljs-comment">// 获取文本输入框中的值</span>
  <span class="hljs-keyword">const</span> clipboardValue = el.<span class="hljs-property">value</span>
  el.<span class="hljs-title function_">remove</span>()
  <span class="hljs-keyword">return</span> clipboardValue
}
</code></pre>
<h3 data-id="heading-10">delay</h3>
<p>延迟执行</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 延迟执行
 * <span class="hljs-doctag">@param</span> wait 延迟时间
 * <span class="hljs-doctag">@returns</span>
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">wait = <span class="hljs-number">1000</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, wait))
}
</code></pre>
<h3 data-id="heading-11">getTypeOf</h3>
<p>获取数据类型</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 获取数据类型
 * <span class="hljs-doctag">@param</span> <span class="hljs-variable">data</span>
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">String</span>} 获取到的数据类型
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTypeOf</span>(<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(data).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>)
}
</code></pre>
<h3 data-id="heading-12">trimStart</h3>
<p>去除字符串开头的空格</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 去除字符串开头的空格
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} str 要处理的字符串
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">String</span>} 去除空格后的字符串
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">trimStart</span> = (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getTypeOf</span>(str) !== <span class="hljs-string">'String'</span>) {
    <span class="hljs-keyword">return</span> str
  }
  <span class="hljs-keyword">return</span> str?.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^(\s+)(.*)$/g</span>, <span class="hljs-string">'$2'</span>)
}
</code></pre>
<h3 data-id="heading-13">trimEnd</h3>
<p>去除字符串结尾的空格</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 去除字符串结尾的空格
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} str 要处理的字符串
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">String</span>} 去除空格后的字符串
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">trimEnd</span> = (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getTypeOf</span>(str) !== <span class="hljs-string">'String'</span>) {
    <span class="hljs-keyword">return</span> str
  }
  <span class="hljs-keyword">return</span> str?.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^(.*)(\s+)$/g</span>, <span class="hljs-string">'$1'</span>)
}
</code></pre>
<h3 data-id="heading-14">trimAll</h3>
<p>去除字符串中的所有空格</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 去除字符串中的所有空格
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} str 要处理的字符串
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">String</span>} 去除空格后的字符串
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">trimAll</span> = (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getTypeOf</span>(str) !== <span class="hljs-string">'String'</span>) {
    <span class="hljs-keyword">return</span> str
  }
  <span class="hljs-keyword">return</span> str?.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">''</span>)
}
</code></pre>
<h3 data-id="heading-15">compressPic</h3>
<p>压缩图片</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 压缩图片
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">File</span>} file 要处理的图片文件
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} quality 压缩质量
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;File | Blob&gt;</span>} 压缩后的图片文件
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compressPic</span>(<span class="hljs-params">
  file: File,
  quality = <span class="hljs-number">0.6</span>,
</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">File</span> | <span class="hljs-title class_">Blob</span>&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> reads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>()
      reads.<span class="hljs-title function_">readAsDataURL</span>(file)
      reads.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">{ target }</span>) =&gt;</span> {
        <span class="hljs-comment">// 这里quality的范围是（0-1）</span>
        <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>)
        <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>)!
        <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()
        img.<span class="hljs-property">src</span> = (target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)?.<span class="hljs-property">result</span>
        img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
          <span class="hljs-keyword">const</span> width = img.<span class="hljs-property">width</span>
          <span class="hljs-keyword">const</span> height = img.<span class="hljs-property">height</span>
          canvas.<span class="hljs-property">width</span> = width
          canvas.<span class="hljs-property">height</span> = height
          ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height)
          <span class="hljs-comment">// 转换成base64格式 quality为图片压缩质量 0-1之间  值越小压缩的越大 图片质量越差</span>
          canvas.<span class="hljs-title function_">toBlob</span>(
            <span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> {
              <span class="hljs-title function_">resolve</span>(blob!)
            },
            file.<span class="hljs-property">type</span>,
            quality,
          )
        }
      }
      reads.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">resolve</span>(file)
      }
    } <span class="hljs-keyword">catch</span> {
      <span class="hljs-title function_">resolve</span>(file)
    }
  })
}
</code></pre>
<h3 data-id="heading-16">randomString</h3>
<p>生成指定长度的随机字符串</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 生成指定长度的随机字符串
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} length 输出字符串的长度
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Number</span>} radix 字符串的基数，默认为36（包括0-36）
 * <span class="hljs-doctag">@returns</span> 返回指定长度的随机字符串，全部为大写
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">randomString</span> = (<span class="hljs-params">length: <span class="hljs-built_in">number</span>, radix = <span class="hljs-number">36</span></span>) =&gt; {
  <span class="hljs-comment">// 生成一个随机字符串，基数为radix，并去除前两位"0."</span>
  <span class="hljs-keyword">let</span> str = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(radix).<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>)
  <span class="hljs-comment">// 如果生成的字符串长度大于等于所需长度，则截取前length个字符并转为大写</span>
  <span class="hljs-keyword">if</span> (str.<span class="hljs-property">length</span> &gt;= length) {
    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, length).<span class="hljs-title function_">toLocaleUpperCase</span>()
  }
  <span class="hljs-comment">// 如果字符串长度不足，递归调用自身以生成剩余长度的字符串，并拼接到原字符串上</span>
  str += <span class="hljs-title function_">randomString</span>(length - str.<span class="hljs-property">length</span>, radix)
  <span class="hljs-comment">// 将最终字符串转为大写并返回</span>
  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">toLocaleUpperCase</span>()
}
</code></pre>
<h3 data-id="heading-17">scrollToBottom</h3>
<p>滚动到底部</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 滚动到底部
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} selector 类名
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollToBottom</span> = (<span class="hljs-params">selector?: <span class="hljs-built_in">string</span></span>) =&gt; {
  <span class="hljs-keyword">const</span> domWrapper = selector
    ? <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(selector)
    : <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> <span class="hljs-comment">// 外层容器 出现滚动条的dom</span>
  <span class="hljs-keyword">if</span> (domWrapper) {
    domWrapper.<span class="hljs-title function_">scrollTo</span>({ <span class="hljs-attr">top</span>: domWrapper.<span class="hljs-property">scrollHeight</span>, <span class="hljs-attr">behavior</span>: <span class="hljs-string">'smooth'</span> })
  }
}
</code></pre>
<h3 data-id="heading-18">scrollToTop</h3>
<p>滚动到顶部</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 滚动到顶部
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} selector 类名
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollToTop</span> = (<span class="hljs-params">selector?: <span class="hljs-built_in">string</span></span>) =&gt; {
  <span class="hljs-keyword">const</span> domWrapper = selector
    ? <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(selector)
    : <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> <span class="hljs-comment">// 外层容器 出现滚动条的dom</span>
  <span class="hljs-keyword">if</span> (domWrapper) {
    domWrapper.<span class="hljs-title function_">scrollTo</span>({ <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">behavior</span>: <span class="hljs-string">'smooth'</span> })
  }
}
</code></pre>
<h3 data-id="heading-19">isJSON</h3>
<p>判断是否为JSON字符串</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@description</span> 判断是否为JSON字符串
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} str 字符串
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Boolean</span>} 是否为JSON字符串
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isJSON</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> str !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-comment">// 1、传入值必须是 字符串</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str) <span class="hljs-comment">// 2、仅仅通过 JSON.parse(str)，不能完全检验一个字符串是JSON格式的字符串</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> &amp;&amp; obj) {
      <span class="hljs-comment">//3、还必须是 object 类型</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }
}
</code></pre>
<h3 data-id="heading-20">getRandomIntInclusive</h3>
<p>生成指定范围内的随机整数（包含最小值和最大值）</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * 生成指定范围内的随机整数（包含最小值和最大值）
 * <span class="hljs-doctag">@param</span> min 最小值（包含）
 * <span class="hljs-doctag">@param</span> max 最大值（包含）
 * <span class="hljs-doctag">@returns</span> 指定范围内的随机整数
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getRandomIntInclusive</span>(<span class="hljs-params">
  min: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>,
  max: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span>,
</span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (max - min + <span class="hljs-number">1</span>)) + min
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SpringCloud_Nacos]]></title>    <link>https://juejin.cn/post/7592148975848833067</link>    <guid>https://juejin.cn/post/7592148975848833067</guid>    <pubDate>2026-01-07T10:17:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592148975848833067" data-draft-id="7592236397535969316" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SpringCloud_Nacos"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-07T10:17:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ihgry"/> <meta itemprop="url" content="https://juejin.cn/user/3210229685954718"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SpringCloud_Nacos
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3210229685954718/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ihgry
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:17:13.000Z" title="Wed Jan 07 2026 10:17:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0">基础概念</h4>
<ul>
<li>nacos配置中心通过<code>namespace</code>、<code>group</code> 和 <code>dataId</code> 来唯一确定一条配置，</li>
<li>dataId的格式：<code>${prefix}-${spring.profiles.active}.${file-extension}</code></li>
<li><code>prefix</code>：默认为<code>spring.application.name</code>
<ul>
<li><code>spring.profiles.active</code>：当前激活的环境，当<code>spring.profiles.active</code>为空时，对应的连接符<code>-</code>也将不存在，dataId的拼接格式变 成：<code>${prefix}.${file-extension}</code></li>
<li><code>${file-extension}</code>：默认为<code>properties</code></li>
</ul>
</li>
<li>拉取多个共享文件，要在同一命名空间下，不能跨命名空间</li>
<li>注意springboot和springcloud的版本对应</li>
</ul>
<h4 data-id="heading-1">下载安装</h4>
<ul>
<li>下载：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fnacos%2Ftags" target="_blank" title="https://github.com/alibaba/nacos/tags" ref="nofollow noopener noreferrer">github.com/alibaba/nac…</a></li>
<li>启动：<code>startup.cmd -m standalone</code></li>
<li>访问：<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A8848%2Fnacos%2F" target="_blank" title="http://localhost:8848/nacos/" ref="nofollow noopener noreferrer">http://localhost:8848/nacos/</a>     账号密码：nacos</li>
</ul>
<h4 data-id="heading-2">配置中心</h4>
<ul>
<li>
<p>引入依赖</p>
<pre><code class="hljs language-java" lang="java">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
    &lt;version&gt;<span class="hljs-number">4.1</span><span class="hljs-number">.5</span>&lt;/version&gt;
&lt;/dependency&gt;
    
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
    &lt;version&gt;<span class="hljs-number">2021.0</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>完整<code>bootstrap.properties</code>配置：</p>
<pre><code class="hljs language-properties" lang="properties">spring.application.name=testccb
spring.cloud.nacos.config.username=nacos
spring.cloud.nacos.config.password=nacos
spring.cloud.nacos.config.server-addr=192.168.1.211:8848
spring.cloud.nacos.config.namespace=4f4b-363e-47a5-8a-dbd288c
spring.cloud.nacos.config.group=com.iotsh

# 拉取共享的配置
spring.cloud.nacos.config.extension-configs[0].data-id=testccb.properties
spring.cloud.nacos.config.extension-configs[0].group=ccb
spring.cloud.nacos.config.extension-configs[0].refresh=true
</code></pre>
</li>
</ul>
<h4 data-id="heading-3">注册中心</h4>
<ul>
<li>
<p>引入依赖</p>
<pre><code class="hljs language-java" lang="java">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
    &lt;version&gt;<span class="hljs-number">4.1</span><span class="hljs-number">.5</span>&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
    &lt;version&gt;<span class="hljs-number">2021.0</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
<ul>
<li>
<p>配置文件</p>
<pre><code class="hljs language-properties" lang="properties">spring.cloud.nacos.discovery.server-addr=192.168.1.211:8848
spring.cloud.nacos.discovery.username=nacos
spring.cloud.nacos.discovery.password=nacos
spring.cloud.nacos.discovery.namespace=ed4b94b3-deff-49f1-8973-34029756083d
</code></pre>
</li>
<li>
<p>主启动类：<code>@EnableDiscoveryClient</code></p>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从弹窗变胖到 npm 依赖管理：一次完整的问题排查记录]]></title>    <link>https://juejin.cn/post/7592276645361467392</link>    <guid>https://juejin.cn/post/7592276645361467392</guid>    <pubDate>2026-01-07T09:18:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592276645361467392" data-draft-id="7591156262626082851" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从弹窗变胖到 npm 依赖管理：一次完整的问题排查记录"/> <meta itemprop="keywords" content="前端,NPM,Node.js"/> <meta itemprop="datePublished" content="2026-01-07T09:18:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鹏北海"/> <meta itemprop="url" content="https://juejin.cn/user/1425415102792237"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从弹窗变胖到 npm 依赖管理：一次完整的问题排查记录
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1425415102792237/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鹏北海
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:18:36.000Z" title="Wed Jan 07 2026 09:18:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">踩坑记录：从弹窗变胖到 npm 依赖管理的深度排查</h2>
<blockquote>
<p>2025 年 12 月 26 日</p>
</blockquote>
<h3 data-id="heading-1">一、问题发现</h3>
<p>接手一个老项目，第一天就遇到问题：</p>
<p><strong>npm install 装不上</strong>，要么卡死要么报错。同事让我用 yarn，还给了个 yarn.lock 文件，倒是装上了。</p>
<p>本来以为没事了，结果开发的时候发现：<strong>弹窗怎么胖了一圈？</strong></p>
<p>所有用到 el-dialog 的地方，视觉上都比设计稿大了一点。</p>
<h3 data-id="heading-2">二、问题排查</h3>
<h4 data-id="heading-3">第一步：定位样式来源</h4>
<p>打开 DevTools 看样式，发现 Element Plus 的 el-dialog 有个 padding。</p>
<p>我心想：这 padding 不是一直都有的吗？为啥以前正常现在不正常？</p>
<p>先试着把这个 padding 覆盖掉，弹窗确实恢复正常了。但这不是根本解决方案，得搞清楚为啥会这样。</p>
<h4 data-id="heading-4">第二步：对比版本差异</h4>
<p>我去翻 Element Plus 的 changelog 和源码，发现：</p>
<p><strong>从 2.5.4 版本开始，el-dialog 被强制加了 16px 的 padding。</strong></p>
<p>那问题来了：我本地装的版本为啥比 package.json 里定义的高？</p>
<h4 data-id="heading-5">第三步：追溯依赖变化</h4>
<p>package.json 里写的是：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"element-plus"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^2.3.2"</span>
</code></pre>
<p>这个 <code>^</code> 表示接受 2.x.x 的任何版本。</p>
<p>回想一下我做了什么：因为 npm install 报错，我删了 package-lock.json 重新装。</p>
<p><strong>真相大白</strong>：删掉 lock 文件后，npm 会装 2.x 下最新的版本（比如 2.13.1），然后记录到新的 package-lock.json 里。依赖就这么"偷偷"升级了。</p>
<h4 data-id="heading-6">第四步：追查 npm install 报错原因</h4>
<p>那为啥一开始 npm install 会报错？</p>
<p>我去看了原来的 package-lock.json，发现里面锁定的包镜像地址有问题：</p>

















<table><thead><tr><th>镜像源</th><th>问题描述</th></tr></thead><tbody><tr><td>阿里语雀镜像</td><td>SSL 证书已过期</td></tr><tr><td>旧淘宝镜像</td><td>2024 年淘宝官方已迁移至新域名，旧地址已停服</td></tr></tbody></table>
<p>上网一搜"npm install 报错"，都让删 lock 文件。删了确实能装上，但版本就不对了，这就是个坑。</p>
<h4 data-id="heading-7">第五步：Node 版本冲突</h4>
<p>还有个坑：项目要求用 Node 16.14.0，但只是口头说，没有任何强制措施。</p>
<ul>
<li>我用 16.14.0 装，报错说某个包需要 Node &gt;= 18.12.0</li>
<li>换到 18.12.0，又报错说另一个包需要 Node 16.x</li>
</ul>
<p>原因是之前有人用高版本 Node 装了某些包，这些包对 Node 版本有强依赖，然后提交了 lock 文件。</p>
<h3 data-id="heading-8">三、根因分析</h3>
<p>整个问题链条：</p>
<pre><code class="hljs language-csharp" lang="csharp">旧镜像地址失效
    ↓
npm install 报错
    ↓
删除 package-<span class="hljs-keyword">lock</span>.json
    ↓
依赖版本偷偷升级（^<span class="hljs-number">2.3</span><span class="hljs-number">.2</span> → <span class="hljs-number">2.13</span><span class="hljs-number">.1</span>）
    ↓
引入 Element Plus <span class="hljs-number">2.5</span><span class="hljs-number">.4</span>+ 的破坏性变更
    ↓
弹窗多了 <span class="hljs-number">16</span>px padding
</code></pre>
<p><strong>本质问题</strong>：</p>
<ol>
<li>镜像地址没有统一管理，过期了没人更新</li>
<li>Node 版本没有强制约束，各自为战</li>
<li>包管理器没有锁定，npm/yarn 混用</li>
<li>Element Plus 在次版本搞破坏性变更（这个是他们的锅）</li>
</ol>
<h3 data-id="heading-9">四、解决方案</h3>
<h4 data-id="heading-10">4.1 统一镜像源配置</h4>
<p>把 lock 文件里的旧镜像地址全部替换成新的淘宝镜像。</p>
<p>创建 <code>.npmrc</code> 文件锁定镜像地址（npm 和 pnpm 都读这个文件）：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">registry</span>=https://registry.npmmirror.com
</code></pre>
<p>创建 <code>.yarnrc</code> 文件锁定 yarn 的镜像：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">registry</span> <span class="hljs-string">"https://registry.npmmirror.com"</span>
</code></pre>
<h4 data-id="heading-11">4.2 锁定 Node 版本</h4>
<p>加了 <code>.nvmrc</code> 和 <code>.nvmdrc</code> 文件：</p>
<pre><code class="hljs">16.14.0
</code></pre>
<p>这样用 nvm 或 nvmd 的人切到项目目录会自动切换版本。</p>
<h4 data-id="heading-12">4.3 锁定包管理器</h4>
<p><strong>方法一：packageManager 字段 + Corepack</strong></p>
<p>在 <code>package.json</code> 里加：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"packageManager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm@8.5.0"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>支持的写法：</p>

























<table><thead><tr><th>写法</th><th>说明</th></tr></thead><tbody><tr><td><code>"npm@8.5.0"</code></td><td>使用 npm 8.5.0</td></tr><tr><td><code>"yarn@1.22.19"</code></td><td>使用 yarn classic</td></tr><tr><td><code>"yarn@3.6.0"</code></td><td>使用 yarn berry (v2+)</td></tr><tr><td><code>"pnpm@8.6.0"</code></td><td>使用 pnpm 8.6.0</td></tr></tbody></table>
<blockquote>
<p>注意：只支持精确版本号，不能写 <code>^8.5.0</code>。</p>
</blockquote>
<p>但这个字段单独写没用，得配合 Corepack 才能生效。Corepack 是 Node.js 16.9+ 内置的，但默认是禁用的：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 启用 Corepack（需要管理员权限）</span>
corepack <span class="hljs-built_in">enable</span>

<span class="hljs-comment"># Windows 用管理员终端，Mac/Linux 加 sudo</span>
sudo corepack <span class="hljs-built_in">enable</span>
</code></pre>
<p>启用后的效果：</p>
<ol>
<li>进入项目目录时，Corepack 读取 <code>packageManager</code> 字段</li>
<li>如果本地没有对应版本，自动下载</li>
<li>用错包管理器直接报错</li>
<li>版本不对也报错</li>
</ol>
<p><strong>方法二：preinstall 脚本</strong></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"preinstall"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npx only-allow npm"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>只允许用 npm，用 yarn 或 pnpm 装就报错。</p>
<blockquote>
<p>注意：<code>only-allow</code> 只能限制包管理器类型，不能限制 Node 版本。</p>
</blockquote>
<p><strong>方法三：engines 字段限制 Node 版本</strong></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"engines"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&gt;=16.14.0 &lt;17.0.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"npm"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&gt;=8.0.0"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><code>engines</code> 支持多种写法：</p>





























<table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>"16.14.0"</code></td><td>精确版本</td></tr><tr><td><code>"&gt;=16.14.0 &lt;17.0.0"</code></td><td>范围版本</td></tr><tr><td><code>"~16.14.0"</code></td><td>允许 16.14.x</td></tr><tr><td><code>"^16.14.0"</code></td><td>允许 16.x.x</td></tr><tr><td><code>"16.x || 18.x"</code></td><td>多版本支持</td></tr></tbody></table>
<p>配合 <code>.npmrc</code> 开启严格模式才能真正生效：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">engine-strict</span>=<span class="hljs-literal">true</span>
</code></pre>
<p>启用后版本不对直接报错。</p>
<h4 data-id="heading-13">4.4 配置依赖版本前缀策略</h4>
<p>npm 默认用 <code>^</code> 前缀，风险太大。可以在 <code>.npmrc</code> 里改：</p>

























<table><thead><tr><th>配置值</th><th>效果</th><th>示例</th></tr></thead><tbody><tr><td><code>save-prefix=^</code></td><td>允许次版本升级</td><td><code>^2.3.2</code></td></tr><tr><td><code>save-prefix=~</code></td><td>仅允许修订版本升级</td><td><code>~2.3.2</code></td></tr><tr><td><code>save-exact=true</code></td><td>精确版本，无前缀</td><td><code>2.3.2</code></td></tr></tbody></table>
<p><strong>推荐用 <code>~</code></strong>：</p>
<p>npm/pnpm 配置（<code>.npmrc</code>）：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">save-prefix</span>=~
</code></pre>
<p>yarn 配置（<code>.yarnrc</code>）：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">save-prefix</span> <span class="hljs-string">"~"</span>
</code></pre>
<p>为啥选 <code>~</code>？</p>

























<table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>精确版本</td><td>完全锁定，零风险</td><td>无法自动获取 bug 修复</td></tr><tr><td><code>~</code> 波浪号</td><td>自动获取修订版本，风险可控</td><td>极小概率遇到修订版本引入问题</td></tr><tr><td><code>^</code> 脱字符</td><td>自动获取新功能和修复</td><td>风险较高，如本次 Element Plus 问题</td></tr></tbody></table>
<p>修订版本按 SemVer 规范只包含 bug 修复，向下兼容。配合 lock 文件提交，实际安装版本还是锁定的，只有删 lock 文件重装才会升级。</p>
<p><strong>敏感依赖单独处理</strong>：</p>
<p>UI 组件库这种核心依赖，建议直接在 <code>package.json</code> 里用精确版本：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"element-plus"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2.3.2"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"vue"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"~3.3.4"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-14">4.5 Element Plus 样式修复</h4>
<p><strong>当前方案</strong>：</p>
<ol>
<li>把 Element Plus 版本固定为精确版本（去掉 <code>^</code>），防止后续静默升级</li>
<li>对已受影响的弹窗组件，单独进行样式覆盖：</li>
</ol>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-class">.affected-dialog</span> <span class="hljs-selector-class">.el-dialog</span> {
  <span class="hljs-attr">--el-dialog-padding-primary</span>: <span class="hljs-number">0</span>;
}
</code></pre>
<p><strong>其他可选方案</strong>：</p>
<ul>
<li>全局样式覆盖（影响范围大，需充分测试）</li>
<li>回退 Element Plus 版本至 2.5.3 或更低</li>
</ul>
<h3 data-id="heading-15">五、Element Plus 的问题</h3>
<p>这事本质上是 Element Plus 的锅。</p>
<p>在 2.5.4 这个<strong>次版本</strong>里加了个强制 padding，这是<strong>破坏性变更</strong>。按 SemVer 语义化版本规范，破坏性变更应该放到大版本（3.x）里。</p>
<h3 data-id="heading-16">六、知识点总结</h3>
<h4 data-id="heading-17">版本号前缀</h4>





















<table><thead><tr><th>写法</th><th>含义</th></tr></thead><tbody><tr><td><code>^2.3.2</code></td><td>2.x.x 都行，最低 2.3.2</td></tr><tr><td><code>~2.3.2</code></td><td>2.3.x 都行，最低 2.3.2</td></tr><tr><td><code>2.3.2</code></td><td>精确版本，就要 2.3.2</td></tr></tbody></table>
<h4 data-id="heading-18">SemVer 语义化版本规范</h4>
<pre><code class="hljs">主版本.次版本.修订版本
   │      │      └── bug 修复，向下兼容
   │      └───────── 新功能，向下兼容
   └──────────────── 破坏性变更，不兼容
</code></pre>
<h4 data-id="heading-19">依赖管理配置文件</h4>





































<table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>.npmrc</td><td>npm/pnpm 配置，镜像地址、严格模式等</td></tr><tr><td>.yarnrc</td><td>yarn 配置</td></tr><tr><td>.nvmrc</td><td>nvm 的 Node 版本</td></tr><tr><td>.nvmdrc</td><td>nvmd 的 Node 版本</td></tr><tr><td>package-lock.json</td><td>npm 的依赖锁定</td></tr><tr><td>yarn.lock</td><td>yarn 的依赖锁定</td></tr><tr><td>pnpm-lock.yaml</td><td>pnpm 的依赖锁定</td></tr></tbody></table>
<h3 data-id="heading-20">七、最佳实践</h3>


















































<table><thead><tr><th>优先级</th><th>措施</th><th>说明</th></tr></thead><tbody><tr><td>高</td><td>提交 lock 文件</td><td>防止版本漂移的核心</td></tr><tr><td>高</td><td>配置 <code>.npmrc</code> / <code>.yarnrc</code></td><td>统一镜像源</td></tr><tr><td>高</td><td>配置 <code>.nvmrc</code> / <code>.nvmdrc</code></td><td>本地开发版本提示</td></tr><tr><td>高</td><td>敏感依赖精确版本</td><td>UI 库等去掉 <code>^</code> 前缀</td></tr><tr><td>中</td><td>配置 <code>save-prefix=~</code></td><td>控制新依赖版本范围</td></tr><tr><td>中</td><td>配置 <code>engines</code> + <code>engine-strict</code></td><td>强制 Node 版本检查</td></tr><tr><td>中</td><td><code>only-allow</code> 脚本</td><td>限制包管理器类型</td></tr><tr><td>低</td><td><code>packageManager</code> + Corepack</td><td>锁定包管理器版本</td></tr></tbody></table>
<h3 data-id="heading-21">八、经验教训</h3>
<ol>
<li><strong>lock 文件必须提交</strong>，别让依赖偷偷升级</li>
<li><strong>镜像地址要统一管理</strong>，用 .npmrc/.yarnrc 锁定</li>
<li><strong>Node 版本要强制约束</strong>，用 .nvmrc + engines + engine-strict</li>
<li><strong>包管理器也要锁</strong>，packageManager + Corepack 或 only-allow</li>
<li><strong>敏感依赖用精确版本</strong>，UI 库这种别用 <code>^</code></li>
<li><strong>新依赖用 <code>~</code> 前缀</strong>，比 <code>^</code> 安全，比精确版本灵活</li>
<li><strong>删 lock 文件要谨慎</strong>，可能引入版本漂移</li>
<li><strong>遇到问题要追根溯源</strong>，不能只解决表面现象</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript算法 - 冒泡排序]]></title>    <link>https://juejin.cn/post/7592255257347899433</link>    <guid>https://juejin.cn/post/7592255257347899433</guid>    <pubDate>2026-01-07T10:03:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592255257347899433" data-draft-id="7592236397535674404" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript算法 - 冒泡排序"/> <meta itemprop="keywords" content="排序算法"/> <meta itemprop="datePublished" content="2026-01-07T10:03:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="梅川_酷子"/> <meta itemprop="url" content="https://juejin.cn/user/1488075996274921"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript算法 - 冒泡排序
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1488075996274921/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    梅川_酷子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:03:31.000Z" title="Wed Jan 07 2026 10:03:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">冒泡排序（从小到大）</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0517fa5554bf44229f0442086a737421~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5qKF5bedX-mFt-WtkA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768385010&amp;x-signature=haL45J2MFkq5FlXh%2F5DUL%2FyfExI%3D" alt="生成水面冒泡图片.png" loading="lazy"/></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
* 文字描述，毕竟不如口语表达，所以，这里有一些帮助阅读的方法
* 释义：
*    项："数组的 0 项"，指的是数组 index 为 0 的值
*
* tips:
* 1. 将会用到的数组，都是复杂度最高的数组，也就是原始排序为 [3,2,1] 这样从大到小的数组，有助于直观理解
* 2. 如果觉得有点乱，就关注函数返回的结果。上一步结果，就是我们下一步的根本
*/</span>
</code></pre>
<h5 data-id="heading-1">如果数组一共有两项</h5>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">const</span> myArr = [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>]
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">mySort</span> = (<span class="hljs-params">arr</span>) =&gt; {
    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; arr[<span class="hljs-number">1</span>]) {
      ;[arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]] = [arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">0</span>]]
    }
    <span class="hljs-keyword">return</span> arr
  }
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">mySort</span>(myArr)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result, <span class="hljs-string">'result'</span>) <span class="hljs-comment">// [ 8, 9 ]</span>
</code></pre>
<p>此时数组变为：[ 8, 9 ]
总结：以上是最简单的排序。数组只有两项，0 项和 1 项。比大小、换位，没了</p>
<h5 data-id="heading-2">如果有三个呢</h5>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">const</span> myArr = [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>]
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">mySort</span> = (<span class="hljs-params">arr</span>) =&gt; {
    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; arr[<span class="hljs-number">1</span>]) {
      ;[arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]] = [arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">0</span>]]
    }
    <span class="hljs-keyword">return</span> arr
  }
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">mySort</span>(myArr)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result, <span class="hljs-string">'result'</span>)<span class="hljs-comment">// [ 8, 9, 7 ]</span>
</code></pre>
<p>此时的数组变为：[ 8, 9, 7 ]<br/>
看着这个数组，总结：预料之中，0 项和 1 项换位。接下来呢？</p>
<p>排序后数组的含义可以解释为：<br/>
可以确定：数组的 1 项，是数组 0 项、1 项中的的<strong>最大值</strong><br/>
不能确定：数组的 2 项，更大还是更小</p>
<p>！那么，让数组的 1、2 项比大小，就确定了数组中<strong>最大</strong>的是谁</p>
<h5 data-id="heading-3">代码延申</h5>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">const</span> myArr = [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>]
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">mySort</span> = (<span class="hljs-params">arr</span>) =&gt; {
    <span class="hljs-comment">// 第一步</span>
    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; arr[<span class="hljs-number">1</span>]) {
      ;[arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]] = [arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">0</span>]]
    }
    <span class="hljs-comment">// 走到此处，arr 的值为 [ 8, 9, 7 ]</span>

    <span class="hljs-comment">// 第二步</span>
    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">1</span>] &gt; arr[<span class="hljs-number">2</span>]) {
      ;[arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>]] = [arr[<span class="hljs-number">2</span>], arr[<span class="hljs-number">1</span>]]
    }
    <span class="hljs-comment">// 走到此处，arr 的值为 [ 8, 7, 9 ]</span>
    <span class="hljs-keyword">return</span> arr
  }
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">mySort</span>(myArr)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result, <span class="hljs-string">'result'</span>) <span class="hljs-comment">// [ 8, 7, 9 ]</span>
</code></pre>
<p>此时的数组变为：[ 8, 7, 9 ]</p>
<p>看着这个数组，总结：延申后，我们确定了最大值，且移动到了最右边<br/>
希望这里，你会感受到思路在变清晰</p>
<p>排序后的数组含义可以解释为<br/>
可以确定：0 项和 1 项，都比 2 项小。2 项，是数组的<strong>最大值</strong><br/>
不能确定：数组的 0 项、1 项，谁大</p>
<p>！那么，让数组的 0、1 项比大小。（因为已经确定了 2 项最大，那么，确定了 0、1 的大小关系，就确定了全部的大小关系）</p>
<h5 data-id="heading-4">代码再延申</h5>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">mySort</span> = (<span class="hljs-params">arr</span>) =&gt; {
    <span class="hljs-comment">// 第一步</span>
    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; arr[<span class="hljs-number">1</span>]) {
      ;[arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]] = [arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">0</span>]]
    }
    <span class="hljs-comment">// 走到此处，arr 的值为 [ 8, 9, 7 ]</span>

    <span class="hljs-comment">// 第二步</span>
    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">1</span>] &gt; arr[<span class="hljs-number">2</span>]) {
      ;[arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">2</span>]] = [arr[<span class="hljs-number">2</span>], arr[<span class="hljs-number">1</span>]]
    }
    <span class="hljs-comment">// 走到此处，arr 的值为 [ 8, 7, 9 ]</span>

    <span class="hljs-comment">// 第三步（与 第一步 完全一致）</span>
    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] &gt; arr[<span class="hljs-number">1</span>]) {
      ;[arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]] = [arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">0</span>]]
    }
    <span class="hljs-comment">// 走到此处，arr 的值为[ 7, 8, 9 ]</span>
    <span class="hljs-keyword">return</span> arr
  }
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">mySort</span>(myArr)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result, <span class="hljs-string">'result'</span>) <span class="hljs-comment">// [ 7, 8, 9 ]</span>
</code></pre>
<p>此时的数组变为：[ 7, 8, 9 ]，是我们要的结果</p>
<h4 data-id="heading-5">思路总结：</h4>
<pre><code class="hljs language-markdown" lang="markdown">我们排序的方式为：  
<span class="hljs-code">    0、1 对比换位，1、2 对比换位，确定 2  
    0、1 对比换位，确定 0、1  
</span></code></pre>
<h4 data-id="heading-6">思路扩展：</h4>
<pre><code class="hljs language-markdown" lang="markdown">尝试想象一下，当数组的数量为四个
<span class="hljs-code">    0、1 对比换位，1、2 对比换位，2、3 对比换位，确定 3
然后再重复一下刚刚实现的经过
    0、1 对比换位，1、2 对比换位，确定 2
    0、1 对比换位，确定 0、1
</span></code></pre>
<h6 data-id="heading-7">至此，一种算法入门的排序思路已经出现，它被称为：冒泡排序 ~咕嘟咕嘟</h6>
<h4 data-id="heading-8">根据思路扩展，尝试实现算法：</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 首先，写出第一轮循环对比：得到数组中最大值并移动到最右边</span>
  <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>]
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">bubbleSort</span> = (<span class="hljs-params">arr</span>) =&gt; {
    <span class="hljs-comment">// 先把之前的对比的判断，把索引改成动态的</span>
    <span class="hljs-comment">// if (arr[i] &gt; arr[i + 1]) {</span>
    <span class="hljs-comment">//   ;[arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]</span>
    <span class="hljs-comment">// }</span>
    
    <span class="hljs-comment">// 首先想到for循环。能写出来什么样呢</span>
    <span class="hljs-comment">// for()</span>
    <span class="hljs-comment">// 我们需要用一些数字。跟循环的次数有关</span>
    <span class="hljs-comment">// 一般而言，都会拿数组的长度来用。这里，数组的长度有什么用处</span>
    <span class="hljs-comment">// arr.length // 4</span>
    <span class="hljs-comment">// for (let i = 0; i &lt; ???; i++) {</span>
    <span class="hljs-comment">//   if (arr[i] &gt; arr[i + 1]) {</span>
    <span class="hljs-comment">//       ;[arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]</span>
    <span class="hljs-comment">//     }</span>
    <span class="hljs-comment">// }</span>
    
    <span class="hljs-comment">// 关键是，i 要小于几呢？那就先要确定，我们要对比多少次，然后再给出限制</span>
    <span class="hljs-comment">// 这个对比的次数，要依据 &lt; 思路扩展 &gt; 中的第一轮对比！其中第一轮，经过了 3 次对比换位</span>
    <span class="hljs-comment">// 又因为我们是从 0 开始的。所以，要拿到的数字是0、1、2，所以要小于3</span>
    <span class="hljs-comment">// 数组的长度跟这个数字的关系就是 length - 1，这就是我们要小于的值</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
      <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) {
        ;[arr[i], arr[i + <span class="hljs-number">1</span>]] = [arr[i + <span class="hljs-number">1</span>], arr[i]]
      }
    }
    <span class="hljs-keyword">return</span> arr
    <span class="hljs-comment">// 如果从 1 开始，那就另一回事了</span>
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bubbleSort</span>(arr)) <span class="hljs-comment">// [ 8, 7, 6, 9 ]</span>
</code></pre>
<p>这时候我们已经把最大的移动到了最右边，第一步完成了<br/>
然后呢？接下来，我们要对比前三个，不对比第四个了。这个怎么写啊<br/>
我们要让这个循环再来一遍。但是，循环次数要少一次。重要！！！<br/>
让循环再来一次，也就是说，让这个循环循环</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">bubbleSort</span> = (<span class="hljs-params">arr</span>) =&gt; {
    <span class="hljs-comment">// for()</span>
    <span class="hljs-comment">// 外边这个循环怎么加呢，要让里面的循环，走几轮呢？跟里面的循环有什么关系呢？</span>
    <span class="hljs-comment">// 再一次，依据 &lt; 思路扩展 &gt; ，要让里面循环 3 轮，就能得到结果了</span>
    <span class="hljs-comment">// 里面循环对比的次数不断减 1 的，那让外面的循环不断减 1，并让这个数字同步到里面对 i 的限制</span>
    <span class="hljs-comment">// for(let j = ???; j &gt;= 0; j--){</span>
    <span class="hljs-comment">//    for (let i = 0; i &lt; arr.length - 1; i++) {</span>
    <span class="hljs-comment">//      if (arr[i] &gt; arr[i + 1]) {</span>
    <span class="hljs-comment">//        ;[arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]</span>
    <span class="hljs-comment">//      }</span>
    <span class="hljs-comment">//    }</span>
    <span class="hljs-comment">// }</span>
    <span class="hljs-comment">// 让外面的 j ，设定为里面的 i 的初始值，然后逐渐变小，最终等于 0，然后结束</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) {
        <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) {
          ;[arr[i], arr[i + <span class="hljs-number">1</span>]] = [arr[i + <span class="hljs-number">1</span>], arr[i]]
        }
      }
    }
    <span class="hljs-keyword">return</span> arr
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bubbleSort</span>(arr)) <span class="hljs-comment">// [ 6, 7, 8, 9 ]</span>
</code></pre>
<h5 data-id="heading-9">主线代码完成</h5>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">bubbleSort</span> = (<span class="hljs-params">arr</span>) =&gt; {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) {
        <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) {
          ;[arr[i], arr[i + <span class="hljs-number">1</span>]] = [arr[i + <span class="hljs-number">1</span>], arr[i]]
        }
      }
    }
    <span class="hljs-keyword">return</span> arr
  }
<span class="hljs-comment">// 随便输入一些，看看效果</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bubbleSort</span>([<span class="hljs-number">543</span>, <span class="hljs-number">4</span>, <span class="hljs-number">76</span>, <span class="hljs-number">524</span>, <span class="hljs-number">24</span>, <span class="hljs-number">65</span>, <span class="hljs-number">23</span>, <span class="hljs-number">235</span>, <span class="hljs-number">3245</span>])) <span class="hljs-comment">// [ 4, 23, 24, 65, 76, 235, 524, 543, 3245 ]</span>
</code></pre>
<h5 data-id="heading-10">后续优化：隔离数据源、减少非必要性能开销</h5>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">bubbleSort</span> = (<span class="hljs-params">array</span>) =&gt; {
    <span class="hljs-keyword">const</span> arr = [...array]
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) {
      <span class="hljs-keyword">let</span> swapped = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) {
        <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) {
          ;[arr[i], arr[i + <span class="hljs-number">1</span>]] = [arr[i + <span class="hljs-number">1</span>], arr[i]]
          swapped = <span class="hljs-literal">true</span>
        }
      }
      <span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>
    }
    <span class="hljs-keyword">return</span> arr
  }
</code></pre>
<p>完成。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[后端问前端：我的接口请求花了多少秒？为啥那么慢，是你慢还是我慢？]]></title>    <link>https://juejin.cn/post/7592423411563167770</link>    <guid>https://juejin.cn/post/7592423411563167770</guid>    <pubDate>2026-01-07T10:10:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592423411563167770" data-draft-id="7592423411562840090" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="后端问前端：我的接口请求花了多少秒？为啥那么慢，是你慢还是我慢？"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-07T10:10:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="江湖文人"/> <meta itemprop="url" content="https://juejin.cn/user/3044986347066480"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            后端问前端：我的接口请求花了多少秒？为啥那么慢，是你慢还是我慢？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3044986347066480/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    江湖文人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:10:12.000Z" title="Wed Jan 07 2026 10:10:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/53b2669b859e4a718c010c50a95e41b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rGf5rmW5paH5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768385412&amp;x-signature=q98fB%2BJVpNV%2BdvMqXJlZq59%2FKQc%3D" alt="image.png" loading="lazy"/></p>
<p>不好意思，你说你看不懂接口 用了多少秒？我来告诉大家，因为我也要写记录📝。</p>
<p>我先把答案说出来，总耗时8.54秒。</p>
<ul>
<li>排队(<code>Queued</code>): <code>24.52ms</code></li>
<li>连接(<code>Connection Start</code>): <code>0.86ms</code></li>
<li>请求发送(<code>Request sent</code>): <code>0.23ms</code></li>
<li>等待服务器响应(<code>Waiting for server response</code>): <code>8.39</code>（这部分时间最长）</li>
<li>内容下载(<code>Content Download</code>): <code>126.61ms</code></li>
</ul>
<p>Explanation在最后一行，给出是8.54秒，也就是请求接口加起来总时间是<code>8.54</code>秒。</p>
<hr/>
<p>“Queued at 1.1 min” 和 “Started at 1.1 min” 是在网络性能分析工具（比如 Chrome DevTools 的性能瀑布图）中常见的描述，<strong>表示这次请求在整个页面加载过程中的出现时间点</strong>，而不是请求本身的实际时长。</p>
<h2 data-id="heading-0">具体含义：</h2>
<ul>
<li><code>Queued at 1.1 min</code>：
表示在页面开始加载后的<code>1.1分钟</code>，这个请求被放入浏览器的队列中等待排队。</li>
</ul>
<p>可能是因为：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-deletion">- 浏览器对同一域名有连接数限制（例如6个并发），所以后续请求需要排队。</span>
<span class="hljs-deletion">- 资源优先级较低，需要等其他更高优先级请求先处理。</span>
</code></pre>
<ul>
<li><code>Started at 1.1 min</code></li>
</ul>
<p>表示在页面加载开始后的<code>1.1分钟</code>，这个请求<code>开始真正被处理</code>（例如开始建立连接）。</p>
<p>这两个时间相同（都是<code>1.1</code>分钟），说明<code>这个请求在进入队列后几乎没有排队</code>，很快就开始了实际请求阶段。</p>
<p>换句话说：</p>
<ul>
<li><code>1.1</code>分钟时它被加入队列。</li>
<li><code>同样在1.1分钟时</code>它就开始了连接阶段（<code>Stalled</code>、<code>Request/Response</code>等）。</li>
</ul>
<p>所以，"Queued"和"Started at"是对整个页面加载时间线中的<code>时间点标记</code>，帮助你理解该请求在页面声明周期中何时发生，而不影响请求自身的<code>8.54</code>秒耗时。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[DMC发送M-SEARCH请求，DMR响应流程]]></title>    <link>https://juejin.cn/post/7592451049232990254</link>    <guid>https://juejin.cn/post/7592451049232990254</guid>    <pubDate>2026-01-07T10:22:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592451049232990254" data-draft-id="7592423411563200538" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="DMC发送M-SEARCH请求，DMR响应流程"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-01-07T10:22:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="qwepoilkjasd"/> <meta itemprop="url" content="https://juejin.cn/user/318221180214507"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            DMC发送M-SEARCH请求，DMR响应流程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/318221180214507/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    qwepoilkjasd
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:22:28.000Z" title="Wed Jan 07 2026 10:22:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">DMC发送M-SEARCH请求，DMR响应的完整函数调用链</h2>
<h3 data-id="heading-1">概览</h3>
<p>当DMC（Digital Media Controller）在网络中发送M-SEARCH多播搜索请求时，DMR（Digital Media Receiver）设备需要接收并响应该请求。下面是完整的函数调用链及详细说明。</p>
<hr/>
<h3 data-id="heading-2">1. 网络数据接收阶段</h3>
<h4 data-id="heading-3">1.1 SSDP监听启动</h4>
<pre><code class="hljs language-css" lang="css">PLT_UPnP::<span class="hljs-built_in">Start</span>()
  └─&gt; PLT_DeviceHost::<span class="hljs-built_in">Start</span>(PLT_SsdpListenTask* task)
      └─&gt; m_TaskManager-&gt;<span class="hljs-built_in">StartTask</span>(PLT_SsdpListenTask) 
          ├─&gt; 创建UDP多播套接字，监听多播地址 <span class="hljs-number">239.255</span>.<span class="hljs-number">255.250</span>:<span class="hljs-number">1900</span>
          ├─&gt; 加入多播组
          └─&gt; 持续监听SSDP数据包
</code></pre>
<h4 data-id="heading-4">1.2 M-SEARCH数据包接收</h4>
<pre><code class="hljs language-css" lang="css">PLT_SsdpListenTask::<span class="hljs-built_in">DoRun</span>()（运行在任务线程中）
  └─&gt; PLT_HttpServerSocketTask::<span class="hljs-built_in">Run</span>()
      └─&gt; 循环接收UDP多播数据包
          ├─&gt; <span class="hljs-built_in">GetInputStream</span>() 
          │   └─&gt; 将UDP数据包转换为流 (PLT_InputDatagramStream)
          └─&gt; NPT_HttpClient::<span class="hljs-built_in">ReadRequest</span>()
              └─&gt; 解析HTTP格式的M-SEARCH请求
</code></pre>
<hr/>
<h3 data-id="heading-5">2. M-SEARCH请求处理阶段</h3>
<h4 data-id="heading-6">2.1 请求处理和监听器通知</h4>
<pre><code class="hljs language-css" lang="css">PLT_SsdpListenTask::<span class="hljs-built_in">SetupResponse</span>()
  │
  ├─&gt; 获取SSDP请求和请求上下文（包含源IP和端口）
  │
  └─&gt; m_Listeners.<span class="hljs-built_in">Apply</span>(PLT_SsdpPacketListenerIterator)
      │
      └─&gt; 遍历所有已注册的SSDP监听器，每个监听器执行：
          │
          └─&gt; PLT_SsdpPacketListenerIterator::<span class="hljs-built_in">operator</span>()()
              │
              └─&gt; listener-&gt;<span class="hljs-built_in">OnSsdpPacket</span>(request, context)
                  │
                  └─&gt; PLT_DeviceHost::<span class="hljs-built_in">OnSsdpPacket</span>()
</code></pre>
<h4 data-id="heading-7">2.2 OnSsdpPacket - DMR设备接收处理</h4>
<pre><code class="hljs language-scss" lang="scss">PLT_DeviceHost::<span class="hljs-built_in">OnSsdpPacket</span>(request, context)
{
    <span class="hljs-comment">// 1. 提取请求信息</span>
    ├─ 获取请求者IP地址：context<span class="hljs-selector-class">.GetRemoteAddress</span>()<span class="hljs-selector-class">.GetIpAddress</span>()
    ├─ 获取请求方法：request<span class="hljs-selector-class">.GetMethod</span>()      <span class="hljs-comment">// 应该是 "M-SEARCH"</span>
    ├─ 获取搜索目标：PLT_UPnPMessageHelper::<span class="hljs-built_in">GetST</span>(request)
    ├─ 获取延迟时间：PLT_UPnPMessageHelper::<span class="hljs-built_in">GetMX</span>(request)
    └─ 获取手册字段：PLT_UPnPMessageHelper::<span class="hljs-built_in">GetMAN</span>(request)
    
    // <span class="hljs-number">2</span>. 验证请求格式
    ├─ 验证ST字段不为空
    ├─ 验证URL为 <span class="hljs-string">"*"</span>
    ├─ 验证协议为 <span class="hljs-string">"HTTP/1.1"</span>
    ├─ 验证MAN头为 <span class="hljs-string">"ssdp:discover"</span>
    └─ 验证MX不为<span class="hljs-number">0</span>
    
    // <span class="hljs-number">3</span>. 关键步骤：创建搜索响应任务
    ├─ 生成随机延迟时间（<span class="hljs-number">0</span>到MX秒之间）
    │   └─&gt; 目的：避免网络风暴（所有设备同时回应）
    │
    ├─ 创建 PLT_SsdpDeviceSearchResponseTask 对象
    │   └─&gt; 参数：
    │       ├─ this (PLT_DeviceHost*)
    │       ├─ context.<span class="hljs-built_in">GetRemoteAddress</span>() (请求者地址)
    │       └─ *st (搜索目标类型)
    │
    └─ m_TaskManager-&gt;<span class="hljs-built_in">StartTask</span>(task, &amp;timer)
        └─&gt; 在任务管理器中注册任务，延迟时间后执行
}
</code></pre>
<p><strong>关键逻辑说明：</strong></p>
<ul>
<li>M-SEARCH是一个多播请求，DMR需要检查该请求是否与自己的设备类型匹配</li>
<li>为了避免网络风暴，DMR不是立即回应，而是等待一个随机的延迟时间（0到MX秒）</li>
<li>每个设备都遵循这个规则，这样可以减少网络中的碰撞和拥塞</li>
</ul>
<hr/>
<h3 data-id="heading-8">3. 搜索响应任务执行阶段</h3>
<h4 data-id="heading-9">3.1 响应任务执行</h4>
<pre><code class="hljs language-arduino" lang="arduino">PLT_SsdpDeviceSearchResponseTask::<span class="hljs-built_in">DoRun</span>()（在延迟后执行）
{
    <span class="hljs-comment">// 1. 获取所有活跃的网络接口</span>
    ├─ PLT_UPnPMessageHelper::<span class="hljs-built_in">GetNetworkInterfaces</span>(if_list, <span class="hljs-literal">true</span>)
    │   └─&gt; 获取所有活跃的网络接口列表
    │
    <span class="hljs-comment">// 2. 对每个网络接口应用迭代器</span>
    └─ if_list.<span class="hljs-built_in">Apply</span>(PLT_SsdpDeviceSearchResponseInterfaceIterator)
        │
        └─&gt; 使用该迭代器处理每个网络接口
            （详见下一步）
}
</code></pre>
<h4 data-id="heading-10">3.2 网络接口迭代和响应发送</h4>
<pre><code class="hljs language-scss" lang="scss">PLT_SsdpDeviceSearchResponseInterfaceIterator::<span class="hljs-built_in">operator</span>()(net_if)
{
    <span class="hljs-comment">// ========== 第1步：接口验证 ==========</span>
    ├─ 获取网络接口的地址列表
    └─ 如果接口没有有效地址，则跳过该接口 (return NPT_SUCCESS)
    
    <span class="hljs-comment">// ========== 第2步：接口选择（核心逻辑） ==========</span>
    ├─ 创建UDP套接字 (NPT_UdpSocket socket)
    │
    ├─ 连接到请求者地址
    │   └─&gt; socket<span class="hljs-selector-class">.Connect</span>(m_RemoteAddr, <span class="hljs-number">5000ms</span>)
    │       
    │       作用：
    │       ├─ 让操作系统内核选择合适的出站网络接口
    │       ├─ 确定该接口的本地IP地址
    │       └─ 这个IP地址将用于响应中的Location头
    │
    └─ 获取套接字信息
        └─&gt; socket<span class="hljs-selector-class">.GetInfo</span>(info)
            └─&gt; info<span class="hljs-selector-class">.local_address</span> 就是该接口的本地IP
    
    <span class="hljs-comment">// ========== 第3步：接口匹配验证 ==========</span>
    ├─ 如果成功获取了本地地址信息
    │   └─&gt; if (info.local_address.GetIpAddress()<span class="hljs-selector-class">.AsLong</span>())
    │
    ├─ 验证内核选择的网络接口是否与当前遍历的接口匹配
    │   └─&gt; if ((*niaddr)<span class="hljs-selector-class">.GetPrimaryAddress</span>() != info<span class="hljs-selector-class">.local_address</span><span class="hljs-selector-class">.GetIpAddress</span>())
    │       └─&gt; 如果不匹配，跳过此接口 (return NPT_SUCCESS)
    │
    └─ 如果匹配，则设置remote_addr = NULL
        └─&gt; 表示使用已连接的套接字，不需要再指定目标地址
    
    <span class="hljs-comment">// ========== 第4步：构建SSDP响应 ==========</span>
    ├─ NPT_HttpResponse <span class="hljs-built_in">response</span>(<span class="hljs-number">200</span>, "OK", NPT_HTTP_PROTOCOL_1_1)
    │   └─&gt; 创建HTTP <span class="hljs-number">200</span>响应
    │
    ├─ PLT_UPnPMessageHelper::<span class="hljs-built_in">SetLocation</span>(response, device_url)
    │   └─&gt; 设置Location头，包含设备描述文档URL
    │       └─&gt; URL使用本地IP地址：http://[local_ip]:port/device.xml
    │
    ├─ PLT_UPnPMessageHelper::<span class="hljs-built_in">SetLeaseTime</span>(response, lease_time)
    │   └─&gt; 设置CACHE-CONTROL max-age（设备信息有效期）
    │
    ├─ PLT_UPnPMessageHelper::<span class="hljs-built_in">SetServer</span>(response, server_string)
    │   └─&gt; 设置Server头，标识设备类型和版本
    │
    ├─ response.<span class="hljs-built_in">GetHeaders</span>().<span class="hljs-built_in">SetHeader</span>(<span class="hljs-string">"EXT"</span>, <span class="hljs-string">""</span>)
    │   └─&gt; 设置EXT头（UPnP规范要求，但值为空）
    │
    └─ 【可选】根据DLNA规范，可能发送两次响应
        ├─ if (PLATINUM_UPNP_SPECS_STRICT)
        │   ├─ m_Device-&gt;<span class="hljs-built_in">SendSsdpSearchResponse</span>() [第<span class="hljs-number">1</span>次]
        │   ├─ NPT_System::<span class="hljs-built_in">Sleep</span>(DLNA_DELAY) [延迟<span class="hljs-number">200ms</span>]
        │   └─&gt; [继续执行第<span class="hljs-number">2</span>次发送]
        │
        └─&gt; m_Device-&gt;<span class="hljs-built_in">SendSsdpSearchResponse</span>() [第<span class="hljs-number">2</span>次或唯一次]
}
</code></pre>
<hr/>
<h3 data-id="heading-11">4. 响应发送阶段</h3>
<h4 data-id="heading-12">4.1 设置响应内容</h4>
<pre><code class="hljs language-rust" lang="rust">PLT_DeviceHost::<span class="hljs-title function_ invoke__">SendSsdpSearchResponse</span>(response, socket, st, addr)
{
    <span class="hljs-comment">// 1. 设置UPnP 1.1头信息</span>
    ├─ PLT_UPnPMessageHelper::<span class="hljs-title function_ invoke__">SetBootId</span>(response, device<span class="hljs-punctuation">-&gt;</span>m_BootId)
    │   └─&gt; 用于<span class="hljs-title function_ invoke__">NTS</span> (Notification Type)
    │
    ├─ PLT_UPnPMessageHelper::<span class="hljs-title function_ invoke__">SetConfigId</span>(response, device<span class="hljs-punctuation">-&gt;</span>m_ConfigId)
    │   └─&gt; UPnP <span class="hljs-number">1.1</span>规范，配置ID
    │
    <span class="hljs-comment">// 2. 根据搜索目标类型(ST)决定要发送哪些设备信息</span>
    └─ <span class="hljs-title function_ invoke__">if</span> (ST == <span class="hljs-string">"ssdp:all"</span> || ST == <span class="hljs-string">"upnp:rootdevice"</span>)
        ├─ 发送根设备信息
        └─ <span class="hljs-title function_ invoke__">if</span> (ST == <span class="hljs-string">"ssdp:all"</span>)
            ├─ 也发送服务信息
            └─ 也发送嵌入设备信息
}
</code></pre>
<h4 data-id="heading-13">4.2 发送SSDP搜索响应</h4>
<pre><code class="hljs language-arduino" lang="arduino">PLT_SsdpSender::<span class="hljs-built_in">SendSsdp</span>(response, usn, st, socket, notify=<span class="hljs-literal">false</span>, addr)
{
    <span class="hljs-comment">// 1. 格式化SSDP响应包</span>
    ├─ <span class="hljs-built_in">FormatPacket</span>(response, usn, st, socket, notify)
    │   ├─ PLT_UPnPMessageHelper::<span class="hljs-built_in">SetUSN</span>(message, usn)
    │   ├─ PLT_UPnPMessageHelper::<span class="hljs-built_in">SetST</span>(message, st)
    │   │   └─&gt; notify为<span class="hljs-literal">false</span>时设置ST（搜索目标）
    │   └─&gt; PLT_UPnPMessageHelper::<span class="hljs-built_in">SetDate</span>(message)
    │
    <span class="hljs-comment">// 2. 将响应序列化为字节流</span>
    ├─ NPT_MemoryStream stream
    ├─ response.<span class="hljs-built_in">Emit</span>(stream)
    │   └─&gt; 将HTTP响应对象序列化为原始HTTP格式
    │
    <span class="hljs-comment">// 3. 构造数据包并发送</span>
    ├─ stream.<span class="hljs-built_in">GetSize</span>(size)
    ├─ <span class="hljs-function">NPT_DataBuffer <span class="hljs-title">packet</span><span class="hljs-params">(stream.GetData(), size)</span>
    │   └─&gt; 从内存流创建数据缓冲区
    │
    └─ socket.<span class="hljs-title">Send</span><span class="hljs-params">(packet, addr)</span>
        └─&gt; 通过UDP套接字将响应发送给请求者
            ├─ 如果addr非<span class="hljs-literal">NULL</span>，发送到指定地址
            └─ 如果addr为<span class="hljs-literal">NULL</span>，发送到已连接的地址（socket.Connect前缀）
}
</span></code></pre>
<hr/>
<h3 data-id="heading-14">5. 完整的HTTP SSDP响应内容示例</h3>
<pre><code class="hljs language-makefile" lang="makefile">HTTP/1.1 200 OK
<span class="hljs-section">CACHE-CONTROL: max-age=1800</span>
<span class="hljs-section">EXT:</span>
<span class="hljs-section">LOCATION: http://192.168.1.100:8008/device.xml</span>
<span class="hljs-section">SERVER: Linux/2.6 UPnP/1.0 Platinum/1.2.0</span>
<span class="hljs-section">BOOTID.UPNP.ORG: 1234567890</span>
<span class="hljs-section">CONFIGID.UPNP.ORG: 1</span>
<span class="hljs-section">ST: upnp:rootdevice</span>
<span class="hljs-section">USN: uuid:device-uuid::upnp:rootdevice</span>

[空消息体]
</code></pre>
<hr/>
<h3 data-id="heading-15">6. 关键类和接口关系图</h3>
<pre><code class="hljs language-css" lang="css">┌─────────────────────────────────────────────────────────────┐
│  DMC发送M-SEARCH多播请求                                   │
│  UDP多播地址: <span class="hljs-number">239.255</span>.<span class="hljs-number">255.250</span>:<span class="hljs-number">1900</span>                          │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  PLT_SsdpListenTask (运行在后台任务线程)                   │
│  - 监听SSDP多播套接字                                       │
│  - 接收M-SEARCH请求并解析                                  │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  PLT_SsdpListenTask::<span class="hljs-built_in">SetupResponse</span>()                        │
│  - 调用所有已注册的SSDP监听器                              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  PLT_DeviceHost::<span class="hljs-built_in">OnSsdpPacket</span>() (DMR设备处理)               │
│  - 解析M-SEARCH请求                                         │
│  - 验证请求格式                                             │
│  - 创建搜索响应任务                                         │
│  - 注册到任务管理器（带随机延迟）                          │
└──────────────────────────┬──────────────────────────────────┘
                           │
         随机延迟(<span class="hljs-number">0</span>~MX秒)   │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  PLT_SsdpDeviceSearchResponseTask::<span class="hljs-built_in">DoRun</span>() (延迟后执行)    │
│  - 获取所有活跃网络接口                                     │
│  - 应用迭代器处理每个接口                                   │
└──────────────────────────┬──────────────────────────────────┘
                           │
                    (对每个接口)
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  PLT_SsdpDeviceSearchResponseInterfaceIterator::<span class="hljs-built_in">operator</span>()  │
│  - 通过UDP连接确定出站接口                                  │
│  - 验证接口匹配性                                           │
│  - 构建HTTP <span class="hljs-number">200</span>响应（包含Location、缓存时间等）            │
│  - 【可选】DLNA规范下发送两次                              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  PLT_SsdpSender::<span class="hljs-built_in">SendSsdp</span>()                                 │
│  - 格式化SSDP响应包                                         │
│  - 序列化HTTP响应                                           │
│  - 通过UDP套接字发送                                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│  UDP Socket.<span class="hljs-built_in">Send</span>()                                          │
│  - 发送响应给请求者的IP和端口                              │
└─────────────────────────────────────────────────────────────┘
                           │
                           ▼
              ┌────────────────────────┐
              │   DMC接收响应          │
              │ 获取Location URL       │
              │ 下载设备描述文档      │
              └────────────────────────┘
</code></pre>
<hr/>
<h3 data-id="heading-16">7. 重要的设计考虑</h3>
<h4 data-id="heading-17">7.1 为什么要延迟响应？</h4>
<ul>
<li><strong>防止网络风暴</strong>：多个设备同时收到M-SEARCH，如果立即回应会造成大量数据碰撞</li>
<li><strong>随机延迟</strong>：每个设备延迟 0 ~ MX 秒，这样响应会分散开来</li>
<li><strong>MX参数</strong>：DMC在M-SEARCH中指定MX值，设备据此计算延迟</li>
</ul>
<h4 data-id="heading-18">7.2 为什么要多次遍历网络接口？</h4>
<ul>
<li><strong>多网卡场景</strong>：一个DMR可能有多个网络接口（以太网、WiFi等）</li>
<li><strong>正确的Location IP</strong>：必须使用将数据发送给请求者的那个接口的IP地址</li>
<li><strong>内核选择</strong>：通过socket.Connect()让OS内核选择合适的出站接口</li>
</ul>
<h4 data-id="heading-19">7.3 为什么要发送两次（DLNA规范）？</h4>
<ul>
<li><strong>DLNA兼容性</strong>：某些DLNA设备需要接收两次响应来确保收到</li>
<li><strong>间隔延迟</strong>：两次响应之间延迟约200ms（PLT_DLNA_SSDP_DELAY_GROUP）</li>
<li><strong>可选条件</strong>：仅当编译时定义了PLATINUM_UPNP_SPECS_STRICT时</li>
</ul>
<h4 data-id="heading-20">7.4 USN和ST的区别</h4>
<ul>
<li><strong>ST（Search Target）</strong>：搜索目标，在M-SEARCH请求中指定
<ul>
<li><code>ssdp:all</code> - 搜索所有设备和服务</li>
<li><code>upnp:rootdevice</code> - 仅搜索根设备</li>
<li><code>urn:schemas-upnp-org:device:MediaRenderer:1</code> - 搜索特定设备类型</li>
</ul>
</li>
<li><strong>USN（Unique Service Name）</strong>：响应中的唯一服务名标识
<ul>
<li><code>uuid:device-uuid::upnp:rootdevice</code></li>
<li><code>uuid:device-uuid::urn:schemas-upnp-org:device:MediaRenderer:1</code></li>
<li><code>uuid:device-uuid::urn:schemas-upnp-org:service:RenderingControl:1</code></li>
</ul>
</li>
</ul>
<hr/>
<h3 data-id="heading-21">8. 代码流追踪总结</h3>
<pre><code class="hljs language-arduino" lang="arduino">网络接收
  ↓
PLT_SsdpListenTask 监听UDP多播
  ↓
接收到M-SEARCH请求
  ↓
PLT_SsdpListenTask::<span class="hljs-built_in">SetupResponse</span>()
  ↓
通知所有监听器 → PLT_DeviceHost::<span class="hljs-built_in">OnSsdpPacket</span>()
  ↓
验证请求+创建响应任务
  ↓
任务管理器→延迟执行
  ↓
PLT_SsdpDeviceSearchResponseTask::<span class="hljs-built_in">DoRun</span>()
  ↓
遍历网络接口→PLT_SsdpDeviceSearchResponseInterfaceIterator
  ↓
选择正确接口+构建HTTP200响应
  ↓
PLT_SsdpSender::<span class="hljs-built_in">SendSsdp</span>()
  ↓
UDP Socket发送响应
  ↓
DMC接收响应并解析
</code></pre>
<hr/>
<h3 data-id="heading-22">9. 参考的关键源文件</h3>
<ul>
<li><a href="https://link.juejin.cn?target=Platinum%2FCore%2FPltSsdp.h" target="_blank" title="Platinum/Core/PltSsdp.h" ref="nofollow noopener noreferrer">PltSsdp.h</a> - SSDP类定义</li>
<li><a href="https://link.juejin.cn?target=Platinum%2FCore%2FPltSsdp.cpp" target="_blank" title="Platinum/Core/PltSsdp.cpp" ref="nofollow noopener noreferrer">PltSsdp.cpp</a> - SSDP实现（含搜索响应迭代器）</li>
<li><a href="https://link.juejin.cn?target=Platinum%2FCore%2FPltDeviceHost.h" target="_blank" title="Platinum/Core/PltDeviceHost.h" ref="nofollow noopener noreferrer">PltDeviceHost.h</a> - 设备主机接口</li>
<li><a href="https://link.juejin.cn?target=Platinum%2FCore%2FPltDeviceHost.cpp" target="_blank" title="Platinum/Core/PltDeviceHost.cpp" ref="nofollow noopener noreferrer">PltDeviceHost.cpp</a> - OnSsdpPacket实现</li>
<li><a href="https://link.juejin.cn?target=Platinum%2FCore%2FPltDeviceData.h" target="_blank" title="Platinum/Core/PltDeviceData.h" ref="nofollow noopener noreferrer">PltDeviceData.h</a> - 设备数据结构</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[js中的using声明]]></title>    <link>https://juejin.cn/post/7592423411563233306</link>    <guid>https://juejin.cn/post/7592423411563233306</guid>    <pubDate>2026-01-07T10:25:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592423411563233306" data-draft-id="7531888107878023203" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="js中的using声明"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-01-07T10:25:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="布列瑟农的星空"/> <meta itemprop="url" content="https://juejin.cn/user/976022056218471"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            js中的using声明
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/976022056218471/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    布列瑟农的星空
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:25:48.000Z" title="Wed Jan 07 2026 10:25:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、<code>using</code> 声明简介</h2>
<p><code>using</code> 是 <strong>ECMAScript 2023（ES14）</strong> 引入的一项新语法，用于<strong>自动管理资源的生命周期</strong>。<br/>
它的主要目标是简化“资源使用完后自动释放”的场景，例如文件句柄、数据库连接、锁等。
相关提案可见：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-using-enforcement" target="_blank" title="https://github.com/tc39/proposal-using-enforcement" ref="nofollow noopener noreferrer">github.com/tc39/propos…</a></p>
<p>📜 <strong>语法结构：</strong></p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">using</span> 变量名 = 表达式;
<span class="hljs-keyword">await</span> <span class="hljs-keyword">using</span> 变量名 = 异步表达式;
</code></pre>
<p><code>using</code> 声明的变量必须是一个实现了 <strong><code>Symbol.dispose</code></strong> 或 <strong><code>Symbol.asyncDispose</code></strong> 方法的对象。<br/>
当作用域退出（无论是正常返回还是异常）时，JS 引擎会自动调用该方法释放资源。</p>
<hr/>
<h2 data-id="heading-1">二、基本使用示例</h2>
<h3 data-id="heading-2">同步版本</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`打开文件: <span class="hljs-subst">${name}</span>`</span>);
  }
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">dispose</span>]() {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`关闭文件: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"/>) {
  using f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">"data.txt"</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"读取文件中..."</span>);
}

<span class="hljs-title function_">main</span>();
<span class="hljs-comment">// 输出：</span>
<span class="hljs-comment">// 打开文件: data.txt</span>
<span class="hljs-comment">// 读取文件中...</span>
<span class="hljs-comment">// 关闭文件: data.txt</span>
</code></pre>
<blockquote>
<p>⚡ 当 <code>main()</code> 执行完毕时，<code>f</code> 离开作用域，系统会自动调用 <code>f[Symbol.dispose]()</code>。</p>
</blockquote>
<hr/>
<h3 data-id="heading-3">异步版本</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncResource</span> {
  <span class="hljs-keyword">async</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncDispose</span>]() {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"异步释放资源..."</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(res, <span class="hljs-number">1000</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"资源已释放"</span>);
  }
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">await</span> using r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncResource</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"使用异步资源中..."</span>);
}

<span class="hljs-title function_">run</span>();
</code></pre>
<hr/>
<h2 data-id="heading-4">三、内部机制简析</h2>
<ul>
<li>
<p><code>using</code> 是 <strong>词法作用域绑定</strong>（和 <code>let</code>/<code>const</code> 类似）。</p>
</li>
<li>
<p>离开作用域时：</p>
<ul>
<li>如果是同步资源 → 调用 <code>[Symbol.dispose]()</code></li>
<li>如果是异步资源 → 调用 <code>[Symbol.asyncDispose]()</code></li>
</ul>
</li>
<li>
<p>它可以和 <code>try</code>、<code>catch</code>、<code>finally</code> 一起安全使用。</p>
</li>
</ul>
<hr/>
<h2 data-id="heading-5">四、使用场景</h2>

























<table><thead><tr><th>场景</th><th>传统做法</th><th>新写法（using）</th></tr></thead><tbody><tr><td>文件操作</td><td>try/finally 手动关闭</td><td>自动调用 dispose</td></tr><tr><td>数据库连接</td><td>手动断开</td><td>自动释放连接</td></tr><tr><td>临时锁</td><td>try/finally 释放锁</td><td>离开作用域自动释放</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-6">五、注意事项</h2>
<ol>
<li><code>using</code> <strong>只能在模块或函数作用域中使用</strong>，不能在全局作用域直接声明。</li>
<li>不能与 <code>var</code> 共用。</li>
<li>不会影响 GC（垃圾回收），它只是提供<strong>结构化释放资源</strong>的机制。</li>
</ol>
<h2 data-id="heading-7">六、实践demo——简化revokeObjectURL</h2>
<p>在图片回显/文件下载等场景中，开发很容易忘记<code>revokeObjectURL</code>,我们可以利用<code>using</code>特性进行封装，消除<code>revokeObjectURL</code>的心智负担。</p>
<p>就比如上传图片后回显的操作：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'🚀 using demo 启动...'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">objectURLResource</span>(<span class="hljs-params">blob</span>) {
    <span class="hljs-keyword">const</span> url = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'🆕 创建 URL:'</span>, url);
    <span class="hljs-keyword">return</span> {
        url,
          [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">dispose</span>]() {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"释放资源..."</span>);
            <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(url);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'🧹 自动释放 URL:'</span>, url);
            
        },
        <span class="hljs-comment">// [Symbol.dispose]() {</span>
        <span class="hljs-comment">//     console.log("释放资源...");</span>
        <span class="hljs-comment">//     new Promise(resolve =&gt; setTimeout(resolve, 1000)).then(()=&gt;{</span>
        <span class="hljs-comment">//         URL.revokeObjectURL(url);</span>
        <span class="hljs-comment">//         console.log('🧹 自动释放 URL:', url);</span>
        <span class="hljs-comment">//     })</span>
            
        <span class="hljs-comment">// },</span>
          <span class="hljs-keyword">async</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncDispose</span>]() {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"异步释放资源..."</span>);
            <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">3000</span>)); <span class="hljs-comment">// 模拟异步操作</span>
            <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(url);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'🧹 自动释放 URL:'</span>, url);
        },
    };
}



<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">showImage</span>(<span class="hljs-params">blob</span>) {
    <span class="hljs-comment">// await using resource = objectURLResource(blob);</span>
    using resource = <span class="hljs-title function_">objectURLResource</span>(blob);
    <span class="hljs-keyword">const</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'img'</span>);
    img.<span class="hljs-property">src</span> = resource.<span class="hljs-property">url</span>;
    img.<span class="hljs-property">alt</span> = <span class="hljs-string">'demo'</span>;
    <span class="hljs-keyword">const</span> { resolve, promise } = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">withResolvers</span>()
    img.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">resolve</span>()
    }
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(img);
    <span class="hljs-keyword">await</span> promise;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'✅ 演示完毕，URL 将被自动 revoke'</span>);
}
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#file'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'change'</span>,<span class="hljs-keyword">async</span> (e) =&gt; {
    <span class="hljs-keyword">const</span> f = e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]
   <span class="hljs-keyword">await</span> <span class="hljs-title function_">showImage</span>(f);
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'do others...    '</span>)

})

</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85a10c9e0fb44bcf92ace642a19898a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5biD5YiX55Gf5Yac55qE5pif56m6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768386347&amp;x-signature=n82HBvEQsoDr3ubfCEec6oqKuDE%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-8">revokeObjectURL的注意事项</h3>
<p>当img加载后，执行<code>revokeObjectURL</code>并不会影响内容显示，但如果img未加载完就执行了<code>revokeObjectURL</code>，则无法显示图片。因此以上demo中增加了<code>await promise</code>的处理，确保图片被显示出来。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e581b6c97c9406c9cfd14f00ebc20a6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5biD5YiX55Gf5Yac55qE5pif56m6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768386347&amp;x-signature=7uh9OAdRX7WaWapeSpY7QrSN8Yc%3D" alt="image.png" loading="lazy"/></p>
<p>那么可能会有人问，此处能否用<code>Symbol.asyncDispose</code>来解决该问题？答案是不能。但这是一个很好的问题，触及到了
<code>Symbol.asyncDispose</code>与<code>Symbol.dispose</code>的根本区别.</p>
<h2 data-id="heading-9">七、Symbol.asyncDispose与Symbol.dispose的区别</h2>
<p>表面上看，以上demo中如果写成<code>await using resource = objectURLResource(blob);</code>，释放资源用的是<code>Symbol.asyncDispose</code>，如果不加<code>await</code>，则调用<code>Symbol.dispose</code>。</p>
<p>异步释放：
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c06c4140e25f4b4c89fd4ddd0d6997bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5biD5YiX55Gf5Yac55qE5pif56m6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768386347&amp;x-signature=RGnOX6ZQdZrhrCH8sc3F%2Bh8dttE%3D" alt="异步释放" loading="lazy"/></p>
<p>那么这两个api的使用场景分别是啥呢？我们不妨在同步释放中写下如下代码：</p>
<pre><code class="hljs language-javascript" lang="javascript">[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">dispose</span>]() {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"释放资源..."</span>);
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>)).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>{
        <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(url);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'🧹 自动释放 URL:'</span>, url);
    })
},
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9884740a6cbe43398f665f3475f63890~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5biD5YiX55Gf5Yac55qE5pif56m6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768386347&amp;x-signature=93S5o31ix4f%2B8B1Sf5Hj8PABNIw%3D" alt="image.png" loading="lazy"/>
可以看到，<code>do others...</code>在释放完成前就执行了。</p>
<p>因此可以理解：<code>Symbol.asyncDispose</code>是为了让后续的代码等待异步释放完成后再执行，因为有些释放场景，可能需要进行io或其他异步校验，而<code>Symbol.dispose</code>释放过程是同步的，后续代码执行时可以认为资源已经被释放了。如果后续代码执行时并不关心该资源是否已经释放了，那使用<code>Symbol.dispose</code>即可。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于 Agent Skills 的 UI 重构实践：从 Demo 到主题化界面的升级之路]]></title>    <link>https://juejin.cn/post/7592431064976228367</link>    <guid>https://juejin.cn/post/7592431064976228367</guid>    <pubDate>2026-01-07T09:46:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592431064976228367" data-draft-id="7592431064976211983" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于 Agent Skills 的 UI 重构实践：从 Demo 到主题化界面的升级之路"/> <meta itemprop="keywords" content="前端,AI编程,Claude"/> <meta itemprop="datePublished" content="2026-01-07T09:46:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="dragonZhang"/> <meta itemprop="url" content="https://juejin.cn/user/1684908923689773"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于 Agent Skills 的 UI 重构实践：从 Demo 到主题化界面的升级之路
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1684908923689773/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    dragonZhang
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:46:24.000Z" title="Wed Jan 07 2026 09:46:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;color:#282d36}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px;color:#2f845e}.markdown-body h2{font-size:22px;display:inline-block;font-weight:700;background:#2f845e;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(47,132,194,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 32px);border-bottom:3px solid #2f845e}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%;box-shadow:6px 6px 6px #888}.markdown-body hr{border:none;border-top:1px solid rgba(66,185,131,.15);margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#f6ffed;color:#52c41a;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:16px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#262626;border:1px solid #2f845e;border-top:8px solid #2f845e;background:linear-gradient(180deg,rgba(66,185,131,.1),transparent)!important}.markdown-body pre&gt;code.hljs[lang]:before{top:8px!important;color:#2f845e!important}.markdown-body pre&gt;code.language-awesome_error{border:1px solid #ff4d4f!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#ff4d4f!important;background:#fff2f0!important}.markdown-body pre&gt;code.language-awesome_error:before{content:"!"!important;position:absolute!important;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#ff4d4f!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body pre&gt;code.language-awesome_warn{border:1px solid #ffc46f!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#ffc46f!important;background:#fffbe6!important}.markdown-body pre&gt;code.language-awesome_warn:before{content:"☂"!important;position:absolute;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#ffc46f!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body pre&gt;code.language-awesome_success{border:1px solid #52c41a!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#52c41a!important;background:#f6ffed!important}.markdown-body pre&gt;code.language-awesome_success:before{content:"✓"!important;position:absolute!important;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#52c41a!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body pre&gt;code.language-awesome_info{border:1px solid #1890ff!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#1890ff!important;background:#e6f7ff!important}.markdown-body pre&gt;code.language-awesome_info:before{content:"i"!important;position:absolute!important;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#1890ff!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body strong{background-color:inherit;color:#2f845e}.markdown-body em{background-color:inherit;color:#949415}.markdown-body a{text-decoration:none;color:#2f8e54;border-bottom:1px solid #3f9e64}.markdown-body a:active,.markdown-body a:hover{color:#3f9e64}.markdown-body a[class^=footnote]{margin-left:4px}.markdown-body a:before{content:"➤ "}.markdown-body table{font-size:12px;width:100%;max-width:100%;overflow:auto;border:2px solid #2f8e54}.markdown-body thead{background:#2f8e54;color:#fff;text-align:left;font-weight:700}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:22px}.markdown-body td{min-width:120px}.markdown-body blockquote{padding:1px 22px;margin:22px 0;border-left:6px solid #2f845e;background-color:rgba(66,185,131,.1);border-radius:2px}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#2f845e}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px;color:#282d36}.markdown-body del{color:#2f845e}.markdown-body input[type=checkbox]:checked:before{content:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA/klEQVQ4T72TMU7DQBBF318XdFR06egQEnAXRINEGlqgowoIR8AF4AZOZ4JEGq5AC5EixBU4A55BNrEVHAcSBTHlaubt37/zxZKlcn7n6mDPXJvz8IJ89HzWu8t7C8D2dfsY52ae4apHnLx0ktsCsHXZjiUuFgG40x2eJ/H/AhztB+zDUTpLwWj8jGkzxSHiHaMPrDQC8sMoilKzLAUqiKQjmb+ZuAdW80tmelCHODoNgSfP7AFprTTaRTzsJN1GEyuIZ7uW6TEEHwCtyV/6EVBKJHhfzgC0Xv/iXwEFBF4FG0378bd7sPQq5xK/hSnk6sdlX3mZrKkwLZKBeu8n9XuWEUE7X+YAAAAASUVORK5CYII=);position:relative;top:-1px;left:-1px}.markdown-body .math .katex{font-family:Menlo,Monaco,Consolas,Courier New,monospace;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#f6ffed;color:#52c41a;font-size:.87em;padding:.065em .4em}@media (max-width:720px){.markdown-body h1{font-size:22px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-light">.hljs-comment,.hljs-quote{color:#696969}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#d91e18}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#aa5d00}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:green}.hljs-section,.hljs-title{color:#007faa}.hljs-keyword,.hljs-selector-tag{color:#7928a1}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fefefe;color:#545454}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">重构缘起：为什么选择 Agent Skills 优化 UI</h2>

<h3 data-id="heading-1">从一个小 Demo 开始</h3>
<p>最近正在读《百万富翁快车道》，里面有个观点是通过工作收入 &amp; 投资复利，要实现财富自由需要非常久的时间，于是心血来潮，用 AI 做了一个<a href="https://link.juejin.cn?target=https%3A%2F%2Fsavings.abrdns.com%2Fzh" target="_blank" title="https://savings.abrdns.com/zh" ref="nofollow noopener noreferrer">积蓄模拟器</a>（完全开源，欢迎来试试看），看看自己未来收入的变化。初版的 UI 大概长这个样子：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de5934b4ee734e37b82de1b67d1b72f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=eTpI%2FLEpLcDnzwfy%2Bw8HN2q2lTg%3D" alt="" loading="lazy"/></p>
<p>非常典型的 AI 风，对吧，既不高级也不吸睛，与金融财富类网页的主题调性也相去甚远。为此，我尝试引入 <strong>Agent Skills</strong> 对页面进行重构，优化后的 UI 效果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39d9ed86cf9d4319a0f3e9df6241084e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=tjQrI9119NkOOdQK9AbKEjBxGJU%3D" alt="" loading="lazy"/></p>
<p>重构后的界面不仅美观度显著提升，风格也与金融财富的主题高度契合。那么，<strong>Agent Skills 究竟是什么？</strong> 我又为何选择它来完成本次 UI 重构工作？接下来将逐一解答。</p>
<h3 data-id="heading-2">什么是 Agent Skills？</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fagentskills.io%2Fhome" target="_blank" title="https://agentskills.io/home" ref="nofollow noopener noreferrer">Agent Skills</a>（又称 Claude Skills，简称 Skills）是 Anthropic 在 2025 年 10 月 16 号发布的一个<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.anthropic.com%2Fengineering%2Fequipping-agents-for-the-real-world-with-agent-skills" target="_blank" title="https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills" ref="nofollow noopener noreferrer">功能</a>，并在 2025 年 12 月 18 日发布为跨平台的开放标准，成为 MCP 之后又一被各家 AI 大厂纷纷支持的新标准。</p>
<p>该标准的设计初衷，是为了弥补通用智能体在处理特定领域任务时，对<strong>过程性知识</strong>与<strong>组织上下文</strong>的掌握不足。简单来说，Agent Skills 是一个包含指令、脚本与资源的结构化目录，能够让智能体根据任务需求，动态发现并加载对应的专业能力包。</p>
<p>每个 Skill 的核心载体是一个名为 <code>SKILL.md</code> 的文件，其结构分为两部分：</p>
<ul>
<li>元数据（YAML Frontmatter）：文件开头包含技能的名称和描述。 智能体在启动时会预加载这些元数据，以便在遇到相关任务时识别并触发该技能。</li>
<li>多层级内容：技能目录可以包含多个文件（如 .md 文档或脚本）。 这种设计允许作者将复杂的指令拆分，仅在需要时让智能体读取特定部分。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a682b0848cb48c6a868b58c9c8f7387~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=ygHwqPvzzitudIng5%2FpJmrOxlBs%3D" alt="" loading="lazy"/></p>
<p>为了最大化节约 Token 资源，Skills 采用<strong>三层式渐进式披露（Progressive Disclosure）</strong> 机制，具体规则如下：</p>
<ul>
<li>Level 1: Metadata。会在 Coding Agent 冷启动时加载到 System Prompt 中。</li>
<li>Level 2: Instructions。当请求的内容与技能描述相符时，Coding Agent 会通过 bash 从文件系统中读取 SKILL.md 文件。只有这样，该文件的内容才会显示在上下文窗口中。</li>
<li>Level 3: Resources and code。仅在被引用时才会访问这些文件，指令提供灵活的指导，代码提供可靠性，资源用于事实查找，确保在任何给定时间，上下文窗口中只显示相关内容。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b48745fc673490bbca0a7195ccfb20b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=PIIl5zPfTtWueAeNTp%2FEKrRTrBI%3D" alt="" loading="lazy"/></p>
<p>为了更清晰地理解 Skills 的定位，我们将其与相似技术概念进行对比：</p>

































<table><thead><tr><th>对比对象</th><th>核心差异点</th></tr></thead><tbody><tr><td>提示词文件（如 Claude.md、Agent.md）</td><td>1.  加载机制：提示词文件在对话初期即全部载入上下文，无论是否需要均占用 Token；2.  功能边界：Skills 支持捆绑 Python 脚本、Bash 工具等可执行资源，提示词文件仅为纯文本指令。</td></tr><tr><td>自定义命令（Custom Command）/ Slash Command</td><td>1.  触发方式：Slash Command 需用户手动触发，Skills 由智能体根据任务需求自主发现并调用；2.  扩展性：Skills 封装性更强，支持跨技能调用，复用与分享更便捷。</td></tr><tr><td>MCP</td><td>1.  定位互补：MCP 是通信协议，解决 “连接外部工具与数据源” 的问题（即 “有什么工具”）；2.  功能侧重：Skills 聚焦于 “教授智能体如何使用工具完成复杂业务流程”，相当于 MCP 工具箱的 “使用说明书” 与 “最佳实践指南”。</td></tr><tr><td>Subagents</td><td>Subagents 是独立的 LLM 实例，拥有专属上下文窗口，由主智能体协调并行工作，核心目标是实现上下文隔离以节约 Token，与 Skills 的能力封装定位不同。</td></tr><tr><td>Plugins</td><td>Plugins 是 Claude Code 对可复用流程的高阶封装，包含 Slash Command、Custom Agents、Skills、Hooks 等多种组件，<strong>Skills 是 Plugins 的子集</strong>。</td></tr><tr><td>Cursor Rules</td><td>核心功能与使用逻辑基本一致。</td></tr></tbody></table>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9cffb8bf4504525ac03466b96a94ab9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=FqxBiNIzUE1Li2PjKZAsKj4hSOI%3D" alt="" loading="lazy"/></p>
<p>综上，<strong>技能封装与复用能力</strong>是 Agent Skills 的核心优势，支持开发者直接复用成熟技能并快速扩展新功能，这也是我选择基于 Skills 完成本次 UI 优化的关键原因。</p>
<h3 data-id="heading-3">我想用 Skills！</h3>
<p>如果你也想用 Skills 来给工作乃至生活提效，可以看看以下这些仓库，里面有大量现成的 skills 可以直接拿来使用：</p>
<ul>
<li>Anthropic 官方 Skills：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">github.com/anthropics/…</a></li>
<li>企业级 Skills：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmrgoonie%2Fclaudekit-skills" target="_blank" title="https://github.com/mrgoonie/claudekit-skills" ref="nofollow noopener noreferrer">github.com/mrgoonie/cl…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FComposioHQ%2Fawesome-claude-skills" target="_blank" title="https://github.com/ComposioHQ/awesome-claude-skills" ref="nofollow noopener noreferrer">github.com/ComposioHQ/…</a></li>
<li>Copilot 官方 Skills：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgithub%2Fawesome-copilot%2Ftree%2Fmain%2Fskills" target="_blank" title="https://github.com/github/awesome-copilot/tree/main/skills" ref="nofollow noopener noreferrer">github.com/github/awes…</a></li>
</ul>
<p>目前，Claude Code、Codex、GitHub Copilot 等主流 AI 编码工具均已支持 Skills 标准，但这类工具大多需要付费使用，部分还存在网络访问限制。</p>
<p>那么，有没有一款产品，能以免费的价格，实现 Claude Code 80% 的能力呢？（挑眉）</p>
<p>这里就不得不给自家产品打个广告，隆重介绍一下 <a href="https://link.juejin.cn?target=https%3A%2F%2Fqwenlm.github.io%2Fqwen-code-docs%2F" target="_blank" title="https://qwenlm.github.io/qwen-code-docs/" ref="nofollow noopener noreferrer">Qwen Code</a>。就在今日，Qwen Code 正式发布 0.6.0 版本，全面支持 <a href="https://link.juejin.cn?target=https%3A%2F%2Fqwenlm.github.io%2Fqwen-code-docs%2Fzh%2Fusers%2Ffeatures%2Fskills%2F" target="_blank" title="https://qwenlm.github.io/qwen-code-docs/zh/users/features/skills/" ref="nofollow noopener noreferrer">Agent Skills</a> 标准；同时提供每日 2000 次免费请求额度，搭配编程领域 SOTA 模型 Qwen3-Coder-Plus，助力开发者革新编码体验！</p>
<p>官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fqwenlm.github.io%2Fqwen-code-docs%2F" target="_blank" title="https://qwenlm.github.io/qwen-code-docs/" ref="nofollow noopener noreferrer">qwenlm.github.io/qwen-code-d…</a></p>
<p>GitHub 链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FQwenLM%2Fqwen-code" target="_blank" title="https://github.com/QwenLM/qwen-code" ref="nofollow noopener noreferrer">github.com/QwenLM/qwen…</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4165b974fb9946c0851455a03dd8243c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=obWQigzpxLmsAp7VOEHKUTdUxRQ%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">重构之旅：基于 Agent Skills 的 UI 优化实战</h2>
<p>本次 UI 重构并非从零搭建，而是基于社区开发者封装的成熟 Skills 进行扩展。我选用了 <code>https://github.com/mrgoonie/claudekit-skills</code> 仓库中的三个核心技能，其功能分别如下：</p>
<ul>
<li>aesthetic：负责创建符合设计原则的美观界面，可调用 <code>chrome-devtools</code> 技能分析外部网站设计风格，为 UI 优化提供灵感参考。</li>
<li>chrome-devtools：基于 Puppeteer 的浏览器自动化工具，原生支持对目标网站进行页面截图。</li>
<li>ui-styling：结合 shadcn/ui 组件库与 Tailwind CSS 技术栈，实现界面的美观化与可访问性优化。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab02b1cf6b034ead9e34212a013e86c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=nVQMdTGyWTzLIKc36riAIUWF5E0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba93ffada0e34e638257e5a3e09be8c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=lh%2FcRwq0tK6QuA8w3PHrqR9pmGo%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97d893c8ea854fc0a7f34f882305f9fc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=I6XcQ9ngD9fIJleiN5N52agkn4o%3D" alt="" loading="lazy"/></p>
<p>在实践过程中，我发现原生 <code>chrome-devtools</code> 技能存在明显局限：它仅支持对搜索结果页面进行整页截图，导致获取的 UI 设计图尺寸小、清晰度低，后续 AI 分析的素材精度与针对性严重不足，优化效果大打折扣。</p>
<p>针对这一问题，我对该技能进行了功能扩展 ——<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDragonnZhang%2Fclaudekit-skills%2Fblob%2Fmain%2F.claude%2Fskills%2Fchrome-devtools%2Fscripts%2Fdownload-dribbble.js" target="_blank" title="https://github.com/DragonnZhang/claudekit-skills/blob/main/.claude/skills/chrome-devtools/scripts/download-dribbble.js" ref="nofollow noopener noreferrer">集成爬虫脚本</a>，使其能够直接从设计平台 Dribbble 的搜索结果中，精准抓取并下载目标 UI 设计图至本地，为 AI 模型提供高质量的分析素材。</p>
<p>基于优化后的 Skill 组合，我向 Coding Agent 下达了如下提示词指令，启动 UI 重构流程：</p>
<pre><code class="hljs">帮我用 aesthetic 这个 skill 帮我重构并美化当前的 ui，注意要用到 chrome-devtools 这个 skill 来分析来自灵感网站 Dribbble 的设计作品，然后用 ui-styling 这个 skill 来重构 ui，不要用 ai-multimodal，用你自己的多模态能力来分析下载下来的图片
</code></pre>
<p>随后，Coding Agent 按照既定流程启动工作：</p>
<ol>
<li><strong>素材抓取</strong>：访问 Dribbble 平台，抓取与金融财富主题匹配的 UI 设计参考图；</li>
<li><strong>风格分析</strong>：对参考图的视觉风格（色彩搭配、布局结构、组件样式等）进行解析与提炼；</li>
<li><strong>文档生成</strong>：基于分析结果输出标准化设计指南；</li>
<li><strong>界面重构</strong>：依据设计指南完成目标 UI 的迭代优化。</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c871fde2da8c41ccb4bf7f777a0920af~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=rSexikXB0BUR2bf3Rmn4%2BBg%2B7kA%3D" alt="" loading="lazy"/></p>
<p>值得注意的是，下载的设计图风格五花八门。要是直接让 AI 照着这些图生成设计文档、重构 UI，做出来的界面风格会很杂乱，没有亮点。所以我先人工挑出想要模仿的 UI，再让 AI 按照这个 UI 的风格来重构（如下图）。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c844432558b64f62a4d958443d4c139c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=oHp2KtQp0T3KyaDxnxenu5Y%2BaDU%3D" alt="" loading="lazy"/></p>
<p>经过上述流程，最终我成功打造出一款 <strong>Nebula 主题</strong>的全新 UI—— 以深色为背景基调，搭配金色与绿色作为点缀色，既契合金融产品的专业质感，又具备极强的视觉吸引力。本次 UI 重构实践圆满完成，撒花！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7699e573d4d94b668fd13d49b0b32527~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZHJhZ29uWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383983&amp;x-signature=MISpLutoShFCVNOIamQykCisoDc%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Cursor 系列（2）：使用心得]]></title>    <link>https://juejin.cn/post/7592134330314031147</link>    <guid>https://juejin.cn/post/7592134330314031147</guid>    <pubDate>2026-01-07T09:40:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592134330314031147" data-draft-id="7585096444190179364" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Cursor 系列（2）：使用心得"/> <meta itemprop="keywords" content="前端,Cursor,AI编程"/> <meta itemprop="datePublished" content="2026-01-07T09:40:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="我是千浔呀"/> <meta itemprop="url" content="https://juejin.cn/user/3184634666692312"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Cursor 系列（2）：使用心得
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3184634666692312/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    我是千浔呀
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:40:07.000Z" title="Wed Jan 07 2026 09:40:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-light">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">Cursor 系列（2）：使用心得</h2>
<p>这篇文章主要是分享一些我在<code>Cursor</code>使用过程中总结的一些心得、踩过的坑以及解决办法，能够帮助大家更好的使用<code>Cursor</code>去辅助我们的开发。主要包括使用技巧、<code>Cursor</code>锁区问题、<code>Rules</code>相关以及模型的选择。</p>
<h3 data-id="heading-1">使用技巧</h3>
<h4 data-id="heading-2">使用 <code>@</code>精确到行</h4>
<p>用 <code>@</code> 标记相关文件可以<strong>显著提高代码建议的准确性</strong>，在明确知道需要改动哪行或者改动哪个文件的情况下，最好用<code>@</code>精确到行。在<code>Cursor</code>里操作也挺方便的，直接复制代码到<code>Chat</code>里面，编辑器会自动关联文件。</p>
<h4 data-id="heading-3">缩小变更范围，不要试图一次更改太多</h4>
<p>在使用 <code>AI</code> 编辑器 <code>coding</code> 过程中，无论是使用哪个<code>AI</code>编辑器，我的建议是<strong>一个功能点一个功能点的去做</strong>，尽量让<strong>更改范围小些</strong>。这样不至于让 <code>AI</code> 写的代码变得越来越不可控，以至于到最后我们看不懂也改不动。</p>
<p>更小的更改范围有助于我们<strong>更好的阅读</strong>、<strong>理解</strong> <code>AI</code> 写的代码，毕竟，<strong>人，才是写代码的主体</strong>。</p>
<h4 data-id="heading-4">让 <code>cursor</code> 复述你的要求</h4>
<p>我们表述的语言总是有模糊性的，加上 <code>AI</code> 理解特定信息的局限性，以及 <code>AI</code> 生成内容的一定随机性，有时候我们可能会遇到 <code>AI</code><strong>答非所问</strong>的情况，这个时候先别怪 <code>AI</code>，先去看下自己的提问或描述是否清晰易懂，其实最好的方法就是让 <code>AI</code> <strong>复述</strong>一遍你的需求，从它复述的结果看 <code>AI</code> 是否充分理解了你的要求。</p>
<h4 data-id="heading-5">善用图示提问</h4>
<p>各个<code>AI</code>的识图其实已经非常强了，如果你的需求是否很难用文字完全描述清楚，可以适当<strong>增加一些图示</strong>，哪怕是一些简单的流程图，都能更好地帮助 <code>cursor</code> 去理解你的意图。</p>
<h4 data-id="heading-6">经常创建新的chat</h4>
<p>每次完成一个新功能，最好新开一个<code>chat</code>，避免之前的上下文对后面的功能开发造成污染，这也是我之前踩过的一个坑。而且因为新开的<code>chat</code>只包含只包含当前任务相关的上下文，不包含历史无关信息，在按 <code>token</code> 计费模式下，还可以节省费用。</p>
<h4 data-id="heading-7">灵活使用<code>Chat</code>的模式</h4>
<p>当前版本 <code>cursor</code>（2.2.43版本）的<code>Chat</code> 有 <code>Ask</code> 、<code>Agent</code>、 <code>Plan</code>和<code>Debug</code>四种模式。</p>
<p>这四个模式的定位、行为特点以及典型适用场景如下：</p>



































<table><thead><tr><th>模式</th><th>核心定位</th><th>行为特点</th><th>典型适用场景</th></tr></thead><tbody><tr><td><code>Ask</code></td><td>对话 / 思考 / 出方案</td><td>只聊天和给建议，不主动大改代码</td><td>问概念、要方案、评审代码、讨论架构和技术选型</td></tr><tr><td><code>Agent</code></td><td>自动改代码 / 执行任务</td><td>自动读改多文件，真正帮你写和改代码</td><td>新增功能、重构、批量替换 API/埋点/日志等跨文件修改</td></tr><tr><td><code>Plan</code></td><td>拆解任务 / 生成路线图</td><td>只给步骤和 TODO，不直接动代码</td><td>大型功能、复杂重构、技术栈升级前的规划</td></tr><tr><td><code>Debug</code></td><td>定位和修复问题 / 调试辅助</td><td>围绕报错和异常，找原因给修复方案</td><td>接口 500、程序报错、测试失败、性能问题等调试场景</td></tr></tbody></table>
<p>对我来说，没啥思路时，我会使用<code>Ask</code>跟<code>AI</code>讨论技术方案，有时候也会使用<code>Ask</code>去分析代码。</p>
<p>在自己知道代码咋写的情况下，如果是大需求，我会先使用<code>Ask</code> 模式与 <code>cursor</code> 沟通好需求的背景、目的、实现效果等，或者直接上传 <code>prd</code>，让它生成一个初始的技术方案，再根据自己的业务理解与代码理解去优化这个技术方案，最后拿这个比较成熟的方案使用<code>Agent</code> 模式去执行。当然一些小的简单的需求直接<code>Agent</code> 改就完事了，这样效率更高。</p>
<p><code>Plan</code> 模式像个大号的<code>Ask</code>模式，我只会在大型功能开发、复杂重构和项目初始化时使用。他会先问你，如果我想把项目的<code>element ui</code>升级下版本，直接问：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6422c5b6b94541a6b0b0ec1dda9b4b41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5Y2D5rWU5ZGA:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383607&amp;x-signature=9EEzzW8V0qOL2g1EVqCXWctpYM0%3D" alt="image.png" loading="lazy"/></p>
<p>它会先问你几个问题：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4204e8ddb3e842a5a793b4ba30fb5d70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5Y2D5rWU5ZGA:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383607&amp;x-signature=iGS%2BjmralpBC%2BlSaihmq1ZF5jZU%3D" alt="image.png" loading="lazy"/></p>
<p>等你回答完这几个问题后，他会生成一个后缀为.plan的md文档：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3cdc373574b240cd8359a19d7da1a2b1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5Y2D5rWU5ZGA:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383607&amp;x-signature=Q%2BtINJywGkmULQle6VQ0I1Jy1y0%3D" alt="image.png" loading="lazy"/></p>
<p>在这个md文件的最下面，有一个<code>todo list</code>，如果你认为这个<code>todo list</code>没啥问题，可以点<code>new agent</code>按钮（如下图），它会创建一个<code>agent</code>模式的<code>chat</code>按照这个<code>todoList</code>去执行。如果你觉得这个<code>todo list</code>有点问题，可以直接编辑它，也可以点<code>New Todo</code>按钮去自己增加一项<code>todo</code>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9964d2b6db1f44f38b65bb729ddca73e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5Y2D5rWU5ZGA:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383607&amp;x-signature=ir3h4aqiJncYxLjGR3JmwQc%2BYfM%3D" alt="image.png" loading="lazy"/></p>
<p>如果你在你的<code>Chat</code>里面输入的内容，表示这个任务很复杂，<code>Cursor</code> 会自动建议切换到<code>Plan</code>模式。</p>
<p><code>Debug</code>模式我不是很喜欢用，这里就不展开了，可以看<a href="https://link.juejin.cn?target=https%3A%2F%2Fcursor.zone%2Ffaq%2Fcursor-debug-mode.html" target="_blank" title="https://cursor.zone/faq/cursor-debug-mode.html" ref="nofollow noopener noreferrer">这个</a>。</p>
<h4 data-id="heading-8">先检查下<code>accept</code></h4>
<p><code>Cursor</code> 写完代码后。可以不用那么着急着去点 <code>accept all</code>，因为你也不知道 <code>cursor</code> 每次生成的代码是不是正确的。更好的方法是先去验证下 <code>Cusor</code> 写的代码是否正确，让后再点击 <code>accept all</code>，当然如果你不小心点到了 <code>accept all</code>，也可以 <code>ctrl + z</code> 撤回。</p>
<h3 data-id="heading-9">Cursor 锁区问题</h3>
<p>在 <code>2025</code> 年的<code>7</code> 月份，<code>Cursor</code> <strong>中断</strong>了<strong>中国大陆用户</strong>的多个<strong>模型使用权</strong>。我们常使用几个模型比如 <code>Claude</code> 系列、<code>Gemini</code> 系列，在国内都无法使用：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/554abda2cf9840c186fd6e7b89db5b34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5Y2D5rWU5ZGA:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383607&amp;x-signature=NbcH21oWKoNKh67iz22yyNjFGaw%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-10">为什么会这样</h4>
<p>老实说，这次的锁区事件其实跟 <code>Cursor</code> <strong>关系并不大</strong>，<code>Cursor</code> 作为一个 <code>AI</code>+<code>IDE</code> 编辑器，他自身其实并不开发模型，它是基于 <code>VSCode</code>​ 开源代码进行开发，再通过他的网络去调用如：<code>Claude</code>、<code>ChatGPT</code>、<code>Gemini</code> 等等这些模型，去使用的模型的能力。</p>
<p><code>Cursor</code> 也在他的公告里为自己喊冤：</p>
<blockquote>
<p>Some models in <code>Cursor</code> may be unavailable in certain regions based on the terms and policies set by the model providers. We plan to re‑enable all models in any regions where they are supported. If our model partners allow access to your region, we plan to restore the affected models and update this page.</p>
</blockquote>
<p>大概意思就是，这种限制并非 <code>Cursor</code> 故意为之，而是受到上游模型提供商政策变化的影响。类似的情况在 <code>AI</code> 行业<strong>并不罕见</strong>， <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.anthropic.com%2Fen%2Fapi%2Fsupported-regions" target="_blank" title="https://docs.anthropic.com/en/api/supported-regions" ref="nofollow noopener noreferrer"><code>Anthropic</code>（<code>Claude</code>）</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fhelp.openai.com%2Fzh-hans-cn%2Farticles%2F5347006-openai-api-supported-countries-and-territories" target="_blank" title="https://help.openai.com/zh-hans-cn/articles/5347006-openai-api-supported-countries-and-territories" ref="nofollow noopener noreferrer"><code>OpenAI</code>（<code>GPT</code> / <code>o-series</code>）</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fai.google.dev%2Fgemini-api%2Fdocs%2Favailable-regions%3Fhl%3Dzh-cn" target="_blank" title="https://ai.google.dev/gemini-api/docs/available-regions?hl=zh-cn" ref="nofollow noopener noreferrer">Google（<code>Gemini</code>）</a>等公司都有自己的不支持国家和地区。遗憾的是，中国大陆地区都在这三家公司的封禁名单中... 即使是翻墙也不行</p>
<h4 data-id="heading-11">怎么办？</h4>
<p><code>Cursor</code> 官方给了几个方案</p>
<ol>
<li>勾选 <code>Auto</code> 选项，每次请求时<strong>自动选择可用模型</strong>。</li>
<li>如果你有能在当地正常使用的 <code>API</code> key，可以在 <code>Cursor</code> 中配置他，这样就可以绕过去限制。</li>
<li>申请按比例退款</li>
</ol>
<p>这三种方案其实<strong>都没有真正解决问</strong>题。官方相当于直接摆烂了，直接告诉国内用户：我也没办法了，您要不勉强用，要不直接退款吧。</p>
<p>真实情况也是如此——在 <code>Cursor</code> 的锁区事件后，大批量的中国用户<strong>放弃</strong>使用 <code>Cursor</code>，转而使用 <code>Trae</code>、<code>Windsurf</code> 等替代品。那段时间我也放弃 <code>Cursor</code> 去试用了下 <code>Trae</code>，但是使用了一段时间后， <code>Trae</code>着实令我有点失望，生成的代码常常驴头不对马嘴，智能这方面远远不如 <code>Cursor</code>，于是我又回到了 <code>Cursor</code> 的怀抱...</p>
<p>锁区的问题还是得解决啊，民间社区中也有人逐渐摸索出了<strong>解决方案</strong>：</p>
<ol>
<li><strong>修改网络类型</strong>：<code>ctrl + shift + j</code> 打开控制面板后，点击 <code>Network</code>，修改 <code>http</code> 模式，把默认的 <code>HTTP/2</code> 修改为 <code>HTTP/1.1</code></li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/847a6b6640a840ea8527ee4cdec01b65~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5Y2D5rWU5ZGA:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383607&amp;x-signature=BFxyUTwHrsDJh6JAOK9NZnTZDek%3D" alt="image.png" loading="lazy"/></p>
<ol start="2">
<li>打在你的代理工具中，<strong>将 Tun Mode 打开</strong></li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01d734e316bc4a20b6935c43f4ff0dd0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5Y2D5rWU5ZGA:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768383607&amp;x-signature=94lF6n0fmmjHPRdNV0VrE4oox7Y%3D" alt="image.png" loading="lazy"/></p>
<p>我实际测试了下，效果还行，常用的几个模型都能使用，就是链接有时候会中断，应该是我的代理不太稳定的问题。</p>
<p>社区中也有人使用 <code>Proxifier</code> 转发 <code>api2.cursor.sh:443</code> 来实现，这样既可以使用 <code>http2</code> 享受低延迟，也可以用上 <code>claude</code> 等模型，感兴趣的朋友可以查下相关文章去尝试下。</p>
<p>一顿操作下来也是够麻烦，使用体验还没有以前好。这次的锁区事件本质上还是受美国 <code>AI</code> 出口管制以及国家安全相关政策的影响，或者说是受中美技术竞争的影响，也不知道什么时候<strong>技术开放化</strong>才能真正到来，让国界不再成为开发者的一个门槛。同时国内的相关公司也得支棱起来啊，让自己的<code>AI</code> 编辑器更好用些。</p>
<h3 data-id="heading-12">Rules</h3>
<p>想要用好 <code>AI</code> 编辑器，<code>rules</code> 肯定是不能绕过去的，合理的 <code>rules</code> 能够提供明确的结构化指导来约束 <code>AI</code> 的行为，并且有效对抗“<code>AI</code>”幻觉，确保生成的代码符合项目标准。</p>
<p>当前 <code>Cursor</code> 有三种类型规则</p>
<ol>
<li><strong>项目规</strong>则：存储在 .<code>cursor</code>/rules 中，受版本控制，作用范围限定在你的代码库内</li>
<li><strong>用户规则</strong>：在整个 <code>Cursor</code> 环境中全局生效，由 <code>Agent</code>（<code>Chat</code>）使用</li>
<li><strong>AGENTS.md</strong>：以 <code>Markdown</code> 格式编写的 <code>Agent</code> 指令，是 .<code>cursor</code>/rules 的简洁替代方案（一般来说很少使用）。</li>
</ol>
<p>旧版本的<code>.cursorrules</code> 规则文件已经被废弃，当前我还是更推荐写在 <code>.cursor/rules</code> 中的项目规则。</p>
<p>不同于面向全部项目生效的用户规则配置这么简单，项目规则需要根据不同类型的开发项目进行针对性撰写，尤其是其中的<code>角色定位</code>、<code>技术栈选择</code>、<code>代码规范</code>等要求，所以<code>rules</code> 要想写全写好，还真不是个简单事。为此，我的想法是——先找到一个通用的 <code>rules</code> 模板，然后 <code>AI</code> 编辑器中让 <code>AI</code> 分析当前项目的同时，结合我们之前给定的 <code>rules</code> 模板，生成一个符合我们当前项目要求的 <code>rules</code>。我当前使用 <code>rules</code> 模板如下：</p>
<pre><code class="hljs language-swift" lang="swift">角色：
你是一名精通  开发的高级工程师，拥有<span class="hljs-number">10</span>年以上的  应用开发经验，熟悉  等开发工具和技术栈<span class="hljs-operator">。</span>你的任务是帮助用户设计和开发易用且易于维护的  应用<span class="hljs-operator">。</span>始终遵循最佳实践，并坚持干净代码和健壮架构的原则<span class="hljs-operator">。</span>
目标:
你的目标是以用户容易理解的方式帮助他们完成  应用的设计和开发工作，确保应用功能完善<span class="hljs-operator">、</span>性能优异<span class="hljs-operator">、</span>用户体验良好<span class="hljs-operator">。</span>
要求:
在理解用户需求<span class="hljs-operator">、</span>设计<span class="hljs-type">UI</span><span class="hljs-operator">、</span>编写代码<span class="hljs-operator">、</span>解决问题和项目迭代优化时，你应该始终遵循以下原则：
项目初始化

在项目开始时，首先仔细阅读项目目录下的 <span class="hljs-type">README</span>.md文件并理解其内容，包括项目的目标<span class="hljs-operator">、</span>功能架构<span class="hljs-operator">、</span>技术栈和开发计划，确保对项目的整体架构和实现方式有清晰的认识；

如果还没有<span class="hljs-type">README</span>.md文件，请主动创建一个，用于后续记录该应用的功能模块<span class="hljs-operator">、</span>页面结构<span class="hljs-operator">、</span>数据流<span class="hljs-operator">、</span>依赖库等信息<span class="hljs-operator">。</span>
需求理解

充分理解用户需求，站在用户角度思考，分析需求是否存在缺漏，并与用户讨论完善需求；

选择最简单的解决方案来满足用户需求，避免过度设计<span class="hljs-operator">。</span>
<span class="hljs-type">UI和样式设计</span>

使用现代<span class="hljs-type">UI框架进行样式设计（例如</span><span class="hljs-operator">*</span>，这里可以根据不同开发项目仔细展开，比如使用哪些视觉规范或者<span class="hljs-type">UI框架，没有的话也可以不用过多展开）；</span>

在不同平台上实现一致的设计和响应式模式
代码编写

技术选型：根据项目需求选择合适的技术栈（例如<span class="hljs-operator">*</span>，这里需要仔细展开，比如介绍某个技术栈用在什么地方，以及要遵循什么最佳实践）

代码结构：强调代码的清晰性<span class="hljs-operator">、</span>模块化<span class="hljs-operator">、</span>可维护性，遵循最佳实践（如<span class="hljs-type">DRY原则</span><span class="hljs-operator">、</span>最小权限原则<span class="hljs-operator">、</span>响应式设计等）

代码安全性：在编写代码时，始终考虑安全性，避免引入漏洞，确保用户输入的安全处理

性能优化：优化代码的性能，减少资源占用，提升加载速度，确保项目的高效运行

测试与文档：编写单元测试，确保代码的健壮性，并提供清晰的中文注释和文档，方便后续阅读和维护

问题解决

全面阅读相关代码，理解 <span class="hljs-operator">*</span> 应用的工作原理

根据用户的反馈分析问题的原因，提出解决问题的思路

确保每次代码变更不会破坏现有功能，且尽可能保持最小的改动
迭代优化

与用户保持密切沟通，根据反馈调整功能和设计，确保应用符合用户需求

在不确定需求时，主动询问用户以澄清需求或技术细节

每次迭代都需要更新<span class="hljs-type">README</span>.md文件，包括功能说明和优化建议
方法论

系统<span class="hljs-number">2</span>思维：以分析严谨的方式解决问题<span class="hljs-operator">。</span>将需求分解为更小<span class="hljs-operator">、</span>可管理的部分，并在实施前仔细考虑每一步

思维树：评估多种可能的解决方案及其后果<span class="hljs-operator">。</span>使用结构化的方法探索不同的路径，并选择最优的解决方案

迭代改进：在最终确定代码之前，考虑改进<span class="hljs-operator">、</span>边缘情况和优化<span class="hljs-operator">。</span>通过潜在增强的迭代，确保最终解决方案是健壮的
</code></pre>
<p>复制下这个<code>rules</code>模板，在<code>chat</code>中输入</p>
<blockquote>
<p>根据以上提供的rules模板，结合当前项目，生成符合这个项目的 rules，</p>
</blockquote>
<p>然后就可以让<code>Cursor</code>生成一个适用于本项目的<code>rules</code>。</p>
<h3 data-id="heading-13">什么时候该选择什么模型</h3>
<p>根据不同场景使用不同的模型。当然，每个人的编码体验可能有所差别，按照我的习惯：</p>
<ul>
<li>日常编码、补全，使用时<code>Claude-4-Sonnet/Gemini-2.5-Pro</code></li>
<li>调试复杂错误时，使用<code>GPT</code>/<code>O3</code>/<code>O4</code></li>
<li>处理大型代码库，使用<code>Gemini Flash 2.0</code></li>
</ul>
<p>各个模型的差别以及具体场景的模型使用可以参考<a href="https://juejin.cn/post/7535747930281787426" target="_blank" title="https://juejin.cn/post/7535747930281787426">这个文章</a>。</p>
<p><del>嫌麻烦直接<code>Auto</code>一把梭！</del></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Java基础整理】Java字符串处理，String、StringBuffer、StringBuilder]]></title>    <link>https://juejin.cn/post/7592432859862499362</link>    <guid>https://juejin.cn/post/7592432859862499362</guid>    <pubDate>2026-01-07T10:06:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592432859862499362" data-draft-id="7592432859862482978" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Java基础整理】Java字符串处理，String、StringBuffer、StringBuilder"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-01-07T10:06:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="乌日尼乐"/> <meta itemprop="url" content="https://juejin.cn/user/854736525882123"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Java基础整理】Java字符串处理，String、StringBuffer、StringBuilder
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/854736525882123/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    乌日尼乐
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:06:22.000Z" title="Wed Jan 07 2026 10:06:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Java字符串处理详解，String、StringBuffer、StringBuilder</h2>
<h3 data-id="heading-1">1. CharSequence接口概述</h3>
<h4 data-id="heading-2">接口定义</h4>
<p><code>CharSequence</code>接口是char值的一个可读序列，是Java字符串处理的顶层接口。</p>
<h4 data-id="heading-3">实现类</h4>
<p>Java中主要有三个类实现了<code>CharSequence</code>接口：</p>

























<table><thead><tr><th>实现类</th><th>特点</th><th>用途</th></tr></thead><tbody><tr><td><code>String</code></td><td>不可变字符串</td><td>一般字符串操作</td></tr><tr><td><code>StringBuffer</code></td><td>可变字符串，线程安全</td><td>多线程环境下的字符串构建</td></tr><tr><td><code>StringBuilder</code></td><td>可变字符串，线程不安全</td><td>单线程环境下的字符串构建</td></tr></tbody></table>
<h4 data-id="heading-4">共同特征</h4>
<ul>
<li>都被<code>final</code>修饰符修饰，<strong>无法被继承</strong></li>
<li><strong>无法重写方法</strong></li>
<li>都提供了字符序列的基本操作方法</li>
</ul>
<h3 data-id="heading-5">2. String类详解</h3>
<h4 data-id="heading-6">2.1 String类特点</h4>
<p><code>String</code>类是描述字符串的类，具有以下特征：</p>
<ul>
<li><strong>实现接口</strong>：<code>Serializable</code>、<code>CharSequence</code>、<code>Comparable</code>接口</li>
<li><strong>不可变性</strong>：String对象是常量，一旦被初始化不能改变</li>
<li><strong>线程安全</strong>：由于不可变性，天然线程安全</li>
<li><strong>内存优化</strong>：使用字符串常量池进行内存管理</li>
</ul>
<h4 data-id="heading-7">2.2 String构造方法</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 空字符串构造</span>
<span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();  <span class="hljs-comment">// 相当于 ""</span>

<span class="hljs-comment">// 2. 从另一个String构造（克隆）</span>
<span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello"</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(original);  <span class="hljs-comment">// 创建original的副本对象</span>

<span class="hljs-comment">// 3. 从字节数组构造</span>
<span class="hljs-type">byte</span>[] bytes = {<span class="hljs-number">72</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>};  <span class="hljs-comment">// "Hello"的ASCII码</span>
<span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes);  <span class="hljs-comment">// 使用系统默认编码转换</span>

<span class="hljs-comment">// 4. 从字符数组构造</span>
<span class="hljs-type">char</span>[] chars = {<span class="hljs-string">'H'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>};
<span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);  <span class="hljs-comment">// 将字符数组转换成字符串</span>

<span class="hljs-comment">// 5. 直接赋值（推荐）</span>
<span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello"</span>;  <span class="hljs-comment">// 最常用的方式</span>
</code></pre>
<h4 data-id="heading-8">2.3 String常用方法</h4>
<h5 data-id="heading-9">获取类方法</h5>













































<table><thead><tr><th>方法名</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>charAt(int index)</code></td><td>获取指定位置上的字符</td><td><code>"Hello".charAt(1)</code> → <code>'e'</code></td></tr><tr><td><code>codePointAt(int index)</code></td><td>获取指定位置字符的ASCII码</td><td><code>"A".codePointAt(0)</code> → <code>65</code></td></tr><tr><td><code>length()</code></td><td>获取字符串长度</td><td><code>"Hello".length()</code> → <code>5</code></td></tr><tr><td><code>indexOf(String str)</code></td><td>获取子串首次出现位置</td><td><code>"Hello".indexOf("ll")</code> → <code>2</code></td></tr><tr><td><code>lastIndexOf(String str)</code></td><td>反向获取子串位置</td><td><code>"Hello".lastIndexOf("l")</code> → <code>3</code></td></tr><tr><td><code>substring(int beginIndex)</code></td><td>获取从指定位置开始的子串</td><td><code>"Hello".substring(1)</code> → <code>"ello"</code></td></tr><tr><td><code>substring(int begin, int end)</code></td><td>获取指定范围的子串</td><td><code>"Hello".substring(1,4)</code> → <code>"ell"</code></td></tr></tbody></table>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 获取方法示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringGetDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello World"</span>;
        
        System.out.println(<span class="hljs-string">"字符串长度: "</span> + str.length());           <span class="hljs-comment">// 11</span>
        System.out.println(<span class="hljs-string">"第5个字符: "</span> + str.charAt(<span class="hljs-number">4</span>));           <span class="hljs-comment">// 'o'</span>
        System.out.println(<span class="hljs-string">"'o'的位置: "</span> + str.indexOf(<span class="hljs-string">'o'</span>));        <span class="hljs-comment">// 4</span>
        System.out.println(<span class="hljs-string">"'l'最后位置: "</span> + str.lastIndexOf(<span class="hljs-string">'l'</span>));   <span class="hljs-comment">// 9</span>
        System.out.println(<span class="hljs-string">"子串: "</span> + str.substring(<span class="hljs-number">6</span>));            <span class="hljs-comment">// "World"</span>
        System.out.println(<span class="hljs-string">"子串: "</span> + str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>));         <span class="hljs-comment">// "Hello"</span>
        
        <span class="hljs-comment">// indexOf也可以判断是否包含某字符或字符串</span>
        <span class="hljs-keyword">if</span> (str.indexOf(<span class="hljs-string">"World"</span>) != -<span class="hljs-number">1</span>) {
            System.out.println(<span class="hljs-string">"字符串包含'World'"</span>);
        }
    }
}
</code></pre>
<h5 data-id="heading-10">判断类方法</h5>


















































<table><thead><tr><th>方法名</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>matches(String regex)</code></td><td>判断是否匹配正则表达式</td><td><code>"123".matches("\\d+")</code> → <code>true</code></td></tr><tr><td><code>endsWith(String suffix)</code></td><td>判断是否以指定字符串结尾</td><td><code>"Hello.java".endsWith(".java")</code> → <code>true</code></td></tr><tr><td><code>startsWith(String prefix)</code></td><td>判断是否以指定字符串开头</td><td><code>"Hello".startsWith("He")</code> → <code>true</code></td></tr><tr><td><code>isEmpty()</code></td><td>是否为空（JDK 1.6后）</td><td><code>"".isEmpty()</code> → <code>true</code></td></tr><tr><td><code>contains(CharSequence s)</code></td><td>是否包含指定字符序列</td><td><code>"Hello".contains("ell")</code> → <code>true</code></td></tr><tr><td><code>equals(Object obj)</code></td><td>判断字符串内容是否相同</td><td><code>"Hello".equals("Hello")</code> → <code>true</code></td></tr><tr><td><code>equalsIgnoreCase(String str)</code></td><td>忽略大小写判断内容是否相同</td><td><code>"Hello".equalsIgnoreCase("hello")</code> → <code>true</code></td></tr><tr><td><code>compareTo(String str)</code></td><td>按字典顺序比较字符串</td><td><code>"abc".compareTo("abd")</code> → <code>-1</code></td></tr></tbody></table>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 判断方法示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringJudgeDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello World"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"HELLO WORLD"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> <span class="hljs-string">"user@example.com"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-string">"13812345678"</span>;
        
        <span class="hljs-comment">// 基本判断</span>
        System.out.println(<span class="hljs-string">"是否为空: "</span> + str1.isEmpty());                    <span class="hljs-comment">// false</span>
        System.out.println(<span class="hljs-string">"包含'World': "</span> + str1.contains(<span class="hljs-string">"World"</span>));        <span class="hljs-comment">// true</span>
        System.out.println(<span class="hljs-string">"以'Hello'开头: "</span> + str1.startsWith(<span class="hljs-string">"Hello"</span>));     <span class="hljs-comment">// true</span>
        System.out.println(<span class="hljs-string">"以'.com'结尾: "</span> + email.endsWith(<span class="hljs-string">".com"</span>));       <span class="hljs-comment">// true</span>
        
        <span class="hljs-comment">// 相等性判断</span>
        System.out.println(<span class="hljs-string">"内容相等: "</span> + str1.equals(str2));                 <span class="hljs-comment">// false</span>
        System.out.println(<span class="hljs-string">"忽略大小写相等: "</span> + str1.equalsIgnoreCase(str2)); <span class="hljs-comment">// true</span>
        
        <span class="hljs-comment">// 字典顺序比较</span>
        System.out.println(<span class="hljs-string">"字典顺序比较: "</span> + <span class="hljs-string">"abc"</span>.compareTo(<span class="hljs-string">"abd"</span>));         <span class="hljs-comment">// -1</span>
        
        <span class="hljs-comment">// 正则表达式匹配</span>
        System.out.println(<span class="hljs-string">"是否为手机号: "</span> + phone.matches(<span class="hljs-string">"1[3-9]\\d{9}"</span>));  <span class="hljs-comment">// true</span>
    }
}
</code></pre>
<h5 data-id="heading-11">转换类方法</h5>








































<table><thead><tr><th>方法名</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>toCharArray()</code></td><td>转换为字符数组</td><td><code>"Hello".toCharArray()</code> → <code>['H','e','l','l','o']</code></td></tr><tr><td><code>getBytes()</code></td><td>转换为字节数组</td><td><code>"Hello".getBytes()</code></td></tr><tr><td><code>toUpperCase()</code></td><td>转换为大写</td><td><code>"hello".toUpperCase()</code> → <code>"HELLO"</code></td></tr><tr><td><code>toLowerCase()</code></td><td>转换为小写</td><td><code>"HELLO".toLowerCase()</code> → <code>"hello"</code></td></tr><tr><td><code>copyValueOf(char[] data)</code></td><td>静态方法，字符数组转字符串</td><td><code>String.copyValueOf(chars)</code></td></tr><tr><td><code>valueOf(基本类型)</code></td><td>静态方法，基本类型转字符串</td><td><code>String.valueOf(123)</code> → <code>"123"</code></td></tr></tbody></table>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 转换方法示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringConvertDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello World"</span>;
        
        <span class="hljs-comment">// 转换为字符数组</span>
        <span class="hljs-type">char</span>[] chars = str.toCharArray();
        System.out.println(<span class="hljs-string">"字符数组: "</span> + Arrays.toString(chars));
        
        <span class="hljs-comment">// 转换为字节数组</span>
        <span class="hljs-type">byte</span>[] bytes = str.getBytes();
        System.out.println(<span class="hljs-string">"字节数组: "</span> + Arrays.toString(bytes));
        
        <span class="hljs-comment">// 大小写转换</span>
        System.out.println(<span class="hljs-string">"大写: "</span> + str.toUpperCase());        <span class="hljs-comment">// "HELLO WORLD"</span>
        System.out.println(<span class="hljs-string">"小写: "</span> + str.toLowerCase());        <span class="hljs-comment">// "hello world"</span>
        
        <span class="hljs-comment">// 静态方法：基本类型转字符串</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">intStr</span> <span class="hljs-operator">=</span> String.valueOf(<span class="hljs-number">123</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">doubleStr</span> <span class="hljs-operator">=</span> String.valueOf(<span class="hljs-number">3.14</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">boolStr</span> <span class="hljs-operator">=</span> String.valueOf(<span class="hljs-literal">true</span>);
        
        System.out.println(<span class="hljs-string">"整数转字符串: "</span> + intStr);              <span class="hljs-comment">// "123"</span>
        System.out.println(<span class="hljs-string">"小数转字符串: "</span> + doubleStr);           <span class="hljs-comment">// "3.14"</span>
        System.out.println(<span class="hljs-string">"布尔转字符串: "</span> + boolStr);             <span class="hljs-comment">// "true"</span>
        
        <span class="hljs-comment">// 字符数组转字符串</span>
        <span class="hljs-type">char</span>[] charArray = {<span class="hljs-string">'J'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'v'</span>, <span class="hljs-string">'a'</span>};
        <span class="hljs-type">String</span> <span class="hljs-variable">fromChars</span> <span class="hljs-operator">=</span> String.copyValueOf(charArray);
        System.out.println(<span class="hljs-string">"字符数组转字符串: "</span> + fromChars);        <span class="hljs-comment">// "Java"</span>
    }
}
</code></pre>
<h5 data-id="heading-12">替换类方法</h5>






























<table><thead><tr><th>方法名</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>replace(char oldChar, char newChar)</code></td><td>替换所有指定字符</td><td><code>"Hello".replace('l', 'x')</code> → <code>"Hexxo"</code></td></tr><tr><td><code>replace(CharSequence target, CharSequence replacement)</code></td><td>替换所有指定字符串</td><td><code>"Hello World".replace("World", "Java")</code></td></tr><tr><td><code>replaceAll(String regex, String replacement)</code></td><td>用正则表达式替换</td><td><code>"abc123def".replaceAll("\\d+", "XXX")</code></td></tr><tr><td><code>replaceFirst(String regex, String replacement)</code></td><td>替换第一个匹配项</td><td><code>"abc123def456".replaceFirst("\\d+", "XXX")</code></td></tr></tbody></table>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 替换方法示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringReplaceDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello World, Hello Java"</span>;
        
        <span class="hljs-comment">// 字符替换</span>
        System.out.println(<span class="hljs-string">"替换字符'l': "</span> + str.replace(<span class="hljs-string">'l'</span>, <span class="hljs-string">'x'</span>));
        <span class="hljs-comment">// 输出: "Hexxo Worxd, Hexxo Java"</span>
        
        <span class="hljs-comment">// 字符串替换</span>
        System.out.println(<span class="hljs-string">"替换'Hello': "</span> + str.replace(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"Hi"</span>));
        <span class="hljs-comment">// 输出: "Hi World, Hi Java"</span>
        
        <span class="hljs-comment">// 正则表达式替换所有</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">"电话：138-1234-5678，手机：139-8765-4321"</span>;
        System.out.println(<span class="hljs-string">"隐藏手机号: "</span> + text.replaceAll(<span class="hljs-string">"1[3-9]\\d-\\d{4}-\\d{4}"</span>, <span class="hljs-string">"***-****-****"</span>));
        
        <span class="hljs-comment">// 只替换第一个匹配项</span>
        System.out.println(<span class="hljs-string">"替换第一个'Hello': "</span> + str.replaceFirst(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"Hi"</span>));
        <span class="hljs-comment">// 输出: "Hi World, Hello Java"</span>
    }
}
</code></pre>
<h5 data-id="heading-13">切割类方法</h5>




















<table><thead><tr><th>方法名</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>split(String regex)</code></td><td>按正则表达式切割字符串</td><td><code>"a,b,c".split(",")</code> → <code>["a","b","c"]</code></td></tr><tr><td><code>split(String regex, int limit)</code></td><td>限制切割次数</td><td><code>"a,b,c,d".split(",", 2)</code> → <code>["a","b,c,d"]</code></td></tr></tbody></table>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 切割方法示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringSplitDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"apple,banana,orange,grape"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">"C:\\Program Files\\Java\\bin"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Java   is    very   good"</span>;
        
        <span class="hljs-comment">// 基本切割</span>
        String[] fruits = str.split(<span class="hljs-string">","</span>);
        System.out.println(<span class="hljs-string">"水果数组: "</span> + Arrays.toString(fruits));
        <span class="hljs-comment">// 输出: [apple, banana, orange, grape]</span>
        
        <span class="hljs-comment">// 按反斜杠切割（需要转义）</span>
        String[] pathParts = path.split(<span class="hljs-string">"\\\\"</span>);
        System.out.println(<span class="hljs-string">"路径分割: "</span> + Arrays.toString(pathParts));
        <span class="hljs-comment">// 输出: [C:, Program Files, Java, bin]</span>
        
        <span class="hljs-comment">// 按正则表达式切割（多个空格）</span>
        String[] words = text.split(<span class="hljs-string">"\\s+"</span>);
        System.out.println(<span class="hljs-string">"单词数组: "</span> + Arrays.toString(words));
        <span class="hljs-comment">// 输出: [Java, is, very, good]</span>
        
        <span class="hljs-comment">// 限制切割次数</span>
        String[] limitedSplit = str.split(<span class="hljs-string">","</span>, <span class="hljs-number">2</span>);
        System.out.println(<span class="hljs-string">"限制切割: "</span> + Arrays.toString(limitedSplit));
        <span class="hljs-comment">// 输出: [apple, banana,orange,grape]</span>
    }
}
</code></pre>
<h5 data-id="heading-14">去除类方法</h5>






























<table><thead><tr><th>方法名</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>trim()</code></td><td>去除两端空格</td><td><code>" Hello ".trim()</code> → <code>"Hello"</code></td></tr><tr><td><code>strip()</code></td><td>去除两端空白字符（JDK 11+）</td><td><code>" Hello ".strip()</code> → <code>"Hello"</code></td></tr><tr><td><code>stripLeading()</code></td><td>去除开头空白字符（JDK 11+）</td><td><code>" Hello ".stripLeading()</code> → <code>"Hello "</code></td></tr><tr><td><code>stripTrailing()</code></td><td>去除结尾空白字符（JDK 11+）</td><td><code>" Hello ".stripTrailing()</code> → <code>" Hello"</code></td></tr></tbody></table>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 去除方法示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTrimDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"  Hello World  "</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"\t\n  Java Programming  \r\n"</span>;
        
        System.out.println(<span class="hljs-string">"原字符串: '"</span> + str + <span class="hljs-string">"'"</span>);
        System.out.println(<span class="hljs-string">"去除空格: '"</span> + str.trim() + <span class="hljs-string">"'"</span>);
        
        System.out.println(<span class="hljs-string">"原字符串: '"</span> + str2 + <span class="hljs-string">"'"</span>);
        System.out.println(<span class="hljs-string">"去除空格: '"</span> + str2.trim() + <span class="hljs-string">"'"</span>);
        
        <span class="hljs-comment">// 实际应用：处理用户输入</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">userInput</span> <span class="hljs-operator">=</span> <span class="hljs-string">"  user@example.com  "</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">cleanInput</span> <span class="hljs-operator">=</span> userInput.trim();
        System.out.println(<span class="hljs-string">"清理后的输入: '"</span> + cleanInput + <span class="hljs-string">"'"</span>);
    }
}
</code></pre>
<h3 data-id="heading-15">3. StringBuffer类详解</h3>
<h4 data-id="heading-16">3.1 StringBuffer特点</h4>
<ul>
<li><strong>可变长度</strong>：可以对字符串内容进行修改、增加和删除</li>
<li><strong>线程安全</strong>：方法被synchronized修饰，适用于多线程环境</li>
<li><strong>缓冲容器</strong>：内部使用字符数组作为缓冲区</li>
<li><strong>最终转换</strong>：通过<code>toString()</code>方法返回String对象</li>
</ul>
<h4 data-id="heading-17">3.2 StringBuffer构造方法</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 1. 默认构造方法，初始容量为16</span>
<span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();

<span class="hljs-comment">// 2. 指定初始容量</span>
<span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-number">50</span>);

<span class="hljs-comment">// 3. 用字符串初始化</span>
<span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">"Hello"</span>);
</code></pre>
<h4 data-id="heading-18">3.3 StringBuffer特有方法</h4>
<h5 data-id="heading-19">修改类方法</h5>













































<table><thead><tr><th>方法名</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>append(各种类型)</code></td><td>将数据添加到结尾</td><td><code>sb.append("World")</code></td></tr><tr><td><code>insert(int offset, 各种类型)</code></td><td>在指定位置插入数据</td><td><code>sb.insert(5, " Java")</code></td></tr><tr><td><code>delete(int start, int end)</code></td><td>删除指定范围内容</td><td><code>sb.delete(0, 5)</code></td></tr><tr><td><code>deleteCharAt(int index)</code></td><td>删除指定位置字符</td><td><code>sb.deleteCharAt(0)</code></td></tr><tr><td><code>reverse()</code></td><td>反转字符串</td><td><code>sb.reverse()</code></td></tr><tr><td><code>replace(int start, int end, String str)</code></td><td>替换指定范围内容</td><td><code>sb.replace(0, 5, "Hi")</code></td></tr><tr><td><code>setCharAt(int index, char ch)</code></td><td>替换指定位置字符</td><td><code>sb.setCharAt(0, 'H')</code></td></tr></tbody></table>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// StringBuffer修改方法示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBufferDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">"Hello"</span>);
        System.out.println(<span class="hljs-string">"初始值: "</span> + sb);                <span class="hljs-comment">// Hello</span>
        
        <span class="hljs-comment">// append - 追加内容</span>
        sb.append(<span class="hljs-string">" World"</span>);
        System.out.println(<span class="hljs-string">"追加后: "</span> + sb);                 <span class="hljs-comment">// Hello World</span>
        
        sb.append(<span class="hljs-number">123</span>).append(<span class="hljs-literal">true</span>).append(<span class="hljs-number">3.14</span>);
        System.out.println(<span class="hljs-string">"链式追加: "</span> + sb);               <span class="hljs-comment">// Hello World123true3.14</span>
        
        <span class="hljs-comment">// insert - 插入内容</span>
        sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">"Hello World"</span>);
        sb.insert(<span class="hljs-number">6</span>, <span class="hljs-string">"Java "</span>);
        System.out.println(<span class="hljs-string">"插入后: "</span> + sb);                 <span class="hljs-comment">// Hello Java World</span>
        
        <span class="hljs-comment">// delete - 删除内容</span>
        sb.delete(<span class="hljs-number">6</span>, <span class="hljs-number">11</span>);  <span class="hljs-comment">// 删除"Java "</span>
        System.out.println(<span class="hljs-string">"删除后: "</span> + sb);                 <span class="hljs-comment">// Hello World</span>
        
        <span class="hljs-comment">// deleteCharAt - 删除单个字符</span>
        sb.deleteCharAt(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 删除空格</span>
        System.out.println(<span class="hljs-string">"删除字符后: "</span> + sb);              <span class="hljs-comment">// HelloWorld</span>
        
        <span class="hljs-comment">// replace - 替换内容</span>
        sb.replace(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"Hi"</span>);
        System.out.println(<span class="hljs-string">"替换后: "</span> + sb);                 <span class="hljs-comment">// HiWorld</span>
        
        <span class="hljs-comment">// reverse - 反转</span>
        sb.reverse();
        System.out.println(<span class="hljs-string">"反转后: "</span> + sb);                 <span class="hljs-comment">// dlroWiH</span>
        
        <span class="hljs-comment">// setCharAt - 设置指定位置字符</span>
        sb.setCharAt(<span class="hljs-number">0</span>, <span class="hljs-string">'D'</span>);
        System.out.println(<span class="hljs-string">"设置字符后: "</span> + sb);              <span class="hljs-comment">// DlroWiH</span>
    }
}
</code></pre>
<h5 data-id="heading-20">获取类方法（与String类似）</h5>





































<table><thead><tr><th>方法名</th><th>功能描述</th></tr></thead><tbody><tr><td><code>charAt(int index)</code></td><td>获取指定位置字符</td></tr><tr><td><code>indexOf(String str)</code></td><td>获取子串位置</td></tr><tr><td><code>lastIndexOf(String str)</code></td><td>反向获取子串位置</td></tr><tr><td><code>length()</code></td><td>获取长度</td></tr><tr><td><code>substring(int start)</code></td><td>获取子串</td></tr><tr><td><code>substring(int start, int end)</code></td><td>获取指定范围子串</td></tr><tr><td><code>toString()</code></td><td>转换为String对象</td></tr></tbody></table>
<h4 data-id="heading-21">3.4 StringBuffer其他实用方法</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// StringBuffer其他方法示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBufferAdvancedDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">"Hello World"</span>);
        
        <span class="hljs-comment">// 获取字符数组</span>
        <span class="hljs-type">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">5</span>];
        sb.getChars(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, chars, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 从sb的0-5位置复制到chars数组</span>
        System.out.println(<span class="hljs-string">"字符数组: "</span> + Arrays.toString(chars));  <span class="hljs-comment">// [H, e, l, l, o]</span>
        
        <span class="hljs-comment">// 容量相关</span>
        System.out.println(<span class="hljs-string">"当前长度: "</span> + sb.length());           <span class="hljs-comment">// 11</span>
        System.out.println(<span class="hljs-string">"当前容量: "</span> + sb.capacity());         <span class="hljs-comment">// 27 (初始16 + 扩展)</span>
        
        <span class="hljs-comment">// 确保容量</span>
        sb.ensureCapacity(<span class="hljs-number">50</span>);
        System.out.println(<span class="hljs-string">"确保容量后: "</span> + sb.capacity());       <span class="hljs-comment">// 54</span>
        
        <span class="hljs-comment">// 设置长度</span>
        sb.setLength(<span class="hljs-number">5</span>);
        System.out.println(<span class="hljs-string">"设置长度后: "</span> + sb);                  <span class="hljs-comment">// Hello</span>
    }
}
</code></pre>
<h3 data-id="heading-22">4. StringBuilder类详解</h3>
<h4 data-id="heading-23">4.1 StringBuilder特点</h4>
<ul>
<li><strong>JDK 1.5后出现</strong>：作为StringBuffer的简易替换</li>
<li><strong>功能相同</strong>：与StringBuffer提供相同的API</li>
<li><strong>线程不安全</strong>：没有同步控制，性能更好</li>
<li><strong>单线程推荐</strong>：在单线程环境下推荐使用</li>
</ul>
<h4 data-id="heading-24">4.2 StringBuilder使用示例</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// StringBuilder使用示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">"Hello"</span>);
        
        <span class="hljs-comment">// 所有StringBuffer的方法StringBuilder都有</span>
        sb.append(<span class="hljs-string">" World"</span>)
          .append(<span class="hljs-string">" Java"</span>)
          .append(<span class="hljs-string">" Programming"</span>);
        
        System.out.println(<span class="hljs-string">"构建结果: "</span> + sb.toString());
        
        <span class="hljs-comment">// 性能测试对比</span>
        performanceTest();
    }
    
    <span class="hljs-comment">// 性能测试</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performanceTest</span><span class="hljs-params">()</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;
        
        <span class="hljs-comment">// String拼接测试</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; times; i++) {
            str += <span class="hljs-string">"a"</span>;
        }
        <span class="hljs-type">long</span> <span class="hljs-variable">stringTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;
        
        <span class="hljs-comment">// StringBuilder拼接测试</span>
        start = System.currentTimeMillis();
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; times; i++) {
            sb.append(<span class="hljs-string">"a"</span>);
        }
        <span class="hljs-type">String</span> <span class="hljs-variable">sbResult</span> <span class="hljs-operator">=</span> sb.toString();
        <span class="hljs-type">long</span> <span class="hljs-variable">sbTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;
        
        <span class="hljs-comment">// StringBuffer拼接测试</span>
        start = System.currentTimeMillis();
        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sbf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; times; i++) {
            sbf.append(<span class="hljs-string">"a"</span>);
        }
        <span class="hljs-type">String</span> <span class="hljs-variable">sbfResult</span> <span class="hljs-operator">=</span> sbf.toString();
        <span class="hljs-type">long</span> <span class="hljs-variable">sbfTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;
        
        System.out.println(<span class="hljs-string">"String拼接时间: "</span> + stringTime + <span class="hljs-string">"ms"</span>);
        System.out.println(<span class="hljs-string">"StringBuilder拼接时间: "</span> + sbTime + <span class="hljs-string">"ms"</span>);
        System.out.println(<span class="hljs-string">"StringBuffer拼接时间: "</span> + sbfTime + <span class="hljs-string">"ms"</span>);
    }
}
</code></pre>
<h3 data-id="heading-25">5. 三种字符串类的对比</h3>
<h4 data-id="heading-26">5.1 特性对比表</h4>















































<table><thead><tr><th>特性</th><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td><strong>可变性</strong></td><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td><strong>线程安全</strong></td><td>安全（不可变）</td><td>安全（同步）</td><td>不安全</td></tr><tr><td><strong>性能</strong></td><td>低（频繁创建对象）</td><td>中等</td><td>高</td></tr><tr><td><strong>内存使用</strong></td><td>高（创建多个对象）</td><td>低</td><td>低</td></tr><tr><td><strong>适用场景</strong></td><td>少量字符串操作</td><td>多线程环境</td><td>单线程环境</td></tr><tr><td><strong>JDK版本</strong></td><td>1.0+</td><td>1.0+</td><td>1.5+</td></tr></tbody></table>
<h4 data-id="heading-27">5.2 使用场景选择</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 使用场景示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringChoiceDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        
        <span class="hljs-comment">// 场景1：字符串不变，少量操作 - 使用String</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> greeting + <span class="hljs-string">" World!"</span>;  <span class="hljs-comment">// 适合用String</span>
        
        <span class="hljs-comment">// 场景2：单线程环境，大量字符串拼接 - 使用StringBuilder</span>
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">htmlBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        htmlBuilder.append(<span class="hljs-string">"&lt;html&gt;"</span>)
                  .append(<span class="hljs-string">"&lt;head&gt;&lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;"</span>)
                  .append(<span class="hljs-string">"&lt;body&gt;"</span>)
                  .append(<span class="hljs-string">"&lt;h1&gt;欢迎&lt;/h1&gt;"</span>)
                  .append(<span class="hljs-string">"&lt;/body&gt;"</span>)
                  .append(<span class="hljs-string">"&lt;/html&gt;"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> htmlBuilder.toString();
        
        <span class="hljs-comment">// 场景3：多线程环境，需要字符串拼接 - 使用StringBuffer</span>
        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">logBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();
        <span class="hljs-comment">// 多个线程可能同时操作logBuffer</span>
        <span class="hljs-keyword">synchronized</span>(logBuffer) {
            logBuffer.append(<span class="hljs-string">"[INFO] "</span>)
                    .append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())
                    .append(<span class="hljs-string">" - 应用启动成功"</span>);
        }
        
        <span class="hljs-comment">// 场景4：格式化字符串 - 使用String.format</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">"用户%s，年龄%d，余额%.2f"</span>, <span class="hljs-string">"张三"</span>, <span class="hljs-number">25</span>, <span class="hljs-number">1000.5</span>);
        System.out.println(formatted);
    }
}
</code></pre>
<h4 data-id="heading-28">5.3 性能对比测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 性能对比完整测试</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringPerformanceTest</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ITERATIONS</span> <span class="hljs-operator">=</span> <span class="hljs-number">50000</span>;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        testStringConcat();
        testStringBuilder();
        testStringBuffer();
    }
    
    <span class="hljs-comment">// 测试String拼接</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStringConcat</span><span class="hljs-params">()</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {
            result += <span class="hljs-string">"a"</span>;
        }
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"String拼接 "</span> + ITERATIONS + <span class="hljs-string">" 次耗时: "</span> + (end - start) + <span class="hljs-string">"ms"</span>);
    }
    
    <span class="hljs-comment">// 测试StringBuilder</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStringBuilder</span><span class="hljs-params">()</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {
            sb.append(<span class="hljs-string">"a"</span>);
        }
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> sb.toString();
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"StringBuilder拼接 "</span> + ITERATIONS + <span class="hljs-string">" 次耗时: "</span> + (end - start) + <span class="hljs-string">"ms"</span>);
    }
    
    <span class="hljs-comment">// 测试StringBuffer</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStringBuffer</span><span class="hljs-params">()</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sbf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {
            sbf.append(<span class="hljs-string">"a"</span>);
        }
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> sbf.toString();
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"StringBuffer拼接 "</span> + ITERATIONS + <span class="hljs-string">" 次耗时: "</span> + (end - start) + <span class="hljs-string">"ms"</span>);
    }
}
</code></pre>
<h3 data-id="heading-29">6. 字符串处理最佳实践</h3>
<h4 data-id="heading-30">6.1 选择原则</h4>
<ol>
<li><strong>字符串不变或少量操作</strong> → 使用 <code>String</code></li>
<li><strong>单线程大量拼接</strong> → 使用 <code>StringBuilder</code></li>
<li><strong>多线程大量拼接</strong> → 使用 <code>StringBuffer</code></li>
<li><strong>格式化字符串</strong> → 使用 <code>String.format()</code> 或 <code>MessageFormat</code></li>
</ol>
<h4 data-id="heading-31">6.2 常见陷阱和解决方案</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 字符串处理陷阱示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTrapDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        
        <span class="hljs-comment">// 陷阱1：字符串比较使用==而不是equals</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"Hello"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"Hello"</span>);
        System.out.println(<span class="hljs-string">"== 比较: "</span> + (str1 == str2));        <span class="hljs-comment">// false</span>
        System.out.println(<span class="hljs-string">"equals比较: "</span> + str1.equals(str2));   <span class="hljs-comment">// true</span>
        
        <span class="hljs-comment">// 陷阱2：空字符串判断</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">nullStr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">emptyStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;
        <span class="hljs-comment">// 错误方式</span>
        <span class="hljs-comment">// System.out.println(nullStr.isEmpty()); // NullPointerException</span>
        
        <span class="hljs-comment">// 正确方式</span>
        System.out.println(<span class="hljs-string">"null判断: "</span> + (nullStr == <span class="hljs-literal">null</span> || nullStr.isEmpty()));
        System.out.println(<span class="hljs-string">"空串判断: "</span> + (emptyStr == <span class="hljs-literal">null</span> || emptyStr.isEmpty()));
        
        <span class="hljs-comment">// 更好的方式（JDK 8+）</span>
        System.out.println(<span class="hljs-string">"使用工具类: "</span> + isBlank(nullStr));
        System.out.println(<span class="hljs-string">"使用工具类: "</span> + isBlank(emptyStr));
        System.out.println(<span class="hljs-string">"使用工具类: "</span> + isBlank(<span class="hljs-string">"  "</span>));
        
        <span class="hljs-comment">// 陷阱3：循环中的字符串拼接</span>
        <span class="hljs-comment">// 错误方式（性能差）</span>
        badStringConcat();
        
        <span class="hljs-comment">// 正确方式（性能好）</span>
        goodStringConcat();
        
        <span class="hljs-comment">// 陷阱4：split方法的特殊字符</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">"C:\\Users\\Documents\\file.txt"</span>;
        <span class="hljs-comment">// 错误方式</span>
        <span class="hljs-comment">// String[] parts = path.split("\\"); // 异常</span>
        
        <span class="hljs-comment">// 正确方式</span>
        String[] parts = path.split(<span class="hljs-string">"\\\\"</span>);  <span class="hljs-comment">// 需要双重转义</span>
        System.out.println(<span class="hljs-string">"路径分割: "</span> + Arrays.toString(parts));
    }
    
    <span class="hljs-comment">// 判断字符串是否为空或只包含空白字符</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBlank</span><span class="hljs-params">(String str)</span> {
        <span class="hljs-keyword">return</span> str == <span class="hljs-literal">null</span> || str.trim().isEmpty();
    }
    
    <span class="hljs-comment">// 错误的字符串拼接方式</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">badStringConcat</span><span class="hljs-params">()</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
            result += <span class="hljs-string">"第"</span> + i + <span class="hljs-string">"次拼接;"</span>;
        }
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"错误拼接耗时: "</span> + (end - start) + <span class="hljs-string">"ms"</span>);
    }
    
    <span class="hljs-comment">// 正确的字符串拼接方式</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodStringConcat</span><span class="hljs-params">()</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
            sb.append(<span class="hljs-string">"第"</span>).append(i).append(<span class="hljs-string">"次拼接;"</span>);
        }
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> sb.toString();
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"正确拼接耗时: "</span> + (end - start) + <span class="hljs-string">"ms"</span>);
    }
}
</code></pre>
<h4 data-id="heading-32">6.3 实用工具方法</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 字符串处理工具类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtils</span> {
    
    <span class="hljs-comment">// 判断字符串是否为空或null</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(String str)</span> {
        <span class="hljs-keyword">return</span> str == <span class="hljs-literal">null</span> || str.length() == <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-comment">// 判断字符串是否为空、null或只包含空白字符</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBlank</span><span class="hljs-params">(String str)</span> {
        <span class="hljs-keyword">return</span> str == <span class="hljs-literal">null</span> || str.trim().length() == <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-comment">// 安全的字符串截取</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">safeSubstring</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {
        <span class="hljs-keyword">if</span> (isEmpty(str)) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
        }
        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>) start = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (end &gt; str.length()) end = str.length();
        <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
        
        <span class="hljs-keyword">return</span> str.substring(start, end);
    }
    
    <span class="hljs-comment">// 重复字符串</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">repeat</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> count)</span> {
        <span class="hljs-keyword">if</span> (isEmpty(str) || count &lt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
        }
        
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) {
            sb.append(str);
        }
        <span class="hljs-keyword">return</span> sb.toString();
    }
    
    <span class="hljs-comment">// 首字母大写</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">capitalize</span><span class="hljs-params">(String str)</span> {
        <span class="hljs-keyword">if</span> (isEmpty(str)) {
            <span class="hljs-keyword">return</span> str;
        }
        <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() + str.substring(<span class="hljs-number">1</span>).toLowerCase();
    }
    
    <span class="hljs-comment">// 驼峰命名转下划线</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">camelToUnderscore</span><span class="hljs-params">(String camelCase)</span> {
        <span class="hljs-keyword">if</span> (isEmpty(camelCase)) {
            <span class="hljs-keyword">return</span> camelCase;
        }
        
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; camelCase.length(); i++) {
            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> camelCase.charAt(i);
            <span class="hljs-keyword">if</span> (Character.isUpperCase(c) &amp;&amp; i &gt; <span class="hljs-number">0</span>) {
                sb.append(<span class="hljs-string">'_'</span>);
            }
            sb.append(Character.toLowerCase(c));
        }
        <span class="hljs-keyword">return</span> sb.toString();
    }
    
    <span class="hljs-comment">// 下划线转驼峰命名</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">underscoreToCamel</span><span class="hljs-params">(String underscore)</span> {
        <span class="hljs-keyword">if</span> (isEmpty(underscore)) {
            <span class="hljs-keyword">return</span> underscore;
        }
        
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-type">boolean</span> <span class="hljs-variable">nextUpper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; underscore.length(); i++) {
            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> underscore.charAt(i);
            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'_'</span>) {
                nextUpper = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (nextUpper) {
                    sb.append(Character.toUpperCase(c));
                    nextUpper = <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> {
                    sb.append(Character.toLowerCase(c));
                }
            }
        }
        <span class="hljs-keyword">return</span> sb.toString();
    }
    
    <span class="hljs-comment">// 测试工具方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        System.out.println(<span class="hljs-string">"isEmpty测试: "</span> + isEmpty(<span class="hljs-string">""</span>));           <span class="hljs-comment">// true</span>
        System.out.println(<span class="hljs-string">"isEmpty测试: "</span> + isEmpty(<span class="hljs-string">" "</span>));          <span class="hljs-comment">// false</span>
        System.out.println(<span class="hljs-string">"isBlank测试: "</span> + isBlank(<span class="hljs-string">" "</span>));          <span class="hljs-comment">// true</span>
        
        System.out.println(<span class="hljs-string">"重复字符串: "</span> + repeat(<span class="hljs-string">"abc"</span>, <span class="hljs-number">3</span>));        <span class="hljs-comment">// "abcabcabc"</span>
        System.out.println(<span class="hljs-string">"首字母大写: "</span> + capitalize(<span class="hljs-string">"hello"</span>));     <span class="hljs-comment">// "Hello"</span>
        
        System.out.println(<span class="hljs-string">"驼峰转下划线: "</span> + camelToUnderscore(<span class="hljs-string">"userName"</span>));     <span class="hljs-comment">// "user_name"</span>
        System.out.println(<span class="hljs-string">"下划线转驼峰: "</span> + underscoreToCamel(<span class="hljs-string">"user_name"</span>));    <span class="hljs-comment">// "userName"</span>
    }
}
</code></pre>
<h3 data-id="heading-33">7. 字符串常量池和intern()方法</h3>
<h4 data-id="heading-34">7.1 字符串常量池概念</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 字符串常量池示例</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringPoolDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 字符串字面量存储在常量池中</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Hello"</span>;
        System.out.println(<span class="hljs-string">"字面量相等: "</span> + (str1 == str2));  <span class="hljs-comment">// true</span>
        
        <span class="hljs-comment">// new String()创建在堆中</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"Hello"</span>);
        System.out.println(<span class="hljs-string">"字面量与new比较: "</span> + (str1 == str3));  <span class="hljs-comment">// false</span>
        System.out.println(<span class="hljs-string">"内容比较: "</span> + str1.equals(str3));        <span class="hljs-comment">// true</span>
        
        <span class="hljs-comment">// intern()方法的使用</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str3.intern();
        System.out.println(<span class="hljs-string">"intern后比较: "</span> + (str1 == str4));      <span class="hljs-comment">// true</span>
        
        <span class="hljs-comment">// 字符串拼接</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">"He"</span> + <span class="hljs-string">"llo"</span>;  <span class="hljs-comment">// 编译时优化为"Hello"</span>
        System.out.println(<span class="hljs-string">"编译时拼接: "</span> + (str1 == str5));         <span class="hljs-comment">// true</span>
        
        <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">"He"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">str6</span> <span class="hljs-operator">=</span> prefix + <span class="hljs-string">"llo"</span>;  <span class="hljs-comment">// 运行时拼接</span>
        System.out.println(<span class="hljs-string">"运行时拼接: "</span> + (str1 == str6));         <span class="hljs-comment">// false</span>
        System.out.println(<span class="hljs-string">"intern运行时拼接: "</span> + (str1 == str6.intern())); <span class="hljs-comment">// true</span>
    }
}
</code></pre>
<h4 data-id="heading-35">7.2 内存分析</h4>
<pre><code class="hljs language-arduino" lang="arduino">堆内存:
├── 字符串常量池
│   └── <span class="hljs-string">"Hello"</span> (str1, str2, str4指向这里)
└── 普通对象区
    └── <span class="hljs-type">String</span>对象 (str3指向这里，内容为<span class="hljs-string">"Hello"</span>)
</code></pre>
<h3 data-id="heading-36">8. 总结</h3>
<h4 data-id="heading-37">8.1 核心要点</h4>
<ol>
<li>
<p><strong>String类</strong>：</p>
<ul>
<li>不可变字符串，线程安全</li>
<li>适合少量字符串操作</li>
<li>提供丰富的字符串处理方法</li>
</ul>
</li>
<li>
<p><strong>StringBuffer类</strong>：</p>
<ul>
<li>可变字符串缓冲区，线程安全</li>
<li>适合多线程环境下的字符串构建</li>
<li>性能中等</li>
</ul>
</li>
<li>
<p><strong>StringBuilder类</strong>：</p>
<ul>
<li>可变字符串缓冲区，线程不安全</li>
<li>适合单线程环境下的大量字符串操作</li>
<li>性能最佳</li>
</ul>
</li>
</ol>
<h4 data-id="heading-38">8.2 使用建议</h4>



































<table><thead><tr><th>使用场景</th><th>推荐类型</th><th>理由</th></tr></thead><tbody><tr><td>字符串常量或很少修改</td><td>String</td><td>不可变性，简单直观</td></tr><tr><td>单线程频繁拼接</td><td>StringBuilder</td><td>性能最佳</td></tr><tr><td>多线程环境拼接</td><td>StringBuffer</td><td>线程安全</td></tr><tr><td>格式化输出</td><td>String.format</td><td>功能强大</td></tr><tr><td>大量字符串处理</td><td>StringBuilder + 工具方法</td><td>效率和可维护性</td></tr></tbody></table>
<h4 data-id="heading-39">8.3 性能优化总结</h4>
<ol>
<li><strong>避免在循环中使用String拼接</strong></li>
<li><strong>预估StringBuilder的初始容量</strong></li>
<li><strong>使用StringBuilder的链式调用</strong></li>
<li><strong>合理使用字符串常量池</strong></li>
<li><strong>选择合适的字符串比较方法</strong></li>
</ol>
<p>字符串处理是Java编程中的基础技能，正确理解和使用这三个类，能够写出更高效、更安全的代码。在实际开发中，根据具体场景选择合适的字符串处理方式，是每个Java开发者必须掌握的技能。</p>
<hr/>
<p><em>本文全面介绍了Java字符串处理的核心类和方法，包括详细的API说明、性能对比、最佳实践和实用工具，希望对Java字符串编程有所帮助。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[LangChain核心组件可用工具]]></title>    <link>https://juejin.cn/post/7591801024009650185</link>    <guid>https://juejin.cn/post/7591801024009650185</guid>    <pubDate>2026-01-06T03:06:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7591801024009650185" data-draft-id="7591800417254768649" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="LangChain核心组件可用工具"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-06T03:06:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哔哔龙"/> <meta itemprop="url" content="https://juejin.cn/user/4371313960946280"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            LangChain核心组件可用工具
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4371313960946280/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哔哔龙
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T03:06:49.000Z" title="Tue Jan 06 2026 03:06:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>LangChain 是一个用于构建基于大语言模型（LLM）应用的框架，其核心思想是“<strong>组合可复用的组件</strong>”来构建复杂链式逻辑。LangChain 的架构模块化清晰，主要包括以下 <strong>六大核心组件</strong>：</p>
<hr/>
<h2 data-id="heading-0">🧩 一、LangChain 六大核心组件概览</h2>








































<table><thead><tr><th>组件</th><th>功能说明</th><th>主要子模块/工具</th></tr></thead><tbody><tr><td>1. <strong>Models（模型）</strong></td><td>调用 LLM 或 Embedding 模型</td><td><code>ChatOpenAI</code>, <code>HuggingFaceLLM</code>, <code>Ollama</code>, <code>AzureChatOpenAI</code> 等</td></tr><tr><td>2. <strong>Prompts（提示）</strong></td><td>构建和管理提示模板</td><td><code>PromptTemplate</code>, <code>ChatPromptTemplate</code>, <code>FewShotPromptTemplate</code></td></tr><tr><td>3. <strong>Chains（链）</strong></td><td>组合多个步骤形成工作流</td><td><code>LLMChain</code>, <code>RetrievalQA</code>, <code>ConversationalRetrievalChain</code>, <code>SequentialChain</code></td></tr><tr><td>4. <strong>Memory（记忆）</strong></td><td>在对话中保持上下文状态</td><td><code>ConversationBufferMemory</code>, <code>ConversationSummaryMemory</code>, <code>RedisChatMessageHistory</code></td></tr><tr><td>5. <strong>Indexes &amp; Retrievers（索引与检索器）</strong></td><td>文档加载、切分、向量化、检索</td><td><code>Document Loaders</code>, <code>Text Splitters</code>, <code>Vectorstores</code>, <code>Retrievers</code></td></tr><tr><td>6. <strong>Agents（代理）</strong></td><td>让 LLM 调用工具自主决策</td><td><code>Zero-shot ReAct Agent</code>, <code>Self-ask Agent</code>, <code>Tool</code>（如搜索、计算器等）</td></tr></tbody></table>
<hr/>
<p>下面对每个组件进行 <strong>详细展开 + 可用工具 + 优缺点对比</strong>。</p>
<hr/>
<h2 data-id="heading-1">1️⃣ Models（模型）</h2>
<h3 data-id="heading-2">✅ 功能</h3>
<ul>
<li>封装 LLM（生成）和 Embedding（向量化）模型的调用接口。</li>
<li>统一 API，支持切换不同后端。</li>
</ul>
<h3 data-id="heading-3">🔧 常用工具（按类型）</h3>
<h4 data-id="heading-4">A. <strong>Chat/Completion Models</strong></h4>



































<table><thead><tr><th>工具</th><th>所属包</th><th>说明</th></tr></thead><tbody><tr><td><code>ChatOpenAI</code></td><td><code>langchain_openai</code></td><td>OpenAI GPT 系列（gpt-4, gpt-3.5-turbo）</td></tr><tr><td><code>ChatAnthropic</code></td><td><code>langchain_anthropic</code></td><td>Claude 系列</td></tr><tr><td><code>ChatOllama</code></td><td><code>langchain_ollama</code></td><td>本地运行开源模型（Llama3, Mistral 等）</td></tr><tr><td><code>HuggingFacePipeline</code></td><td><code>langchain_huggingface</code></td><td>本地 Hugging Face Transformers 模型</td></tr><tr><td><code>AzureChatOpenAI</code></td><td><code>langchain_openai</code></td><td>Azure OpenAI 服务</td></tr></tbody></table>
<h4 data-id="heading-5">B. <strong>Embedding Models</strong></h4>





















<table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><code>OpenAIEmbeddings</code></td><td>OpenAI text-embedding-ada-002</td></tr><tr><td><code>HuggingFaceEmbeddings</code></td><td>开源模型（如 all-MiniLM-L6-v2）</td></tr><tr><td><code>OllamaEmbeddings</code></td><td>通过 Ollama 使用本地嵌入模型</td></tr></tbody></table>
<h3 data-id="heading-6">⚖️ 优缺点对比</h3>

























<table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>OpenAI / Anthropic</strong></td><td>效果好、API 稳定、低延迟</td><td>付费、需网络、数据隐私风险</td></tr><tr><td><strong>Ollama / HuggingFace（本地）</strong></td><td>数据私有、免费、可离线</td><td>需 GPU/CPU 资源、部署复杂、效果略弱</td></tr><tr><td><strong>Azure OpenAI</strong></td><td>企业合规、私有部署选项</td><td>配置复杂、成本高</td></tr></tbody></table>
<blockquote>
<p>💡 <strong>建议</strong>：开发阶段用 OpenAI 快速验证，生产环境考虑 Ollama + 开源模型保安全。</p>
</blockquote>
<hr/>
<h2 data-id="heading-7">2️⃣ Prompts（提示模板）</h2>
<h3 data-id="heading-8">✅ 功能</h3>
<ul>
<li>结构化构建提示，支持变量注入、示例填充、多轮对话格式。</li>
</ul>
<h3 data-id="heading-9">🔧 常用工具</h3>
<ul>
<li><code>PromptTemplate</code>：基础字符串模板</li>
<li><code>ChatPromptTemplate</code>：支持 <code>HumanMessage</code> / <code>AIMessage</code> 格式（推荐用于聊天模型）</li>
<li><code>FewShotPromptTemplate</code>：带少量示例的提示（提升小模型效果）</li>
<li><code>PipelinePromptTemplate</code>：组合多个子模板</li>
</ul>
<h3 data-id="heading-10">⚖️ 优缺点</h3>

























<table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>PromptTemplate</code></td><td>简单直接</td><td>不适合聊天模型</td></tr><tr><td><code>ChatPromptTemplate</code></td><td>符合现代 LLM 对话格式，支持系统消息</td><td>略复杂</td></tr><tr><td><code>FewShot...</code></td><td>提升 zero-shot 性能</td><td>占用 token，成本高</td></tr></tbody></table>
<blockquote>
<p>✅ <strong>最佳实践</strong>：始终使用 <code>ChatPromptTemplate</code> + <code>SystemMessage</code> 定义角色。</p>
</blockquote>
<hr/>
<h2 data-id="heading-11">3️⃣ Chains（链）</h2>
<h3 data-id="heading-12">✅ 功能</h3>
<ul>
<li>将多个操作（如 prompt → LLM → parse → call tool）串联成 pipeline。</li>
</ul>
<h3 data-id="heading-13">🔧 常用 Chain</h3>





























<table><thead><tr><th>Chain</th><th>用途</th></tr></thead><tbody><tr><td><code>LLMChain</code></td><td>最基础：prompt + LLM</td></tr><tr><td><code>RetrievalQA</code></td><td>RAG：检索 + 问答</td></tr><tr><td><code>ConversationalRetrievalChain</code></td><td>带历史的 RAG</td></tr><tr><td><code>SequentialChain</code> / <code>SimpleSequentialChain</code></td><td>多步骤顺序执行</td></tr><tr><td><code>TransformChain</code></td><td>自定义函数处理输入/输出</td></tr></tbody></table>
<h3 data-id="heading-14">⚖️ 优缺点</h3>

























<table><thead><tr><th>Chain</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>RetrievalQA</code></td><td>开箱即用 RAG</td><td>无法精细控制检索-生成交互</td></tr><tr><td><code>ConversationalRetrievalChain</code></td><td>支持对话历史</td><td>内存消耗大</td></tr><tr><td>自定义 Chain</td><td>灵活</td><td>需手动编写逻辑</td></tr></tbody></table>
<blockquote>
<p>💡 LangChain Expression Language（LCEL）正在取代传统 Chain，更灵活（见 v0.1+）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-15">4️⃣ Memory（记忆）</h2>
<h3 data-id="heading-16">✅ 功能</h3>
<ul>
<li>在多轮对话中保存上下文，避免 LLM “失忆”。</li>
</ul>
<h3 data-id="heading-17">🔧 常用 Memory 类型</h3>

























<table><thead><tr><th>Memory</th><th>特点</th></tr></thead><tbody><tr><td><code>ConversationBufferMemory</code></td><td>保存全部历史（简单但占 token）</td></tr><tr><td><code>ConversationSummaryMemory</code></td><td>用 LLM 压缩历史为摘要</td></tr><tr><td><code>ConversationBufferWindowMemory</code></td><td>只保留最近 N 轮</td></tr><tr><td><code>RedisChatMessageHistory</code></td><td>外部存储（支持多用户会话持久化）</td></tr></tbody></table>
<h3 data-id="heading-18">⚖️ 优缺点</h3>






























<table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Buffer</td><td>精确还原上下文</td><td>token 成本高，长对话失效</td></tr><tr><td>Summary</td><td>节省 token</td><td>摘要可能丢失细节</td></tr><tr><td>Window</td><td>平衡</td><td>可能切断关键上下文</td></tr><tr><td>Redis/DB</td><td>可扩展、多用户</td><td>需额外基础设施</td></tr></tbody></table>
<blockquote>
<p>✅ <strong>生产建议</strong>：用 <code>Window</code> + 外部存储（如 Redis）组合。</p>
</blockquote>
<hr/>
<h2 data-id="heading-19">5️⃣ Indexes &amp; Retrievers（索引与检索）</h2>
<h3 data-id="heading-20">✅ 功能</h3>
<ul>
<li>从非结构化数据（PDF、MD、网页等）构建可检索的知识库。</li>
</ul>
<h3 data-id="heading-21">🔧 子组件与工具</h3>
<h4 data-id="heading-22">A. <strong>Document Loaders</strong></h4>
<ul>
<li><code>TextLoader</code>, <code>UnstructuredMarkdownLoader</code>, <code>PyPDFLoader</code>, <code>WebBaseLoader</code>, <code>DirectoryLoader</code></li>
</ul>
<h4 data-id="heading-23">B. <strong>Text Splitters</strong></h4>
<ul>
<li><code>RecursiveCharacterTextSplitter</code>（最常用）</li>
<li><code>MarkdownHeaderTextSplitter</code>（保留标题结构）</li>
<li><code>TokenTextSplitter</code>（按 token 切分）</li>
</ul>
<h4 data-id="heading-24">C. <strong>Vectorstores（向量数据库）</strong></h4>
<ul>
<li><code>FAISS</code>, <code>Chroma</code>, <code>Qdrant</code>, <code>Pinecone</code>, <code>Weaviate</code>（见前文对比）</li>
</ul>
<h4 data-id="heading-25">D. <strong>Retrievers</strong></h4>
<ul>
<li><code>vectorstore.as_retriever()</code></li>
<li><code>MultiQueryRetriever</code>（生成多个查询提升召回）</li>
<li><code>ContextualCompressionRetriever</code>（压缩冗余内容）</li>
</ul>
<h3 data-id="heading-26">⚖️ 优缺点（整体流程）</h3>






























<table><thead><tr><th>环节</th><th>挑战</th><th>优化建议</th></tr></thead><tbody><tr><td>加载</td><td>格式兼容性差</td><td>优先用 <code>unstructured</code></td></tr><tr><td>切分</td><td>语义断裂</td><td>用 <code>MarkdownHeaderTextSplitter</code> + overlap</td></tr><tr><td>向量库</td><td>过滤能力弱（如 FAISS）</td><td>选 Qdrant/Pinecone 支持 metadata filter</td></tr><tr><td>检索</td><td>召回率低</td><td>用 <code>MultiQueryRetriever</code> + 重排序（CohereRerank）</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-27">6️⃣ Agents（代理）</h2>
<h3 data-id="heading-28">✅ 功能</h3>
<ul>
<li>让 LLM <strong>自主决定是否调用工具</strong>（如搜索、计算、查数据库），实现动态推理。</li>
</ul>
<h3 data-id="heading-29">🔧 核心组成</h3>
<ul>
<li>
<p><strong>Agent Type</strong>：</p>
<ul>
<li><code>zero-shot-react-description</code>（最常用）</li>
<li><code>self-ask-with-search</code></li>
<li><code>conversational-react-description</code></li>
</ul>
</li>
<li>
<p><strong>Tools</strong>：</p>
<ul>
<li><code>DuckDuckGoSearchRun</code>（网络搜索）</li>
<li><code>WikipediaQueryRun</code></li>
<li><code>PythonREPLTool</code>（慎用！）</li>
<li>自定义 Tool（继承 <code>BaseTool</code>）</li>
</ul>
</li>
</ul>
<h3 data-id="heading-30">⚖️ 优缺点</h3>

























<table><thead><tr><th>方面</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>能力</td><td>可解决复杂、开放问题</td><td>执行慢（多轮 LLM 调用）</td></tr><tr><td>可控性</td><td>可限制可用工具</td><td>LLM 可能误用或死循环</td></tr><tr><td>安全性</td><td>——</td><td>若允许代码执行，有安全风险</td></tr></tbody></table>
<blockquote>
<p>⚠️ <strong>生产建议</strong>：严格限制工具权限，避免 <code>PythonREPLTool</code>；用 <code>max_iterations</code> 防止死循环。</p>
</blockquote>
<hr/>
<h2 data-id="heading-31">📌 总结：LangChain 组件选型建议</h2>

























<table><thead><tr><th>场景</th><th>推荐配置</th></tr></thead><tbody><tr><td><strong>快速 RAG Demo</strong></td><td>Chroma + OpenAI + RetrievalQA + BufferMemory</td></tr><tr><td><strong>企业私有知识库</strong></td><td>Qdrant + Ollama（Llama3）+ MarkdownHeaderTextSplitter + RedisMemory</td></tr><tr><td><strong>多轮智能客服</strong></td><td>ConversationalRetrievalChain + WindowMemory + Pinecone</td></tr><tr><td><strong>复杂任务自动化</strong></td><td>Agent（ReAct） + DuckDuckGo + 自定义安全工具</td></tr></tbody></table>
<hr/>
<p>LangChain 的优势在于 <strong>高度模块化</strong>，但也带来“选择困难”。建议：</p>
<ol>
<li>先用默认组合（如 Chroma + OpenAI）跑通流程；</li>
<li>再根据性能、成本、隐私需求逐步替换组件。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[浅谈 import.meta.env 和 process.env 的区别]]></title>    <link>https://juejin.cn/post/7592062873829916722</link>    <guid>https://juejin.cn/post/7592062873829916722</guid>    <pubDate>2026-01-06T14:40:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592062873829916722" data-draft-id="7592251792629547035" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="浅谈 import.meta.env 和 process.env 的区别"/> <meta itemprop="keywords" content="前端,Vue.js,Node.js"/> <meta itemprop="datePublished" content="2026-01-06T14:40:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="在西安牧羊的牛油果"/> <meta itemprop="url" content="https://juejin.cn/user/2946346894233133"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            浅谈 import.meta.env 和 process.env 的区别
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2946346894233133/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    在西安牧羊的牛油果
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-06T14:40:30.000Z" title="Tue Jan 06 2026 14:40:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是一个<strong>前端构建环境里非常核心、也非常容易混淆的问题</strong>。下面我们从<strong>来源、使用场景、编译时机、安全性</strong>四个维度来谈谈 <code>import.meta.env</code> 和 <code>process.env</code> 的区别。</p>
<hr/>
<h2 data-id="heading-0">一句话结论</h2>
<blockquote>
<p><strong><code>process.env</code></strong> <strong>是 Node.js 的环境变量接口</strong> <strong><code>import.meta.env</code></strong> <strong>是 Vite（ESM）在构建期注入的前端环境变量</strong></p>
</blockquote>
<hr/>
<h2 data-id="heading-1">一、<code>process.env</code> 是什么？</h2>
<h3 data-id="heading-2">1️⃣ 本质</h3>
<ul>
<li>来自 <strong>Node.js</strong></li>
<li>运行时读取 <strong>服务器 / 构建机的系统环境变量</strong></li>
<li>本身 <strong>浏览器里不存在</strong></li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span>);
</code></pre>
<h3 data-id="heading-3">2️⃣ 使用场景</h3>
<ul>
<li>Node 服务</li>
<li>构建工具（Webpack / Vite / Rollup）</li>
<li>SSR（Node 端）</li>
</ul>
<h3 data-id="heading-4">3️⃣ 前端能不能用？</h3>
<p>👉 <strong>不能直接用</strong></p>
<p>浏览器里没有 <code>process</code>：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 浏览器原生环境 ❌</span>
<span class="hljs-title class_">Uncaught</span> <span class="hljs-title class_">ReferenceError</span>: process is not defined
</code></pre>
<h3 data-id="heading-5">4️⃣ 为什么 Webpack 项目里能用？</h3>
<p>因为 <strong>Webpack 帮你“编译期替换”了</strong></p>
<pre><code class="hljs language-ts" lang="ts">process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span>
<span class="hljs-comment">// ⬇️ 构建时被替换成</span>
<span class="hljs-string">"production"</span>
</code></pre>
<p>本质是 <strong>字符串替换</strong>，不是运行时读取。</p>
<hr/>
<h2 data-id="heading-6">二、<code>import.meta.env</code> 是什么？</h2>
<h3 data-id="heading-7">1️⃣ 本质</h3>
<ul>
<li><strong>Vite 提供</strong></li>
<li>基于 <strong>ES Module 的</strong> <strong><code>import.meta</code></strong></li>
<li><strong>构建期 + 运行期可用（但值是构建期确定的）</strong></li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">MODE</span>);
</code></pre>
<h3 data-id="heading-8">2️⃣ 特点</h3>
<ul>
<li>浏览器里 <strong>原生支持</strong></li>
<li>不依赖 Node 的 <code>process</code></li>
<li>更符合现代 ESM 规范</li>
</ul>
<hr/>
<h2 data-id="heading-9">三、两者核心区别对比（重点）</h2>








































<table><thead><tr><th><strong>维度</strong></th><th><strong>process.env</strong></th><th><strong>import.meta.env</strong></th></tr></thead><tbody><tr><td>来源</td><td>Node.js</td><td>Vite</td></tr><tr><td>标准</td><td>Node API</td><td>ESM 标准扩展</td></tr><tr><td>浏览器可用</td><td>❌（需编译替换）</td><td>✅</td></tr><tr><td>注入时机</td><td>构建期</td><td>构建期</td></tr><tr><td>是否运行时读取</td><td>❌</td><td>❌</td></tr><tr><td>推荐前端使用</td><td>❌</td><td>✅</td></tr></tbody></table>
<p>⚠️ <strong>两者都不是“前端运行时读取服务器环境变量”</strong></p>
<hr/>
<h2 data-id="heading-10">四、Vite 中为什么不用 <code>process.env</code>？</h2>
<h3 data-id="heading-11">1️⃣ 因为 Vite 不再默认注入 <code>process</code></h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// Vite 项目中 ❌</span>
process.<span class="hljs-property">env</span>.<span class="hljs-property">API_URL</span>
</code></pre>
<p>会直接报错。</p>
<h3 data-id="heading-12">2️⃣ 官方设计选择</h3>
<ul>
<li>避免 Node 全局污染</li>
<li>更贴近浏览器真实环境</li>
<li>更利于 Tree Shaking</li>
</ul>
<hr/>
<h2 data-id="heading-13">五、Vite 环境变量的正确用法（非常重要）</h2>
<h3 data-id="heading-14">1️⃣ 必须以 <code>VITE_</code> 开头</h3>
<pre><code class="hljs language-ts" lang="ts"># .<span class="hljs-property">env</span>
<span class="hljs-variable constant_">VITE_API_URL</span>=<span class="hljs-attr">https</span>:<span class="hljs-comment">//api.example.com</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_URL</span>);
</code></pre>
<p>❌ 否则 <strong>不会注入到前端</strong></p>
<hr/>
<h3 data-id="heading-15">2️⃣ 内置变量</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">MODE</span>        <span class="hljs-comment">// development / production</span>
<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">DEV</span>         <span class="hljs-comment">// true / false</span>
<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">PROD</span>        <span class="hljs-comment">// true / false</span>
<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span>
</code></pre>
<hr/>
<h2 data-id="heading-16">六、安全性</h2>
<h3 data-id="heading-17">⚠️ 重要警告</h3>
<blockquote>
<p><strong><code>import.meta.env</code></strong> <strong>里的变量 ≠ 私密</strong></p>
</blockquote>
<p>它们会：</p>
<ul>
<li>被 <strong>打进 JS Bundle</strong></li>
<li>可在 DevTools 直接看到</li>
</ul>
<h3 data-id="heading-18">❌ 不要这样做</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-variable constant_">VITE_SECRET_KEY</span>=xxxx
</code></pre>
<h3 data-id="heading-19">✅ 正确做法</h3>
<ul>
<li><strong>前端</strong>：只放“公开配置”（API 域名、开关）</li>
<li><strong>私密变量</strong>：只放在 <strong>Node / 服务端</strong></li>
</ul>
<hr/>
<h2 data-id="heading-20">七、SSR / 全栈项目里怎么区分？</h2>
<h3 data-id="heading-21">在 Vite + SSR（如 Nuxt / 自建 SSR）：</h3>
<p>Node 端</p>
<pre><code class="hljs language-ts" lang="ts">process.<span class="hljs-property">env</span>.<span class="hljs-property">DB_PASSWORD</span>
</code></pre>
<p>浏览器端</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_URL</span>
</code></pre>
<p><strong>两套环境变量是刻意分开的</strong>。</p>
<ol>
<li>
<h3 data-id="heading-22">为什么必须分成两套？（设计原因）</h3>
</li>
</ol>
<h4 data-id="heading-23">1️⃣ 执行环境不同（这是根因）</h4>




















<table><thead><tr><th><strong>位置</strong></th><th><strong>运行在哪</strong></th><th><strong>能访问什么</strong></th></tr></thead><tbody><tr><td>SSR Server</td><td>Node.js</td><td>process.env</td></tr><tr><td>Client Bundle</td><td>浏览器</td><td>import.meta.env</td></tr></tbody></table>
<p>浏览器里 <strong>永远不可能安全地访问服务器环境变量</strong>。</p>
<hr/>
<h4 data-id="heading-24">2️⃣ SSR ≠ 浏览器</h4>
<p>很多人误解：</p>
<blockquote>
<p>“SSR 是不是浏览器代码先在 Node 跑一遍？”</p>
</blockquote>
<p>❌ <strong>不完全对</strong></p>
<p>SSR 实际是：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-title class_">Node</span>.<span class="hljs-property">js</span> 先跑一份 → 生成 <span class="hljs-variable constant_">HTML</span>
浏览器再跑一份 → hydrate
</code></pre>
<p>这两次执行：</p>
<ul>
<li><strong>环境不同</strong></li>
<li><strong>变量来源不同</strong></li>
<li><strong>安全级别不同</strong></li>
</ul>
<hr/>
<ol start="2">
<li>
<h3 data-id="heading-25">在 Vite + SSR 中，变量的“真实流向”</h3>
</li>
</ol>
<h4 data-id="heading-26">1️⃣ Node 端（SSR Server）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// server.ts / entry-server.ts</span>
<span class="hljs-keyword">const</span> dbPassword = process.<span class="hljs-property">env</span>.<span class="hljs-property">DB_PASSWORD</span>;
</code></pre>
<p>✔️ 真实运行时读取</p>
<p>✔️ 不会进 bundle</p>
<p>✔️ 只存在于服务器内存</p>
<hr/>
<h4 data-id="heading-27">2️⃣ Client 端（浏览器）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// entry-client.ts / React/Vue 组件</span>
<span class="hljs-keyword">const</span> apiUrl = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_URL</span>;
</code></pre>
<p>✔️ 构建期注入</p>
<p>✔️ 会打进 JS</p>
<p>✔️ 用户可见</p>
<hr/>
<h4 data-id="heading-28">3️⃣ 中间那条“禁止通道”</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// ❌ 绝对禁止</span>
process.<span class="hljs-property">env</span>.<span class="hljs-property">DB_PASSWORD</span> → 浏览器
</code></pre>
<p><strong>SSR 不会、也不允许，自动帮你“透传”环境变量</strong></p>
<hr/>
<ol start="3">
<li>
<h3 data-id="heading-29">SSR 中最容易踩的 3 个坑（重点）</h3>
</li>
</ol>
<hr/>
<h4 data-id="heading-30">❌ 坑 1：在“共享代码”里直接用 <code>process.env</code></h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// utils/config.ts（被 server + client 共用）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">API_URL</span>; <span class="hljs-comment">// ❌</span>
</code></pre>
<p><strong>问题：</strong></p>
<ul>
<li>Server OK</li>
<li>Client 直接炸（或被错误替换）</li>
</ul>
<p>✅ 正确方式：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API</span> = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_URL</span>;
</code></pre>
<p>或者：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API</span> =<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">'undefined'</span>
    ? process.<span class="hljs-property">env</span>.<span class="hljs-property">INTERNAL_API</span>
    : <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_URL</span>;
</code></pre>
<hr/>
<h4 data-id="heading-31">❌ 坑 2：误以为 SSR 可以“顺手用数据库变量”</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// Vue/React 组件里</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">DB_PASSWORD</span>); <span class="hljs-comment">// ❌</span>
</code></pre>
<p>哪怕你在 SSR 模式下，这段代码：</p>
<ul>
<li><strong>最终仍会跑在浏览器</strong></li>
<li><strong>会被打包</strong></li>
<li><strong>是严重安全漏洞</strong></li>
</ul>
<hr/>
<h4 data-id="heading-32">❌ 坑 3：把“环境变量”当成“运行时配置”</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// ❌ 想通过部署切换 API</span>
<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_API_URL</span>
</code></pre>
<p>🚨 这是 <strong>构建期值</strong>：</p>
<pre><code class="hljs language-ts" lang="ts">build 时确定
→ <span class="hljs-variable constant_">CDN</span> 缓存
→ 所有用户共享
</code></pre>
<p><strong>想运行期切换？只能：</strong></p>
<ul>
<li>接口返回配置</li>
<li>HTML 注入 window.<strong>CONFIG</strong></li>
<li>拉 JSON 配置文件</li>
</ul>
<hr/>
<ol start="4">
<li>
<h3 data-id="heading-33">SSR 项目里“正确的分层模型”（工程视角）</h3>
</li>
</ol>
<pre><code class="hljs language-ts" lang="ts">┌──────────────────────────┐
│        浏览器 <span class="hljs-title class_">Client</span>       │
│  <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_</span>*   │ ← 公开配置
└───────────▲──────────────┘
            │
        <span class="hljs-variable constant_">HTTP</span> / <span class="hljs-variable constant_">HTML</span>
            │
┌───────────┴──────────────┐
│        <span class="hljs-title class_">Node</span> <span class="hljs-variable constant_">SSR</span> <span class="hljs-title class_">Server</span>     │
│      process.<span class="hljs-property">env</span>.*        │ ← 私密配置
└───────────▲──────────────┘
            │
        内部访问
            │
┌───────────┴──────────────┐
│        <span class="hljs-variable constant_">DB</span> / <span class="hljs-title class_">Redis</span> / <span class="hljs-variable constant_">OSS</span>    │
└──────────────────────────┘
</code></pre>
<p>这是一条 <strong>单向、安全的数据流</strong>。</p>
<hr/>
<ol start="5">
<li>
<h3 data-id="heading-34">Nuxt / 自建 SSR 的对应关系</h3>
</li>
</ol>





















<table><thead><tr><th><strong>类型</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>runtimeConfig</td><td>Server-only</td></tr><tr><td>runtimeConfig.public</td><td>Client 可见</td></tr><tr><td>process.env</td><td>仅 server</td></tr></tbody></table>
<p>👉 Nuxt 本质也是在<strong>帮你维护这条边界</strong></p>
<hr/>
<h2 data-id="heading-35">八、常见误区总结</h2>
<h3 data-id="heading-36">❌ 误区 1</h3>
<blockquote>
<p><code>import.meta.env</code> 是运行时读取</p>
</blockquote>
<p>❌ <strong>错</strong>，仍是构建期注入</p>
<hr/>
<h3 data-id="heading-37">❌ 误区 2</h3>
<blockquote>
<p>可以用它动态切换环境</p>
</blockquote>
<p>❌ <strong>不行</strong>，想动态只能：</p>
<ul>
<li>接口返回配置</li>
<li>或运行时请求 JSON</li>
</ul>
<hr/>
<h3 data-id="heading-38">❌ 误区 3</h3>
<blockquote>
<p>Vite 里还能继续用 <code>process.env</code></p>
</blockquote>
<p>❌ 除非你手动 polyfill（不推荐）</p>
<hr/>
<h2 data-id="heading-39">九、总结</h2>
<ul>
<li>前端（Vite）只认 <code>import.meta.env.VITE_*</code></li>
<li>服务端（Node）只认 <code>process.env</code></li>
<li>永远不要把秘密放进前端 env</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[别再被 TS 类型冲突折磨了！一文搞懂类型合并规则]]></title>    <link>https://juejin.cn/post/7592444642277670922</link>    <guid>https://juejin.cn/post/7592444642277670922</guid>    <pubDate>2026-01-07T10:40:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592444642277670922" data-draft-id="7592423411563249690" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="别再被 TS 类型冲突折磨了！一文搞懂类型合并规则"/> <meta itemprop="keywords" content="前端,TypeScript"/> <meta itemprop="datePublished" content="2026-01-07T10:40:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="hboot"/> <meta itemprop="url" content="https://juejin.cn/user/2084329777543191"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            别再被 TS 类型冲突折磨了！一文搞懂类型合并规则
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2084329777543191/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    hboot
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:40:00.000Z" title="Wed Jan 07 2026 10:40:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>之前学习了<code>TypeScript</code>的类型定义，我们都知道开发语言中的变量会有覆盖声明的情况，那么对于类型定义是不是也会有这种情况，那么该如何正确利用这种合并规则？在遇到多个类型定义的时候，我们又该如何处理？</p>
<p>了解类型合并规则，有助于我们定义类型，避免类型冲突。可以利用这种合并规则，更灵活的定义类型。</p>
<p>不同版本<code>TypeScript</code>,不同配置可能会导致合并差异，这里说明使用的版本为<code>"typescript": "^5.9.3"</code>,开启了配置<code>"strict": true</code>,测试文件后缀为<code>.ts</code>。<code>.d.ts</code>文件可能更为宽松。</p>
<h2 data-id="heading-0">同名同类型合并</h2>
<p><code>TypeScript</code>仅支持接口<code>interface</code>、命名空间<code>namespace</code>、函数声明<code>function</code>同名合并。在声明解析阶段即完成合并。早于其他类型引用处理，比如交叉/联合类型。</p>
<p>对于<code>type</code>、 <code>class</code> 、<code>enum</code>等定义的同名类型都不能合并。</p>
<h3 data-id="heading-1"><code>interface</code> 接口声明合并</h3>
<p>同一作用域下的同名接口会自动完成合并，无需额外语法。</p>
<p>合并特性：</p>
<ul>
<li>属性、方法、索引签名均可合并。</li>
<li>同名属性、方法必须类型兼容，否则编译器报错。</li>
<li>同一作用域/模块下。</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// 实例必须包含name和age属性</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">""</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">0</span>,
};
</code></pre>
<p><strong>同属性，不同类型不兼容，编译器报错。</strong></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}
<span class="hljs-comment">// ❌ 后续属性声明必须属于同一类型。属性“name”的类型必须为“string”，但此处却为类型“number”。</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">number</span>;
}
</code></pre>
<p><strong>同属性同类型，不同修饰符不兼容，编译器报错。</strong></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}
<span class="hljs-comment">// ❌ 不同修饰符不兼容，编译器报错</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  name?: <span class="hljs-built_in">string</span>;
}
</code></pre>
<h3 data-id="heading-2"><code>namespace</code> 命名空间合并</h3>
<p>同名的命名空间会自动合并内部导出的成员。仅<code>export</code>导出的成员会合并。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Utils</span> {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"hboot"</span>;
  }
}

<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Utils</span> {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>;
  }
}

<span class="hljs-title class_">Utils</span>.<span class="hljs-title function_">getName</span>();
<span class="hljs-title class_">Utils</span>.<span class="hljs-title function_">getAge</span>();
</code></pre>
<p><strong>不允许同名成员导出。</strong></p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Utils</span> {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"hboot"</span>;
  }
}

<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Utils</span> {
  <span class="hljs-comment">// ❌ 成员已存在，不允许重复定义</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getName</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>;
  };
}
</code></pre>
<h3 data-id="heading-3"><code>function</code> 函数声明合并</h3>
<p>函数同名合并，<strong>我们称之为函数重载</strong>。TS编译器会按照倒序匹配，也就是后声明函数重载优先级高。</p>
<p>函数重载最后一个函数声明必须实现内部逻辑，并且参数数量、参数类型和返回值类型必须兼容。</p>
<blockquote>
<p>仅使用<code>function</code>声明的函数支持</p>
</blockquote>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">age: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">nameOrAge: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> nameOrAge;
}
<span class="hljs-title function_">getName</span>(<span class="hljs-string">"hboot"</span>);
<span class="hljs-title function_">getName</span>(<span class="hljs-number">18</span>);
</code></pre>
<p><strong><code>interface</code>接口中定义的方法也会形成重载</strong>。但是和普通的函数重载最后的函数实现参数、返回值类型定义有些不同。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">getVal</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">getVal</span>(<span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// ❌ 这样写编译器会直接报错，提示不能将类型 "string | number" 无法分配给类型 "string"。</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-title function_">getVal</span>(<span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> value;
  },
};
</code></pre>
<p>普通函数重载是满足其一即可；而接口中方法重载是必须<strong>精准匹配类型每一个类型</strong>。利用TS类型推导通过泛型参数锁定类型。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 利用了类型的自动推导，通过泛型参数 T 锁定输入类型及返回类型</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Animal</span> = {
  getVal&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;(<span class="hljs-attr">value</span>: T): T {
    <span class="hljs-keyword">return</span> value;
  }
};
</code></pre>
<h2 data-id="heading-4">同名不同类型合并</h2>
<p>同名不同类型的合并，主要是命名空间<code>namespace + interface/class/function</code>的合并，<code>namespace</code>可以提供静态属性、方法。</p>
<h3 data-id="heading-5"><code>namespace</code>+<code>interface</code> 合并</h3>
<p>同名的<code>namespace</code>命名空间为<code>interface</code>接口扩展静态成员；接口提供类型约束。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"hboot"</span>;
  }
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"hboot"</span>,
};

<span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">getName</span>();
</code></pre>
<p>同名的属性、方法不会冲突，因为<code>Animal</code>命名空间直接通过空间名访问；<code>interface</code>接口需要实例化后的实例访问。它们之间实际上只有名称是相同的，属性之间没有合并。</p>
<h3 data-id="heading-6"><code>namespace</code>+<code>class</code> 合并</h3>
<p>同名的<code>namespace</code>命名空间为<code>class</code>类扩展静态成员；<strong>类声明必须在命名空间的声明必之前</strong>，命名空间不能声明类已有的成员。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}
<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = <span class="hljs-string">"hboot"</span>;
  <span class="hljs-comment">// ❌ 此处扩展静态成员 age 报错，类中已存在 age 静态成员</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"hboot"</span>;
  }
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">"admin"</span>);
<span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">getName</span>();
<span class="hljs-comment">// hboot</span>
<span class="hljs-title class_">Animal</span>.<span class="hljs-property">name</span>;
<span class="hljs-comment">// admin</span>
dog.<span class="hljs-property">name</span>;
</code></pre>
<h3 data-id="heading-7"><code>namespace</code>+<code>function</code> 合并</h3>
<p>同名的<code>namespace</code>命名空间为<code>function</code>函数扩展静态成员。函数保持自身的可调用能力。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World! "</span> + name;
}

<span class="hljs-keyword">namespace</span> speak {
  <span class="hljs-comment">// ❌ 此处无法覆盖 函数的 name 属性；name 是只读属性</span>
  <span class="hljs-comment">// ❌ 类型校验没有报错，但运行时因为只读而报错</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = <span class="hljs-string">"hboot"</span>;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"hboot"</span>;
  }
}

<span class="hljs-title function_">speak</span>(<span class="hljs-string">"hboot"</span>);
speak.<span class="hljs-property">name</span>;
speak.<span class="hljs-title function_">getName</span>();
</code></pre>
<p>扩展的静态成员最好不要覆盖函数本身的属性，比如<code>name</code>、<code>length</code>等。这些只读属性无法被覆盖，在运行时会报错。</p>
<h3 data-id="heading-8"><code>interface</code>+<code>class</code> 合并</h3>
<p>同名的<code>interface</code>接口为<code>class</code>类扩展实例成员。类继承接口的属性、方法，实例必须同时满足接口和类的约束。</p>
<p>合并特性：</p>
<ul>
<li>接口的必选属性，在类中必须显式实现，否则执行报错。</li>
<li>同名属性，必须类型兼容，否则执行报错。</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">getName</span>(): <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">age: <span class="hljs-built_in">number</span>, name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
  <span class="hljs-comment">// 必须显示实现 接口 的方法成员</span>
  <span class="hljs-title function_">getName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
  }
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-number">18</span>, <span class="hljs-string">"hboot"</span>);

dog.<span class="hljs-property">age</span>;
<span class="hljs-comment">// 类中需通过构造函数</span>
dog.<span class="hljs-property">name</span>;
<span class="hljs-comment">// ❌ 如果类没有显示实现；智能提示存在方法，实际调用会报错。</span>
dog.<span class="hljs-title function_">getName</span>();
</code></pre>
<p>除了手动赋值扩展属性外，可以通过<code>public</code>修饰符自动生成</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
 
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">age: <span class="hljs-built_in">number</span>, <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
    <span class="hljs-comment">// 无需手动赋值</span>
    <span class="hljs-comment">// this.name = name;</span>
  }

  <span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-number">18</span>, <span class="hljs-string">"hboot"</span>);
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h2 data-id="heading-9">显示类型合并</h2>
<p>上述的同名同类型、同名不同类型合并实际最终也是属性的合并。对于非同名属性合并则是扩展；同名属性则有一些合并规则。</p>
<p>对于不同类型之间的同名属性合并都有自己的规则，比如：<code>interface</code>+<code>class</code> 合并要求属性类型兼容；<code>namespace</code>+<code>class</code> 合并要求命名空间不能包含类已有的成员。</p>
<p>通过手动将一些类型合并到一个类型中，例如交叉类型<code>&amp;</code>和联合类型<code>|</code></p>
<h3 data-id="heading-10">交叉类型<code>&amp;</code> 关系合并</h3>
<p>交叉类型将多个类型合并为一个新类型。新类型必须满足所有类型约束。</p>
<p>合并特性：</p>
<ul>
<li>不同名属性合并为属性并集。保留属性修饰符。</li>
<li>同名属性取兼容类型，对于修饰符<code>?</code>，存在必选时则属性必选；修饰符<code>readonly</code>，存在属性可修改时则属性可修改。</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 不兼容类型 never</span>
<span class="hljs-keyword">type</span> A = <span class="hljs-built_in">string</span> &amp; <span class="hljs-built_in">number</span>;

<span class="hljs-comment">// 不同名属性并集</span>
<span class="hljs-keyword">type</span> B = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> } &amp; { <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> };

<span class="hljs-comment">// 可选 ? 修饰符, 兼容类型 name 为必选属性</span>
<span class="hljs-keyword">type</span> C = { name?: <span class="hljs-built_in">string</span> } &amp; { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> };

<span class="hljs-comment">// 只读 readonly 修饰符, 兼容类型 age 为可修改</span>
<span class="hljs-keyword">type</span> D = { <span class="hljs-keyword">readonly</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> } &amp; { <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> };
</code></pre>
<h3 data-id="heading-11">联合类型<code>|</code> 关系合并</h3>
<p>将多个类型组合为一个新类型。新类型只需要满足其中一个类型约束。</p>
<p>合并特性：</p>
<ul>
<li>仅能访问公共属性。需通过类型守卫收窄类型后才能访问非公共属性。</li>
<li>完全一致的类型自动去重。</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">type</span> A = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">type</span> B = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">address</span>: <span class="hljs-built_in">string</span>;
};

<span class="hljs-keyword">type</span> C = A | B;

<span class="hljs-comment">// 满足其中一个类型约束</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">c</span>: C = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"hboot"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
};

<span class="hljs-comment">// 访问非公共属性</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">viewC</span>(<span class="hljs-params">data: C</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-string">"age"</span> <span class="hljs-keyword">in</span> data) {
    <span class="hljs-keyword">return</span> data.<span class="hljs-property">age</span>;
  }
  <span class="hljs-keyword">return</span> data.<span class="hljs-property">address</span>;
}
</code></pre>
<h2 data-id="heading-12"><code>.d.ts</code>中的声明合并</h2>
<p><code>.d.ts</code>文件和<code>.ts</code>文件的合并核心规则一致。在执行时机、作用域、编译行为上有些不一样。</p>
<ul>
<li>
<p><code>.d.ts</code> 文件中仅有类型声明，无实际代码实现，仅用于TS类型检验。所以不同于<code>.ts</code>文件。它会在类型校验阶段早期执行，优先合并全局/模块类型；而<code>.ts</code>文件是在编译阶段执行。</p>
</li>
<li>
<p><code>.d.ts</code>类型优先级低，能被<code>.ts</code>文件显示类型声明覆盖。</p>
</li>
<li>
<p><code>.d.ts</code>跨文件同名声明合并（无<code>import/export</code>）。<code>.ts</code>仅在同一个文件中同名声明合并。</p>
</li>
</ul>
<h2 data-id="heading-13"><code>declare</code></h2>
<p><code>declare</code> 主要作用存在性声明，告诉TypeScript编译器无需生成对应的代码。</p>
<ul>
<li>全局变量/函数声明，比如：外部加载的<code>js</code>文件，挂载到<code>window</code>上的变量。</li>
<li>扩展已有类型（与同名接口/命名空间合并）</li>
<li>声明模块（非TS模块，比如<code>.css</code>或<code>.png</code>等静态资源）</li>
</ul>
<p><code>declare</code> 扩展已有类型合并规则与<code>.ts</code>文件的合并核心规则一致.</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">getName</span>(): <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}
</code></pre>
<p><code>.ts</code> 模块中没有<code>import/export</code>时，通过<code>declare</code>声明为全局作用域。如果存在<code>import/export</code>则需要通过<code>declare global</code>扩展全局作用域。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[面向 Interleaved Thinking 的大模型 Agent 蒸馏实践]]></title>    <link>https://juejin.cn/post/7592432859862548514</link>    <guid>https://juejin.cn/post/7592432859862548514</guid>    <pubDate>2026-01-07T10:08:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592432859862548514" data-draft-id="7592170706027151395" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="面向 Interleaved Thinking 的大模型 Agent 蒸馏实践"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-01-07T10:08:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云大数据AI技术"/> <meta itemprop="url" content="https://juejin.cn/user/2414974667341287"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            面向 Interleaved Thinking 的大模型 Agent 蒸馏实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2414974667341287/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云大数据AI技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:08:57.000Z" title="Wed Jan 07 2026 10:08:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>大语言模型Agent在复杂任务中展现出卓越能力。相比传统线性推理链(Chain-of-Thought)，"交错思维"(Interleaved Thinking)通过"思考→行动→观察→再思考"的闭环机制，有效解决了状态漂移和上下文遗忘问题，显著提升多轮交互的连贯性与策略调整能力。</p>
<p>阿里云 PAI 团队结合交错思维的推理机制，构建了涵盖多轮交互的训练数据集，训练更符合交错思维特性的轻量级 Agent 模型，有效提升性能与响应效率。本文将在 EasyDistill（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmodelscope%2Feasydistill%25EF%25BC%2589%25E5%25BC%2580%25E6%25BA%2590%25E6%25A1%2586%25E6%259E%25B6%25E4%25B8%258B" target="_blank" title="https://github.com/modelscope/easydistill%EF%BC%89%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B8%8B" ref="nofollow noopener noreferrer">github.com/modelscope/…</a>，系统阐述面向 Interleaved Thinking 的大模型 Agent 蒸馏实践，涵盖数据集构建和蒸馏算法的开发，并结合实际应用案例，全面展示该技术在智能体模型训练中的潜力与优势。</p>
<h2 data-id="heading-1">面向Interleaved Thinking的蒸馏方法</h2>
<p>在本节中，我们首先回顾 Interleaved Thinking 的基础范式 ReAct，其次详细介绍面向 Interleaved Thinking 的大模型蒸馏方法，最后对蒸馏模型在 Agent 评测任务上的实际效果进行评测。</p>
<h3 data-id="heading-2">ReAct范式回眸</h3>
<p>我们首先简要回顾 Interleaved Thinking 的基础推理范式 ReAct。ReAct（Reasoning and Acting）由普林斯顿大学与谷歌研究团队提出，作为一种交互式推理框架，旨在解决传统大语言模型在复杂多轮推理任务中遇到的固有瓶颈与效率问题。传统的 Chain-of-Thought（CoT）推理方法通常采用线性、单向的处理流程，即模型先生成完整的推理链条，随后统一执行行动步骤。这种“先思考后行动”的顺序方法，在面对动态变化、环境不确定或需要多工具交互的任务时，容易导致上下文信息丢失、状态漂移和响应延迟，显著制约了模型的实用性和鲁棒性。</p>
<p>ReAct 范式的核心理念是将推理（Reasoning）与行动（Acting）紧密动态交织，通过“思考→行动→观察→再思考”的闭环交互，构建一个实时反馈驱动的推理体系。在实际运行中，模型在每一步不仅生成推理文本，还会决定是否调用外部工具（如数据库查询、API 调用、代码执行等），并根据工具反馈的结果即时调整推理策略与推理状态。这样，模型能够持续更新工作记忆中的环境状态和推理上下文，有效避免在多轮复杂推理与工具调用过程中出现的意图偏离和信息遗忘，确保推理的连贯性与动作执行的准确性。</p>
<p>技术上，ReAct 框架设计了一套交叉迭代的执行机制，具体流程包括：模型基于当前上下文进行推理，生成下一步的行动指令；系统执行对应工具调用并返回结果；模型根据返回信息更新推理状态，进行下一轮思考和决策。该机制不仅提升了模型对环境的响应敏捷性，也支持条件路径分支和自我纠正能力，使 Agent 能应对高度动态和不确定的任务环境。ReAct 与其他基础范式的对比如下所示：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/00998fbe47f54a019726350d1ff0bf13~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768385337&amp;x-signature=Nu7%2FVtg%2FxMvJA%2FmpUq%2FGr4QrZng%3D" alt="5eecdaf48460cde5a3f33c191076f85b249b71b4c034e49875b8339e1c4c24831b75b38faadcd24bec177c308ebd530451b2f706b2ae6ce1db97a0c0d5fd2289e3a71713c83748a4709ded22f389353d6ba7c70869fa707e4fb4c8ed7016461c.png" loading="lazy"/>
（上图源自ReAct: Synergizing Reasoning and Acting in Language Models. ICLR 2023）</p>
<h3 data-id="heading-3">教师轨迹数据生成</h3>
<p>教师轨迹数据的质量直接决定了学生模型推理能力的上限和训练效果的稳定性，因此，高质量轨迹数据的生成是多步推理与工具调用能力训练的关键基础环节。我们可以选用任何具备足够能力的大语言模型作为教师（Teacher），如 Qwen3-Max 等，借助其强大的理解与推理能力，生成高质量的任务执行轨迹。生成的轨迹需符合 ReAct 范式。以求解数学题为例，我们采用 Python 代码解释器作为工具，生成的轨迹数据采用标准的三元组结构 [Thought, Code, Observation]，具体对应如下：</p>
<ul>
<li>Thought（思考）：教师模型以自然语言对问题进行分析和推理，描述拆解思路、逻辑判断和决策依据；</li>
<li>Code（代码）：紧接思考后的工具调用指令，通常为 Python 代码，直接执行具体操作或计算，确保每步推理均具有可执行性与明确、可验证的输出；</li>
<li>Observation（观察）：代码执行后的环境反馈，包含具体结果和状态信息，为后续推理步骤提供实时上下文支持。</li>
</ul>
<p>这一设计充分模拟了人类在解决复杂问题时“思考→行动→观察→再思考”的思维闭环，保障了推理流程的透明性和过程的可复现性。</p>
<p>以下是一个典型的轨迹示例，展示教师模型如何根据题意动态拆解问题、生成工具调用代码，并根据代码执行的反馈调整后续步骤：</p>









































<table><thead><tr><th>Question</th><th>In how many ways can 6 girls and 2 boys sit in a row if the 2 boys sit next to each other?</th></tr></thead><tbody><tr><td>Thought 1 （Teacher）</td><td>First, I need to treat the 2 boys as a single unit, which means I have 7 units to arrange. I will calculate the number of ways.</td></tr><tr><td>Code 1 （Teacher）</td><td>import math<br/>ways_wo_boys_together = math.factorial(7)<br/>print(ways_wo_boys_together )</td></tr><tr><td>Observation 1</td><td>5040</td></tr><tr><td>Thought 2 （Teacher）</td><td>The boys can switch places within their unit, I will multiply it by 2.</td></tr><tr><td>Code 2 （Teacher）</td><td>ways = ways_wo_boys_together * 2<br/>print(ways)</td></tr><tr><td>Observation 2</td><td>10080</td></tr><tr><td>Thought 3 （Teacher）</td><td>I will provide the true answer.</td></tr><tr><td>Code 3 （Teacher）</td><td>print(“There are 10080 ways.”)</td></tr></tbody></table>
<p>通过构建自动化的数据生成流水线，并结合分布式高性能计算资源，我们能够高效产出大规模、多样化的教师轨迹数据集。整个流程包括任务指令发起、教师模型推理执行、代码运行环境反馈采集以及轨迹结果的验证与筛选等步骤，形成闭环，从而保证数据生成的稳定性与可扩展性。</p>
<h3 data-id="heading-4">行为克隆训练</h3>
<p>通过模仿教师模型的推理与执行轨迹，行为克隆训练使学生模型逐步学会如何将复杂问题拆解为有序的步骤，并能够基于上下文生成合理的推理思路和可执行代码，从而实现对任务的基本掌控。行为克隆训练采用标准的监督学习框架，其目标是最大化学生模型在训练轨迹数据上生成教师动作的概率。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51f68adec91447ad80ddffa937840e48~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768385337&amp;x-signature=S1TqVvCTS2uPygyIWuGwcS7cXf8%3D" alt="60f7b6733910467dbb2e4bbe8ccb84ec.png" loading="lazy"/></p>
<p>经过行为克隆阶段的训练，学生模型表现出以下能力提升：</p>
<ul>
<li>
<p>多步逻辑拆解能力：模型能够基于问题描述合理分解步骤，以符合逻辑的自然语言思维指导问题求解；</p>
</li>
<li>
<p>准确代码生成：学生模型生成的代码在语法和功能上表现明显提升，确保行动步骤可执行且输出结果有效；</p>
</li>
<li>
<p>动态反馈适应：模型能够有效利用环境反馈调整推理状态，展现了一定程度的闭环推理能力。</p>
</li>
</ul>
<p>该阶段的训练显著降低了后续训练的难度和复杂度。</p>
<h3 data-id="heading-5">教师纠错训练</h3>
<p>在完成行为克隆训练后，学生模型已经具备了基本的多步推理与工具调用能力，但在面对未见任务场景时，仍然可能出现推理漏洞或执行错误。为了促进学生模型能力的动态自适应提升，本阶段旨在让学生模型在全新任务中主动进行“思考-执行-观察”的闭环推理，自主尝试解决问题，并结合教师模型的针对性纠错辅导，实现能力的精准匹配与持续优化。</p>
<p>具体而言，在任务环境中，学生模型接收问题输入后，按照 ReAct 范式生成一系列轨迹步骤，每一步均包含自然语言推理（Thought）、对应代码执行（Code）及环境反馈（Observation）。通过让学生模型真实地“自己动手”解题，主动与环境交互生成完整的推理轨迹，我们大大减少了传统行为克隆中由于“模仿分布漂移”带来的训练偏差，使训练数据更加贴近真实推理行为。</p>
<p>例如，针对题目“6个女孩和2个男孩排成一排，要求2个男孩相邻，有多少种排法？”，学生模型的思考和执行可能出现如下情况：</p>

































<table><thead><tr><th>Question</th><th>In how many ways can 6 girls and 2 boys sit in a row if the 2 boys sit next to each other?</th></tr></thead><tbody><tr><td>Thought 1 （Student）</td><td>First, I need to treat the 2 boys as a single unit, which means I have 7 units to arrange. I will calculate the number of ways.</td></tr><tr><td>Code 1 （Student）</td><td>import math<br/>ways_wo_boys_together = math.factorial(7)<br/>print(ways_wo_boys_together )</td></tr><tr><td>Observation 1</td><td>5040</td></tr><tr><td>Thought 2 （Student）</td><td>The boys are a single unit, the ways equal to ways_wo_boys_together</td></tr><tr><td>Code 2 （Student）</td><td>ways = ways_wo_boys_together<br/>print(ways)</td></tr><tr><td>Observation 2</td><td>5040</td></tr></tbody></table>
<p>此处，学生模型在第二步未考虑男孩内部位置的交换，导致结果出现偏差。我们可以采用经过教师纠错和修正的完整轨迹，作为更贴合学生当前能力的训练样本。这样，模型既能学习关键错误的更正过程，又能避免在纯模仿训练中因错误轨迹未加控制而导致的误差快速累计与指数级扩散。技术实现上，本阶段训练时，模型以初始行为克隆阶段的权重为基础，利用教师修正后的轨迹作为训练输入，并沿用第一阶段的交叉熵监督损失。此举能够有效引导模型纠正其局部错误，持续提升推理与工具调用的准确性与鲁棒性。</p>
<h3 data-id="heading-6">实验效果评测</h3>
<p>为验证面向 Interleaved Thinking 的蒸馏方法在真实 Agent 任务中的优势，我们在多类 Agent 基准任务上对蒸馏模型进行了评测与对比。具体包括以下任务和评测基准：</p>
<ul>
<li>
<p>数学推理（需频繁调用 Python 工具）：AIME2024、AIME2025、MATH500、OlymMath</p>
<ul>
<li>指标：判断最终答案的正确性</li>
</ul>
</li>
<li>
<p>事实 / 多跳问答（需搜索工具）：HotpotQA、2WikiMultihopQA、MuSiQ、Bamboogle</p>
<ul>
<li>指标：token-level F1</li>
</ul>
</li>
<li>
<p>Deep Search：GAIA、WebWalker、HLE、xBench</p>
<ul>
<li>指标：使用 LLM-as-a-judge 判定正确性</li>
</ul>
</li>
</ul>
<p>在工具设置上，数学推理问题采用 Python 解释器，事实问答任务则使用在线搜索 API snippet（不包含浏览器功能），以降低工具调用成本和时延。</p>
<p>实验结果表明，面向 Interleaved Thinking 的蒸馏框架能够显著提升小模型在多步推理与工具调用任务中的稳定性和成功率。具体而言，经过上述模型蒸馏训练，在数学推理和事实 / 多跳问答任务上，7B 模型的效果已超过 32B 模型，并接近 72B 模型的表现；在 Deep Search 任务上，8B 模型的结果也与 72B 模型接近。</p>













































































<table><thead><tr><th><strong>Method</strong></th><th><strong>Mathematical Reasoning</strong></th><th/><th/><th/><th><strong>Factual Reasoning</strong></th><th/><th/><th/><th><strong>Avg.</strong></th></tr></thead><tbody><tr><td/><td>AIME24</td><td>AIME25</td><td>MATH500</td><td>OlymM</td><td>HQA</td><td>2Wiki</td><td>MuSiQ</td><td>Bamb</td><td/></tr><tr><td>Qwen2.5-72B-Instruct (大模型 直接调用工具)</td><td>33.3</td><td>40.0</td><td>77.4</td><td>17.0</td><td>60.5</td><td>75.5</td><td>36.8</td><td>73.2</td><td>51.7</td></tr><tr><td>Qwen2.5-32B-Instruct (大模型 直接调用工具)</td><td>30.0</td><td>23.3</td><td>74.0</td><td>18.0</td><td>54.9</td><td>64.9</td><td>26.9</td><td>67.8</td><td>45.0</td></tr><tr><td>Qwen2.5-7B-Instruct (AgentKD)</td><td>26.7</td><td>16.7</td><td>73.4</td><td>18.5</td><td>59.5</td><td>72.8</td><td>29.2</td><td>69.8</td><td>45.8</td></tr><tr><td>Qwen2.5-3B-Instruct (AgentKD)</td><td>20.0</td><td>13.3</td><td>67.0</td><td>12.5</td><td>55.9</td><td>71.6</td><td>27.8</td><td>67.5</td><td>41.9</td></tr></tbody></table>

















































<table><thead><tr><th><strong>Method</strong></th><th><strong>GAIA</strong></th><th/><th/><th/><th><strong>HLE</strong></th><th><strong>XBench</strong></th><th><strong>WebWalker</strong></th><th><strong>Avg.</strong></th></tr></thead><tbody><tr><td/><td>GAIA-1</td><td>GAIA-2</td><td>GAIA-3</td><td>Avg.</td><td/><td/><td/><td/></tr><tr><td>Qwen2.5-72B-Instruct (大模型直接调用工具)</td><td>30.8</td><td>36.5</td><td>16.7</td><td>32.0</td><td>7.8</td><td>31.0</td><td>38.5</td><td>27.3</td></tr><tr><td>Qwen3-8B (AgentKD)</td><td>35.9</td><td>26.9</td><td>8.3</td><td>28.2</td><td>10.0</td><td>22.0</td><td>41.5</td><td>25.4</td></tr></tbody></table>
<h2 data-id="heading-7">EasyDistill应用实践</h2>
<p>在 EasyDistill 开源框架中，我们支持了上文提到的面向 Interleaved Thinking 的大模型Agent蒸馏训练。在此，我们给出具体的应用实践示例。</p>
<h3 data-id="heading-8">项目主体框架</h3>
<p>EasyDistill 的 Agent 蒸馏模块主要基于 langgraph 框架，用于 Agent 推理轨迹生成，以及基于该轨迹的小型 Agent 模型蒸馏训练，其项目主体框架如下所示：</p>
<pre><code class="hljs language-plain" lang="plain">.
├── configs/
│   └── agentkd_local.json      # 主配置文件
├── data/
│   └── agent_demo.jsonl    # 原始数据源
│   └── agent_demo_labeled.jsonl    # 生成的推理轨迹
├── easydistill/agentkd
│   └── infer.py        # agent推理轨迹生成
│   └── train.py        # 蒸馏训练脚本
</code></pre>
<h3 data-id="heading-9">实践应用示例</h3>
<ol>
<li>
<p>首先，我们进行数据准备工作。数据集格式支持.jsonl，我们已经在 data/agent_demo.jsonl 中提供了示例数据。每条数据格式如下：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"question"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TLDR"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"solution"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TLDR"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"true_answer"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TLDR"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
</li>
<li>
<p>接着，我们配置训练所需参数，configs/agentkd_local.json 包含了生成 Agent 轨迹和蒸馏训练所需的全部参数配置信息，如下所示：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"job_type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"agentkd_local"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"dataset"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"instruction_path"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"data/agent_demo.jsonl"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"labeled_path_raw"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"data/agent_demo_labeled_raw.jsonl"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"labeled_path"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"data/agent_demo_labeled.json"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"models"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"teacher"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Qwen/Qwen2.5-72B-Instruct"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"student"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Qwen/Qwen2.5-7B-Instruct"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"inference"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span>
        ...
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"training"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
       ...
    <span class="hljs-punctuation">}</span>
    
<span class="hljs-punctuation">}</span>
</code></pre>
</li>
<li>
<p>使用 命令一键生成Agent轨迹数据和拉起训练任务</p>
</li>
</ol>
<pre><code class="hljs language-json" lang="json">easydistill --config configs/agentkd_local.json
</code></pre>
<p>该命令会基于源数据 data/agent_demo.jsonl 生成 原始Agent 推理轨迹，并将其进行格式转换，最终生成直接可用于训练的轨迹数据（实际使用中可根据需要调整推理参数），即 data/agent_demo_labeled.json，示例数据格式如下：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"conversations"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
            <span class="hljs-punctuation">{</span>
                <span class="hljs-attr">"from"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"human"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"A pool has 48 blue tiles and 32 red tiles. If the pool needs 100 tiles to be completed, how many more tiles are needed?"</span>
            <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
            <span class="hljs-punctuation">{</span>
                <span class="hljs-attr">"from"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"gpt"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;first_thought&gt;Calculate the total number of tiles currently in the pool, then subtract this number from the total number of tiles needed to find out how many more tiles are required.&lt;/first_thought&gt;"</span>
            <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
            <span class="hljs-punctuation">{</span>
                <span class="hljs-attr">"from"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"human"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Observation: None"</span>
            <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
            <span class="hljs-punctuation">{</span>
                <span class="hljs-attr">"from"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"gpt"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;thought&gt;I need to calculate the total number of tiles currently in the pool and then find out how many more tiles are needed to reach 100 tiles.&lt;/thought&gt;&lt;code&gt;# Calculate the total number of tiles currently in the pool\nblue_tiles = 48\nred_tiles = 32\ntotal_tiles_current = blue_tiles + red_tiles\n\n# Calculate how many more tiles are needed\ntiles_needed = 100 - total_tiles_current\nprint(tiles_needed)&lt;/code&gt;"</span>
            <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
            <span class="hljs-punctuation">{</span>
                <span class="hljs-attr">"from"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"human"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Observation: 20"</span>
            <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
            <span class="hljs-punctuation">{</span>
                <span class="hljs-attr">"from"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"gpt"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;thought&gt;I have already calculated the number of tiles needed to complete the pool, which is 20. Now, I need to format this number as a final answer in LaTeX format.&lt;/thought&gt;&lt;code&gt;final_answer_print(r\"\boxed{20}\")&lt;/code&gt;"</span>
            <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">]</span>
</code></pre>
<p>基于生成的 Agent 推理轨迹（data/agent_demo_labeled.json），该命令将自动进行最终的蒸馏训练。同样地，在实际使用中可根据需要修改 configs/agentkd_local.json 中的训练参数。</p>
<h2 data-id="heading-10">本文小结</h2>
<p>本文围绕面向 Interleaved Thinking 的大模型 Agent 蒸馏，系统介绍了基于动态交错推理机制的训练数据构建与蒸馏算法设计方法。通过引入符合交错思维特点的多轮交互数据及专门的蒸馏策略，我们能够训练出轻量、高效且具备强推理能力的 Agent 模型，有效提升模型在复杂任务中的表现和响应速度。这不仅突破了传统 CoT 推理链在多轮交互场景下的局限，也为智能体系统的规模化应用奠定了坚实基础。展望未来，我们将基于 EasyDistill 框架进一步开源更多 Agent 蒸馏相关的算法与模型。欢迎大家加入我们，共同交流大模型蒸馏技术！</p>
<h2 data-id="heading-11">参考工作</h2>
<p>EasyDistill 系列相关论文</p>
<ul>
<li>Wenrui Cai, Chengyu Wang, Junbing Yan, Jun Huang, Xiangzhong Fang. Reasoning with OmniThought: A Large CoT Dataset with Verbosity and Cognitive Difficulty Annotations. arXiv preprint</li>
</ul>

<ul>
<li>
<p>Yuanjie Lyu, Chengyu Wang, Jun Huang, Tong Xu. From Correction to Mastery: Reinforced Distillation of Large Language Model Agents. arXiv preprint</p>
</li>
<li>
<p>Chengyu Wang, Junbing Yan, Wenrui Cai, Yuanhao Yue, Jun Huang. EasyDistill: A Comprehensive Toolkit for Effective Knowledge Distillation of Large Language Models. <strong>EMNLP 2025</strong></p>
</li>
<li>
<p>Wenrui Cai, Chengyu Wang, Junbing Yan, Jun Huang, Xiangzhong Fang. Thinking with DistilQwen: A Tale of Four Distilled Reasoning and Reward Model Series. <strong>EMNLP 2025</strong></p>
</li>
<li>
<p>Wenrui Cai, Chengyu Wang, Junbing Yan, Jun Huang, Xiangzhong Fang. Enhancing Reasoning Abilities of Small LLMs with Cognitive Alignment. <strong>EMNLP 2025</strong></p>
</li>
<li>
<p>Chengyu Wang, Junbing Yan, Yuanhao Yue, Jun Huang. DistilQwen2.5: Industrial Practices of Training Distilled Open Lightweight Language Models. <strong>ACL 2025</strong></p>
</li>
<li>
<p>Yuanhao Yue, Chengyu Wang, Jun Huang, Peng Wang. Building a Family of Data Augmentation Models for Low-cost LLM Fine-tuning on the Cloud. <strong>COLING 2025</strong></p>
</li>
<li>
<p>Yuanhao Yue, Chengyu Wang, Jun Huang, Peng Wang. Distilling Instruction-following Abilities of Large Language Models with Task-aware Curriculum Planning. <strong>EMNLP 2024</strong></p>
</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Lambda NodeJS 运行时链路接入观测云]]></title>    <link>https://juejin.cn/post/7592531796039434274</link>    <guid>https://juejin.cn/post/7592531796039434274</guid>    <pubDate>2026-01-07T10:48:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592531796039434274" data-draft-id="7592432859862532130" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Lambda NodeJS 运行时链路接入观测云"/> <meta itemprop="keywords" content="AWS"/> <meta itemprop="datePublished" content="2026-01-07T10:48:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="可观测性用观测云"/> <meta itemprop="url" content="https://juejin.cn/user/2392958212523102"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Lambda NodeJS 运行时链路接入观测云
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2392958212523102/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    可观测性用观测云
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:48:41.000Z" title="Wed Jan 07 2026 10:48:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>为有效监控无服务器架构的业务性能，我们需要将 AWS Lambda 函数的全链路数据接入观测云进行统一可观测性分析。由于 Lambda 环境的特殊性，最佳实践是构建一个集成了 OpenTelemetry 的官方 Layer。该 Layer 能自动捕获函数调用链与性能指标，并通过标准 OTLP 协议上报。为确保数据传输的高效性与前瞻性，我们特别将社区常见的 JSON 格式调整为 Protobuf 编码，以适配观测云后端的技术演进，为函数性能优化与故障诊断提供坚实的数据基础。</p>
<h2 data-id="heading-1">前提条件</h2>
<p>运行时：NodeJS 22</p>
<h2 data-id="heading-2">安装 DataKit 并配置采集器</h2>
<p>进入观测云控制台 -「集成」-「DataKit」-「Linux」复制命令安装 DataKit 。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2020a93bad84dbfa840177c18697373~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=djYIyrwHJ9278%2FpMDXR3plgqJKE%3D" alt="" loading="lazy"/></p>
<p>进入 <code>/usr/local/datakit/conf.d/samples</code> ，将 <code>opentelemetry.conf.sample</code> 复制到上级目录 <code>/conf.d</code> 中，并修改文件后缀为 <code>conf</code> 。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cp</span> opentelemetry.conf.sample ../opentelemetry.conf
</code></pre>
<p>编辑 opentelemetry 配置文件，修改如下部分，添加 enable = true ，然后保存。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75d3ad86f89944b2812ede68519a7531~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=KaVfzyDvZfcKEB4YGinGGNFliIA%3D" alt="" loading="lazy"/></p>
<p>执行以下命令重启 DataKit 。</p>
<pre><code class="hljs">datakit service -R
</code></pre>
<p>打开 <code>datakit.conf</code> 的 <code>http_api</code> 开启 <code>0.0.0.0:9529</code> 。</p>
<h2 data-id="heading-3">准备一个 Lambda 函数</h2>
<p>以下 demo 脚本调用了一个 Java 服务 <code>52.83.66.70:8090/user</code> ：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-built_in">exports</span>.<span class="hljs-property">handler</span> = <span class="hljs-keyword">async</span> (event, context) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'=== 开始调用Java服务验证TraceID ==='</span>);
    
    <span class="hljs-keyword">try</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'准备调用Java服务: 52.83.66.70:8090/user'</span>);
        
        <span class="hljs-comment">// 调用您的Java服务</span>
        <span class="hljs-keyword">const</span> javaServiceResult = <span class="hljs-keyword">await</span> <span class="hljs-title function_">callJavaService</span>();
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Java服务调用成功'</span>);
        
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">statusCode</span>: <span class="hljs-number">200</span>,
            <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
                <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">message</span>: <span class="hljs-string">'Java服务调用完成'</span>,
                <span class="hljs-attr">javaServiceResponse</span>: javaServiceResult,
                <span class="hljs-attr">requestId</span>: context.<span class="hljs-property">awsRequestId</span>,
                <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>()
            })
        };
        
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'调用Java服务失败:'</span>, error);
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">statusCode</span>: <span class="hljs-number">500</span>,
            <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
                <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">message</span>: <span class="hljs-string">'Java服务调用失败'</span>,
                <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span>
            })
        };
    }
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">callJavaService</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'开始发起HTTP请求到Java服务...'</span>);
        
        <span class="hljs-keyword">const</span> options = {
            <span class="hljs-attr">hostname</span>: <span class="hljs-string">'52.83.66.70'</span>,
            <span class="hljs-attr">port</span>: <span class="hljs-number">8090</span>,
            <span class="hljs-attr">path</span>: <span class="hljs-string">'/user'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
            <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,  <span class="hljs-comment">// 5秒超时</span>
            <span class="hljs-attr">headers</span>: {
                <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Lambda-OTEL-Test/1.0'</span>,
                <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'application/json'</span>
            }
        };
        
        <span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Java服务响应状态码: <span class="hljs-subst">${res.statusCode}</span>`</span>);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'响应头:'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res.<span class="hljs-property">headers</span>));
            
            <span class="hljs-keyword">let</span> data = <span class="hljs-string">''</span>;
            res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
                data += chunk;
            });
            
            res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Java服务响应数据长度:'</span>, data.<span class="hljs-property">length</span>);
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'原始响应:'</span>, data);
                
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 尝试解析JSON响应</span>
                    <span class="hljs-keyword">const</span> parsedData = data ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data) : {};
                    <span class="hljs-title function_">resolve</span>({
                        <span class="hljs-attr">statusCode</span>: res.<span class="hljs-property">statusCode</span>,
                        <span class="hljs-attr">data</span>: parsedData,
                        <span class="hljs-attr">headers</span>: res.<span class="hljs-property">headers</span>,
                        <span class="hljs-attr">rawResponse</span>: data
                    });
                } <span class="hljs-keyword">catch</span> (e) {
                    <span class="hljs-comment">// 如果JSON解析失败，返回原始数据</span>
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'响应不是JSON格式，返回原始数据'</span>);
                    <span class="hljs-title function_">resolve</span>({
                        <span class="hljs-attr">statusCode</span>: res.<span class="hljs-property">statusCode</span>,
                        <span class="hljs-attr">data</span>: data,
                        <span class="hljs-attr">headers</span>: res.<span class="hljs-property">headers</span>,
                        <span class="hljs-attr">isJson</span>: <span class="hljs-literal">false</span>
                    });
                }
            });
        });
        
        req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求Java服务错误:'</span>, error.<span class="hljs-property">message</span>);
            <span class="hljs-title function_">reject</span>(error);
        });
        
        req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'timeout'</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求Java服务超时'</span>);
            req.<span class="hljs-title function_">destroy</span>();
            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'请求Java服务超时'</span>));
        });
        
        <span class="hljs-comment">// 发送请求</span>
        req.<span class="hljs-title function_">end</span>();
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'HTTP请求已发送到Java服务'</span>);
    });
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eb01cf1faace401990f6f8e6d868dda3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=qkyiTsIOdVU1qnFmG%2BxiM3VMnTI%3D" alt="" loading="lazy"/></p>
<p>测试事件：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/81a09bc5f94b45f7a84f7c4dde2365e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=iy8FVxCLHlzl3%2BYedEKyAYCfTZI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4">构建 Layer</h2>
<p>构建官方的 Layer 做导出器，通过 Layer 集成，无侵入式地自动捕获 Lambda 函数执行的链路数据可以自动采集 Lambda 函数的链路数据，将采集的数据转换为 OpenTelemetry（OTel）标准格式，确保与观测后端平台的兼容性。</p>
<p>注意：Node.js 社区提供的默认 OpenTelemetry 导出器通常使用 HTTP/JSON 方式发送数据，需要将默认的导出协议从 HTTP/JSON 改为 HTTP/PROTOBUF，DataKit 后续可能考虑废弃 HTTP/JSON 方式。Protobuf 编码具有更高的序列化/反序列化效率，能显著降低传输数据大小和网络开销，尤其适用于 Lambda 的短时执行环境。</p>
<p>具体可以参考 Opentelemetry 的社区：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopen-telemetry%2Fopentelemetry-lambda%2Ftree%2Fmain%2Fnodejs" target="_blank" title="https://github.com/open-telemetry/opentelemetry-lambda/tree/main/nodejs" ref="nofollow noopener noreferrer">github.com/open-teleme…</a></p>
<h3 data-id="heading-5">克隆仓库</h3>
<pre><code class="hljs language-bash" lang="bash">git <span class="hljs-built_in">clone</span> https://github.com/open-telemetry/opentelemetry-lambda
</code></pre>
<h3 data-id="heading-6">修改协议</h3>
<p>进入项目目录，将相关文件的 <code>@opentelemetry/exporter-trace-otlp-http</code> 改成<code>@opentelemetry/exporter-trace-otlp-proto</code>，一共需要修改 3 个文件。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> opentelemetry-lambda/nodejs
</code></pre>
<p><code>./packages/layer/src/wrapper.ts</code></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38bd51a9fd604663979fc5fe82efef3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=utXS21k%2B99DdNPhTnjPCgkE%2B2%2FE%3D" alt="" loading="lazy"/></p>
<p><code>./packages/layer/package.json</code></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5cd6458047554a50b6c72a2699e2faa5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=eHYE3RkZpLk%2BWlmbmqJ2voJAruE%3D" alt="" loading="lazy"/></p>
<p><code>./packages/layer/test/wrapper.spec.ts</code></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/029ffbd3acf149fca5418d18c0a3d905~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=uXLGyEOoug6iGc98KmqJ93Em9IA%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-7">安装依赖</h3>
<pre><code class="hljs">npm  install
</code></pre>
<h3 data-id="heading-8">构建项目</h3>
<pre><code class="hljs language-arduino" lang="arduino">npm run build
</code></pre>
<p>在 <code>./nodejs/packages/layer/build/</code> 会有一个 layer.zip 文件。</p>
<h2 data-id="heading-9">添加 Layer</h2>
<h3 data-id="heading-10">创建 Layer</h3>
<p>在 AWS 控制台 Lambda 进入「layer」，新建一个 Layer，选择上传 .zip 文件方式上传刚才生成的 layer.zip 文件，架构选择 x86、运行时选择 nodejs。创建好后复制 ARN 。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b889203182e436eb6828d4073cbce93~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=DIps1JMjleDD3e5mgF2GAYLD5l4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-11">添加 Layer</h3>
<p>在 Demo 函数中添加 Layer，选择指定一个 ARN ，将刚才的 ARN 复制进去，点击「添加」。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/60e5f5924386484b9cf6d2bd71f8d5fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=TmZcFr40Ady0bHLAE3iKTf6%2BYCM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-12">配置环境变量</h3>
<p>配置 Lambda 环境变量，选择「配置」-「环境变量」。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d0716a8352a44aa4af10685cbbe277a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=XBT0U9mdoS8OnqgxGVzjBTvXsOU%3D" alt="" loading="lazy"/></p>
<p>添加如下变量：</p>

































<table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>AWS_LAMBDA_EXEC_WRAPPER</td><td>/opt/otel-handler</td></tr><tr><td>OTEL_EXPORTER_OTLP_ENDPOINT</td><td>http://&lt;datakit主机地址&gt;:9529/otel</td></tr><tr><td>OTEL_EXPORTER_OTLP_TRACES_PROTOCOL</td><td>http/protobuf</td></tr><tr><td>OTEL_NODE_ENABLED_INSTRUMENTATIONS</td><td>aws-lambda,aws-sdk,http,https,pg,mysql,redis</td></tr><tr><td>OTEL_SERVICE_NAME</td><td>服务名称</td></tr><tr><td>OTEL_TRACES_SAMPLER</td><td>always_on</td></tr></tbody></table>
<h3 data-id="heading-13">测试函数</h3>
<p>回到函数点击测试</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9106fe8e902c449eac82d2fe92570dda~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=4JyEzTUGZLgkEdduUXqwIdd5gGU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-14">观测云效果</h2>
<p>链路上报效果如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aea9fb76b0c54b8f8466c235bf81e610~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=ZskSaVssjpwSxLCVCnssWBZK0bQ%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0164a6c9903745f08f7f7c8755041fff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=rht6tINseTc0fe5ZGlRAIFtCoo4%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b0101db490eb425f94d07a49ee9e5ca4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=44M1aFWkzGbRFpOrFBi6DBEILRU%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ecba69b48a06441cb03a71fa436134cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-v6KeC5rWL5oCn55So6KeC5rWL5LqR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768387721&amp;x-signature=dx8EcFh1G%2FXIdGgMi7YwUSmbYWY%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[学习一些常用的混合模式之BlendMode. SRC_ATOP]]></title>    <link>https://juejin.cn/post/7592148975848882219</link>    <guid>https://juejin.cn/post/7592148975848882219</guid>    <pubDate>2026-01-07T10:58:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592148975848882219" data-draft-id="7592255257347538985" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="学习一些常用的混合模式之BlendMode. SRC_ATOP"/> <meta itemprop="keywords" content="Flutter"/> <meta itemprop="datePublished" content="2026-01-07T10:58:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="火柴就是我"/> <meta itemprop="url" content="https://juejin.cn/user/272334614705575"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            学习一些常用的混合模式之BlendMode. SRC_ATOP
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/272334614705575/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    火柴就是我
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T10:58:08.000Z" title="Wed Jan 07 2026 10:58:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>SRC_ATOP</p>
<p><code>Discards the source pixels that do not cover destination pixels. Draws remaining source pixels over destination pixels.</code></p>
<p>计算公式:</p>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39ae708a05a74dbbb15ca94533b45d2f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Gr5p-05bCx5piv5oiR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768388288&amp;x-signature=cQ0eTE82kWAYKS8gg9x0tM1vcIg%3D" alt="image.png" width="30%" loading="lazy"/>
<p>在src.a 跟 dst.a 都是1的情况下,整体效果跟srcIn一样。</p>
<p>但是当dst.a = 1 的时候颜色值就是 src.a 从0-1变化的时候 就是src.c + src.dst * （1 - src.a）</p>
<p>例子:</p>
<pre><code class="hljs language-js" lang="js">  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span>(<span class="hljs-params">Canvas canvas, Size size</span>) {
    <span class="hljs-keyword">var</span> width = size.<span class="hljs-property">width</span>;
    <span class="hljs-keyword">var</span> height = size.<span class="hljs-property">height</span>;

    canvas.<span class="hljs-title function_">saveLayer</span>(<span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), <span class="hljs-title class_">Paint</span>());
    <span class="hljs-title class_">Paint</span> dstPaint = <span class="hljs-title class_">Paint</span>()..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">red</span>;
    dstPaint.<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">20</span>;
    dstPaint.<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span>;

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">10</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">50</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">90</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">130</span>, dstPaint);

    <span class="hljs-keyword">var</span> srcPaint = <span class="hljs-title class_">Paint</span>()
      ..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">blue</span>.<span class="hljs-title function_">withOpacity</span>(<span class="hljs-number">0.5</span>) <span class="hljs-comment">// 源颜色：蓝色</span>
      ..<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span> <span class="hljs-comment">// 填充模式</span>
      ..<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">70</span>
      ..<span class="hljs-property">blendMode</span> = <span class="hljs-title class_">BlendMode</span>.<span class="hljs-property">srcATop</span>; <span class="hljs-comment">// 混合模式</span>
    <span class="hljs-comment">// canvas.drawRect(Rect.fromLTWH(0, 0, width, height), srcPaint);</span>
    canvas.<span class="hljs-title function_">drawImageRect</span>(image!, <span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, image!.<span class="hljs-property">width</span>.<span class="hljs-title function_">toDouble</span>(), image!.<span class="hljs-property">height</span>.<span class="hljs-title function_">toDouble</span>()), <span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), srcPaint);
    canvas.<span class="hljs-title function_">restore</span>();
  }
</code></pre>
<p>这里src.a = 0.5 相当于在src.c中混入了 0.5*dst.c 所以图片就看起来有点泛红。效果图如下:</p>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3ddd82060da40fea836caccc30cc9d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Gr5p-05bCx5piv5oiR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768388288&amp;x-signature=P%2FqiwDUz5YtYWwM%2B1wVt2uEm5dc%3D" alt="image.png" width="30%" loading="lazy"/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[她问我：数据库还在存 Timestamp？我说：大人，时代变了]]></title>    <link>https://juejin.cn/post/7592276497400381490</link>    <guid>https://juejin.cn/post/7592276497400381490</guid>    <pubDate>2026-01-07T08:55:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592276497400381490" data-draft-id="7592340733954195506" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="她问我：数据库还在存 Timestamp？我说：大人，时代变了"/> <meta itemprop="keywords" content="数据库,后端,MySQL"/> <meta itemprop="datePublished" content="2026-01-07T08:55:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="洛小豆"/> <meta itemprop="url" content="https://juejin.cn/user/2049145406229127"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            她问我：数据库还在存 Timestamp？我说：大人，时代变了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2049145406229127/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    洛小豆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T08:55:33.000Z" title="Wed Jan 07 2026 08:55:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    25
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.7;font-weight:400;font-size:16px;overflow-x:hidden;color:#212122}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-bottom:8px;padding-bottom:8px}.markdown-body h1{color:#a0a0a0;font-size:38px;margin-top:32px;padding-top:32px}.markdown-body h2{color:#fff;background-color:#212122;width:fit-content;border-bottom-right-radius:100px;margin-top:47px;margin-bottom:16px;padding:4px 48px 4px 8px;line-height:1.7;font-size:30px;transition:all .3s ease-out}.markdown-body h2:hover{border-bottom-right-radius:50px;transition:all .3s ease-out}.markdown-body h3{font-size:24px;padding-left:8px;margin-top:32px;border-bottom:2px solid #c6c4c4;line-height:1.7}.markdown-body h4{font-size:20px;padding-left:8px;margin-top:32px;border-bottom:1px solid #ddd}.markdown-body h5{font-size:16px;margin-top:24px}.markdown-body h6{margin-top:16px;line-height:1.1}.markdown-body p{font-size:16px;text-align:start;white-space:normal;text-size-adjust:auto;line-height:2;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%;margin:auto;padding-left:8px;padding-right:8px}.markdown-body hr{border:none;border-top:4px double #212122;margin-top:32px;margin-bottom:32px;text-align:center}.markdown-body hr:after{content:"♥";display:inline-block;position:relative;top:-15px;padding:0 10px;color:#212122;font-size:18px}.markdown-body code{word-break:break-word;overflow-x:auto;background-color:#f1f1f1;color:#ef7060;font-size:14px;padding:.065em 6px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.7;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);margin:32px 16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-color:#212122;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);background-size:40px}.markdown-body pre&gt;code{font-size:14px;padding:16px 8px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#fff;background:#272822}.markdown-body pre&gt;code::-webkit-scrollbar{height:10px;background-color:#f5f5f5}.markdown-body pre&gt;code::-webkit-scrollbar-track{box-shadow:inset 0 0 6px rgba(0,0,0,.3);border-radius:3px;background-color:#f5f5f5}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{border-radius:3px;box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#555}.markdown-body a{color:#ef7060;padding:2px;text-decoration:none;border-bottom:.125em solid #ef7060;border-radius:2px;box-shadow:inset 0 -.025em 0 #ef7060;transition:box-shadow .27s cubic-bezier(.77,0,.175,1),color .27s cubic-bezier(.77,0,.175,1)}.markdown-body a:focus,.markdown-body a:hover{outline:none;box-shadow:inset 0 -1.5em 0 #ef7060;color:#fff}.markdown-body a:before{content:"⇲ ";vertical-align:top;margin-left:2px;font-family:dart!important;font-size:12px;color:inherit;opacity:.7}.markdown-body table{background:#fbfbfb;border-radius:4px;border-collapse:collapse;margin:auto;padding:5px;width:95%;box-shadow:0 5px 10px rgba(0,0,0,.1);animation:float 5s infinite}.markdown-body table th{color:#fff;background:#212122;border-bottom:1px solid #9ea7af;border-right:1px solid #343a45;font-size:18px;padding:16px;text-align:left;vertical-align:middle}.markdown-body table th:first-child{border-top-left-radius:4px}.markdown-body table th:last-child{border-top-right-radius:4px;border-right:none}.markdown-body table tr{border-top:1px solid #c1c3d1;border-bottom:1px solid #c1c3d1;color:#666b85}.markdown-body table tr:hover td{background:#212122;color:#fff;border-top:1px solid #22262e}.markdown-body table tr:first-child{border-top:none}.markdown-body table tr:last-child{border-bottom:none}.markdown-body table tr:nth-child(odd) td{background:#f1f1f1}.markdown-body table tr:nth-child(odd):hover td{background:#212122}.markdown-body table tr:last-child td:first-child{border-bottom-left-radius:4px}.markdown-body table tr:last-child td:last-child{border-bottom-right-radius:4px}.markdown-body table td{background:#fbfbfb;padding:16px;text-align:left;vertical-align:middle;font-size:16px;border-right:1px solid #c1c3d1}.markdown-body table td:last-child{border-right:0}.markdown-body blockquote{color:#777;padding:1px 16px;margin:24px 0;border-left:4px solid #c6c4c4;background-color:#f1f1f1;transition:all .3s ease-out;border-radius:4px}.markdown-body blockquote:hover{border-left-color:#212122;background-color:#212122;color:#fff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:24px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body span.math{margin-left:32px;font-size:18px;font-weight:700}@media (max-width:720px){.markdown-body h1{font-size:30.4px}.markdown-body h2{font-size:24px}.markdown-body h3{font-size:19.2px}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:12.8px}}</style><style data-highlight="" data-highlight-key="an-old-hope">.hljs-comment,.hljs-quote{color:#b6b18b}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#eb3c54}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#e7ce56}.hljs-attribute{color:#ee7c2b}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#4fb4d7}.hljs-section,.hljs-title{color:#78bb65}.hljs-keyword,.hljs-selector-tag{color:#b45ea4}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#1c1d21;color:#c0c5ce}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>深夜代码系列 · 第6期</p>
<p>关注我，和小豆一起在掘金刷小说</p>
</blockquote>
<h2 data-id="heading-0">🔥 开篇引爆</h2>
<p>周四深夜，办公室里的中央空调早就停了，只剩下几台显示器发出的微弱嗡鸣声，混杂着硬盘读写时偶尔传来的咔哒声。窗外下着雨，雨滴砸在空调外机上发出闷闷的啪嗒声，像是有人在敲打着铁皮，催促着这栋楼里最后几个不肯离开的人。</p>
<p>空气里飘着速溶咖啡的苦味，还有从楼下便利店带上来的关东煮汤汁蒸发后留下的味道。我的手掌贴在键盘上，能感觉到键帽因为长时间敲击而变得温热，指尖有些发麻。</p>
<p>"豆子……"</p>
<p>小汐的声音从我左后方传来，轻得像是怕惊扰了这深夜的寂静。我回过头，她正侧坐在椅子上，一只手撑着下巴，另一只手无力地搭在鼠标上。办公室昏黄的壁灯光从侧面打过来，在她脸颊上留下一道浅浅的阴影，让她看起来比平时更疲惫。</p>
<p>她的头发松松地扎着，有几缕已经从发圈里滑了出来，垂在耳边。她眨了眨眼，睫毛在灯光下投下细小的影子。</p>
<p>"你能过来看看吗？"她的声音里带着一丝犹豫，像是不确定该不该在这个点打扰我，"我这个时间轴组件，排序怎么都不对。"</p>
<p>我滑着椅子过去，心里隐隐有种不好的预感——每次她用这种语气叫我，通常意味着问题不简单。</p>
<p>她把屏幕转向我，指着那个密密麻麻的操作记录列表："你看，这几条明明是我连续点的，时间应该是有先后顺序的。但它们在列表里的位置完全乱了，有时候后点的反而排在前面。"</p>
<p>我凑近看了看，确实，那几条用户操作记录的时间戳看起来都一样，全是整秒。</p>
<p>"你传给我的时间戳是 10 位的，"她轻叹了口气，用鼠标在控制台里划了一下，"但我前端用的是 13 位毫秒时间戳。<code>Date.now()</code> 返回的就是 13 位。你给我 10 位，我只能自己乘以 1000 补成 13 位，但这样毫秒位永远是 <code>000</code>，同一秒内的操作根本排不了序。"</p>
<h2 data-id="heading-1">🎯 场景还原</h2>
<p>我打开后端的返回数据，心里已经猜到问题出在哪了：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1024</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"user_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">88</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"action"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"click_button"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"timestamp"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1704723600</span>  <span class="hljs-comment">// 10 位秒级时间戳</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>"这个……"我有些尴尬地挠了挠头，"我后端存的是 MySQL 的 <code>TIMESTAMP</code> 类型，它只能精确到秒。所以返回的时间戳就是 10 位的。"</p>
<p>小汐抬起头看着我，眼神里写满了不解："豆子，现在是 2025 年了，前端早就全面用 13 位毫秒时间戳了。你看这个……"</p>
<p>她打开她的代码，指给我看：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 前端创建时间戳的标准做法</span>
<span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now); <span class="hljs-comment">// 输出：1704723600123（13 位）</span>

<span class="hljs-comment">// 但后端返回的是这个</span>
<span class="hljs-keyword">const</span> serverTime = <span class="hljs-number">1704723600</span>; <span class="hljs-comment">// 10 位</span>
<span class="hljs-keyword">const</span> timestamp = serverTime * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 只能硬补成 1704723600000</span>
<span class="hljs-comment">// 问题：同一秒内的所有操作，毫秒位都是 000，无法区分先后</span>
</code></pre>
<p>"我做的是用户行为分析，"她的声音很轻，但我能听出那种无奈，"产品要求能精确回放用户在页面上的每一个操作。如果同一秒内用户点了三个按钮、输入了两段文字，我需要知道具体的顺序。但你的精度只到秒，这些细节全丢了。"</p>
<p>我看着数据库表结构，这是项目启动时我"顺手"建的：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `user_actions` (
  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,
  `user_id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  `action` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
  `created_at` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)
) ENGINE<span class="hljs-operator">=</span>InnoDB;
</code></pre>
<p>"我当时选 <code>TIMESTAMP</code> 是因为它只占 4 个字节，"我试图解释，但声音越来越没底气，"而且它会自动处理时区……"</p>
<p>小汐摇了摇头，她的手指在桌面上轻轻敲了两下："豆子，你知道 <code>TIMESTAMP</code> 最多能存到哪一年吗？"</p>
<p>我愣了一下。</p>
<p>"2038 年。"她看着我的眼睛说，"如果这个系统活过 2038 年，你这个字段就会炸。"</p>
<p>那一刻，我突然意识到自己当初的"顺手"决定，可能埋下了一个定时炸弹。</p>
<h2 data-id="heading-2">🧠 思路分析</h2>
<p>"还在用 <code>TIMESTAMP</code> 存时间？"</p>
<p>一个平静的声音从茶水间方向传来。是阿辰。</p>
<p>他端着保温杯走过来，身上还披着那件常年不离身的灰色冲锋衣。眼镜在灯光下反着光，让人看不清他的眼神，但从他嘴角那一丝若有若无的笑意，我知道他肯定又要讲大道理了。</p>
<p>"辰哥，你还没走？"小汐有些惊讶。</p>
<p>"刚修完一个时区 Bug，"阿辰在我们旁边坐下，拧开保温杯喝了一口，"刚好听到你们在讨论时间戳的问题。豆子，你现在用的这个 <code>TIMESTAMP</code>，已经不适合现代应用了。"</p>
<p>他转身走到白板前，拿起记号笔画了两个图：</p>
<p>"你把 <code>TIMESTAMP</code> 想象成<strong>超市里的鲜牛奶</strong>，"他指着第一个图说，"保质期短（只到 2038 年），而且对环境很敏感——温度变了它就变质了。你的服务器从北京迁到伦敦，它存的时间就会跟着变，因为它会自动根据服务器时区转换。"</p>
<p>小汐听得很认真，微微点了点头。</p>
<p>"而 <code>DATETIME</code>，尤其是 <code>DATETIME(3)</code>，"阿辰画了第二个图，"就像<strong>真空包装的食品</strong>。保质期长（能存到 9999 年），不受环境影响。不管你把它放在哪个时区的服务器上，它存的值都不会变。而且这个 <code>(3)</code> 很关键——它表示小数点后保留 3 位，也就是毫秒。"</p>
<p>"毫秒？"小汐的眼睛亮了一下。</p>
<p>"对，"阿辰在白板另一侧快速写下了一个对比表：</p>



































<table><thead><tr><th>对比维度</th><th>TIMESTAMP</th><th>DATETIME(3)</th></tr></thead><tbody><tr><td><strong>存储空间</strong></td><td>4 字节</td><td>6 字节</td></tr><tr><td><strong>时间范围</strong></td><td>1970~2038</td><td>1000~9999</td></tr><tr><td><strong>精度</strong></td><td>秒（10位时间戳）</td><td>毫秒（13位时间戳）</td></tr><tr><td><strong>时区行为</strong></td><td>自动转换（易出Bug）</td><td>不处理（手动管理UTC）</td></tr><tr><td><strong>前端兼容</strong></td><td>❌ 需要乘以1000补零</td><td>✅ 原生匹配13位</td></tr></tbody></table>
<p>"你看最后一行，"阿辰指着表格，"现代前端用的都是 13 位毫秒时间戳，这是 <code>Date.now()</code> 的标准。而 <code>DATETIME(3)</code> 的精度正好是毫秒，和前端完美匹配。"</p>
<p>他停顿了一下，看着我："而且，<code>DATETIME(3)</code> 只比 <code>TIMESTAMP</code> 多占 2 个字节。2025 年了，谁还在乎那 2 个字节？"</p>
<p>"更重要的是，"阿辰继续说，"如果用 <code>DATETIME(3)</code> + UTC 的方案，前后端就完全打通了。前端传 13 位时间戳过来，你转成 <code>DATETIME(3)</code> 存进数据库。读出来时，再转回 13 位返回给前端。精度一点不丢。"</p>
<h2 data-id="heading-3">💻 代码实战</h2>
<p>既然方案明确了，那就动手。我打开终端，准备对这张表做个"手术"。</p>
<h3 data-id="heading-4">1. 数据库表结构升级</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 第一步：从 TIMESTAMP 升级为 DATETIME(3)</span>
<span class="hljs-comment">-- (3) 表示保留 3 位小数，即毫秒精度</span>
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `user_actions`
MODIFY <span class="hljs-keyword">COLUMN</span> `created_at` DATETIME(<span class="hljs-number">3</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'1970-01-01 00:00:00.000'</span>;

<span class="hljs-comment">-- 如果你还有 updated_at 字段，也一起改了</span>
<span class="hljs-comment">-- ALTER TABLE `user_actions`</span>
<span class="hljs-comment">-- MODIFY COLUMN `updated_at` DATETIME(3) NOT NULL;</span>
</code></pre>
<p>"看这里，"我指着 SQL 对小汐说，"这个 <code>DATETIME(3)</code> 中的 <code>(3)</code> 就是关键。以前我们写 <code>DATETIME</code> 都不加这个，默认精度是 0，只能到秒。加了 <code>(3)</code> 之后，就能存到毫秒了，比如 <code>2025-01-09 18:00:00.123</code>。"</p>
<p><strong>为什么是 3 位小数？</strong></p>
<ul>
<li><code>DATETIME(0)</code>：秒，对应 10 位时间戳</li>
<li><code>DATETIME(3)</code>：毫秒，对应 13 位时间戳（前端标准）</li>
<li><code>DATETIME(6)</code>：微秒，对应 16 位时间戳（高频交易场景）</li>
</ul>
<h3 data-id="heading-5">2. 前后端数据流转方案</h3>
<p>我在白板上画了个完整的数据流：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant F as 前端（小汐）
    participant B as 后端（我）
    participant D as MySQL

    Note over F,D: 核心原则：13 位时间戳 + UTC

    F-&gt;&gt;B: POST /api/action&lt;br/&gt;{action: "click", ts: 1704723600123}
    Note right of F: Date.now() 生成&lt;br/&gt;13 位毫秒时间戳

    B-&gt;&gt;B: 转换函数&lt;br/&gt;1704723600123 → "2025-01-09 01:00:00.123"

    B-&gt;&gt;D: INSERT INTO user_actions&lt;br/&gt;(created_at) VALUES ('2025-01-09 01:00:00.123')

    D--&gt;&gt;B: 写入成功

    F-&gt;&gt;B: GET /api/actions
    B-&gt;&gt;D: SELECT created_at FROM user_actions
    D--&gt;&gt;B: "2025-01-09 01:00:00.123"

    B-&gt;&gt;B: 转换函数&lt;br/&gt;"2025-01-09 01:00:00.123" → 1704723600123

    B--&gt;&gt;F: {ts: 1704723600123, ...}
    Note left of F: 前端拿到 13 位时间戳&lt;br/&gt;直接使用，精度完整
</code></pre>
<h3 data-id="heading-6">3. 后端转换函数实现</h3>
<p>核心是两个工具函数：13 位时间戳 ↔ DATETIME(3) 的双向转换。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> dayjs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dayjs'</span>);
<span class="hljs-keyword">const</span> utc = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dayjs/plugin/utc'</span>);
dayjs.<span class="hljs-title function_">extend</span>(utc);

<span class="hljs-comment">// =========== 转换工具函数 ===========</span>

<span class="hljs-comment">/**
 * 前端 13 位毫秒时间戳 → 数据库 DATETIME(3) 格式
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">timestamp</span> - 13 位毫秒时间戳，如 1704723600123
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} - 如 "2025-01-09 01:00:00.123"
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">timestampToDb</span>(<span class="hljs-params">timestamp</span>) {
  <span class="hljs-comment">// 关键：使用 utc() 确保转换为 UTC 时间</span>
  <span class="hljs-keyword">return</span> dayjs.<span class="hljs-title function_">utc</span>(timestamp).<span class="hljs-title function_">format</span>(<span class="hljs-string">'YYYY-MM-DD HH:mm:ss.SSS'</span>);
}

<span class="hljs-comment">/**
 * 数据库 DATETIME(3) 格式 → 前端 13 位毫秒时间戳
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">datetime</span> - 如 "2025-01-09 01:00:00.123"
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">number</span>} - 13 位毫秒时间戳
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dbToTimestamp</span>(<span class="hljs-params">datetime</span>) {
  <span class="hljs-comment">// valueOf() 返回 13 位毫秒时间戳</span>
  <span class="hljs-keyword">return</span> dayjs.<span class="hljs-title function_">utc</span>(datetime).<span class="hljs-title function_">valueOf</span>();
}

<span class="hljs-comment">// =========== API 接口实现 ===========</span>

<span class="hljs-comment">// 记录用户操作</span>
app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/action'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> { user_id, action, ts } = req.<span class="hljs-property">body</span>;

  <span class="hljs-comment">// 前端传来 13 位时间戳，转为数据库格式</span>
  <span class="hljs-keyword">const</span> createdAt = <span class="hljs-title function_">timestampToDb</span>(ts);

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`前端传入: <span class="hljs-subst">${ts}</span> (13位)`</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`存入数据库: <span class="hljs-subst">${createdAt}</span>`</span>);

  <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">query</span>(
    <span class="hljs-string">'INSERT INTO user_actions (user_id, action, created_at) VALUES (?, ?, ?)'</span>,
    [user_id, action, createdAt]
  );

  res.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> });
});

<span class="hljs-comment">// 获取用户操作列表</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/actions'</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> { user_id } = req.<span class="hljs-property">query</span>;

  <span class="hljs-keyword">const</span> [rows] = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">query</span>(
    <span class="hljs-string">'SELECT id, action, created_at FROM user_actions WHERE user_id = ? ORDER BY created_at DESC'</span>,
    [user_id]
  );

  <span class="hljs-comment">// 将数据库的 DATETIME(3) 转为前端需要的 13 位时间戳</span>
  <span class="hljs-keyword">const</span> actions = rows.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">row</span> =&gt;</span> ({
    <span class="hljs-attr">id</span>: row.<span class="hljs-property">id</span>,
    <span class="hljs-attr">action</span>: row.<span class="hljs-property">action</span>,
    <span class="hljs-attr">ts</span>: <span class="hljs-title function_">dbToTimestamp</span>(row.<span class="hljs-property">created_at</span>) <span class="hljs-comment">// 转为 13 位时间戳</span>
  }));

  res.<span class="hljs-title function_">json</span>(actions);
});
</code></pre>
<p>"看，"我指着代码说，"你前端传过来 <code>1704723600123</code>，我用 <code>timestampToDb</code> 转成 <code>'2025-01-09 01:00:00.123'</code> 存进数据库。读出来时，用 <code>dbToTimestamp</code> 转回 <code>1704723600123</code> 返回给你。毫秒位的 <code>123</code> 完整保留下来了。"</p>
<h3 data-id="heading-7">4. 前端代码调整</h3>
<p>小汐也快速改了她的代码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 记录用户操作时，直接用 Date.now()</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">logAction</span>(<span class="hljs-params">action</span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/action'</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
    <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">user_id</span>: <span class="hljs-title function_">getCurrentUserId</span>(),
      <span class="hljs-attr">action</span>: action,
      <span class="hljs-attr">ts</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() <span class="hljs-comment">// 13 位毫秒时间戳</span>
    })
  });
}

<span class="hljs-comment">// 获取操作列表并渲染</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderActionTimeline</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/actions?user_id=<span class="hljs-subst">${getCurrentUserId()}</span>`</span>);
  <span class="hljs-keyword">const</span> actions = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();

  <span class="hljs-comment">// 后端返回的 ts 就是 13 位时间戳，直接排序</span>
  actions.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">ts</span> - a.<span class="hljs-property">ts</span>);

  <span class="hljs-comment">// 渲染时显示毫秒</span>
  actions.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(item.<span class="hljs-property">ts</span>);
    <span class="hljs-keyword">const</span> timeStr = date.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">'zh-CN'</span>, {
      <span class="hljs-attr">hour12</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">hour</span>: <span class="hljs-string">'2-digit'</span>,
      <span class="hljs-attr">minute</span>: <span class="hljs-string">'2-digit'</span>,
      <span class="hljs-attr">second</span>: <span class="hljs-string">'2-digit'</span>,
      <span class="hljs-attr">fractionalSecondDigits</span>: <span class="hljs-number">3</span> <span class="hljs-comment">// 显示毫秒</span>
    });

    <span class="hljs-title function_">renderTimelineItem</span>(item.<span class="hljs-property">action</span>, timeStr);
  });
}
</code></pre>
<h2 data-id="heading-8">📊 效果验证</h2>
<p>代码改完，我重启了服务。小汐迫不及待地刷新了页面。</p>
<p>"我来测试一下，"她说着，手指在按钮上快速点了五次，动作连贯得像是在弹钢琴，"这五次应该都在同一秒内。"</p>
<p>几秒后，她的时间轴组件里出现了五条记录：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">01:23:45.891 - 点击按钮</span>
<span class="hljs-section">01:23:45.756 - 点击按钮</span>
<span class="hljs-section">01:23:45.623 - 点击按钮</span>
<span class="hljs-section">01:23:45.489 - 点击按钮</span>
<span class="hljs-section">01:23:45.234 - 点击按钮</span>
</code></pre>
<p>小汐的脸上终于露出了笑容，那种释然的笑，像是终于放下了压在心里的一块石头："你看！毫秒位都不一样，排序完全准确了！"</p>
<p>她快速滚动列表，那些密密麻麻的操作记录按照时间顺序整整齐齐地排列着，不会再像之前那样在同一秒内乱序。</p>
<p>"而且你看控制台，"她打开开发者工具，"你返回给我的直接就是 13 位时间戳：<code>1704723685891</code>、<code>1704723685756</code>……我前端不用做任何额外处理，直接用 <code>new Date(ts)</code> 就能转成本地时间显示。"</p>
<p>阿辰在旁边喝了口茶，淡淡地说："这才是前后端该有的协作方式。"</p>
<h2 data-id="heading-9">💡 经验总结</h2>
<p>这次深夜重构，让我彻底理解了 MySQL 8 时代的时间存储最佳实践。</p>
<h3 data-id="heading-10">核心要点</h3>
<ol>
<li>
<p><strong>MySQL 8 首选 <code>DATETIME(3)</code>，不要再用 <code>TIMESTAMP</code></strong></p>
<ul>
<li><code>DATETIME(3)</code> 的 <code>(3)</code> 代表毫秒精度（小数点后 3 位）</li>
<li>存储空间：6 字节（比 <code>TIMESTAMP</code> 的 4 字节只多 2 字节）</li>
<li>时间范围：1000年 ~ 9999年（而 <code>TIMESTAMP</code> 只到 2038年）</li>
</ul>
</li>
<li>
<p><strong><code>DATETIME(3)</code> 天然匹配前端的 13 位时间戳</strong></p>
<ul>
<li>JavaScript 的 <code>Date.now()</code> 返回 13 位毫秒时间戳（标准）</li>
<li><code>DATETIME(3)</code> 可以完整保存毫秒，精度完全对应</li>
</ul>
</li>
<li>
<p><strong>统一用 UTC，时区问题交给应用层</strong></p>
<ul>
<li>数据库只存 UTC 时间，不要让 MySQL 去处理时区</li>
<li>后端与数据库交互时用 UTC</li>
<li>前端根据用户本地时区显示（浏览器自动处理）</li>
</ul>
</li>
<li>
<p><strong>TIMESTAMP 的三大问题</strong></p>
<ul>
<li><strong>2038年危机</strong>：最大只能存到 <code>2038-01-19 03:14:07</code></li>
<li><strong>精度不足</strong>：只能到秒，无法满足现代应用的毫秒级需求</li>
<li><strong>时区依赖</strong>：受服务器 <code>time_zone</code> 配置影响，迁移易出Bug</li>
</ul>
</li>
</ol>
<h3 data-id="heading-11">常见坑点</h3>
<ul>
<li>
<p>❌ <strong>坑1：前端 13 位时间戳直接存入 TIMESTAMP</strong></p>
<ul>
<li>问题：<code>TIMESTAMP</code> 会自动截断，毫秒丢失</li>
<li>正确做法：用 <code>DATETIME(3)</code> 存储</li>
</ul>
</li>
<li>
<p>❌ <strong>坑2：ORM 驱动的时区配置不正确</strong></p>
<ul>
<li>问题：Sequelize、TypeORM 等会根据本地时区自动转换</li>
<li>正确做法：连接配置中强制 <code>timezone: '+00:00'</code></li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Sequelize 示例</span>
<span class="hljs-keyword">const</span> sequelize = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sequelize</span>({
  <span class="hljs-attr">dialect</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-attr">timezone</span>: <span class="hljs-string">'+00:00'</span> <span class="hljs-comment">// 关键！强制使用 UTC</span>
});
</code></pre>
</li>
<li>
<p>❌ <strong>坑3：老表直接 ALTER 不备份</strong></p>
<ul>
<li>问题：<code>TIMESTAMP</code> 转 <code>DATETIME</code> 可能涉及时区隐式转换</li>
<li>正确做法：先在测试环境验证，生产环境操作前必须备份</li>
</ul>
</li>
<li>
<p>❌ <strong>坑4：后端返回时不转换为 13 位时间戳</strong></p>
<ul>
<li>问题：返回字符串 <code>"2025-01-09 01:00:00.123"</code>，前端还要手动处理</li>
<li>正确做法：统一返回 13 位数字时间戳</li>
</ul>
</li>
</ul>
<h3 data-id="heading-12">技术拓展</h3>
<ul>
<li>如果需要<strong>更高精度</strong>（如日志系统、高频交易），可以用 <code>DATETIME(6)</code> 存储微秒</li>
<li>如果追求<strong>极致性能</strong>，可以直接用 <code>BIGINT</code> 存储 13 位时间戳数字（但牺牲了可读性）</li>
<li>关于时区处理的更多细节，可以研究 <code>CONVERT_TZ()</code> 函数</li>
</ul>
<h2 data-id="heading-13">🌙 温馨收尾</h2>
<p>小汐关上电脑，站起来伸了个懒腰。她走过我身边时，轻轻拍了拍我的肩膀："谢了。"</p>
<p>阿辰也收拾好东西，路过时只说了句："早点休息。"</p>
<p>办公室里又只剩下我一个人了。窗外的雨还在下，但声音变小了很多。我看了看电脑右下角的时间：01:18:47.325。</p>
<p>显示器的光映在键盘上，那些被敲了无数次的按键在光影下显得有些斑驳。我想起三个月前建这张表的时候，也是深夜，也是下雨。那时候我随手选了 <code>TIMESTAMP</code>，觉得够用了。</p>
<p>现在想想，有些"够用"的选择，只是因为问题还没暴露而已。</p>
<hr/>
<p><em>这里是《深夜代码》，我们下期见。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[学习一些常用的混合模式之BlendMode.srcIn]]></title>    <link>https://juejin.cn/post/7592159803410497572</link>    <guid>https://juejin.cn/post/7592159803410497572</guid>    <pubDate>2026-01-07T09:05:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592159803410497572" data-draft-id="7592236397535232036" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 学习一些常用的混合模式之BlendMode.srcIn"/> <meta itemprop="keywords" content="Flutter"/> <meta itemprop="datePublished" content="2026-01-07T09:05:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="火柴就是我"/> <meta itemprop="url" content="https://juejin.cn/user/272334614705575"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             学习一些常用的混合模式之BlendMode.srcIn
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/272334614705575/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    火柴就是我
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:05:38.000Z" title="Wed Jan 07 2026 09:05:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>SRC_IN</p>
<p><code>Keeps the source pixels that cover the destination pixels, discards the remaining source and destination pixels.</code></p>
<p>计算公式</p>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17e9298a9851429883786947bbdce669~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Gr5p-05bCx5piv5oiR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768381538&amp;x-signature=xn2nBRmuIUa%2Bs5CKmuPAknVOF5s%3D" alt="image.png" width="30%" loading="lazy"/>
<p>大白话就是：在dst透明度是1的时候,重叠部分显示的就是src的内容。非重叠部分src 直接全部丢弃,dst不修改。</p>
<p>第一个例子:</p>
<pre><code class="hljs language-js" lang="js">  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span>(<span class="hljs-params">Canvas canvas, Size size</span>) {
    <span class="hljs-keyword">var</span> width = size.<span class="hljs-property">width</span>;
    <span class="hljs-keyword">var</span> height = size.<span class="hljs-property">height</span>;

    canvas.<span class="hljs-title function_">saveLayer</span>(<span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), <span class="hljs-title class_">Paint</span>());
    <span class="hljs-title class_">Paint</span> dstPaint = <span class="hljs-title class_">Paint</span>()..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">red</span>.<span class="hljs-title function_">withOpacity</span>(<span class="hljs-number">0.8</span>);
    dstPaint.<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">20</span>;
    dstPaint.<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span>;

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">10</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">50</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">90</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">130</span>, dstPaint);

    <span class="hljs-keyword">var</span> srcPaint = <span class="hljs-title class_">Paint</span>()
      ..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">blue</span> <span class="hljs-comment">// 源颜色：蓝色</span>
      ..<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span> <span class="hljs-comment">// 填充模式</span>
      ..<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">50</span>
      ..<span class="hljs-property">blendMode</span> = <span class="hljs-title class_">BlendMode</span>.<span class="hljs-property">srcIn</span>; <span class="hljs-comment">// 混合模式</span>
    canvas.<span class="hljs-title function_">drawRect</span>(<span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), srcPaint);
    <span class="hljs-comment">// canvas.drawImageRect(image!, Rect.fromLTWH(0, 0, image!.width.toDouble(), image!.height.toDouble()), Rect.fromLTWH(0, 0, width, height), srcPaint);</span>
    canvas.<span class="hljs-title function_">restore</span>();
  }
</code></pre>
<p>一个矩形边框跟多个环形进行srcIn混合。效果如下：可以看出重叠部分保留了src，src非重叠部分直接丢弃了。非重叠dst还是保持原样。</p>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7d143d89ab94cbcabe98f10daaec269~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Gr5p-05bCx5piv5oiR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768381538&amp;x-signature=qKTcUwalJOkSdlA%2FdpTZnesJpls%3D" alt="image.png" width="30%" loading="lazy"/>
<p>第二个例子:给图形贴纸或者说是图片保留任意部分(只要你能画出路径)</p>
<pre><code class="hljs language-js" lang="js">  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span>(<span class="hljs-params">Canvas canvas, Size size</span>) {
    <span class="hljs-keyword">var</span> width = size.<span class="hljs-property">width</span>;
    <span class="hljs-keyword">var</span> height = size.<span class="hljs-property">height</span>;

    canvas.<span class="hljs-title function_">saveLayer</span>(<span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), <span class="hljs-title class_">Paint</span>());
    <span class="hljs-title class_">Paint</span> dstPaint = <span class="hljs-title class_">Paint</span>()..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">red</span>.<span class="hljs-title function_">withOpacity</span>(<span class="hljs-number">0.8</span>);
    dstPaint.<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">20</span>;
    dstPaint.<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span>;

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">10</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">50</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">90</span>, dstPaint);

    canvas.<span class="hljs-title function_">drawCircle</span>(<span class="hljs-title class_">Offset</span>(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>), <span class="hljs-number">130</span>, dstPaint);

    <span class="hljs-keyword">var</span> srcPaint = <span class="hljs-title class_">Paint</span>()
      ..<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">blue</span> <span class="hljs-comment">// 源颜色：蓝色</span>
      ..<span class="hljs-property">style</span> = <span class="hljs-title class_">PaintingStyle</span>.<span class="hljs-property">stroke</span> <span class="hljs-comment">// 填充模式</span>
      ..<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">50</span>
      ..<span class="hljs-property">blendMode</span> = <span class="hljs-title class_">BlendMode</span>.<span class="hljs-property">srcIn</span>; <span class="hljs-comment">// 混合模式</span>
    <span class="hljs-comment">// canvas.drawRect(Rect.fromLTWH(0, 0, width, height), srcPaint);</span>
    canvas.<span class="hljs-title function_">drawImageRect</span>(image!, <span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, image!.<span class="hljs-property">width</span>.<span class="hljs-title function_">toDouble</span>(), image!.<span class="hljs-property">height</span>.<span class="hljs-title function_">toDouble</span>()), <span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromLTWH</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), srcPaint);
    canvas.<span class="hljs-title function_">restore</span>();
  }
</code></pre>
<p>效果图如下:把一张图片贴到了环形上面，如果dst是个圆形，那就是圆形头像。</p>
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9617663f5dc429f9aa89fd747183c58~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Gr5p-05bCx5piv5oiR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1768381538&amp;x-signature=2oBDA2%2FLZYbYV%2F9vwgCU7elaroQ%3D" alt="image.png" width="30%" loading="lazy"/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React 自定义 Hooks 生存指南：7 个让你少加班的"偷懒"神器]]></title>    <link>https://juejin.cn/post/7592361736130756618</link>    <guid>https://juejin.cn/post/7592361736130756618</guid>    <pubDate>2026-01-07T09:00:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592361736130756618" data-draft-id="7592340733954261042" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React 自定义 Hooks 生存指南：7 个让你少加班的&quot;偷懒&quot;神器"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-01-07T09:00:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员Agions"/> <meta itemprop="url" content="https://juejin.cn/user/360295545187751"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React 自定义 Hooks 生存指南：7 个让你少加班的"偷懒"神器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/360295545187751/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员Agions
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:00:07.000Z" title="Wed Jan 07 2026 09:00:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>摘要</strong>：都 2026 年了，还在写重复代码？还在 useEffect 里疯狂 copy-paste？醒醒，自定义 Hooks 才是现代 React 开发者的"摸鱼"神器。本文手把手教你封装 7 个超实用的自定义 Hooks，从此告别 996，拥抱 WLB。代码即拿即用，CV 工程师狂喜。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">引言：一个关于"偷懒"的故事</h2>
<p><strong>场景一：</strong> 产品经理："这个搜索框要做防抖。" 你："好的。"（打开 Google，搜索 "react debounce"） 产品经理："那个页面也要。" 你："好的。"（再次 copy-paste） 产品经理："还有这 10 个页面..." 你：（开始怀疑人生）</p>
<p><strong>场景二：</strong> 你："这个表单状态管理写得真优雅。" （三个月后） 你："这 TM 是谁写的？！" Git blame："是你自己。" 你：（沉默）</p>
<p><strong>场景三：</strong> Code Review 时—— 同事："这段逻辑我在另外 5 个文件里见过。" 你："那个...我准备重构的..." 同事："你三个月前也是这么说的。" 你：（想找个地缝钻进去）</p>
<p><strong>如果你也有类似经历，恭喜你，这篇文章就是为你准备的。</strong></p>
<p>今天，我要分享 7 个超实用的自定义 Hooks，让你：</p>
<ul>
<li>代码复用率提升 300%</li>
<li>每天少写 200 行重复代码</li>
<li>准时下班不是梦</li>
</ul>
<hr/>
<h2 data-id="heading-1">第一章：自定义 Hooks 的"道"与"术"</h2>
<h3 data-id="heading-2">1.1 什么是自定义 Hook？</h3>
<p>简单说，自定义 Hook 就是一个以 <code>use</code> 开头的函数，里面可以调用其他 Hooks。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 这就是一个最简单的自定义 Hook</span>
function <span class="hljs-built_in">useMyHook</span>() {
  const <span class="hljs-selector-attr">[state, setState]</span> = <span class="hljs-built_in">useState</span>(null)

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    <span class="hljs-comment">// 做一些事情</span>
  }, <span class="hljs-selector-attr">[]</span>)

  return state
}
</code></pre>
<p><strong>为什么要用自定义 Hook？</strong></p>
<ol>
<li><strong>复用逻辑</strong>：同样的逻辑写一次，到处用</li>
<li><strong>关注点分离</strong>：组件只管渲染，逻辑交给 Hook</li>
<li><strong>更好测试</strong>：Hook 可以单独测试</li>
<li><strong>代码更清晰</strong>：组件代码从 500 行变成 50 行</li>
</ol>
<h3 data-id="heading-3">1.2 自定义 Hook 的命名规范</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// ✅ 正确：以 use 开头</span>
<span class="hljs-built_in">useLocalStorage</span>()
<span class="hljs-built_in">useDebounce</span>()
<span class="hljs-built_in">useFetch</span>()

<span class="hljs-comment">// ❌ 错误：不以 use 开头（React 不会识别为 Hook）</span>
<span class="hljs-built_in">getLocalStorage</span>()
<span class="hljs-built_in">debounceValue</span>()
<span class="hljs-built_in">fetchData</span>()
</code></pre>
<p><strong>记住：</strong> 以 <code>use</code> 开头不是装逼，是 React 识别 Hook 的方式。不这么写，React 的 Hooks 规则检查会失效。</p>
<hr/>
<h2 data-id="heading-4">第二章：7 个让你少加班的自定义 Hooks</h2>
<h3 data-id="heading-5">Hook #1：useLocalStorage —— 本地存储の优雅姿势</h3>
<p><strong>痛点：</strong> 每次用 localStorage 都要 JSON.parse、JSON.stringify，还要处理 SSR 报错。</p>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useState, useEffect, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-comment">/**
 * 将状态同步到 localStorage 的 Hook
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">key</span> - localStorage 的键名
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">initialValue</span> - 初始值
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">[any, Function, Function]</span>} [存储的值, 设置函数, 删除函数]
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-params">key, initialValue</span>) {
  <span class="hljs-comment">// 获取初始值（惰性初始化）</span>
  <span class="hljs-keyword">const</span> [storedValue, setStoredValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// SSR 环境下 window 不存在</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">"undefined"</span>) {
      <span class="hljs-keyword">return</span> initialValue
    }

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)
      <span class="hljs-comment">// 如果存在则解析，否则返回初始值</span>
      <span class="hljs-keyword">return</span> item ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(item) : initialValue
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Error reading localStorage key "<span class="hljs-subst">${key}</span>":`</span>, error)
      <span class="hljs-keyword">return</span> initialValue
    }
  })

  <span class="hljs-comment">// 设置值的函数</span>
  <span class="hljs-keyword">const</span> setValue = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 支持函数式更新</span>
        <span class="hljs-keyword">const</span> valueToStore =
          value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span> ? <span class="hljs-title function_">value</span>(storedValue) : value
        <span class="hljs-title function_">setStoredValue</span>(valueToStore)

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">"undefined"</span>) {
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(valueToStore))
        }
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Error setting localStorage key "<span class="hljs-subst">${key}</span>":`</span>, error)
      }
    },
    [key, storedValue]
  )

  <span class="hljs-comment">// 删除值的函数</span>
  <span class="hljs-keyword">const</span> removeValue = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-title function_">setStoredValue</span>(initialValue)
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">"undefined"</span>) {
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key)
      }
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Error removing localStorage key "<span class="hljs-subst">${key}</span>":`</span>, error)
    }
  }, [key, initialValue])

  <span class="hljs-keyword">return</span> [storedValue, setValue, removeValue]
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useLocalStorage
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 就像 useState 一样简单！</span>
  <span class="hljs-keyword">const</span> [theme, setTheme, removeTheme] = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">"theme"</span>, <span class="hljs-string">"light"</span>)
  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">"user"</span>, <span class="hljs-literal">null</span>)

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">app</span> ${<span class="hljs-attr">theme</span>}`}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setTheme(theme === "light" ? "dark" : "light")}&gt;
        切换主题：{theme}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setUser({ name: "张三", age: 25 })}&gt;登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{removeTheme}</span>&gt;</span>重置主题<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

      {user &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>欢迎，{user.name}！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p><strong>为什么这个 Hook 香？</strong></p>
<ul>
<li>自动处理 JSON 序列化/反序列化</li>
<li>支持 SSR（不会报 window is not defined）</li>
<li>支持函数式更新（和 useState 一样）</li>
<li>提供删除功能</li>
</ul>
<hr/>
<h3 data-id="heading-6">Hook #2：useDebounce —— 防抖の终极方案</h3>
<p><strong>痛点：</strong> 搜索框输入时，每敲一个字就发请求，服务器直接被你打爆。</p>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-comment">/**
 * 防抖 Hook：延迟更新值，避免频繁触发
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 需要防抖的值
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">delay</span> - 延迟时间（毫秒）
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">any</span>} 防抖后的值
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useDebounce</span>(<span class="hljs-params">value, delay = <span class="hljs-number">500</span></span>) {
  <span class="hljs-keyword">const</span> [debouncedValue, setDebouncedValue] = <span class="hljs-title function_">useState</span>(value)

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 设置定时器</span>
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setDebouncedValue</span>(value)
    }, delay)

    <span class="hljs-comment">// 清理函数：值变化时清除上一个定时器</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">clearTimeout</span>(timer)
    }
  }, [value, delay])

  <span class="hljs-keyword">return</span> debouncedValue
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useDebounce
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">SearchComponent</span>() {
  const <span class="hljs-selector-attr">[searchTerm, setSearchTerm]</span> = <span class="hljs-built_in">useState</span>("")
  const <span class="hljs-selector-attr">[results, setResults]</span> = <span class="hljs-built_in">useState</span>([])
  const <span class="hljs-selector-attr">[loading, setLoading]</span> = <span class="hljs-built_in">useState</span>(false)

  <span class="hljs-comment">// 防抖处理：用户停止输入 500ms 后才触发</span>
  const debouncedSearchTerm = <span class="hljs-built_in">useDebounce</span>(searchTerm, <span class="hljs-number">500</span>)

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    if (debouncedSearchTerm) {
      <span class="hljs-built_in">setLoading</span>(true)
      <span class="hljs-comment">// 模拟 API 请求</span>
      <span class="hljs-built_in">fetch</span>(`/api/search?q=${debouncedSearchTerm}`)
        <span class="hljs-selector-class">.then</span>((res) =&gt; res<span class="hljs-selector-class">.json</span>())
        <span class="hljs-selector-class">.then</span>((data) =&gt; {
          <span class="hljs-built_in">setResults</span>(data)
          <span class="hljs-built_in">setLoading</span>(false)
        })
    } else {
      <span class="hljs-built_in">setResults</span>([])
    }
  }, <span class="hljs-selector-attr">[debouncedSearchTerm]</span>) <span class="hljs-comment">// 只在防抖值变化时触发</span>

  return (
    &lt;div&gt;
      &lt;input
        type='text'
        placeholder='搜索...'
        value={searchTerm}
        onChange={(e) =&gt; <span class="hljs-built_in">setSearchTerm</span>(e.target.value)}
      /&gt;

      {loading &amp;&amp; &lt;<span class="hljs-selector-tag">p</span>&gt;搜索中...&lt;/<span class="hljs-selector-tag">p</span>&gt;}

      &lt;<span class="hljs-selector-tag">ul</span>&gt;
        {results<span class="hljs-selector-class">.map</span>((item) =&gt; (
          &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
        ))}
      &lt;/<span class="hljs-selector-tag">ul</span>&gt;
    &lt;/<span class="hljs-selector-tag">div</span>&gt;
  )
}
</code></pre>
<p><strong>进阶版：带回调的防抖</strong></p>
<pre><code class="hljs language-scss" lang="scss">import { useCallback, useRef, useEffect } from "react"

<span class="hljs-comment">/**
 * 防抖函数 Hook：返回一个防抖处理后的函数
 * @param {Function} callback - 需要防抖的回调函数
 * @param {number} delay - 延迟时间（毫秒）
 * @returns {Function} 防抖后的函数
 */</span>
function <span class="hljs-built_in">useDebouncedCallback</span>(callback, delay = <span class="hljs-number">500</span>) {
  const timeoutRef = <span class="hljs-built_in">useRef</span>(null)
  const callbackRef = <span class="hljs-built_in">useRef</span>(callback)

  <span class="hljs-comment">// 保持 callback 最新</span>
  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    callbackRef<span class="hljs-selector-class">.current</span> = callback
  }, <span class="hljs-selector-attr">[callback]</span>)

  <span class="hljs-comment">// 清理定时器</span>
  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    return () =&gt; {
      if (timeoutRef.current) {
        <span class="hljs-built_in">clearTimeout</span>(timeoutRef.current)
      }
    }
  }, <span class="hljs-selector-attr">[]</span>)

  const debouncedCallback = <span class="hljs-built_in">useCallback</span>(
    (...args) =&gt; {
      if (timeoutRef.current) {
        <span class="hljs-built_in">clearTimeout</span>(timeoutRef.current)
      }

      timeoutRef<span class="hljs-selector-class">.current</span> = <span class="hljs-built_in">setTimeout</span>(() =&gt; {
        callbackRef<span class="hljs-selector-class">.current</span>(...args)
      }, delay)
    },
    <span class="hljs-selector-attr">[delay]</span>
  )

  return debouncedCallback
}

<span class="hljs-comment">// 使用示例</span>
function <span class="hljs-built_in">SearchWithCallback</span>() {
  const <span class="hljs-selector-attr">[results, setResults]</span> = <span class="hljs-built_in">useState</span>([])

  const handleSearch = <span class="hljs-built_in">useDebouncedCallback</span>((term) =&gt; {
    console<span class="hljs-selector-class">.log</span>("搜索:", term)
    <span class="hljs-comment">// 发起请求...</span>
  }, <span class="hljs-number">500</span>)

  return (
    &lt;input
      type='text'
      onChange={(e) =&gt; <span class="hljs-built_in">handleSearch</span>(e.target.value)}
      placeholder='输入搜索...'
    /&gt;
  )
}
</code></pre>
<hr/>
<h3 data-id="heading-7">Hook #3：useFetch —— 数据请求の瑞士军刀</h3>
<p><strong>痛点：</strong> 每个组件都要写 loading、error、data 三件套，烦死了。</p>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-scss" lang="scss">import { useState, useEffect, useCallback, useRef } from "react"

<span class="hljs-comment">/**
 * 数据请求 Hook
 * @param {string} url - 请求地址
 * @param {object} options - fetch 选项
 * @returns {object} { data, loading, error, refetch }
 */</span>
function <span class="hljs-built_in">useFetch</span>(url, options = {}) {
  const <span class="hljs-selector-attr">[data, setData]</span> = <span class="hljs-built_in">useState</span>(null)
  const <span class="hljs-selector-attr">[loading, setLoading]</span> = <span class="hljs-built_in">useState</span>(true)
  const <span class="hljs-selector-attr">[error, setError]</span> = <span class="hljs-built_in">useState</span>(null)

  <span class="hljs-comment">// 用 ref 存储 options，避免无限循环</span>
  const optionsRef = <span class="hljs-built_in">useRef</span>(options)
  optionsRef<span class="hljs-selector-class">.current</span> = options

  const fetchData = <span class="hljs-built_in">useCallback</span>(async () =&gt; {
    <span class="hljs-built_in">setLoading</span>(true)
    <span class="hljs-built_in">setError</span>(null)

    try {
      const response = await <span class="hljs-built_in">fetch</span>(url, optionsRef.current)

      if (!response.ok) {
        throw new <span class="hljs-built_in">Error</span>(`HTTP error! status: ${response.status}`)
      }

      const result = await response<span class="hljs-selector-class">.json</span>()
      <span class="hljs-built_in">setData</span>(result)
    } catch (err) {
      <span class="hljs-built_in">setError</span>(err.message || "请求失败")
    } finally {
      <span class="hljs-built_in">setLoading</span>(false)
    }
  }, <span class="hljs-selector-attr">[url]</span>)

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    <span class="hljs-built_in">fetchData</span>()
  }, <span class="hljs-selector-attr">[fetchData]</span>)

  <span class="hljs-comment">// 手动重新请求</span>
  const refetch = <span class="hljs-built_in">useCallback</span>(() =&gt; {
    <span class="hljs-built_in">fetchData</span>()
  }, <span class="hljs-selector-attr">[fetchData]</span>)

  return { data, loading, error, refetch }
}

export default useFetch
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ userId }</span>) {
  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">data</span>: user,
    loading,
    error,
    refetch,
  } = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">`https://jsonplaceholder.typicode.com/users/<span class="hljs-subst">${userId}</span>`</span>)

  <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'skeleton'</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'error'</span>&gt;</span>错误：{error}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  <span class="hljs-keyword">if</span> (!user) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'user-profile'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>📧 {user.email}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>📱 {user.phone}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>🏢 {user.company?.name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{refetch}</span>&gt;</span>刷新数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p><strong>进阶版：支持缓存和自动重试</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useState, useEffect, useCallback, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-comment">// 简单的内存缓存</span>
<span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()

<span class="hljs-comment">/**
 * 增强版数据请求 Hook
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">url</span> - 请求地址
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} <span class="hljs-variable">config</span> - 配置项
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useFetchAdvanced</span>(<span class="hljs-params">url, config = {}</span>) {
  <span class="hljs-keyword">const</span> {
    enabled = <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否启用请求</span>
    cacheTime = <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 缓存时间（默认 5 分钟）</span>
    retry = <span class="hljs-number">3</span>, <span class="hljs-comment">// 重试次数</span>
    retryDelay = <span class="hljs-number">1000</span>, <span class="hljs-comment">// 重试延迟</span>
    onSuccess, <span class="hljs-comment">// 成功回调</span>
    onError, <span class="hljs-comment">// 失败回调</span>
  } = config

  <span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>({
    <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">loading</span>: enabled,
    <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,
  })

  <span class="hljs-keyword">const</span> retryCountRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-number">0</span>)

  <span class="hljs-keyword">const</span> fetchData = <span class="hljs-title function_">useCallback</span>(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// 检查缓存</span>
    <span class="hljs-keyword">const</span> cached = cache.<span class="hljs-title function_">get</span>(url)
    <span class="hljs-keyword">if</span> (cached &amp;&amp; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - cached.<span class="hljs-property">timestamp</span> &lt; cacheTime) {
      <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">data</span>: cached.<span class="hljs-property">data</span>, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> })
      <span class="hljs-keyword">return</span>
    }

    <span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> ({ ...prev, <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> }))

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url)

      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${response.status}</span>`</span>)
      }

      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>()

      <span class="hljs-comment">// 存入缓存</span>
      cache.<span class="hljs-title function_">set</span>(url, { data, <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() })

      <span class="hljs-title function_">setState</span>({ data, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span> })
      retryCountRef.<span class="hljs-property">current</span> = <span class="hljs-number">0</span>
      onSuccess?.(data)
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-comment">// 重试逻辑</span>
      <span class="hljs-keyword">if</span> (retryCountRef.<span class="hljs-property">current</span> &lt; retry) {
        retryCountRef.<span class="hljs-property">current</span>++
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
          <span class="hljs-string">`请求失败，<span class="hljs-subst">${retryDelay}</span>ms 后重试 (<span class="hljs-subst">${retryCountRef.current}</span>/<span class="hljs-subst">${retry}</span>)`</span>
        )
        <span class="hljs-built_in">setTimeout</span>(fetchData, retryDelay)
        <span class="hljs-keyword">return</span>
      }

      <span class="hljs-title function_">setState</span>({ <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: err.<span class="hljs-property">message</span> })
      onError?.(err)
    }
  }, [url, cacheTime, retry, retryDelay, onSuccess, onError])

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (enabled) {
      <span class="hljs-title function_">fetchData</span>()
    }
  }, [enabled, fetchData])

  <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">refetch</span>: fetchData }
}
</code></pre>
<hr/>
<h3 data-id="heading-8">Hook #4：useToggle —— 布尔值の优雅切换</h3>
<p><strong>痛点：</strong> <code>setIsOpen(!isOpen)</code> 写了 100 遍，手都酸了。</p>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-scss" lang="scss">import { useState, useCallback } from "react"

<span class="hljs-comment">/**
 * 布尔值切换 Hook
 * @param {boolean} initialValue - 初始值
 * @returns {[boolean, Function, Function, Function]} [值, 切换, 设为true, 设为false]
 */</span>
function <span class="hljs-built_in">useToggle</span>(initialValue = false) {
  const <span class="hljs-selector-attr">[value, setValue]</span> = <span class="hljs-built_in">useState</span>(initialValue)

  const toggle = <span class="hljs-built_in">useCallback</span>(() =&gt; <span class="hljs-built_in">setValue</span>((v) =&gt; !v), <span class="hljs-selector-attr">[]</span>)
  const setTrue = <span class="hljs-built_in">useCallback</span>(() =&gt; <span class="hljs-built_in">setValue</span>(true), <span class="hljs-selector-attr">[]</span>)
  const setFalse = <span class="hljs-built_in">useCallback</span>(() =&gt; <span class="hljs-built_in">setValue</span>(false), <span class="hljs-selector-attr">[]</span>)

  return <span class="hljs-selector-attr">[value, toggle, setTrue, setFalse]</span>
}

export default useToggle
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Modal</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [isOpen, toggle, open, close] = <span class="hljs-title function_">useToggle</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> [isDarkMode, toggleDarkMode] = <span class="hljs-title function_">useToggle</span>(<span class="hljs-literal">false</span>)

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{isDarkMode</span> ? "<span class="hljs-attr">dark</span>" <span class="hljs-attr">:</span> "<span class="hljs-attr">light</span>"}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{toggleDarkMode}</span>&gt;</span>
        {isDarkMode ? "🌙" : "☀️"} 切换主题
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{open}</span>&gt;</span>打开弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

      {isOpen &amp;&amp; (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'modal-overlay'</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{close}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'modal'</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(e)</span> =&gt;</span> e.stopPropagation()}&gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>点击遮罩层或按钮关闭<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{close}</span>&gt;</span>关闭<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<hr/>
<h3 data-id="heading-9">Hook #5：useClickOutside —— 点击外部关闭の神器</h3>
<p><strong>痛点：</strong> 下拉菜单、弹窗点击外部关闭，每次都要写一堆事件监听。</p>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-comment">/**
 * 点击元素外部时触发回调
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">callback</span> - 点击外部时的回调函数
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">React.RefObject</span>} 需要绑定到目标元素的 ref
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useClickOutside</span>(<span class="hljs-params">callback</span>) {
  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">event</span>) =&gt; {
      <span class="hljs-comment">// 如果点击的不是 ref 元素内部，则触发回调</span>
      <span class="hljs-keyword">if</span> (ref.<span class="hljs-property">current</span> &amp;&amp; !ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">contains</span>(event.<span class="hljs-property">target</span>)) {
        <span class="hljs-title function_">callback</span>(event)
      }
    }

    <span class="hljs-comment">// 使用 mousedown 而不是 click，响应更快</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"mousedown"</span>, handleClick)
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"touchstart"</span>, handleClick)

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">"mousedown"</span>, handleClick)
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">"touchstart"</span>, handleClick)
    }
  }, [callback])

  <span class="hljs-keyword">return</span> ref
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useClickOutside
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dropdown</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)

  <span class="hljs-comment">// 点击下拉菜单外部时关闭</span>
  <span class="hljs-keyword">const</span> dropdownRef = <span class="hljs-title function_">useClickOutside</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-literal">false</span>)
  })

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'dropdown-container'</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{dropdownRef}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setIsOpen(!isOpen)}&gt;
        选择选项 {isOpen ? "▲" : "▼"}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

      {isOpen &amp;&amp; (
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'dropdown-menu'</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setIsOpen(false)}&gt;选项 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setIsOpen(false)}&gt;选项 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setIsOpen(false)}&gt;选项 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p><strong>进阶：支持多个 ref</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useEffect, useRef, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-comment">/**
 * 支持多个元素的点击外部检测
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">callback</span> - 点击外部时的回调
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Function</span>} 返回一个函数，调用它获取 ref
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useClickOutsideMultiple</span>(<span class="hljs-params">callback</span>) {
  <span class="hljs-keyword">const</span> refs = <span class="hljs-title function_">useRef</span>([])

  <span class="hljs-keyword">const</span> addRef = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (element &amp;&amp; !refs.<span class="hljs-property">current</span>.<span class="hljs-title function_">includes</span>(element)) {
      refs.<span class="hljs-property">current</span>.<span class="hljs-title function_">push</span>(element)
    }
  }, [])

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">event</span>) =&gt; {
      <span class="hljs-keyword">const</span> isOutside = refs.<span class="hljs-property">current</span>.<span class="hljs-title function_">every</span>(
        <span class="hljs-function">(<span class="hljs-params">ref</span>) =&gt;</span> ref &amp;&amp; !ref.<span class="hljs-title function_">contains</span>(event.<span class="hljs-property">target</span>)
      )

      <span class="hljs-keyword">if</span> (isOutside) {
        <span class="hljs-title function_">callback</span>(event)
      }
    }

    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"mousedown"</span>, handleClick)
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">"mousedown"</span>, handleClick)
  }, [callback])

  <span class="hljs-keyword">return</span> addRef
}

<span class="hljs-comment">// 使用示例：弹窗 + 触发按钮都不算"外部"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">PopoverWithTrigger</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> addRef = <span class="hljs-title function_">useClickOutsideMultiple</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-literal">false</span>))

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{addRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setIsOpen(!isOpen)}&gt;
        触发按钮
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

      {isOpen &amp;&amp; (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{addRef}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'popover'</span>&gt;</span>
          点击这里不会关闭
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}
</code></pre>
<hr/>
<h3 data-id="heading-10">Hook #6：usePrevious —— 获取上一次的值</h3>
<p><strong>痛点：</strong> 想对比新旧值做一些操作，但 React 不给你上一次的值。</p>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useRef, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-comment">/**
 * 获取上一次渲染时的值
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">any</span>} <span class="hljs-variable">value</span> - 当前值
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">any</span>} 上一次的值
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">usePrevious</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>()

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    ref.<span class="hljs-property">current</span> = value
  }, [value])

  <span class="hljs-comment">// 返回上一次的值（在 useEffect 更新之前）</span>
  <span class="hljs-keyword">return</span> ref.<span class="hljs-property">current</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> usePrevious
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
  <span class="hljs-keyword">const</span> prevCount = <span class="hljs-title function_">usePrevious</span>(count)

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前值：{count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上一次：{prevCount ?? "无"}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        变化趋势：
        {prevCount !== undefined &amp;&amp;
          (count &gt; prevCount
            ? "📈 上升"
            : count &lt; prevCount
            ? "📉 下降"
            : "➡️ 不变")}
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount((c) =&gt; c + 1)}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount((c) =&gt; c - 1)}&gt;-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p><strong>实际应用：检测 props 变化</strong></p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">UserProfile</span>({ userId }) {
  const prevUserId = <span class="hljs-built_in">usePrevious</span>(userId)
  const <span class="hljs-selector-attr">[user, setUser]</span> = <span class="hljs-built_in">useState</span>(null)

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    <span class="hljs-comment">// 只有当 userId 真正变化时才重新请求</span>
    if (userId !== prevUserId) {
      console<span class="hljs-selector-class">.log</span>(`用户 ID 从 ${prevUserId} 变为 ${userId}`)
      <span class="hljs-built_in">fetchUser</span>(userId)<span class="hljs-selector-class">.then</span>(setUser)
    }
  }, <span class="hljs-selector-attr">[userId, prevUserId]</span>)

  return &lt;<span class="hljs-selector-tag">div</span>&gt;{user?<span class="hljs-selector-class">.name</span>}&lt;/<span class="hljs-selector-tag">div</span>&gt;
}
</code></pre>
<hr/>
<h3 data-id="heading-11">Hook #7：useMediaQuery —— 响应式の优雅方案</h3>
<p><strong>痛点：</strong> CSS 媒体查询很方便，但 JS 里想根据屏幕尺寸做逻辑判断就麻烦了。</p>
<p><strong>解决方案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-comment">/**
 * 媒体查询 Hook
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">query</span> - CSS 媒体查询字符串
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} 是否匹配
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-params">query</span>) {
  <span class="hljs-keyword">const</span> [matches, setMatches] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// SSR 环境下返回 false</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">"undefined"</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">matchMedia</span>(query).<span class="hljs-property">matches</span>
  })

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">"undefined"</span>) <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">const</span> mediaQuery = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">matchMedia</span>(query)

    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-title function_">setMatches</span>(mediaQuery.<span class="hljs-property">matches</span>)

    <span class="hljs-comment">// 监听变化</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params">event</span>) =&gt; <span class="hljs-title function_">setMatches</span>(event.<span class="hljs-property">matches</span>)

    <span class="hljs-comment">// 现代浏览器用 addEventListener</span>
    <span class="hljs-keyword">if</span> (mediaQuery.<span class="hljs-property">addEventListener</span>) {
      mediaQuery.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"change"</span>, handler)
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> mediaQuery.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">"change"</span>, handler)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 兼容旧浏览器</span>
      mediaQuery.<span class="hljs-title function_">addListener</span>(handler)
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> mediaQuery.<span class="hljs-title function_">removeListener</span>(handler)
    }
  }, [query])

  <span class="hljs-keyword">return</span> matches
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useMediaQuery
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ResponsiveComponent</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> isMobile = <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-string">"(max-width: 768px)"</span>)
  <span class="hljs-keyword">const</span> isTablet = <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-string">"(min-width: 769px) and (max-width: 1024px)"</span>)
  <span class="hljs-keyword">const</span> isDesktop = <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-string">"(min-width: 1025px)"</span>)
  <span class="hljs-keyword">const</span> prefersDark = <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-string">"(prefers-color-scheme: dark)"</span>)

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{prefersDark</span> ? "<span class="hljs-attr">dark-theme</span>" <span class="hljs-attr">:</span> "<span class="hljs-attr">light-theme</span>"}&gt;</span>
      {isMobile &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">MobileNav</span> /&gt;</span>}
      {isTablet &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">TabletNav</span> /&gt;</span>}
      {isDesktop &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">DesktopNav</span> /&gt;</span>}

      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
          当前设备：{isMobile ? "📱 手机" : isTablet ? "📱 平板" : "💻 桌面"}
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>主题偏好：{prefersDark ? "🌙 深色" : "☀️ 浅色"}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p><strong>封装常用断点：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// hooks/useBreakpoint.js</span>
<span class="hljs-keyword">import</span> useMediaQuery <span class="hljs-keyword">from</span> <span class="hljs-string">"./useMediaQuery"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useBreakpoint</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> breakpoints = {
    <span class="hljs-attr">xs</span>: <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-string">"(max-width: 575px)"</span>),
    <span class="hljs-attr">sm</span>: <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-string">"(min-width: 576px) and (max-width: 767px)"</span>),
    <span class="hljs-attr">md</span>: <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-string">"(min-width: 768px) and (max-width: 991px)"</span>),
    <span class="hljs-attr">lg</span>: <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-string">"(min-width: 992px) and (max-width: 1199px)"</span>),
    <span class="hljs-attr">xl</span>: <span class="hljs-title function_">useMediaQuery</span>(<span class="hljs-string">"(min-width: 1200px)"</span>),
  }

  <span class="hljs-comment">// 返回当前断点名称</span>
  <span class="hljs-keyword">const</span> current =
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(breakpoints).<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">[, matches]</span>) =&gt;</span> matches)?.[<span class="hljs-number">0</span>] || <span class="hljs-string">"xs"</span>

  <span class="hljs-keyword">return</span> {
    ...breakpoints,
    current,
    <span class="hljs-attr">isMobile</span>: breakpoints.<span class="hljs-property">xs</span> || breakpoints.<span class="hljs-property">sm</span>,
    <span class="hljs-attr">isTablet</span>: breakpoints.<span class="hljs-property">md</span>,
    <span class="hljs-attr">isDesktop</span>: breakpoints.<span class="hljs-property">lg</span> || breakpoints.<span class="hljs-property">xl</span>,
  }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { isMobile, isDesktop, current } = <span class="hljs-title function_">useBreakpoint</span>()

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前断点：{current}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      {isMobile ? <span class="hljs-tag">&lt;<span class="hljs-name">MobileLayout</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">DesktopLayout</span> /&gt;</span>}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<hr/>
<h2 data-id="heading-12">第三章：Hooks 组合の艺术</h2>
<h3 data-id="heading-13">3.1 组合多个 Hooks 解决复杂问题</h3>
<p><strong>场景：</strong> 一个带搜索、分页、缓存的列表组件</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { useState, useEffect, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

<span class="hljs-comment">// 组合使用多个自定义 Hooks</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useSearchableList</span>(<span class="hljs-params">fetchFn, options = {}</span>) {
  <span class="hljs-keyword">const</span> { pageSize = <span class="hljs-number">10</span>, debounceMs = <span class="hljs-number">300</span> } = options

  <span class="hljs-comment">// 搜索关键词</span>
  <span class="hljs-keyword">const</span> [searchTerm, setSearchTerm] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">""</span>)
  <span class="hljs-keyword">const</span> debouncedSearch = <span class="hljs-title function_">useDebounce</span>(searchTerm, debounceMs)

  <span class="hljs-comment">// 分页</span>
  <span class="hljs-keyword">const</span> [page, setPage] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>)

  <span class="hljs-comment">// 数据请求</span>
  <span class="hljs-keyword">const</span> { data, loading, error, refetch } = <span class="hljs-title function_">useFetch</span>(
    <span class="hljs-string">`<span class="hljs-subst">${fetchFn}</span>?search=<span class="hljs-subst">${debouncedSearch}</span>&amp;page=<span class="hljs-subst">${page}</span>&amp;pageSize=<span class="hljs-subst">${pageSize}</span>`</span>
  )

  <span class="hljs-comment">// 搜索时重置页码</span>
  <span class="hljs-keyword">const</span> prevSearch = <span class="hljs-title function_">usePrevious</span>(debouncedSearch)
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (prevSearch !== <span class="hljs-literal">undefined</span> &amp;&amp; prevSearch !== debouncedSearch) {
      <span class="hljs-title function_">setPage</span>(<span class="hljs-number">1</span>)
    }
  }, [debouncedSearch, prevSearch])

  <span class="hljs-comment">// 计算总页数</span>
  <span class="hljs-keyword">const</span> totalPages = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> data?.<span class="hljs-property">total</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(data.<span class="hljs-property">total</span> / pageSize) : <span class="hljs-number">0</span>
  }, [data?.<span class="hljs-property">total</span>, pageSize])

  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// 数据</span>
    <span class="hljs-attr">items</span>: data?.<span class="hljs-property">items</span> || [],
    <span class="hljs-attr">total</span>: data?.<span class="hljs-property">total</span> || <span class="hljs-number">0</span>,
    loading,
    error,

    <span class="hljs-comment">// 搜索</span>
    searchTerm,
    setSearchTerm,

    <span class="hljs-comment">// 分页</span>
    page,
    setPage,
    totalPages,
    <span class="hljs-attr">hasNextPage</span>: page &lt; totalPages,
    <span class="hljs-attr">hasPrevPage</span>: page &gt; <span class="hljs-number">1</span>,

    <span class="hljs-comment">// 操作</span>
    refetch,
    <span class="hljs-attr">nextPage</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setPage</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(p + <span class="hljs-number">1</span>, totalPages)),
    <span class="hljs-attr">prevPage</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setPage</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(p - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)),
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserList</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> {
    items,
    loading,
    error,
    searchTerm,
    setSearchTerm,
    page,
    totalPages,
    hasNextPage,
    hasPrevPage,
    nextPage,
    prevPage,
  } = <span class="hljs-title function_">useSearchableList</span>(<span class="hljs-string">"/api/users"</span>, { <span class="hljs-attr">pageSize</span>: <span class="hljs-number">20</span> })

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'user-list'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">'text'</span>
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">'搜索用户...'</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">{searchTerm}</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setSearchTerm(e.target.value)}
      /&gt;

      {loading &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'loading'</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
      {error &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'error'</span>&gt;</span>{error}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}

      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {items.map((user) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span>&gt;</span>
            {user.name} - {user.email}
          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'pagination'</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{prevPage}</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">{!hasPrevPage}</span>&gt;</span>
          上一页
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>
          {page} / {totalPages}
        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{nextPage}</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">{!hasNextPage}</span>&gt;</span>
          下一页
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<h3 data-id="heading-14">3.2 创建 Hook 工厂</h3>
<p><strong>场景：</strong> 多个表单都需要类似的验证逻辑</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 表单验证 Hook 工厂
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} <span class="hljs-variable">validationRules</span> - 验证规则
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Function</span>} 返回一个自定义 Hook
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createFormValidation</span>(<span class="hljs-params">validationRules</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useFormValidation</span>(<span class="hljs-params">initialValues = {}</span>) {
    <span class="hljs-keyword">const</span> [values, setValues] = <span class="hljs-title function_">useState</span>(initialValues)
    <span class="hljs-keyword">const</span> [errors, setErrors] = <span class="hljs-title function_">useState</span>({})
    <span class="hljs-keyword">const</span> [touched, setTouched] = <span class="hljs-title function_">useState</span>({})

    <span class="hljs-comment">// 验证单个字段</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">validateField</span> = (<span class="hljs-params">name, value</span>) =&gt; {
      <span class="hljs-keyword">const</span> rules = validationRules[name]
      <span class="hljs-keyword">if</span> (!rules) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> rule <span class="hljs-keyword">of</span> rules) {
        <span class="hljs-keyword">if</span> (rule.<span class="hljs-property">required</span> &amp;&amp; !value) {
          <span class="hljs-keyword">return</span> rule.<span class="hljs-property">message</span> || <span class="hljs-string">"此字段必填"</span>
        }
        <span class="hljs-keyword">if</span> (rule.<span class="hljs-property">minLength</span> &amp;&amp; value.<span class="hljs-property">length</span> &lt; rule.<span class="hljs-property">minLength</span>) {
          <span class="hljs-keyword">return</span> rule.<span class="hljs-property">message</span> || <span class="hljs-string">`最少 <span class="hljs-subst">${rule.minLength}</span> 个字符`</span>
        }
        <span class="hljs-keyword">if</span> (rule.<span class="hljs-property">maxLength</span> &amp;&amp; value.<span class="hljs-property">length</span> &gt; rule.<span class="hljs-property">maxLength</span>) {
          <span class="hljs-keyword">return</span> rule.<span class="hljs-property">message</span> || <span class="hljs-string">`最多 <span class="hljs-subst">${rule.maxLength}</span> 个字符`</span>
        }
        <span class="hljs-keyword">if</span> (rule.<span class="hljs-property">pattern</span> &amp;&amp; !rule.<span class="hljs-property">pattern</span>.<span class="hljs-title function_">test</span>(value)) {
          <span class="hljs-keyword">return</span> rule.<span class="hljs-property">message</span> || <span class="hljs-string">"格式不正确"</span>
        }
        <span class="hljs-keyword">if</span> (rule.<span class="hljs-property">validate</span> &amp;&amp; !rule.<span class="hljs-title function_">validate</span>(value, values)) {
          <span class="hljs-keyword">return</span> rule.<span class="hljs-property">message</span> || <span class="hljs-string">"验证失败"</span>
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>
    }

    <span class="hljs-comment">// 验证所有字段</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">validateAll</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">const</span> newErrors = {}
      <span class="hljs-keyword">let</span> isValid = <span class="hljs-literal">true</span>

      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(validationRules).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">validateField</span>(name, values[name] || <span class="hljs-string">""</span>)
        <span class="hljs-keyword">if</span> (error) {
          newErrors[name] = error
          isValid = <span class="hljs-literal">false</span>
        }
      })

      <span class="hljs-title function_">setErrors</span>(newErrors)
      <span class="hljs-keyword">return</span> isValid
    }

    <span class="hljs-comment">// 处理输入变化</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">name</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> value = e.<span class="hljs-property">target</span> ? e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span> : e
      <span class="hljs-title function_">setValues</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> ({ ...prev, [name]: value }))

      <span class="hljs-comment">// 实时验证已触碰的字段</span>
      <span class="hljs-keyword">if</span> (touched[name]) {
        <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">validateField</span>(name, value)
        <span class="hljs-title function_">setErrors</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> ({ ...prev, [name]: error }))
      }
    }

    <span class="hljs-comment">// 处理失焦</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleBlur</span> = (<span class="hljs-params">name</span>) =&gt; <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setTouched</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> ({ ...prev, [name]: <span class="hljs-literal">true</span> }))
      <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">validateField</span>(name, values[name] || <span class="hljs-string">""</span>)
      <span class="hljs-title function_">setErrors</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> ({ ...prev, [name]: error }))
    }

    <span class="hljs-comment">// 重置表单</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reset</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-title function_">setValues</span>(initialValues)
      <span class="hljs-title function_">setErrors</span>({})
      <span class="hljs-title function_">setTouched</span>({})
    }

    <span class="hljs-keyword">return</span> {
      values,
      errors,
      touched,
      handleChange,
      handleBlur,
      validateAll,
      reset,
      <span class="hljs-attr">isValid</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(errors).<span class="hljs-property">length</span> === <span class="hljs-number">0</span>,
      <span class="hljs-attr">getFieldProps</span>: <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> ({
        <span class="hljs-attr">value</span>: values[name] || <span class="hljs-string">""</span>,
        <span class="hljs-attr">onChange</span>: <span class="hljs-title function_">handleChange</span>(name),
        <span class="hljs-attr">onBlur</span>: <span class="hljs-title function_">handleBlur</span>(name),
      }),
    }
  }
}

<span class="hljs-comment">// 创建登录表单验证 Hook</span>
<span class="hljs-keyword">const</span> useLoginForm = <span class="hljs-title function_">createFormValidation</span>({
  <span class="hljs-attr">email</span>: [
    { <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"请输入邮箱"</span> },
    { <span class="hljs-attr">pattern</span>: <span class="hljs-regexp">/^[^\s@]+@[^\s@]+.[^\s@]+$/</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"邮箱格式不正确"</span> },
  ],
  <span class="hljs-attr">password</span>: [
    { <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"请输入密码"</span> },
    { <span class="hljs-attr">minLength</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"密码至少 6 位"</span> },
  ],
})

<span class="hljs-comment">// 创建注册表单验证 Hook</span>
<span class="hljs-keyword">const</span> useRegisterForm = <span class="hljs-title function_">createFormValidation</span>({
  <span class="hljs-attr">username</span>: [
    { <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"请输入用户名"</span> },
    { <span class="hljs-attr">minLength</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"用户名至少 3 个字符"</span> },
    { <span class="hljs-attr">maxLength</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"用户名最多 20 个字符"</span> },
  ],
  <span class="hljs-attr">email</span>: [
    { <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"请输入邮箱"</span> },
    { <span class="hljs-attr">pattern</span>: <span class="hljs-regexp">/^[^\s@]+@[^\s@]+.[^\s@]+$/</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"邮箱格式不正确"</span> },
  ],
  <span class="hljs-attr">password</span>: [
    { <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"请输入密码"</span> },
    { <span class="hljs-attr">minLength</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"密码至少 8 位"</span> },
    {
      <span class="hljs-attr">pattern</span>: <span class="hljs-regexp">/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">"需包含大小写字母和数字"</span>,
    },
  ],
  <span class="hljs-attr">confirmPassword</span>: [
    { <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"请确认密码"</span> },
    {
      <span class="hljs-attr">validate</span>: <span class="hljs-function">(<span class="hljs-params">value, values</span>) =&gt;</span> value === values.<span class="hljs-property">password</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">"两次密码不一致"</span>,
    },
  ],
})

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">LoginForm</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { values, errors, touched, getFieldProps, validateAll } = <span class="hljs-title function_">useLoginForm</span>()

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; {
    e.<span class="hljs-title function_">preventDefault</span>()
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">validateAll</span>()) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"提交:"</span>, values)
      <span class="hljs-comment">// 发起登录请求...</span>
    }
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'form-group'</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">'email'</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">'邮箱'</span> {<span class="hljs-attr">...getFieldProps</span>("<span class="hljs-attr">email</span>")} /&gt;</span>
        {touched.email &amp;&amp; errors.email &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'error'</span>&gt;</span>{errors.email}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        )}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'form-group'</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
          <span class="hljs-attr">type</span>=<span class="hljs-string">'password'</span>
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">'密码'</span>
          {<span class="hljs-attr">...getFieldProps</span>("<span class="hljs-attr">password</span>")}
        /&gt;</span>
        {touched.password &amp;&amp; errors.password &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'error'</span>&gt;</span>{errors.password}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        )}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">'submit'</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
  )
}
</code></pre>
<hr/>
<h2 data-id="heading-15">第四章：避坑指南</h2>
<h3 data-id="heading-16">4.1 常见错误 #1：在条件语句中调用 Hook</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误：条件调用 Hook</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">BadComponent</span>(<span class="hljs-params">{ shouldFetch }</span>) {
  <span class="hljs-keyword">if</span> (shouldFetch) {
    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">"/api/data"</span>) <span class="hljs-comment">// 💥 报错！</span>
  }
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
}

<span class="hljs-comment">// ✅ 正确：Hook 始终调用，用参数控制行为</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">GoodComponent</span>(<span class="hljs-params">{ shouldFetch }</span>) {
  <span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">"/api/data"</span>, { <span class="hljs-attr">enabled</span>: shouldFetch })
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
}
</code></pre>
<h3 data-id="heading-17">4.2 常见错误 #2：忘记依赖项</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// ❌ 错误：缺少依赖项，callback 永远是旧的</span>
function <span class="hljs-built_in">BadHook</span>(callback) {
  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    window<span class="hljs-selector-class">.addEventListener</span>("resize", callback)
    return () =&gt; window<span class="hljs-selector-class">.removeEventListener</span>("resize", callback)
  }, <span class="hljs-selector-attr">[]</span>) <span class="hljs-comment">// callback 变了也不会更新！</span>
}

<span class="hljs-comment">// ✅ 正确：使用 ref 保持最新引用</span>
function <span class="hljs-built_in">GoodHook</span>(callback) {
  const callbackRef = <span class="hljs-built_in">useRef</span>(callback)

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    callbackRef<span class="hljs-selector-class">.current</span> = callback
  }, <span class="hljs-selector-attr">[callback]</span>)

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    const handler = (...args) =&gt; callbackRef<span class="hljs-selector-class">.current</span>(...args)
    window<span class="hljs-selector-class">.addEventListener</span>("resize", handler)
    return () =&gt; window<span class="hljs-selector-class">.removeEventListener</span>("resize", handler)
  }, <span class="hljs-selector-attr">[]</span>)
}
</code></pre>
<h3 data-id="heading-18">4.3 常见错误 #3：闭包陷阱</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// ❌ 错误：count 永远是 0</span>
function <span class="hljs-built_in">BadCounter</span>() {
  const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>)

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    const timer = <span class="hljs-built_in">setInterval</span>(() =&gt; {
      console<span class="hljs-selector-class">.log</span>(count) <span class="hljs-comment">// 永远打印 0</span>
      <span class="hljs-built_in">setCount</span>(count + <span class="hljs-number">1</span>) <span class="hljs-comment">// 永远设置为 1</span>
    }, <span class="hljs-number">1000</span>)
    return () =&gt; <span class="hljs-built_in">clearInterval</span>(timer)
  }, <span class="hljs-selector-attr">[]</span>) <span class="hljs-comment">// 空依赖，count 被闭包捕获</span>

  return &lt;<span class="hljs-selector-tag">div</span>&gt;{count}&lt;/<span class="hljs-selector-tag">div</span>&gt;
}

<span class="hljs-comment">// ✅ 正确：使用函数式更新</span>
function <span class="hljs-built_in">GoodCounter</span>() {
  const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>)

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    const timer = <span class="hljs-built_in">setInterval</span>(() =&gt; {
      <span class="hljs-built_in">setCount</span>((c) =&gt; c + <span class="hljs-number">1</span>) <span class="hljs-comment">// 函数式更新，不依赖外部 count</span>
    }, <span class="hljs-number">1000</span>)
    return () =&gt; <span class="hljs-built_in">clearInterval</span>(timer)
  }, <span class="hljs-selector-attr">[]</span>)

  return &lt;<span class="hljs-selector-tag">div</span>&gt;{count}&lt;/<span class="hljs-selector-tag">div</span>&gt;
}
</code></pre>
<h3 data-id="heading-19">4.4 常见错误 #4：无限循环</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// ❌ 错误：每次渲染都创建新对象，导致无限循环</span>
function <span class="hljs-built_in">BadComponent</span>() {
  const <span class="hljs-selector-attr">[data, setData]</span> = <span class="hljs-built_in">useState</span>(null)

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    <span class="hljs-built_in">fetch</span>("/api/data")
      <span class="hljs-selector-class">.then</span>((res) =&gt; res<span class="hljs-selector-class">.json</span>())
      <span class="hljs-selector-class">.then</span>(setData)
  }, <span class="hljs-selector-attr">[{ page: 1 }]</span>) <span class="hljs-comment">// 每次都是新对象！无限循环！</span>

  return &lt;<span class="hljs-selector-tag">div</span>&gt;{data}&lt;/<span class="hljs-selector-tag">div</span>&gt;
}

<span class="hljs-comment">// ✅ 正确：使用原始值或 useMemo</span>
function <span class="hljs-built_in">GoodComponent</span>() {
  const <span class="hljs-selector-attr">[data, setData]</span> = <span class="hljs-built_in">useState</span>(null)
  const page = <span class="hljs-number">1</span>

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    <span class="hljs-built_in">fetch</span>(`/api/data?page=${page}`)
      <span class="hljs-selector-class">.then</span>((res) =&gt; res<span class="hljs-selector-class">.json</span>())
      <span class="hljs-selector-class">.then</span>(setData)
  }, <span class="hljs-selector-attr">[page]</span>) <span class="hljs-comment">// 原始值，不会无限循环</span>

  return &lt;<span class="hljs-selector-tag">div</span>&gt;{data}&lt;/<span class="hljs-selector-tag">div</span>&gt;
}
</code></pre>
<hr/>
<h2 data-id="heading-20">写在最后：Hook 的哲学</h2>
<p>自定义 Hooks 不只是代码复用的工具，更是一种思维方式：</p>
<p><strong>1. 关注点分离</strong></p>
<ul>
<li>组件负责"长什么样"（UI）</li>
<li>Hook 负责"怎么工作"（逻辑）</li>
</ul>
<p><strong>2. 组合优于继承</strong></p>
<ul>
<li>小而专注的 Hook 可以自由组合</li>
<li>比 HOC 和 Render Props 更灵活</li>
</ul>
<p><strong>3. 声明式思维</strong></p>
<ul>
<li>描述"要什么"，而不是"怎么做"</li>
<li><code>useDebounce(value, 500)</code> 比手写 setTimeout 清晰 100 倍</li>
</ul>
<p><strong>最后，送你一句话：</strong></p>
<blockquote>
<p>"好的代码不是写出来的，是删出来的。"</p>
<p>当你发现自己在 copy-paste 时，就是该写自定义 Hook 的时候了。</p>
</blockquote>
<hr/>
<blockquote>
<p>💬 <strong>互动时间</strong>：你在项目中封装过哪些好用的自定义 Hooks？评论区分享一下，让大家一起"偷懒"！</p>
<p>觉得这篇文章有用？<strong>点赞 + 在看 + 转发</strong>，让更多 React 开发者早点下班～</p>
</blockquote>
<hr/>
<p><em>本文作者是一个靠自定义 Hooks 实现准时下班的前端开发。关注我，一起用更少的代码，写更好的应用。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go语言核心三剑客：数组、切片与结构体使用指南]]></title>    <link>https://juejin.cn/post/7592438587388543014</link>    <guid>https://juejin.cn/post/7592438587388543014</guid>    <pubDate>2026-01-07T09:18:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592438587388543014" data-draft-id="7592361736130887690" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Go语言核心三剑客：数组、切片与结构体使用指南"/> <meta itemprop="keywords" content="Go,后端"/> <meta itemprop="datePublished" content="2026-01-07T09:18:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="stark张宇"/> <meta itemprop="url" content="https://juejin.cn/user/1983974643871069"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Go语言核心三剑客：数组、切片与结构体使用指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1983974643871069/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    stark张宇
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:18:38.000Z" title="Wed Jan 07 2026 09:18:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎯 学习目标</h2>
<p>完成本课程后，学习者将能够：</p>
<ul>
<li>
<p>Go语言中数组（Array）和切片（Slice）的定义方式、数组和切片的区别</p>
</li>
<li>
<p>切片（Slice）的底层存储原理和扩容方式计算</p>
</li>
<li>
<p>结构体（struct）的定义和使用</p>
</li>
<li>
<p>包（package）的导入 modules、设置国内代理</p>
</li>
</ul>
<h3 data-id="heading-1">一、Go 语言中数组（Array）的定义方式</h3>
<p>数组是<strong>固定长度、同类型</strong>的元素序列，长度是数组类型的一部分，编译期确定，不可动态扩容。</p>
<h4 data-id="heading-2">1. 基本定义（指定长度 + 类型）</h4>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 定义长度为5的int数组，元素初始化为零值（0）</span>
<span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>

<span class="hljs-comment">// 定义长度为3的string数组，显式初始化</span>
<span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">3</span>]<span class="hljs-type">string</span> = [<span class="hljs-number">3</span>]<span class="hljs-type">string</span>{<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>}

<span class="hljs-comment">// 类型推导（省略等号右侧类型）</span>
<span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</code></pre>
<h4 data-id="heading-3">2. 自动推导长度（<code>...</code>）</h4>
<p>通过初始化值的数量自动确定数组长度：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 长度为4的int数组（根据初始化元素个数推导）</span>
<span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-type">int</span>{<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>}

<span class="hljs-comment">// 长度为5的数组，指定索引初始化（未指定的索引为零值）</span>
<span class="hljs-keyword">var</span> arr5 = [...]<span class="hljs-type">int</span>{<span class="hljs-number">0</span>: <span class="hljs-number">1</span>, <span class="hljs-number">3</span>: <span class="hljs-number">4</span>, <span class="hljs-number">4</span>: <span class="hljs-number">5</span>} <span class="hljs-comment">// [1, 0, 0, 4, 5]</span>
</code></pre>
<h4 data-id="heading-4">3. 简短声明（仅局部作用域）</h4>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    arr6 := [<span class="hljs-number">2</span>]<span class="hljs-type">bool</span>{<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>} <span class="hljs-comment">// 长度2的bool数组</span>
}
</code></pre>
<h3 data-id="heading-5">二、Go 语言中切片（Slice）的定义方式</h3>
<p>切片是<strong>动态长度</strong>的数组视图，底层指向一个数组（称为底层数组），包含：指针（指向底层数组）、长度（len）、容量（cap）。切片本身不存储数据，仅描述底层数组的一段。</p>
<h4 data-id="heading-6">1. 基本定义（空切片 / 零值切片）</h4>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 零值切片：nil，len=0，cap=0，无底层数组</span>
<span class="hljs-keyword">var</span> s1 []<span class="hljs-type">int</span>

<span class="hljs-comment">// 空切片：len=0，cap=0，底层数组为空（非nil）</span>
<span class="hljs-keyword">var</span> s2 []<span class="hljs-type">string</span> = []<span class="hljs-type">string</span>{}
<span class="hljs-keyword">var</span> s3 = []<span class="hljs-type">int</span>{}
s4 := []<span class="hljs-type">bool</span>{}
</code></pre>
<h4 data-id="heading-7">2. 基于数组 / 切片截取（最常用）</h4>
<p>语法：<code>[起始索引:结束索引]</code>（左闭右开，结束索引省略则到末尾，起始索引省略则从 0 开始）</p>
<pre><code class="hljs language-go" lang="go">arr := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}

<span class="hljs-comment">// 截取数组的[1,3)区间，s5 = [2,3]，len=2，cap=4（从索引1到数组末尾）</span>
s5 := arr[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]

<span class="hljs-comment">// 截取全部：s6 = [1,2,3,4,5]，len=5，cap=5</span>
s6 := arr[:]

<span class="hljs-comment">// 从索引2到末尾：s7 = [3,4,5]，len=3，cap=3</span>
s7 := arr[<span class="hljs-number">2</span>:]

<span class="hljs-comment">// 从开头到索引3：s8 = [1,2,3]，len=3，cap=5</span>
s8 := arr[:<span class="hljs-number">3</span>]

<span class="hljs-comment">// 切片截取切片</span>
s9 := s5[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] <span class="hljs-comment">// s9 = [2]，len=1，cap=4</span>
</code></pre>
<h4 data-id="heading-8">3. <code>make</code>函数创建（指定长度 / 容量）</h4>
<p>语法：make([]T, len, cap)（cap 可选，默认等于 len）</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 长度3，容量3，元素初始化为零值（0）</span>
s10 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// len=3, cap=3, [0,0,0]</span>

<span class="hljs-comment">// 长度2，容量5，元素初始化为零值（""）</span>
s11 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// len=2, cap=5, ["", ""]</span>
</code></pre>
<h4 data-id="heading-9">4. 直接初始化（字面量）</h4>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 长度3，容量3，元素[10,20,30]</span>
s12 := []<span class="hljs-type">int</span>{<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>}

<span class="hljs-comment">// 指定索引初始化，len=5（最大索引+1），cap=5</span>
s13 := []<span class="hljs-type">int</span>{<span class="hljs-number">0</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">4</span>: <span class="hljs-number">5</span>} <span class="hljs-comment">// [1,0,3,0,5]</span>
</code></pre>
<h3 data-id="heading-10">三、数组与切片的核心区别</h3>













































<table><thead><tr><th>特性</th><th>数组（Array）</th><th>切片（Slice）</th></tr></thead><tbody><tr><td>长度特性</td><td>长度固定，是类型的一部分（如<code>[5]int</code>和<code>[3]int</code>是不同类型）</td><td>长度动态，可通过<code>append</code>扩容，类型仅与元素有关（如<code>[]int</code>）</td></tr><tr><td>内存存储</td><td>直接存储元素，值类型（赋值 / 传参时拷贝整个数组）</td><td>仅存储指针、len、cap，引用类型（赋值 / 传参时拷贝切片结构体，底层数组共享）</td></tr><tr><td>容量（cap）</td><td>容量 = 长度，不可变</td><td>容量≥长度，可通过<code>append</code>自动扩容（底层数组替换）</td></tr><tr><td>零值</td><td>数组零值是每个元素为对应类型零值（如<code>[3]int</code>零值是<code>[0,0,0]</code>）</td><td>切片零值是<code>nil</code>（len=0，cap=0，无底层数组）</td></tr><tr><td>扩容能力</td><td>无，只能重新创建新数组</td><td>支持<code>append</code>扩容，扩容规则：- 原 cap&lt;1024：新 cap=2<em>原 cap- 原 cap≥1024：新 cap≈1.25</em>原 cap</td></tr><tr><td>比较操作</td><td>同类型数组可直接用<code>==</code>比较（元素全部相等则相等）</td><td>切片不能直接用<code>==</code>比较（仅<code>nil == nil</code>），需手动遍历元素比较</td></tr><tr><td>底层依赖</td><td>无依赖，自身就是存储载体</td><td>依赖底层数组，切片是底层数组的 “视图”</td></tr></tbody></table>
<h3 data-id="heading-11">四、示例：直观理解区别</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 数组：长度固定，值拷贝</span>
    arr := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
    arrCopy := arr
    arrCopy[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>
    fmt.Println(arr)     <span class="hljs-comment">// [1 2 3]（原数组不变）</span>
    fmt.Println(arrCopy) <span class="hljs-comment">// [100 2 3]</span>
    
    <span class="hljs-comment">// 切片：引用类型，共享底层数组</span>
    s := arr[:]
    sCopy := s
    sCopy[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>
    fmt.Println(arr)  <span class="hljs-comment">// [100 2 3]（原数组被修改）</span>
    fmt.Println(s)    <span class="hljs-comment">// [100 2 3]</span>
    fmt.Println(sCopy)<span class="hljs-comment">// [100 2 3]</span>

    <span class="hljs-comment">// 切片扩容：底层数组替换</span>
    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">4</span>)
    s[<span class="hljs-number">0</span>] = <span class="hljs-number">200</span>
    fmt.Println(arr)  <span class="hljs-comment">// [100 2 3]（原数组不变，扩容后底层数组已替换）</span>
    fmt.Println(s)    <span class="hljs-comment">// [200 2 3 4]</span>
}
</code></pre>
<h3 data-id="heading-12">五、切片的底层存储</h3>
<p>掌握 Go 切片核心特性（比如扩容、引用传递）的关键，搞清楚切片在内存中是如何存储、分配和管理数据。</p>
<p>切片不是独立的容器，而是对<strong>底层数组（underlying array）</strong> 的封装和引用。可以把切片理解为 “带了长度和容量信息的数组指针”，它本身不存储数据，所有数据都存在底层数组中。</p>
<p>Go 的运行时源码中，切片被定义为 <code>reflect.SliceHeader</code> 结构体（位于 <code>reflect</code> 包），核心包含 3 个字段：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> {
    Data <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 指向底层数组的指针（内存地址）</span>
    Len  <span class="hljs-type">int</span>     <span class="hljs-comment">// 切片的长度：当前可访问的元素个数</span>
    Cap  <span class="hljs-type">int</span>     <span class="hljs-comment">// 切片的容量：从指针指向的位置开始，底层数组剩余的元素总数</span>
}
</code></pre>
<h4 data-id="heading-13">内存布局示例</h4>
<p>比如创建切片 <code>s := []int{1,2,3,4}</code>，其内存布局如下：</p>
<pre><code class="hljs language-go" lang="go">切片s（SliceHeader）        底层数组
+---------+---------+---------+    +---+---+---+---+
| Data    | Len=<span class="hljs-number">4</span>   | Cap=<span class="hljs-number">4</span>   | -&gt; | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> |
+---------+---------+---------+    +---+---+---+---+
</code></pre>
<p>如果对切片截取 <code>s2 := s[1:3]</code>，内存布局变为：</p>
<pre><code class="hljs language-go" lang="go">切片s（原）                底层数组
+---------+---------+---------+    +---+---+---+---+
| Data-&gt;<span class="hljs-number">1</span> | Len=<span class="hljs-number">4</span>   | Cap=<span class="hljs-number">4</span>   |    | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> |
+---------+---------+---------+    +---+---+---+---+
                                      ^
切片s2（新）                            |
+---------+---------+---------+       |
| Data-&gt;<span class="hljs-number">2</span> | Len=<span class="hljs-number">2</span>   | Cap=<span class="hljs-number">3</span>   | ------+
+---------+---------+---------+
</code></pre>
<ul>
<li><code>s2</code> 的 <code>Data</code> 指针指向原数组索引 1 的位置（值为 2）；</li>
<li><code>s2.Len=2</code>（可访问 2、3）；</li>
<li><code>s2.Cap=3</code>（从索引 1 到数组末尾共 3 个元素：2、3、4）。</li>
</ul>
<h4 data-id="heading-14">切片的内存分配规则</h4>
<p>不同创建方式，底层数组的分配规则不同：</p>





















<table><thead><tr><th>创建方式</th><th>底层数组分配逻辑</th></tr></thead><tbody><tr><td>字面量 <code>s := []int{1,2}</code></td><td>编译器自动创建匿名底层数组，切片指向该数组，Len=Cap = 元素个数</td></tr><tr><td>make 创建 <code>s := make([]int, 3, 5)</code></td><td>显式分配长度为 5 的底层数组，切片 Len=3（前 3 个元素初始化为 0），Cap=5</td></tr><tr><td>从数组截取 <code>s := arr[1:3]</code></td><td>切片复用原数组，Data 指针指向数组指定位置，Len=2，Cap = 原数组长度 - 起始索引</td></tr></tbody></table>
<p>当通过 <code>append</code> 向切片添加元素，且 <code>len == cap</code> 时，切片会触发<strong>扩容</strong>，底层逻辑如下：</p>
<ol start="0">
<li><strong>分配新数组</strong>：根据原切片的容量，计算新容量，然后分配一块新的内存空间作为新底层数组；</li>
<li><strong>拷贝数据</strong>：将原底层数组中的数据拷贝到新数组；</li>
<li><strong>更新切片</strong>：切片的 <code>Data</code> 指针指向新数组，<code>Len</code> 增加（新增元素个数），<code>Cap</code> 更新为新容量；</li>
<li><strong>原数组回收</strong>：如果原数组没有其他切片引用，会被 Go 的垃圾回收（GC）清理。</li>
</ol>
<h5 data-id="heading-15">扩容容量计算规则（Go 1.18+）</h5>
<ul>
<li>若原容量 <code>cap &lt; 256</code>：新容量 = 原容量 × 2；</li>
<li>若原容量 <code>cap ≥ 256</code>：新容量 = 原容量 × 1.25（实际会对齐内存块大小，比如向上取整到最近的 8 的倍数）；</li>
<li>特殊情况：如果 <code>append</code> 后需要的长度超过上述计算值，则直接以需要的长度作为新容量。</li>
</ul>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// Len=0, Cap=1</span>
    fmt.Printf(<span class="hljs-string">"初始：len=%d, cap=%d\n"</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">// len=0, cap=1</span>

    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>) <span class="hljs-comment">// Len=1, Cap=1（未扩容）</span>
    fmt.Printf(<span class="hljs-string">"添加1个元素：len=%d, cap=%d\n"</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">// len=1, cap=1</span>

    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>) <span class="hljs-comment">// Len=2, Cap=2（扩容，cap&lt;256 翻倍）</span>
    fmt.Printf(<span class="hljs-string">"添加第2个元素：len=%d, cap=%d\n"</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">// len=2, cap=2</span>

    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 需要len=5，原cap=2，计算新cap=4（2×2）不够，直接用5</span>
    fmt.Printf(<span class="hljs-string">"添加3个元素：len=%d, cap=%d\n"</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">// len=5, cap=5</span>
}
</code></pre>
<h4 data-id="heading-16">关键特性的底层解释</h4>
<h4 data-id="heading-17">1. 切片的 “引用传递”</h4>
<p>切片作为函数参数传递时，传递的是 <code>SliceHeader</code> 的副本（值传递），但副本的 <code>Data</code> 指针仍指向原底层数组。因此：</p>
<ul>
<li>修改切片元素（如 <code>s[0] = 10</code>）会影响原切片（因为共享底层数组）；</li>
<li>修改切片的 <code>Len/Cap</code>（如 <code>s = append(s, 1)</code>）不会影响原切片（因为副本的 <code>Data</code> 可能指向新数组）。</li>
</ul>
<h4 data-id="heading-18">2. <code>copy</code> 函数的底层逻辑</h4>
<p><code>copy(dst, src []T)</code> 是<strong>值拷贝</strong>，会把 src 底层数组的元素逐个复制到 dst 的底层数组，不会共享数组：</p>
<ul>
<li>拷贝的元素个数 = min (len (dst), len (src))；</li>
<li>拷贝后，dst 和 src 的底层数组相互独立，修改一方不会影响另一方。</li>
</ul>
<h4 data-id="heading-19">切片的知识点归纳</h4>
<ol start="0">
<li><strong>切片的底层核心</strong>：切片是 <code>Data指针 + Len + Cap</code> 的结构体，数据存储在底层数组中，切片本身仅占 24 字节（64 位系统，3 个 int 字段）；</li>
<li><strong>扩容的本质</strong>：当切片长度超出容量时，会分配新的底层数组，拷贝数据并更新切片指针，原数组若无引用则被 GC 回收；</li>
<li><strong>引用特性</strong>：切片截取、函数传参默认共享底层数组，<code>copy</code> 函数可实现值拷贝，避免共享。</li>
</ol>
<h3 data-id="heading-20">六、结构体</h3>
<p>结构体通过<code>type + 结构体名 + struct</code>关键字定义，用于聚合多个不同类型的字段（成员变量），支持字段标签（Tag）用于序列化、ORM 映射等场景。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 定义User结构体，包含基础信息和标签</span>
<span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {
    ID       <span class="hljs-type">int</span>    <span class="hljs-string">`json:"id"`</span>       <span class="hljs-comment">// JSON序列化时映射为id</span>
    Name     <span class="hljs-type">string</span> <span class="hljs-string">`json:"name"`</span>     <span class="hljs-comment">// JSON序列化时映射为name</span>
    Age      <span class="hljs-type">int</span>    <span class="hljs-string">`json:"age"`</span>      <span class="hljs-comment">// JSON序列化时映射为age</span>
    IsActive <span class="hljs-type">bool</span>   <span class="hljs-string">`json:"is_active"`</span><span class="hljs-comment">// JSON序列化时映射为is_active</span>
}
</code></pre>
<p><strong>结构体所有实例化方式</strong></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 方式1：直接声明（零值初始化）</span>
<span class="hljs-comment">// 所有字段会被初始化为对应类型的零值（int:0, string:"", bool:false）</span>
<span class="hljs-keyword">var</span> u1 User
fmt.Println(<span class="hljs-string">"方式1-直接声明（零值）："</span>, u1)

<span class="hljs-comment">// 手动赋值字段</span>
u1.ID = <span class="hljs-number">1</span>
u1.Name = <span class="hljs-string">"张三"</span>
u1.Age = <span class="hljs-number">25</span>
u1.IsActive = <span class="hljs-literal">true</span>
fmt.Println(<span class="hljs-string">"方式1-赋值后："</span>, u1)

<span class="hljs-comment">// 方式2：字面量初始化（值类型）</span>
<span class="hljs-comment">// 指定部分字段，未指定字段为零值；字段顺序可与定义不一致</span>
u2 := User{
    ID:   <span class="hljs-number">2</span>,
    Name: <span class="hljs-string">"李四"</span>,
    Age:  <span class="hljs-number">30</span>,
    <span class="hljs-comment">// IsActive 未指定，默认false</span>
}
fmt.Println(<span class="hljs-string">"方式2-字面量（值类型）："</span>, u2)

<span class="hljs-comment">// 方式3：字面量初始化（指针类型）【推荐】</span>
<span class="hljs-comment">// 直接返回结构体指针，减少值拷贝开销；语法上与值类型仅多一个&amp;</span>
u3 := &amp;User{
    ID:       <span class="hljs-number">3</span>,
    Name:     <span class="hljs-string">"王五"</span>,
    Age:      <span class="hljs-number">28</span>,
    IsActive: <span class="hljs-literal">true</span>,
}
fmt.Println(<span class="hljs-string">"方式3-字面量（指针类型）："</span>, u3)
<span class="hljs-comment">// 指针类型访问字段（Go自动解引用，无需(*u3).Name）</span>
fmt.Println(<span class="hljs-string">"方式3-访问指针字段："</span>, u3.Name, u3.Age)

<span class="hljs-comment">// 方式4：new函数初始化（指针类型）</span>
<span class="hljs-comment">// new(结构体名) 等价于 &amp;结构体名{}，返回指针，所有字段为零值</span>
u4 := <span class="hljs-built_in">new</span>(User)
fmt.Println(<span class="hljs-string">"方式4-new函数（指针零值）："</span>, u4)
<span class="hljs-comment">// 给指针实例赋值字段</span>
u4.ID = <span class="hljs-number">4</span>
u4.Name = <span class="hljs-string">"赵六"</span>
u4.Age = <span class="hljs-number">35</span>
u4.IsActive = <span class="hljs-literal">false</span>
fmt.Println(<span class="hljs-string">"方式4-new函数（赋值后）："</span>, u4)

<span class="hljs-comment">// 方式5：字面量简写（按字段定义顺序初始化，不推荐，可读性差）</span>
<span class="hljs-comment">// 必须严格按结构体字段定义顺序赋值，且不能省略任何字段（除非用空值）</span>
u5 := User{<span class="hljs-number">5</span>, <span class="hljs-string">"钱七"</span>, <span class="hljs-number">22</span>, <span class="hljs-literal">true</span>}
fmt.Println(<span class="hljs-string">"方式5-字面量简写（值类型）："</span>, u5)
</code></pre>
<p>Go 通过<strong>结构体嵌套</strong>实现 “组合”（替代继承），支持 “匿名字段”（提升字段）。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 定义地址结构体</span>
<span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> {
    Province <span class="hljs-type">string</span>
    City     <span class="hljs-type">string</span>
}

<span class="hljs-comment">// User嵌套Address字段</span>
<span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {
    ID      <span class="hljs-type">int</span>
    Name    <span class="hljs-type">string</span>
    Address Address <span class="hljs-comment">// 显式嵌套</span>
}

<span class="hljs-comment">// 使用</span>
u := &amp;User{
    ID:   <span class="hljs-number">1</span>,
    Name: <span class="hljs-string">"张三"</span>,
    Address: Address{
        Province: <span class="hljs-string">"北京"</span>,
        City:     <span class="hljs-string">"朝阳区"</span>,
    },
}
fmt.Println(u.Address.City) <span class="hljs-comment">// 朝阳区</span>
</code></pre>
<p>嵌套的结构体字段省略名称时，其内部字段会被 “提升” 为外层结构体的直接字段，可直接访问。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> {
    Province <span class="hljs-type">string</span>
    City     <span class="hljs-type">string</span>
}

<span class="hljs-comment">// 匿名字段嵌套</span>
<span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {
    ID      <span class="hljs-type">int</span>
    Name    <span class="hljs-type">string</span>
    Address <span class="hljs-comment">// 匿名字段，Address的字段被提升</span>
}

<span class="hljs-comment">// 使用</span>
u := &amp;User{
    ID:   <span class="hljs-number">1</span>,
    Name: <span class="hljs-string">"张三"</span>,
    Address: Address{
        Province: <span class="hljs-string">"北京"</span>,
        City:     <span class="hljs-string">"朝阳区"</span>,
    },
}
fmt.Println(u.City) <span class="hljs-comment">// 直接访问提升字段，等价于u.Address.City</span>
</code></pre>
<h3 data-id="heading-21">七、包（package）</h3>
<p>Go 语言的是代码组织的核心单元，<strong>一个目录下的所有.go 文件必须属于同一个包</strong>，且包名建议与目录名保持一致（非强制，但符合最佳实践）。</p>
<p><strong>核心定义规则：</strong></p>
<ul>
<li>每个 Go 源文件必须以 <code>package 包名</code> 开头，声明所属包。</li>
<li>包名<strong>推荐</strong>使用小写、简短、见名知意的名称，避免下划线、驼峰式（除非是约定俗成的如 <code>encoding/json</code>）。</li>
<li>包名可以与所在目录名不同，但<strong>建议保持一致</strong>（提升可读性）。</li>
<li><code>main</code> 包是特殊包：包含 <code>func main()</code> 函数，是程序的入口包，编译后生成可执行文件；非 <code>main</code> 包编译后生成库文件（<code>.a</code>）。</li>
<li>同一个目录下的所有 <code>.go</code> 文件必须声明为同一个包名。</li>
</ul>
<h4 data-id="heading-22">Package 的导入方式</h4>
<p>Go 支持多种灵活的包导入方式，核心关键字是 <code>import</code>，需写在 <code>package</code> 声明之后、函数 / 变量定义之前。</p>
<p>1、先初始化 Go 模块（确保代码可运行）：</p>
<pre><code class="hljs language-go" lang="go"># 进入项目目录
cd ~/<span class="hljs-keyword">go</span>-demo
# 初始化模块（模块名自定义，如 demo）
<span class="hljs-keyword">go</span> mod init demo
</code></pre>
<p>2、文件路径：<code>~/go-demo/main.go</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-comment">// 方式1：多行分组导入（推荐）</span>
<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>          <span class="hljs-comment">// 标准库包</span>
    <span class="hljs-string">"demo/utils"</span>   <span class="hljs-comment">// 自定义包（基于go mod的相对路径）</span>
)

<span class="hljs-comment">// 方式2：单行导入（适合少量包）</span>
<span class="hljs-comment">// import "fmt"</span>
<span class="hljs-comment">// import "demo/utils"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 调用导入包的导出函数：包名.函数名</span>
    result := utils.Add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)
    fmt.Printf(<span class="hljs-string">"10 + 20 = %d\n"</span>, result)
}
</code></pre>
<p>3、别名导入</p>
<p>给导入的包起别名，适用于包名过长、包名冲突或简化代码的场景。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-comment">// 给utils包起别名u</span>
    u <span class="hljs-string">"demo/utils"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 通过别名调用包的函数</span>
    result := u.Add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)
    fmt.Printf(<span class="hljs-string">"5 + 3 = %d\n"</span>, result)
}
</code></pre>
<p>4、设置国内代理</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">go</span> env -w GO111MODULE=on
<span class="hljs-keyword">go</span> env -w GOPROXY=https:<span class="hljs-comment">//goproxy.cn,direct</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[聊聊我对 React Hook 不一样的理解]]></title>    <link>https://juejin.cn/post/7592423411562332186</link>    <guid>https://juejin.cn/post/7592423411562332186</guid>    <pubDate>2026-01-07T09:05:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7592423411562332186" data-draft-id="7592340733954244658" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="聊聊我对 React Hook 不一样的理解"/> <meta itemprop="keywords" content="React.js"/> <meta itemprop="datePublished" content="2026-01-07T09:05:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="fe小陈"/> <meta itemprop="url" content="https://juejin.cn/user/4019470241892983"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            聊聊我对 React Hook 不一样的理解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4019470241892983/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    fe小陈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-07T09:05:55.000Z" title="Wed Jan 07 2026 09:05:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">什么是 React Hook</h2>
<p>React Hook 是 React 16.8 版本推出的特性，核心作用是让函数组件也能使用状态（State）、生命周期等原本只有类组件才能拥有的 React 特性。它通过一系列预定义的钩子函数（如 useState、useEffect），让开发者无需编写类组件，就能更简洁、灵活地管理组件逻辑，同时也便于逻辑的复用与拆分。</p>
<blockquote>
<p>网上有大量的总结文章教会你如何使用 react hook，包括一些诸如取代 mixin 、hoc、类组件继承，所以这不是我想讲的重点。</p>
</blockquote>
<h2 data-id="heading-1">两面性</h2>
<p>Hook的出现不仅是React语法层面的优化，更重塑了函数组件的能力边界与代码组织方式，但也随之引入了新的认知与实践门槛。从核心能力来看，其价值主要体现在三个维度：</p>
<p><strong>1. 逻辑复用的革命性突破</strong>：相比类组件时代mixins的命名冲突、HOC的嵌套地狱，Hook通过自定义Hook实现了“逻辑抽取-复用”的极简路径。开发者可将分散在不同生命周期的关联逻辑（如数据请求+加载状态+异常处理）抽离为独立Hook，在多个组件中直接复用，且不存在属性透传或嵌套冗余的问题。</p>
<p><strong>2. 状态与副作用的集中管控</strong>：类组件中需分散在componentDidMount、componentDidUpdate、componentWillUnmount的副作用逻辑，在Hook中可通过useEffect统一管理，配合返回函数完成资源清理，实现“关联逻辑聚合”，大幅提升代码可读性。同时，useState、useReducer让函数组件无需依赖this即可实现灵活的状态管理，摆脱了类组件中this指向的诸多陷阱。</p>
<p><strong>3. 更友好的工程化适配</strong>：Hook天然契合函数式编程理念，与TypeScript的类型推导无缝兼容，能显著降低强类型项目的开发成本。此外，React 18后续推出的useTransition、useDeferredValue等新Hook，进一步拓展了并发渲染场景下的能力，让函数组件能更好地适配现代前端复杂的性能需求。</p>
<p>但能力的拓展也伴随着新的痛点，这些问题往往源于对Hook设计理念的理解偏差，而非特性本身：</p>
<p><strong>1. 依赖管理的“隐形门槛”</strong> ：useEffect、useCallback等Hook的依赖数组是最易踩坑的环节。依赖缺失会导致副作用不触发更新，依赖冗余（如未缓存的函数、每次渲染新建的对象）则会引发频繁重渲染，更隐蔽的是“依赖闭环”导致的无限循环（如useEffect中更新state却依赖该state），排查成本极高。</p>
<p><strong>2. 闭包陷阱的高频踩坑</strong>：函数组件每次渲染都会创建新的作用域，异步操作（定时器、Promise回调）极易捕获旧作用域的“过期状态”。例如依赖数组为空的useEffect中，定时器始终获取初始state值，这类问题因表象与逻辑预期背离，新手往往难以定位。</p>
<p><strong>3. 副作用清理的隐蔽风险</strong>：useEffect的清理函数（返回函数）是避免内存泄漏的关键，但实际开发中常被遗漏（如window事件监听、WebSocket连接未解绑）。尤其在复杂组件中，多个副作用叠加时，清理逻辑的顺序与完整性更难把控，容易引发隐性bug。</p>
<p><strong>4. 复杂场景下的性能优化难题</strong>：Hook简化了代码编写，但也容易催生“胖Hook”——一个useEffect包含多个无关副作用逻辑，导致组件耦合度升高。同时，新手常忽视useMemo、useCallback的合理使用，在大数据渲染、深层组件传递函数时，易出现不必要的重渲染，且性能瓶颈难以定位。</p>
<h2 data-id="heading-2">限制与规则</h2>
<p>React Hook 并非可以随意使用，其设计遵循严格的规则与限制，这些规则是 React 能够稳定管理 Hook 状态关联的核心保障，违反规则可能导致组件渲染异常、状态错乱等难以排查的问题。核心规则与限制主要包括以下几点：</p>
<p><strong>1. 只能在函数组件或自定义 Hook 的顶层调用</strong>：这是最核心的规则。Hook 不能嵌套在循环、条件语句（if/else）、switch 语句或嵌套函数内部调用。原因是 React 依靠 Hook 的调用顺序来建立状态与组件的关联，若调用顺序不固定（如条件判断导致某些 Hook 有时执行有时不执行），会破坏 React 对状态的追踪，导致状态错乱。例如：不能在 if (isShow) { useState(0) } 中调用 Hook。</p>
<p><strong>2. 只能在 React 函数中调用 Hook</strong>：Hook 仅能用于 React 函数组件（包括箭头函数组件）和自定义 Hook 中，不能在普通的 JavaScript 函数中调用。这是因为 Hook 依赖 React 的内部机制来管理状态和副作用，普通 JS 函数不具备这样的运行环境，调用后无法正常工作。</p>
<p><strong>3. 自定义 Hook 必须以 “use” 开头命名</strong>：这是 React 约定的命名规范，并非语法强制要求，但遵循该规范能让 React 识别自定义 Hook，同时让开发者快速区分普通函数与 Hook，避免误用。例如：useRequest（数据请求 Hook）、useWindowSize（监听窗口大小 Hook），若命名为 requestHook 则无法被 React 正确识别为 Hook，也不便于团队协作维护。</p>
<p><strong>4. 状态更新的不可变性限制</strong>：使用 useState 或 useReducer 管理引用类型状态（对象、数组）时，必须遵循不可变性原则，不能直接修改原始状态对象（如 state.obj.name = 'new'），而应创建新的对象/数组来更新状态。因为 React 通过浅比较引用是否变化来判断是否需要重新渲染，直接修改原始状态不会改变引用，导致组件无法触发重渲染。</p>
<p><strong>5. 副作用清理的必要性限制</strong>：使用 useEffect 管理副作用（如事件监听、定时器、网络连接）时，若副作用会产生内存泄漏风险（如组件卸载后仍执行回调），必须在 useEffect 的返回函数中编写清理逻辑（如移除事件监听、清除定时器、关闭连接）。这是保障组件性能和稳定性的重要限制，忽略清理可能导致内存泄漏、多次触发副作用等问题。</p>
<h2 data-id="heading-3">不一样的想法</h2>
<h3 data-id="heading-4">某些规则是可以打破的</h3>
<p><a href="https://juejin.cn/post/7584298069610283008" target="_blank" title="https://juejin.cn/post/7584298069610283008">juejin.cn/post/758429…</a></p>
<ol>
<li>只能在函数顶部使用 hook</li>
<li>条件 hook</li>
<li>类组件内使用 hook</li>
</ol>
<h3 data-id="heading-5">类组件完全放弃了吗？代价是什么？</h3>
<p>在新的项目中，几乎已经看不到类组件被使用（除了手搓 ErrorBoundary)。</p>
<p>但在享受 hook 带来函数式组件魔法的过程中，也引入了许多的问题</p>
<ol>
<li>为了防止子组件重渲染，需要对回调函数、数据做 memo（useCallback、useMemo)</li>
<li>少传个 dep，导致闭包问题、子组件不更新问题</li>
<li>然后又引入了 React Compiler 、useEventEffect</li>
</ol>
<p>这就有点为了填一个坑，挖了另一个坑的感觉</p>
<p>类组件是有可取之处的，比如</p>
<ol>
<li>
<p>回调方法通过 this.state 是可以取到最新的状态的，因此不需要那么多 useCallback useMemo，减少了性能优化的心智负担；</p>
</li>
<li>
<p>ref 可以直接使用组件的属性，无需像函数组件那样借助 useRef 再手动关联，操作更简洁；</p>
</li>
<li>
<p>生命周期逻辑时序更直观：类组件通过 componentDidMount、componentDidUpdate、componentWillUnmount 等明确的钩子划分生命周期阶段，复杂副作用（如多轮数据请求、时序依赖的资源操作）的执行时机更易把控，无需像 useEffect 那样通过依赖数组间接控制；</p>
</li>
<li>
<p>状态更新支持自动合并：类组件中 setState 会自动合并对象类型状态的部分属性（如 this.setState({ name: 'new' }) 不会覆盖其他未修改的状态字段），而函数组件 useState 需手动通过扩展运算符（...）实现合并，降低了状态更新的代码复杂度。</p>
</li>
</ol>
<p>但 Hook 在逻辑注入、复用方面相比类组件有绝对的优势。</p>
<p><strong>所以有没有人想过在类组件里面使用 Hook，将两者的优势结合一下？</strong> <a href="https://juejin.cn/post/7584298069610283008#heading-4" target="_blank" title="https://juejin.cn/post/7584298069610283008#heading-4">juejin.cn/post/758429…</a></p>
<h3 data-id="heading-6">Hook 作为状态管理的一种方式，却依赖于组件生命周期</h3>
<p>想必 React 开发者最头疼的就是状态管理方案了，但是一旦引入了状态管理方案如 redux、zustand，你会直接失去 Hook 的能力。 <a href="https://juejin.cn/post/7591728734983208987#heading-7" target="_blank" title="https://juejin.cn/post/7591728734983208987#heading-7">juejin.cn/post/759172…</a></p>
<p>原本可以使用 ahooks 的 useRequest 发起请求，迁移到 zustand 直接就是一坨。</p>
<p>没有对比，就真没有伤害。</p>
<p>如果你用过 vue 生态中的 pinia <a href="https://link.juejin.cn?target=https%3A%2F%2Fpinia.vuejs.org%2Fzh%2Fcookbook%2Fcomposables.html%23setup-stores" target="_blank" title="https://pinia.vuejs.org/zh/cookbook/composables.html#setup-stores" ref="nofollow noopener noreferrer">pinia.vuejs.org/zh/cookbook…</a> ，就会知道 pinia 是可以直接复用 vue 的 composition api 以及 VueUse 相关的能力的。</p>
<p>针对这个课题，我也进行了尝试。 <a href="https://juejin.cn/post/7591207451779121178" target="_blank" title="https://juejin.cn/post/7591207451779121178">juejin.cn/post/759120…</a></p>
<h2 data-id="heading-7">总结</h2>
<p>综上，React Hook 绝非完美的“银弹”，而是一把兼具强大能力与使用门槛的“双刃剑”。它以革命性的逻辑复用方式、集中化的状态与副作用管控，以及友好的工程化适配性，重塑了React函数组件的开发模式，成为现代React项目的主流选择。但与此同时，依赖管理难题、闭包陷阱、副作用清理风险等痛点，也让开发者面临更高的认知与实践成本。</p>
<p>关于Hook的规则，并非绝对不可突破，在特定场景下通过合理封装实现动态Hook调用、类组件间接使用Hook等探索，为特殊需求（如旧项目迁移）提供了更多可能，但需警惕代码复杂度提升的风险。而类组件与Hook的取舍之争，本质是开发效率、可维护性与性能之间的权衡——类组件在状态获取、生命周期直观性等方面的优势仍不可忽视，完全放弃可能陷入“为填坑而挖新坑”的循环。</p>
<p>此外，Hook依赖组件生命周期的特性，使其在状态管理场景中存在天然局限，相比Vue Pinia对组合式API的无缝复用能力，仍有优化空间。这也提示我们，不应盲目迷信Hook的“魔法”，而应回归开发本质：既要充分发挥其逻辑复用的核心优势，也要理性看待其不足，结合项目场景（新旧项目、复杂度、团队习惯）灵活选择技术方案，甚至探索类组件与Hook的优势融合路径。最终，技术的价值在于解决问题，对Hook的理解不应局限于“规范用法”，而应基于对其底层逻辑的深刻认知，实现灵活、高效且稳定的开发实践。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>