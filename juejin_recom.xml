<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[【Numpy数据运算】Numpy速学手册]]></title>    <link>https://juejin.cn/post/7573170756869128244</link>    <guid>https://juejin.cn/post/7573170756869128244</guid>    <pubDate>2025-11-17T06:31:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573170756869128244" data-draft-id="7573241978901659663" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Numpy数据运算】Numpy速学手册"/> <meta itemprop="keywords" content="Python,NumPy"/> <meta itemprop="datePublished" content="2025-11-17T06:31:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AI小云"/> <meta itemprop="url" content="https://juejin.cn/user/4153318871926912"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Numpy数据运算】Numpy速学手册
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4153318871926912/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AI小云
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:31:40.000Z" title="Mon Nov 17 2025 06:31:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、Numpy的基本介绍和配置</h3>
<h4 data-id="heading-1">1.1 numpy基本介绍</h4>
<p>numpy是Python语言的一个第三方科学计算库，它的意思是“Numeric Python”，它是一个由多维数组对象和用于处理数组的函数集合组成的库。</p>
<p>numpy支持N维数组运算、处理大型矩阵、成熟的广播函数库、矢量计算、线性代数等常见科学运算操作，而且处理效率非常高，特别是针对数组运算，所以是非常常用的一个科学计算和数据分析用的库。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d237438b8c344369962d9b2d833655b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlsI_kupE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965899&amp;x-signature=hcvQq%2Fq8x0%2FB4bjPD6zh5JeDL54%3D" alt="1.png" loading="lazy"/></p>
<h4 data-id="heading-2">1.2 numpy的优势</h4>
<p>numpy的数组在运算时是非常高效的，特别是在多维向量运算时远比python数组快得多。我们可以通过一个简单的例子来对比python数组和numpy数组的运行效率哪个更高，代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># numpy和python原生列表求和计算的对比</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> time
py_list = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000000</span>):
    py_list.append(random.random())   <span class="hljs-comment"># 生成100000000个元素的随机数列表</span>
np_list = np.array(py_list)  <span class="hljs-comment"># 将100000000个元素的随机数列表放入到ndarray中</span>
<span class="hljs-comment"># 原生python list求和</span>
st1 = time.time()  <span class="hljs-comment"># 记录开始时间</span>
<span class="hljs-built_in">sum</span>(py_list)        <span class="hljs-comment"># 直接使用python列表提供的sum方法对列表求和</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"用原生python列表计算耗时为："</span>, time.time()-st1)
<span class="hljs-comment"># 用ndarray求和</span>
st2 = time.time()
np.<span class="hljs-built_in">sum</span>(np_list)     <span class="hljs-comment"># 利用numpy提供的sum方法对列表求和</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"用ndarray计算耗时为："</span>, time.time()-st2)
</code></pre>
<p>python为什么慢？</p>
<ol start="0">
<li>标准的python中用列表保存一组值，可以当作数组使用。但由于列表的元素可以是任何对象，因此列表中保存的是对象的指针（地址）。对于数值运算来说，这种结构显然比较浪费内存和CPU运算。</li>
<li>Python提供了array模块，能直接保存数值，但由于它不支持多维数组，也没有各种运算函数，因为也不适合做数值运算。</li>
</ol>
<h3 data-id="heading-3">二、Numpy基础使用</h3>
<h4 data-id="heading-4">2.1 生成numpy数组</h4>
<p>在numpy中，最重要的对象是被称为叫ndarray的N维数组类型。ndarray中的每个元素在内存中使用相同大小的块，它描述相同类型的元素集合。这个集合中的元素是基于零的索引来进行访问。</p>
<ul>
<li>创建一个基本的numpy数组</li>
</ul>

<pre><code class="hljs language-php" lang="php">import numpy <span class="hljs-keyword">as</span> np
my_array = np.<span class="hljs-keyword">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-keyword">print</span>(my_array)
</code></pre>
<p>实际上上面的代码是将一个python数组转化为了一个numpy数组。</p>
<p>除了可以将python数组转化为一个numpy数组外，numpy还内置了几种常见的创建数组的方式。</p>
<ul>
<li>创建指定形状的全0的二维数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">ndarr1</span> = np.zeros(shape=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>), dtype=np.int_)  <span class="hljs-comment"># np.int_是numpy里面自带的整型类型</span>
print(ndarr1)
打印出来的结果是：
<span class="hljs-section">[[0 0 0 0]</span>
 <span class="hljs-section">[0 0 0 0]</span>
 <span class="hljs-section">[0 0 0 0]]</span>
</code></pre>
<ul>
<li>创建指定形状全1的二维数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd2</span> = np.<span class="hljs-literal">on</span>es(shape=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>), dtype=np.float_) <span class="hljs-comment"># 注意，指定的是float类型</span>
print(nd2)
输出结果为：
<span class="hljs-section">[[1. 1. 1. 1.]</span>
 <span class="hljs-section">[1. 1. 1. 1.]</span>
 <span class="hljs-section">[1. 1. 1. 1.]]</span>
</code></pre>
<p>这些方法的主要意义是方便用户快速创建指定大小的全零数组，并将其作为其他计算和操作的基础。</p>
<ul>
<li>生成指定维数的多维数组，比如三维数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">np.full(<span class="hljs-attr">shape</span>=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>), fill_value=<span class="hljs-number">1.23</span>) <span class="hljs-comment"># 生成一个三维数组，第一维有3行，第二维有4行，第三维有5个元素。所有的元素都用1.23来填充。</span>
运行结果如下：
array(<span class="hljs-section">[[[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]]</span>,
       <span class="hljs-section">[[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]]</span>,
       <span class="hljs-section">[[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]]]</span>)
</code></pre>
<ul>
<li>生成随机数组</li>
</ul>

<pre><code class="hljs language-scss" lang="scss">np<span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.randint</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">20</span>)  # 生成一个<span class="hljs-number">1</span>-<span class="hljs-number">100</span>之间，<span class="hljs-number">20</span>个随机的整数值
运行结果如下：
<span class="hljs-built_in">array</span>([<span class="hljs-number">83</span>, <span class="hljs-number">26</span>, <span class="hljs-number">69</span>, <span class="hljs-number">60</span>, <span class="hljs-number">86</span>, <span class="hljs-number">92</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">21</span>, <span class="hljs-number">13</span>, <span class="hljs-number">28</span>, <span class="hljs-number">71</span>, <span class="hljs-number">61</span>, <span class="hljs-number">49</span>, <span class="hljs-number">28</span>, <span class="hljs-number">34</span>, <span class="hljs-number">71</span>, <span class="hljs-number">13</span>,
       <span class="hljs-number">63</span>, <span class="hljs-number">68</span>, <span class="hljs-number">25</span>])
</code></pre>
<ul>
<li>生成0-1之间的随机数</li>
</ul>

<pre><code class="hljs language-lua" lang="lua">np.<span class="hljs-built_in">random</span>.rand(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)  # 生成<span class="hljs-number">3</span>行<span class="hljs-number">5</span>列的<span class="hljs-number">0</span><span class="hljs-number">-1</span>之间的随机数
运行结果如下：
array(<span class="hljs-string">[[0.99575551, 0.15548124, 0.22529574, 0.51938085, 0.45664922],
       [0.90502429, 0.3120783 , 0.8739342 , 0.94432649, 0.68055903],
       [0.47818137, 0.17935855, 0.03667778, 0.1575434 , 0.03999879]]</span>)
</code></pre>
<ul>
<li>生成等差数列</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">np.arange(1, 100, <span class="hljs-attr">step</span>=<span class="hljs-number">2</span>)  <span class="hljs-comment"># 生成差值为2的等差序列</span>
运行结果如下：
array(<span class="hljs-section">[ 1,  3,  5,  7,  9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33,
       35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67,
       69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]</span>)
np.linspace(1, 10, <span class="hljs-attr">num</span>=<span class="hljs-number">20</span>)  <span class="hljs-comment"># 生成从1-10之间的有20个数的等差数列</span>
运行结果如下：
array(<span class="hljs-section">[ 1.        ,  1.47368421,  1.94736842,  2.42105263,  2.89473684,
        3.36842105,  3.84210526,  4.31578947,  4.78947368,  5.26315789,
        5.73684211,  6.21052632,  6.68421053,  7.15789474,  7.63157895,
        8.10526316,  8.57894737,  9.05263158,  9.52631579, 10.        ]</span>)
注意，两者的区别是：
1. arange是左开右闭，并且可以通过参数指定等差的步长。
2. linspace是左开右开，通过参数指定的是等差数列的值的个数，无法指定步长
</code></pre>
<ul>
<li>创建单位数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">np.eye(4)   <span class="hljs-comment"># 创建一个4行4列的数组，对角线全为1</span>
输出结果：
array(<span class="hljs-section">[[1., 0., 0., 0.]</span>,
       <span class="hljs-section">[0., 1., 0., 0.]</span>,
       <span class="hljs-section">[0., 0., 1., 0.]</span>,
       <span class="hljs-section">[0., 0., 0., 1.]]</span>)
</code></pre>
<ul>
<li>创建对角数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">np.diag(<span class="hljs-section">[2,3,4,8]</span>)  <span class="hljs-comment"># 根据列表参数创建对角数组</span>
输出结果：
array(<span class="hljs-section">[[2, 0, 0, 0]</span>,
       <span class="hljs-section">[0, 3, 0, 0]</span>,
       <span class="hljs-section">[0, 0, 4, 0]</span>,
       <span class="hljs-section">[0, 0, 0, 8]]</span>)
</code></pre>
<h4 data-id="heading-5">2.2 其他运算操作</h4>
<p>数组的聚合运算：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-tag">a</span> = np<span class="hljs-selector-class">.array</span>([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]])
<span class="hljs-built_in">print</span>(np.sum(a))
<span class="hljs-built_in">print</span>(np.average(a))
<span class="hljs-built_in">print</span>(np.mean(a))
<span class="hljs-built_in">print</span>(np.std(a))
<span class="hljs-built_in">print</span>(np.var(a))
<span class="hljs-built_in">print</span>(np.min(a))
<span class="hljs-built_in">print</span>(np.max(a))
<span class="hljs-built_in">print</span>(np.median(a))
</code></pre>
<p>转换方向：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">print</span>(np.rot90(a))        <span class="hljs-comment"># 旋转90度</span>
<span class="hljs-built_in">print</span>(np.rot90(a, k=3))    <span class="hljs-comment"># 旋转270度</span>
</code></pre>
<p>特殊运算：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">print</span>(np.power(a, 2))   <span class="hljs-comment"># 各数的平方</span>
<span class="hljs-built_in">print</span>(np.exp(a))        <span class="hljs-comment"># e的各数次方</span>
<span class="hljs-built_in">print</span>(np.log(a))        <span class="hljs-comment"># 自然对数</span>
<span class="hljs-built_in">print</span>(np.log2(a))        <span class="hljs-comment"># 2为底数</span>
<span class="hljs-built_in">print</span>(np.log10(a))        <span class="hljs-comment"># 10为底数</span>
</code></pre>
<h4 data-id="heading-6">2.2 查看数组属性</h4>
<p>新建一个数组，并查看数组的各个常见属性。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd</span> = np.random.rand(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)
array(<span class="hljs-section">[[0.68500603, 0.33329822, 0.95843204, 0.88017799, 0.27872737]</span>,
       <span class="hljs-section">[0.33032208, 0.26202034, 0.64646861, 0.79371605, 0.18761317]</span>,
       <span class="hljs-section">[0.06157604, 0.2343893 , 0.55365721, 0.60644976, 0.81372911]]</span>)
<span class="hljs-comment"># 查看数组的形状</span>
nd.shape  <span class="hljs-comment">#(3, 5)</span>
<span class="hljs-comment"># 查看数组的长度</span>
nd.size   <span class="hljs-comment"># 15</span>
<span class="hljs-comment"># 查看数组元素类型</span>
nd.dtype  <span class="hljs-comment"># dtype('float64')</span>
<span class="hljs-comment"># 查看数组的维度</span>
nd.ndim   <span class="hljs-comment"># 2</span>
</code></pre>
<h4 data-id="heading-7">2.3 常见数据类型</h4>
<p>在numpy中，常见的数据类型包括int，float，str，和datetime64等类型。</p>
<pre><code class="hljs language-ini" lang="ini">np.array(<span class="hljs-section">[1,2,3,4]</span>, <span class="hljs-attr">dtype</span>=<span class="hljs-string">"float16"</span>)  <span class="hljs-comment"># 创建数组时指定数据类型</span>
输出结果：
array(<span class="hljs-section">[1., 2., 3., 4.]</span>, <span class="hljs-attr">dtype</span>=float16)
<span class="hljs-comment"># 文本型数据类型</span>
np.array(list('hello'))
输出结果：array(<span class="hljs-section">['h', 'e', 'l', 'l', 'o']</span>, <span class="hljs-attr">dtype</span>=<span class="hljs-string">'&lt;U1'</span>)
也可以进行数据类型的转换
<span class="hljs-attr">nd</span> = np.random.rand(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)
nd.dtype   <span class="hljs-comment"># float64</span>
np.asarray(nd, <span class="hljs-attr">dtype</span>=<span class="hljs-string">"float16"</span>)   <span class="hljs-comment"># 将nd数组由float64位变为float16位，精度减小</span>
np.asarray(nd, <span class="hljs-attr">dtype</span>=<span class="hljs-string">"int8"</span>)     <span class="hljs-comment"># 将nd数组变成int类型，结果全部是0，因为小数位数舍去了</span>
通过对象自身的astype进行类型转换
nd.astype(<span class="hljs-attr">dtype</span>=<span class="hljs-string">"float32"</span>)
</code></pre>
<p>时间类型的用法 datetime64 类型是 Numpy 中一种用于表示日期和时间的数据类型。下面是一个使用方法的示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-comment"># 创建一个 datetime 对象表示 2022-01-01 12:00:00</span>
dt = np.datetime64(<span class="hljs-string">'2022-01-01T12:00:00'</span>)
<span class="hljs-comment"># 输出对象以及其数据类型</span>
<span class="hljs-built_in">print</span>(dt)
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(dt))
<span class="hljs-comment"># 创建一个包含多个 datetime 对象的数组</span>
dt_arr = np.array([<span class="hljs-string">'2022-01-01T12:00:00'</span>, <span class="hljs-string">'2022-01-02T06:30:00'</span>, <span class="hljs-string">'2022-01-03T14:15:00'</span>], dtype=<span class="hljs-string">'datetime64'</span>)
<span class="hljs-built_in">print</span>(dt_arr)
</code></pre>
<h4 data-id="heading-8">2.4 数组元素的索引</h4>
<h5 data-id="heading-9">2.4.1 一维数组的索引</h5>
<p>一维数组的索引方式跟python中的列表元素的索引方式是相同的，都是通过0开始的数字来进行索引，也支持倒序-1开始的索引。</p>
<h5 data-id="heading-10">2.4.2 多维数组的索引</h5>
<ul>
<li>二维数组的索引操作</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd</span> = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, size=(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))
输出内容：
array(<span class="hljs-section">[[47,  9, 51, 16,  9, 18]</span>,
       <span class="hljs-section">[23, 74, 58, 91, 63, 84]</span>,
       <span class="hljs-section">[97, 44, 33, 27,  9, 77]</span>,
       <span class="hljs-section">[11, 41, 35, 61, 10, 71]</span>,
       <span class="hljs-section">[87, 71, 20, 57, 83,  2]]</span>)
nd<span class="hljs-section">[0, 1:]</span>  <span class="hljs-comment"># 第1行第2个到最后一个数</span>
输出内容：
array(<span class="hljs-section">[ 9, 51, 16,  9, 18]</span>)
nd<span class="hljs-section">[:, 0]</span>  <span class="hljs-comment"># 所有行的第一个数字</span>
输出内容：
array(<span class="hljs-section">[47, 23, 97, 11, 87]</span>)
nd<span class="hljs-section">[1:4, 1:5]</span>  <span class="hljs-comment"># 第2到4行，第2到5列的数字</span>
输出内容：
array(<span class="hljs-section">[[74, 58, 91, 63]</span>,
       <span class="hljs-section">[44, 33, 27,  9]</span>,
       <span class="hljs-section">[41, 35, 61, 10]]</span>)
nd<span class="hljs-section">[::2, ::-1]</span>  <span class="hljs-comment"># 隔一行取，并且每行的数字反序输出</span>
输出内容：
array(<span class="hljs-section">[[18,  9, 16, 51,  9, 47]</span>,
       <span class="hljs-section">[77,  9, 27, 33, 44, 97]</span>,
       <span class="hljs-section">[ 2, 83, 57, 20, 71, 87]]</span>)
nd<span class="hljs-section">[2:, (1,4,5)]</span>   <span class="hljs-comment"># 指定选择某几列的数字</span>
输出内容：
array(<span class="hljs-section">[[44,  9, 77]</span>,
       <span class="hljs-section">[41, 10, 71]</span>,
       <span class="hljs-section">[71, 83,  2]]</span>)
nd<span class="hljs-section">[(1,3,4), 2:]</span>  <span class="hljs-comment"># 指定选择某几行的数字</span>
输出内容：
array(<span class="hljs-section">[[58, 91, 63, 84]</span>,
       <span class="hljs-section">[35, 61, 10, 71]</span>,
       <span class="hljs-section">[20, 57, 83,  2]]</span>)
<span class="hljs-comment"># 单条件筛选，筛选出所有大于50的数字</span>
print(nd<span class="hljs-section">[nd&gt;50]</span>)
<span class="hljs-comment"># 多条件筛选，筛选出所有大于50但小于70的数字</span>
print(nd<span class="hljs-section">[(nd&gt;50) &amp; (nd&lt;70)]</span>)
<span class="hljs-comment"># 多条件筛选，筛选出小于10或者是大于90的</span>
print(nd<span class="hljs-section">[(nd&lt;10) | (nd&gt;90)]</span>)
nd<span class="hljs-section">[(1,2,3,4), (1,2,4,3)]</span>  <span class="hljs-comment"># 花式索引。规则，要取的每个元素的行和列索引，分别组成行的索引数组和列的索引数组。</span>
输出内容：
array(<span class="hljs-section">[74, 33, 10, 57]</span>)
</code></pre>
<p>注意，花式索引的用法如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/810dfd3a429245c3871361d5819191fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlsI_kupE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965899&amp;x-signature=XCh1kZuJyhnnqebgaPRlkzD0k%2BA%3D" alt="2.png" loading="lazy"/></p>
<ul>
<li>三维数组的索引操作</li>
</ul>

<pre><code class="hljs language-lua" lang="lua">nd = np.arange(<span class="hljs-number">18</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)  # 生成一个三维数组
输出内容：
array(<span class="hljs-string">[[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8]]</span>,
       <span class="hljs-string">[[ 9, 10, 11],
        [12, 13, 14],
        [15, 16, 17]]</span>])
# 取三维数组每组的第一行数据。
# 参数包含<span class="hljs-number">3</span>个部分
# 第一个参数指定要取哪些组
# 第二个参数指定要取第几行
# 第三个参数指定要取哪几列的值
nd[:, <span class="hljs-number">0</span>, :]
输出内容：
array(<span class="hljs-string">[[ 0,  1,  2],
       [ 9, 10, 11]]</span>)
nd[:, :, <span class="hljs-number">0</span>]   # 取所有行的第一列的值
输出内容：
array(<span class="hljs-string">[[ 0,  3,  6],
       [ 9, 12, 15]]</span>)
nd[:, ::<span class="hljs-number">2</span>, ::<span class="hljs-number">2</span>]   # 隔一行隔一列取值
输出内容：
array(<span class="hljs-string">[[[ 0,  2],
        [ 6,  8]]</span>,
       <span class="hljs-string">[[ 9, 11],
        [15, 17]]</span>])
</code></pre>
<h4 data-id="heading-11">2.5 变换数组形态</h4>
<p>数组的形态变换主要涉及到重塑、展平、堆叠、拼接和分割。</p>
<h5 data-id="heading-12">2.5.1 重塑reshape（重点）</h5>
<p>使用reshape可以将一个数组转化为一个任意形状的数组。注意，转换时必须使元素能够对齐。</p>
<pre><code class="hljs language-lua" lang="lua">nd = np.arange(<span class="hljs-number">18</span>)   # 生成一个<span class="hljs-number">18</span>个元素的一维数组
nd.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)  # 将一维变成二维
输出结果：
array(<span class="hljs-string">[[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17]]</span>)
nd.reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)    # 元素个数能对齐可以生成
输出结果：
array(<span class="hljs-string">[[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8]]</span>,
       <span class="hljs-string">[[ 9, 10, 11],
        [12, 13, 14],
        [15, 16, 17]]</span>])
nd.reshape(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)   # 维度相乘和总的数值个数不符，元素无法对齐
输出结果：
<span class="hljs-comment">---------------------------------------------------------------------------</span>
ValueError Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_26616\<span class="hljs-number">1265043701.</span>py <span class="hljs-keyword">in</span> &lt;<span class="hljs-built_in">module</span>&gt;
<span class="hljs-comment">----&gt; 1 nd.reshape(2,4,3)</span>
ValueError: cannot reshape array of size <span class="hljs-number">18</span> into shape (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)
nd.reshape(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>)    # 从三维降到二维
输出结果：
array(<span class="hljs-string">[[ 0,  1,  2,  3,  4,  5,  6,  7,  8],
       [ 9, 10, 11, 12, 13, 14, 15, 16, 17]]</span>)
nd.reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)   # 任一维度设置成<span class="hljs-number">-1</span>表示该维度自动计算
输出结果：
array(<span class="hljs-string">[[[ 0,  1,  2],
        [ 3,  4,  5]]</span>,
       <span class="hljs-string">[[ 6,  7,  8],
        [ 9, 10, 11]]</span>,
       <span class="hljs-string">[[12, 13, 14],
        [15, 16, 17]]</span>])
注意，一次只能有一个维度的值设置为<span class="hljs-number">-1</span>让numpy自行计算。
</code></pre>
<h5 data-id="heading-13">2.5.2 展平flatten（重点）</h5>
<p>展平操作就是将多维数组变成一维的数组，俗称降维操作。</p>
<pre><code class="hljs language-ini" lang="ini">nd.flatten()    <span class="hljs-comment"># 横向展平，将多维降为一维</span>
输出内容：
array(<span class="hljs-section">[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
       17]</span>)
nd.flatten(<span class="hljs-attr">order</span>=<span class="hljs-string">'F'</span>)   <span class="hljs-comment"># 按列方向进行拼接展平</span>
输出内容：
array(<span class="hljs-section">[ 0,  6, 12,  1,  7, 13,  2,  8, 14,  3,  9, 15,  4, 10, 16,  5, 11,
       17]</span>)
</code></pre>
<h5 data-id="heading-14">2.5.6 拼接concatenate（重点）</h5>
<p>concatenate和stack非常类似，都是用于把多个数组进行拼接。唯一区别是concatenate是使用参数来控制拼接方向。</p>
<pre><code class="hljs language-ini" lang="ini">np.concatenate(<span class="hljs-section">[nd1, nd2]</span>, <span class="hljs-attr">axis</span>=<span class="hljs-number">0</span>)    <span class="hljs-comment"># 0轴是竖直方向进行拼接，必须保证两个数组的列数一致</span>
np.concatenate(<span class="hljs-section">[nd1, nd2]</span>, <span class="hljs-attr">axis</span>=<span class="hljs-number">1</span>)    <span class="hljs-comment"># 1轴是水平方向进行拼接，必须保证两个数组的行数一致</span>
</code></pre>
<h4 data-id="heading-15">2.6 数组的运算</h4>
<p>数组运算又叫通用函数运算，是指numpy的数组中的每个值都参与运算。这里面又分为数组与值之间的运算和数组与数组之间的运算两种情况。</p>
<p>通用函数运算会使用到numpy的广播机制，所谓广播机制是指当我们使用通用函数对两个数组进行计算时，通用函数会对这两个数组的对应元素进行运算，因此它要求这两个数组shape相同。如果形状不同时不一定能进行运算，要看情况。</p>
<p>一、数组与单个值之间的运算</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd1</span> = np.arange(<span class="hljs-number">18</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)
nd1 * 3    <span class="hljs-comment"># 直接将nd1中的每个元素乘以3</span>
</code></pre>
<p>二、数组与数组之间的运算</p>
<ul>
<li>数组形状一致</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd1</span> = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
<span class="hljs-attr">nd2</span> = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
nd1 * nd2     <span class="hljs-comment"># 两个数组形状一致，则会将每个数组对应位置的数字进行运算</span>
输出结果：
array(<span class="hljs-section">[[  0,   1,   4,   9]</span>,
       <span class="hljs-section">[ 16,  25,  36,  49]</span>,
       <span class="hljs-section">[ 64,  81, 100, 121]]</span>)
</code></pre>
<p>数组形状一致，可以利用广播机制对对应位置的数字进行运算。</p>
<ul>
<li>数组形状不同</li>
</ul>
<p>当两个NumPy数组的维度不同时，这两个Numpy数组不一定能够进行运算，是否能够运算取决于Numpy的广播机制。广播机制规则如下：</p>
<ol>
<li>如果两个数组的维数不同，则向较少维度的数组添加一个”1″以匹配两个数组的形状</li>
<li>如果两个数组在某个维度上的大小不同，但至少有一个数组的该维度大小为 1，则使用带有大小 1 的该维度的数组进行操作，以匹配另一个数组的形状；</li>
<li>如果两个数组在某个维度上的大小不同且都不为 1，则无法进行广播。对于不同形状的数组，通常需要通过重塑数组来进行匹配。</li>
</ol>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 广播规则一，维数不同，reshape较少维度数组以适配两个数组的形状</span>
import numpy as np
<span class="hljs-attr">a</span> = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment"># 形状为一维 (3,)，会自动reshape到(1, 3),相当于执行了a.reshape(1,3)</span>
<span class="hljs-attr">b</span> = np.array([[<span class="hljs-number">4</span>], [<span class="hljs-number">5</span>], [<span class="hljs-number">6</span>]])  <span class="hljs-comment"># 形状为 (3, 1),注意，必须有一个维度的值为1，否则无法计算</span>
<span class="hljs-comment"># 可以进行广播计算</span>
<span class="hljs-attr">result</span> = a + b
print(result)
<span class="hljs-comment"># 广播规则二，维数相同，但两个数组在某个维度上的大小不同，且至少有一个数组的该维度大小为 1</span>
import numpy as np
<span class="hljs-attr">a</span> = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])  <span class="hljs-comment"># 形状为 (2, 3)</span>
<span class="hljs-attr">b</span> = np.array([[<span class="hljs-number">10</span>], [<span class="hljs-number">11</span>]])  <span class="hljs-comment"># 形状为 (2, 1)</span>
<span class="hljs-comment"># 可以进行广播计算</span>
<span class="hljs-attr">result</span> = a + b
print(result)
<span class="hljs-comment"># 广播规则三，如果两个数组在某个维度上的大小不同且都不为 1，则无法进行广播</span>
import numpy as np
<span class="hljs-attr">a</span> = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])  <span class="hljs-comment"># 形状为 (2, 3)</span>
<span class="hljs-attr">b</span> = np.array([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])  <span class="hljs-comment"># 形状为 (2, 2)</span>
<span class="hljs-comment"># 无法进行广播计算</span>
<span class="hljs-attr">result</span> = a + b
print(result)
</code></pre>
<p>如果是多维数组之间进行运算，应尽量保证形状相同，否则因为numpy去调整数组的形状后，很容易产生计算错误。</p>
<h3 data-id="heading-16">三、矩阵运算</h3>
<p>矩阵乘法规则：矩阵A的列数必须等于矩阵B的行数，才能相乘。 A(M行，N列) * B(N行，P列) = C(M行，P列)， 且，A中行号i与B中列号j相同时相乘，再求和即可。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87ff0f079c014db9b3075fb5b1f6d9f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlsI_kupE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965899&amp;x-signature=vwrdD7%2BH%2BW5LtS2vMf1E%2BFdNlY8%3D" alt="3.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab867d79859f4f0ab6e46135368bfe16~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlsI_kupE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965899&amp;x-signature=DbxtHMpmS2RxrAbxlEzAG2v493o%3D" alt="4.png" loading="lazy"/></p>
<p>结果矩阵中，9的来源为：<code>1*3+3*2=9</code>，19的来源为：<code>5*3+2*2=19</code>，12的来源为：<code>0*4+4*3=12</code></p>
<pre><code class="hljs language-css" lang="css"># 定义数组<span class="hljs-selector-tag">A</span>为<span class="hljs-number">3</span>行<span class="hljs-number">4</span>列
<span class="hljs-selector-tag">A</span> = np<span class="hljs-selector-class">.array</span>(<span class="hljs-selector-attr">[[11,12,13,14]</span>,<span class="hljs-selector-attr">[21,22,23,24]</span>,<span class="hljs-selector-attr">[31,32,33,34]</span>])
# 定义数组<span class="hljs-selector-tag">B</span>为<span class="hljs-number">4</span>行<span class="hljs-number">2</span>列
<span class="hljs-selector-tag">B</span> = np<span class="hljs-selector-class">.array</span>(<span class="hljs-selector-attr">[[41,42]</span>, <span class="hljs-selector-attr">[51,52]</span>, <span class="hljs-selector-attr">[61,62]</span>, <span class="hljs-selector-attr">[71, 72]</span>])
# 则最终矩阵乘法的结果为<span class="hljs-number">3</span>行<span class="hljs-number">2</span>列
print(np<span class="hljs-selector-class">.dot</span>(<span class="hljs-selector-tag">A</span>, <span class="hljs-selector-tag">B</span>))
# 输出结果为：
'''
<span class="hljs-selector-attr">[[2850 2900]</span>
 <span class="hljs-selector-attr">[5090 5180]</span>
 <span class="hljs-selector-attr">[7330 7460]</span>]
'''
</code></pre>
<p>其实明白了运算规则，即使使用最原始的Python也一样可以快速搞定</p>
<pre><code class="hljs language-less" lang="less"># <span class="hljs-selector-tag">A</span>中的每一行与<span class="hljs-selector-tag">B</span>中的第一列相乘，得到结果<span class="hljs-selector-tag">C</span>中的第一列，<span class="hljs-selector-tag">A</span>中的每一行与<span class="hljs-selector-tag">B</span>中的第二列相乘，得到结果<span class="hljs-selector-tag">C</span>中的第二列
<span class="hljs-selector-tag">listA</span> = <span class="hljs-selector-attr">[[11,12,13,14]</span>,
         <span class="hljs-selector-attr">[21,22,23,24]</span>,
         <span class="hljs-selector-attr">[31,32,33,34]</span>]
<span class="hljs-selector-tag">listB</span> = <span class="hljs-selector-attr">[[41,42]</span>,
         <span class="hljs-selector-attr">[51,52]</span>,
         <span class="hljs-selector-attr">[61,62]</span>,
         <span class="hljs-selector-attr">[71, 72]</span>]
<span class="hljs-selector-tag">listC</span> = <span class="hljs-selector-attr">[[0,0]</span>,<span class="hljs-selector-attr">[0,0]</span>,<span class="hljs-selector-attr">[0,0]</span>]  # 初始化为<span class="hljs-number">3</span>行<span class="hljs-number">2</span>列的列表
# 循环<span class="hljs-selector-tag">B</span>的列数
<span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(listB[<span class="hljs-number">0</span>])):
    # 循环<span class="hljs-selector-tag">A</span>的行数
    <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(listA)):
        <span class="hljs-selector-tag">sum</span> = <span class="hljs-number">0</span>
        # 循环<span class="hljs-selector-tag">A</span>的列数，由<span class="hljs-selector-tag">A</span>的行和列取得每个数，并与<span class="hljs-selector-tag">B</span>的列相乘再求和
        <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">ai</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(listA[a])):
            <span class="hljs-selector-tag">sum</span> += (listA[a][ai] * listB[ai][b])
        <span class="hljs-selector-tag">listC</span><span class="hljs-selector-attr">[a]</span><span class="hljs-selector-attr">[b]</span> = <span class="hljs-selector-tag">sum</span>
<span class="hljs-selector-tag">print</span>(listC)
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[python探本] 内存数据存储机制]]></title>    <link>https://juejin.cn/post/7573310642959613990</link>    <guid>https://juejin.cn/post/7573310642959613990</guid>    <pubDate>2025-11-17T07:35:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573310642959613990" data-draft-id="7573002274324660270" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[python探本] 内存数据存储机制"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2025-11-17T07:35:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="rimoyee"/> <meta itemprop="url" content="https://juejin.cn/user/564483199874953"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [python探本] 内存数据存储机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/564483199874953/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    rimoyee
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T07:35:28.000Z" title="Mon Nov 17 2025 07:35:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎙️ 前言</h2>
<p>python是一门迷惑性很强的编程语言。</p>
<p>在刚开始接触的时候, 大学期间让人头疼的编程语言突然从面目狰狞的C变成了python。直接无痛入门。</p>
<p>从头到尾敲完一本《python编程-从入门到实践》, 总觉着自己牛逼坏了, 这不全都掌握了, 小小python一举拿下。</p>
<p>后面再去接触爬虫, 一整个大傻眼。这都啥? 大脑一片空白。😣</p>
<p>再回头重新反思自己的学习道路, 发现很大的缺陷就在于一直都是按照书本上或者是视频上的案例在誊抄代码, 并没有形成自己的编程思维; 以及底层的数据结构仍然是不了解状态。尤其是当ai工具出现之后, 本身就站立不住的腿多了这条拐杖, 更是拿走后一步都走不远。</p>
<p>已经拿到了python这把利器, 却无法充分发挥它的效用, 通过自己的尝试去落地有趣好玩的项目, 实在是件蛮遗憾的事情。</p>
<p>抛弃掉自己的自负, 踏踏实实回头重新梳理基础。不仅仅是被动接收, 而是理解为什么要这么设计? 需求可以用这种方式实现, 换种方式可不可以? 更新的版本中有没有提供更好用的模块, 从而避免自己重复造轮子?</p>
<p>为此我重新梳理了自己的学习笔记, 希望不仅仅是对我, 还是对像我一样仍然困在半路的苦行者, 能有一点点帮助。</p>
<h2 data-id="heading-1">🗂️ 存储管理系统</h2>
<p>程序中直接使用的数据保存在计算机的内存储器(简称<strong>内存</strong>)中, 内存可以<strong>通过CPU直接访问</strong>。暂时不使用的数据存储在外存储器(磁盘、光盘等, 简称<strong>外存</strong>)中, 如果想要读取外存中的数据, 需要先装入内存, 然后CPU才能正常使用。</p>
<p>内存存储的结构是线性的, 每个单元的大小相同, 可以保存一个单位大小的数据。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35180c7a39df429095b6683261acd303~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=UCC04F7OpGj%2FAH2Ba82JfJFkQEk%3D" alt="image-20251114105523498.png" loading="lazy"/></p>
<p>为了方便访问, <strong>每个存储单元都有一个地址(数据标识)</strong>, 在程序执行时, 直接找到地址就可以读取存储的数据内容。
同时, 程序在运行时会处理各种各样的数据, 如果数据存储在相邻的一块或者几块区域, 访问就会很方便。
内存中的存储单元是有限的, 所以要做到合理的分配和利用。</p>
<p>python提供<strong>存储管理系统</strong>来负责数据的存储和管理工作, 不需要像C和C++一样, 手动分配和回收内存, 大大提升了编写代码的便捷性。</p>
<p>同时python作为<strong>面向对象</strong>的语言, <strong>将数据和操作数据的方法都封装在对象中, 通过和对象的交互来完成任务</strong>。
在程序运行的过程中, 不断建立对象并使用它们, 创建的每个对象都有一个确定的唯一标识(即地址), 用于识别和使用这个对象。在一个对象的存续期间, 地址是保持不变的。</p>
<p>如何去查看对象在程序运行时的地址标识?</p>
<p>通过内置函数<code>id()</code></p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(a)))  <span class="hljs-comment"># 通过hex()将地址转化为十六进制, 方便观看</span>
<span class="hljs-comment"># 0x7ffb06ab4ad8  </span>
</code></pre>
<p>同时可以也通过<code>is</code>和<code>is not</code>关键字来判断是否是同一个对象, 这种方法就是通过对比地址来判断的</p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
b = <span class="hljs-number">10</span>
c = <span class="hljs-number">20</span>
<span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)  <span class="hljs-comment"># True</span>
<span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> c)  <span class="hljs-comment"># False</span>
<span class="hljs-built_in">print</span>(b <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> c)  <span class="hljs-comment"># True</span>
</code></pre>
<p>上面的代码有个很有意思的现象, 会发现定义的变量a和变量b是一个对象, 即内存中存储的地址是一个。</p>
<p>为什么会这样?</p>
<p>这就涉及到了内存中数据的存储方式。内存中, 包含有三个区域: <strong>代码区、栈区和堆区</strong>。</p>
<p>(1) <strong>代码区</strong>: 存储编写的代码</p>
<p>(2) <strong>栈区</strong>: 存储变量名和地址, 以及函数调用相关信息, 遵循LIFO(先进后出)原则, 存储小型、临时数据</p>
<p>(3) <strong>堆区</strong>: 存储真正的变量数据, 无序存储, 生命周期较长, 存储复杂或大型数据</p>
<p>下面先通过栈与堆的存储机制来了解这三个区域都是如何工作的。</p>
<h2 data-id="heading-2">🛒 栈与堆的存储</h2>
<p>上面我们提到, 内存中存储了大量的数据和操作方法, 均封装在对象中, 可以称之为<strong>数据对象</strong>。这些数据对象被存储在容器中, 容器支持对这些数据存储、管理和使用。</p>
<p><strong>栈和队列都是保存数据元素的容器</strong>, 是计算中最广泛的<strong>缓存结构</strong>。主要用于在计算过程中保存临时数据, 这些数据都是在计算中发现或者产生的, 在后面的计算中可能使用它们。</p>
<p>在栈区主要使用栈来操作数据, 下面先来介绍一下栈的机制。</p>
<h3 data-id="heading-3">🤔 栈是什么?</h3>
<p>栈是限制在一端进行插入操作和删除操作的线性表, 允许进行操作的一端称为"栈顶", 另一固定端称为"栈底", 当栈中没有元素时称为"空栈"。栈内元素遵循LIFO(先进后出)的原则。</p>
<p>栈的机制如下图所示:  <code>s1 = (a1,a2,...,an)</code></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e056b484fca4a76ac5364231245c18b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=kjWHHfwINQrDTrAho%2FO2ZHFICu8%3D" alt="image-20251114150244267.png" loading="lazy"/></p>
<p>栈的抽象数据类型(预定义的操作):</p>
<ul>
<li>栈的创建 (创建一个空栈)</li>
<li>判断栈是否为空</li>
<li>将元素压入栈中 (也称进栈或入栈)</li>
<li>从栈中弹出元素并将其返回 (也称退栈或出栈)</li>
<li>检查栈元素 (访问最后入栈元素)</li>
</ul>
<p><strong>python中的栈机制</strong></p>
<p>三个区域的存储情况如下图所示</p>
<p><strong>栈区中存储的是对象的引用(指针)</strong>,也就是说存储的并不是数据, 真正的数据存储在堆区中。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e420e7d5ea9410e83eedc08417f3660~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=yW4ccDoyGnE00iM%2FheWFrUyQbh4%3D" alt="image-20251114164920222.png" loading="lazy"/></p>
<h3 data-id="heading-4">🤔 堆是什么?</h3>
<p>上面说到, 栈本质上是一种线性表, 而python中的 "堆", 并不是一种固定的数据结构, 而是解释器向操作系统申请的动态内存区域, 由python的内存管理器在这个区域内进行灵活分配。</p>
<p>在区域的内部, python使用<strong>pymalloc分配器</strong>进行管理。</p>
<p>下面是堆区总体结构图:</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed6169f5d8e44cbebcb03ca87fb5a519~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=%2B2eXtnZ0%2BKrmhLfypUtwSQ3fgc8%3D" alt="image-20251114153418482.png" loading="lazy"/></p>
<h2 data-id="heading-5">🗑️ 垃圾回收机制</h2>
<p>内存空间是有限的, 既然有存储, 就必然有回收。</p>
<p>python使用<strong>引用计数</strong>作为主要机制, 辅以<strong>标记-清除</strong>和<strong>分代回收</strong>来处理循环应用问题。</p>
<p><strong>引用计数</strong></p>
<p>如下图所示, 在堆区中, 每个对象都包含一个引用计数, 用于统计当前对象被引用的次数。当引用计数为0时, 该对象被垃圾回收机制回收。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/43ba327faa8c4834b8626cb7430c4ee8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=5sUvCz%2B%2BtpjRJPouAsLB21iNRY4%3D" alt="image-20251117112540368.png" loading="lazy"/></p>
<p>可以通过<code>sys.getrefcount()</code>方法来查看引用计数的数量</p>
<p>📍 Note: 需要在python交互式解释器下执行, 在其他环境下, 会做优化处理, 导致结果不符</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">532</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>y = x
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.getrefcount(x)
<span class="hljs-number">3</span>
</code></pre>
<p><strong>🎃 一个有趣的尝试</strong></p>
<p>定义变量a和b, 并存储到变量c中, 查看各个变量的引用计数</p>
<pre><code class="hljs language-ini" lang="ini">&gt;&gt;&gt; <span class="hljs-attr">a</span> = <span class="hljs-number">10</span>
&gt;&gt;&gt; <span class="hljs-attr">b</span> = <span class="hljs-number">20</span>
&gt;&gt;&gt; <span class="hljs-attr">c</span> = [a,b]
&gt;&gt;&gt; sys.getrefcount(a)
4294967295
&gt;&gt;&gt; sys.getrefcount(b)
4294967295
&gt;&gt;&gt; sys.getrefcount(c)
2
</code></pre>
<p>在上面的代码中, 会发现a和b的计数数值尤其大。按道理来说不应该a和b的应用计数都是1吗?</p>
<p>🔍 原因分析</p>
<p>小整数对象(通常在-5~256)会被缓存和复用, 这些缓存对象的应用计数机制被优化掉了, 当<code>sys.getrefcount()</code>检测到这种情况时, 会返回一个特殊值。</p>
<p>在堆区总体结构图中, 可以看到在对象池/缓存池中, 有小整数池。常用的小整数对象存储在这里, 避免频繁创建和销毁, 减少了内存分配的开销。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d760f70b7404bfb90b06a3924a2b1aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=kJQfnoj23eBM9jgQDT4tdPic7OA%3D" alt="image-20251116101843128.png" loading="lazy"/></p>
<h2 data-id="heading-6">🔎 相同对象判断 <code>==</code> 与 <code>is</code></h2>
<p>在 <em>⌈存储管理系统⌋</em> 的章节中, 我们了解到可以使用<code>is</code>关键字来判断是否是同一个对象。</p>
<p>同时, 我们也可以通过<code>==</code>运算符来判断两者的值是否相同, 那么在使用的时候, 这两者有什么需要注意的吗?</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 定义三个变量, 这三个变量的值是一样的</span>
s1 = <span class="hljs-string">"helloworld"</span>
s2 = <span class="hljs-string">"hello"</span> + <span class="hljs-string">"world"</span>
s3 = <span class="hljs-string">""</span>.join([<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>])

<span class="hljs-built_in">print</span>(s1, s2, s3)  <span class="hljs-comment"># helloworld</span>

<span class="hljs-comment"># 看一下这些对象的地址</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(s1)))  <span class="hljs-comment"># 0x2f489ed91f0</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(s2)))  <span class="hljs-comment"># 0x2f489ed91f0</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(s3)))  <span class="hljs-comment"># 0x2f489fa3570</span>
</code></pre>
<p>查看地址后发现, <code>s1</code>和<code>s2</code>的地址是一样的, 但是<code>s3</code>的地址却不同。</p>
<p>我们分别使用<code>==</code>和<code>is</code>来判断这些变量</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(s1 == s2)  <span class="hljs-comment"># True</span>
<span class="hljs-built_in">print</span>(s1 == s3)  <span class="hljs-comment"># True</span>

<span class="hljs-built_in">print</span>(s1 <span class="hljs-keyword">is</span> s2)  <span class="hljs-comment"># True</span>
<span class="hljs-built_in">print</span>(s1 <span class="hljs-keyword">is</span> s3)  <span class="hljs-comment"># False</span>
</code></pre>
<p>🙋‍ 通过上面的案例, 我产生了下面的疑问:</p>
<p>❓ 问题1: 为什么<code>s3</code>和<code>s1</code>与<code>s2</code>的地址不同?</p>
<p>❓ 问题2: <code>==</code>和<code>is</code>的底层判断机制是怎样的? 为什么会有不一样的返回结果?</p>
<h3 data-id="heading-7">💡 <strong>字符串驻留机制</strong></h3>
<p>python的一种优化技术, 它保存不可变对象(如字符串)的唯一副本, 当需要时, 让多个应用指向这个副本, 以节省内存。</p>
<p>但并不是所有的字符串都会被驻留, 字符串的创建方式会影响它们是否被驻留(<code>Interned</code>)。</p>
<p>自动驻留的规则:</p>
<ul>
<li>编译时常量: 在代码编译时就能确定的字符串字面量</li>
<li>短字符串: 通常只包含字母、数字、下划线的短字符串</li>
<li>标识符: 变量名、函数名等</li>
</ul>
<p>🙋‍ 如果在定义字符串变量的时候加入空格会怎么样?</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">&gt;&gt;&gt; </span>s1 = <span class="hljs-string">"hello world"</span>  
<span class="hljs-meta">&gt;&gt;&gt; </span>s2 = <span class="hljs-string">"hello"</span> + <span class="hljs-string">" "</span> + <span class="hljs-string">"world"</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s1 <span class="hljs-keyword">is</span> s2
<span class="hljs-literal">False</span>
</code></pre>
<p>在python交互式解释器中查看, 可以看到因为包含有空格, 定义的对象并没有被驻留, 所以<code>s1</code>和<code>s2</code>并不是同一个对象。</p>
<p>⬆️ 解答问题1</p>
<p>了解上面的知识点之后, 再去分析上面的代码</p>
<p>(1) <code>s1</code>是一个字符串字面量, 在编译时被创建, 会被驻留</p>
<p>(2) <code>s2</code>作为表达式, 在编译时会被优化成字符串字面量, 因此和<code>s1</code>是同一个对象</p>
<p>(3) <code>s3</code>是在运行时通过<code>join</code>方法动态创建的字符串, 无法在编译时确定结果, 因此并不会被驻留优化, 是一个新的字符串对象</p>
<p>通过上面的分析, 我们就了解了为什么会有值相同但地址不同的现象。</p>
<p>⬆️ 解答问题2</p>
<p>调用<code>==</code>来比对两个变量的值时, 调用对象的<code>__eq__()</code>方法(继承自<code>object</code>), 如下图所示</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/195c450a35414b198bb683dd2915a5d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=3XHh0dbrrAsd2NM7U28iA81cSyI%3D" alt="image-20251117110420927.png" loading="lazy"/></p>
<p>而上面的案例中, 两个变量的类型是字符串, <code>str()</code>方法会重写继承的<code>__eq__()</code>方法, 使得判断的时候比较的是两者的值, 而不是地址。</p>
<p>而调用<code>is</code>比较两个变量时, 比较的就是两者的地址是否相同。</p>
<p>📍 Tips: 内存中存储的常量, 如<code>True</code>, <code>False</code>, <code>None</code>, 判断的时候直接使用<code>is</code>关键字, 不要用<code>==</code>。因为这些常量在内存中的存储地址只有一个, 通过<code>is</code>去判断地址即可。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[实时光线追踪加速硬件结构（详细版）]]></title>    <link>https://juejin.cn/post/7573225720697536564</link>    <guid>https://juejin.cn/post/7573225720697536564</guid>    <pubDate>2025-11-17T06:47:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720697536564" data-draft-id="7490815158190571546" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="实时光线追踪加速硬件结构（详细版）"/> <meta itemprop="keywords" content="游戏,GPU,计算机图形学"/> <meta itemprop="datePublished" content="2025-11-17T06:47:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="像素之境"/> <meta itemprop="url" content="https://juejin.cn/user/721729778626808"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            实时光线追踪加速硬件结构（详细版）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/721729778626808/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    像素之境
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:47:42.000Z" title="Mon Nov 17 2025 06:47:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="atom-one-dark-reasonable">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-keyword,.hljs-operator,.hljs-pattern-match{color:#f92672}.hljs-function,.hljs-pattern-match .hljs-constructor{color:#61aeee}.hljs-function .hljs-params{color:#a6e22e}.hljs-function .hljs-params .hljs-typing{color:#fd971f}.hljs-module-access .hljs-module{color:#7e57c2}.hljs-constructor{color:#e2b93d}.hljs-constructor .hljs-string{color:#9ccc65}.hljs-comment,.hljs-quote{color:#b18eb1;font-style:italic}.hljs-doctag,.hljs-formula{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>近几年一些大型游戏开始支持<strong>光线追踪渲染</strong>，在设置中开启光追后，画质能有明显的提升。但要实现这种<strong>实时的光追渲染</strong>并不简单，其不仅需要游戏中编写了相关的<strong>算法及程序</strong>，更需要你的<strong>电脑硬件</strong>支持。</p>
<p>但光追算法特殊，且计算量大，普通GPU是无法达成实时渲染要求的，目前各处理器厂商都是搭配专门的<strong>实时光线追踪加速硬件</strong>进行支持，比如<code>NVIDIA</code>的<code>RT Cores</code>，<code>AMD</code>的<code>Ray Accelerator</code>等等。</p>
<p>这篇文章我们主要理清<strong>实时光追加速硬件的大致结构和其实现原理</strong>，会偏向于广度，略过一些详细部分。因为光线追踪加速硬件是对光线追踪算法的实现，所以下面先对<strong>光线追踪算法</strong>做一些提及，再梳理<strong>硬件</strong>的知识。</p>
<h2 data-id="heading-0">1 光线追踪技术</h2>
<p>光线追踪是一种模拟现实世界，光线在场景中多次<strong>反射、折射</strong>的一个过程。所以光追算法里，物体所受光照除了主要来自光源直接照射外，还来自其它间接的光线。若能考虑到<strong>足够数量的间接光线</strong>，就可以得到更真实的渲染效果。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/27488e23cfe5463b9e8e3d9959e3001d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=PSNL4PPWD4sKarqDVddiWtfQ5Io%3D" alt="rays.png" loading="lazy"/></p>
<p>光线追踪属于全局光照技术的一种，起初较为完善的是“基于Whitted”风格的光线追踪，后续学者们在其基础上改善，衍生出许多其它算法，如：光子映射、梅特波利斯光照传输、双向路径追踪等。它们核心的步骤如下：</p>
<ol>
<li><strong>构建场景树</strong>：将场景按空间、物体（三角形组成）划分为一颗<strong>树形数据</strong>保存，方便第2步使用。</li>
<li><strong>光线求交</strong>：光线从光源出发，在<strong>场景树</strong>中查找，判断是与哪一个物体相交，计算具体的交点。</li>
<li><strong>光照效果计算</strong>：在相交点处要计算光线的辐射强度、亮度，进行微面元模拟、菲涅尔效果等等，记录这条光线光照效果。</li>
<li><strong>生成次级光线</strong>：交点处要根据物体材质产生<strong>次级光线</strong>（反射、折射、阴影光线），光线能量衰减到阈值，或者进入摄像机后结束。</li>
<li><strong>着色计算</strong>：每条光线都重复2,3,4步骤，直到所有的光线在场景中完成传播和计算。每个点的着色由其上方半空间内所有光线积分得到。</li>
</ol>
<p><strong>耗时的部分</strong>：</p>
<ul>
<li>光线与基元的求交：每秒数十亿的光线，数百万的三角形场景，每条光线要计算与哪个三角形相交，这个数量非常庞大。</li>
<li>点的着色：每个光线相交点需要计算辐射度、能量衰减、菲涅尔效果等，最终每个像素点还要对其上半空间的光线进行积分（一条光线包括其从光源多次反射折射）得到最终颜色。这一系列计算非常复杂。</li>
</ul>
<p>以上说的只是大概思想，具体算法会有所变化，再对应到光追硬件又会<strong>有所简化</strong>，具体在提到相关硬件架构时细述。</p>
<h2 data-id="heading-1">2 光线追踪管线</h2>
<p>光线追踪管线是对<strong>光线追踪技术</strong>实现过程的一个<strong>抽象</strong>，总体使用基于Whitted风格的光线追踪。现有的光追硬件多数都按照一个过程实现。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e95ba77713014ab9854e1e05c73240a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=BvYgfyBOCoATis%2FWn%2FfxmeChALQ%3D" alt="ray-tra-pipline.png" loading="lazy"/></p>
<ul>
<li><strong>加速结构构建</strong>：将给定的场景按照空间、<strong>基元</strong>（三角形）划分成一颗树形结构。</li>
<li><strong>主光线生成</strong>：相机向各像素点投射指定数量的光线。</li>
<li><strong>光线遍历</strong>：生成的主光线和次级光线（相交后折射/反射等产生）要在第一步生成的<strong>加速结构</strong>中遍历，判断与哪个叶子空间相交。</li>
<li><strong>光线求交</strong>：遍历得到的叶子空间中可能包含多个基元，要继续计算与哪个基于相交及交点坐标，并产生次级光线。</li>
<li><strong>着色</strong>：每个像素根据当前点材质、纹理、有贡献的光线，进行最终的着色计算。</li>
</ul>
<h2 data-id="heading-2">3 实时光线追踪硬件</h2>
<p>实时光线追踪硬件架构可以按专用性分成两类：</p>
<ul>
<li>一类是<strong>混合架构</strong>，结合CPU，GPU，优化算法、辅以部分硬件等方式实现。更多的可编程性，早期和移动端采用的较多。</li>
<li>另一类是<strong>专用架构</strong>，从一开始就是为光线追踪而设计，功能多用新的硬件直接实现，性能更佳。</li>
</ul>
<p>我们主要讲述的是一个大致结构，所以会提到多种架构的知识。以下是一个偏专用型光追架构的示意图。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0cbd642b80e24be7bde0a06e737bd24c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=%2B5g4oBvHgITIoz6d2QhQWNbsYXU%3D" alt="ray-trace.png" loading="lazy"/></p>
<p><strong>CPU</strong>：应用程序主体仍然在cpu运行，但编译后的着色器代码、场景数据、参数等要经过系统总线发送到光追加速硬件上执行。</p>
<ul>
<li><strong>着色器</strong>：有自定义<strong>光线生成着色器</strong>（初始主光线生成）、<strong>相交着色器</strong>（自定义几何体的相交检测）、命中/未命中等着色器。若光追硬件支持，那么着色器程序在使用硬件厂商提供的编译器<strong>编译</strong>之后发送。</li>
<li><strong>场景三角形</strong>：3d场景由众多三角形构成，需要将其发送到光追硬件用于构建<strong>加速结构</strong>。</li>
<li>其它配置：场景物体上用到的纹理贴图、摄像机位置、光源位置等配置。</li>
</ul>
<p><strong>TBU</strong>：（Tree Building Unit）构建器，根据<code>kd-Tree</code>算法或<code>BVH</code>算法构建一个<strong>树形加速结构</strong>，每一帧都需要根据场景的变化构建或<strong>更新加速结构</strong>，其结果在RTU上使用。</p>
<p><strong>RTU</strong>：（Ray Tracing Unit）光追单元，光线的生成、遍历、相交计算、着色计算在这个单元进行。</p>
<p><strong>External Memory</strong>：一个共享内存，使用的几何数据、加速结构等存储在这里。</p>
<h2 data-id="heading-3">4 TBU详细</h2>
<p>因为场景可能是<strong>动态变化</strong>的，所以每一帧，TBU都要构建出对应场景的<strong>加速结构</strong>，这是实现实时光追的一个重要前提条件。</p>
<p><strong>混合架构</strong>中不含TBU单元，而是利用CPU和一些其它方式实现，具体如下：</p>
<ul>
<li><strong>树的构建</strong>：混合架构中构建加速结构会让CPU实现，因为CPU的<strong>多级缓存</strong>和优秀的<strong>控制流</strong>，这两点适合树的构建过程。</li>
<li><strong>树的更新</strong>：若每帧都让CPU构建再传到光追硬件，这样的方式非常缓慢。还需要配合一个<code>GTU</code>（树更新单元）拟合变化的部分，再配合一些树改造、算法调整等方式达到实时构建的要求。</li>
</ul>
<p>硬件<code>TBU</code>一般有<code>kd-tree</code>或<code>BVH</code>算法实现的两种，这两者只要进行足够调优都能达到相近的性能。它们通常不支持编程，但为了支持<strong>动态更新场景</strong>，<code>TBU</code>会支持三条特殊<strong>指令</strong>：“更新节点”、“处理叶子”和“加载顶点”。CPU只需将变化了的部分几何数据发给TBU即可。</p>
<p>使用TBU硬件来构建加速结构的情况一般比使用CPU/GPU构建的速度快4倍左右。</p>
<h3 data-id="heading-4">4.1 使用SAH+BVH的TBU</h3>
<p>下面先大致介绍一下BVH算法，再叙述相关硬件结构，方便理解。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/839290c8281248749f3dd99659982bd0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=HTpGpky%2BI75jVBvJxZigXXXe%2BQE%3D" alt="BVH-struct.png" loading="lazy"/></p>
<p><strong>BVH</strong>（Bounding Volume Hierarchy）包围体层次结构</p>
<ul>
<li>先对场景空间进行二分，再对分割出的子场景进行二分。</li>
<li>每次分割递归时要为当前子空间中的所有几何体计算一个可以包围它们的<strong>包围盒</strong>（通常使用BBAA包围盒——立方体）。</li>
<li>一直分割到只剩一个或少量几个物体为止。</li>
<li>分割和计算所得包围盒存储在一个树形结构的数据中。</li>
</ul>
<p><strong>SAH</strong>（Surface Area Heuristic）：一种划分方法。进行空间二分时，根据包围盒的表面积和光线与包围盒相交的概率来选择划分点，以最小化求交计算的成本。</p>
<p>构建器整体架构如下图（a）所示：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7ff179f4cfc48da8757aabb766408ac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=jJDYpauN4ve6R6R7owq0ZWnrUHI%3D" alt="sah-bvh.jpg" loading="lazy"/></p>
<p><strong>DRAM</strong>：动态存储器。在构建开始之前，场景图元会被分配到各个DRAM对中。</p>
<p><strong>upper builder(上层构建器)</strong>：直接读写<code>DRAM</code>中的图元数据，负责构建层次结构的上层。</p>
<ul>
<li>该构建器包含划分单元、分箱单元以及一对 SAH计算器（详细参考下面的子树构建器）</li>
<li>上层构建器的工作较少，只有一个线程负责。</li>
</ul>
<p><strong>subtree builder（子树构建器）</strong>：如上右图（b）所示，负责构建上层构建器传来的子树。</p>
<ul>
<li><strong>Buffer(图元缓冲区)</strong>：有一排成对的buffer，每对中的一个Buffer先接收上层构建器划分来的图元，另一个缓冲区则保持为空。</li>
<li><strong>PUnit(分区单元)</strong>：从Buffer读取图元向量，它们的分割点由<code>Bin unit</code>和<code>SAH</code>计算得出，根据结果，分区单元对其Buffer中的图元进行划分，将结果写入另一个Buffer。在下一次递归划分时，两个Buffer的作用互换。</li>
<li><strong>Bin Unit(分箱单元)</strong>：每个<code>PUnit</code>连接到三个<code>Bin Unit</code>——Bin x/y/z它们分别处理图元AABB（包围盒）各轴的中心点，最后输出在三个轴上选择的分箱位置，以及用于计算这些分箱位置的原始图元AABB。</li>
<li><strong>SAH Calc(实现SAH算法的计算器)</strong>：<code>Bin Unit</code>输出的AABB及其选择的分箱位置被输入到SAH计算器中，这些计算器为每个轴上的每个分箱累积一个AABB和一个计数器。一旦所有图元都被累积，SAH计算器就会评估每个可能划分的SAH成本，并输出找到的最低成本划分，将划分信息反馈到<code>PUnit</code>。</li>
<li><strong>Main Control Logic(主控逻辑)</strong>：用于控制子树逻辑的运行、各单元的执行顺序、缓冲区的负载均衡等。</li>
<li><strong>子树的多线程</strong>：上层构建器是一个线程执行，划分到各子树后，每个子树都会生成一个新的线程来执行。一个线程由1个寄存器（存储当前划分图元在buffer中的开始与结束地址），1个划分方案（SAH计算得的划分信息），1个栈（划分图元时辅助操作用）和栈顶指针等组成。</li>
</ul>
<h3 data-id="heading-5">4.2 PLOCTree：另一种实现BVH的TBU</h3>
<p>PLOCTree是一种基于并行局部<strong>有序聚类</strong>（Parallel Locally-Ordered Clustering，PLOC）算法的树构建加速器。PLOC算法从树的底部开始构建，对所有图元的AABB包围盒进行聚类（距离较近的一些图元归为一类，为它们计算1个新的包围盒），逐层使用该方法，最终只有一个包围盒时整颗树构建完成。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a58b5a10ea44428ac10fa8c3dbb2420~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=3hj2mFT%2BStheJu%2BsGHzPfA3Rch8%3D" alt="ploctree-bvh.png" loading="lazy"/></p>
<ul>
<li>从左侧输入所有图元的AABB包围盒。</li>
<li>为每个包围盒的<code>x,y,z</code>坐标生成莫顿码，使用排序器按莫顿码排序（排序上相邻的其空间位置上也相邻）</li>
<li>将这些包围盒分给多个扫描流水线，每个流水线有1个扫描窗口将扫描的包围盒存入窗口缓冲区。</li>
<li>将2R+1个输入到2R个<strong>距离评估器</strong>中（<code>Distance Metric Evaluator DME</code>）。</li>
<li><strong>比较树</strong>（<code>Comparator Tree</code>）接收来自DME组的2R个距离作为输入，并输出具有最低距离的AABB的相对索引</li>
<li><strong>后处理模块</strong>（<code>Postprocessing</code>）从比较树的结果中将最相近的两个AABB合并，用一个新的AABB表示，再次从最左侧输入进行第二轮处理。</li>
</ul>
<h3 data-id="heading-6">4.3 FastTree：一个实现kd-tree算法的TBU</h3>
<p>BVH算法的一个固有问题是：<strong>同一级别的两个节点在空间上可能重叠</strong>（包围盒的重叠），因此在定位到命中之前可能会访问大量节点。kd树算法没有存储包围盒，不存在这个问题，但在处理图元时需要额外的处理步骤。</p>
<p><code>FastTree</code>架构图及功能描述如下：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d489d903e6b24a0987914b5a81553ca2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=oIzM%2FFdl5i2TXk%2BzsAwJ9rUHee8%3D" alt="FasterTree-kdTree.png" loading="lazy"/></p>
<ul>
<li><strong>SBCU(场景边界计算单元)</strong>：从右上角批量输入的图元中计算它们的<code>x, y, z</code>最大最小值更新为边界值。</li>
<li><strong>MCGU(莫顿码生成单元)</strong>：计算输入图元的包围盒，并为每个图元生成莫顿码。</li>
<li><strong>PSU(前缀和单元)</strong>：计算数组的前缀和，配合RSU单元进行排序。</li>
<li><strong>RSU(基数排序单元)</strong>：设计为多轮计数排序，用前缀和计算，依据莫顿码排序。</li>
<li><strong>LNGU(叶节点生成单元)</strong>：获取排序数组中相邻的两个莫顿码码字，相距较近基元的做为一组叶节点，否则单独作为一个叶节点。</li>
<li><strong>INGU(内部节点生成单元)</strong>：输入两个叶子节点的莫顿码，确定1个分割平面，将两个叶子节点划分到不同子空间,结果发送到位编码单元（BEU）。编码结果通过片上缓存写入片外存储器。</li>
<li><strong>PCU(路径压缩单元)</strong>：输入每个节点的莫顿码，查找其父节点，判断父节点是否为必要节点，不是则舍弃，直到找到一个必要节点。</li>
</ul>
<h2 data-id="heading-7">5 RTU详细</h2>
<p>这里选用一个资料较详细的<code>SGRT</code>架构做主要讲解，适当拓展其它架构知识。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a450140ae8d4bd5b151446a84cc7dfd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=7g3xNWqWqmtlISKxrjzMj8vWEy8%3D" alt="SGRT.png" loading="lazy"/></p>
<p>SGRT是一个移动端的实时光线追踪图形系统，属于混合型架构，没有<code>TBU</code>硬件，其加速结构在CPU构建。<code>SGRT</code>使用的静态场景测试，暂未添加<strong>树更新单元</strong>，但他的架构是为态场景设计的，只是暂未扩展，可做我们参考用。</p>
<p>SGRT拥有多个核心，每个核心都包含一个<code>T&amp;I</code>（遍历与相交）单元和一个<strong>SRP</strong>（三星可重构处理器）单元。各部分详细结构及功能如下：</p>
<h3 data-id="heading-8">5.1 SRP结构</h3>
<p><code>SRP</code>使用的是[Lee等人2011]中开发的GPU着色器核心，用于执行<strong>光线生成</strong>（初始生成的主光线、遍历、相交时产生的<strong>次级光线</strong>）、相交等各种光线<strong>着色器程序</strong>和<strong>着色计算</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a6f370233dbd44c3a7c2dfe1827a6a9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=eOQgrf98921davfM%2FyWWNyDfmrc%3D" alt="SRP.png" loading="lazy"/></p>
<p><strong>VLIW</strong>（超长指令字）引擎适用于通用计算，例如函数调用和分支选择。<strong>CGRA</strong>（粗粒度可重构阵列）使用SIMD架构（单指令多数据），用于高效执行密集型计算。</p>
<p>主机端调用<code>SGRT</code>提供的<strong>编译器</strong>，对着色器代码（光线生成、相交等）进行编译时，会针对<code>VLIW,CGRA</code>的特性进行处理，比如控制流语句在VLIW中执行，光线的计算在CGRA中执行。</p>
<p><strong>Configuration Memory</strong>：SRP提供的为设计人员自定义的一些<strong>配置</strong>用来辅助实现功能。</p>
<p><strong>FU</strong>（功能单元）： 内部的组件包括：<strong>本地缓冲区</strong>、<strong>算术逻辑单元</strong>（ALU）、输入和输出<strong>多路复用器</strong>以及<strong>寄存器文件</strong>（RF）。</p>
<h3 data-id="heading-9">5.2 光线生成与着色</h3>
<p><code>SGRT</code>架构的主光线生成直接由SRP执行光线生成着色器产生，在<strong>编译</strong>时，SGRT提供的编译器会为各类型的光线执行不同的内核代码，并为它们添加<strong>着色代码</strong>。生成的光线会被放到缓冲区，以便被批量分配给T&amp;I单元。</p>
<p><strong>光线生成单元</strong>：一些专用型光追架构中会单独用硬件实现<strong>主光线生成</strong>，可以为主光线按莫顿顺序（空间上排序）以提高缓存效率。还可以剔除在三角形背面生成的阴影光线，生成采样光线以支持分布式光线追踪和超级采样抗锯齿等。</p>
<p><strong>着色</strong>：部分硬件架构支持<strong>自定义着色代码</strong>，但<code>SGRT</code>架构的着色由编译时附加，具体如下：</p>
<ul>
<li>在<strong>编译</strong>时对不同的光线类型和是否命中分类（阴影光线未命中、其它光线命中等），添加不同的着色内核代码。</li>
<li>其他光线且命中的情况是计算量最大的，编译时为其添加的内核代码中会包括：中心坐标计算法向量、是否生成次级光线、纹理映射、<strong>光照计算</strong>。</li>
<li>当前光线计算出的颜色被添加到着色缓冲区中的先前颜色上；最终颜色由从给定像素生成的所有光线的颜色值<strong>累加得到</strong>。</li>
</ul>
<p><strong>光照计算</strong>：由于辐射度的计算方式复杂，实现成本高，且实现了的辐射度方法依然很难达到实时帧率要求，所以现在实时光追硬件中的光照计算几乎都使用更简单的<code>Phong</code>光照模型。</p>
<h3 data-id="heading-10">5.3 T&amp;I单元详细</h3>
<p>光线的遍历与相交计算是整个光追管线中<strong>最耗资源的阶段</strong>，所以多数光追架构中都含有<code>T&amp;I</code>单元，其硬件化程度高，多采用硬连线代替通用寄存器，且包含<code>TRV</code>和<code>IST</code>硬件。</p>
<p><code>SGRT</code>的<code>T&amp;I</code>由<strong>光线分配单元（RD）</strong> 、四个<strong>遍历单元（TRV）</strong> 和一个<strong>相交单元（IST）</strong> 组成。每个单元都通过一个内部缓冲区连接，缓冲区将光线从一个单元传递到其他单元。T&amp;I单元和SRP通过基于FIFO的<strong>专用接口</strong>进行通信。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a078ad273ec4ee2926dde265b63b366~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=%2BVsT0B6apyTIVjEDz2Nj7uddPtw%3D" alt="SGRT-T&amp;I.png" loading="lazy"/></p>
<p><strong>光线分配单元</strong>（<code>RD</code>）：从光线缓冲区中获取光线（主光线与次级光线），并首先将其分配给空闲的<code>TRV</code>（每个周期只提供一条光线）。</p>
<p><strong>TRV</strong>：将所给的光线在<code>TBU</code>所构建的加速结构中遍历，查找到与当前光线相交的<strong>叶子节点</strong>（包含1个或多个基元）</p>
<ul>
<li>每个TRV都由一个内存处理模块（输入缓冲区、RAU、L1缓存、短栈）和计算流水线组成。</li>
<li>TRV流水线的输出分为三条路径：一条反馈回路路径返回输入缓冲区，用于对内部节点进行迭代访问；</li>
<li>一条输出路径用于在光线到达叶节点时将光线发送到<code>IST</code>。</li>
<li>还有一条输出路径用于在光线完成<code>BVH</code>树遍历后将光线发送到<strong>SRP（着色资源处理器）</strong> 。</li>
<li><code>TRV</code>的<strong>计算流水线</strong>由4个浮点加法器、4个浮点乘法器和11个浮点比较器组成。</li>
</ul>
<p><strong>IST</strong>：计算当前光线与TRV所给的多个<strong>基元</strong>（一般是三角形）是否相交，及其交点。</p>
<ul>
<li>其由一个内存处理模块（输入缓冲区、RAU、L1缓存）和计算流水线组成。</li>
<li><code>IST</code>流水线的输出分为两条路径：一条反馈回路路径返回输入缓冲区，用于对同一叶节点中的三角形进行迭代测试；</li>
<li>还有一条输出路径用于将光线发送到<code>TRV</code>，以便访问下一个树节点。</li>
</ul>
<p><strong>三阶段相交计算</strong>：较好的T&amp;I硬件有<strong>三阶段相交测试单元</strong>，该单元将相交测试阶段分为三个阶段。</p>
<ul>
<li>第一阶段是光线平面测试：判断光线是否与三角形所在的平面有交点，没有则终止。</li>
<li>第二阶段是重心坐标测试：判断光线是否与该三角形有交点，没有则终止。</li>
<li>第三阶段是最终的命中点计算：计算确切的相交坐标。</li>
</ul>
<p><strong>包追踪与单光线追踪</strong>：T&amp;I可以设计为多条光线或单条光线一起进行处理，两者各有差别：</p>
<ul>
<li>包追踪（多条光线）：对与单个盒子相交的多条光线进行<code>SIMD</code>（单指令多数据）并行化，但由于分支发散问题，它不适用于次级光线。一般会应用光线重新排序、排序或调度算法以提高光线连贯性。</li>
<li>单光线追踪：每条光线都被视为一个单独的线程，这意味着在处理非相干光线时可以获得更高的硬件利用率。对于不连贯光线而言，单光线追踪更稳健。<code>SGRT</code>的T&amp;I就采用这种方式。</li>
</ul>
<h3 data-id="heading-11">5.4 计算架构</h3>
<p>光线追踪过程会产生大量的光线，对这些光线需要高并行性的处理和计算，T&amp;I的<code>SIMD</code>架构方式是较适合处理光线的方法之一。还有其它几种计算架构，以下是他们的使用情况：</p>
<p><strong>SIMD</strong>：每条光线都由相同的遍历程序处理，但使用数据不同，这一点很适合使用SIMD结构。只是光线在场景中反射、折射，与基元相交、未相交等情况存在许多分支指令情况，纯SIMD机制无法提供足够的灵活性。</p>
<p><strong>SIMD+SIMT</strong>：引入<code>SIMT</code>（单指令多线程）可以为一组SIMD硬件执行的作业中的分支指令提供更灵活的支持；与多线程集成，通过时间复用SIMD硬件来隐藏内存延迟。但这种模型不适合非相干光线追踪，因为它会导致<strong>分支发散</strong>和<strong>共享内存争用</strong>。</p>
<p><strong>MIMD</strong>（多指令多数据）：每个核心都有自己的光线缓冲区，有独立的指令流和数据流，增加多组指令获取、解码和分发逻辑。<code>MIMD</code>架构提供了最佳的执行灵活性，但更复杂，硅面积占用多。</p>
<h2 data-id="heading-12">6 总结</h2>
<p><strong>实时光追硬件</strong>根据面向的场景不同，其硬件化程度有很大差异，一般面向专用集成电路、专用集成处理器的情况，硬件程度高，可能有专门实现的<code>TBU</code>、<strong>光线生成、着色单元</strong>等硬件。它们虽然有更好的性能，但可编程性少、灵活度低。</p>
<p>面向<strong>通用处理器</strong>，也就是大众用户的情况，则要有一定的灵活性，通常支持部分<strong>自定义着色器</strong>程序。移动端限于空间、发热等条件，更多使用混合架构，即：树构建在CPU执行，配合一个异步构建的<strong>树更新单元</strong>，着色器的执行也可能与<code>GPU</code>共用。</p>
<p>PC端的相关研究较多，能达到更高的性能，好的实时光追硬件多会用TBU硬件、更适合光追的<code>MIMD</code>架构。光追硬件一般放到显卡中，作为<code>GPU</code>架构的一部分。</p>
<p><strong>光追效果与性能</strong>：光追渲染中，因为每个物体考虑到了更多的间接光线，所以画面效果更亮；阴影、镜面、倒影等效果更明显，更真实。高端光追硬件每秒可执行<strong>数亿~百亿</strong>根光线。</p>
<p>但实际应用中有高清像素、帧率的要求，高端的实时光追硬件也很容易产生<strong>噪点</strong>，一般会结合<strong>降噪算法</strong>后处理，<strong>光流插帧</strong>技术提升帧率等。软件端渲染一个场景时也不一定全用光追渲染，比如远处的场景使用传统<strong>光栅化渲染</strong>，近处场景用光追渲染，最后两者结合。</p>
<h2 data-id="heading-13">7 主要参考</h2>
<ol>
<li>A Hardware Unit for Fast SAH-optimised BVH Construction</li>
<li>PLOCTree: A Fast, High-Quality Hardware BVH Builder</li>
<li>FastTree: A Hardware KD-Tree Construction Acceleration Engine for Real-Time Ray Tracing</li>
<li>HART: A Hybrid Architecture for Ray Tracing Animated Scenes</li>
<li>MergeTree: a HLBVH constructor for mobile systems</li>
<li>MRTP: Mobile Ray Tracing Processor With Reconfigurable Stream Multi-Processors for High Datapath Utilization</li>
<li>RayCore: A ray-tracing hardware architecture for mobile devices</li>
<li>SGRT: A Mobile GPU Architecture for Real-Time Ray Tracing</li>
<li>A Reconfigurable SIMT Processor for Mobile Ray Tracing With Contention Reduction in Shared Memory</li>
<li>T&amp;I Engine: Traversal and Intersection Engine for Hardware Accelerated Ray Tracing</li>
<li>Toward Real-Time Ray Tracing: A Survey on Hardware Acceleration and Microarchitecture Techniques</li>
<li>TRaX: A Multicore Hardware Architecture for Real-Time Ray Tracing</li>
<li>光线追踪硬件加速方案综述</li>
<li>《全局光照》</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python入门到实战：网络请求与数据获取]]></title>    <link>https://juejin.cn/post/7573242085610176563</link>    <guid>https://juejin.cn/post/7573242085610176563</guid>    <pubDate>2025-11-17T08:10:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573242085610176563" data-draft-id="7572939250586910771" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python入门到实战：网络请求与数据获取"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2025-11-17T08:10:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="烤汉堡"/> <meta itemprop="url" content="https://juejin.cn/user/3563932375586313"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python入门到实战：网络请求与数据获取
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3563932375586313/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    烤汉堡
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:10:21.000Z" title="Mon Nov 17 2025 08:10:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">一、环境准备，安装requests库</h2>
<h3 data-id="heading-1">1.安装命令（终端执行）</h3>
<pre><code class="hljs language-python" lang="python"> <span class="hljs-comment">#安装requests库</span>
pip install requests -i https://pypi.tuna.tsinghua.edu.cn/simple/
<span class="hljs-comment">#(该方式是临时指定的,每次下载需要去cmd终端下载库 相对来说比较麻烦，每次添加库的时候就要去cmd终端去下载)</span>
</code></pre>
<h3 data-id="heading-2">2.解决安装超时的问题（配置国内镜像源）</h3>
<pre><code class="hljs language-python" lang="python">pip config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>.index-url https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<h6 data-id="heading-3"><strong>说明：默认连接Python官方仓库，国内镜像源（如清华源）可提升下载速度。</strong></h6>
<h2 data-id="heading-4">二、基本用法：发起GET请求</h2>
<h3 data-id="heading-5">1.导入模块与基础请求</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests <span class="hljs-comment">#导入requests库</span>
<span class="hljs-comment"># 在要获取数据的浏览器页面里，找到目标URL（以疾病查询页面为例）,键盘按下Fn+F12，查看是什么请求方式</span>
url = <span class="hljs-string">'https://www.youlai.cn/dise'</span>
<span class="hljs-comment"># 发起get请求，获取响应对象 将获取到的响应对象的结果给到变量res</span>
res = requests.get(url) 
<span class="hljs-comment"># 打印响应内容（如果响应结果是HTML文本内容）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"响应内容："</span>,res.text)
</code></pre>
<h3 data-id="heading-6">2.处理中文乱码问题</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
url = <span class="hljs-string">'https://www.tjwenming.cn/'</span>
res = requests.get(url)
<span class="hljs-comment"># 手动指定编码（根据目标网页的meta标签设置，此处以gb2312为例）</span>
res.encoding = <span class="hljs-string">'gb2312'</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'处理后的中午内容：'</span>,res.text)
</code></pre>
<p>调用encoding前
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bce0d84f852c4b6c9d13bb336241f93d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Ok5rGJ5aCh:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972330&amp;x-signature=umqPC17N76SSDKgpedcmdYWtBIc%3D" alt="628f3e95-898f-4d77-a032-162c7db7f13d.png" loading="lazy"/>
调用encoding后
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4b8bc3c9ad848bca09247983e316e10~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Ok5rGJ5aCh:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972330&amp;x-signature=rquQvudDyFSshS0D29PUtjqH7Lo%3D" alt="33a8a6bb-8de0-4500-9089-7971429fd69e.png" loading="lazy"/></p>
<h6 data-id="heading-7"><strong>关键步骤：</strong></h6>
<ul>
<li>检查网页源码中的&lt;metacharset="xxx"&gt;标签，获取编码格式（如utf-8、gbk、gb2312）。</li>
<li>通过response.encoding设置编码，确保中文正常显示。</li>
</ul>
<h2 data-id="heading-8">三、带参数的GET请求</h2>
<h3 data-id="heading-9">1.参数传递方式</h3>
<h4 data-id="heading-10">方式一：URL拼接参数（直接在URL中携带参数）</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
<span class="hljs-comment">#包含参数的完整URL（从浏览器复制）</span>
url=<span class="hljs-string">'https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1763364793381&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=2,3&amp;keyword=&amp;pageIndex=1&amp;pageSize=10&amp;language=zh-cn&amp;area=cn'</span>
res = requests.get(url)
<span class="hljs-built_in">print</span>(res.text)
</code></pre>
<h4 data-id="heading-11">方式二：通过params参数传递</h4>
<pre><code class="hljs language-python" lang="python">url = <span class="hljs-string">'https://careers.tencent.com/tencentcareer/api/post/Query'</span> <span class="hljs-comment"># 注意写基础的URL 不带后面的请求参数</span>
params = { <span class="hljs-comment"># 将请求参数通过字典的形式存起来，给到params</span>
    <span class="hljs-string">'timestamp'</span>: <span class="hljs-number">1763364793381</span>,
    <span class="hljs-string">'ountryId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'cityId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'bgIds'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'productId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'categoryId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'parentCategoryId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'attrId'</span>: <span class="hljs-string">'2,3'</span>, <span class="hljs-comment"># 注意参数为字符串类型</span>
    <span class="hljs-string">'keyword'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'pageIndex'</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">'pageSize'</span>: <span class="hljs-number">10</span>,
    <span class="hljs-string">'language'</span>: <span class="hljs-string">'zh-cn'</span>,
    <span class="hljs-string">'area'</span>: <span class="hljs-string">'cn'</span>
}
<span class="hljs-comment"># 发起请求时传递params参数</span>
res = requests.get(url,params=params)
<span class="hljs-built_in">print</span>(res.text)
</code></pre>
<h2 data-id="heading-12">四、获取二进制数据（图片、视频等）</h2>
<h3 data-id="heading-13">：下载网络图片并保存</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
url = <span class="hljs-string">'http://pic.enorth.com.cn/005/026/920/00502692031_21660ab6.jpg'</span>
res = requests.get(url)
<span class="hljs-comment">#如果请求网址对应的数据为图片视频音频</span>
<span class="hljs-comment">#获取数据的方式：响应对象.content---&gt;字节数据</span>
res_img = res.content 
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'1.jpg'</span>,<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:
    f.write(res_img)
</code></pre>
<h6 data-id="heading-14"><strong>关键点：</strong></h6>
<ul>
<li>二进制数据通过response.content获取，而非text。</li>
<li>文件扩展名需与内容类型匹配（如.gif、.mp4、.jpg）。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我为什么说全栈正在杀死前端？]]></title>    <link>https://juejin.cn/post/7573172586839834676</link>    <guid>https://juejin.cn/post/7573172586839834676</guid>    <pubDate>2025-11-17T08:15:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573172586839834676" data-draft-id="7573170756869701684" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我为什么说全栈正在杀死前端？"/> <meta itemprop="keywords" content="前端,JavaScript,后端"/> <meta itemprop="datePublished" content="2025-11-17T08:15:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"/> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我为什么说全栈正在杀死前端？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:15:42.000Z" title="Mon Nov 17 2025 08:15:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我又来了🤣。</p>
<p>打开2025年的招聘软件，十个资深前端岗位，有八个在JD（职位描述）里写着：“<strong>有Node.js/Serverless/全栈经验者优先</strong>”。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/396bd4a478b94074abdb22cf0bcd992c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972142&amp;x-signature=KgZ0NpU4hqp6nYYJQiiCF2T8pPI%3D" alt="50fb0729f6733fc5092ecfc91f063c6.jpg" loading="lazy"/></p>
<p>全栈 👉 成了我们前端工程师内卷的一种方式。仿佛你一个干前端的，要是不懂点BFF、不会配Nginx、不聊聊K8s，你都不好意思跟人说你是资深。</p>
<p>我们都在拼命地，去学Nest.js、学数据库、学运维。<strong>我们看起来，变得越来越全能了。</strong></p>
<p>但今天，我想泼一盆冷水🤔：</p>
<p><strong>全栈正在杀死前端。</strong></p>
<hr/>
<h4 data-id="heading-0"><strong>全栈到底是什么</strong></h4>
<p>我们先要搞清楚，现在公司老板们想要的全栈，到底是什么？</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/983308b05bc44a6987b2efdfb2ef63f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972142&amp;x-signature=rmdBMjFP0%2BDvXkU9IDhKJ6aceP0%3D" alt="image.png" loading="lazy"/></p>
<p>他们想要的，不是一个T型人才（在一个领域是专家，同时懂其他领域）。</p>
<p>他们想要的是：一个能干两个人（前端+后端）的活，但只需要付1.5个人的工资。</p>
<p>但一个人的精力，毕竟是有限的。</p>
<ul>
<li>当我花了3个月，去死磕K8s的部署和Nest.js的依赖注入时，我必然没有时间，去研究新出炉的<code>INP</code>性能指标该如何优化。</li>
<li>当我花了半周时间，去设计数据库表结构和BFF接口时，我必然没有精力，去打磨那个React组件的可访问性，无障碍（a11y）和动画细节。</li>
</ul>
<p>我们引以为傲的前端精神，正在被全栈的广度要求，稀释得一干二净。</p>
<p><strong>全栈的趋势，正在逼迫我们，从一个能拿90分的前端专家，变成一个前后端都是及格的功能实现者。</strong></p>
<hr/>
<h4 data-id="heading-1"><strong>关于前端体验</strong></h4>
<p>做全栈的后果，最终由谁来买单？</p>
<p><strong>是用户。</strong></p>
<p>我们来看看全栈前端主导下，最容易出现的受灾现场：</p>
<p><strong>1.能用就行的交互</strong></p>
<p>全栈思维，是功能驱动的。</p>
<p>数据能从数据库里查出来，通过API发到前端，再用v-for渲染出来，好了，这个功能完成了😁。</p>
<p>至于：</p>
<ul>
<li>列表的虚拟滚动做了吗？</li>
<li>图片的懒加载做了吗？</li>
<li>按钮的<code>loading</code>和<code>disabled</code>状态，在API请求时加了吗？</li>
<li>页面切换的骨架屏做了吗？</li>
<li>弱网环境下的超时和重试逻辑写了吗？</li>
<li>UI测试呢？</li>
</ul>
<p><strong>抱歉，没时间。我还要去写BFF层的单元测试。</strong></p>
<p><strong>2.无障碍，可访问性（a11y）</strong></p>
<p>你猜一个全栈，在用 <code>&lt;div&gt;</code> 还是 <code>&lt;button&gt;</code> 来实现一个按钮时，会思考 <code>aria-*</code> 属性吗？他会关心Tab键的焦点顺序吗？</p>
<p><strong>根本不会。</strong></p>
<p>因为可访问性这个东西，是纯粹的纯前端范围，它不属于全栈能力范围。</p>
<p><strong>3. 性能优化</strong></p>
<p>当一个全栈工程师的注意力，被数据库索引、Nginx缓存、Docker镜像大小给占满时，他还有多少脑容量，去关心LCP、CLS、Tree Shaking、Code Splitting？</p>
<p><code>useMemo</code>？<code>PureComponent</code>？能跑就行了，别搞那么复杂。</p>
<p><strong>前端，正在从用户体验的第一负责人，被降维成了全栈流程的最后一个环节——那个把数据显示出来UI就行。</strong></p>
<hr/>
<h4 data-id="heading-2"><strong>一个前端的专业性</strong></h4>
<p>最让我发慌的，是一种风气的转变。</p>
<p>五年前，我们团队，会为一个<strong>如何把白屏时间再减少100ms</strong>的议题，在白板前吵一个下午。我们会为<strong>该用<code>padding</code>还是<code>margin</code>来实现间距</strong> 这种像素级的细节，在CR（Code Review）里吵架。</p>
<p>现在呢？</p>
<p>CR时，大家都在聊：你这个BFF的Controller层，不该写业务逻辑、你这个数据库类型定义不规范。</p>
<p><strong>没人再关心那个前端按钮逻辑了。</strong></p>
<p>全栈，正在杀死前端的专业性。它让前端这个职业，变得不再纯粹，不再专注一个领域。</p>
<hr/>
<h4 data-id="heading-3"><strong>我不想做全栈开发😠</strong></h4>
<p>聊了这么多，我不是在贩卖焦虑，也不是在抵制学习后端知识。</p>
<p>作为8年老前端，我现在给自己的定位是：<strong>一个T型前端工程师。</strong></p>
<p>我必须是团队里，对浏览器渲染原理、JS性能优化、CSS布局、组件化架构、可访问性理解最深的那个人。这是我的前端身份，是我的技能。</p>
<p>我懂Node.js，是为了能和后端吵架时，提出更合理的BFF接口设计。</p>
<p>我懂Docker，是为了能理解我的代码，是如何在CI/CD上闪退的。</p>
<p>我懂SQL，是为了能理解为什么我的一个查询，会导致查询慢。</p>
<hr/>
<p>请大家别再神话全栈了😒。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/533b70c9236940c8819809215bc94615~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972142&amp;x-signature=A7U8o8c6C9mMuLLE5cHg7Wrw%2F7M%3D" alt="Suggestion.gif" loading="lazy"/></p>
<p>全栈的尽头，很可能是全废了，这个也不精，那个也不精。</p>
<p>我宁愿要做一个95分的前端专家，和一个95分的后端专家，让他们强强联手；</p>
<p>也不想要两个及格的全栈工程师，最终交付一个50分的、能跑就行的垃圾代码💩。</p>
<p>欢呼大家，尊重前端这个职业的专业性。</p>
<p>谢谢🙌</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Set 和 Map常用场景代码片段]]></title>    <link>https://juejin.cn/post/7573468493569179684</link>    <guid>https://juejin.cn/post/7573468493569179684</guid>    <pubDate>2025-11-17T08:23:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573468493569179684" data-draft-id="7571490332372172819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Set 和 Map常用场景代码片段"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2025-11-17T08:23:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MoMoDad"/> <meta itemprop="url" content="https://juejin.cn/user/2788017221151342"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Set 和 Map常用场景代码片段
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2788017221151342/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    MoMoDad
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:23:48.000Z" title="Mon Nov 17 2025 08:23:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、Set 实用代码片段</h3>
<h4 data-id="heading-1">1. 数组去重（基础版）</h4>
<p><strong>场景</strong>：接口返回数组、用户输入列表等需要快速去重。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 数组去重（支持基本类型，引用类型需额外处理）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">arr</span> - 待去重数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Array</span>} 去重后数组
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">uniqueArray</span> = (<span class="hljs-params">arr</span>) =&gt; [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];

<span class="hljs-comment">// 示例</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniqueArray</span>(arr)); <span class="hljs-comment">// [1, 2, 3, 'a']</span>
</code></pre>
<h4 data-id="heading-2">2. 检查数组是否有重复元素</h4>
<p><strong>场景</strong>：表单验证（如 “标签不可重复”）、数据校验。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 检查数组是否存在重复元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">arr</span> - 待检查数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} 是否有重复
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">hasDuplicates</span> = (<span class="hljs-params">arr</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr).<span class="hljs-property">size</span> !== arr.<span class="hljs-property">length</span>;

<span class="hljs-comment">// 示例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// true</span>
</code></pre>
<h4 data-id="heading-3">3. 集合操作（交集 / 并集 / 差集）</h4>
<p><strong>场景</strong>：权限对比（如 “用户权限与角色权限的交集”）、数据筛选。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-ini" lang="ini">// 交集：两个数组的共同元素
const <span class="hljs-attr">intersection</span> = (arr1, arr2) =&gt; {
  const <span class="hljs-attr">set2</span> = new Set(arr2)<span class="hljs-comment">;</span>
  return arr1.filter(<span class="hljs-attr">item</span> =&gt; set2.has(item))<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

// 并集：两个数组的所有元素（去重）
const <span class="hljs-attr">union</span> = (arr1, arr2) =&gt; [...new Set([...arr1, ...arr2])]<span class="hljs-comment">;</span>

// 差集：arr1 有但 arr2 没有的元素
const <span class="hljs-attr">difference</span> = (arr1, arr2) =&gt; {
  const <span class="hljs-attr">set2</span> = new Set(arr2)<span class="hljs-comment">;</span>
  return arr1.filter(<span class="hljs-attr">item</span> =&gt; !set2.has(item))<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

// 示例
const <span class="hljs-attr">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">;</span>
const <span class="hljs-attr">b</span> = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<span class="hljs-comment">;</span>
console.log(intersection(a, b))<span class="hljs-comment">; // [2, 3]</span>
console.log(union(a, b))<span class="hljs-comment">; // [1, 2, 3, 4]</span>
console.log(difference(a, b))<span class="hljs-comment">; // [1]</span>
</code></pre>
<h4 data-id="heading-4">4. 临时存储 “已处理项”（避免重复操作）</h4>
<p><strong>场景</strong>：批量处理数据时记录已处理 ID，防止重复请求 / 计算。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 记录已处理的任务ID</span>
const processedTaskIds = new <span class="hljs-built_in">Set</span>();

<span class="hljs-comment">/**
 * 处理任务（仅处理未处理过的）
 * @param {number} taskId - 任务ID
 */</span>
const processTask = (taskId) =&gt; {
  if (processedTaskIds.has(taskId)) {
    console<span class="hljs-selector-class">.log</span>(`任务 ${taskId} 已处理，跳过`);
    return;
  }
  <span class="hljs-comment">// 模拟处理逻辑</span>
  console<span class="hljs-selector-class">.log</span>(`处理任务 ${taskId}`);
  processedTaskIds<span class="hljs-selector-class">.add</span>(taskId);
};

<span class="hljs-comment">// 示例</span>
<span class="hljs-built_in">processTask</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 处理任务 1</span>
<span class="hljs-built_in">processTask</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 任务 1 已处理，跳过</span>
<span class="hljs-built_in">processTask</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 处理任务 2</span>
</code></pre>
<h3 data-id="heading-5">二、Map 实用代码片段</h3>
<h4 data-id="heading-6">1. 复杂键名映射（替代对象的局限性）</h4>
<p><strong>场景</strong>：用对象（如 DOM 元素、实例）作为键存储数据（对象的键会被转为字符串，无法直接用对象当键）。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 场景：给DOM元素绑定额外数据（如点击次数、状态）</span>
<span class="hljs-keyword">const</span> elementData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-comment">// 获取DOM元素</span>
<span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'submit-btn'</span>);
<span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'username-input'</span>);

<span class="hljs-comment">// 存储数据（键为DOM元素，值为任意类型）</span>
elementData.<span class="hljs-keyword">set</span>(btn, { clickCount: <span class="hljs-number">0</span>, disabled: <span class="hljs-keyword">false</span> });
elementData.<span class="hljs-keyword">set</span>(input, { value: <span class="hljs-string">''</span>, touched: <span class="hljs-keyword">false</span> });

<span class="hljs-comment">// 更新数据</span>
btn.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> data = elementData.<span class="hljs-keyword">get</span>(btn);
  elementData.<span class="hljs-keyword">set</span>(btn, { ...data, clickCount: data.clickCount + <span class="hljs-number">1</span> });
  console.log(`按钮点击次数：${elementData.<span class="hljs-keyword">get</span>(btn).clickCount}`);
});
</code></pre>
<h4 data-id="heading-7">2. 接口数据缓存（避免重复请求）</h4>
<p><strong>场景</strong>：同一参数的接口请求，优先返回缓存数据，减少接口调用。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 带缓存的接口请求工具
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">fetchFn</span> - 实际请求函数（返回Promise）
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Function</span>} 包装后的请求函数
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">withCache</span> = (<span class="hljs-params">fetchFn</span>) =&gt; {
  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 缓存：键为参数字符串，值为请求结果</span>

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (...args) =&gt; {
    <span class="hljs-comment">// 生成唯一缓存键（将参数转为字符串，支持多参数）</span>
    <span class="hljs-keyword">const</span> cacheKey = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args);

    <span class="hljs-comment">// 命中缓存：直接返回</span>
    <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(cacheKey)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'使用缓存数据'</span>);
      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(cacheKey);
    }

    <span class="hljs-comment">// 未命中：请求并缓存</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'发起新请求'</span>);
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchFn</span>(...args);
    cache.<span class="hljs-title function_">set</span>(cacheKey, result);
    <span class="hljs-keyword">return</span> result;
  };
};

<span class="hljs-comment">// 示例：包装一个获取用户信息的接口</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">userId</span>) =&gt; {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/user/<span class="hljs-subst">${userId}</span>`</span>);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();
};

<span class="hljs-comment">// 使用缓存版请求</span>
<span class="hljs-keyword">const</span> fetchUserWithCache = <span class="hljs-title function_">withCache</span>(fetchUser);

<span class="hljs-comment">// 第一次请求（无缓存）</span>
<span class="hljs-title function_">fetchUserWithCache</span>(<span class="hljs-number">1</span>); 
<span class="hljs-comment">// 第二次请求同一用户（用缓存）</span>
<span class="hljs-title function_">fetchUserWithCache</span>(<span class="hljs-number">1</span>); 
</code></pre>
<h4 data-id="heading-8">3. 多维度数据映射（快速查询）</h4>
<p><strong>场景</strong>：同一份数据需要通过多个 “键” 查询（如用户信息可通过 ID、手机号、用户名查询）。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 原始用户数据</span>
<span class="hljs-keyword">const</span> users = [
  { id: <span class="hljs-number">1</span>, name: <span class="hljs-string">'张三'</span>, phone: <span class="hljs-string">'13800138000'</span> },
  { id: <span class="hljs-number">2</span>, name: <span class="hljs-string">'李四'</span>, phone: <span class="hljs-string">'13900139000'</span> }
];

<span class="hljs-comment">// 构建多维度映射</span>
<span class="hljs-keyword">const</span> userMaps = {
  byId: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),    <span class="hljs-comment">// 键：id</span>
  byName: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),  <span class="hljs-comment">// 键：name</span>
  byPhone: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-comment">// 键：phone</span>
};

users.forEach(user =&gt; {
  userMaps.byId.<span class="hljs-keyword">set</span>(user.id, user);
  userMaps.byName.<span class="hljs-keyword">set</span>(user.name, user);
  userMaps.byPhone.<span class="hljs-keyword">set</span>(user.phone, user);
});

<span class="hljs-comment">// 快速查询示例</span>
console.log(userMaps.byId.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// {id:1, name:'张三', ...}</span>
console.log(userMaps.byPhone.<span class="hljs-keyword">get</span>(<span class="hljs-string">'13900139000'</span>)); <span class="hljs-comment">// {id:2, ...}</span>
</code></pre>
<h4 data-id="heading-9">4. 有序键值对遍历（保留插入顺序）</h4>
<p><strong>场景</strong>：需要按 “插入顺序” 遍历键值对（对象的键遍历顺序不稳定，尤其是数字键）。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 场景：按用户操作顺序记录日志（需保留顺序）</span>
<span class="hljs-keyword">const</span> actionLog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

<span class="hljs-comment">// 按顺序插入操作</span>
actionLog.<span class="hljs-title function_">set</span>(<span class="hljs-string">'login'</span>, { <span class="hljs-attr">time</span>: <span class="hljs-string">'09:00'</span>, <span class="hljs-attr">user</span>: <span class="hljs-string">'张三'</span> });
actionLog.<span class="hljs-title function_">set</span>(<span class="hljs-string">'view'</span>, { <span class="hljs-attr">time</span>: <span class="hljs-string">'09:05'</span>, <span class="hljs-attr">page</span>: <span class="hljs-string">'首页'</span> });
actionLog.<span class="hljs-title function_">set</span>(<span class="hljs-string">'logout'</span>, { <span class="hljs-attr">time</span>: <span class="hljs-string">'10:00'</span>, <span class="hljs-attr">user</span>: <span class="hljs-string">'张三'</span> });

<span class="hljs-comment">// 按插入顺序遍历（Map 会保留插入顺序）</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [action, detail] <span class="hljs-keyword">of</span> actionLog) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${action}</span>：<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(detail)}</span>`</span>);
}
<span class="hljs-comment">// 输出顺序：login → view → logout（与插入顺序一致）</span>
</code></pre>
<h3 data-id="heading-10">三、使用小贴士</h3>
<ol>
<li>
<p><strong>选择 Set 还是 Map</strong>？</p>
<ul>
<li>只需要 “唯一元素集合” → 用 Set；</li>
<li>需要 “键值对映射”（尤其是复杂键） → 用 Map。</li>
</ul>
</li>
<li>
<p><strong>性能考量</strong>：</p>
<ul>
<li>Set/Map 的 <code>has</code>/<code>get</code>/<code>set</code> 操作时间复杂度为 O (1)，比数组的 <code>indexOf、includes</code>等（O (n)）更高效，数据量大时优先使用。</li>
</ul>
</li>
<li>
<p><strong>转换技巧</strong>：</p>
<ul>
<li>Set 转数组：<code>[...mySet]</code> 或 <code>Array.from(mySet)</code>；</li>
<li>Map 转对象（键为字符串时）：<code>Object.fromEntries(myMap)</code>。</li>
</ul>
</li>
<li>
<p><strong>转换技巧</strong>：</p>
<ul>
<li>Set/Map 的 <code>has</code>/<code>get</code>/<code>set</code> 操作都是 O (1)，比数组 <code>indexOf</code>（O (n)）、对象循环查询快，<strong>数据量大（&gt;100）时优先用</strong>。</li>
<li>临时缓存（比如接口缓存）如果不需要持久化，用 Map 即可；需要持久化到 localStorage，要先转成数组 / 对象（因为 localStorage 只能存字符串）。</li>
</ul>
</li>
<li>
<p><strong>避坑提醒</strong></p>
<ul>
<li>Set 存引用类型（对象、数组）时，不会自动去重（因为引用地址不同），比如 <code>new Set([{a:1}, {a:1}])</code> 会存两个对象。</li>
<li>Map 的键是 “引用相等”，比如 <code>map.set({}, 1)</code> 和 <code>map.set({}, 2)</code> 是两个不同的键（对象引用不同）。</li>
</ul>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端代码一键打包上传服务器？10分钟配好永久告别手动部署！]]></title>    <link>https://juejin.cn/post/7573299401046802478</link>    <guid>https://juejin.cn/post/7573299401046802478</guid>    <pubDate>2025-11-17T08:26:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573299401046802478" data-draft-id="7573506713865682995" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端代码一键打包上传服务器？10分钟配好永久告别手动部署！"/> <meta itemprop="keywords" content="前端,Node.js"/> <meta itemprop="datePublished" content="2025-11-17T08:26:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="扑棱蛾子"/> <meta itemprop="url" content="https://juejin.cn/user/2823201593493790"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端代码一键打包上传服务器？10分钟配好永久告别手动部署！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2823201593493790/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    扑棱蛾子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:26:46.000Z" title="Mon Nov 17 2025 08:26:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>搞了一个服务器准备折腾一下，但是每次打包用FTP一个个传文件太麻烦了。
受不了于是准备搞个脚本自动部署下。</p>
<p>于是乎，我今天教你配一套<strong>自动化部署脚本</strong>，以后改完代码直接一个命令<code>npm run deploy</code>，喝杯咖啡十分钟的功夫，就自动打包部署完了。</p>
<h2 data-id="heading-0">第一步：配置免密登录</h2>
<p>让本地电脑和服务器之间建立信任关系，不然每次上传都要输密码，烦都烦死。</p>
<p><strong>本地生成密钥</strong>（如果你之前没搞过的话）：</p>
<pre><code class="hljs language-bash" lang="bash">ssh-keygen -t rsa -b 4096 -C “your-email@example.com”
</code></pre>
<p>一路回车就行。这就像给你的电脑办了张身份证。</p>
<p><strong>查看刚生成的密钥</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub
</code></pre>
<p>会出来一长串字符，全选复制它！这是你电脑的“身份证号”。</p>
<p><strong>登录服务器添加信任</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">ssh username@your-server-ip
</code></pre>
<p>输完密码进去后，执行下面这几条命令：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建存放密钥的文件夹</span>
<span class="hljs-built_in">mkdir</span> -p ~/.ssh

<span class="hljs-comment"># 设置文件夹权限</span>
<span class="hljs-built_in">chmod</span> 700 ~/.ssh

<span class="hljs-comment"># 把刚才复制的公钥粘贴进去</span>
<span class="hljs-built_in">echo</span> “粘贴你刚才复制的那一长串” &gt;&gt; ~/.ssh/authorized_keys

<span class="hljs-comment"># 设置密钥文件权限</span>
<span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys
</code></pre>
<blockquote>
<p><strong>测试一下有没有配好</strong>：退出服务器后重新执行<code>ssh username@your-server-ip</code>，如果不用输密码直接进去了，那就成了！</p>
</blockquote>
<h2 data-id="heading-1">第二步：部署脚本</h2>
<p>在项目根目录新建一个<code>deploy。js</code>文件，直接把下面代码复制进去：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// deploy.js - 完整的部署脚本（直接上传文件版本）</span>
<span class="hljs-keyword">import</span> { execSync } <span class="hljs-keyword">from</span> <span class="hljs-string">'child_process'</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>

<span class="hljs-comment">// 配置信息 - 根据你的实际情况修改</span>
<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">server</span>: <span class="hljs-string">'username@your-server-ip'</span>, <span class="hljs-comment">// 替换为你的服务器信息</span>
  <span class="hljs-attr">deployPath</span>: <span class="hljs-string">'yourpath'</span>
}

<span class="hljs-comment">// 彩色日志</span>
<span class="hljs-keyword">const</span> colors = {
  <span class="hljs-attr">reset</span>: <span class="hljs-string">'\x1b[0m'</span>,
  <span class="hljs-attr">red</span>: <span class="hljs-string">'\x1b[31m'</span>,
  <span class="hljs-attr">green</span>: <span class="hljs-string">'\x1b[32m'</span>,
  <span class="hljs-attr">yellow</span>: <span class="hljs-string">'\x1b[33m'</span>,
  <span class="hljs-attr">blue</span>: <span class="hljs-string">'\x1b[34m'</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">message, color = colors.reset</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(color + message + colors.<span class="hljs-property">reset</span>)
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">runCommand</span>(<span class="hljs-params">command, description</span>) {
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`📝 <span class="hljs-subst">${description}</span>`</span>, colors.<span class="hljs-property">blue</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`  执行: <span class="hljs-subst">${command}</span>`</span>, colors.<span class="hljs-property">yellow</span>)

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> output = <span class="hljs-title function_">execSync</span>(command, { <span class="hljs-attr">stdio</span>: <span class="hljs-string">'inherit'</span> })
    <span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ <span class="hljs-subst">${description}</span> 成功`</span>, colors.<span class="hljs-property">green</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-title function_">log</span>(<span class="hljs-string">`❌ <span class="hljs-subst">${description}</span> 失败: <span class="hljs-subst">${error.message}</span>`</span>, colors.<span class="hljs-property">red</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }
}

<span class="hljs-comment">// 递归获取目录中的所有文件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllFiles</span>(<span class="hljs-params">dirPath, arrayOfFiles = []</span>) {
  <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(dirPath)

  files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">join</span>(dirPath, file)
    <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">statSync</span>(fullPath).<span class="hljs-title function_">isDirectory</span>()) {
      arrayOfFiles = <span class="hljs-title function_">getAllFiles</span>(fullPath, arrayOfFiles)
    } <span class="hljs-keyword">else</span> {
      arrayOfFiles.<span class="hljs-title function_">push</span>(fullPath)
    }
  })

  <span class="hljs-keyword">return</span> arrayOfFiles
}

<span class="hljs-comment">// 主部署函数</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deploy</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'🚀 开始直接文件上传部署流程'</span>, colors.<span class="hljs-property">blue</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">50</span>))

  <span class="hljs-comment">// 1. 检查 dist 目录是否存在，如果不存在则构建</span>
  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(<span class="hljs-string">'dist'</span>)) {
    <span class="hljs-title function_">log</span>(<span class="hljs-string">'📦 dist 目录不存在，开始构建项目...'</span>, colors.<span class="hljs-property">yellow</span>)
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">runCommand</span>(<span class="hljs-string">'npm run build'</span>, <span class="hljs-string">'项目构建'</span>)) {
      <span class="hljs-keyword">return</span>
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">log</span>(<span class="hljs-string">'📦 发现已存在的 dist 目录，跳过构建'</span>, colors.<span class="hljs-property">green</span>)
  }

  <span class="hljs-comment">// 2. 获取 dist 目录中的所有文件</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'📋 扫描 dist 目录中的文件...'</span>, colors.<span class="hljs-property">blue</span>)
  <span class="hljs-keyword">const</span> distFiles = <span class="hljs-title function_">getAllFiles</span>(<span class="hljs-string">'dist'</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`📄 找到 <span class="hljs-subst">${distFiles.length}</span> 个文件需要上传`</span>, colors.<span class="hljs-property">green</span>)

  <span class="hljs-comment">// 3. 测试服务器连接</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'🔗 测试服务器连接...'</span>, colors.<span class="hljs-property">blue</span>);
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">runCommand</span>(<span class="hljs-string">`ssh -o ConnectTimeout=10 <span class="hljs-subst">${config.server}</span> "echo '连接成功'; exit"`</span>, <span class="hljs-string">'测试SSH连接'</span>)) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 4. 在服务器上创建备份</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'💾 在服务器上创建备份...'</span>, colors.<span class="hljs-property">blue</span>);
  <span class="hljs-keyword">const</span> backupCommands = <span class="hljs-string">`set -e; cd <span class="hljs-subst">${config.deployPath}</span>; echo "备份当前文件..."; if [ -f "index.html" ] || [ -d "assets" ]; then tar -czf backup_old.tar.gz index.html assets 2&gt;/dev/null || true; echo "✅ 当前文件已备份为 backup_old.tar.gz"; else echo "⚠️ 没有找到当前文件，跳过备份"; fi; echo "清理旧文件..."; rm -rf index.html assets; echo "✅ 服务器准备完成"; exit 0`</span>;
  
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">runCommand</span>(<span class="hljs-string">`ssh -o ConnectTimeout=30 <span class="hljs-subst">${config.server}</span> "<span class="hljs-subst">${backupCommands}</span>"`</span>, <span class="hljs-string">'服务器准备'</span>)) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 5. 逐个上传文件到服务器</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'📤 开始上传文件到服务器...'</span>, colors.<span class="hljs-property">blue</span>)
  <span class="hljs-keyword">let</span> uploadedCount = <span class="hljs-number">0</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> filePath <span class="hljs-keyword">of</span> distFiles) {
    <span class="hljs-keyword">const</span> relativePath = path.<span class="hljs-title function_">relative</span>(<span class="hljs-string">'dist'</span>, filePath)
    <span class="hljs-keyword">const</span> remotePath = path
      .<span class="hljs-title function_">join</span>(config.<span class="hljs-property">deployPath</span>, relativePath)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>)
    <span class="hljs-keyword">const</span> remoteDir = path.<span class="hljs-title function_">dirname</span>(remotePath).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>)

    <span class="hljs-comment">// 确保远程目录存在</span>
    <span class="hljs-keyword">const</span> mkdirCommand = <span class="hljs-string">`ssh <span class="hljs-subst">${config.server}</span> "mkdir -p <span class="hljs-subst">${remoteDir}</span>"`</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">runCommand</span>(mkdirCommand, <span class="hljs-string">`创建目录: <span class="hljs-subst">${remoteDir}</span>`</span>)) {
      <span class="hljs-keyword">continue</span>
    }

    <span class="hljs-comment">// 上传文件</span>
    <span class="hljs-keyword">const</span> scpCommand = <span class="hljs-string">`scp <span class="hljs-subst">${filePath}</span> <span class="hljs-subst">${config.server}</span>:<span class="hljs-subst">${remotePath}</span>`</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">runCommand</span>(scpCommand, <span class="hljs-string">`上传文件: <span class="hljs-subst">${relativePath}</span>`</span>)) {
      uploadedCount++
    }
  }

  <span class="hljs-title function_">log</span>(
    <span class="hljs-string">`✅ 文件上传完成: <span class="hljs-subst">${uploadedCount}</span>/<span class="hljs-subst">${distFiles.length}</span> 个文件`</span>,
    colors.<span class="hljs-property">green</span>
  )

  <span class="hljs-comment">// 6. 在服务器上设置文件权限</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'🔒 设置服务器文件权限...'</span>, colors.<span class="hljs-property">blue</span>);
  <span class="hljs-keyword">const</span> permissionCommands = <span class="hljs-string">`set -e; cd <span class="hljs-subst">${config.deployPath}</span>; echo "设置文件权限..."; chmod -R 755 .; echo "✅ 权限设置完成"; exit 0`</span>;
  
  <span class="hljs-title function_">runCommand</span>(<span class="hljs-string">`ssh -o ConnectTimeout=30 <span class="hljs-subst">${config.server}</span> "<span class="hljs-subst">${permissionCommands}</span>"`</span>, <span class="hljs-string">'设置文件权限'</span>);

  <span class="hljs-comment">// 7. 验证部署</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'🔍 验证部署结果...'</span>, colors.<span class="hljs-property">blue</span>);
  <span class="hljs-title function_">runCommand</span>(
    <span class="hljs-string">`ssh -o ConnectTimeout=10 <span class="hljs-subst">${config.server}</span> "cd <span class="hljs-subst">${config.deployPath}</span> &amp;&amp; ls -la &amp;&amp; echo '--- 文件统计 ---' &amp;&amp; find . -type f | wc -l; exit"`</span>,
    <span class="hljs-string">'检查部署目录'</span>
  );

  <span class="hljs-title function_">log</span>(<span class="hljs-string">'\n🎉 部署完成！'</span>, colors.<span class="hljs-property">green</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`🌐 请访问: http://<span class="hljs-subst">${config.server.split(<span class="hljs-string">'@'</span>)[<span class="hljs-number">1</span>]}</span>`</span>, colors.<span class="hljs-property">green</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">50</span>))
}

<span class="hljs-comment">// 执行部署</span>
<span class="hljs-title function_">deploy</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`💥 部署过程出现错误: <span class="hljs-subst">${error.message}</span>`</span>, colors.<span class="hljs-property">red</span>)
  process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)
})
</code></pre>
<p><strong>这脚本干了啥？</strong></p>
<ol>
<li>自动检查有没有打包文件，没有就先打包</li>
<li>测试服务器连接（别传到一半断了）</li>
<li>备份服务器上的旧文件（万一新版本有问题能回滚）</li>
<li>上传所有新文件</li>
<li>设置好权限让Nginx能访问</li>
</ol>
<h2 data-id="heading-2">第三步：配置打包命令</h2>
<p>打开<code>package.json</code>，在<code>scripts</code>里加一行：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite build"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"preview"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite preview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"deploy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite build &amp;&amp; node deploy.js"</span>
<span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre>
<p>就这么简单！</p>
<h2 data-id="heading-3">开始享受一键部署</h2>
<p>以后每次改完代码需要部署的时候，终端里输入：</p>
<pre><code class="hljs language-bash" lang="bash">npm run deploy
</code></pre>
<p>然后你就会看到彩色的日志在跑，<strong>打包→上传→部署</strong>一气呵成。等出现<code>🎉 部署完成！</code>的时候，刷新浏览器就能看到新版本了。没看到记得重启一下nginx。</p>
<p><strong>是不是超简单？</strong></p>
<p>以后再也不用打开一堆工具手动传文件了，改完代码一个命令搞定，省下的时间够你多摸几次鱼了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【hvigor专栏】OpenHarmony应用开发-hvigor插件之动态修改应用hap文件名]]></title>    <link>https://juejin.cn/post/7573300346262945846</link>    <guid>https://juejin.cn/post/7573300346262945846</guid>    <pubDate>2025-11-17T08:30:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573300346262945846" data-draft-id="7573486671296643114" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【hvigor专栏】OpenHarmony应用开发-hvigor插件之动态修改应用hap文件名"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-17T08:30:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Winslei"/> <meta itemprop="url" content="https://juejin.cn/user/4336129592008104"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【hvigor专栏】OpenHarmony应用开发-hvigor插件之动态修改应用hap文件名
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4336129592008104/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Winslei
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:30:03.000Z" title="Mon Nov 17 2025 08:30:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在OpenHarmony应用开发中，动态修改应用hap文件名是较为常见的功能，比如文件名包含版本号、构建时间、编译模式等等。下文会以一个完整的示例为大家讲述如何实现此功能。</p>
<h2 data-id="heading-1">开发环境</h2>
<p><strong>DevEco Studio：</strong> DevEco Studio 6.0.0 Release（Build Version： 6.0.0.858）</p>
<h2 data-id="heading-2">开发流程</h2>
<h3 data-id="heading-3">前置步骤</h3>
<ol>
<li>
<p>创建新工程。</p>
</li>
<li>
<p>编译工程，可以看到<code>build/default/outputs/default/</code>目录下生成了名为<strong>entry-default-unsigned.hap</strong>的默认hap。</p>
</li>
</ol>
<h3 data-id="heading-4">新增artifactName</h3>
<p>在<code>entry</code>模块的<code>build-profile.json5</code>下新增</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  ···
  <span class="hljs-attr">"targets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"default"</span><span class="hljs-punctuation">,</span>
      ···
      <span class="hljs-attr">"output"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"artifactName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"samples"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-5">新增hvigor任务</h3>
<p>在根目录<code>hvigorfile.ts</code>里修改为以下代码</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { appTasks, <span class="hljs-title class_">OhosAppContext</span>, <span class="hljs-title class_">OhosHapContext</span>, <span class="hljs-title class_">OhosPluginId</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos/hvigor-ohos-plugin'</span>;
<span class="hljs-keyword">import</span> { hvigor } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos/hvigor'</span>;

<span class="hljs-comment">// 动态修改应用hap文件名</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">dynamicChangeNamePlugin</span>(<span class="hljs-params"/>): <span class="hljs-title class_">HvigorPlugin</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">pluginId</span>: <span class="hljs-string">'dynamicChangeNamePlugin'</span>,
    <span class="hljs-title function_">context</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">data</span>: <span class="hljs-string">'modify output name'</span>
      };
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">apply</span>(<span class="hljs-attr">currentNode</span>: <span class="hljs-title class_">HvigorNode</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
      <span class="hljs-comment">// 获取app插件的上下文对象</span>
      <span class="hljs-keyword">const</span> appContext = currentNode.<span class="hljs-title function_">getContext</span>(<span class="hljs-title class_">OhosPluginId</span>.<span class="hljs-property">OHOS_APP_PLUGIN</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OhosAppContext</span>;
      <span class="hljs-comment">// 通过上下文对象获取从根目录build-profile.json5文件中读出来的obj对象</span>
      <span class="hljs-keyword">const</span> buildProfileOpt = appContext.<span class="hljs-title function_">getBuildProfileOpt</span>();
      <span class="hljs-keyword">const</span> appJsonOpt = appContext.<span class="hljs-title function_">getAppJsonOpt</span>();
      <span class="hljs-comment">// 修改obj对象为想要的，此处举例修改app中的signingConfigs</span>
      <span class="hljs-keyword">const</span> products = buildProfileOpt.<span class="hljs-property">app</span>.<span class="hljs-property">products</span>;
      <span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
      <span class="hljs-keyword">let</span> formatDate = date.<span class="hljs-title function_">getFullYear</span>().<span class="hljs-title function_">toString</span>() + (date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>) +
      date.<span class="hljs-title function_">getDate</span>().<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>) + <span class="hljs-string">'_'</span> + date.<span class="hljs-title function_">getHours</span>().<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>) +
      date.<span class="hljs-title function_">getMinutes</span>().<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>) + date.<span class="hljs-title function_">getSeconds</span>().<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> product <span class="hljs-keyword">of</span> products) {
        <span class="hljs-keyword">if</span> (product.<span class="hljs-property">name</span> == <span class="hljs-string">'default'</span>) {
          product.<span class="hljs-property">output</span>.<span class="hljs-property">artifactName</span> = formatDate + <span class="hljs-string">'_'</span> + appJsonOpt.<span class="hljs-property">app</span>.<span class="hljs-property">versionName</span> + <span class="hljs-string">'_'</span> +
          product.<span class="hljs-property">output</span>.<span class="hljs-property">artifactName</span> + <span class="hljs-string">'_'</span> + appContext.<span class="hljs-title function_">getBuildMode</span>();
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`output app name: <span class="hljs-subst">${product.output.artifactName}</span>`</span>);
        }
      }
      <span class="hljs-comment">// 将obj对象设置回上下文对象以使能到构建的过程与结果中</span>
      appContext.<span class="hljs-title function_">setBuildProfileOpt</span>(buildProfileOpt);
      hvigor.<span class="hljs-title function_">nodesEvaluated</span>(<span class="hljs-keyword">async</span> () =&gt; {
        currentNode.<span class="hljs-title function_">subNodes</span>(<span class="hljs-function">(<span class="hljs-params">node: HvigorNode</span>) =&gt;</span> {
          <span class="hljs-comment">// 获取hpp插件的上下文对象</span>
          <span class="hljs-keyword">const</span> hapContext = node.<span class="hljs-title function_">getContext</span>(<span class="hljs-title class_">OhosPluginId</span>.<span class="hljs-property">OHOS_HAP_PLUGIN</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OhosHapContext</span>;
          <span class="hljs-comment">// 通过上下文对象获取从根目录build-profile.json5文件中读出来的obj对象</span>
          <span class="hljs-keyword">const</span> hapBuildProfileOpt = hapContext?.<span class="hljs-title function_">getBuildProfileOpt</span>();
          <span class="hljs-keyword">if</span> (hapBuildProfileOpt != <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">const</span> targets = hapBuildProfileOpt[<span class="hljs-string">'targets'</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> target <span class="hljs-keyword">of</span> targets) {
              <span class="hljs-keyword">if</span> (target.<span class="hljs-property">name</span> == <span class="hljs-string">'default'</span> &amp;&amp; target.<span class="hljs-property">output</span>?.<span class="hljs-property">artifactName</span> != <span class="hljs-literal">undefined</span>) {
                target.<span class="hljs-property">output</span>.<span class="hljs-property">artifactName</span> = formatDate + <span class="hljs-string">'_'</span> + appJsonOpt.<span class="hljs-property">app</span>.<span class="hljs-property">versionName</span> + <span class="hljs-string">'_'</span> +
                target.<span class="hljs-property">output</span>.<span class="hljs-property">artifactName</span> + <span class="hljs-string">'_'</span> + appContext.<span class="hljs-title function_">getBuildMode</span>();
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`output hap name: <span class="hljs-subst">${target.output?.artifactName}</span>`</span>);
              }
            }
            hapContext.<span class="hljs-title function_">setBuildProfileOpt</span>(hapBuildProfileOpt);
          }
        })
      })
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">system</span>: appTasks, <span class="hljs-comment">/* Built-in plugin of Hvigor. It cannot be modified. */</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">dynamicChangeNamePlugin</span>()
  ]       <span class="hljs-comment">/* Custom plugin to extend the functionality of Hvigor. */</span>
}
</code></pre>
<h3 data-id="heading-6">编译验证</h3>
<ol>
<li>编译工程，可以看到<code>build/default/outputs/default/</code>目录下生成了名为<strong>20251117_113634_1.0.0_samples_debug-unsigned.hap</strong>的自定义文件名hap，其中包含了构建时间、版本号、自定义产物名、编译模式、是否签名等信息。</li>
</ol>
<h3 data-id="heading-7">注意事项</h3>
<ol>
<li>如果自定义文件名里包含了时间规则，那么因为时间的变化，每次打出的hap都不会覆盖前一个，而是会创建一个新的，从而导致hap越来越多，本地工程体积越来越大。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[17. Vue3 业务组件库按需加载的实现原理]]></title>    <link>https://juejin.cn/post/7572480736362119174</link>    <guid>https://juejin.cn/post/7572480736362119174</guid>    <pubDate>2025-11-16T09:53:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572480736362119174" data-draft-id="7567194020462133274" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="17. Vue3 业务组件库按需加载的实现原理"/> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"/> <meta itemprop="datePublished" content="2025-11-16T09:53:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Cobyte"/> <meta itemprop="url" content="https://juejin.cn/user/668147376989517"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            17. Vue3 业务组件库按需加载的实现原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/668147376989517/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Cobyte
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T09:53:14.000Z" title="Sun Nov 16 2025 09:53:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    31
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto;border:3px solid rgba(62,175,124,.2)}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-weight:700;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:6px;border:2px solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c}.markdown-body a:active,.markdown-body a:hover{border-bottom:1.5px solid #3eaf7c}.markdown-body a:before{content:"⇲"}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(62,175,124,.2)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:.5rem solid;border-color:#42b983;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none}.markdown-body ul li:before{content:"•";margin-right:4px;color:#3eaf7c}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>最近在公司实现一个业务组件库按需加载的需求。简单来说，有两个需求，第一个是实现业务组件库的按需加载，第二，因为业务组件库里面有引用了类似 Element Plus 的第三方组件库，所以在实现业务组件库按需加载的同时，业务组件库里面的引用的第三方组件库也要实现按需加载。</p>
<p>作为一个编程技术人员，即便有了AI，也需要研究底层的技术原理，甚至需要比没有AI的时代，需要更加深入研究，在AI时代，基础的都通过AI实现了，只有AI解决不了的问题，最终还得靠你自己的专业知识去解决，而这将是你的核心竞争力的体现，所以在AI时代对技术人员的技术素养要求将更加的高。</p>
<p>扯远了，我们回到业务组件库按需加载的实现原理的主题上来。</p>
<p>一般在项目中如果没有进行组件库按需加载配置，都是一开始就全量加载进行全局组件注册，这样就等于整个组件库在初始化的时候就全部加载了，如果在追求性能的项目中，这是不可接受的。这时我们就要实现组件库的按需加载，来提高性能。</p>
<h3 data-id="heading-1">按需加载的基本实现原理</h3>
<p>首先什么是按需加载？</p>
<p>所谓按需加载，顾名思义就是有需要就加载，不需要就不加载，比如 <code>Element Plus</code> 组件库有几十个组件，可能在我们的项目只用到了到了其中一个组件 <code>&lt;el-button&gt;</code>，那么我们就希望只加载跟这个按钮组件相关的代码，从而达到减少打包体积的效果。</p>
<p>按需加载最简单的实现方式就是手动设置，实现如下：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElButton</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus/es/components/button'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'element-plus/es/components/button/style/index'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: { <span class="hljs-title class_">ElButton</span> },
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>我们像上述例子这样手动引用第三方组件库的话，在打包的时候就只会打包引用到的组件，因为目前的开源组件库基本都实现了利于 Tree Shaking 的 <code>ESM</code> 模块化实现。</p>
<p>如果每个业务组件都需要进行上述设置，其实还是挺繁琐的，所以我们希望只在 template 中直接调用就好，其他什么设置都不需要，就像全局注册组件那样使用。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>而剩下部分的代码，我们希望在打包或者运行的时候自动设置上去。主要是以下部分的代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElButton</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus/es/components/button'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'element-plus/es/components/button/style/index'</span>
</code></pre>
<p>上述部分的代码，希望自动加载，而不需要手动设置。整个所谓按需加载所需要实现的就是上述的功能。</p>
<p>那么怎么实现呢？</p>
<p>首先上述模板代码的编译结果如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { createTextVNode <span class="hljs-keyword">as</span> _createTextVNode, resolveComponent <span class="hljs-keyword">as</span> _resolveComponent, withCtx <span class="hljs-keyword">as</span> _withCtx, createVNode <span class="hljs-keyword">as</span> _createVNode, openBlock <span class="hljs-keyword">as</span> _openBlock, createElementBlock <span class="hljs-keyword">as</span> _createElementBlock } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">const</span> _component_el_button = <span class="hljs-title function_">_resolveComponent</span>(<span class="hljs-string">"el-button"</span>)

  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createElementBlock</span>(<span class="hljs-string">"template"</span>, <span class="hljs-literal">null</span>, [
    <span class="hljs-title function_">_createVNode</span>(_component_el_button, <span class="hljs-literal">null</span>, {
      <span class="hljs-attr">default</span>: <span class="hljs-title function_">_withCtx</span>(<span class="hljs-function">() =&gt;</span> [
        <span class="hljs-title function_">_createTextVNode</span>(<span class="hljs-string">"按钮"</span>)
      ], <span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>),
      <span class="hljs-attr">_</span>: <span class="hljs-number">1</span> <span class="hljs-comment">/* STABLE */</span>
    })
  ]))
}
</code></pre>
<p>我们只需要找到 Vue3 的内置函数 <code>_resolveComponent("el-button")</code> 部分，然后替换成对应的组件代码即可。例如：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-addition">+ import { ElButton } from 'element-plus/es/components/button'</span>
<span class="hljs-addition">+ import 'element-plus/es/components/button/style/index'</span>
import { createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache, $props, $setup, $data, $options) {
<span class="hljs-deletion">-  const _component_el_button = _resolveComponent("el-button")</span>
<span class="hljs-addition">+ const _component_el_button = ElButton</span>

  return (_openBlock(), _createElementBlock("template", null, [
    _createVNode(_component_el_button, null, {
      default: _withCtx(() =&gt; [
        _createTextVNode("按钮")
      ], undefined, true),
      _: 1 /* STABLE */
    })
  ]))
}
</code></pre>
<p>上述就是组件库按需加载的基本实现原理。</p>
<h3 data-id="heading-2">使用 Vite 打包组件库</h3>
<p>为了更好还原实际场景，我们快速创建一个组件库项目并且通过 Vite 进行打包。
首先创建一个 <code>cobyte-vite-ui</code> 的组件库目录，在根目录下初始化 Node 项目，执行 <code>pnpm init</code>, 会自动生成 <code>package.json</code>  文件，内容如下：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cobyte-vite-ui"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"index.js"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"keywords"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"license"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ISC"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"packageManager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"pnpm@10.20.0"</span><span class="hljs-punctuation">,</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>在根目录新建 <code>pnpm-workspace.yaml</code> 文件进行 Monorepo 项目配置：</p>
<pre><code class="hljs language-markdown" lang="markdown">packages:
<span class="hljs-bullet">  -</span> packages/*
<span class="hljs-bullet">  -</span> play
</code></pre>
<p>总的目录结构如下：</p>
<pre><code class="hljs language-go" lang="go">├── packages
│   ├── components
│   ├── hooks
│   └── utils
├── play
├── <span class="hljs-keyword">package</span>.json
└── pnpm-workspace.yaml
</code></pre>
<p>接着我们安装一些必要的依赖：</p>
<pre><code class="hljs language-sql" lang="sql">pnpm <span class="hljs-keyword">add</span> vite typescript <span class="hljs-variable">@vitejs</span><span class="hljs-operator">/</span>plugin<span class="hljs-operator">-</span>vue sass <span class="hljs-variable">@types</span><span class="hljs-operator">/</span>node <span class="hljs-operator">-</span>D <span class="hljs-operator">-</span>w
</code></pre>
<p>接着我们安装一下 vue 依赖：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> vue -w
</code></pre>
<p>基础依赖安装完毕，我们设置一下 TS 的配置，因为我们这个项目是一个 TS 的项目，在根目录创建一个 <code>tsconfig.json</code>，配置内容可以简单设置如下：</p>
<pre><code class="hljs language-js" lang="js">{
    <span class="hljs-string">"compilerOptions"</span>: {
      <span class="hljs-string">"target"</span>: <span class="hljs-string">"ESNext"</span>,
      <span class="hljs-string">"module"</span>: <span class="hljs-string">"NodeNext"</span>,
      <span class="hljs-string">"sourceMap"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 关键：启用源映射</span>
      <span class="hljs-string">"outDir"</span>: <span class="hljs-string">"./dist"</span>, <span class="hljs-comment">// 可选：指定输出目录</span>
      <span class="hljs-string">"esModuleInterop"</span>: <span class="hljs-literal">true</span>
    }
}
</code></pre>
<p>接着我们就在 <code>packages/components</code> 目录下创建一个测试按钮组件</p>
<p>目录路径：<code>packages/components/button/button.vue</code>，内容如下：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>测试按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-title function_">defineOptions</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'co-button'</span>,
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">button</span> {
  <span class="hljs-attribute">color</span>: red;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p>目录路径：<code>packages/components/button/index.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> button <span class="hljs-keyword">from</span> <span class="hljs-string">"./button.vue"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">CoButton</span> = button;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CoButton</span>;
</code></pre>
<p>目录路径：<code>packages/components/components.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">CoButton</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./button'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
    <span class="hljs-title class_">CoButton</span>
]
</code></pre>
<p>将所有组件集中在一个数组中统一导出，方便批量管理和使用。</p>
<p>目录路径：<code>packages/components/defaults.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">App</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> components <span class="hljs-keyword">from</span> <span class="hljs-string">'./components'</span>;

<span class="hljs-keyword">const</span> install = <span class="hljs-keyword">function</span> (<span class="hljs-params">app: App</span>) {
    components.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">component</span> =&gt;</span> {
        app.<span class="hljs-title function_">component</span>(component.<span class="hljs-property">name</span>, component);
    });
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    install
};
</code></pre>
<p>目录路径：<code>packages/components/index.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./button'</span>;

<span class="hljs-keyword">import</span> install <span class="hljs-keyword">from</span>  <span class="hljs-string">'./defaults'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> install;
</code></pre>
<p>我们再配置一个测试文件，目录路径：<code>packages/utils/index.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testUtils</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'testUtils'</span>);
}
</code></pre>
<p>如果大家对创建组件库比较有经验的话，就知道上述步骤，是 Vue3 组件库的基础设置，各大组件库的实现虽然差异很大，但最核心机制都可以简单归纳为上述设置内容。
大家如果想详细了解更多也可以看看本栏目前面章节的内容。</p>
<p>接着我们就到了我们最核心的组件库打包的环节了，我们在根本目录创建一个 <code>vite.config.ts</code>，设置内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-vue"</span>;
<span class="hljs-keyword">import</span> path, { resolve } <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">"fs"</span>;

<span class="hljs-comment">// 动态获取组件目录列表</span>
<span class="hljs-keyword">const</span> componentsDir = <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./packages/components"</span>);
<span class="hljs-keyword">const</span> modules = fs.<span class="hljs-title function_">readdirSync</span>(componentsDir).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">join</span>(componentsDir, name);
    <span class="hljs-comment">// 只获取目录，排除文件</span>
    <span class="hljs-keyword">return</span> fs.<span class="hljs-title function_">statSync</span>(fullPath).<span class="hljs-title function_">isDirectory</span>();
});

<span class="hljs-keyword">const</span> entryArr = {
    <span class="hljs-comment">// 主入口</span>
    <span class="hljs-attr">index</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./packages/components/index.ts"</span>),

    <span class="hljs-comment">// 工具入口</span>
    <span class="hljs-attr">utils</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./packages/utils/index.ts"</span>),
};

<span class="hljs-comment">// 为每个组件创建独立入口</span>
modules.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
    entryArr[<span class="hljs-string">`components/<span class="hljs-subst">${name}</span>/index`</span>] = <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">`./packages/components/<span class="hljs-subst">${name}</span>/index.ts`</span>);
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(<span class="hljs-function">(<span class="hljs-params">{ command, mode }</span>) =&gt;</span> {
    <span class="hljs-comment">// 主构建配置</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">plugins</span>: [
            <span class="hljs-title function_">vue</span>(),
        ],
        <span class="hljs-attr">build</span>: {
            <span class="hljs-attr">lib</span>: {
                <span class="hljs-attr">entry</span>: entryArr,
                <span class="hljs-attr">formats</span>: [<span class="hljs-string">"es"</span>], <span class="hljs-comment">// 只构建 ES 模块</span>
                <span class="hljs-attr">cssFileName</span>: <span class="hljs-string">"style"</span>,
            },
            <span class="hljs-attr">rollupOptions</span>: {
                <span class="hljs-attr">external</span>: [
                    <span class="hljs-string">"vue"</span>,
                ],
                <span class="hljs-attr">output</span>: {
                    <span class="hljs-attr">format</span>: <span class="hljs-string">"es"</span>,
                    <span class="hljs-attr">preserveModules</span>: <span class="hljs-literal">true</span>,
                },
            },
        },
    };
});
</code></pre>
<p>设置完 Vite 配置文件后，我们还要设置 <code>packages.json</code> 中的打包命令脚本配置，设置如下：</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"vite build"</span>
  },
</code></pre>
<p>这样我们就可以在根目录运行打包命令了：<code>pnpm build</code>。</p>
<p>运行结果如下，我们成功打包了我们的组件库。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c195ef5bfdd043c2a61e6435e0d4c4f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=uSri%2FlN4ICmesLuFyDi%2BF3Vssl8%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">通过 pnpm 安装本地 npm 包</h3>
<p>接着我们在根目录下创建一个测试项目：</p>
<pre><code class="hljs language-lua" lang="lua">pnpm <span class="hljs-built_in">create</span> vite play <span class="hljs-comment">--template vue-ts</span>
</code></pre>
<p>上述 play 就是测试项目目录，我们原本就建了一个 play 目录，现在这条命令会直接在 play 目录中生成一个使用 Vite 创建的 Vue 项目。</p>
<p>接着我们修改根目录的 package.json 文件：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-deletion">- "main": "index.js",</span>
<span class="hljs-addition">+ "module": "/dist/index.mjs",</span>
</code></pre>
<p>接着我们进入 play 目录，通过 pnpm 安装本地 npm 包，命令如下：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> ../
</code></pre>
<p>运行完上述命令，我们可以看到 <code>./play/packages.json</code> 文件变化如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3f21a2e6b8f4ee08a4a56ae78e9f51e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=GmvFW3i3GJ9n8Fuw656PlJx5h%2Fc%3D" alt="image.png" loading="lazy"/></p>
<p>可以看到我们成功把我们本地的 npm 包安装到 play 测试项目中了。</p>
<p>接着修改 <code>./play/main.ts</code> 内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">CobyteViteUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'cobyte-vite-ui'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'cobyte-vite-ui/dist/style.css'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
app.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">CobyteViteUI</span>)
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<p>我们直接引用我们本地创建的 npm 包。</p>
<p>接着修改 <code>./play/App.vue</code> 内容如下：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">co-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">co-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>最后我们运行 play 测试项目，结果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74f6c189f9d44171887736447e2e142d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=kvnojOly9beWhKfj52wsCyNla5U%3D" alt="image.png" loading="lazy"/></p>
<p>我们可以看到成功运行了本地组件库的 npm 包。</p>
<p>接下来我们希望不进行完整引入组件库：</p>
<pre><code class="hljs language-diff" lang="diff">import { createApp } from 'vue'
import App from './App.vue'
<span class="hljs-deletion">- import CobyteViteUI from 'cobyte-vite-ui'</span>
<span class="hljs-deletion">- import 'cobyte-vite-ui/dist/style.css'</span>

const app = createApp(App)
<span class="hljs-deletion">- app.use(CobyteViteUI)</span>
app.mount('#app')
</code></pre>
<p>即便这样我们同样可以在测试项目中使用我们的测试组件。</p>
<h3 data-id="heading-4">通过静态分析实现按需加载</h3>
<p>根据上文我们知道 App.vue 的模板内容会被编译成：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { resolveComponent <span class="hljs-keyword">as</span> _resolveComponent, createVNode <span class="hljs-keyword">as</span> _createVNode, openBlock <span class="hljs-keyword">as</span> _openBlock, createElementBlock <span class="hljs-keyword">as</span> _createElementBlock } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">const</span> _component_co_button = <span class="hljs-title function_">_resolveComponent</span>(<span class="hljs-string">"co-button"</span>)

  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createElementBlock</span>(<span class="hljs-string">"template"</span>, <span class="hljs-literal">null</span>, [
    <span class="hljs-title function_">_createVNode</span>(_component_co_button)
  ]))
}
</code></pre>
<p>那么根据上文我们知道需要把 <code>_resolveComponent("co-button")</code> 部分替换成对应的组件对象，内容如下：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-addition">+ import CoButton from 'cobyte-vite-ui/dist/components/button'</span>
<span class="hljs-addition">+ import 'cobyte-vite-ui/dist/style.css'</span>
import { resolveComponent as _resolveComponent, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache, $props, $setup, $data, $options) {
<span class="hljs-deletion">-  const _component_co_button = _resolveComponent("co-button")</span>
<span class="hljs-addition">+  const _component_co_button = CoButton</span>

  return (_openBlock(), _createElementBlock("template", null, [
    _createVNode(_component_co_button)
  ]))
}
</code></pre>
<p>那么要实现上述功能，我们得通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2Fguide%2Fapi-plugin" target="_blank" title="https://cn.vitejs.dev/guide/api-plugin" ref="nofollow noopener noreferrer">Vite 插件</a>来实现，我们在上面安装了一个 <code>@vitejs/plugin-vue</code> 插件，这个 Vite 插件的主要功能就是把 <code>.vue</code> 文件编译成上述的 js 内容。那么我们这样在它的后面继续添加一个插件在编译后的 js 内容中去实现上述替换功能即可。</p>
<p>我们在 <code>./packages/utils/index.ts</code> 文件中实现这个自动加载组件的 Vite 插件，实现如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MagicString</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'magic-string'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">VitePluginAutoComponents</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// 插件名称，用于调试和错误信息</span>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vite-plugin-auto-component'</span>,

    <span class="hljs-comment">// transform 钩子函数，在转换模块时调用</span>
    <span class="hljs-comment">// code: 文件内容，id: 文件路径</span>
    <span class="hljs-title function_">transform</span>(<span class="hljs-params">code, id</span>) {
      <span class="hljs-comment">// 使用正则表达式检查文件是否为.vue文件</span>
      <span class="hljs-comment">// 如果不是.vue文件，不进行处理</span>
      <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/\.vue$/</span>.<span class="hljs-title function_">test</span>(id)) {
          <span class="hljs-comment">// 创建 MagicString 实例，用于高效地修改字符串并生成 source map</span>
          <span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MagicString</span>(code)
          <span class="hljs-comment">// 初始化结果数组，用于存储匹配到的组件信息</span>
          <span class="hljs-keyword">const</span> results = []

          <span class="hljs-comment">// 使用 matchAll 方法查找所有匹配的 resolveComponent 调用</span>
          <span class="hljs-comment">// 正则表达式解释：</span>
          <span class="hljs-comment">// _?resolveComponent\d* - 匹配可能的函数名变体（可能带下划线或数字后缀）</span>
          <span class="hljs-comment">// \("(.+?)"\) - 匹配括号内的字符串参数</span>
          <span class="hljs-comment">// g - 全局匹配</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> code.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/_?resolveComponent\d*\("(.+?)"\)/g</span>)) {
              <span class="hljs-comment">// match[1] 是第一个捕获组，即组件名称字符串</span>
              <span class="hljs-keyword">const</span> matchedName = match[<span class="hljs-number">1</span>]
              <span class="hljs-comment">// 检查匹配是否有效：</span>
              <span class="hljs-comment">// match.index != null - 确保有匹配位置</span>
              <span class="hljs-comment">// matchedName - 确保捕获到组件名</span>
              <span class="hljs-comment">// !matchedName.startsWith('_') - 确保组件名不以_开头（可能是内部组件）</span>
              <span class="hljs-keyword">if</span> (match.<span class="hljs-property">index</span> != <span class="hljs-literal">null</span> &amp;&amp; matchedName &amp;&amp; !matchedName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'_'</span>)) {
                  <span class="hljs-comment">// 计算匹配字符串的起始位置</span>
                  <span class="hljs-keyword">const</span> start = match.<span class="hljs-property">index</span>
                  <span class="hljs-comment">// 计算匹配字符串的结束位置</span>
                  <span class="hljs-keyword">const</span> end = start + match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>
                  <span class="hljs-comment">// 将匹配信息存入结果数组</span>
                  results.<span class="hljs-title function_">push</span>({
                      <span class="hljs-attr">rawName</span>: matchedName,  <span class="hljs-comment">// 原始组件名称</span>
                      <span class="hljs-comment">// 创建替换函数，使用 MagicString 的 overwrite 方法替换指定范围的文本</span>
                      <span class="hljs-attr">replace</span>: <span class="hljs-function"><span class="hljs-params">resolved</span> =&gt;</span> s.<span class="hljs-title function_">overwrite</span>(start, end, resolved),
                  })
              }
          }

          <span class="hljs-comment">// 遍历所有匹配结果进行处理</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { rawName, replace } <span class="hljs-keyword">of</span> results) {
              <span class="hljs-comment">// 定义要替换的变量名（这里暂时编码为 CoButton）</span>
              <span class="hljs-keyword">const</span> varName = <span class="hljs-string">`CoButton`</span>
              <span class="hljs-comment">// 在代码开头添加导入语句：</span>
              <span class="hljs-comment">// 1. 导入 CoButton 组件</span>
              <span class="hljs-comment">// 2. 导入样式文件</span>
              s.<span class="hljs-title function_">prepend</span>(<span class="hljs-string">`import CoButton from 'cobyte-vite-ui/dist/components/button';\nimport 'cobyte-vite-ui/dist/style.css';\n`</span>)

              <span class="hljs-comment">// 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名</span>
              <span class="hljs-title function_">replace</span>(varName)
          }

          <span class="hljs-comment">// 返回转换后的代码</span>
          <span class="hljs-keyword">return</span> {
              <span class="hljs-attr">code</span>: s.<span class="hljs-title function_">toString</span>(),  <span class="hljs-comment">// 转换后的代码字符串</span>
              <span class="hljs-attr">map</span>: <span class="hljs-literal">null</span>, 
          }
      }
    },
  }
}
</code></pre>
<p>我们在上述 Vite 插件中使用到了一个新工具库 <code>magic-string</code>，我们需要安装一下它的依赖：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> magic-<span class="hljs-built_in">string</span> -D -w
</code></pre>
<p><code>magic-string</code> 是一个专注于字符串操作，主要作用是对源代码可以进行<strong>精准的插入、删除、替换等操作</strong>。</p>
<p>上述编写的 Vite 的插件主要是实现在<code>.vue</code> 文件中查找所有形如 <code>resolveComponent("xxx")</code> 的函数调用，对于每一个找到的调用，它会在文件顶部添加一个固定的导入语句，例如导入 <code>CoButton</code> 组件和样式。最后把找到的<code>resolveComponent("xxx")</code> 替换成对应的组件，例如 <code>CoButton</code>。</p>
<p>然后我们在根目录重新打包，接着在 play 目录中的 <code>vite.config.ts</code> 文件中进行以下修改：</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
<span class="hljs-addition">+ import AutoComponents from 'cobyte-vite-ui/dist/utils'</span>

// https://vite.dev/config/
export default defineConfig({
<span class="hljs-deletion">-  plugins: [vue()],</span>
<span class="hljs-addition">+  plugins: [vue(), AutoComponents()],</span>
})
</code></pre>
<p>接着我们再次重启 play 测试项目，我们可以看到即便我们不导入任何我们编写的组件库设置，我们依然可以在 play 项目中成功使用 <code>CoButton</code> 组件。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74f6c189f9d44171887736447e2e142d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=kvnojOly9beWhKfj52wsCyNla5U%3D" alt="image.png" loading="lazy"/></p>
<p>同时我们在网络窗口可以查看到 App.vue 文件的内容变化如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f36029b5c57d4c9ca82ddb0fecd2f3be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=t1CzRagQrOlUssF9zNOZpEvdDqI%3D" alt="image.png" loading="lazy"/></p>
<p>可以看到<strong>我们通过静态分析代码，识别并替换 Vue3 的组件解析函数，成功实现了组件的自动导入功能</strong>。但上述实现为了快速验证功能，无论匹配到的组件名是什么，都导入 <code>CoButton</code> 组件，并替换为 <code>CoButton</code>。这显然是不正确的，应该根据匹配到的组件名动态导入对应的组件。</p>
<h3 data-id="heading-5">自动化路径解析</h3>
<p>因为我们的组件编译后的调用变成 <code>_resolveComponent("co-button")</code>，组件名称变成了 <code>co-button</code>，而我们在导入的语句是这样的 <code>import CoButton from 'cobyte-vite-ui/dist/components/button'</code>，组件名称又需要变成 <code>CoButton</code>，所以我们需要把匹配到的 <code>co-button</code> 变成 <code>CoButton</code>。</p>
<p>代码迭代如下：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-addition">+ // 将字符串转换为帕斯卡命名（即大驼峰，每个单词首字母大写）</span>
<span class="hljs-addition">+ export function pascalCase(str: string) {</span>
<span class="hljs-addition">+    return capitalize(camelCase(str))</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ // 将字符串转换为驼峰命名  </span>
<span class="hljs-addition">+ export function camelCase(str: string) {</span>
<span class="hljs-addition">+    return str.replace(/-(\w)/g, (_, c) =&gt; (c ? c.toUpperCase() : ''))</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ // 将字符串的首字母大写，使用 charAt(0) 获取第一个字符并转换为大写，然后加上剩余字符串（从索引1开始）</span>
<span class="hljs-addition">+ export function capitalize(str: string) {</span>
<span class="hljs-addition">+    return str.charAt(0).toUpperCase() + str.slice(1)</span>
<span class="hljs-addition">+ }</span>

export default function VitePluginAutoComponents() {
    return {
      // 插件名称，用于调试和错误信息
      name: 'vite-plugin-auto-component',
  
      // transform 钩子函数，在转换模块时调用
      // code: 文件内容，id: 文件路径
      transform(code, id) {
        // 使用正则表达式检查文件是否为.vue文件
        // 如果不是.vue文件，不进行处理
        if(/\.vue$/.test(id)) {
            // 省略...
  
            // 遍历所有匹配结果进行处理
            for (const { rawName, replace } of results) {
<span class="hljs-addition">+                // 将字符串转换为大驼峰</span>
<span class="hljs-addition">+                const name = pascalCase(rawName)</span>
<span class="hljs-addition">+                // 只处理 Co 开头的组件</span>
<span class="hljs-addition">+                if (!name.match(/^Co[A-Z]/)) return</span>
                // 定义要替换的变量名
<span class="hljs-deletion">-                const varName = `CoButton`</span>
<span class="hljs-addition">+                const varName = name</span>
                // 在代码开头添加导入语句：
                // 1. 导入 CoButton 组件
                // 2. 导入样式文件
                s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/button';\nimport 'cobyte-vite-ui/dist/style.css';\n`)
  
                // 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名
                replace(varName)
            }
  
            // 返回转换后的代码
            return {
                code: s.toString(),  // 转换后的代码字符串
                map: null, 
            }
        }
      },
    }
}
</code></pre>
<p>经过上述实现还是存在以下问题，无论 <code>rawName</code> 是什么，组件都是从 <code>'cobyte-vite-ui/dist/components/button'</code> 这个固定路径导入。这意味着即使使用了 <code>resolveComponent("CoTable")</code>，插件依然会尝试从 <code>button</code> 文件导入，这显然是不正确的。理想情况下，导入路径应根据组件名动态生成。所以我们继续实现动态组件路径，例如 <code>CoTableColumn</code> 组件映射到 <code>'cobyte-vite-ui/dist/components/table-column'</code>。</p>
<p>我们上述的组件是 "CoButton"，那么转换过程则是：<br/>
"CoButton" -&gt; 去掉"Co" -&gt; "Button" -&gt; kebabCase -&gt; "button"。</p>
<p>我们通过实现一个 kebabCase 函数进行组件路径转换解析，实现如下：</p>
<pre><code class="hljs language-diff" lang="diff">// 省略...

<span class="hljs-addition">+ // 将驼峰命名的字符串转换为短横线分隔的字符串（即kebab-case）</span>
<span class="hljs-addition">+ export function kebabCase(key: string) {</span>
<span class="hljs-addition">+    const result = key.replace(/([A-Z])/g, ' $1').trim()</span>
<span class="hljs-addition">+    return result.split(' ').join('-').toLowerCase()</span>
<span class="hljs-addition">+ }</span>

export default function VitePluginAutoComponents() {
    return {
      // 插件名称，用于调试和错误信息
      name: 'vite-plugin-auto-component',
  
      // transform 钩子函数，在转换模块时调用
      // code: 文件内容，id: 文件路径
      transform(code, id) {
        // 使用正则表达式检查文件是否为.vue文件
        // 如果不是.vue文件，不进行处理
        if(/\.vue$/.test(id)) {
            // 省略...
  
            // 遍历所有匹配结果进行处理
            for (const { rawName, replace } of results) {
                // 将字符串转换为大驼峰
                const name = pascalCase(rawName)
                // 只处理 Co 开头的组件
                if (!name.match(/^Co[A-Z]/)) return
<span class="hljs-addition">+                // 组件路径转换</span>
<span class="hljs-addition">+                const partialName = kebabCase(name.slice(2))</span>
                // 定义要替换的变量名
                const varName = name
                // 在代码开头添加导入语句：
                // 1. 导入 CoButton 组件
                // 2. 导入样式文件
<span class="hljs-deletion">-                s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/button';\nimport 'cobyte-vite-ui/dist/style.css';\n`)</span>
<span class="hljs-addition">+                s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/${partialName}';\nimport 'cobyte-vite-ui/dist/style.css';\n`)</span>
  
                // 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名
                replace(varName)
            }
  
            // 返回转换后的代码
            return {
                code: s.toString(),  // 转换后的代码字符串
                map: null, 
            }
        }
      },
    }
}
</code></pre>
<p>经过上述迭代后，我们重新打包，重新启动 play 测试项目，我们发现我们的代码是能够正常运行的，说明我们上述的迭代是没有问题的。<strong>至此我们为组件自动导入提供了核心的路径解析能力</strong>。</p>
<h3 data-id="heading-6">引入解析器 (Resolver) 概念</h3>
<p>当前插件硬编码了组件库的路径和样式文件，只能用于特定的组件库（cobyte-vite-ui）。我们可以通过引入解析器(Resolver)，让插件支持不同的组件库，用户可以根据需要配置不同的解析器。</p>
<p>解析器的作用是根据组件名返回一个解析结果，包括组件的导入路径和样式文件路径以及组件原始名称。这样，插件就可以通过解析器返回的对象信息动态获取组件的导入信息，而不是固定写死。</p>
<p>在实现解析器之前，我们先设计解析器返回的对象结构如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> component = {
    name, <span class="hljs-comment">// 组件原始名称</span>
    <span class="hljs-attr">from</span>: <span class="hljs-string">`cobyte-vite-ui/dist/components/<span class="hljs-subst">${partialName}</span>`</span>, <span class="hljs-comment">// 组件的导入路径</span>
    <span class="hljs-attr">sideEffects</span>: [<span class="hljs-string">'cobyte-vite-ui/dist/style.css'</span>] <span class="hljs-comment">// 组件的样式文件路径</span>
}
</code></pre>
<p>为什么要这样设计？</p>
<ol>
<li>组件名 (name):<br/>
用于在导入语句中作为标识符。这里使用的是帕斯卡命名，因为它在 Vue 中通常用于组件注册和模板中。</li>
<li>导入路径 (from):<br/>
这里使用模板字符串动态构建导入路径。其中，<code>partialName</code> 是通过将组件名去掉前两个字符（即去掉"Co"）并转换为 kebab-case 得到的。<br/>
例如，组件名 "CoTableColumn" 转换为 "table-column"，然后拼接成路径 'cobyte-vite-ui/dist/components/table-column'。<br/>
这样设计是因为组件库的目录结构可能是按照 kebab-case 命名的，而组件在代码中是以帕斯卡命名使用的。</li>
<li>副作用 (sideEffects):<br/>
这是一个数组，指定在导入组件时需要同时导入的样式文件或其他资源。这里指定了组件库的全局样式文件。<br/>
注意：这个样式文件是全局的，也就是说，不管导入哪个组件，都会导入整个组件库的样式。这可能会造成样式冗余。<br/>
更精细的做法是为每个组件指定其对应的样式文件，例如：<br/>
sideEffects: [<code>cobyte-vite-ui/dist/components/${partialName}/style.css</code>]</li>
</ol>
<p>但是，我们当前组件库没有为每个组件单独提供样式文件，我们只提供了固定的全局样式文件。</p>
<p>上面设计解析器返回的对象封装了组件的完整导入信息，作为数据载体传递给后续处理函数，我们可以基于此进行迭代：</p>
<pre><code class="hljs language-diff" lang="diff">// 省略...

<span class="hljs-addition">+ // 根据传入的信息生成对应的导入语句字符串</span>
<span class="hljs-addition">+ export function stringifyImport(info) {</span>
<span class="hljs-addition">+    if (typeof info === 'string')</span>
<span class="hljs-addition">+      return `import '${info}'`</span>
<span class="hljs-addition">+    if (!info.as)</span>
<span class="hljs-addition">+      return `import '${info.from}'`</span>
<span class="hljs-addition">+    else if (info.name)</span>
<span class="hljs-addition">+      return `import { ${info.name} as ${info.as} } from '${info.from}'`</span>
<span class="hljs-addition">+    else</span>
<span class="hljs-addition">+      return `import ${info.as} from '${info.from}'`</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ // 根据组件的导入信息生成完整的导入语句，包括组件本身的导入和其副作用（如样式文件）的导入。</span>
<span class="hljs-addition">+ export function stringifyComponentImport({ as: name, from: path, name: importName, sideEffects }) {</span>
<span class="hljs-addition">+    const imports = [</span>
<span class="hljs-addition">+      // 生成组件导入语句</span>
<span class="hljs-addition">+      stringifyImport({ as: name, from: path, name: importName }),</span>
<span class="hljs-addition">+    ]</span>
  
<span class="hljs-addition">+    if (sideEffects) {</span>
<span class="hljs-addition">+      // 生成副作用导入语句</span>
<span class="hljs-addition">+      sideEffects.forEach(i =&gt; imports.push(stringifyImport(i)))</span>
<span class="hljs-addition">+    }</span>
  
<span class="hljs-addition">+    return imports.join(';')</span>
<span class="hljs-addition">+ }</span>

  export default function VitePluginAutoComponents() {
    return {
      // 插件名称，用于调试和错误信息
      name: 'vite-plugin-auto-component',
  
      // transform 钩子函数，在转换模块时调用
      // code: 文件内容，id: 文件路径
      transform(code, id) {
        // 使用正则表达式检查文件是否为.vue文件
        // 如果不是.vue文件，不进行处理
        if(/\.vue$/.test(id)) {
            // 省略...
<span class="hljs-addition">+            let no = 0</span>
            // 遍历所有匹配结果进行处理
            for (const { rawName, replace } of results) {
                // 将字符串转换为大驼峰
                const name = pascalCase(rawName)
                // 只处理 Co 开头的组件
                if (!name.match(/^Co[A-Z]/)) return
                // 组件路径转换
                const partialName = kebabCase(name.slice(2))
<span class="hljs-addition">+                // 封装了组件的完整导入信息，作为数据载体传递给后续处理函数</span>
<span class="hljs-addition">+                const component = {</span>
<span class="hljs-addition">+                    name,</span>
<span class="hljs-addition">+                    from: `cobyte-vite-ui/dist/components/${partialName}`,</span>
<span class="hljs-addition">+                    sideEffects: ['cobyte-vite-ui/dist/style.css']</span>
<span class="hljs-addition">+                }</span>
<span class="hljs-deletion">-                // 定义要替换的变量名（这里暂时编码为 CoButton）</span>
<span class="hljs-deletion">-                const varName = name</span>
<span class="hljs-addition">+                // 使用特殊前缀减少与用户变量的冲突，以及使用递增的序号，保证唯一性，避免变量名冲突</span>
<span class="hljs-addition">+                const varName = `__unplugin_components_${no}`</span>
                // 在代码开头添加导入语句：
                // 1. 导入 CoButton 组件
                // 2. 导入样式文件
<span class="hljs-deletion">-                 s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/${partialName}';\nimport 'cobyte-vite-ui/dist/style.css';\n`)</span>
<span class="hljs-addition">+                // 这里将 component 对象展开，并添加 as: varName 参数，形成完整的导入配置</span>
<span class="hljs-addition">+                s.prepend(`${stringifyComponentImport({ ...component, as: varName })};\n`)</span>
<span class="hljs-addition">+                no += 1</span>
                // 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名
                replace(varName)
            }
  
            // 返回转换后的代码
            return {
                code: s.toString(),  // 转换后的代码字符串
                map: null, 
            }
        }
      },
    }
}
</code></pre>
<p>我们添加了根据传入的信息生成对应的导入语句字符串的 <code>stringifyImport</code> 函数和根据组件的导入信息生成完整的导入语句，包括组件本身的导入和其副作用（如样式文件）的导入的 <code>stringifyComponentImport</code> 函数。其中 stringifyImport 处理单一导入语句，<code>stringifyComponentImport</code> 处理组合多个相关导入，实现了职责分离和配置灵活的设计优势。这两个函数共同构成了一个灵活的导入语句生成系统，为自动导入插件提供了强大的代码生成能力。</p>
<p>我们设计了一个解析结果包括：<code>name</code>（组件名）、<code>from</code>（导入路径）、<code>sideEffects</code>（样式等副作用导入）的数据结构对象 <code>component</code> 作为数据载体传递给后续处理函数，后续程序基于此来生成导入语句和替换代码。</p>
<p>其中变量名生成策略使用特殊前缀减少与用户变量的冲突从而<strong>避免污染</strong>，同时使用递增序号来<strong>保证唯一性</strong>。</p>
<p>最终我们实现了一个基于数据驱动的架构，将来解析器只负责识别组件和返回路径的数据信息，然后导入生成器函数，也就是上述的 <code>stringifyComponentImport</code> 和 <code>stringifyImport</code> 负责根据配置生成导入代码，我们整体的 Vite 插件就只负责协调流程和代码修改。</p>
<p>这种架构为后续引入真正的多解析器支持奠定了良好基础，只需要将硬编码的解析逻辑替换为可配置的解析器数组即可。</p>
<h3 data-id="heading-7">实现解析器 (Resolver)</h3>
<p>我们引入解析器是为了提高插件的灵活性和可扩展性。当前插件硬编码了组件库的路径和样式文件，只能用于特定的组件库（cobyte-vite-ui）。通过引入解析器，我们可以让插件支持不同的组件库，用户可以根据需要配置不同的解析器。</p>
<p>解析器的作用是根据组件名返回一个解析结果，包括组件的导入路径和样式文件路径等。这样，插件就可以通过解析器来动态获取组件的导入信息，而不是固定写死。</p>
<p>改造步骤：</p>
<ol>
<li>修改插件函数，使其可以接受一个选项对象，选项中包含解析器数组。</li>
<li>在插件内部，遍历解析器数组，对每个组件名尝试使用解析器进行解析。</li>
<li>如果某个解析器返回了结果，则使用该结果来生成导入语句。</li>
<li>如果没有解析器匹配，可以跳过该组件，也可以根据需求做其他处理。</li>
</ol>
<p>参考 <code>NaiveUi</code> 基于 <code>unplugin-vue-components</code> 实现的解析器结构：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">NaiveUiResolver</span>(<span class="hljs-params"/>): <span class="hljs-title class_">ComponentResolver</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'component'</span>,
    <span class="hljs-attr">resolve</span>: <span class="hljs-function">(<span class="hljs-params">name: string</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^(N[A-Z]|n-[a-z])/</span>))
        <span class="hljs-keyword">return</span> { name, <span class="hljs-attr">from</span>: <span class="hljs-string">'naive-ui'</span>, <span class="hljs-attr">sideEffects</span>: [] }
    },
  }
}
</code></pre>
<ul>
<li>解析器是一个对象，包含一个<code>resolve</code>方法，该方法接收组件名，返回一个解析结果对象或undefined。</li>
<li>解析结果对象包括：<code>name</code>（组件名，可选，默认使用原始名），<code>from</code>（导入路径），<code>sideEffects</code>（样式文件路径等，可选）</li>
</ul>
<p>我们还可以支持多种解析器，这样插件可以同时支持多个组件库。</p>
<p>下面我们按照这个思路改造插件代码。首先基于上述 <code>NaiveUi</code> 的解析器实现我们的测试组件的解析器，<code>./packages/utils/index.ts</code> 新增代码如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 解析器函数</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">CobyteViteUiResolver</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'component'</span>,
    <span class="hljs-attr">resolve</span>: <span class="hljs-function">(<span class="hljs-params">name: string</span>) =&gt;</span> {
      <span class="hljs-comment">// 只处理 Co 开头的组件</span>
      <span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^Co[A-Z]/</span>)) {
        <span class="hljs-keyword">const</span> partialName = <span class="hljs-title function_">kebabCase</span>(name.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// CoTableColumn -&gt; table-column</span>
        <span class="hljs-keyword">return</span> { 
          name, 
          <span class="hljs-attr">from</span>: <span class="hljs-string">`cobyte-vite-ui/dist/components/<span class="hljs-subst">${partialName}</span>`</span>, 
          <span class="hljs-attr">sideEffects</span>: [<span class="hljs-string">'cobyte-vite-ui/dist/style.css'</span>] 
        }
      }
    },
  }
}
</code></pre>
<p>接下来修改插件函数，使其可以接受一个选项对象，选项中包含解析器数组，采用上下文管理，因此我们引入 Context 类，创建 Context 类来管理插件配置和解析器，并缓存解析结果，接着在 transform 钩子中，使用 Context 实例来查找组件，而不是硬编码解析逻辑。</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-addition">+ export class Context {</span>
<span class="hljs-addition">+  options: any;</span>
<span class="hljs-addition">+  private _componentNameMap = {} // 组件缓存</span>
<span class="hljs-addition">+  constructor(private rawOptions: any) {</span>
<span class="hljs-addition">+    this.options = rawOptions</span>
<span class="hljs-addition">+  }</span>

<span class="hljs-addition">+  async findComponent(name: string) {</span>
<span class="hljs-addition">+    // 1. 检查缓存中是否有该组件的信息</span>
<span class="hljs-addition">+    let info = this._componentNameMap[name]</span>
<span class="hljs-addition">+    if (info) {</span>
<span class="hljs-addition">+      return info // 缓存命中，直接返回</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    // 2. 遍历所有解析器</span>
<span class="hljs-addition">+    for (const resolver of this.options.resolvers) {</span>
<span class="hljs-addition">+      const result = await resolver.resolve(name)</span>
<span class="hljs-addition">+      // 3. 判断解析器是否返回了结果</span>
<span class="hljs-addition">+      if (!result) {</span>
<span class="hljs-addition">+        continue</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      // 4. 构建完整组件信息</span>
<span class="hljs-addition">+      info = {</span>
<span class="hljs-addition">+        as: name, // 添加别名</span>
<span class="hljs-addition">+        ...result,</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      // 5. 存入缓存</span>
<span class="hljs-addition">+      this._componentNameMap[name] = info</span>
<span class="hljs-addition">+      return info</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    // 所有解析器都不匹配，返回 undefined</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+ }</span>

<span class="hljs-deletion">-  export default function VitePluginAutoComponents() {</span>
<span class="hljs-addition">+  export default function VitePluginAutoComponents(options = {}) {</span>
<span class="hljs-addition">+    // 创建 Context 实例，用于存储插件配置和组件信息</span>
<span class="hljs-addition">+    const ctx = new Context(options)</span>
    return {
      // 插件名称，用于调试和错误信息
      name: 'vite-plugin-auto-component',
  
      // transform 钩子函数，在转换模块时调用
      // code: 文件内容，id: 文件路径
      async transform(code, id) {
        // 使用正则表达式检查文件是否为.vue文件
        // 如果不是.vue文件，不进行处理
        if(/\.vue$/.test(id)) {
            // 省略...
            
            let no = 0
            // 遍历所有匹配结果进行处理
            for (const { rawName, replace } of results) {
                // 将字符串转换为大驼峰
                const name = pascalCase(rawName)
<span class="hljs-deletion">-                // 只处理 Co 开头的组件</span>
<span class="hljs-deletion">-                 if (!name.match(/^Co[A-Z]/)) return</span>
<span class="hljs-deletion">-                // 组件路径转换</span>
<span class="hljs-deletion">-                 const partialName = kebabCase(name.slice(2))</span>
<span class="hljs-deletion">-                // 封装了组件的完整导入信息，作为数据载体传递给后续处理函数</span>
<span class="hljs-deletion">-                 const component = {</span>
<span class="hljs-deletion">-                     name,</span>
<span class="hljs-deletion">-                     from: `cobyte-vite-ui/dist/components/${partialName}`,</span>
<span class="hljs-deletion">-                     sideEffects: ['cobyte-vite-ui/dist/style.css']</span>
<span class="hljs-deletion">-                 }</span>
<span class="hljs-addition">+                const component = await ctx.findComponent(name)</span>
<span class="hljs-addition">+                if (component) {</span>
                  // 定义要替换的变量名（这里暂时编码为 CoButton）
                  // const varName = name
                  // 使用特殊前缀减少与用户变量的冲突，以及使用递增的序号，保证唯一性，避免变量名冲突
                  const varName = `__unplugin_components_${no}`
                  // 在代码开头添加导入语句：
                  // 1. 导入 CoButton 组件
                  // 2. 导入样式文件
                  // s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/${partialName}';\nimport 'cobyte-vite-ui/dist/style.css';\n`)
                  // 这里将 component 对象展开，并添加 as: varName 参数，形成完整的导入配置
                  s.prepend(`${stringifyComponentImport({ ...component, as: varName })};\n`)
                  no += 1
                  // 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名
                  replace(varName)
<span class="hljs-addition">+                }</span>
            }
  
            // 返回转换后的代码
            return {
                code: s.toString(),  // 转换后的代码字符串
                map: null, 
            }
        }
      },
    }
}
</code></pre>
<p>插件初始化时，创建 Context 实例，传入options，其中包含解析器 resolvers。Context 类提供了一个findComponent方法，用于根据组件名查找组件信息。该方法会先查看缓存，如果缓存中没有，则依次调用每个解析器的 resolve 方法，直到有一个解析器返回结果。然后将结果缓存起来。在 transform 钩子中，使用 Context 实例的findComponent 方法来查找组件信息，而不再是硬编码解析逻辑。这次迭代使插件从单一组件库的支持扩展到多组件库，使用缓存提高性能，通过解析器模式提高扩展性，并且通过异步解析查找组件信息、为未来异步解析预留接口。</p>
<p>经过此次的迭代，我们的插件实现了真正的解耦，插件核心只负责流程控制，解析逻辑则完全由解析器处理，配置管理则由 Context 统一管理，标准化了解析器的接口，这样所有解析器都遵循相同的接口，由此实现了强大的拓展性。</p>
<p>接着我们更新 play 项目中的 Vite 配置文件 <code>vite.config.ts</code>，更新如下：</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
<span class="hljs-deletion">- import AutoComponents from 'cobyte-vite-ui/dist/utils'</span>
<span class="hljs-addition">+ import AutoComponents, { CobyteViteUiResolver} from 'cobyte-vite-ui/dist/utils'</span>

export default defineConfig({
<span class="hljs-deletion">-  plugins: [vue(), AutoComponents()]</span>
<span class="hljs-addition">+  plugins: [vue(), AutoComponents({</span>
<span class="hljs-addition">+    resolvers: [CobyteViteUiResolver()]</span>
<span class="hljs-addition">+  })],</span>
})
</code></pre>
<p>接着重新打包组件库，再重启 play 项目，我们发现依然正常，说明我们上述的改动是正确的。</p>
<h3 data-id="heading-8">多解析器配置</h3>
<p>上文说了我们实现了插件从单一组件库的支持扩展到多组件库的按需加载解析，那么下面就让我们来测试一下。
首先我们往 <code>packages/utils/index.ts</code> 文件添加 Naive UI 的解析器，代码如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * Resolver for Naive UI
 *
 * <span class="hljs-doctag">@link</span> https://www.naiveui.com/
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">NaiveUiResolver</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'component'</span>,
    <span class="hljs-attr">resolve</span>: <span class="hljs-function">(<span class="hljs-params">name: string</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'NaiveUiResolver'</span>, name, name.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^(N[A-Z]|n-[a-z])/</span>));
      <span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^(N[A-Z]|n-[a-z])/</span>))
        <span class="hljs-keyword">return</span> { name, <span class="hljs-attr">from</span>: <span class="hljs-string">'naive-ui'</span> }
    },
  }
}
</code></pre>
<p>这个解析器是完全从 <code>unplugin-vue-components</code> 插件中搬过来的，我们测试一下是否能够在我们实现的插件中使用。</p>
<p>接着我们在 play 项目中安装 Naive UI 的依赖：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> naive-ui
</code></pre>
<p>然后在 App.vue 文件中引用 Naive UI 的组件：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">co-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">co-button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">n-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>&gt;</span>naive-ui<span class="hljs-tag">&lt;/<span class="hljs-name">n-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>接着修改 <code>./play/vite.config.ts</code> 文件中的配置。</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
<span class="hljs-deletion">- import AutoComponents, { CobyteViteUiResolver } from 'cobyte-vite-ui/dist/utils'</span>
<span class="hljs-addition">+ import AutoComponents, { CobyteViteUiResolver, NaiveUiResolver } from 'cobyte-vite-ui/dist/utils'</span>

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue(), AutoComponents({
<span class="hljs-deletion">-   resolvers: [CobyteViteUiResolver()]</span>
<span class="hljs-addition">+    resolvers: [CobyteViteUiResolver(), NaiveUiResolver()]</span>
  })],
})
</code></pre>
<p>接着我们重新打包我们的测试组件库，再重启 play 测试项目，测试结果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f9fc0afaa6f74916a0a1ba1e7f0b866c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=NmSVWgC%2B09BWju5OVR4Mw3s6Ev8%3D" alt="01.png" loading="lazy"/></p>
<p>我们可以看到成功验证了我们上述的结论：<strong>我们实现了插件从单一组件库的支持扩展到多组件库的按需加载解</strong>。</p>
<p>我们上面所实现的插件其实就是 <code>unplugin-vue-components</code> 库的实现原理，在 Vue 技术栈中都是通过这个库来实现组件按需加载的。</p>
<h3 data-id="heading-9">业务组件库按需加载实践</h3>
<p>我们在 play 项目中安装 <code>unplugin-vue-components</code> 库来替换我们手写的插件。安装命令如下：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> unplugin-vue-components -D 
</code></pre>
<p>接着修改 play 项目中的 <code>vite.config.ts</code> 文件。</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
<span class="hljs-deletion">- import AutoComponent, { CobyteViteUiResolver, NaiveUiResolver } from 'cobyte-vite-ui/dist/utils'</span>
<span class="hljs-addition">+ import { CobyteViteUiResolver, NaiveUiResolver } from 'cobyte-vite-ui/dist/utils'</span>
<span class="hljs-addition">+ import AutoComponents from 'unplugin-vue-components/vite';</span>

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue(), AutoComponents({
    resolvers: [CobyteViteUiResolver(), NaiveUiResolver()]
  })],
})
</code></pre>
<p>然后重启 play 项目，我们发现我们的测试例子依然是正常运行的。所以我们一般的组件库或者业务组件库想要实现按需加载，只需要参考 <code>unplugin-vue-components</code> 库中提供的解析器，写一个符合自己的组件库的解析器再配合 <code>unplugin-vue-components</code> 即可。当然还有一个重要的前提，你的组件库得设计成模块化，即一个组件一个模块，互不关联或者弱关联。</p>
<h3 data-id="heading-10">业务组件库引用第三方组件库的按需加载</h3>
<p>我们知道所谓业务组件库，就是一些基于第三方组件库开发的组件库，比如基于 Element Plus、Naive UI 开发的组件库。那么我们修改一下我们的测试组件库 <code>./packages/components/button</code>，让它使用 Naive UI 的 button 组件，修改如下：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">n-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"warning"</span>&gt;</span>
    Warning
  <span class="hljs-tag">&lt;/<span class="hljs-name">n-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-title function_">defineOptions</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'co-button'</span>,
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">button</span> {
  <span class="hljs-attribute">color</span>: red;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p>接着我们重新打包测试组件库，然后重启 play 项目。我们发现测试组件库中 Naive UI 的按钮 Button 并没有生效。并且在浏览器的控制台报以下警报：</p>
<pre><code class="hljs language-css" lang="css">Failed <span class="hljs-selector-tag">to</span> resolve component: n-button
</code></pre>
<p>这是因为我们使用 Vite 来打包组件库，Vite 默认会把代码进行压缩混淆。我们可以看一下打包后的测试 button 组件的代码。可以看到原本应该是 <code>_resolveComponent("n-button")</code> 的代码，因为 Vite 进行了压缩混淆而变成了 o("n-button")。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a1fd47f258b45e7825b38666b32cef5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=xj9PMv0rEFl1dTwVMX%2F0Hu3GpE4%3D" alt="02.png" loading="lazy"/></p>
<p>而我们的插件是基于 <code>_resolveComponent</code> 为前缀进行匹配的，现在前缀被压缩了也就肯定匹配到不到了。所以简单的处理方法就是修改 Vite 打包配置，让其不进行压缩混淆，毕竟 Element Plus、Naive UI 这些开源组件库打包后的产物也没有进行压缩混淆。所以我们修改 Vite 打包配置禁止构建压缩混淆。修改根目录下的 <code>vite.config.ts</code> 如下：</p>
<pre><code class="hljs language-diff" lang="diff">// 省略...

export default defineConfig(({ command, mode }) =&gt; {
    // 主构建配置
    return {
        // 省略...
        build: {
<span class="hljs-addition">+            minify: false, // 禁止压缩混淆</span>
            // 省略...
        },
    };
});
</code></pre>
<p>我们发现打包后的组件代码不压缩混淆了，但还是不生效，这是因为我们写的插件只解析 <code>.vue</code> 文件，而我们打包后的文件变成了 <code>.mjs</code> 了，所以我们要修改一下 play 项目的 Vite 配置让 <code>.mjs</code> 文件也可以被解析。修改 <code>./play/vite.config.ts</code>  文件如下：</p>
<pre><code class="hljs language-diff" lang="diff">  // 省略...
export default defineConfig({
  plugins: [vue(), AutoComponents({
<span class="hljs-addition">+    include: [</span>
<span class="hljs-addition">+      /\.vue$/,</span>
<span class="hljs-addition">+      /\.mjs$/</span>
<span class="hljs-addition">+    ],</span>
    resolvers: [CobyteViteUiResolver(), NaiveUiResolver()]
  })],
})
</code></pre>
<p>经过上述修改后我们重启 play 项目，发现基于 Naive UI 二次开发的组件可以成功加载了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/40241ada01dc43be8f8adfdd50ebac34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=fTIbzwPyquF5rKqzxpe8urIlk2g%3D" alt="03.png" loading="lazy"/></p>
<h3 data-id="heading-11">依赖预构建配置</h3>
<p>我们知道 Vite 会在第一次启动的时候把依赖预构建并缓存到 <code>node_modules/.vite</code> 目录中。主要有以下几个原因：</p>
<ol>
<li>模块格式转换</li>
</ol>
<p>许多 npm 包使用的是 CommonJS 或 UMD 格式，而 Vite 在开发环境中使用的是原生 ES 模块（ESM）。预构建会将这些包转换为 ESM 格式，使其能够在浏览器中直接运行。</p>
<ol start="2">
<li>性能优化 - 减少 HTTP 请求</li>
</ol>
<p>某些包会有很多内部模块，如果不预构建，浏览器可能需要发起数百个 HTTP 请求。预构建会将这些模块打包成一个或少数几个文件。</p>
<p>典型例子：</p>
<ul>
<li>lodash-es 有超过 600 个内置模块</li>
<li>如果不预构建，会导致 600+ 个 HTTP 请求</li>
<li>预构建后只需要 1-2 个请求</li>
</ul>
<ol start="3">
<li>提升页面加载速度</li>
</ol>
<p>预构建使用 esbuild（用 Go 编写），速度比传统 JavaScript 打包工具快 10-100 倍。通过将依赖预先打包并缓存，可以显著提升开发服务器的启动速度和模块热更新（HMR）的响应速度。</p>
<p>默认的时候 Vite 是通过 import 语句进行分析需要预构建的依赖的，但我们使用按需加载的插件之后，在代码中就有些 npm 包不存在 import 语句了，所以需要我们手动通过 <code>optimizeDeps.include</code> 选项设置预构建。</p>
<p>我们对 <code>./play/vite.config.ts</code> 设置如下：</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { CobyteViteUiResolver, NaiveUiResolver } from 'cobyte-vite-ui/dist/utils'
import AutoComponents from 'unplugin-vue-components/vite';
<span class="hljs-addition">+ import pkg from './package.json';</span>
<span class="hljs-addition">+ const dependencies = Object.keys(pkg.dependencies);</span>

export default defineConfig({
  plugins: [vue(), AutoComponents({
    include: [
      /\.vue$/,
      /\.mjs$/
    ],
    resolvers: [CobyteViteUiResolver(), NaiveUiResolver()]
  })],
<span class="hljs-addition">+  optimizeDeps: {</span>
<span class="hljs-addition">+    include: [...dependencies]</span>
<span class="hljs-addition">+  }</span>
})
</code></pre>
<p>由于 Node 不处理虚拟链接，同时为了更真实验证真实场景，我们把测试组件库改成更加真实，首先修改 <code>./play/packages.json</code></p>
<pre><code class="hljs language-diff" lang="diff">{
  // 省略...
  "dependencies": {
<span class="hljs-deletion">-    "cobyte-vite-ui": "link:..",</span>
    "cobyte-vite-ui": "^1.0.0",
    "naive-ui": "^2.43.1",
    "vue": "^3.5.22"
  },
  // 省略...
}
</code></pre>
<p>同时删掉 <code>./play/node_modules</code> 目录中的 <code>cobyte-vite-ui</code> 虚拟目录，再重新创建一个 <code>cobyte-vite-ui</code> 目录，同时把根目录下的 <code>./dist</code> 目录中的内容和根目录下的 <code>packages.json</code> 文件复制到刚刚新创建的
<code>cobyte-vite-ui</code> 目录中，这相当于手动安装我们创建的测试组件库的依赖了。之后我们再删掉 <code>./play/node_modules/.vite</code> 目录的预构建缓存，再重启 play 项目。这时我们发现 <code>cobyte-vite-ui</code> 组件库中引用的 Naive UI 的 button 组件不生效了。这是因为我们把 <code>cobyte-vite-ui</code> 进行预构建后，它的内容就会被预构建后缓存到 <code>./play/node_modules/.vite</code> 目录中了，而 unplugin-vue-components 插件默认是不解析 <code>node_modules</code> 目录中的文件的，所以我们可以修改 unplugin-vue-components 插件的配置让其可以解析 <code>node_modules</code> 目录中的文件，但这不是最优的方案。最优的方案是在打包 <code>cobyte-vite-ui</code> 组件库的时候就
进行按需打包。我们在根目录下安装 <code>unplugin-vue-components</code> 依赖。</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> unplugin-vue-components -D -w
</code></pre>
<p>我们在安装上述依赖的时候，可能会报以下错误：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6746af5fde3446af853e12ef3aa69e0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=AaAWOg3oR8etvN4X%2FocknaSdzaQ%3D" alt="04.png" loading="lazy"/></p>
<p>这是因为我们刚刚把 play 目录中的测试组件库 <code>cobyte-vite-ui</code> 改了正式库一样的依赖，我们可以暂时把它改回虚拟依赖。</p>
<pre><code class="hljs language-diff" lang="diff">"dependencies": {
<span class="hljs-deletion">-    "cobyte-vite-ui": "^1.0.0",</span>
<span class="hljs-addition">+    "cobyte-vite-ui": "link:..",</span>
    "naive-ui": "^2.43.1",
    "vue": "^3.5.22"
},
</code></pre>
<p>再进行安装即可。</p>
<p>然后新增根目录下的 <code>vite.config.ts</code> 文件的配置：</p>
<pre><code class="hljs language-diff" lang="diff">// 省略...
<span class="hljs-addition">+ import AutoComponents from 'unplugin-vue-components/vite';</span>
<span class="hljs-addition">+ import { NaiveUiResolver } from 'unplugin-vue-components/resolvers';</span>

// 省略...

export default defineConfig(({ command, mode }) =&gt; {
    // 主构建配置
    return {
        plugins: [
            vue(),
<span class="hljs-addition">+            AutoComponents({</span>
<span class="hljs-addition">+                resolvers: [NaiveUiResolver()]</span>
<span class="hljs-addition">+            })</span>
        ],
        build: {
            // 省略...
            rollupOptions: {
                external: [
                    "vue", 
<span class="hljs-addition">+                    "naive-ui", // 排除打包</span>
                ],
            // 省略..
            },
        },
    };
});
</code></pre>
<p>配置完后，重新打包我们的测试组件库，打包完后，重新删掉 <code>./play/node_modules/.vite</code> 中的缓存，和 <code>./play/node_modules/cobyte-vite-ui</code> 中的内容，重新把刚刚新打包的根目录下的 <code>./dist</code> 目录中的内容和根目录下的 <code>packages.json</code> 文件复制到 <code>./play/node_modules/cobyte-vite-ui</code> 中，同时恢复修改的 <code>./play/packages.json</code> 文件，然后重启 play 项目。</p>
<p>这时我们就发现测试项目可以正常渲染了。</p>
<p>至此我们业务组件库按需加载的实现原理就都讲得差不多了，有什么可以在评论区交流。</p>
<h3 data-id="heading-12">总结</h3>
<p>看完了全篇文章相信你会觉得，所谓组件库按需加载或者业务组件库按需加载其实很简单，首先组件库的每一个组件都得设计成独立的模块，并且可以按模块导入，也就是 ESM 化，可以进行 Tree Shaking，只有这样按需加载才有意义，才能达到减小包体积的作用。</p>
<p>全局组件在模板中使用被编译后会通过一个内置函数 <strong>resolveComponent</strong> 来调用组件，按需加载的实现原理就是通过插件进行正则匹配查找编译后的模板代码中的 <strong>resolveComponent</strong> 函数的相关代码来找到需要按需加载的组件，然后自动按编译后的代码的头部添加需要加载的组件的导入语句代码以及替换掉 <strong>resolveComponent</strong> 函数的相关代码为对应的组件对象。</p>
<p>而业务组件实现按需加载的关键是需要在业务组件库打包的时候也进行按需加载配置。虽然这个关键步骤很简单，但由于这是一个低频且跨项目的需求，所以AI对低频的需求的实现和给的解决方案都不尽人意，至少本人解决上述问题时，AI提供方案没有一个可以实现的，虽然最后的实现其实很简单。</p>
<p>最后，再说说个人对AI的一些感悟吧，个人觉得在AI时代，就编程这个领域而言对个人的专业要求会比以前更加的高，至少你得有能力去解决AI不会的问题。</p>
<p>上述组件库测试代码地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Famebyte%2Fcobyte-vite-ui" target="_blank" title="https://github.com/amebyte/cobyte-vite-ui" ref="nofollow noopener noreferrer">github.com/amebyte/cob…</a></p>
<p>欢迎关注本专栏，了解更多 Element Plus 组件库知识</p>
<p>本专栏文章：</p>
<p><a href="https://juejin.cn/post/7143196940992413709" target="_blank" title="https://juejin.cn/post/7143196940992413709">1. Vue3 组件库的设计和实现原理</a></p>
<p><a href="https://juejin.cn/post/7146183222425518093" target="_blank" title="https://juejin.cn/post/7146183222425518093">2. 组件库工程化实战之 Monorepo 架构搭建</a></p>
<p><a href="https://juejin.cn/post/7153659360177029150" target="_blank" title="https://juejin.cn/post/7153659360177029150">3. ESLint 核心原理剖析</a></p>
<p><a href="https://juejin.cn/post/7157743898939359262" target="_blank" title="https://juejin.cn/post/7157743898939359262">4. ESLint 技术原理与实战及代码规范自动化详解</a></p>
<p><a href="https://juejin.cn/post/7161063570594070559" target="_blank" title="https://juejin.cn/post/7161063570594070559">5. 从终端命令解析器说起谈谈 npm 包管理工具的运行原理</a></p>
<p><a href="https://juejin.cn/post/7165503808217284616" target="_blank" title="https://juejin.cn/post/7165503808217284616">6. CSS 架构模式之 BEM 在组件库中的实践</a></p>
<p><a href="https://juejin.cn/post/7168835045984043022" target="_blank" title="https://juejin.cn/post/7168835045984043022">7. 组件实现的基本流程及 Icon 组件的实现</a></p>
<p><a href="https://juejin.cn/post/7170716245762048036" target="_blank" title="https://juejin.cn/post/7170716245762048036">8. 为什么组件库或插件需要定义 peerDependencies</a></p>
<p><a href="https://juejin.cn/post/7179257832632483896" target="_blank" title="https://juejin.cn/post/7179257832632483896">9. 组件开发中 Vue3 相关知识的应用与解析及 Button 组件的实现</a></p>
<p><a href="https://juejin.cn/post/7186683381470462007" target="_blank" title="https://juejin.cn/post/7186683381470462007">10. CSS 系统颜色和暗黑模式的关系及意义</a></p>
<p><a href="https://juejin.cn/post/7190370726677839932" target="_blank" title="https://juejin.cn/post/7190370726677839932">11. 深入理解组件库中SCSS和CSS变量的架构应用和实践</a></p>
<p><a href="https://juejin.cn/post/7204454572890046501" target="_blank" title="https://juejin.cn/post/7204454572890046501">12. 组件 v-model 的封装实现原理及 Input 组件的核心实现</a></p>
<p><a href="https://juejin.cn/post/7217399337989881911" target="_blank" title="https://juejin.cn/post/7217399337989881911">13. 深入理解 Vue3 的 v-model 及自定义指令的实现原理</a></p>
<p><a href="https://juejin.cn/post/7249299811497066551" target="_blank" title="https://juejin.cn/post/7249299811497066551">14. React 和 Vue 都离不开的表单验证工具库 async-validator 之策略模式的应用</a></p>
<p><a href="https://juejin.cn/post/7258966810350174263" target="_blank" title="https://juejin.cn/post/7258966810350174263">15. Form 表单的设计与实现</a></p>
<p><a href="https://juejin.cn/post/7313380227160522763" target="_blank" title="https://juejin.cn/post/7313380227160522763">16. 组件库的打包原理与实践详解</a></p>
<p><a href="https://juejin.cn/post/7572480736362119174" target="_blank" title="https://juejin.cn/post/7572480736362119174">17. Vue3 业务组件库按需加载的实现原理</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我用 SOLO Coder 做 Excalidraw 开源项目二次开发]]></title>    <link>https://juejin.cn/post/7572697146286735410</link>    <guid>https://juejin.cn/post/7572697146286735410</guid>    <pubDate>2025-11-16T00:17:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572697146286735410" data-draft-id="7572387666979979290" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我用 SOLO Coder 做 Excalidraw 开源项目二次开发"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2025-11-16T00:17:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不惑_"/> <meta itemprop="url" content="https://juejin.cn/user/1471609400466218"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我用 SOLO Coder 做 Excalidraw 开源项目二次开发
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1471609400466218/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不惑_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T00:17:44.000Z" title="Sun Nov 16 2025 00:17:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我总觉得，真正的二次开发不是把功能贴到代码里那么简单，而是要在一个有生命力的开源项目里，摸索出它的气质和脉络，然后把自己的改动像一块合适的木料，打磨到恰好咬合的位置。Excalidraw 正好是那种适合雕琢的项目：接口清晰、结构分明、社区稳健，甚至它的白板本身就鼓励你在上面画来画去。于是我把一个小愿望丢给 SOLO Coder：把文本 → 图形的智能生成做进来，流程图也好，思维导图也罢，最好的结果就是我能在编辑器里写一句话，轻轻一点，就看到图像在面前成形。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44c9372d06e84782bc5118f4f5aad85a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=RC5YxC7RVoQcAgqy1bxDgb8PN4M%3D" alt="image.png" loading="lazy"/></p>
<p>这是一篇完整的AI绘图功能二次开发笔记：我用 SOLO Coder 在 Excalidraw 开源项目中增加文本→图形的 AI 能力，支持流程图与思维导图，并在编辑器里直接预览和插入。文章覆盖环境搭建、前后端改造、联调验证、问题处理与可复制的操作步骤，先看效果吧。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ccc064be923f4f33aa161ff06c16a3b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=RaInPrvxWlWbgdAc6HCl%2F1%2Fj1tE%3D" alt="1114-2.gif" loading="lazy"/></p>
<p>你将获得</p>
<ul>
<li>在主菜单新增AI绘图入口，打开文本转图对话框（TTD）</li>
<li>前端将文本与图类型发送到后端；后端接入豆包（Volcengine Ark）生成 Mermaid 文本</li>
<li>预览区渲染并一键插入到画布；失败时有清洗与兜底策略</li>
</ul>
<p>在此之前，我们已经通过SOLO Coder 部署了本地的Excalidraw，接着要找入口，找一个人走近白板时自然会按下的地方。我把AI绘图放到主菜单里，让它像一个轻微的邀请而不是强制的引导。点击以后，前端抛给我第一个态度不好的报错：<code>setAppState is not a function</code>。两秒钟的心情起伏之后，我意识到是这个问题可以通过AI去解决，于是我把AI产生的问题换个了AI。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5f338985e11406b9860ce6e8fcf6165~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=SJLxzCniCWg6aBii2Pvtg3Yj9Bo%3D" alt="image.png" loading="lazy"/>
不难发现，它很快修复了这个问题，Excalidraw 的命令式接口里没有这个方法，应该用 <code>updateScene</code>。把全局事件改成 <code>updateScene({ appState: { openDialog: ... } })</code>，对话框乖乖弹出来，像终于滑到桌面正中间的一杯茶。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ff559656a01476f87b1c4964105393b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=QxiB4NbZKEmsniQ%2FAzMthsodwDg%3D" alt="image.png" loading="lazy"/>
这扇窗叫 TTD，对话框的全名是 Text-to-Diagram。也就是 Text-to-Diagram。对话框的形态很友好，左边一个文本框，右边一个预览区，鼠标在文本框里点击一下，那种手指压下去的瞬间，我顺手截了一张图，留作交互起点的标记。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d2a10c0cf9c474eaa863bed731efa38~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=unYW20bZPrUY%2FyH1AhcX1cZ0HUY%3D" alt="image.png" loading="lazy"/>
第一次按下Generate，我看到的是一片沉默，预览区安静地不动，还给我抛了一个Generated an invalid diagram。我把这个截图也留下，作为一次不太成功的尝试。那会儿我就明白了，这不是没调用，而是调用了，但返回的 Mermaid 文本不合身。思维导图的 Mermaid 语法算是实验性，转换库不是对所有情况都拿得很稳。于是我把后端派上台，搭了一个干净的 ai-backend ，用 Express 做路由，让它站在 excalidraw-master 的旁边，同时悄悄接入豆包（Volcengine Ark）的 Chat Completions，用 .env.local 留住密钥，不往前端暴露，保持整个结构清爽。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2678a90256624a3d928c1cf9c57e0aa3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=H07Z5HgwuhGmbTnB3mWtOEkwAKM%3D" alt="image.png" loading="lazy"/></p>
<p>后端这边，我直接把豆包API输入个SOLO。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/788f70c912c3481ba51dab0abaf55e2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=ryqs5pm7F3UA%2BSSpRI%2B2DI3CE6U%3D" alt="image.png" loading="lazy"/></p>
<p>这里有详解的API文档：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a761f7773fc40099239adccf93a0852~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=pZg82gVjaAonuZXXlMvFp284wM4%3D" alt="image.png" loading="lazy"/></p>
<p>接下来会新建一个 <code>ai-backend</code>，让它站在主项目的旁侧，单纯、安静，读 <code>.env.local</code> 里的密钥，不把任何敏感信息暴露到前端，也不往仓库里乱提交。路由只做一件事：<code>/v1/ai/text-to-diagram/generate</code> 接受 <code>prompt</code> 和 <code>type</code>，优先调用豆包 Ark Chat Completions，把返回的内容清洗一下。</p>
<p>我很在意交互的微妙。TTD 对话框里那段英文提示，说系统目前用 Mermaid 当中间步骤，这句话像一个前置的协议：你要么给我流程、要么给我结构，我来想办法帮你成长为图像。用户写的是人话，模型理解的是人话，但预览需要的是规整的语言。所以我把类型的选择前置到生成动作的上方，让这组 UI 形成一个心智链条：输入、选择、生成、预览、插入。你能感到手势的顺畅，能看到预期的结果，这比任何文档提示都有效。</p>
<p>过程中有一些次要的插曲，比如浏览器标签意外打开旧端口 3000，所以事件监听并没有注册到你看的页面上；比如我一度尝试用 <code>window.addEventListener</code> 做一些全局控制，后来还是把它规整到 <code>useEffect</code>，跟着 <code>excalidrawAPI</code> 走生命周期；比如Mermaid 原文那一页会让人想查看细节，我就保留了View as Mermaid的跳转，给调试者一个后备的工具。每一个小动作都不是必须，但它们是贴心，我希望这套体验不是硬塞进去的功能，而是一种自然的延伸。</p>
<p>豆包的接入自己也带了一点个性。我把密钥放在本地 <code>.env.local</code> 里，不在代码里落笔，也不在终端里写长串的临时变量。模型的参数没有走极端，<code>max_completion_tokens</code> 设个温和的上限，<code>reasoning_effort</code> 放在中等，确保稳定和成本可控。有时为了让预览稳定，我会把 Mindmap 的生成提示悄悄引导成 Flowchart 的层级表达，毕竟转换链路对流程图更友好，这不是背叛，更像是一个实用主义的选择。用户要的是看到结构并可编辑的图形，图的样式可以慢慢打磨，但空白的预览等不及。</p>
<p>这时候整条链路开始有了握手的感觉。我在首页截图之后，又截了一个主菜单展开的画面，那里有AI绘图这个新朋友。我点开对话框，在文本框里敲了一段结构——比如把项目规划放在首行，然后用短句把目标范围时间资源团队预算一行一行列出来，然后按下Generate。这回预览区不再冷场，图像从右边长出来，节点紧紧排列，像把散落的书页用线穿在一起。我让它落到画布中央，放大一点，给这个时刻留一张干净的截图。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06827f2c5b5f47cea490247124f5e17a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=4bEMWKimkbIA9yfzYrI7EG5AcW0%3D" alt="image.png" loading="lazy"/></p>
<p>接下来点击Insert按钮，就可以将内容插入到画布中。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6508bd6916cc41dbb9b238748e363c0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=vbRCSy2zV9VNECpx1p1IKCLSYKs%3D" alt="image.png" loading="lazy"/></p>
<p>偶尔，它还会闹些情绪。比如你输入了太长的一段话，没有清晰的结构，它会再次用Generated an invalid diagram提醒你，语气像朋友。这个时候，不要把锅丢给模型，稍微调整一下文本，把主题放在第一行，把一级要点一行一个，风格更像大纲，再按一下生成。它会给你面子，预览就出来了。如果你想更确定一点，把右上角的类型切到 Flowchart，它几乎不会让你失望。</p>
<p>写到这里，我开始觉得这件事并不只是给项目加了一个AI功能。它更像是让一个成熟的工具，学会听另一种语言。Excalidraw 原本鼓励你用手去画，现在它也可以理解你说画一个这样的结构。TTD 对话框不是魔法，它只是一个理性的桥梁，把人的表达连接到图的表达，帮你跨过去。SOLO Coder 在这件事上扮演的角色，是把那些易碎的衔接点，替你稳稳地固定住。下载、安装、起服务、修事件、接模型、清文本、兜底，这些看起来像是工程细节，但它们构成了整个体验的实感。</p>
<p>如果你问我，SOLO Coder 在这件事里做了什么，我想说它并没有替我写掉所有代码，但它帮我把那条从下载到看见的路径铺平了。在本地拉起项目，协调工作区依赖、启动 Vite，修好入口事件，把后端服务跑起来，豆包的密钥藏在 .env.local ，调用链条串上去，预览链条又稳住，再给这条路放几个路标，这些工作听起来不起眼，却让一切变得顺畅。二次开发真正的魅力在于此：你不是把自己的想法贴上去，而是把它揉进来，跟项目的语言在一起，跟它的节奏在一起。</p>
<p>我把这篇文章写成一段连续的叙事，不讲首先、其次、最后，不做报告那样堆观点。我只是把自己的实操摊开，让那些按键、链接、路径、拐角、错误和修复全都在地上，带着你走过一次。等你走完，你会发现你也能这样，把一个想法交给 SOLO Coder，给它一个被验证的出口，只要你愿意在中间补上一点点耐心，这条路会变得像一条平整的木板道，踩上去不会发出吱嘎的声响。这个项目于是有了一个新习惯：不仅用手画，还能用话画。图像不再需要你去一个个摆放，它可以按照你的文字，自己站在画布上。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 中的迭代机制：Sequence、Collection 与 Iterator 完全拆解]]></title>    <link>https://juejin.cn/post/7573506713865863219</link>    <guid>https://juejin.cn/post/7573506713865863219</guid>    <pubDate>2025-11-17T08:23:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573506713865863219" data-draft-id="7571729676344049727" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 中的迭代机制：Sequence、Collection 与 Iterator 完全拆解"/> <meta itemprop="keywords" content="Swift"/> <meta itemprop="datePublished" content="2025-11-17T08:23:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unravel2025"/> <meta itemprop="url" content="https://juejin.cn/user/1116759541421880"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 中的迭代机制：Sequence、Collection 与 Iterator 完全拆解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759541421880/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unravel2025
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:23:31.000Z" title="Mon Nov 17 2025 08:23:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>日常开发里，我们写 <code>for item in list</code> 像呼吸一样自然。</p>
<p>但 Swift 编译器在背后悄悄做了三件事：</p>
<ol>
<li>调用 <code>list.makeIterator()</code> 拿到一个迭代器</li>
<li>反复调用 <code>iterator.next()</code></li>
<li>把返回的可选值解包后赋给 <code>item</code></li>
</ol>
<p>一旦理解这三步，你就能</p>
<ul>
<li>自己写“能 for-in 的数据结构”</li>
<li>避免“遍历同时修改”导致的崩溃</li>
<li>把回调式 API 优雅地转成 <code>AsyncSequence</code></li>
</ul>
<h2 data-id="heading-1">Sequence：最小迭代单元</h2>
<p>协议定义（核心部分，Swift 5.9 仍不变）</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Iterator</span>: <span class="hljs-type">IteratorProtocol</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span> <span class="hljs-operator">==</span> <span class="hljs-type">Element</span>
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IteratorProtocol</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Element</span>?
}
</code></pre>
<p>关键知识点</p>
<ol>
<li>Sequence 只承诺“能生成迭代器”，不保证能反复遍历，也不保证有 <code>count</code>。</li>
<li>迭代器几乎总是 <code>struct</code>：值语义保证“复制一份就从头开始”，不会意外共享状态。</li>
<li>单趟序列（例如网络流）完全合法；第二次 <code>makeIterator()</code> 可以返回空迭代器。</li>
</ol>
<p>代码示例：自定义一个“从 n 倒数到 0”的序列</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Countdown</span>: <span class="hljs-title class_">Sequence</span> {
    <span class="hljs-keyword">let</span> start: <span class="hljs-type">Int</span>
    
    <span class="hljs-comment">// 每次 for-in 都会调用一次，生成新的迭代器</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span> {
        <span class="hljs-type">Iterator</span>(current: start)
    }
    
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iterator</span>: <span class="hljs-title class_">IteratorProtocol</span> {
        <span class="hljs-keyword">var</span> current: <span class="hljs-type">Int</span>
        
        <span class="hljs-comment">// 返回 nil 时代表迭代结束</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Int</span>? {
            <span class="hljs-keyword">guard</span> current <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> }
            <span class="hljs-keyword">defer</span> { current <span class="hljs-operator">-=</span> <span class="hljs-number">1</span> }          <span class="hljs-comment">// 先返回，再减</span>
            <span class="hljs-keyword">return</span> current
        }
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> <span class="hljs-type">Countdown</span>(start: <span class="hljs-number">3</span>) {
    <span class="hljs-built_in">print</span>(number)   <span class="hljs-comment">// 3 2 1 0</span>
}
</code></pre>
<h2 data-id="heading-2">Collection：在 Sequence 上加了三把锁</h2>
<p>Collection 额外保证</p>
<ul>
<li>可多次遍历且顺序稳定（除非自己把文档写错）</li>
<li>提供 <code>count</code>、<code>endIndex</code>、下标访问</li>
<li>支持切片、前缀、后缀等默认实现</li>
</ul>
<p>协议片段</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Collection</span>: <span class="hljs-title class_">Sequence</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Index</span>: <span class="hljs-type">Comparable</span>
    <span class="hljs-keyword">var</span> startIndex: <span class="hljs-type">Index</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> endIndex: <span class="hljs-type">Index</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">position</span>: <span class="hljs-type">Index</span>) -&gt; <span class="hljs-type">Element</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">after</span> <span class="hljs-params">i</span>: <span class="hljs-type">Index</span>) -&gt; <span class="hljs-type">Index</span>
}
</code></pre>
<p>因为多趟安全，<code>map</code>、<code>filter</code> 可以提前分配内存；</p>
<p>因为下标存在，<code>Array</code>、<code>Dictionary</code>、<code>Set</code> 都直接 conform。</p>
<h2 data-id="heading-3">for-in 的糖衣剥开长这样</h2>
<p>编译器把</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> container {
    <span class="hljs-built_in">print</span>(element)
}
</code></pre>
<p>翻译成</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">var</span> iterator <span class="hljs-operator">=</span> container.makeIterator()
<span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> element <span class="hljs-operator">=</span> iterator.next() {
    <span class="hljs-built_in">print</span>(element)
}
</code></pre>
<p>理解这段模板代码，你就能：</p>
<ul>
<li>在 Playground 里手动模拟 <code>for</code> 循环</li>
<li>把“遍历同时修改”的崩溃场景复现出来</li>
</ul>
<h2 data-id="heading-4">遍历同时修改：崩溃现场与三种安全写法</h2>
<p>现场：遍历数组时删除元素</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">var</span> todoItems <span class="hljs-operator">=</span> [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>]

<span class="hljs-comment">// 目前倒是没有崩溃，但是也不是很符合逻辑</span>
<span class="hljs-keyword">for</span> (index, item) <span class="hljs-keyword">in</span> todoItems.enumerated() {
    <span class="hljs-keyword">if</span> item <span class="hljs-operator">==</span> <span class="hljs-string">"B"</span> {
        todoItems.remove(at: index)   <span class="hljs-comment">// ❌ Fatal error: Collection modified while enumerating</span>
    }
}
</code></pre>
<p>原因：数组缓冲区搬迁，迭代器指针失效。</p>
<p>三种安全写法：</p>
<ol>
<li>官方一次性 API</li>
</ol>
<pre><code class="hljs language-swift" lang="swift">todoItems.removeAll { <span class="hljs-variable">$0</span> <span class="hljs-operator">==</span> <span class="hljs-string">"B"</span> }
</code></pre>
<ol start="2">
<li>先记下索引，后删除</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> indexesToRemove <span class="hljs-operator">=</span> todoItems.indices.filter { todoItems[<span class="hljs-variable">$0</span>] <span class="hljs-operator">==</span> <span class="hljs-string">"B"</span> }
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> indexesToRemove.reversed() {
    todoItems.remove(at: i)
}
</code></pre>
<ol start="3">
<li>过滤后整体替换</li>
</ol>
<pre><code class="hljs language-swift" lang="swift">todoItems <span class="hljs-operator">=</span> todoItems.filter { <span class="hljs-variable">$0</span> <span class="hljs-operator">!=</span> <span class="hljs-string">"B"</span> }
</code></pre>
<h2 data-id="heading-5">AsyncSequence：把“迭代”搬到异步世界</h2>
<p>协议定义</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AsyncSequence</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">AsyncIterator</span>: <span class="hljs-type">AsyncIteratorProtocol</span> <span class="hljs-keyword">where</span> <span class="hljs-type">AsyncIterator</span>.<span class="hljs-type">Element</span> <span class="hljs-operator">==</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeAsyncIterator</span>() -&gt; <span class="hljs-type">AsyncIterator</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AsyncIteratorProtocol</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Element</span>?
}
</code></pre>
<p>消费方式</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> element <span class="hljs-keyword">in</span> stream {
    <span class="hljs-built_in">print</span>(element)          <span class="hljs-comment">// 会在每次 next() 挂起时让出线程</span>
}
</code></pre>
<p>桥接回调式 API 的模板：进度条场景</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">makeProgressStream</span>() -&gt; <span class="hljs-type">AsyncStream</span>&lt;<span class="hljs-type">Double</span>&gt; {
    <span class="hljs-type">AsyncStream</span> { continuation <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">let</span> token <span class="hljs-operator">=</span> <span class="hljs-type">ProgressCenter</span>.onUpdate { value <span class="hljs-keyword">in</span>
            continuation.yield(value)
            <span class="hljs-keyword">if</span> value <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1.0</span> { continuation.finish() }
        }
        continuation.onTermination <span class="hljs-operator">=</span> { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span>
            <span class="hljs-type">ProgressCenter</span>.removeObserver(token)
        }
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-type">Task</span> {
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> p <span class="hljs-keyword">in</span> makeProgressStream() {
        progressView.progress <span class="hljs-operator">=</span> <span class="hljs-type">Float</span>(p)
    }
}
</code></pre>
<h2 data-id="heading-6">自己动手：一个固定容量的 RingBuffer</h2>
<p>需求：保持最新 N 条日志，支持 for-in 打印。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RingBuffer</span>&lt;<span class="hljs-title class_">Element</span>&gt;: <span class="hljs-title class_">Collection</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> storage: [<span class="hljs-type">Element</span>?]   <span class="hljs-comment">// 用 Optional 占位</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> head <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tail <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> count <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> capacity: <span class="hljs-type">Int</span>
    
    <span class="hljs-keyword">init</span>(<span class="hljs-params">capacity</span>: <span class="hljs-type">Int</span>) {
        <span class="hljs-keyword">self</span>.capacity <span class="hljs-operator">=</span> capacity
        storage <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(repeating: <span class="hljs-literal">nil</span>, count: capacity)
    }
    
    <span class="hljs-comment">// 写入新元素，覆盖最旧数据</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">append</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">newElement</span>: <span class="hljs-type">Element</span>) {
        storage[tail] <span class="hljs-operator">=</span> newElement
        tail <span class="hljs-operator">=</span> (tail <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">%</span> capacity
        <span class="hljs-keyword">if</span> count <span class="hljs-operator">==</span> capacity {
            head <span class="hljs-operator">=</span> (head <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">%</span> capacity   <span class="hljs-comment">// 丢弃最旧</span>
        } <span class="hljs-keyword">else</span> {
            count <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
        }
    }
    
    <span class="hljs-comment">// MARK: Collection 必备</span>
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">Index</span> <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>
    
    <span class="hljs-keyword">var</span> startIndex: <span class="hljs-type">Int</span> { <span class="hljs-number">0</span> }
    <span class="hljs-keyword">var</span> endIndex: <span class="hljs-type">Int</span> { count }
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">after</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> {
        <span class="hljs-built_in">precondition</span>(i <span class="hljs-operator">&lt;</span> endIndex, <span class="hljs-string">"Index out of bounds"</span>)
        <span class="hljs-keyword">return</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>
    }
    
    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">position</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Element</span> {
        <span class="hljs-built_in">precondition</span>((<span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>count).contains(position), <span class="hljs-string">"Index out of bounds"</span>)
        <span class="hljs-keyword">let</span> offset <span class="hljs-operator">=</span> (head <span class="hljs-operator">+</span> position) <span class="hljs-operator">%</span> capacity
        <span class="hljs-keyword">return</span> storage[offset]<span class="hljs-operator">!</span>
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">var</span> buffer <span class="hljs-operator">=</span> <span class="hljs-type">RingBuffer</span>&lt;<span class="hljs-type">Int</span>&gt;(capacity: <span class="hljs-number">3</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">5</span> {
    buffer.append(i)   <span class="hljs-comment">// 1,2,3 → 2,3,4 → 3,4,5</span>
}

<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> buffer {
    <span class="hljs-built_in">print</span>(value)   <span class="hljs-comment">// 3 4 5</span>
}
</code></pre>
<h2 data-id="heading-7">总结与扩展场景</h2>
<ol>
<li>协议层次</li>
</ol>
<p><code>IteratorProtocol</code> → <code>Sequence</code> → <code>Collection</code> → <code>BidirectionalCollection</code> → <code>RandomAccessCollection</code></p>
<p>每一层只加必要约束，绝不多要一颗糖。</p>
<ol start="2">
<li>值语义是 Swift 迭代的灵魂</li>
</ol>
<p>结构体迭代器复制即“新游标”，避免共享状态，这点与 Objective-C 的 NSEnumerator 形成鲜明对比。</p>
<ol start="3">
<li>遍历同时修改的崩溃本质是“迭代器失效”</li>
</ol>
<p>所有带指针/索引的集合都存在，掌握“先记录后改”或“一次性 API”即可。</p>
<ol start="4">
<li>AsyncSequence 让“事件流”变成普通 for-in</li>
</ol>
<p>网络下载、蓝牙数据、用户点击序列都能用同一套思维建模；配合 <code>AsyncStream</code> 几乎零成本桥接老代码。</p>
<ol start="5">
<li>自定义 Collection 是架构试金石</li>
</ol>
<p>RingBuffer 这类小容器写一遍，你会深刻理解“下标换算”、“容量与 count 区别”、“前置条件断言”这些日常被标准库隐藏的细节。</p>
<h2 data-id="heading-8">学习资料</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.donnywals.com%2Fa-deep-dive-into-collections-sequences-and-iterators-in-swift%2F" target="_blank" title="https://www.donnywals.com/a-deep-dive-into-collections-sequences-and-iterators-in-swift/" ref="nofollow noopener noreferrer">www.donnywals.com/a-deep-dive…</a></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Nacos 源码深度畅游：注册中心核心流程详解]]></title>    <link>https://juejin.cn/post/7572537221540560911</link>    <guid>https://juejin.cn/post/7572537221540560911</guid>    <pubDate>2025-11-16T01:15:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572537221540560911" data-draft-id="7572502156486606874" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Nacos 源码深度畅游：注册中心核心流程详解"/> <meta itemprop="keywords" content="后端,GitHub,分布式"/> <meta itemprop="datePublished" content="2025-11-16T01:15:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="方圆想当图灵"/> <meta itemprop="url" content="https://juejin.cn/user/386633160473101"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Nacos 源码深度畅游：注册中心核心流程详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/386633160473101/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    方圆想当图灵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T01:15:36.000Z" title="Sun Nov 16 2025 01:15:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是 <strong>方圆</strong>。本篇文章我们来了解一下 Nacos 另一大功能：<strong>注册中心</strong>。本文会先介绍一下 Nacos 注册中心的数据存储模型，让大家对 Nacos 注册中心有一个大致的理解，随后根据流程图简要介绍 Nacos 注册中心的核心流程，避免直接阅读源码时太过晦涩，并让大家对 Nacos 注册中心有一个基本的了解，随后阅读这一部分源码能让大家对分布式服务或注册中心有一个更好的认识，更好的理解 CP 或 AP 定理；注册中心内对数据一致性的保证；以及复杂流程中如何将各个操作解耦并不使操作丢失等等，以辅助大家日后的系统设计。</p>
<hr/>
<p>Nacos 的注册中心服务将服务的注册信息的 <strong>存储模型</strong> 分为三级，如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1efe507f1b814d8fb8154e6a881fe0f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=pZjupmcm1sQSwZGm3dnaLF9BGPA%3D" alt="img_2.png" loading="lazy"/></p>
<ol>
<li>一级是 <strong>服务</strong>：例如系统的微服务划分，提供用户服务的 <code>user-service</code>，服务的类定义在 Nacos 中是 <code>com.alibaba.nacos.naming.core.v2.pojo.Service</code></li>
<li>二级是 <strong>集群</strong>：比如可以按区域机房划分集群，北京集群、上海集群、广州集群等等，集群在 Nacos 中没有专门的类定义，使用 <code>clusterName</code> 识别</li>
<li>三级是 <strong>实例</strong>：例如北京机房的某台服务器部署的某个实例，实例的类定义在 Nacos 中是 <code>com.alibaba.nacos.api.naming.pojo.Instance</code></li>
</ol>
<p>如果我们向 <code>test-server</code> 服务下，集群为 <code>clusterA</code> 下注册两个实例时（默认 public 的命名空间），在控制台查询实例信息时如下所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74bad56d73de417ba3787f5c94b46b4a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=xVvXXpTJR5rwElMiC0cUdGZYACw%3D" alt="img_3.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ad7092ab3594418815cd1f4898b4ee1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=1YIPxPzIozbwoSMEOE7gG9O5Mz8%3D" alt="img_4.png" loading="lazy"/></p>
<p>在服务详情中会展示这个集群下所有的实例信息。在深入分析源码之前，我们还是根据流程图简述一下 Nacos 作为注册中心时，注册实例信息的核心流程：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/82d5e2b6f92d4684befb47e65262331d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=EY6A5O2YJRhCBnHrAEK%2FIOP%2BarM%3D" alt="nacos-naming.drawio.png" loading="lazy"/></p>
<p>首先，Nacos Client 会对 Nacos Server 集群中某一个节点发送 gRPC 请求进行实例注册；服务端处理客户端请求时，会先将 <strong>Service 信息</strong> 和 <strong>实例信息</strong> 写入本地缓存，并触发 <code>ClientRegisterServiceEvent</code> 和 <code>ClientChangedEvent</code> 两个事件。</p>
<p><code>ClientRegisterServiceEvent</code> 事件的作用是创建推送给订阅了服务的客户端的任务，在 <code>ScheduledExecutorService</code> 中定时异步执行，并且有失败重试机制，保证客户端及时接收到注册实例发生变更的数据。</p>
<p><code>ClientChangedEvent</code> 事件的作用是创建延迟执行 Distro 协议数据同步的任务，同样也是依赖 <code>ScheduledExecutorService</code> 延迟执行。<strong>Distro 协议是 Nacos 中专门用于处理临时实例数据一致性的分布式协议</strong>，它保证集群内数据一致性的方法非常简单，由接收到实例注册信息的节点将数据异步发送给集群内其他节点，其他节点会向该节点一样执行一次实例注册的流程。能通过这么简单的方式来完成数据同步，因为以下原因：</p>
<ol>
<li><strong>服务注册数据模型的属性简化了分布式一致性问题，避免了复杂的冲突解决机制</strong>：<strong>服务实例通过多个维度确定唯一性</strong>：命名空间 + 服务名 + 集群名 + IP地址 + 端口号，这种唯一性设计确保了同一个服务实例的注册信息在任何节点都是相同的，所以同一实例的注册信息在不同节点、不同时间先后写入都不会存在数据冲突问题，<strong>写入操作是幂等的</strong>，大大降低了保证数据一致性的复杂度</li>
<li>服务实例的注册信息是 <strong>临时数据</strong>：数据具有生命周期，会自动过期或被清理，不需要持久化存储，丢失后可以重新生成，降低了维护实例数据的难度</li>
<li>业务场景能够接受数据的 <strong>最终一致性</strong>：可用性（Availability）比一致性（Consistency）更重要，短时间内部分实例注册信息不一致不影响业务</li>
<li>多个 Nacos Client 客户端会连接到不同的 Nacos Server 服务端，相当于进行了 <strong>分片</strong>：每个服务节点负责特定的客户端实例，客户端注册的操作基本只在一个服务节点发生，大大降低了发生写入冲突的可能</li>
</ol>
<p>所以 Distro 协议才能如此简单和高效，保证 Nacos 集群内注册实例信息的 <strong>最终一致性</strong>。以上便是在 Nacos 注册中心注册实例的大致流程，做了一些省略，但是主要的原理没有改变：同步写入本地缓存记录服务和实例信息，异步处理事件执行客户端的订阅推送和 Distro 协议的数据同步，保证集群内实例信息的数据一致性，如果大家想深入到源码的细节中，欢迎阅读以下内容。</p>
<h3 data-id="heading-0">源码分析</h3>
<p>以如下源码来作为注册服务实例的入口来验证向 Nacos 注册中心注册服务实例的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNaming</span> {
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNacosNamingService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, NacosException {
        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
        properties.put(PropertyKeyConst.SERVER_ADDR, <span class="hljs-string">"127.0.0.1:8848"</span>);
        properties.put(PropertyKeyConst.NAMESPACE, <span class="hljs-string">"public"</span>);
        <span class="hljs-type">NamingService</span> <span class="hljs-variable">namingService</span> <span class="hljs-operator">=</span> NacosFactory.createNamingService(properties);

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 注册一个服务实例</span>
            namingService.registerInstance(<span class="hljs-string">"test-service"</span>, <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">"clusterA"</span>);

            <span class="hljs-comment">// 添加事件监听器</span>
            namingService.subscribe(<span class="hljs-string">"test-service"</span>, event -&gt; System.out.println(<span class="hljs-string">"服务实例变化: "</span> + event));
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"服务注册失败(预期，因为服务器可能未启动): "</span> + e.getMessage());
        }

        TimeUnit.HOURS.sleep(<span class="hljs-number">5</span>);

        namingService.shutDown();
    }
}
</code></pre>
<p>最先它会执行 <code>NamingService#registerInstance</code> 方法，<code>Instance</code> 对象便是存储模型的实例信息：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosNamingService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NamingService</span> {

    <span class="hljs-keyword">private</span> NamingClientProxy clientProxy;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(String serviceName, String groupName, String ip, <span class="hljs-type">int</span> port, String clusterName)</span>
            <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-type">Instance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Instance</span>();
        instance.setIp(ip);
        instance.setPort(port);
        <span class="hljs-comment">// 默认权重值为 1</span>
        instance.setWeight(<span class="hljs-number">1.0</span>);
        instance.setClusterName(clusterName);
        registerInstance(serviceName, groupName, instance);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 参数校验</span>
        NamingUtils.checkInstanceIsLegal(instance);
        checkAndStripGroupNamePrefix(instance, groupName);
        <span class="hljs-comment">// 在这里实际上使用了静态代理模式来区分是使用 HTTPClient 还是 GrpcClient，默认为后者</span>
        clientProxy.registerService(serviceName, groupName, instance);
    }
}
</code></pre>
<p>实际执行注册的为 <code>NamingGrpcClientProxy</code> 实现类，在向注册中心注册服务的逻辑中，我们 <strong>只关注创建临时（Ephemeral）服务实例</strong> 的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingGrpcClientProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNamingClientProxy</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NamingGrpcRedoService redoService;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerService</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span> <span class="hljs-keyword">throws</span> NacosException {
        NAMING_LOGGER.info(<span class="hljs-string">"[REGISTER-SERVICE] {} registering service {} with instance {}"</span>, namespaceId, serviceName,
                instance);
        <span class="hljs-comment">// [registerInstance] 步骤1：创建服务实例区分是否为临时</span>
        <span class="hljs-keyword">if</span> (instance.isEphemeral()) { 
            registerServiceForEphemeral(serviceName, groupName, instance);
        } <span class="hljs-keyword">else</span> {
            doRegisterServiceForPersistent(serviceName, groupName, instance);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerServiceForEphemeral</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span>
            <span class="hljs-keyword">throws</span> NacosException {
        redoService.cacheInstanceForRedo(serviceName, groupName, instance);
        doRegisterService(serviceName, groupName, instance);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterService</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 客户端创建注册实例请求对象，包含命名空间、服务名、分组名和实例信息</span>
        <span class="hljs-type">InstanceRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceRequest</span>(namespaceId, serviceName, groupName,
                NamingRemoteConstants.REGISTER_INSTANCE, instance);
        <span class="hljs-comment">// [registerInstance] 步骤2：通过gRPC协议向服务端发送注册请求</span>
        requestToServer(request, Response.class);
        redoService.instanceRegistered(serviceName, groupName);
    }
}
</code></pre>
<p>在上述步骤中，可以发现分别两次调用了 <code>redoServer</code> 的 <code>cacheInstanceForRedo</code> 和 <code>instanceRegistered</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingGrpcRedoService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConnectionEventListener</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, InstanceRedoData&gt; registeredInstances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    
    <span class="hljs-comment">// 创建 InstanceRedoData 对象在 ConcurrentMap 中</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cacheInstanceForRedo</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span> {
        <span class="hljs-comment">// eg: DEFAULT_GROUP@@test-service</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);
        <span class="hljs-type">InstanceRedoData</span> <span class="hljs-variable">redoData</span> <span class="hljs-operator">=</span> InstanceRedoData.build(serviceName, groupName, instance);
        <span class="hljs-keyword">synchronized</span> (registeredInstances) {
            registeredInstances.put(key, redoData);
        }
    }
}
</code></pre>
<p>首先它会创建 <code>InstanceRedoData</code> 对象保存在 <code>ConcurrentMap</code> 中，初始字段值如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e384e223d7864c9e8ffe2f6384976b38~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=GjJ0dffh%2BVrt%2BPLe5jHzzQZ1NtA%3D" alt="img.png" loading="lazy"/></p>
<p>在成功调用向服务端注册实例后，会将 <code>InstanceRedoData#registered</code> 字段标记为 true：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingGrpcRedoService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConnectionEventListener</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, InstanceRedoData&gt; registeredInstances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceRegistered</span><span class="hljs-params">(String serviceName, String groupName)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);
        <span class="hljs-keyword">synchronized</span> (registeredInstances) {
            <span class="hljs-type">InstanceRedoData</span> <span class="hljs-variable">redoData</span> <span class="hljs-operator">=</span> registeredInstances.get(key);
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != redoData) {
                <span class="hljs-comment">// 标记 registered 字段为 true</span>
                redoData.registered();
            }
        }
    }
}
</code></pre>
<p>至于 <code>InstanceRedoData</code> 对象有什么作用我们之后再看，我们还是先回到 gRPC 请求服务端注册实例的逻辑中。Nacos Client 会向服务端发送 <code>InstanceRequest</code> 请求，并有 Nacos Server 端的 <code>InstanceRequestHandler</code> 承接：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceRequestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestHandler</span>&lt;InstanceRequest, InstanceResponse&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EphemeralClientOperationServiceImpl clientOperationService;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InstanceRequestHandler</span><span class="hljs-params">(EphemeralClientOperationServiceImpl clientOperationService)</span> {
        <span class="hljs-built_in">this</span>.clientOperationService = clientOperationService;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@NamespaceValidation</span>
    <span class="hljs-meta">@TpsControl(pointName = "RemoteNamingInstanceRegisterDeregister", name = "RemoteNamingInstanceRegisterDeregister")</span>
    <span class="hljs-meta">@Secured(action = ActionTypes.WRITE)</span>
    <span class="hljs-meta">@ExtractorManager</span>.Extractor(rpcExtractor = InstanceRequestParamExtractor.class)
    <span class="hljs-keyword">public</span> InstanceResponse <span class="hljs-title function_">handle</span><span class="hljs-params">(InstanceRequest request, RequestMeta meta)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// [registerInstance] 步骤3：根据请求参数创建服务对象，设置为ephemeral（临时）服务</span>
        <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Service.newService(request.getNamespace(), request.getGroupName(), request.getServiceName(),
                <span class="hljs-literal">true</span>);
        InstanceUtil.setInstanceIdIfEmpty(request.getInstance(), service.getGroupedServiceName());
        <span class="hljs-keyword">switch</span> (request.getType()) {
            <span class="hljs-keyword">case</span> NamingRemoteConstants.REGISTER_INSTANCE:
                <span class="hljs-comment">// 根据请求类型分发到具体的注册实例方法</span>
                <span class="hljs-keyword">return</span> registerInstance(service, request, meta);
            <span class="hljs-keyword">case</span> NamingRemoteConstants.DE_REGISTER_INSTANCE:
                <span class="hljs-keyword">return</span> deregisterInstance(service, request, meta);
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosException</span>(NacosException.INVALID_PARAM,
                        String.format(<span class="hljs-string">"Unsupported request type %s"</span>, request.getType()));
        }
    }

    <span class="hljs-keyword">private</span> InstanceResponse <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(Service service, InstanceRequest request, RequestMeta meta)</span>
            <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 调用客户端操作服务注册实例，传入服务、实例和连接ID</span>
        clientOperationService.registerInstance(service, request.getInstance(), meta.getConnectionId());
        <span class="hljs-comment">// 发布实例注册跟踪事件，记录注册操作的详细信息</span>
        NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegisterInstanceTraceEvent</span>(System.currentTimeMillis(),
                NamingRequestUtil.getSourceIpForGrpcRequest(meta), <span class="hljs-literal">true</span>, service.getNamespace(), service.getGroup(),
                service.getName(), request.getInstance().getIp(), request.getInstance().getPort()));
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceResponse</span>(NamingRemoteConstants.REGISTER_INSTANCE);
    }
}
</code></pre>
<p>它会创建 <code>Service</code> 对象，它是存储模型中的服务信息，如下所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37b23fbb9a9e4a7ea343c8d4e90d6487~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=bDn4A65AAZlt%2BrS0O7PvXd7rfx8%3D" alt="img_1.png" loading="lazy"/></p>
<p>接下来我们先深入到其中调用的 <code>EphemeralClientOperationServiceImpl#registerInstance</code> 方法中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EphemeralClientOperationServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClientOperationService</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(Service service, Instance instance, String clientId)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 验证实例的合法性（IP、端口等）</span>
        NamingUtils.checkInstanceIsLegal(instance);

        <span class="hljs-comment">// [registerInstance] 步骤4：从服务管理器获取单例服务对象</span>
        <span class="hljs-type">Service</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> ServiceManager.getInstance().getSingleton(service);
        <span class="hljs-keyword">if</span> (!singleton.isEphemeral()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosRuntimeException</span>(NacosException.INVALID_PARAM,
                    String.format(<span class="hljs-string">"Current service %s is persistent service, can't register ephemeral instance."</span>,
                            singleton.getGroupedServiceName()));
        }
        <span class="hljs-comment">// 获取客户端连接对象并验证其合法性</span>
        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> clientManager.getClient(clientId);
        checkClientIsLegal(client, clientId);
        <span class="hljs-comment">// 将实例信息转换为发布信息对象</span>
        <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">instanceInfo</span> <span class="hljs-operator">=</span> getPublishInfo(instance);
        <span class="hljs-comment">// [registerInstance] 步骤5：将实例信息 InstancePublishInfo 添加到客户端的服务实例列表中</span>
        client.addServiceInstance(singleton, instanceInfo);
        client.setLastUpdatedTime();
        client.recalculateRevision();
        <span class="hljs-comment">// 发布客户端注册服务事件</span>
        NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientOperationEvent</span>(singleton, clientId));
        <span class="hljs-comment">// 发布实例元数据事件，完成注册流程</span>
        NotifyCenter
                .publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MetadataEvent</span>.InstanceMetadataEvent(singleton, instanceInfo.getMetadataId(), <span class="hljs-literal">false</span>));
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceManager</span> {

    <span class="hljs-comment">// 单例模式：饿汉式</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ServiceManager</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceManager</span>();
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ServiceManager <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> INSTANCE;
    }


    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Service, Service&gt; singletonRepository;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;Service&gt;&gt; namespaceSingletonMaps;

    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ServiceManager</span><span class="hljs-params">()</span> {
        singletonRepository = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>);
        namespaceSingletonMaps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>);
    }
    
    <span class="hljs-keyword">public</span> Service <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(Service service)</span> {
        <span class="hljs-comment">// 首先在 singletonRepository 中查找或创建服务单例</span>
        <span class="hljs-type">Service</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> singletonRepository.computeIfAbsent(service, key -&gt; {
            NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MetadataEvent</span>.ServiceMetadataEvent(service, <span class="hljs-literal">false</span>));
            <span class="hljs-keyword">return</span> service;
        });
        <span class="hljs-comment">// [registerInstance] 关键数据写入：将服务添加到命名空间服务映射表中 namespaceSingletonMaps</span>
        namespaceSingletonMaps.computeIfAbsent(result.getNamespace(), namespace -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashSet</span>&lt;&gt;()).add(result);
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre>
<p>在 <strong>[registerInstance] 步骤4</strong> 中完成了 <strong>服务实例信息注册后本地缓存的写入</strong>，它会被记录到 <code>ServiceManager#singletonRepository</code> 和 <code>ServiceManager#namespaceSingletonMaps</code> 两个变量中，并且在在首次通过 <code>ConcurrentHashMap#computeIfAbsent</code> 方法添加时会触发 <code>ServiceMetadataEvent</code> 事件，这个事件用于更新服务信息的元数据，比较简单就不再解释了，这有一点 <strong>代码规范</strong> 需要注意：它将 <code>ServiceManager#getSingleton</code> 命名为获取服务实例的方法，但是却在这个 <code>get</code> 方法中执行了写入逻辑，具有迷惑性，应该修改命名为 <code>registerAndGetSingleton</code> 才对。再回到 <code>registerInstance</code> 方法中，<strong>[registerInstance] 步骤5</strong> 也是一段重要的逻辑，它会在 <code>ConcurrentHashMap&lt;Service, InstancePublishInfo&gt; publishers</code> 记录注册实例的发布信息 <code>InstancePublishInfo</code>，包含 <strong>实例的 IP，端口和集群等必要信息</strong>，后续会从发布信息中来获取这些字段值，并且会触发 <code>ClientChangedEvent</code> 事件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Client</span> {

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Service, InstancePublishInfo&gt; publishers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">1</span>);
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addServiceInstance</span><span class="hljs-params">(Service service, InstancePublishInfo instancePublishInfo)</span> {
        <span class="hljs-keyword">if</span> (instancePublishInfo <span class="hljs-keyword">instanceof</span> BatchInstancePublishInfo) {
            <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> publishers.put(service, instancePublishInfo);
            MetricsMonitor.incrementIpCountWithBatchRegister(old, (BatchInstancePublishInfo) instancePublishInfo);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 记录实例的发布信息，用于后续从发布信息中解析获取注册实例的 IP 信息等</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == publishers.put(service, instancePublishInfo)) {
                MetricsMonitor.incrementInstanceCount();
            }
        }
        <span class="hljs-comment">// 触发 ClientChangedEvent 事件</span>
        NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientEvent</span>.ClientChangedEvent(<span class="hljs-built_in">this</span>));
        Loggers.SRV_LOG.info(<span class="hljs-string">"Client change for service {}, {}"</span>, service, getClientId());
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>在 <code>registerInstance</code> 方法中还会发布两个事件：<code>ClientRegisterServiceEvent</code> 和 <code>InstanceMetadataEvent</code>，后者用于写入实例的元数据比较简单，就不再赘述了。在以上逻辑中，我们知道了服务信息 <code>Service</code> 被记录在了 <code>ServiceManager</code> 中，服务下实例的信息被保存在了 <code>AbstractClient#publishers</code> 字段中，接下来我们看 <code>ClientRegisterServiceEvent</code> 事件和 <code>ClientChangedEvent</code> 事件是如何被处理的。</p>
<h4 data-id="heading-1">ClientRegisterServiceEvent</h4>
<p><code>ClientRegisterServiceEvent</code> 事件由 <code>ClientServiceIndexesManager</code> 订阅并消费，在这里也会记录服务信息，如下方代码所示，它还会触发 <code>ServiceChangedEvent</code> 事件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientServiceIndexesManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SmartSubscriber</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Service, Set&lt;String&gt;&gt; publisherIndexes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleClientOperation</span><span class="hljs-params">(ClientOperationEvent event)</span> {
        <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> event.getService();
        <span class="hljs-type">String</span> <span class="hljs-variable">clientId</span> <span class="hljs-operator">=</span> event.getClientId();
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientOperationEvent.ClientRegisterServiceEvent) {
            <span class="hljs-comment">// [registerInstance] 步骤6：处理客户端注册服务事件，将服务和客户端ID添加到发布者索引 publisherIndexes 中</span>
            addPublisherIndexes(service, clientId);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientOperationEvent.ClientDeregisterServiceEvent) {
            removePublisherIndexes(service, clientId);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientOperationEvent.ClientSubscribeServiceEvent) {
            addSubscriberIndexes(service, clientId);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientOperationEvent.ClientUnsubscribeServiceEvent) {
            removeSubscriberIndexes(service, clientId);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPublisherIndexes</span><span class="hljs-params">(Service service, String clientId)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">serviceChangedType</span> <span class="hljs-operator">=</span> Constants.ServiceChangedType.INSTANCE_CHANGED;
        <span class="hljs-keyword">if</span> (!publisherIndexes.containsKey(service)) {
            <span class="hljs-comment">// 唯一需要更新索引的时间是 "首次" 创建服务的时</span>
            serviceChangedType = Constants.ServiceChangedType.ADD_SERVICE;
        }
        <span class="hljs-comment">// 发布服务变更事件，通知订阅者有新的服务实例注册</span>
        NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceEvent</span>.ServiceChangedEvent(service, serviceChangedType, <span class="hljs-literal">true</span>));
        publisherIndexes.computeIfAbsent(service, key -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashSet</span>&lt;&gt;()).add(clientId);
    }
}
</code></pre>
<p><code>ServiceChangedEvent</code> 事件被 <code>NamingSubscriberServiceV2Impl</code> 订阅并消费：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingSubscriberServiceV2Impl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SmartSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NamingSubscriberService</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTaskExecuteEngine delayTaskEngine;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Event event)</span> {
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ServiceEvent.ServiceChangedEvent) {
            <span class="hljs-comment">// [registerInstance] 步骤7：处理服务变更事件，创建推送任务将服务变更通知给所有订阅者</span>
            ServiceEvent.<span class="hljs-type">ServiceChangedEvent</span> <span class="hljs-variable">serviceChangedEvent</span> <span class="hljs-operator">=</span> (ServiceEvent.ServiceChangedEvent) event;
            <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> serviceChangedEvent.getService();
            delayTaskEngine.addTask(service, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushDelayTask</span>(service, PushConfig.getInstance().getPushTaskDelay()));
            MetricsMonitor.incrementServiceChangeCount(service);
        }
    }
}
</code></pre>
<p>它会创建一个 <code>PushDelayTask</code> 添加到 <code>NacosDelayTaskExecuteEngine#tasks</code> 中，这个 <code>NacosDelayTaskExecuteEngine</code> 我们在配置发布的章节介绍过，本质上它是一个 <code>ScheduledExecutorService</code> 在每 100ms 执行一个 <code>ConcurrentHashMap&lt;Object, AbstractDelayTask&gt; tasks</code> 的任务。接下来我们先来了解一下 <code>PushDelayTask</code> 任务，重点关注注释信息：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushDelayTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDelayTask</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Service service;

    <span class="hljs-comment">// 是否推送给所有订阅服务信息的 Client</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> pushToAll;

    <span class="hljs-keyword">private</span> Set&lt;String&gt; targetClients;

    <span class="hljs-comment">// 创建推送所有订阅者的任务，上文中便是调用的这个构造函数</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PushDelayTask</span><span class="hljs-params">(Service service, <span class="hljs-type">long</span> delay)</span> {
        <span class="hljs-built_in">this</span>.service = service;
        pushToAll = <span class="hljs-literal">true</span>;
        targetClients = <span class="hljs-literal">null</span>;
        setTaskInterval(delay);
        setLastProcessTime(System.currentTimeMillis());
    }

    <span class="hljs-comment">// 创建推送某一个订阅者的任务，专门用于处理某个 IP 推送失败的情况</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PushDelayTask</span><span class="hljs-params">(Service service, <span class="hljs-type">long</span> delay, String targetClient)</span> {
        <span class="hljs-built_in">this</span>.service = service;
        <span class="hljs-built_in">this</span>.pushToAll = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">this</span>.targetClients = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(<span class="hljs-number">1</span>);
        <span class="hljs-built_in">this</span>.targetClients.add(targetClient);
        setTaskInterval(delay);
        setLastProcessTime(System.currentTimeMillis());
    }

    <span class="hljs-comment">// 合并任务，避免多次重复调用</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(AbstractDelayTask task)</span> {
        <span class="hljs-keyword">if</span> (!(task <span class="hljs-keyword">instanceof</span> PushDelayTask)) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-type">PushDelayTask</span> <span class="hljs-variable">oldTask</span> <span class="hljs-operator">=</span> (PushDelayTask) task;
        <span class="hljs-keyword">if</span> (isPushToAll() || oldTask.isPushToAll()) {
            pushToAll = <span class="hljs-literal">true</span>;
            targetClients = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
            targetClients.addAll(oldTask.getTargetClients());
        }
        setLastProcessTime(Math.min(getLastProcessTime(), task.getLastProcessTime()));
        Loggers.PUSH.info(<span class="hljs-string">"[PUSH] Task merge for {}"</span>, service);
    }

    <span class="hljs-keyword">public</span> Service <span class="hljs-title function_">getService</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> service;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPushToAll</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> pushToAll;
    }

    <span class="hljs-comment">// 获取目标推送 Client</span>
    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getTargetClients</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> targetClients;
    }
}
</code></pre>
<p>我们能了解到 <code>PushDelayTask</code> 能够 <strong>区分是推送给所有客户端还是只推送单一客户端，这么做的目的是可以针对某些推送异常的客户端进行任务重试</strong>。随后 <code>PushDelayTask</code> 会被 <code>PushDelayTaskProcessor</code> 处理，会被封装到 <code>PushExecuteTask</code> 任务中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushDelayTaskProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NacosTaskProcessor</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTaskExecuteEngine executeEngine;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PushDelayTaskProcessor</span><span class="hljs-params">(PushDelayTaskExecuteEngine executeEngine)</span> {
        <span class="hljs-built_in">this</span>.executeEngine = executeEngine;
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(NacosTask task)</span> {
        <span class="hljs-type">PushDelayTask</span> <span class="hljs-variable">pushDelayTask</span> <span class="hljs-operator">=</span> (PushDelayTask) task;
        <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> pushDelayTask.getService();
        <span class="hljs-comment">// [registerInstance] 步骤8：分发推送任务到执行器，准备将服务变更推送给客户端</span>
        NamingExecuteTaskDispatcher.getInstance()
                .dispatchAndExecuteTask(service, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushExecuteTask</span>(service, executeEngine, pushDelayTask));
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p><code>NamingExecuteTaskDispatcher#dispatchAndExecuteTask</code> 方法会执行到如下逻辑中，分配给某一条线程去处理：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosExecuteTaskExecuteEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNacosTaskExecuteEngine</span>&lt;AbstractExecuteTask&gt; {

    <span class="hljs-comment">// 本质上是多条线程</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TaskExecuteWorker[] executeWorkers;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NacosExecuteTaskExecuteEngine</span><span class="hljs-params">(String name, Logger logger, <span class="hljs-type">int</span> dispatchWorkerCount)</span> {
        <span class="hljs-built_in">super</span>(logger);
        executeWorkers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskExecuteWorker</span>[dispatchWorkerCount];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; mod &lt; dispatchWorkerCount; ++mod) {
            executeWorkers[mod] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskExecuteWorker</span>(name, mod, dispatchWorkerCount, getEngineLog());
        }
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTask</span><span class="hljs-params">(Object tag, AbstractExecuteTask task)</span> {
        <span class="hljs-type">NacosTaskProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> getProcessor(tag);
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != processor) {
            processor.process(task);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 分配给某个线程处理</span>
        <span class="hljs-type">TaskExecuteWorker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> getWorker(tag);
        worker.process(task);
    }

    <span class="hljs-keyword">private</span> TaskExecuteWorker <span class="hljs-title function_">getWorker</span><span class="hljs-params">(Object tag)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> (tag.hashCode() &amp; Integer.MAX_VALUE) % workersCount();
        <span class="hljs-keyword">return</span> executeWorkers[idx];
    }
}
</code></pre>
<p>以上逻辑还未涉及 <code>PushExecuteTask</code> 推送服务变更的逻辑处理，大家只需要了解到，至此将推送任务转交到了某个单一的线程中去执行了，接下来我们看一下 <code>PushExecuteTask</code> 的具体逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushExecuteTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecuteTask</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTaskExecuteEngine delayTaskEngine;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTask delayTask;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// [registerInstance] 步骤9：生成推送数据，包含服务实例信息和元数据</span>
            <span class="hljs-type">PushDataWrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> generatePushData();
            <span class="hljs-type">ClientManager</span> <span class="hljs-variable">clientManager</span> <span class="hljs-operator">=</span> delayTaskEngine.getClientManager();
            <span class="hljs-comment">// 遍历目标客户端，向订阅了该服务的客户端推送数据</span>
            <span class="hljs-keyword">for</span> (String each : getTargetClientIds()) {
                <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> clientManager.getClient(each);
                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == client) {
                    <span class="hljs-comment">// means this client has disconnect</span>
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-type">Subscriber</span> <span class="hljs-variable">subscriber</span> <span class="hljs-operator">=</span> client.getSubscriber(service);
                <span class="hljs-comment">// skip if null</span>
                <span class="hljs-keyword">if</span> (subscriber == <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-comment">// 通过推送执行器向客户端推送服务变更通知</span>
                delayTaskEngine.getPushExecutor().doPushWithCallback(each, subscriber, wrapper,
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServicePushCallback</span>(each, subscriber, wrapper.getOriginalData(), delayTask.isPushToAll()));
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            Loggers.PUSH.error(<span class="hljs-string">"Push task for service"</span> + service.getGroupedServiceName() + <span class="hljs-string">" execute failed "</span>, e);
            <span class="hljs-comment">// 异常重试</span>
            delayTaskEngine.addTask(service, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushDelayTask</span>(service, <span class="hljs-number">1000L</span>));
        }
    }

    <span class="hljs-comment">// 初始推送时获取所有订阅服务信息的 Client；如果不是推送所有，说明是处理失败重试的场景，则只推送目标 Client 即可</span>
    <span class="hljs-keyword">private</span> Collection&lt;String&gt; <span class="hljs-title function_">getTargetClientIds</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> delayTask.isPushToAll() ? delayTaskEngine.getIndexesManager().getAllClientsSubscribeService(service)
                : delayTask.getTargetClients();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServicePushCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NamingPushCallback</span> {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">()</span> {
            <span class="hljs-comment">// monitor and log</span>
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFail</span><span class="hljs-params">(Throwable e)</span> {
            <span class="hljs-type">long</span> <span class="hljs-variable">pushCostTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - executeStartTime;
            <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> NoRequiredRetryException)) {
                Loggers.PUSH.error(<span class="hljs-string">"Reason detail: "</span>, e);
                <span class="hljs-comment">// 如果针对某个 IP 推送失败，则创建推送针对目标 IP 的任务重试推送</span>
                delayTaskEngine.addTask(service,
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushDelayTask</span>(service, PushConfig.getInstance().getPushTaskRetryDelay(), clientId));
            }
            <span class="hljs-type">PushResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> PushResult
                    .pushFailed(service, clientId, actualServiceInfo, subscriber, pushCostTime, e, isPushToAll);
            PushResultHookHolder.getInstance().pushFailed(result);
        }
    }

}
</code></pre>
<p>从以上逻辑中可知：服务注册信息将推送给每个订阅了这个服务的 Client，如果推送失败会重新添加 <code>PushDelayTask</code> 任务重试，以此来保证订阅服务实例信息的 Client 都接收到变更。需要注意的是在 <strong>[registerInstance] 步骤9</strong> 中有以下非常关键的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushExecuteTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecuteTask</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTaskExecuteEngine delayTaskEngine;
    
    <span class="hljs-comment">// 生成推送请求信息</span>
    <span class="hljs-keyword">private</span> PushDataWrapper <span class="hljs-title function_">generatePushData</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 获取要推送的服务信息，包含实例信息</span>
        <span class="hljs-type">ServiceInfo</span> <span class="hljs-variable">serviceInfo</span> <span class="hljs-operator">=</span> delayTaskEngine.getServiceStorage().getPushData(service);
        <span class="hljs-type">ServiceMetadata</span> <span class="hljs-variable">serviceMetadata</span> <span class="hljs-operator">=</span> delayTaskEngine.getMetadataManager().getServiceMetadata(service).orElse(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushDataWrapper</span>(serviceMetadata, serviceInfo);
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceStorage</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Service, Set&lt;String&gt;&gt; serviceClusterIndex;
    
    <span class="hljs-keyword">public</span> ServiceInfo <span class="hljs-title function_">getPushData</span><span class="hljs-params">(Service service)</span> {
        <span class="hljs-type">ServiceInfo</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> emptyServiceInfo(service);
        <span class="hljs-keyword">if</span> (!ServiceManager.getInstance().containSingleton(service)) {
            <span class="hljs-keyword">return</span> result;
        }
        <span class="hljs-type">Service</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> ServiceManager.getInstance().getSingleton(service);
        result.setHosts(getAllInstancesFromIndex(singleton));
        serviceDataIndexes.put(singleton, result);
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">private</span> ServiceInfo <span class="hljs-title function_">emptyServiceInfo</span><span class="hljs-params">(Service service)</span> {
        <span class="hljs-type">ServiceInfo</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceInfo</span>();
        result.setName(service.getName());
        result.setGroupName(service.getGroup());
        result.setLastRefTime(System.currentTimeMillis());
        result.setCacheMillis(switchDomain.getDefaultPushCacheMillis());
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// 获取服务下所有的实例信息</span>
    <span class="hljs-keyword">private</span> List&lt;Instance&gt; <span class="hljs-title function_">getAllInstancesFromIndex</span><span class="hljs-params">(Service service)</span> {
        Set&lt;Instance&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        Set&lt;String&gt; clusters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        <span class="hljs-comment">// 获取 ClientId</span>
        <span class="hljs-keyword">for</span> (String each : serviceIndexesManager.getAllClientsRegisteredService(service)) {
            <span class="hljs-comment">// 获取实例注册信息 InstancePublishInfo</span>
            Optional&lt;InstancePublishInfo&gt; instancePublishInfo = getInstanceInfo(each, service);
            <span class="hljs-keyword">if</span> (instancePublishInfo.isPresent()) {
                <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">publishInfo</span> <span class="hljs-operator">=</span> instancePublishInfo.get();
                <span class="hljs-comment">//If it is a BatchInstancePublishInfo type, it will be processed manually and added to the instance list</span>
                <span class="hljs-keyword">if</span> (publishInfo <span class="hljs-keyword">instanceof</span> BatchInstancePublishInfo) {
                    <span class="hljs-type">BatchInstancePublishInfo</span> <span class="hljs-variable">batchInstancePublishInfo</span> <span class="hljs-operator">=</span> (BatchInstancePublishInfo) publishInfo;
                    List&lt;Instance&gt; batchInstance = parseBatchInstance(service, batchInstancePublishInfo, clusters);
                    result.addAll(batchInstance);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 根据请求时 InstancePublishInfo 的注册实例对象创建出 Instance 实例</span>
                    <span class="hljs-type">Instance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> parseInstance(service, instancePublishInfo.get());
                    result.add(instance);
                    clusters.add(instance.getClusterName());
                }
            }
        }
        <span class="hljs-comment">// 缓存记录这个服务的集群</span>
        serviceClusterIndex.put(service, clusters);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(result);
    }
}
</code></pre>
<p>在 <code>generatePushData</code> 方法中，生成了 <code>ServiceInfo</code> 对象，其中包含服务和该服务下注册的所有实例，实例信息是从 <code>InstancePublishInfo</code> 中解析出来的，实例的发布信息我们在上文中提到过。除此之外，还需要注意在 <code>getAllInstancesFromIndex</code> <strong>读方法中包含了缓存写入的逻辑</strong>，这种写法是非常不推荐的，具有迷惑性：谁会想到在读方法中还会包含写逻辑呢？所以在日常开发中一定要避免这种写法！</p>
<p>总结一下：<code>ClientRegisterServiceEvent</code> 事件的作用是将服务实例的变更信息推送给订阅了这个服务的所有客户端。</p>
<h4 data-id="heading-2">ClientChangedEvent</h4>
<p><code>ClientChangedEvent</code> 事件会被 <code>DistroClientDataProcessor</code> 订阅并消费，在它的 <code>onEvent</code> 方法中的 <code>else</code> 逻辑中可以发现它调用了 <code>syncToAllServer</code> 方法，从方法名中可以大概能猜出来，在 Nacos 采用集群模式部署时，会通过这个方法将注册的服务信息同步到其他节点上：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroClientDataProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SmartSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DistroDataStorage</span>, DistroDataProcessor {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroProtocol distroProtocol;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Event event)</span> {
        <span class="hljs-keyword">if</span> (EnvUtil.getStandaloneMode()) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientEvent.ClientVerifyFailedEvent) {
            syncToVerifyFailedServer((ClientEvent.ClientVerifyFailedEvent) event);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// [registerInstance] 步骤10：同步所有服务</span>
            syncToAllServer((ClientEvent) event);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syncToAllServer</span><span class="hljs-params">(ClientEvent event)</span> {
        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> event.getClient();
        <span class="hljs-keyword">if</span> (isInvalidClient(client)) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 区分客户端断开连接的事件客户端变更事件</span>
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientEvent.ClientDisconnectEvent) {
            <span class="hljs-type">DistroKey</span> <span class="hljs-variable">distroKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroKey</span>(client.getClientId(), TYPE);
            distroProtocol.sync(distroKey, DataOperation.DELETE);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientEvent.ClientChangedEvent) {
            <span class="hljs-type">DistroKey</span> <span class="hljs-variable">distroKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroKey</span>(client.getClientId(), TYPE);
            distroProtocol.sync(distroKey, DataOperation.CHANGE);
        }
    }
}
</code></pre>
<p>在这个方法中，可以发现调用了 <code>DistroProtocol#sync</code> 方法，<code>DistroProtocol</code> 表示 <strong>Distro 协议</strong>：<strong>专门用于处理临时实例数据一致性的分布式协议</strong>，接下来我们通过 Nacos 的逻辑来了解一下这个协议。在 <code>DistroProtocol#sync</code> 方法中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroProtocol</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroTaskEngineHolder distroTaskEngineHolder;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sync</span><span class="hljs-params">(DistroKey distroKey, DataOperation action)</span> {
        sync(distroKey, action, DistroConfig.getInstance().getSyncDelayMillis());
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sync</span><span class="hljs-params">(DistroKey distroKey, DataOperation action, <span class="hljs-type">long</span> delay)</span> {
        <span class="hljs-keyword">for</span> (Member each : memberManager.allMembersWithoutSelf()) {
            syncToTarget(distroKey, action, each.getAddress(), delay);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syncToTarget</span><span class="hljs-params">(DistroKey distroKey, DataOperation action, String targetServer, <span class="hljs-type">long</span> delay)</span> {
        <span class="hljs-type">DistroKey</span> <span class="hljs-variable">distroKeyWithTarget</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroKey</span>(distroKey.getResourceKey(), distroKey.getResourceType(),
                targetServer);
        <span class="hljs-comment">// 创建异步 DistroDelayTask 任务</span>
        <span class="hljs-type">DistroDelayTask</span> <span class="hljs-variable">distroDelayTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroDelayTask</span>(distroKeyWithTarget, action, delay);
        <span class="hljs-comment">// 添加到任务列表中延迟执行</span>
        distroTaskEngineHolder.getDelayTaskExecuteEngine().addTask(distroKeyWithTarget, distroDelayTask);
        <span class="hljs-keyword">if</span> (Loggers.DISTRO.isDebugEnabled()) {
            Loggers.DISTRO.debug(<span class="hljs-string">"[DISTRO-SCHEDULE] {} to {}"</span>, distroKey, targetServer);
        }
    }
}
</code></pre>
<p>它会创建一个 <code>DistroDelayTask</code> 添加到 <code>NacosDelayTaskExecuteEngine#tasks</code> 中，这个 <code>NacosDelayTaskExecuteEngine</code> 我们在配置发布的章节介绍过，本质上它是一个 <code>ScheduledExecutorService</code> 在每 100ms 执行一个 <code>ConcurrentHashMap&lt;Object, AbstractDelayTask&gt; tasks</code> 的任务。<code>DistroDelayTask</code> 任务中没有什么重要的逻辑，直接来看处理这个任务的实现类 <code>DistroDelayTaskProcessor</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroDelayTaskProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NacosTaskProcessor</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroTaskEngineHolder distroTaskEngineHolder;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroComponentHolder distroComponentHolder;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistroDelayTaskProcessor</span><span class="hljs-params">(DistroTaskEngineHolder distroTaskEngineHolder,
                                    DistroComponentHolder distroComponentHolder)</span> {
        <span class="hljs-built_in">this</span>.distroTaskEngineHolder = distroTaskEngineHolder;
        <span class="hljs-built_in">this</span>.distroComponentHolder = distroComponentHolder;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(NacosTask task)</span> {
        <span class="hljs-keyword">if</span> (!(task <span class="hljs-keyword">instanceof</span> DistroDelayTask)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-type">DistroDelayTask</span> <span class="hljs-variable">distroDelayTask</span> <span class="hljs-operator">=</span> (DistroDelayTask) task;
        <span class="hljs-type">DistroKey</span> <span class="hljs-variable">distroKey</span> <span class="hljs-operator">=</span> distroDelayTask.getDistroKey();
        <span class="hljs-keyword">switch</span> (distroDelayTask.getAction()) {
            <span class="hljs-keyword">case</span> DELETE:
                <span class="hljs-type">DistroSyncDeleteTask</span> <span class="hljs-variable">syncDeleteTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroSyncDeleteTask</span>(distroKey, distroComponentHolder);
                distroTaskEngineHolder.getExecuteWorkersManager().addTask(distroKey, syncDeleteTask);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">case</span> CHANGE:
            <span class="hljs-keyword">case</span> ADD:
                <span class="hljs-comment">// [registerInstance] 步骤11：创建 DistroSyncChangeTask 任务异步执行</span>
                <span class="hljs-type">DistroSyncChangeTask</span> <span class="hljs-variable">syncChangeTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroSyncChangeTask</span>(distroKey, distroComponentHolder);
                distroTaskEngineHolder.getExecuteWorkersManager().addTask(distroKey, syncChangeTask);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<p><strong>[registerInstance] 步骤11</strong> 会创建 <code>DistroSyncChangeTask</code> 任务同样添加到延迟执行的任务队列中等待处理，这个任务的逻辑我们先来看一下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroSyncChangeTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDistroExecuteTask</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DataOperation</span> <span class="hljs-variable">OPERATION</span> <span class="hljs-operator">=</span> DataOperation.CHANGE;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistroSyncChangeTask</span><span class="hljs-params">(DistroKey distroKey, DistroComponentHolder distroComponentHolder)</span> {
        <span class="hljs-built_in">super</span>(distroKey, distroComponentHolder);
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> DataOperation <span class="hljs-title function_">getDataOperation</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> OPERATION;
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doExecute</span><span class="hljs-params">()</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> getDistroKey().getResourceType();
        <span class="hljs-type">DistroData</span> <span class="hljs-variable">distroData</span> <span class="hljs-operator">=</span> getDistroData(type);
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == distroData) {
            Loggers.DISTRO.warn(<span class="hljs-string">"[DISTRO] {} with null data to sync, skip"</span>, toString());
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-comment">// gRPC 通知其他节点服务实例信息</span>
        <span class="hljs-keyword">return</span> getDistroComponentHolder().findTransportAgent(type).syncData(distroData, getDistroKey().getTargetServer());
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doExecuteWithCallback</span><span class="hljs-params">(DistroCallback callback)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> getDistroKey().getResourceType();
        <span class="hljs-type">DistroData</span> <span class="hljs-variable">distroData</span> <span class="hljs-operator">=</span> getDistroData(type);
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == distroData) {
            Loggers.DISTRO.warn(<span class="hljs-string">"[DISTRO] {} with null data to sync, skip"</span>, toString());
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// gRPC 通知其他节点服务实例信息</span>
        getDistroComponentHolder().findTransportAgent(type).syncData(distroData, getDistroKey().getTargetServer(), callback);
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"DistroSyncChangeTask for "</span> + getDistroKey().toString();
    }
    
    <span class="hljs-comment">// 获取 Distro 要推送的数据</span>
    <span class="hljs-keyword">private</span> DistroData <span class="hljs-title function_">getDistroData</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-type">DistroData</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> getDistroComponentHolder().findDataStorage(type).getDistroData(getDistroKey());
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != result) {
            result.setType(OPERATION);
        }
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre>
<p>它的源码很简短，主要关注 <code>doExecute</code> 和 <code>doExecuteWithCallback</code> 方法，这两个方法的逻辑是借助 gRPC 通知集群中其他节点，区别是是否在 gRPC 调用完成后执行回调函数，这个任务的执行是在 <code>NacosExecuteTaskExecuteEngine</code> 中异步执行的，因为在上文中讲解过就不再赘述了，失败重试采用的还是重新添加到任务队列中等待执行。除此之外我们也要弄清楚推送的 DistroData 中到底都包含哪些信息，如下代码所示，它会执行到 <code>AbstractClient#generateSyncData</code> 的逻辑中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Client</span> {
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ClientSyncData <span class="hljs-title function_">generateSyncData</span><span class="hljs-params">()</span> {
        List&lt;String&gt; namespaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;String&gt; groupNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;String&gt; serviceNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();

        List&lt;String&gt; batchNamespaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;String&gt; batchGroupNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;String&gt; batchServiceNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();

        List&lt;InstancePublishInfo&gt; instances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;BatchInstancePublishInfo&gt; batchInstancePublishInfos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-type">BatchInstanceData</span>  <span class="hljs-variable">batchInstanceData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchInstanceData</span>();
        <span class="hljs-keyword">for</span> (Map.Entry&lt;Service, InstancePublishInfo&gt; entry : publishers.entrySet()) {
            <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">instancePublishInfo</span> <span class="hljs-operator">=</span> entry.getValue();
            <span class="hljs-keyword">if</span> (instancePublishInfo <span class="hljs-keyword">instanceof</span> BatchInstancePublishInfo) {
                <span class="hljs-type">BatchInstancePublishInfo</span> <span class="hljs-variable">batchInstance</span> <span class="hljs-operator">=</span> (BatchInstancePublishInfo) instancePublishInfo;
                batchInstancePublishInfos.add(batchInstance);
                buildBatchInstanceData(batchInstanceData, batchNamespaces, batchGroupNames, batchServiceNames, entry);
                batchInstanceData.setBatchInstancePublishInfos(batchInstancePublishInfos);
            } <span class="hljs-keyword">else</span> {
                namespaces.add(entry.getKey().getNamespace());
                groupNames.add(entry.getKey().getGroup());
                serviceNames.add(entry.getKey().getName());
                instances.add(entry.getValue());
            }
        }
        <span class="hljs-comment">// 包含了命名空间、服务信息和实例信息（InstancePublishInfo 或 BatchInstanceData）等</span>
        <span class="hljs-type">ClientSyncData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientSyncData</span>(getClientId(), namespaces, groupNames, serviceNames, instances, batchInstanceData);
        data.getAttributes().addClientAttribute(REVISION, getRevision());
        <span class="hljs-keyword">return</span> data;
    }
}
</code></pre>
<p>虽然比较长，只看注释相关的内容即可，推送内容包含了命名空间、服务信息和实例信息等，这些信息大部分都来自 <code>InstancePublishInfo</code>，可见这个对象多么重要。</p>
<p><code>DistroSyncChangeTask</code> 任务会向其他节点发送 <code>DistroDataRequest</code> 请求，这个请求是如何被处理的呢？继续看 <code>DistroDataRequestHandler</code> 的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@InvokeSource(source = {RemoteConstants.LABEL_SOURCE_CLUSTER})</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroDataRequestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestHandler</span>&lt;DistroDataRequest, DistroDataResponse&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroProtocol distroProtocol;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistroDataRequestHandler</span><span class="hljs-params">(DistroProtocol distroProtocol)</span> {
        <span class="hljs-built_in">this</span>.distroProtocol = distroProtocol;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@Secured(apiType = ApiType.INNER_API)</span>
    <span class="hljs-keyword">public</span> DistroDataResponse <span class="hljs-title function_">handle</span><span class="hljs-params">(DistroDataRequest request, RequestMeta meta)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">switch</span> (request.getDataOperation()) {
                <span class="hljs-keyword">case</span> VERIFY:
                    <span class="hljs-keyword">return</span> handleVerify(request.getDistroData(), meta);
                <span class="hljs-keyword">case</span> SNAPSHOT:
                    <span class="hljs-keyword">return</span> handleSnapshot();
                <span class="hljs-keyword">case</span> ADD:
                <span class="hljs-keyword">case</span> CHANGE:
                <span class="hljs-keyword">case</span> DELETE:
                    <span class="hljs-comment">// [registerInstance] 步骤12 处理 DistroDataRequest 请求</span>
                    <span class="hljs-keyword">return</span> handleSyncData(request.getDistroData());
                <span class="hljs-keyword">case</span> QUERY:
                    <span class="hljs-keyword">return</span> handleQueryData(request.getDistroData());
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroDataResponse</span>();
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            Loggers.DISTRO.error(<span class="hljs-string">"[DISTRO-FAILED] distro handle with exception"</span>, e);
            <span class="hljs-type">DistroDataResponse</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroDataResponse</span>();
            result.setResultCode(ResponseCode.FAIL.getCode());
            result.setErrorCode(ResponseCode.FAIL.getCode());
            result.setMessage(<span class="hljs-string">"handle distro request with exception"</span>);
            <span class="hljs-keyword">return</span> result;
        }
    }

    <span class="hljs-keyword">private</span> DistroDataResponse <span class="hljs-title function_">handleSyncData</span><span class="hljs-params">(DistroData distroData)</span> {
        <span class="hljs-type">DistroDataResponse</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroDataResponse</span>();
        <span class="hljs-keyword">if</span> (!distroProtocol.onReceive(distroData)) {
            result.setErrorCode(ResponseCode.FAIL.getCode());
            result.setMessage(<span class="hljs-string">"[DISTRO-FAILED] distro data handle failed"</span>);
        }
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre>
<p>我们需要关注 <code>DistroProtocol#onReceive</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroProtocol</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroComponentHolder distroComponentHolder;
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(DistroData distroData)</span> {
        Loggers.DISTRO.info(<span class="hljs-string">"[DISTRO] Receive distro data type: {}, key: {}"</span>, distroData.getType(),
                distroData.getDistroKey());
        <span class="hljs-type">String</span> <span class="hljs-variable">resourceType</span> <span class="hljs-operator">=</span> distroData.getDistroKey().getResourceType();
        <span class="hljs-type">DistroDataProcessor</span> <span class="hljs-variable">dataProcessor</span> <span class="hljs-operator">=</span> distroComponentHolder.findDataProcessor(resourceType);
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == dataProcessor) {
            Loggers.DISTRO.warn(<span class="hljs-string">"[DISTRO] Can't find data process for received data {}"</span>, resourceType);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> dataProcessor.processData(distroData);
    }
}
</code></pre>
<p>它会执行到 <code>DistroClientDataProcessor#processData</code> 方法，其中的 <code>upgradeClient</code> 方法是关键：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroClientDataProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SmartSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DistroDataStorage</span>, DistroDataProcessor {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">processData</span><span class="hljs-params">(DistroData distroData)</span> {
        <span class="hljs-keyword">switch</span> (distroData.getType()) {
            <span class="hljs-keyword">case</span> ADD:
            <span class="hljs-keyword">case</span> CHANGE:
                <span class="hljs-comment">// [registerInstance] 步骤12：处理 Distro 协议同步的数据</span>
                <span class="hljs-type">ClientSyncData</span> <span class="hljs-variable">clientSyncData</span> <span class="hljs-operator">=</span> ApplicationUtils.getBean(Serializer.class)
                        .deserialize(distroData.getContent(), ClientSyncData.class);
                handlerClientSyncData(clientSyncData);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">case</span> DELETE:
                <span class="hljs-type">String</span> <span class="hljs-variable">deleteClientId</span> <span class="hljs-operator">=</span> distroData.getDistroKey().getResourceKey();
                Loggers.DISTRO.info(<span class="hljs-string">"[Client-Delete] Received distro client sync data {}"</span>, deleteClientId);
                clientManager.clientDisconnected(deleteClientId);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerClientSyncData</span><span class="hljs-params">(ClientSyncData clientSyncData)</span> {
        Loggers.DISTRO
                .info(<span class="hljs-string">"[Client-Add] Received distro client sync data {}, revision={}"</span>, clientSyncData.getClientId(),
                        clientSyncData.getAttributes().getClientAttribute(ClientConstants.REVISION, <span class="hljs-number">0L</span>));
        clientManager.syncClientConnected(clientSyncData.getClientId(), clientSyncData.getAttributes());
        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> clientManager.getClient(clientSyncData.getClientId());
        <span class="hljs-comment">// upgrade 是升级的含义，实际逻辑是完成 Distro 数据的写入</span>
        upgradeClient(client, clientSyncData);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">upgradeClient</span><span class="hljs-params">(Client client, ClientSyncData clientSyncData)</span> {
        Set&lt;Service&gt; syncedService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        <span class="hljs-comment">// process batch instance sync logic</span>
        processBatchInstanceDistroData(syncedService, client, clientSyncData);
        List&lt;String&gt; namespaces = clientSyncData.getNamespaces();
        List&lt;String&gt; groupNames = clientSyncData.getGroupNames();
        List&lt;String&gt; serviceNames = clientSyncData.getServiceNames();
        List&lt;InstancePublishInfo&gt; instances = clientSyncData.getInstancePublishInfos();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; namespaces.size(); i++) {
            <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Service.newService(namespaces.get(i), groupNames.get(i), serviceNames.get(i));
            <span class="hljs-comment">// 注册并获取服务信息</span>
            <span class="hljs-type">Service</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> ServiceManager.getInstance().getSingleton(service);
            syncedService.add(singleton);
            <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">instancePublishInfo</span> <span class="hljs-operator">=</span> instances.get(i);
            <span class="hljs-keyword">if</span> (!instancePublishInfo.equals(client.getInstancePublishInfo(singleton))) {
                <span class="hljs-comment">// 执行的是 [registerInstance] 步骤5 的逻辑：将实例信息 InstancePublishInfo 添加到客户端的服务实例列表中</span>
                client.addServiceInstance(singleton, instancePublishInfo);
                <span class="hljs-comment">// 触发 ClientRegisterServiceEvent 事件</span>
                NotifyCenter.publishEvent(
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientOperationEvent</span>.ClientRegisterServiceEvent(singleton, client.getClientId()));
                NotifyCenter.publishEvent(
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetadataEvent</span>.InstanceMetadataEvent(singleton, instancePublishInfo.getMetadataId(), <span class="hljs-literal">false</span>));
            }
        }
        <span class="hljs-keyword">for</span> (Service each : client.getAllPublishedService()) {
            <span class="hljs-keyword">if</span> (!syncedService.contains(each)) {
                client.removeServiceInstance(each);
                NotifyCenter.publishEvent(
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientOperationEvent</span>.ClientDeregisterServiceEvent(each, client.getClientId()));
            }
        }
        client.setRevision(clientSyncData.getAttributes().&lt;Integer&gt;getClientAttribute(ClientConstants.REVISION, <span class="hljs-number">0</span>));
    }
}
</code></pre>
<p><code>DistroClientDataProcessor#upgradeClient</code> 方法会执行时就和开篇介绍的 <code>EphemeralClientOperationServiceImpl#registerInstance</code> 方法基本一致的逻辑，注册 <code>Service</code> 信息，写入实例信息 <code>InstancePublishInfo</code>，并在随后发布 <code>ClientRegisterServiceEvent</code> 事件，这个事件我们在上一个小节专门介绍过，它的作用是将服务实例的变更信息推送给订阅了这个服务的所有客户端。</p>
<p>总而言之，通过 Distro 协议同步数据给集群中其他节点相当于在其他节点重新执行了一次实例注册的逻辑。不过，大家有没有考虑过这个问题：为什么 Distro 协议能够通过如此简单的方式在服务发现场景下保证数据的最终一致性呢？</p>
<p>最主要的原因是：<strong>服务注册数据模型的属性简化了分布式一致性问题，避免了复杂的冲突解决机制</strong>。该如何理解这个特点呢？</p>
<ul>
<li><strong>服务实例通过多个维度确定唯一性</strong>：命名空间 + 服务名 + 集群名 + IP地址 + 端口号，这种唯一性设计确保了同一个服务实例的注册信息在任何节点都是相同的，所以同一实例的注册信息在不同节点、不同时间先后写入都不会存在数据冲突问题，<strong>写入操作是幂等的</strong>，大大降低了保证数据一致性的复杂度。</li>
</ul>
<p>理解了这一点，我觉得便清楚了 Distro 协议的精髓。此外，还有以下原因使得 Distro 协议适用：</p>
<ol>
<li>服务实例的注册信息是 <strong>临时数据</strong>：数据具有生命周期，会自动过期或被清理，不需要持久化存储，丢失后可以重新生成，降低了维护实例数据的难度</li>
<li>业务场景能够接受数据的 <strong>最终一致性</strong>：可用性（Availability）比一致性（Consistency）更重要，短时间内部分实例注册信息不一致不影响业务</li>
<li>多个 Nacos Client 客户端会连接到不同的 Nacos Server 服务端，相当于进行了 <strong>分片</strong>：每个服务节点负责特定的客户端实例，客户端注册的操作基本只在一个服务节点发生，大大降低了发生写入冲突的可能</li>
</ol>
<p>接下来我们看一下在 Distro 协议中是如何清理过期数据的，核心逻辑在 <code>ExpiredClientCleaner</code> 中，它是一个定期执行的任务，任务逻辑如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpiredClientCleaner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EphemeralIpPortClientManager clientManager;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-comment">// 获取当前 Nacos Server 下连接的所有客户端</span>
        <span class="hljs-keyword">for</span> (String each : clientManager.allClientId()) {
            <span class="hljs-comment">// 遍历处理客户端信息</span>
            <span class="hljs-type">IpPortBasedClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> (IpPortBasedClient) clientManager.getClient(each);
            <span class="hljs-comment">// 如果客户端已经失效（在规定时间段内失去心跳）了</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != client &amp;&amp; isExpireClient(currentTime, client)) {
                <span class="hljs-comment">// 执行客户端断开的逻辑，会触发 ClientDisconnectEvent 事件，删除失效的链接并通知集群内其他节点</span>
                clientManager.clientDisconnected(each);
            }
        }
    }
}
</code></pre>
<p>这个定时任务会在 Nacos Server 启动时，在 <code>ScheduledExecutorService</code> 中定期 5s 执行一次：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EphemeralIpPortClientManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClientManager</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EphemeralIpPortClientManager</span><span class="hljs-params">(DistroMapper distroMapper, SwitchDomain switchDomain)</span> {
        <span class="hljs-comment">// 默认定期 5s 检查一次</span>
        GlobalExecutor.scheduleExpiredClientCleaner(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpiredClientCleaner</span>(<span class="hljs-built_in">this</span>, switchDomain), <span class="hljs-number">0</span>,
                Constants.DEFAULT_HEART_BEAT_INTERVAL, TimeUnit.MILLISECONDS);
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>以此来保证过期的实例数据能及时被移除。</p>
<hr/>
<h3 data-id="heading-3">巨人的肩膀</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fnacos" target="_blank" title="https://github.com/alibaba/nacos" ref="nofollow noopener noreferrer">Github - alibaba/nacos</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fwenxuehai%2Fp%2F16179629.html" target="_blank" title="https://www.cnblogs.com/wenxuehai/p/16179629.html" ref="nofollow noopener noreferrer">博客园 - Nacos的基本使用（注册中心、配置中心）</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude发布新功能Agent Skills，让你的Agent更专业]]></title>    <link>https://juejin.cn/post/7572714389942435892</link>    <guid>https://juejin.cn/post/7572714389942435892</guid>    <pubDate>2025-11-16T01:18:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572714389942435892" data-draft-id="7567208390369247272" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude发布新功能Agent Skills，让你的Agent更专业"/> <meta itemprop="keywords" content="Claude,AIGC"/> <meta itemprop="datePublished" content="2025-11-16T01:18:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小溪彼岸"/> <meta itemprop="url" content="https://juejin.cn/user/976781670357400"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude发布新功能Agent Skills，让你的Agent更专业
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/976781670357400/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小溪彼岸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T01:18:54.000Z" title="Sun Nov 16 2025 01:18:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>大家好，我是小溪，见字如面。2025年10月16日，Anthropic发布了Claude模型的一项重大更新Agent Skills，它允许用户将专业知识、脚本和资源打包成模块化的“技能文件夹”（Skill folders），让 AI 能在特定工作场景中更专业地执行任务。对Claude Code CLI往期内容感兴趣的小伙伴也可以看往期内容：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493170%26idx%3D1%26sn%3D13e9d5122d788175ab587ce33720f777%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493170&amp;idx=1&amp;sn=13e9d5122d788175ab587ce33720f777&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Hooks才是Claude Code CLI 的革命性更新</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493196%26idx%3D1%26sn%3Db4efa96c86f66fff3acd21c175ceb89f%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493196&amp;idx=1&amp;sn=b4efa96c86f66fff3acd21c175ceb89f&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Claude Code颠覆编程风格的Output Styles</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493228%26idx%3D1%26sn%3D7bb969019478e4e38974776bb04fedda%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493228&amp;idx=1&amp;sn=7bb969019478e4e38974776bb04fedda&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">分享一个Claude Code宝藏网站Claude Code Templates</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493269%26idx%3D1%26sn%3D4775c90a4fab04126502bf79b0f75d70%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493269&amp;idx=1&amp;sn=4775c90a4fab04126502bf79b0f75d70&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Claude Code上线插件系统，AI编程模式再次升级</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493288%26idx%3D1%26sn%3D0274d7f3a741cbfde4d09adf7a595efb%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493288&amp;idx=1&amp;sn=0274d7f3a741cbfde4d09adf7a595efb&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">如何从零开始创建一个Claude Code插件</a></li>
</ul>
<h2 data-id="heading-1">当前使用版本</h2>
<p>2.0.24 (Claude Code)</p>
<h2 data-id="heading-2">简介</h2>
<p>官方的描述是：“代理技能将专业知识打包到可发现的功能中。每个技能都由一个 SKILL.md 文件组成，其中包含Claude在需要时阅读的 说明、脚本 和 模板 等可选支持文件”。</p>
<p>用白话讲就是，Agent Skill是一个用于告诉模型如何执行某项操作的Markdown文件，同时允许附带额外的文档和预先编写的脚本，通过运行这些脚本，使模型在执行特定任务时更专业、更高效，是AI“可加载的能力包”</p>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.claude.com%2Fen%2Fdocs%2Fclaude-code%2Fskills" target="_blank" title="https://docs.claude.com/en/docs/claude-code/skills" ref="nofollow noopener noreferrer">docs.claude.com/en/docs/cla…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbaf20322f164eda82b6bdb74dddb3d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=cqXXFH5QK%2BT4hFH5I2Xs3zE2e98%3D" alt="图片" loading="lazy"/></p>
<p>Anthropic提供了一系列Skill示例，部分已经集成到了Claude Code桌面端，也可以在Claude Code CLI中使用，感兴趣的小伙伴可以自行了解。</p>
<p>Github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">github.com/anthropics/…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31ad3b7da1224a5b9b049e643cd29f30~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=aOUWIj6Gd4yGTG3L9YztKUoriI8%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-3">优势</h2>
<p>Agent Skills具备如下特性：</p>
<ul>
<li>为您的特定工作流程扩展 Claude 的功能</li>
<li>通过 git 在团队中共享专业知识</li>
<li>减少重复提示</li>
<li>为复杂任务编写多种技能</li>
</ul>
<h2 data-id="heading-4">如何调用？</h2>
<p>技能是模型调用的，Claude 根据您的请求和技能的描述自主决定何时使用它们。</p>
<h2 data-id="heading-5">Skills类型</h2>
<p>Agent Skills有 3种类型，Claude Code从以下来源自动发现Skills：</p>
<ul>
<li>个人(全局)技能：作用于所有项目，路径在 ~/.claude/skills/ 目录下</li>
<li>项目技能：作用于特定项目，路径在 .claude/skills/ 目录下</li>
<li>插件技能：与已安装的插件捆绑在一起</li>
</ul>
<h2 data-id="heading-6">Skills目录及操作</h2>
<h3 data-id="heading-7">Skill目录结构</h3>
<p>Agent Skills的文件结构大致如下：</p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-keyword">my</span>-skill/
├── SKILL.md <span class="hljs-comment"># 指令与说明文件 必需项</span>
├── reference.md <span class="hljs-comment"># 文档（可选）</span>
├── examples.md <span class="hljs-comment"># 示例（可选）</span>
├── scripts/ <span class="hljs-comment"># 脚本（可选）</span>
│   └── helper.py
└── templates/  <span class="hljs-comment"># 模版（可选）</span>
    └── template.txt
</code></pre>
<h3 data-id="heading-8">SKILL.md</h3>
<p>每个Skills都定义在具有以下结构的 Markdown 文件中：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">your-skill-name</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">Introduce</span> <span class="hljs-string">the</span> <span class="hljs-string">Skills</span> <span class="hljs-string">function。Description</span> <span class="hljs-string">of</span> <span class="hljs-string">when</span> <span class="hljs-string">this</span> <span class="hljs-string">Skill</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-string">invoked</span>
<span class="hljs-attr">allowed-tools:</span> <span class="hljs-string">which</span> <span class="hljs-string">tools</span> <span class="hljs-string">Claude</span> <span class="hljs-string">can</span> <span class="hljs-string">use</span> <span class="hljs-string">when</span> <span class="hljs-string">a</span> <span class="hljs-string">Skill</span> <span class="hljs-string">is</span> <span class="hljs-string">active</span>
<span class="hljs-string">license：skill</span> <span class="hljs-string">license</span>
<span class="hljs-meta">---</span>
<span class="hljs-string">Skill</span> <span class="hljs-string">Implementation</span> <span class="hljs-string">and</span> <span class="hljs-string">Requirements</span>
</code></pre>
<p>Skill技能Markdown Frontmatter属性：</p>
<ul>
<li>name：Skill名称</li>
<li>description：描述Skill功能及何时应该调用此Skill</li>
<li>allowed-tools：Skill处于活动状态时可以使用的工具</li>
<li>license：开源许可协议</li>
</ul>
<p>Skill中可以引用其他额外的文件作为上下文：</p>
<pre><code class="hljs language-scss" lang="scss">For advanced usage, see <span class="hljs-selector-attr">[reference.md]</span>(reference.md).
</code></pre>
<p>也可以使用文件路径形式</p>
<pre><code class="hljs language-bash" lang="bash">For advanced usage, see ./reference.md
</code></pre>
<p>需要执行脚本的操作，可以使用如下方式指定：</p>
<pre><code class="hljs language-go" lang="go">Run the helper script:
<span class="hljs-string">``</span><span class="hljs-string">`bash
python scripts/helper.py input.txt
`</span><span class="hljs-string">``</span>
</code></pre>
<p>对于 allowed-tools 的使用，可以在 frontmatter 中来限制 Claude 在技能处于活动状态时可以使用的工具：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">your-skill-name</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">Introduce</span> <span class="hljs-string">the</span> <span class="hljs-string">Skills</span> <span class="hljs-string">function。Description</span> <span class="hljs-string">of</span> <span class="hljs-string">when</span> <span class="hljs-string">this</span> <span class="hljs-string">Skill</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-string">invoked</span>
<span class="hljs-attr">allowed-tools:</span> <span class="hljs-string">Read,</span> <span class="hljs-string">Grep,</span> <span class="hljs-string">Glob</span>
<span class="hljs-meta">---
</span></code></pre>
<h2 data-id="heading-9">基本使用</h2>
<h3 data-id="heading-10">前提条件</h3>
<ul>
<li>Claude Code 版本 1.0 或更高版本</li>
</ul>
<h3 data-id="heading-11">官方Skill安装使用</h3>
<p>首先以Claude Code官方Skill 市场为例，在交互式命令中输入如下指令添加Skill市场：</p>
<pre><code class="hljs language-bash" lang="bash">/plugin marketplace add anthropics/skills
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76b51ed79fe44f21be947774fda099b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=tXfzksxxUkyi%2BuF5DLKp0CW0mE4%3D" alt="图片" loading="lazy"/></p>
<p>在插件市场选择【Browse and install plugins】浏览并安装</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3ac55bc3fb945ad8886307c0891c197~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=rdpFaS2I6CjMib0bE6YISU3tD9c%3D" alt="图片" loading="lazy"/></p>
<p>或者通过以下命令直接安装：</p>
<pre><code class="hljs language-typescript" lang="typescript">/plugin install <span class="hljs-variable language_">document</span>-skills\<span class="hljs-meta">@anthropic</span>-agent-skills
/plugin install example-skills\<span class="hljs-meta">@anthropic</span>-agent-skills
</code></pre>
<p>document-skills 和 example-skills 包含的Skills如下所示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/59b3b19575114609ba101408b7f4be8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=bJtdGd3lTOVZBjSQZGFG7zUwC%2Fk%3D" alt="图片" loading="lazy"/></p>
<p>安装完成后，根据提示重启Claude Code CLI</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c51b45603f3a4bdb902bb0e06d218bcf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=sQbiUb6BPwb4sLXU3MRvU8Zifa8%3D" alt="图片" loading="lazy"/></p>
<p>在交互式命令中直接输入提示词：</p>
<pre><code class="hljs language-bash" lang="bash">提取 /Users/username/Desktop/工作簿1.xlsx 文件内容 
</code></pre>
<p>Claude Code CLI会先进行权限请求，然后启动Excel处理技能</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b6a82c077ba439d8e1d8548612b1e35~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=mSn%2FRUkiXeXZO9tbG2Mqnhj299w%3D" alt="图片" loading="lazy"/></p>
<p>允许后，Claude Code CLI会安装所需的依赖并创建脚本</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1df6bf7bf2c74e6ebbc7d58cacb75a63~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=4G2S%2B6u8JCdpooAKNrypZRVow0I%3D" alt="图片" loading="lazy"/></p>
<p>允许脚本后最终读取到了Excel表格内容</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1873d8d1fd5b4602a257e58ce16c973c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=WFC1qRxMIlBUBTvDL35agKgJA9I%3D" alt="图片" loading="lazy"/></p>
<p>最后看一下传统Claude Code CLI读取Excel表格的效果</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d04c69d89837447aacf2f1c8bd577905~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=Z2fIbFAW8KwBCzT8Qc8XeGqoVGA%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-12">三方Skill安装使用</h3>
<p>这里以Claude Code Templates提供的Skills为例，对Claude Code Templates还不了解的小伙伴可以看往期内容：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493228%26idx%3D1%26sn%3D7bb969019478e4e38974776bb04fedda%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493228&amp;idx=1&amp;sn=7bb969019478e4e38974776bb04fedda&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">分享一个Claude Code宝藏网站Claude Code Templates</a></p>
<p>进入项目根目录，在命令行终端输入如下指令进行安装：</p>
<pre><code class="hljs language-ini" lang="ini">$ npx claude-code-templates\@latest <span class="hljs-attr">--skill</span>=creative-design/canvas-design --<span class="hljs-literal">yes</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ebaee8eeced443e836dd6816fa30d36~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=AltEG%2B2VIw1KNnX6pcg7fzrw6Lo%3D" alt="图片" loading="lazy"/></p>
<p>安装完成后，项目 .claude/ 目录会多出一个 skills 目录</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/755ed8a633cf4e91beb7f978278fa55a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=iJn8Pa43k6yVBKFy9EA6hwvt1fo%3D" alt="图片" loading="lazy"/></p>
<p>完整的 SKILL.md 内容如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">name:</span> canvas-design
<span class="hljs-symbol">description:</span> Create beautiful visual art <span class="hljs-keyword">in</span> .png <span class="hljs-built_in">and</span> .pdf documents <span class="hljs-keyword">using</span> design philosophy. You should use this skill <span class="hljs-keyword">when</span> the user asks <span class="hljs-keyword">to</span> create a poster, piece <span class="hljs-keyword">of</span> art, design, <span class="hljs-built_in">or</span> other <span class="hljs-keyword">static</span> piece. Create original visual designs, never copying existing artists<span class="hljs-comment">' work to avoid copyright violations.</span>
<span class="hljs-symbol">license:</span> Complete terms <span class="hljs-keyword">in</span> LICENSE.txt
--------------------------------------

These are instructions <span class="hljs-keyword">for</span> creating design philosophies - aesthetic movements that are <span class="hljs-keyword">then</span> EXPRESSED VISUALLY. Output only .md files, .pdf files, <span class="hljs-built_in">and</span> .png files.
Complete this <span class="hljs-keyword">in</span> two steps:

<span class="hljs-number">1</span>.  Design Philosophy Creation (.md file)
<span class="hljs-number">2</span>.  Express <span class="hljs-keyword">by</span> creating it <span class="hljs-keyword">on</span> a canvas (.pdf file <span class="hljs-built_in">or</span> .png file)
    First, undertake this task:

## DESIGN PHILOSOPHY CREATION

<span class="hljs-keyword">To</span> begin, create a VISUAL PHILOSOPHY (<span class="hljs-built_in">not</span> layouts <span class="hljs-built_in">or</span> templates) that will be interpreted through:

*   Form, space, color, composition
*   Images, graphics, shapes, patterns
*   Minimal <span class="hljs-keyword">text</span> <span class="hljs-keyword">as</span> visual accent

### THE CRITICAL UNDERSTANDING

*   What <span class="hljs-built_in">is</span> received: Some subtle input <span class="hljs-built_in">or</span> instructions <span class="hljs-keyword">by</span> the user that should be taken <span class="hljs-keyword">into</span> account, but used <span class="hljs-keyword">as</span> a foundation; it should <span class="hljs-built_in">not</span> constrain creative freedom.
*   What <span class="hljs-built_in">is</span> created: A design philosophy/aesthetic movement.
*   What happens <span class="hljs-keyword">next</span>: <span class="hljs-keyword">Then</span>, the same version receives the philosophy <span class="hljs-built_in">and</span> EXPRESSES IT VISUALLY - creating artifacts that are <span class="hljs-number">90%</span> visual design, <span class="hljs-number">10%</span> essential <span class="hljs-keyword">text</span>.
    Consider this approach:
*   Write a manifesto <span class="hljs-keyword">for</span> an art movement
*   The <span class="hljs-keyword">next</span> phase involves making the artwork
    The philosophy must emphasize: Visual expression. Spatial communication. Artistic interpretation. Minimal words.

### HOW <span class="hljs-keyword">TO</span> GENERATE A VISUAL PHILOSOPHY

**Name the movement** (<span class="hljs-number">1</span>-<span class="hljs-number">2</span> words): <span class="hljs-string">"Brutalist Joy"</span> / <span class="hljs-string">"Chromatic Silence"</span> / <span class="hljs-string">"Metabolist Dreams"</span>
**Articulate the philosophy** (<span class="hljs-number">4</span>-<span class="hljs-number">6</span> paragraphs - concise but complete):
<span class="hljs-keyword">To</span> capture the VISUAL essence, express how the philosophy manifests through:

*   Space <span class="hljs-built_in">and</span> form
*   Color <span class="hljs-built_in">and</span> material
*   Scale <span class="hljs-built_in">and</span> rhythm
*   Composition <span class="hljs-built_in">and</span> balance
*   Visual hierarchy
    **CRITICAL GUIDELINES:**
*   **Avoid redundancy**: <span class="hljs-keyword">Each</span> design aspect should be mentioned once. Avoid repeating points about color theory, spatial relationships, <span class="hljs-built_in">or</span> typographic principles unless adding <span class="hljs-built_in">new</span> depth.
*   **Emphasize craftsmanship REPEATEDLY**: The philosophy MUST stress multiple times that the final work should appear <span class="hljs-keyword">as</span> though it took countless hours <span class="hljs-keyword">to</span> create, was labored over <span class="hljs-keyword">with</span> care, <span class="hljs-built_in">and</span> comes <span class="hljs-keyword">from</span> someone at the absolute top <span class="hljs-keyword">of</span> their field. This framing <span class="hljs-built_in">is</span> essential - repeat phrases <span class="hljs-built_in">like</span> <span class="hljs-string">"meticulously crafted,"</span> <span class="hljs-string">"the product of deep expertise,"</span> <span class="hljs-string">"painstaking attention,"</span> <span class="hljs-string">"master-level execution."</span>
*   **Leave creative space**: Remain specific about the aesthetic direction, but concise enough that the <span class="hljs-keyword">next</span> Claude has room <span class="hljs-keyword">to</span> make interpretive choices also at a extremely high level <span class="hljs-keyword">of</span> craftmanship.
    The philosophy must guide the <span class="hljs-keyword">next</span> version <span class="hljs-keyword">to</span> express ideas VISUALLY, <span class="hljs-built_in">not</span> through <span class="hljs-keyword">text</span>. Information lives <span class="hljs-keyword">in</span> design, <span class="hljs-built_in">not</span> paragraphs.

### PHILOSOPHY EXAMPLES

**<span class="hljs-string">"Concrete Poetry"</span>**
<span class="hljs-symbol">Philosophy:</span> Communication through monumental form <span class="hljs-built_in">and</span> bold geometry.
Visual expression: Massive color blocks, sculptural typography (huge <span class="hljs-type">single</span> words, tiny labels), Brutalist spatial divisions, Polish poster energy meets Le Corbusier. Ideas expressed through visual weight <span class="hljs-built_in">and</span> spatial tension, <span class="hljs-built_in">not</span> explanation. <span class="hljs-keyword">Text</span> <span class="hljs-keyword">as</span> rare, powerful gesture - never paragraphs, only essential words integrated <span class="hljs-keyword">into</span> the visual architecture. Every element placed <span class="hljs-keyword">with</span> the precision <span class="hljs-keyword">of</span> a master craftsman.
**<span class="hljs-string">"Chromatic Language"</span>**
<span class="hljs-symbol">Philosophy:</span> Color <span class="hljs-keyword">as</span> the primary information system.
Visual expression: Geometric precision <span class="hljs-keyword">where</span> color zones create meaning. Typography minimal - small sans-serif labels letting chromatic fields communicate. Think Josef Albers<span class="hljs-comment">' interaction meets data visualization. Information encoded spatially and chromatically. Words only to anchor what color already shows. The result of painstaking chromatic calibration.</span>
**<span class="hljs-string">"Analog Meditation"</span>**
<span class="hljs-symbol">Philosophy:</span> Quiet visual contemplation through texture <span class="hljs-built_in">and</span> breathing room.
Visual expression: Paper grain, ink bleeds, vast negative space. Photography <span class="hljs-built_in">and</span> illustration dominate. Typography whispered (small, restrained, serving the visual). Japanese photobook aesthetic. Images breathe across pages. <span class="hljs-keyword">Text</span> appears sparingly - <span class="hljs-type">short</span> phrases, never explanatory blocks. <span class="hljs-keyword">Each</span> composition balanced <span class="hljs-keyword">with</span> the care <span class="hljs-keyword">of</span> a meditation practice.
**<span class="hljs-string">"Organic Systems"</span>**
<span class="hljs-symbol">Philosophy:</span> Natural clustering <span class="hljs-built_in">and</span> modular growth patterns.
Visual expression: Rounded forms, organic arrangements, color <span class="hljs-keyword">from</span> nature through architecture. Information shown through visual diagrams, spatial relationships, iconography. <span class="hljs-keyword">Text</span> only <span class="hljs-keyword">for</span> <span class="hljs-keyword">key</span> labels floating <span class="hljs-keyword">in</span> space. The composition tells the story through expert spatial orchestration.
**<span class="hljs-string">"Geometric Silence"</span>**
<span class="hljs-symbol">Philosophy:</span> Pure <span class="hljs-keyword">order</span> <span class="hljs-built_in">and</span> restraint.
Visual expression: Grid-based precision, bold photography <span class="hljs-built_in">or</span> stark graphics, dramatic negative space. Typography precise but minimal - small essential <span class="hljs-keyword">text</span>, large quiet zones. Swiss formalism meets Brutalist material honesty. <span class="hljs-keyword">Structure</span> communicates, <span class="hljs-built_in">not</span> words. Every alignment the work <span class="hljs-keyword">of</span> countless refinements.
*These are condensed examples. The actual design philosophy should be <span class="hljs-number">4</span>-<span class="hljs-number">6</span> substantial paragraphs.*

### ESSENTIAL PRINCIPLES

\- **VISUAL PHILOSOPHY**: Create an aesthetic worldview <span class="hljs-keyword">to</span> be expressed through design
\- **MINIMAL <span class="hljs-keyword">TEXT</span>**: Always emphasize that <span class="hljs-keyword">text</span> <span class="hljs-built_in">is</span> sparse, essential-only, integrated <span class="hljs-keyword">as</span> visual element - never lengthy
\- **SPATIAL EXPRESSION**: Ideas communicate through space, form, color, composition - <span class="hljs-built_in">not</span> paragraphs
\- **ARTISTIC FREEDOM**: The <span class="hljs-keyword">next</span> Claude interprets the philosophy visually - provide creative room
\- **PURE DESIGN**: This <span class="hljs-built_in">is</span> about making ART OBJECTS, <span class="hljs-built_in">not</span> documents <span class="hljs-keyword">with</span> decoration
\- **EXPERT CRAFTSMANSHIP**: Repeatedly emphasize the final work must look meticulously crafted, labored over <span class="hljs-keyword">with</span> care, the product <span class="hljs-keyword">of</span> countless hours <span class="hljs-keyword">by</span> someone at the top <span class="hljs-keyword">of</span> their field
**The design philosophy should be <span class="hljs-number">4</span>-<span class="hljs-number">6</span> paragraphs <span class="hljs-type">long</span>.** Fill it <span class="hljs-keyword">with</span> poetic design philosophy that brings together the core vision. Avoid repeating the same points. Keep the design philosophy generic without mentioning the intention <span class="hljs-keyword">of</span> the art, <span class="hljs-keyword">as</span> <span class="hljs-keyword">if</span> it can be used wherever. Output the design philosophy <span class="hljs-keyword">as</span> a .md file.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## DEDUCING THE SUBTLE REFERENCE

**CRITICAL <span class="hljs-keyword">STEP</span>**: Before creating the canvas, identify the subtle conceptual thread <span class="hljs-keyword">from</span> the original request.
**THE ESSENTIAL PRINCIPLE**:
The topic <span class="hljs-built_in">is</span> a **subtle, niche reference embedded within the art itself** - <span class="hljs-built_in">not</span> always literal, always sophisticated. Someone familiar <span class="hljs-keyword">with</span> the subject should feel it intuitively, <span class="hljs-keyword">while</span> others simply experience a masterful abstract composition. The design philosophy provides the aesthetic language. The deduced topic provides the soul - the quiet conceptual DNA woven invisibly <span class="hljs-keyword">into</span> form, color, <span class="hljs-built_in">and</span> composition.
This <span class="hljs-built_in">is</span> **VERY IMPORTANT**: The reference must be refined so it enhances the work<span class="hljs-comment">'s depth without announcing itself. Think like a jazz musician quoting another song - only those who know will catch it, but everyone appreciates the music.</span>
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CANVAS CREATION

<span class="hljs-keyword">With</span> both the philosophy <span class="hljs-built_in">and</span> the conceptual framework established, express it <span class="hljs-keyword">on</span> a canvas. <span class="hljs-keyword">Take</span> a moment <span class="hljs-keyword">to</span> gather thoughts <span class="hljs-built_in">and</span> clear the mind. Use the design philosophy created <span class="hljs-built_in">and</span> the instructions below <span class="hljs-keyword">to</span> craft a masterpiece, embodying all aspects <span class="hljs-keyword">of</span> the philosophy <span class="hljs-keyword">with</span> expert craftsmanship.
**IMPORTANT**: <span class="hljs-keyword">For</span> any type <span class="hljs-keyword">of</span> content, even <span class="hljs-keyword">if</span> the user requests something <span class="hljs-keyword">for</span> a movie/game/book, the approach should still be sophisticated. Never lose sight <span class="hljs-keyword">of</span> the idea that this should be art, <span class="hljs-built_in">not</span> something that<span class="hljs-comment">'s cartoony or amateur.</span>
<span class="hljs-keyword">To</span> create museum <span class="hljs-built_in">or</span> magazine quality work, use the design philosophy <span class="hljs-keyword">as</span> the foundation. Create one <span class="hljs-type">single</span> page, highly visual, design-forward PDF <span class="hljs-built_in">or</span> PNG output (unless asked <span class="hljs-keyword">for</span> more pages). Generally use repeating patterns <span class="hljs-built_in">and</span> perfect shapes. Treat the abstract philosophical design <span class="hljs-keyword">as</span> <span class="hljs-keyword">if</span> it were a scientific bible, borrowing the visual language <span class="hljs-keyword">of</span> systematic observation—dense accumulation <span class="hljs-keyword">of</span> marks, repeated elements, <span class="hljs-built_in">or</span> layered patterns that build meaning through patient repetition <span class="hljs-built_in">and</span> reward sustained viewing. Add sparse, clinical typography <span class="hljs-built_in">and</span> systematic reference markers that suggest this could be a diagram <span class="hljs-keyword">from</span> an imaginary discipline, treating the invisible subject <span class="hljs-keyword">with</span> the same reverence typically reserved <span class="hljs-keyword">for</span> documenting observable phenomena. Anchor the piece <span class="hljs-keyword">with</span> simple phrase(s) <span class="hljs-built_in">or</span> details positioned subtly, <span class="hljs-keyword">using</span> a limited color palette that feels intentional <span class="hljs-built_in">and</span> cohesive. Embrace the paradox <span class="hljs-keyword">of</span> <span class="hljs-keyword">using</span> analytical visual language <span class="hljs-keyword">to</span> express ideas about human experience: the result should feel <span class="hljs-built_in">like</span> an artifact that proves something ephemeral can be studied, mapped, <span class="hljs-built_in">and</span> understood through careful attention. This <span class="hljs-built_in">is</span> <span class="hljs-literal">true</span> art. 
**<span class="hljs-keyword">Text</span> <span class="hljs-keyword">as</span> a contextual element**: <span class="hljs-keyword">Text</span> <span class="hljs-built_in">is</span> always minimal <span class="hljs-built_in">and</span> visual-first, but <span class="hljs-keyword">let</span> context guide whether that means whisper-quiet labels <span class="hljs-built_in">or</span> bold typographic gestures. A punk venue poster might have larger, more aggressive type than a minimalist ceramics studio identity. Most <span class="hljs-keyword">of</span> the time, font should be thin. All use <span class="hljs-keyword">of</span> fonts must be design-forward <span class="hljs-built_in">and</span> prioritize visual communication. Regardless <span class="hljs-keyword">of</span> <span class="hljs-keyword">text</span> scale, <span class="hljs-literal">nothing</span> falls <span class="hljs-keyword">off</span> the page <span class="hljs-built_in">and</span> <span class="hljs-literal">nothing</span> overlaps. Every element must be contained within the canvas boundaries <span class="hljs-keyword">with</span> proper margins. Check carefully that all <span class="hljs-keyword">text</span>, graphics, <span class="hljs-built_in">and</span> visual elements have breathing room <span class="hljs-built_in">and</span> clear separation. This <span class="hljs-built_in">is</span> non-negotiable <span class="hljs-keyword">for</span> professional execution. **IMPORTANT: Use different fonts <span class="hljs-keyword">if</span> writing <span class="hljs-keyword">text</span>. Search the `./canvas-fonts` directory. Regardless <span class="hljs-keyword">of</span> approach, sophistication <span class="hljs-built_in">is</span> non-negotiable.**
Download <span class="hljs-built_in">and</span> use whatever fonts are needed <span class="hljs-keyword">to</span> make this a reality. <span class="hljs-keyword">Get</span> creative <span class="hljs-keyword">by</span> making the typography actually part <span class="hljs-keyword">of</span> the art itself -- <span class="hljs-keyword">if</span> the art <span class="hljs-built_in">is</span> abstract, bring the font onto the canvas, <span class="hljs-built_in">not</span> typeset digitally.
<span class="hljs-keyword">To</span> push boundaries, follow design instinct/intuition <span class="hljs-keyword">while</span> <span class="hljs-keyword">using</span> the philosophy <span class="hljs-keyword">as</span> a guiding principle. Embrace ultimate design freedom <span class="hljs-built_in">and</span> choice. Push aesthetics <span class="hljs-built_in">and</span> design <span class="hljs-keyword">to</span> the frontier. 
**CRITICAL**: <span class="hljs-keyword">To</span> achieve human-crafted quality (<span class="hljs-built_in">not</span> AI-generated), create work that looks <span class="hljs-built_in">like</span> it took countless hours. Make it appear <span class="hljs-keyword">as</span> though someone at the absolute top <span class="hljs-keyword">of</span> their field labored over every detail <span class="hljs-keyword">with</span> painstaking care. Ensure the composition, spacing, color choices, typography - everything screams expert-level craftsmanship. <span class="hljs-type">Double</span>-check that <span class="hljs-literal">nothing</span> overlaps, formatting <span class="hljs-built_in">is</span> flawless, every detail perfect. Create something that could be shown <span class="hljs-keyword">to</span> people <span class="hljs-keyword">to</span> prove expertise <span class="hljs-built_in">and</span> rank <span class="hljs-keyword">as</span> undeniably impressive.
Output the final result <span class="hljs-keyword">as</span> a <span class="hljs-type">single</span>, downloadable .pdf <span class="hljs-built_in">or</span> .png file, alongside the design philosophy used <span class="hljs-keyword">as</span> a .md file.
------------------------------------------------------------------------------------------------------------------------

\## FINAL <span class="hljs-keyword">STEP</span>
**IMPORTANT**: The user ALREADY said <span class="hljs-string">"It isn't perfect enough. It must be pristine, a masterpiece if craftsmanship, as if it were about to be displayed in a museum."</span>
**CRITICAL**: <span class="hljs-keyword">To</span> refine the work, avoid adding more graphics; instead refine what has been created <span class="hljs-built_in">and</span> make it extremely crisp, respecting the design philosophy <span class="hljs-built_in">and</span> the principles <span class="hljs-keyword">of</span> minimalism entirely. Rather than adding a fun filter <span class="hljs-built_in">or</span> refactoring a font, consider how <span class="hljs-keyword">to</span> make the existing composition more cohesive <span class="hljs-keyword">with</span> the art. <span class="hljs-keyword">If</span> the instinct <span class="hljs-built_in">is</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">call</span> a <span class="hljs-built_in">new</span> <span class="hljs-keyword">function</span> <span class="hljs-built_in">or</span> draw a <span class="hljs-built_in">new</span> shape, <span class="hljs-keyword">STOP</span> <span class="hljs-built_in">and</span> instead ask: <span class="hljs-string">"How can I make what's already here more of a piece of art?"</span>
<span class="hljs-keyword">Take</span> a second pass. Go back <span class="hljs-keyword">to</span> the code <span class="hljs-built_in">and</span> refine/polish further <span class="hljs-keyword">to</span> make this a philosophically designed masterpiece.

## MULTI-PAGE <span class="hljs-keyword">OPTION</span>

<span class="hljs-keyword">To</span> create additional pages <span class="hljs-keyword">when</span> requested, create more creative pages along the same lines <span class="hljs-keyword">as</span> the design philosophy but distinctly different <span class="hljs-keyword">as</span> well. Bundle those pages <span class="hljs-keyword">in</span> the same .pdf <span class="hljs-built_in">or</span> many .pngs. Treat the first page <span class="hljs-keyword">as</span> just a <span class="hljs-type">single</span> page <span class="hljs-keyword">in</span> a whole coffee table book waiting <span class="hljs-keyword">to</span> be filled. Make the <span class="hljs-keyword">next</span> pages unique twists <span class="hljs-built_in">and</span> memories <span class="hljs-keyword">of</span> the original. Have them almost tell a story <span class="hljs-keyword">in</span> a very tasteful way. Exercise full creative freedom.
</code></pre>
<p>包含 执行流程、设计理念关键理解、哲学示例、画布创建 等操作描述。</p>
<p>重启Claude Code CLI，要查看当前所有可用的技能，可以在交互式命令中直接询问 Claude Code CLI：</p>
<pre><code class="hljs language-arduino" lang="arduino">List all available Skills
</code></pre>
<p>Claude Code CLI会查找所有可用的Skill</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c76ed90d9cb4c99ac3c2ab284967072~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=USF%2BaXxiAouSxtj%2B9G2t0dpxosw%3D" alt="图片" loading="lazy"/></p>
<p>Skill的使用也很简单，直接输入提示词：</p>
<pre><code class="hljs">「流浪猫领养公益海报，视觉主体是 3 只不同毛色的流浪猫（橘猫、三花猫、黑猫，姿态温顺，睁着圆眼看向镜头），趴在铺着柔软灰色毛毯的木质平台上，背景是浅薄荷绿纯色背景，角落点缀小型白色爱心图案，风格为清新治愈的扁平插画风，
色调以薄荷绿、奶白、橘色为主，顶部用圆润字体写‘给它一个家 —— 流浪猫领养日’，下方标注时间（10.1-10.7）和地点（城市中心广场），画面无尖锐元素，整体温暖柔和，传递‘关爱生命’的氛围」，根据上面提示词生成对应内容海报
</code></pre>
<p>Claude Code CLI会根据Skill要求先进行设计哲学创作并保存到 tender_sanctuary_philosophy.md 文件</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ca013a34c324535a53821b8b4b2a1a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=NV9hkW9IJtX0LRkWvw77tcGpFws%3D" alt="图片" loading="lazy"/></p>
<p>然后根据创作设计文件编写Python脚本绘制图片</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d78c9de9a8c147c0a6c0d26a67b2d65d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=JTlrKQBhYXHiH1s47OhmbVys7HU%3D" alt="图片" loading="lazy"/></p>
<p>绘制完成后，效果如下，效果有点一言难尽，对中文支持有问题，中文没有展示出来</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5c3c3fa44640400e908b0b972a1cedae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=Xa%2BwItPw41pT7wRG1ewQ8pUmcZw%3D" alt="图片" loading="lazy"/></p>
<p>最后替换为英文版，效果如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96da3fefc42443d695aadd5876d261b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=yBcqq5bKWS3%2FcSx6CCMYHweWe9A%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-13">自定义Skill</h3>
<p>这里我们以一个简单的待办事项为例，自定义Skill首先需要创建一个 skills目录，可以手动创建，也可以通过以下命令创建：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_">$</span><span class="bash"> <span class="hljs-built_in">mkdir</span> -p .claude/skills/my-skill-name</span>
</code></pre>
<p>在 my-skill-name 目录下创建 SKILL.md 文件，首先创建一个简单的Skill输入提示词内容：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">my-first-skill</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">调用个人工作流。当用户需要执行个人工作流时调用该Skill</span>
<span class="hljs-attr">allowed-tools:</span> <span class="hljs-string">Read,Grep,Glob</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment">## 执行步骤</span>
<span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">查找项目中</span> <span class="hljs-string">task.md</span> <span class="hljs-string">文件：</span>
<span class="hljs-string">```bash</span>
<span class="hljs-string">find</span> <span class="hljs-string">.</span> <span class="hljs-string">-name</span> <span class="hljs-string">"task.md"</span>
<span class="hljs-string">```</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">没有查找到输出</span> <span class="hljs-string">“项目中不存在task.md”</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">执行下一步</span>
<span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">输出</span> <span class="hljs-string">task.md</span> <span class="hljs-string">文件中的未读项</span>
</code></pre>
<p>调用也很简单，直接输入提示词：</p>
<pre><code class="hljs">调用个人工作流Skill 
</code></pre>
<p>Claude Code CLI会按照指定的Shell语句查找 task.md 文件，没有找到最终输出了“项目中不存在task.md”</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5dbea69612df4641b67ef4cf7f8ac052~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=d5BKk0i81k1J4Yp2F1U9Hq1kirw%3D" alt="图片" loading="lazy"/></p>
<p>我们在项目根目录创建一个 task.md 文件</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/565a492e7a8f4db59b7a895f1c1bdaba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=eRDagrb2aA43DyD6eV02sUr%2FuEw%3D" alt="图片" loading="lazy"/></p>
<p>再次执行自定义Skill，可以看到输出结果如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61fa819a90514dca967bf73217d84ae4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=WmWfLOKJUEp3Y6iekbnZ7Fc93JA%3D" alt="图片" loading="lazy"/></p>
<p>我们也可以将 task.md 文件的查找和输出规则进行调整，对Skill进行完善和优化</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d7f9b5c9b064511b557eb93d246f4de~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=RwH%2BffPVaej%2BFkN%2Bnkowqj1xHJY%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs language-markdown" lang="markdown">name: my-first-skill
description: 调用个人工作流。当用户需要执行个人工作流时调用该Skill
<span class="hljs-section">allowed-tools: Read,Grep,Glob
-----------------------------</span>

<span class="hljs-section">## 执行步骤</span>

<span class="hljs-bullet">1.</span> 查找项目根目录是否存在 task.md 文件， 参考 [<span class="hljs-string">reference.md</span>](<span class="hljs-link">./reference.md</span>)：
    - 没有查找到输出 “项目中不存在task.md”
    - 找到执行下一步
<span class="hljs-bullet">2.</span> 输出 task.md 文件中的未读项
    - 没有未读项输出 “没有未读项”
    - 输出未读项，输出格式参考 [<span class="hljs-string">templates.md</span>](<span class="hljs-link">./templates/templates.md</span>)
</code></pre>
<p>reference.md</p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># task.md文件查找规则</span>
<span class="hljs-string">``</span><span class="hljs-string">`bash
find . -name "task.md"
`</span><span class="hljs-string">``</span>
</code></pre>
<p>templates.md</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 任务未读项格式</span>
<span class="hljs-bullet">-</span> 【任务1】（未完成）
<span class="hljs-bullet">-</span> 【任务2】（未完成）
</code></pre>
<p>再次执行Skill任务，可以发现AI按照我们指定的规则输出了结果</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/04d622c4789c46b78a316d69b79aa716~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=dEJOXp4q7X8O5Cui%2BOB%2FMwnMzgo%3D" alt="图片" loading="lazy"/></p>
<p>当然Skill还可以做更多更强大的能力扩展，以上只是简单的抛砖引玉。</p>
<h2 data-id="heading-14">友情提示</h2>
<p>见原文：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FP674ZIjwoeD1kjUELMkaBg" target="_blank" title="https://mp.weixin.qq.com/s/P674ZIjwoeD1kjUELMkaBg" ref="nofollow noopener noreferrer">Claude发布新功能Agent Skills，让你的Agent更专业</a></p>
<blockquote>
<p>本文同步自微信公众号 "<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FP674ZIjwoeD1kjUELMkaBg" target="_blank" title="https://mp.weixin.qq.com/s/P674ZIjwoeD1kjUELMkaBg" ref="nofollow noopener noreferrer">程序员小溪</a>" ，这里只是同步，想看及时消息请移步我的公众号，不定时更新我的学习经验。友情提示友情提示</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter,Compose,Web 在Android平台上从布局到屏幕的机制探究]]></title>    <link>https://juejin.cn/post/7572480736362266630</link>    <guid>https://juejin.cn/post/7572480736362266630</guid>    <pubDate>2025-11-16T12:41:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572480736362266630" data-draft-id="7572525491538821162" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter,Compose,Web 在Android平台上从布局到屏幕的机制探究"/> <meta itemprop="keywords" content="Flutter,Android,WebView"/> <meta itemprop="datePublished" content="2025-11-16T12:41:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="apigfly"/> <meta itemprop="url" content="https://juejin.cn/user/2488950054453613"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter,Compose,Web 在Android平台上从布局到屏幕的机制探究
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2488950054453613/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    apigfly
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T12:41:46.000Z" title="Sun Nov 16 2025 12:41:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读27分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>最近用到了 Flutter 做跨平台项目，比较好奇跨平台项目是怎么能够在 Android 设备上显示出来的，就有了今天的文章，因为之前写的 <a href="https://juejin.cn/post/6944960866404007944" target="_blank" title="https://juejin.cn/post/6944960866404007944">Android 图形显示系统</a> ，也算是承上启下了吧，毕竟这么多年没更啦</p>
</blockquote>
<h2 data-id="heading-0"><strong>1. 核心架构基础：Android 图形栈与数据流</strong></h2>
<p>理解任何 Android UI 组件的渲染过程，都必须从操作系统的底层图形架构开始，特别是缓冲区管理、Surface 抽象以及系统合成器的功能。</p>
<h3 data-id="heading-1"><strong>1.1. Android 渲染数据流：BufferQueue, Surface 与 Layer 模型</strong></h3>
<p>Android 图形系统基于<code>生产者-消费者</code>模型。
在这种模型中，应用或其渲染引擎被视为<code>生产者</code>，而系统合成器 <code>SurfaceFlinger</code> 则充当<code>消费者</code>。具体大家可以看之前的文章：<a href="https://juejin.cn/post/6944960866404007944#heading-0" target="_blank" title="https://juejin.cn/post/6944960866404007944#heading-0">显示原理</a></p>
<p>简要示意图如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1eb1d3858e0a4552bdcf7f7ab7935270~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=dv7A%2FgboMU5H0jYcGQ0o2kt6evw%3D" alt="graphics-pipeline.png" loading="lazy"/></p>
<h4 data-id="heading-2"><code>BufferQueue</code></h4>
<p>数据交换的核心。这是一个先进先出（FIFO）队列，位于 <code>libgui IPC</code> 库中，用于跨进程安全地传输图形缓冲区。</p>
<p><code>生产者</code>负责向队列中写入已渲染的帧，而<code>消费者</code>则从队列中取出帧进行合成。
这种机制的设计目标是确保数据的原子性传输和同步。</p>
<p><code>消费者</code>通常是 Android 的核心合成器 <code>SurfaceFlinger</code>，但也可以是其他组件，例如 <code>SurfaceView</code>、<code>SurfaceTexture</code> 或 <code>ImageReader</code>。</p>
<h4 data-id="heading-3"><code>Surface</code></h4>
<p><code>Surface</code> 对象是应用进程用于与 <code>BufferQueue</code> 交互的高级 API 接口。
它本身并不存储像素数据，而是持有一个对底层 <code>IGraphicBufferProducer</code> 接口的引用。
这个接口允许应用跨进程将渲染完成的图形缓冲区排队等待消费。</p>
<h4 data-id="heading-4"><code>Layer</code></h4>
<p><code>Layer</code> 是 <code>SurfaceFlinger</code> 内部用于合成的基本单位。
它与 <code>Surface</code> 不同，<code>Surface</code> 专注于像素内容的生产，而 <code>Layer</code> 专注于该内容的合成方式。
一个 <code>Layer</code> 封装了合成所需的全部元数据和状态信息，包括：Z 轴顺序（决定遮挡关系）、可见性、混合模式（Alpha 混合）、裁剪区域、完整的 2D/3D 转换矩阵（Translation, Rotation, Scale）。</p>
<h4 data-id="heading-5">零拷贝优化</h4>
<p>现代 Android 图形系统严重依赖 <code>AHardwareBuffer (API 26+)</code> 来实现高性能、低延迟的图形数据传输。<br/>
<code>AHardwareBuffer</code> 代表一种硬件支持的缓冲区，可以高效地在不同系统组件和进程之间共享，通常用于实现零拷贝操作。<br/>
<code>AHardwareBuffer</code>支持多层纹理数组和立方体贴图的定义，特别适用于 Vulkan 后端或跨进程图形传输<br/>
<code>WebView</code> 的进程外光栅化（OOPR）就需要利用<code>AHardwareBuffer</code>机制实现高效的缓冲区共享。</p>
<p><strong>生产者与消费者的“距离”与隔离</strong>
<code>BufferQueue</code> 机制的核心价值在于，它使得<code>生产者</code>和<code>消费者</code>能够在不同的线程甚至不同的进程中独立、并行地运行。这种隔离性是 Android 实现流畅 UI 和高保真媒体播放的关键：</p>
<ol>
<li><strong>线程隔离（距离近）：</strong> 生产者（如应用中的 RenderThread 或 GLSurfaceView 的专用渲染线程）可以在高频下（如 60FPS）渲染，而不会阻塞接收该缓冲区的消费者（通常是 <code>SurfaceFlinger</code>）。这确保了渲染任务不会拖累应用的主 UI 线程。</li>
<li><strong>进程隔离（距离远）：</strong> <code>Surface</code> 对象实现了 <code>Parcelable</code> 接口，因此可以安全地通过 <code>Binder IPC</code> 机制跨越进程边界传输。这种能力使得一个独立进程的渲染结果能够直接提交给另一个进程中的接收者（例如 <code>SurfaceFlinger</code> 或 <code>SurfaceView</code>）。</li>
</ol>
<p><strong>SF 之外的消费者 (应用程序主动选择的数据处理流)</strong></p>
<ol>
<li><strong>SurfaceTexture (GPU 纹理消费者):</strong>
<ul>
<li><strong>场景：</strong> 实时相机预览、将视频流作为纹理应用到 3D 游戏或 AR 场景中。</li>
<li><strong>机制：</strong> <code>SurfaceTexture</code> 充当 <code>BufferQueue</code> 的消费者。它接收生产者（如相机驱动或视频解码器）提交的帧数据，并将其转换为一个 <strong>OpenGL ES 纹理</strong>，供应用内的 GLES 线程绑定和使用。这允许开发者在 GPU 上直接处理这些数据（例如应用滤镜、进行几何变换），<strong>而无需将数据提交给 SurfaceFlinger 进行系统合成</strong>。这种路径允许应用在本地 GPU 上完成渲染和处理，但最终如果需要显示，应用通常需要将这个<strong>处理后的纹理</strong>绘制到自己的主 <code>Surface</code> 上（最终仍由 SF 合成）。</li>
</ul>
</li>
<li><strong>ImageReader (数据处理消费者):</strong>
<ul>
<li><strong>场景：</strong> 截屏、图像分析（如人脸识别）、自定义相机捕获原始帧。</li>
<li><strong>机制：</strong> ImageReader 也充当 BufferQueue 的消费者。它允许应用程序从队列中获取图像数据（Image 对象），通常是原始像素数据。数据随后被发送到应用的 CPU/NDK 层，用于进一步的软件处理、分析或保存，<strong>完全绕过了 Android 的硬件加速显示路径</strong>，是纯粹的数据获取和处理通道。</li>
</ul>
</li>
</ol>
<p><strong>SF 跨进程/跨线程能力的常见示例 (显示场景)</strong></p>
<ul>
<li><strong>视频播放 (SurfaceView 场景):</strong>
<ul>
<li><strong>生产者：</strong> 视频解码器（通常是运行在独立进程中的硬件或系统服务）。</li>
<li><strong>消费者：</strong> SurfaceFlinger。</li>
<li><strong>优势：</strong> 解码器将视频帧直接绘制到从 SurfaceView 获得的 Surface 上。由于 SurfaceFlinger 直接从 BufferQueue 获取缓冲区，整个过程<strong>完全绕过了应用的主 CPU/GPU 管线</strong>。这实现了零拷贝的数据路径，对高吞吐量的视频帧传输至关重要，确保了低延迟和低功耗。</li>
</ul>
</li>
<li><strong>多窗口/系统 UI 合成 (SurfaceFlinger 核心功能):</strong>
<ul>
<li><strong>生产者：</strong> 应用 A 的主渲染 Layer (Native View/Compose 的 RenderThread 提交)；应用 B 的独立 Layer；系统状态栏和导航栏 Layer。</li>
<li><strong>消费者：</strong> SurfaceFlinger。</li>
<li><strong>优势：</strong> SurfaceFlinger 接收来自<strong>多个不同应用进程</strong>和<strong>系统进程</strong>的独立 Layer，并管理它们的 Z 轴顺序、位置和变换。这种隔离确保了即使一个应用崩溃，也不会影响其他应用或系统 UI 的显示。</li>
</ul>
</li>
<li><strong>进程外 WebView 渲染 (OOPR 模式):</strong>
<ul>
<li><strong>生产者：</strong> 沙箱隔离的 Chrome Render Process（一个独立进程）。</li>
<li><strong>消费者：</strong> SurfaceFlinger。</li>
<li><strong>优势：</strong> WebView 的内容渲染发生在应用主进程之外。渲染进程将结果提交到专用的 Surface 缓冲区，SurfaceFlinger 将其作为独立 Layer 合成。这提供了极佳的安全性和稳定性隔离，即使 Web 内容中的 JavaScript 导致渲染进程崩溃，主机应用也可以通过回调机制恢复。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-6"><strong>1.2. 系统合成器：<code>SurfaceFlinger</code> 与硬件合成器 (<code>HWC</code>) 的角色</strong></h3>
<p><code>SurfaceFlinger (SF)</code> 是 Android 的核心系统服务，充当所有可见 UI 元素的最终合成器。</p>
<h4 data-id="heading-7"><code>SurfaceFlinger (SF)</code> 的职责</h4>
<p><code>SF</code> 接收来自所有可见窗口和系统 UI 组件的图形缓冲区，这些缓冲区通过 <code>Layer</code> 的形式提交给 <code>SF</code> 。<br/>
<code>SF</code> 的任务是：</p>
<ul>
<li>管理所有 <code>Layer</code> 的 Z 轴顺序、位置、变换和剪裁。</li>
<li>根据 <code>Layer</code> 的属性（例如透明度、相对 Z 轴、圆角等）决定如何进行合成。</li>
<li>将最终合成的结果发送给显示硬件。</li>
</ul>
<h4 data-id="heading-8"><code>SurfaceFlinger</code> 的核心地位</h4>
<p>无论采用哪种渲染技术栈（<code>Native View</code>, <code>Compose</code>, <code>Flutter</code>, <code>WebView</code>, <code>GLSurfaceView</code>），它们最终都必须通过各自的 <code>Surface</code> 接口向 <code>BufferQueue</code> 提交渲染完成的图形缓冲区。<br/>
因此，可以确定，在 Android 平台上，所有五种技术路线的渲染结果，都会以独立的或应用主 Layer 的形式，统一由 <code>SurfaceFlinger</code> 来接收和处理，这是它们最终得以在屏幕上显示的必经之路。</p>
<h4 data-id="heading-9">硬件合成器 (HWC) 优化</h4>
<p>为了最大化性能和降低功耗，<code>SurfaceFlinger</code> 倾向于将合成任务卸载给硬件合成器（<code>Hardware Composer, HWC</code>）。<br/>
<code>HWC</code> 是一个 SoC 厂商实现的 HAL（硬件抽象层）模块，能够直接处理 Layer 的合成，通常以零拷贝的方式操作缓冲区。这极大地提高了效率。<br/>
只有当 <code>Layer</code> 具有复杂的混合、变换或特效，<code>HWC</code> 无法直接处理时，<code>SF</code> 才会退回到使用 GPU 进行合成（GPU Compositing），这会增加系统的渲染开销。</p>
<h3 data-id="heading-10"><strong>1.3. 绘制指令模式对比：即时与保留</strong></h3>
<p>UI 框架在生成绘图指令时，主要遵循两种模式：保留模式 (Retained Mode) 和即时模式 (Immediate Mode)。</p>
<h4 data-id="heading-11">保留模式 (Retained Mode)</h4>
<p>在这种模式下，UI 元素的结构和属性被存储为一个场景图或对象层级结构（在 Android <code>Native/Compose</code> 中称为 <code>RenderNode</code> 或 <code>Display List</code>）。当 UI 状态发生变化时，系统只需更新场景图中发生变化的部分，而不是重新执行所有绘图指令。这种模式非常适合动态或频繁变化的 UI，因为它允许更灵活和高效的更新 。Android Native Views 和 Jetpack Compose 都是基于保留模式的实现。</p>
<h4 data-id="heading-12">即时模式 (Immediate Mode)</h4>
<p>在这种模式下，每一次帧更新，应用程序都需要重新发送完整的绘图指令序列。系统不存储 UI 状态图。即时模式要求开发者对底层的图形 API（如 OpenGL ES 或 Skia Canvas）有更直接的控制。它在静态 UI 中可能资源占用较少，但在动态 UI 中可能性能较差，除非底层引擎进行了高效优化（如 Flutter 的 Skia）。<br/>
GLSurfaceView 和 Flutter 的核心渲染流程属于即时模式。</p>
<p><strong>绘制模式 (Immediate vs. Retained) 特性对比</strong></p>






























<table><thead><tr><th align="left">特性</th><th align="left">保留模式 (Retained Mode)</th><th align="left">即时模式 (Immediate Mode)</th></tr></thead><tbody><tr><td align="left"><strong>核心机制</strong></td><td align="left">场景图/显示列表 (RenderNode) 存储状态</td><td align="left">立即执行绘图指令，不存储状态</td></tr><tr><td align="left"><strong>更新效率</strong></td><td align="left">高效 (仅重绘变动部分)</td><td align="left">依赖框架/引擎 (Skia 优化了底层效率)</td></tr><tr><td align="left"><strong>线程隔离</strong></td><td align="left">RenderThread 机制提供原生的 CPU/GPU 隔离</td><td align="left">需用户/引擎自行实现专用 Raster/GLES 线程</td></tr><tr><td align="left"><strong>代表技术</strong></td><td align="left">Android Native View, Jetpack Compose</td><td align="left">Flutter (Skia), GLSurfaceView</td></tr></tbody></table>
<h2 data-id="heading-13"><strong>2. 保留模式下的原生 UI 渲染管线：Native View 与 Compose</strong></h2>
<p>Android 原生 UI 框架（无论是基于 View 还是 Compose）都依赖于 AOSP 的保留模式渲染架构，核心在于 <code>RenderThread</code>。</p>
<h3 data-id="heading-14"><strong>2.1. Android 原生 View 渲染流程：Record, Execute 与 RenderThread</strong></h3>
<p>当 <code>View</code> 层次结构需要更新时，渲染流程在应用进程内分两个主要阶段进行：</p>
<h4 data-id="heading-15">1. UI 线程：记录 (<code>Record</code>) 阶段</h4>
<p>UI 线程（或主线程）负责所有的业务逻辑、布局计算（Measure 和 Layout），以及绘图指令的记录。在硬件加速开启的前提下，<code>View#draw(Canvas)</code>的调用不会直接执行 GPU 渲染，而是将绘图操作记录到关联的 <code>RenderNode</code>（即 <code>Display List</code>）中。</p>
<ul>
<li><strong>性能风险：</strong> 尽管记录 Display List 通常很快，但如果应用代码在此阶段涉及复杂的 CPU 密集型操作，例如绘制到 Bitmap（这会触发 CPU 软件渲染），则会占用 UI 线程时间，可能导致帧率下降（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F476477559" target="_blank" title="https://zhuanlan.zhihu.com/p/476477559" ref="nofollow noopener noreferrer">Jank指标</a>）。</li>
</ul>
<h4 data-id="heading-16">2. RenderThread：执行 (Execute) 阶段</h4>
<p><code>RenderThread</code> 是一个系统管理的新线程，自 Android Lollipop 引入，旨在将 GPU 相关的重型工作负载从 UI 线程分离出来。</p>
<ul>
<li><strong>JANK 隔离：</strong> <code>RenderThread</code> 的核心价值在于，即使 UI 线程被阻塞（例如，因垃圾回收或复杂业务逻辑），它仍能继续执行先前提交的 Display List，从而保持动画、触摸反馈和 <code>Material Design</code> 特效（如涟漪效果）的平滑运行。</li>
<li><strong>执行与优化：</strong> <code>RenderThread</code> 接收 UI 线程提交的 <code>RenderNode</code>，负责对指令进行优化（例如，批处理），将它们翻译成低级的 GPU API 调用（GLES 或 Vulkan），并最终通过 <code>eglSwapBuffers()</code> 提交到 <code>Surface</code> 的 <code>BufferQueue</code> 中。</li>
<li><strong>潜在的性能陷阱：</strong> 某些 <code>Canvas</code> 操作，如绘制非常大的或复杂的 <code>Path</code> 对象，在 UI 线程上的记录成本很低，但在 <code>RenderThread</code> 执行时可能触发昂贵的 CPU 或 GPU 计算，导致 <code>RenderThread</code> 成为新的瓶颈。系统分析工具（如 Systrace）常用于识别这类问题。</li>
</ul>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 专用 <code>RenderThread</code>。</li>
<li><strong>驱动机制：</strong> <strong>强依赖 VSync 信号。</strong> 当应用需要渲染时，系统会向 <code>Choreographer</code> 注册一个回调，等待 <code>VSync</code> 信号的到来。</li>
<li><strong>频率控制：</strong> 渲染频率主要由系统 <code>VSync 频率</code>（通常 60Hz 或 120Hz）控制。应用通过 <code>View.invalidate()</code> 标记 <code>View</code> 为脏，但实际的绘制执行始终与 <code>VSync</code> 同步，以避免画面撕裂。</li>
</ul>
<h4 data-id="heading-17">原生 View 渲染流程</h4>
<p>时序图：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/798ae6ffa43b42c194fe7292b8475ea0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=0lmRV1St0QkWybG1WhxQYVmJK%2BA%3D" alt="image.png" loading="lazy"/></p>
<p>该流程描述了 Native View 从输入事件到最终显示的序列：</p>
<ol>
<li><strong>Application UI Thread：</strong> 执行 <code>View</code> 层次结构的 <code>Measure</code> &amp; <code>Layout</code> 阶段，确定所有组件的尺寸和位置。</li>
<li><strong>Application UI Thread：</strong> 执行 <code>Record</code> 阶段，调用 <code>View#draw</code>，将所有绘图操作（如绘制文本、形状）记录到 <code>RenderNode (Display List)</code> 中。</li>
<li><strong>Application UI Thread -&gt; RenderThread：</strong> 分发记录好的 <code>RenderNode</code> 数据到独立的 <strong>RenderThread</strong>。</li>
<li><strong>RenderThread：</strong> 优化 <code>RenderNode</code> 中的指令，将其转化为低级 GPU 调用 (GLES 或 Vulkan)。</li>
<li><strong>RenderThread -&gt; GPU：</strong> 发出 <strong>光栅化指令</strong>，在 <code>VSync</code> 信号驱动下，在应用独占的缓冲区中绘制 View 的像素内容。<strong>此步骤在应用进程内完成所有 UI 元素的绘制。</strong></li>
<li><strong>RenderThread -&gt; SurfaceFlinger：</strong> 通过 <code>EGLSurface</code> 调用 <code>eglSwapBuffers()</code>，将绘制完成的缓冲区提交给系统合成器<code>SF</code>。</li>
<li><strong>SurfaceFlinger/HWC：</strong> 接收应用缓冲区，进行 <strong>系统级合成 (Composition)</strong> 和最终显示。<code>HWC</code> 确定最佳合成路径，将此 <code>Layer</code> 与状态栏、导航栏、其他应用窗口等所有 <code>Layer</code> 合并，并最终显示到屏幕上。</li>
</ol>
<h3 data-id="heading-18"><strong>2.2. Jetpack Compose 渲染管线：声明式与 GraphicsLayer 优化</strong></h3>
<p><code>Jetpack Compose</code> 采用了声明式 UI 模型，其渲染管线遵循 <code>Composition</code>（节点创建）、<code>Measure</code>、<code>Layout</code>，最终到达 <code>Drawing</code> 阶段。尽管其编程范式发生了根本性变化，但在 Android 平台上，<code>Compose</code> 最终仍复用 <code>Native View</code> 的底层硬件加速机制。</p>
<h4 data-id="heading-19"><code>Draw</code> 阶段与 <code>Canvas</code> 的关联</h4>
<p><code>Compose</code> 框架在 <code>Draw</code> 阶段，底层仍然依赖于 <code>View</code> 系统的 <code>Canvas API</code> 进行实际的像素操作 。<br/>
然而，<code>Compose</code> 通过 <code>DrawScope</code> 抽象简化了传统的 <code>View</code> 绘图模型，例如替开发者管理复杂的 <code>Paint</code> 对象配置，确保性能优化。<br/>
<strong>GraphicsLayer 与 RenderNode 的复用</strong><br/>
<code>Compose</code>通过 <code>Modifier.graphicsLayer</code> 引入了与 <code>Native View</code> 中 <code>RenderNode</code> 相似的概念 。<br/>
使用 <code>graphicsLayer</code> 意味着 <code>Composable</code> 组件的绘图指令会被捕获并缓存到一个 <code>Layer</code> 中 。</p>
<ul>
<li><strong>性能收益：</strong> 这种缓存机制允许渲染管线高效地重发这些绘图指令，尤其适用于频繁的几何变换、透明度变化或缩放动画。一旦指令被捕获，RenderThread 可以在不依赖 UI 线程重新执行 Composable 代码的情况下，重复执行这些已缓存的指令。</li>
</ul>
<h4 data-id="heading-20">Offscreen Rasterization (离屏光栅化)</h4>
<p><code>graphicsLayer</code> 的进一步优化是离屏光栅化，也被称为纹理缓存。<br/>
在这种情况下，<code>RenderThread</code> 会执行 <code>RenderNode</code> 中的指令，并将结果捕获到一个离屏 GPU 纹理中。<br/>
在后续的帧中，<code>RenderThread</code> 只需要发送一个简单的指令：“绘制这个纹理”，这极大减少了 CPU 和 GPU 的重复计算，尤其对于复杂的、不常变化的组件（如 <code>LazyList</code> 中滚动的条目）的性能优化至关重要。</p>
<h4 data-id="heading-21">渲染管线性能瓶颈聚焦</h4>
<p>原生 View 和 Compose 共享 RenderThread 执行管线，这表明它们的 GPU 性能优化途径是相似的。它们的主要性能差异体现在 UI 线程的记录阶段：</p>
<ul>
<li>原生 View 的性能瓶颈通常集中在传统的 View 层次结构遍历和 Measure/Layout 效率上。</li>
<li>Compose 的性能瓶颈则集中在 Composition/Recomposition 逻辑的效率和状态管理上。<br/>
即使 RenderThread 隔离了 GPU 执行，如果 Composition 或 Layout 阶段耗时超过每帧预算（例如 16ms），UI 线程的阻塞仍会导致新的 RenderNode 无法及时提交，从而引发 JANK。因此，无论是 Native 还是 Compose，优化策略的重点都必须放在减少 UI 线程的负载上。</li>
</ul>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 共享 AOSP 的 RenderThread。</li>
<li><strong>驱动机制：</strong> <strong>强依赖 VSync 信号。</strong> Compose 状态（State）变化触发 UI 线程的重组和布局计算。RenderThread 的光栅化执行（绘制）同样严格对齐 VSync 脉冲。</li>
<li><strong>频率控制：</strong> 无法直接控制。频率由系统 VSync 确定。Compose 仅在需要时（状态改变）才触发新的帧提交。</li>
</ul>
<h4 data-id="heading-22">Jetpack Compose 渲染流程</h4>
<p>时序图：<br/>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb044636c992468d8eb5196c5104a544~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=Gsih9xpjFxOn3PZdMsAjsDkgJmk%3D" alt="image.png" loading="lazy"/></p>
<p>该流程描述了 Compose 从状态变化到渲染的序列：</p>
<ol>
<li><strong>UI Thread (Composition/Layout)：</strong> 执行 <strong>Composition</strong> 阶段，根据状态（State）变化确定需要创建、更新或跳过哪些 UI 节点。</li>
<li><strong>UI Thread (Composition/Layout)：</strong> 执行 <strong>Measure &amp; Layout</strong> 阶段，确定所有 Composable 组件的最终尺寸和屏幕位置。</li>
<li><strong>UI Thread (Composition/Layout)：</strong> 执行 <strong>Draw Phase</strong>，捕获绘图操作，并将其存储在 GraphicsLayer 中。</li>
<li><strong>UI Thread -&gt; RenderThread：</strong> 将封装了绘图指令的 RenderNode/GraphicsLayer 提交给 RenderThread。</li>
<li><strong>RenderThread -&gt; GPU：</strong> <strong>RenderThread</strong> 在 VSync 驱动下，在 GPU 上执行光栅化指令，包括处理离屏纹理缓存等优化，在应用 Surface 缓冲区中绘制 Composable UI 像素。</li>
<li><strong>RenderThread -&gt; SurfaceFlinger：</strong> 调用缓冲区交换函数，提交渲染完成的帧缓冲区。</li>
<li><strong>SurfaceFlinger：</strong> 接收缓冲区，执行系统级合成，并最终交给 HWC 进行显示。</li>
</ol>
<h2 data-id="heading-23"><strong>3. 即时模式与专用渲染管线：Flutter 与 GLSurfaceView</strong></h2>
<p>与依赖 <code>AOSP</code> <code>RenderThread</code> 的 <code>Native/Compose</code> 不同，<code>Flutter</code> 和 <code>GLSurfaceView</code> 使用即时模式渲染，并创建了独立于 <code>AOSP</code> 图形栈的专用渲染环境。</p>
<h3 data-id="heading-24"><strong>3.1. Flutter View 渲染管线</strong></h3>
<p><code>Flutter</code> 在 Android 上运行于一个名为 <code>Flutter Embedder</code> 的 C++ 组件中，并管理着一组专用的线程：平台线程（负责与宿主 OS 通信）、UI 线程（运行 Dart 逻辑和 Widget 树构建），以及关键的 Raster Thread（栅格化线程）。</p>
<h4 data-id="heading-25">双线程模型</h4>
<p><code>Flutter</code> 的高性能渲染基于其严格隔离的双线程模型：</p>
<ol>
<li><strong>Dart UI Thread：</strong> 负责处理应用逻辑、Widget 构建、Element Tree 维护、Render Tree 创建以及布局计算。</li>
<li><strong>Flutter Raster Thread (也称 GPU Thread)：</strong> 这是一个专用的 C++ 线程，负责将 Dart UI Thread 生成的 Layer Tree 传递给 Flutter 引擎。Flutter 引擎在此线程上将高层级绘图指令翻译成低层级的 GPU/CPU 指令，执行光栅化，并利用 GPU 加速，确保高效渲染。</li>
</ol>
<blockquote>
<p>Flutter 的 UI 线程负责构建高层次的 Layer Tree。然后，Raster Thread 专门负责消耗这个 Layer Tree，并使用其集成的 Skia 或更新的 Impeller 渲染引擎生成低级图形命令。</p>
</blockquote>
<blockquote>
<p>Impeller 旨在通过提前编译着色器等方式，进一步优化移动 GPU 性能</p>
</blockquote>
<h4 data-id="heading-26">即时模式与底层优化</h4>
<p><code>Flutter Android Embedder</code> 负责与 Android 系统进行底层交互。它为 Flutter 的输出获取一个专用的 Android <code>Surface</code>，为 <code>Raster Thread</code> 设置必要的 <code>EGL</code> 或 <code>Vulkan</code> 上下文，并处理低级的缓冲区提交逻辑。</p>
<p><code>Skia/Impeller</code> 最终将整个应用 UI 渲染到一个 <code>Surface</code> 中，作为 Android 系统的一个独立 <code>Layer</code> 提交给 <code>SurfaceFlinger</code>。</p>
<p>虽然 <code>Flutter</code> 在 <code>Dart</code> 侧的 <code>Widget</code> 构建和 <code>Render Tree</code> 创建可以被视为每帧都可能重新发生的即时模式行为，但 <code>Skia/Impeller</code> 在底层对这些指令进行高度优化、批处理和硬件加速。</p>
<h4 data-id="heading-27">渲染架构的独立性</h4>
<p>Flutter <code>Raster Thread</code> 的存在绕过了 AOSP 的 <code>RenderThread</code> 机制。这赋予了 <code>Flutter Engine</code> 对渲染管线的完全控制权和跨平台性能的确定性。</p>
<p>这种架构决策避免了与原生 View 系统的复杂交互，但代价是在集成原生组件时需要引入额外的桥接层和合成模式，如 <code>Platform Views</code>。</p>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 独立于 AOSP 的 <code>Raster Thread</code> (C++ 实现)。</li>
<li><strong>驱动机制：</strong> <code>Flutter Engine</code> 内部具备自己的调度器，但它会监听和对齐<strong>平台 VSync 信号</strong>，以确保渲染帧与显示器的刷新率同步（目标 60 FPS 或 120 FPS）。渲染工作在 UI Thread 和 <code>Raster Thread</code> 之间分工。</li>
<li><strong>频率控制：</strong> 由 <code>Skia/Impeller</code> 控制，同步于系统 <code>VSync</code> 频率。</li>
</ul>
<h4 data-id="heading-28"><strong>Flutter Platform Views 的集成方案深度对比</strong></h4>
<p>Flutter Engine 作为一个完全独立的渲染引擎，当需要嵌入原生 Android View（如 MapView 或 WebView）时，必须采用特殊的机制来桥接 Flutter 的 Raster Thread 与 Android 的 Surface 机制。</p>
<p>Flutter 提供了两种核心渲染机制，选择哪一种取决于对原生组件保真度、Flutter 动画性能以及是否需要 Flutter 侧变换的需求。</p>























<table><thead><tr><th align="left">模式</th><th align="left">适用场景/优势</th><th align="left">限制/劣势</th><th align="left">选择判断</th></tr></thead><tbody><tr><td align="left"><strong>Hybrid Composition (HC)</strong></td><td align="left"><strong>原生视图保真度和性能至上：</strong> 适用于对输入处理、本地视图生命周期和渲染保真度要求极高（接近原生体验）的组件。它提供<strong>最佳的 Android View 性能和保真度</strong></td><td align="left"><strong>牺牲 Flutter 性能：</strong> 由于 SurfaceFlinger 需要进行系统级合成，Flutter UI 的 FPS 会有所降低 <strong>不支持 Flutter 侧变换：</strong> 无法对嵌入的原生视图应用所有 Flutter Widget 的几何变换、透明度或裁剪效果。</td><td align="left"><strong>原生 View 包含 SurfaceView</strong> (如视频、相机)，且原生视图性能优先于 Flutter 动画流畅度。</td></tr><tr><td align="left"><strong>Texture Layer (TLHC)</strong></td><td align="left"><strong>Flutter 动画和变换能力至上：</strong> 适用于需要对嵌入的 View 进行旋转、缩放、裁剪或应用透明度效果的场景。它提供<strong>最佳的 Flutter 渲染性能</strong>。</td><td align="left"><strong>原生视图滚动可能出现卡顿 (Jank)：</strong> 由于将原生 View 渲染到纹理需要额外的处理延迟，快速滚动（如内嵌的 WebView）可能出现卡顿 [17]。SurfaceView 组件在此模式下表现不佳。</td><td align="left"><strong>需要对原生 View 应用 Flutter 侧变换</strong>（如 3D 旋转、裁剪），且原生 View 内容更新频率不高或不需要使用 SurfaceView。</td></tr></tbody></table>
<p><strong>默认机制与自动选择</strong></p>
<ul>
<li><strong>Texture Layer Hybrid Composition (TLHC)</strong> 是目前 Flutter 框架中推荐且默认的 Platform View 渲染模式。</li>
<li><strong>回退机制：</strong> 当原生视图树中包含 SurfaceView 组件时（例如视频播放器、相机预览等），TLHC 模式会遇到困难，系统可能会自动回退到 Hybrid Composition (HC) 模式。</li>
</ul>
<h4 data-id="heading-29">Flutter 渲染架构 (流程描述)</h4>
<p>时序图：<br/>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd5ef9e3e3cd4e94a7c95cb5a3be3614~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=FMKlOo8nbpJ%2BzpZOHwNlhvYu%2F9Y%3D" alt="image.png" loading="lazy"/></p>
<p>该流程描述了 Flutter 引擎的渲染序列：</p>
<ol>
<li><strong>Dart UI Thread (Engine)：</strong> 执行 Widget Tree 的构建，转换为 Element Tree。</li>
<li><strong>Dart UI Thread (Engine)：</strong> 在 VSync 信号开始时，执行 Layout 阶段，计算 Render Tree，最终生成包含 Skia/Impeller 绘图指令的 Layer Tree。</li>
<li><strong>Dart UI Thread -&gt; Raster Thread (Skia/GPU Thread)：</strong> 将 Layer Tree 传输到独立的 Raster Thread。</li>
<li><strong>Raster Thread (Skia/GPU Thread) -&gt; GPU：</strong> <strong>Skia 引擎</strong> 在其专用线程上执行 <strong>光栅化</strong>，将 Layer Tree 指令转换为低级 GPU 调用，在 Flutter 的 Surface 缓冲区中绘制整个 UI 像素内容。</li>
<li><strong>Raster Thread -&gt; SurfaceFlinger (System)：</strong> 提交应用 Surface 缓冲区，作为单一 Layer 提交给系统。</li>
<li><strong>SurfaceFlinger (System)：</strong> 接收 Flutter 的 Layer，进行系统级合成，并最终交给 HWC 显示。</li>
</ol>
<h3 data-id="heading-30"><strong>3.2. <code>GLSurfaceView</code>：面向 <code>GLES</code> 的低层级控制</strong></h3>
<p><code>GLSurfaceView</code> 为需要进行高性能、自定义 GLES 渲染的应用提供了一个直接的接口，如游戏或视频处理。</p>
<h4 data-id="heading-31">EGL 环境与线程要求</h4>
<p><code>GLSurfaceView</code> 的主要功能是管理 <code>GLES</code> 渲染所需的 <code>EGL</code> 环境。这包括在生命周期回调中创建 <code>EGLContext</code> 和 <code>EGLSurface</code> 实例。</p>
<ul>
<li><strong>专用 GLES 线程：</strong> <code>GLES</code> 规范要求所有的绘图操作必须在特定的 <code>GLES</code> 线程上执行，绝对不能在 UI 线程上执行。<code>GLSurfaceView</code> 内部创建了一个专用的渲染线程来满足这一要求，确保了重型 GPU 负载与应用主线程的彻底隔离。</li>
</ul>
<p>即时模式与缓冲区控制<br/>
开发者在 <code>GLES</code> 线程中执行即时模式的绘图指令。当一帧渲染完成后，必须通过调用 <code>eglSwapBuffers()</code> 来明确地提交当前缓冲区。这个方法名源于传统的双缓冲机制，它将渲染好的后台缓冲区提交到前台供消费者使用。</p>
<ul>
<li><strong>帧率控制：</strong> 默认情况下，<code>GLSurfaceView</code> 可能以显示器的刷新率（例如 60fps）连续渲染。然而，通过设置 <code>RENDERMODE_WHEN_DIRTY</code>，开发者可以只在 UI 逻辑或输入事件明确要求时才请求渲染 (<code>requestRender()</code>)，这对于非实时动画或静态场景的电源和性能优化至关重要。</li>
</ul>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 专用 Dedicated GLES Thread。</li>
<li><strong>驱动机制：</strong> <strong>可控模式。</strong>
<ul>
<li><strong>RENDERMODE_CONTINUOUSLY：</strong> 渲染循环持续运行，默认与 <code>VSync</code> 对齐，尝试达到最高刷新率。</li>
<li><strong>RENDERMODE_WHEN_DIRTY：</strong> 渲染循环仅在应用明确调用 requestRender() 时执行一帧。</li>
</ul>
</li>
<li><strong>频率控制：</strong> <strong>开发者完全控制。</strong> 可以选择连续渲染（高频/Vsync 约束）或事件驱动渲染（低频/按需）。</li>
</ul>
<h4 data-id="heading-32">GLSurfaceView 渲染流程</h4>
<p>时序图：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e20a6d4865e74adc97d21e2272733167~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=uflmgBv89AJ4rNSbyG1L0qB%2BBio%3D" alt="image.png" loading="lazy"/></p>
<p>该流程描述了 <code>GLSurfaceView</code> 的渲染序列：</p>
<ol>
<li><strong>Application UI Thread -&gt; Dedicated GLES Thread：</strong> UI 线程在生命周期回调中，请求 <code>GLES</code> 线程设置 <code>EGL</code> 环境，创建 <code>EGLContext</code> 和 <code>EGLSurface</code> 实例。</li>
<li><strong>Application UI Thread -&gt; Dedicated GLES Thread：</strong> UI 线程通过事件或动画循环，触发 GLES 线程调用 <code>requestRender()</code> 或保持连续渲染模式。</li>
<li><strong>Dedicated GLES Thread -&gt; GPU：</strong> 执行用户定义的 OpenGL ES 绘图命令（即时模式），直接利用 GPU <strong>光栅化</strong> 3D/2D 内容到当前的 EGL 缓冲区。<strong>这是开发者对 GPU 绘图的最直接控制</strong>。</li>
<li><strong>Dedicated GLES Thread -&gt; BufferQueue (EGLSurface)：</strong> 调用 <code>eglSwapBuffers()</code>，将刚刚绘制的缓冲区提交给 <code>BufferQueue</code> 消费者。</li>
<li><strong>BufferQueue (EGLSurface) -&gt; SurfaceFlinger (System)：</strong> 缓冲区作为独立 <code>Layer</code> 提交给系统合成器。</li>
<li><strong>SurfaceFlinger (System)：</strong> 将 <code>GLSurfaceView</code> 的独立 Layer 与其他系统 UI 合成，并通过 HWC 显示。</li>
</ol>
<h2 data-id="heading-33"><strong>4. 混合与跨进程渲染：<code>WebView</code> 与 Platform Views</strong></h2>
<p>复杂的 UI 场景往往涉及不同渲染技术的混合，这要求系统合成器 <code>SurfaceFlinger</code> 介入处理多个独立渲染源的 <code>Layer</code> 合成。</p>
<h3 data-id="heading-34"><strong>4.1. 现代 <code>WebView</code> 渲染机制：Out-of-Process Rasterization (OOPR)</strong></h3>
<p><code>WebView</code> 承载了复杂的 <code>Web</code> 渲染引擎（<code>Chromium</code>）。为了增强安全性和稳定性，现代 Android 系统（API 30 及以上）默认使用进程外光栅化 (<code>OOPR</code>) 模式。<br/>
在 Android API 30 (Android R) 之前，<code>WebView</code> 的渲染模式取决于具体的 <code>Android</code> 版本和设备的内存条件：</p>
<ul>
<li>进程内渲染 (In-Process Renderer): 在 Android Lollipop (API 21) 到 Android Nougat (API 25) 期间，进程内渲染是默认模式。在这种模式下，<code>Chromium</code> 渲染引擎（包括布局和光栅化）与主机应用运行在同一个进程内，共享资源和内存空间。这导致 Web 内容的复杂操作可能直接阻塞应用的主 UI 线程。</li>
<li>进程外渲染的过渡 (Oreo - Q): 从 Android Oreo (API 26) 到 Android Q (API 29)，系统通常会启用进程外渲染，但对于低内存设备，可能会回退到进程内渲染模式。</li>
<li><code>OOPR</code> 默认化 (Android R/API 30+): 由于 Android R 对内存管理的优化，WebView 在 Android R 及以上版本中总是默认使用进程外光栅化 (<code>OOPR</code>) 模式，确保了隔离性。</li>
</ul>
<h4 data-id="heading-35">进程隔离与 Surface IPC</h4>
<p>在 OOPR 模式下，实际的 Web 内容渲染工作发生在宿主应用进程之外的 Chrome Render Process 中。</p>
<ul>
<li><strong>数据流：</strong> <code>Chrome</code> 渲染进程将其渲染结果绘制到一个专用的 Surface 中。这个 <code>Surface</code> 对象通过 <code>Android</code> 的 <code>Binder IPC</code> 机制被传递和管理。渲染进程充当 <code>Surface</code> 的生产者，负责将渲染好的 <code>GraphicBuffer</code> (或 <code>AHardwareBuffer</code>) 提交给 <code>SurfaceFlinger</code>。</li>
<li><strong>宿主应用职责：</strong> 宿主应用的主进程只需要管理 <code>WebView</code> 的生命周期、输入事件转发以及 <code>Surface</code> 的分配，渲染工作负载被完全卸载到远程进程，实现了极高的隔离性。</li>
</ul>
<h4 data-id="heading-36">WebView 的绘制模式与崩溃隔离</h4>
<p><strong>绘制模式：</strong> 尽管 <code>WebView</code> 是作为 Android Native View 层次结构的一部分被托管，其内部的 Chromium 渲染引擎遵循 <code>保留模式 (Retained Mode)</code> 的原则。<br/>
Web 平台的 文档对象模型 (DOM) 充当了其保留状态的模型。浏览器维护 DOM 的状态，并可以在不需要 JavaScript 持续重新发送所有绘图指令的情况下进行渲染，这与 <code>Android View</code> 使用 <code>RenderNode</code> 的思路一致 。</p>
<p><strong>崩溃隔离：</strong> <code>WebView</code> 的进程外光栅化（<code>OOPR</code>）旨在通过将渲染工作负载转移到沙箱隔离的进程中 ，从而提高稳定性和安全性。<br/>
然而，如果发生严重的渲染故障，例如未捕获的 <code>JavaScript</code> 异常导致 <code>Chrome Render Process</code> 崩溃，这仍然可能导致主机应用程序受到影响。<br/>
为了实现进程级别的鲁棒性，Android 平台在 API 26 及更高版本中提供了 <code>WebViewClient#onRenderProcessGone</code> 回调方法。通过重写此方法，主机应用可以在渲染进程崩溃时被通知，从而允许应用进行恢复操作，例如重新加载 WebView 或显示错误信息，防止整个应用程序崩溃。</p>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 隔离的 <code>Chrome Render Process</code> 内部的渲染线程。</li>
<li><strong>驱动机制：</strong> <strong>内部 VSync 对齐。</strong> 渲染进程的渲染循环独立运行，但会与系统 VSync 信号对齐。主机应用通过滚动、页面加载或 JavaScript 动画等触发更新，渲染进程负责高效地将新内容光栅化。</li>
<li><strong>频率控制：</strong> 由 Chromium 引擎内部控制。主机应用无法直接调节其帧率。</li>
</ul>
<h4 data-id="heading-37">SurfaceFlinger 的参与</h4>
<p>由于 <code>WebView</code> 的内容是作为独立进程的输出，它必定是一个独立的 Layer 提交给 SurfaceFlinger。</p>
<ul>
<li><strong>性能影响：</strong> 尽管 <code>OOPR</code> 提供了卓越的进程隔离，但它强制 <code>WebView</code> 成为一个独立 <code>Layer</code>，无法内嵌到应用主界面的 <code>RenderNode</code> 中进行优化。这意味着 <code>WebView</code> 内容的任何更新都必须经过 SurfaceFlinger 的系统级合成步骤。这增加了系统合成的开销，尤其是在高频更新的场景下。</li>
</ul>
<h4 data-id="heading-38">WebView OOPR 渲染流程</h4>
<p>时序图：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30b0ed54774140a29a80c515f029b1c7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=OMYido96TIS69haAc46aTK6tGMs%3D" alt="image.png" loading="lazy"/></p>
<p><code>WebView</code> <code>OOPR</code> 渲染架构 (流程描述) 该流程描述了 WebView 跨进程渲染的组件交互：</p>
<ol>
<li>App Host Process (WVHost)： 调用 WebView.loadUrl() 或 loadData()，触发 Web 内容加载。</li>
<li>App Host Process (WVHost) -&gt; Chrome Render Process (WebEngine)： Host 进程通过 Binder IPC 机制向 Chrome 渲染进程分发加载请求、生命周期控制和输入事件。</li>
<li>Chrome Render Process (WebEngine)： Web 引擎（Blink）在远程进程中执行页面解析、布局计算，并构建 Web Layer Tree。</li>
<li>Chrome Render Process (WebEngine) -&gt; GPU： 渲染进程的 GPU 线程执行 光栅化，将 Web 内容绘制到专用的 AHardwareBuffer 中。渲染帧率内部与 VSync 对齐。</li>
<li>Chrome Render Process (WebEngine) -&gt; Android Graphics Subsystem (SF/BQ): Chrome 进程通过 Surface 生产者接口，将渲染好的缓冲区提交到 BufferQueue。</li>
<li>Android Graphics Subsystem (SF/BQ) -&gt; SurfaceFlinger (System)： SurfaceFlinger 接收 WebView 的独立 Layer。</li>
<li>SurfaceFlinger (System)： 执行系统级合成，将 WebView Layer 放置在正确的 Z 轴顺序和位置上，并最终显示。</li>
</ol>
<h2 data-id="heading-39">5. <strong>总结与建议</strong></h2>








































<table><thead><tr><th align="left">技术栈</th><th align="left">系统集成度</th><th align="left">线程隔离粒度</th><th align="left">关键性能关注点</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left"><strong>Native/Compose</strong></td><td align="left">高 (共享 RenderThread)</td><td align="left">CPU/GPU 隔离 (RT)</td><td align="left">优化 UI 线程的记录/重组负载。</td><td align="left">标准 UI 界面，需要高度原生平台特性。</td></tr><tr><td align="left"><strong>Flutter</strong></td><td align="left">低 (独立引擎)</td><td align="left">彻底隔离 (Raster Thread)</td><td align="left">跨平台一致性，减少 Platform View 的合成开销。</td><td align="left">高性能、高自定义度 UI，跨平台项目。</td></tr><tr><td align="left"><strong>GLSurfaceView</strong></td><td align="left">中 (独立 Surface)</td><td align="left">彻底隔离 (GLES Thread)</td><td align="left">自主控制 eglSwapBuffers 频率。</td><td align="left">游戏引擎，实时视频流，自定义 3D 渲染。</td></tr><tr><td align="left"><strong>WebView</strong></td><td align="left">中 (跨进程 Surface)</td><td align="left">彻底隔离 (OOPR)</td><td align="left">跨进程通信延迟和 SurfaceFlinger 的 Layer 合成开销。</td><td align="left">嵌入复杂 HTML/JS 内容。</td></tr></tbody></table>
<p><strong>原生 UI 的瓶颈转移：</strong> 对于 Native View 和 Compose，AOSP 已经通过 RenderThread 解决了 GPU 执行阻塞 UI 线程的问题。然而，性能优化的重点已从 GPU 转移到 UI 线程的 <strong>记录/布局/重组</strong> 阶段。</p>
<p><strong>独立 Surface 的开销：</strong> 无论采用 Flutter、WebView 还是 GLSurfaceView，当它们使用独立的 Surface 对象时，都不可避免地成为 SurfaceFlinger 的一个独立 Layer。虽然这提供了极佳的线程隔离，但也意味着每一次更新都必须经过系统合成器的处理。对于需要大量 Layer 合成或复杂混合的场景，这可能导致比 HWC 零拷贝合成更高的系统资源消耗。</p>
<p><strong>高性能图形的选择：</strong> 对于需要实时（60fps 或 120fps）更新和完全控制图形管线的场景，GLSurfaceView 或 Flutter Engine 是最佳选择。它们通过专用的渲染线程实现了高确定性性能，将光栅化工作负载从 AOSP 的主渲染路径中完全解耦。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java 中 UnaryOperator 接口与 Lambda 表达式的应用示例]]></title>    <link>https://juejin.cn/post/7572459757107724342</link>    <guid>https://juejin.cn/post/7572459757107724342</guid>    <pubDate>2025-11-15T19:21:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572459757107724342" data-draft-id="7572481101710278710" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java 中 UnaryOperator 接口与 Lambda 表达式的应用示例"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-11-15T19:21:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Dcs"/> <meta itemprop="url" content="https://juejin.cn/user/3679404422861902"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java 中 UnaryOperator 接口与 Lambda 表达式的应用示例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3679404422861902/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Dcs
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T19:21:15.000Z" title="Sat Nov 15 2025 19:21:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，这里是<strong>架构资源栈</strong>！点击上方关注，添加“<strong>星标</strong>”，一起学习大厂前沿架构！</p>
<p>关注、发送<code>C1</code>即可获取JetBrains全家桶激活工具和码！</p>
<hr/>
<p>在 Java 8 引入 Lambda 表达式的过程中，开发者面临了许多新的接口，其中不乏一些看起来颇为学术、难以理解的名称。<strong>UnaryOperator</strong> 接口就是其中之一，但其实它的用途和实现非常简单。</p>
<h3 data-id="heading-0"><strong>UnaryOperator 的功能</strong></h3>
<p><strong>UnaryOperator</strong> 接口的功能就是接收一个对象，处理它后返回相同类型的对象。这个“unary”特性意味着输入和输出的对象类型是相同的。</p>
<p>从技术角度看，<strong>UnaryOperator</strong> 接口继承了 <strong>Function</strong> 接口，并且定义了一个名为 <strong>apply</strong> 的方法。</p>
<pre><code class="hljs language-java" lang="java">java.util.function.UnaryOperator
<span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UnaryOperator</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&lt;T, T&gt; {
    T <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d097d6e6669f4bb18fab03c2cf0e8b8d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGNz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763839275&amp;x-signature=o%2FmS%2BTD3RyuHY%2FPqILCHUprgWVs%3D" alt="image" loading="lazy"/></p>
<p>比如，你可能想从一个对一个字符串做特殊处理后返回新的字符串。这正是 <strong>UnaryOperator</strong> 的应用场景——输入和输出都是字符串。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee962e4a8162472282a1f590454d9889~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGNz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763839275&amp;x-signature=1psbfMxnAYBytTYGDR85E1LAyWk%3D" alt="image" loading="lazy"/></p>
<h3 data-id="heading-1"><strong>UnaryOperator 实现示例</strong></h3>
<p>首先来看一个传统的实现方式，我们创建一个类 <code>UnaryOperatorExample</code> 来实现 <strong>UnaryOperator</strong> 接口，并提供 <code>apply</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.xiaod.lambda;


<span class="hljs-keyword">import</span> java.util.function.UnaryOperator;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryOperatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UnaryOperator</span>&lt;String&gt; {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-keyword">return</span> name+<span class="hljs-string">"，财运滚滚！"</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryOperatorImplTest</span> {

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUnaryOperatorImpl</span><span class="hljs-params">()</span> {
        <span class="hljs-type">UnaryOperatorImpl</span> <span class="hljs-variable">unaryOperatorImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnaryOperatorImpl</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">"小D"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> unaryOperatorImpl.apply(name);
        <span class="hljs-comment">// 小D，财运滚滚！</span>
        System.out.println(result);
    }

}
</code></pre>
<p>执行上述代码后，控制台将输出字符串 <code>小D，财运滚滚！</code>。</p>
<h3 data-id="heading-2"><strong>UnaryOperator 的 Lambda 表达式示例</strong></h3>
<p>使用 Java 的 Lambda 表达式可以简化代码，不再需要创建完整的类。通过 Lambda 表达式，我们可以直接实现 <strong>UnaryOperator</strong> 接口：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUnaryOperatorImplLambda</span><span class="hljs-params">()</span> {
        UnaryOperator&lt;String&gt; extensionAdder = (String name) -&gt; { <span class="hljs-keyword">return</span> name+<span class="hljs-string">"，财运滚滚！"</span>;} ;
        <span class="hljs-type">String</span> <span class="hljs-variable">newText</span> <span class="hljs-operator">=</span> extensionAdder.apply(<span class="hljs-string">"小D1"</span>);
        <span class="hljs-comment">// 小D1，财运滚滚！</span>
        System.out.println(newText);
    }

</code></pre>
<p>Lambda 表达式使得代码更加简洁和紧凑，能够快速传达功能意图。</p>
<h3 data-id="heading-3"><strong>进一步简化 Lambda 表达式</strong></h3>
<p>你还可以进一步简化 Lambda 表达式，省略类型声明，使得代码更加简洁：</p>
<pre><code class="hljs language-java" lang="java">UnaryOperator&lt;String&gt; extensionAdder = text -&gt; text + <span class="hljs-string">".txt"</span>;
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUnaryOperatorImplLambda1</span><span class="hljs-params">()</span> {
        UnaryOperator&lt;String&gt; extensionAdder = (name)-&gt; name+<span class="hljs-string">"，财运滚滚！"</span> ;
        <span class="hljs-type">String</span> <span class="hljs-variable">newText</span> <span class="hljs-operator">=</span> extensionAdder.apply(<span class="hljs-string">"小D2"</span>);
        <span class="hljs-comment">// 小D2，财运滚滚！</span>
        System.out.println(newText);
    }
</code></pre>
<h3 data-id="heading-4"><strong>Java API 中 UnaryOperator 的应用</strong></h3>
<p><strong>UnaryOperator</strong> 接口在 Java API 中广泛应用。例如，它作为参数传递给 <strong>Stream</strong> 类的 <code>iterate</code> 方法。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">iterate</span><span class="hljs-params">(T seed, UnaryOperator&lt;T&gt; f)</span>;
</code></pre>
<p>这种方法签名可能对初学者来说比较陌生，但通过 <strong>UnaryOperator</strong> 的简单示例，我们可以清晰地理解：它只是接收并返回相同类型的数据。Lambda 表达式的引入，使得 Java 编程更简洁易读，也极大提高了开发效率。</p>
<h3 data-id="heading-5"><strong>总结</strong></h3>
<p>通过这个简单的示例，我们深入了解了 <strong>UnaryOperator</strong> 接口及其在 Java Lambda 表达式中的应用。作为一个功能强大的工具，它简化了 Java 编程的复杂性，使得代码更加简洁和易于维护。</p>
<hr/>
<p><strong>喜欢就奖励一个“👍”和“在看”呗~</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5097f5cd8ee944e4893201a7b6deaf68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGNz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763839275&amp;x-signature=7sqwJIDs3EuLkoLjDfBQIt0ezFo%3D" alt="image" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【底层机制】Ashmem匿名共享内存：原理与应用深度解析]]></title>    <link>https://juejin.cn/post/7573239644156067867</link>    <guid>https://juejin.cn/post/7573239644156067867</guid>    <pubDate>2025-11-17T08:47:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573239644156067867" data-draft-id="7573506713865977907" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【底层机制】Ashmem匿名共享内存：原理与应用深度解析"/> <meta itemprop="keywords" content="Android,面试"/> <meta itemprop="datePublished" content="2025-11-17T08:47:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="沐怡旸"/> <meta itemprop="url" content="https://juejin.cn/user/2875978146656750"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【底层机制】Ashmem匿名共享内存：原理与应用深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2875978146656750/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    沐怡旸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:47:12.000Z" title="Mon Nov 17 2025 08:47:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0"><strong>一、 核心概念：什么是Ashmem？</strong></h4>
<p>Ashmem，全称Android Shared Memory，是Android自定义的一套匿名共享内存机制。它的核心作用是：<strong>在进程间高效地共享一块匿名的内存区域</strong>。</p>
<p>我们可以从它的名字来分解理解：</p>
<ul>
<li><strong>匿名：</strong> 与传统Linux System V IPC的共享内存需要通过一个全局的<code>key</code>来标识不同，Ashmem不需要显式的名字。它通过文件描述符（File Descriptor）来引用，这使得其管理和权限控制更加灵活。</li>
<li><strong>共享：</strong> 多个进程可以将同一块物理内存映射到各自的进程虚拟地址空间，从而实现数据的共享，避免了数据的多次拷贝。</li>
<li><strong>内存：</strong> 它本质上是对一段内存区域的管理。</li>
</ul>
<h4 data-id="heading-1"><strong>二、 为什么需要Ashmem？对比传统方案的优劣</strong></h4>
<p>要理解Ashmem的价值，我们必须先看它解决了什么问题。</p>
<ol>
<li>
<p><strong>对比Linux System V SHM：</strong></p>
<ul>
<li><strong>资源泄露问题：</strong> System V SHM的<code>key</code>是全局的，如果进程崩溃后没有正确释放，这块共享内存会一直存在，导致资源泄露。Ashmem与进程的生命周期绑定更紧密，并且有回收机制。</li>
<li><strong>权限控制弱：</strong> System V SHM的权限控制比较简单。Ashmem基于文件描述符，可以继承Binder的权限模型，进行更精细的管控。</li>
<li><strong>pin / unpin机制：</strong> 这是Ashmem的核心创新，后面会详述。</li>
</ul>
</li>
<li>
<p><strong>对比Binder：</strong></p>
<ul>
<li><strong>Binder限制：</strong> Binder虽然强大，但其设计初衷是为了高频率、小数据量的进程间调用（RPC）。它对于传输数据有大小限制（通常约为1MB），并且数据需要经过多次序列化与反序列化，对于大块数据（如图片、大文件）效率低下。</li>
<li><strong>Ashmem的优势：</strong> Ashmem专为<strong>大块数据</strong>的共享而生。一旦内存映射建立，进程可以直接读写内存，几乎没有大小限制，性能极高。典型的应用场景就是传递Bitmap。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong> Ashmem是Android为弥补Binder在大数据传递上的短板，并改进传统共享内存缺陷而设计的“大块数据高速公路”。</p>
<h4 data-id="heading-2"><strong>三、 核心原理与工作机制</strong></h4>
<p>Ashmem的运作主要涉及三个核心环节：创建、映射和管理。</p>
<p><strong>1. 创建与获取文件描述符</strong></p>
<p>Ashmem的入口是<code>ashmem_create_region</code>函数（Native层）。这个函数会：</p>
<ul>
<li>在内核中开辟一块指定大小的匿名共享内存区域。</li>
<li>返回一个指向该内存区域的<strong>文件描述符（fd）</strong>。</li>
</ul>
<p>这个<code>fd</code>是整个Ashmem机制的核心。它本身只是一个数字，但进程可以通过它找到背后那块真正的物理内存。</p>
<p><strong>2. 内存映射</strong></p>
<p>单个进程拿到<code>fd</code>后，还需要通过<code>mmap</code>系统调用，将这块共享内存映射到自己的进程虚拟地址空间。这样，进程就可以像访问普通内存一样（通过指针）来读写这块共享内存了。</p>
<p>关键点在于：<strong>多个进程可以拿到同一个<code>fd</code>（或其副本），并各自执行<code>mmap</code>，最终它们的不同虚拟地址会指向同一块物理内存</strong>。这就是进程间共享的本质。</p>
<p><strong>3. pin / unpin 内存回收机制</strong></p>
<p>这是Ashmem最精妙的设计。它允许系统在内存紧张时，回收那些被进程标记为“未锁定”的内存页。</p>
<ul>
<li><strong>Pin：</strong> 进程通过<code>ioctl</code>接口告诉内核，某块内存区域目前正在被使用，不能被回收。这相当于给内存上了锁。</li>
<li><strong>Unpin：</strong> 进程告诉内核，某块内存区域已经使用完毕，如果系统内存不足，可以回收这部分内存。回收可能意味着将其换出到硬盘（如果支持），或者直接丢弃（如果是只读的脏页，可以从源文件恢复）。</li>
</ul>
<p><strong>工作流程示例：</strong>
假设进程A创建了一块Ashmem，并写入数据。</p>
<ol>
<li>进程A将数据写入后，调用unpin，表示“我的工作完成了，必要时你可以回收”。</li>
<li>进程B拿到<code>fd</code>，进行<code>mmap</code>并读取数据。在读取期间，进程B会调用pin锁定内存，防止被回收。</li>
<li>进程B读取完毕，调用unpin。</li>
<li>此时如果系统内存不足，内核就可以安全地回收这块内存，因为它被两个进程都标记为unpin状态。</li>
</ol>
<p>这个机制完美地解决了传统共享内存“一旦分配就常驻”的浪费问题，实现了按需内存管理。</p>
<h4 data-id="heading-3"><strong>四、 核心应用场景</strong></h4>
<p><strong>1. 跨进程传递大数据（尤其是Bitmap）</strong></p>
<p>这是Ashmem最经典的应用。当你在<code>Intent</code>中直接传递一个大的Bitmap对象时，Android系统底层会自动使用Ashmem来优化。</p>
<ul>
<li><strong>过程：</strong> 系统会将Bitmap的像素数据放入一块Ashmem区域，然后在进程间只传递这个Ashmem的<code>fd</code>。接收进程通过<code>fd</code>直接映射并读取像素数据。</li>
<li><strong>优势：</strong> 避免了将几MB的像素数据通过Binder进行拷贝，极大地提升了效率，并突破了Binder的大小限制。</li>
</ul>
<p><strong>2. 系统内部使用</strong></p>
<p>很多Android系统服务都重度依赖Ashmem：</p>
<ul>
<li><strong><code>OpenGL</code>、<code>SurfaceFlinger</code>：</strong> 用于图形缓冲区（<code>GraphicBuffer</code>）的共享。应用绘制的画面数据就存放在Ashmem中，供<code>SurfaceFlinger</code>合成最终图像。</li>
<li><strong><code>MediaServer</code>：</strong> 用于共享音视频数据流。</li>
</ul>
<p><strong>3. 进程间自定义大数据通信</strong></p>
<p>开发者也可以直接使用Ashmem API（主要通过<code>MemoryFile</code>这个Java封装类）来实现自定义的进程间大数据共享。</p>
<h4 data-id="heading-4"><strong>五、 开发者视角：如何使用Ashmem</strong></h4>
<p>对于应用开发者，最方便的接口是<code>android.os.MemoryFile</code>。</p>
<p><strong>创建并提供MemoryFile的示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 服务端：创建并准备数据</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> {
    <span class="hljs-keyword">private</span> ParcelFileDescriptor mPfd;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 1. 创建MemoryFile， 大小为 1MB</span>
            <span class="hljs-type">MemoryFile</span> <span class="hljs-variable">memoryFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemoryFile</span>(<span class="hljs-string">"my_shmem"</span>, <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);
            <span class="hljs-comment">// 2. 写入数据</span>
            <span class="hljs-type">byte</span>[] data = <span class="hljs-string">"Hello from Server!"</span>.getBytes();
            memoryFile.writeBytes(data, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.length);
            
            <span class="hljs-comment">// 3. 关键：获取其ParcelFileDescriptor，以便通过Binder传递</span>
            <span class="hljs-type">Method</span> <span class="hljs-variable">getFileDescriptor</span> <span class="hljs-operator">=</span> MemoryFile.class.getDeclaredMethod(<span class="hljs-string">"getFileDescriptor"</span>);
            <span class="hljs-type">FileDescriptor</span> <span class="hljs-variable">fd</span> <span class="hljs-operator">=</span> (FileDescriptor) getFileDescriptor.invoke(memoryFile);
            mPfd = ParcelFileDescriptor.dup(fd); <span class="hljs-comment">// 复制一份fd</span>

            <span class="hljs-comment">// 4. 通过Binder将mPfd传递给客户端</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IMyAidlInterface</span>.Stub() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> ParcelFileDescriptor <span class="hljs-title function_">getSharedMemoryFd</span><span class="hljs-params">()</span> {
                    <span class="hljs-keyword">return</span> mPfd;
                }
            };
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
}
</code></pre>
<p><strong>客户端接收并读取的示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 客户端：通过AIDL接口获取ParcelFileDescriptor并读取</span>
<span class="hljs-type">IMyAidlInterface</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> ...; <span class="hljs-comment">// 从onServiceConnected获取</span>
<span class="hljs-type">ParcelFileDescriptor</span> <span class="hljs-variable">pfd</span> <span class="hljs-operator">=</span> service.getSharedMemoryFd();
<span class="hljs-keyword">if</span> (pfd != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-type">FileDescriptor</span> <span class="hljs-variable">fd</span> <span class="hljs-operator">=</span> pfd.getFileDescriptor();
        <span class="hljs-comment">// 1. 将fd包装成FileInputStream（或者直接使用JNI的mmap）</span>
        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fd);
        <span class="hljs-comment">// 2. 读取数据</span>
        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];
        <span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> inputStream.read(buffer);
        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span>, bytesRead);
        Log.d(<span class="hljs-string">"Client"</span>, <span class="hljs-string">"Received: "</span> + message);
        
        inputStream.close();
    } <span class="hljs-keyword">catch</span> (IOException e) {
        e.printStackTrace();
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">try</span> {
            pfd.close();
        } <span class="hljs-keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>注意事项：</strong></p>
<ul>
<li><code>MemoryFile.getFileDescriptor()</code>是一个<code>@hide</code>方法，上述示例使用了反射，在生产环境中需要考虑兼容性或寻找其他方式。</li>
<li>核心在于<code>ParcelFileDescriptor</code>可以通过Binder传递。</li>
</ul>
<h4 data-id="heading-5"><strong>六、 总结与启示</strong></h4>
<ul>
<li><strong>Ashmem是Android高效内存管理的基石之一</strong>，它通过文件描述符和pin/unpin机制，实现了高性能、可回收的进程间大内存共享。</li>
<li>它在图形系统、多媒体等性能关键路径上扮演着不可替代的角色。</li>
<li>对于普通开发者，理解其原理有助于我们明白系统底层（如Bitmap传输）是如何工作的。在特定场景下（如需要自己实现跨进程大数据传输），直接使用<code>MemoryFile</code>或Native API是一个高效的解决方案。</li>
</ul>
<p>通过这篇解析，希望你能理解Ashmem在Android生态系统中的地位和价值，并能在实际开发中更好地利用或规避相关技术点。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[搞不懂作用域链？这篇文章让你一眼秒懂！]]></title>    <link>https://juejin.cn/post/7573241978902560783</link>    <guid>https://juejin.cn/post/7573241978902560783</guid>    <pubDate>2025-11-17T08:39:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573241978902560783" data-draft-id="7572524368875126819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="搞不懂作用域链？这篇文章让你一眼秒懂！"/> <meta itemprop="keywords" content="JavaScript,面试"/> <meta itemprop="datePublished" content="2025-11-17T08:39:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="soda_yo"/> <meta itemprop="url" content="https://juejin.cn/user/3270387091383163"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            搞不懂作用域链？这篇文章让你一眼秒懂！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3270387091383163/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    soda_yo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:39:33.000Z" title="Mon Nov 17 2025 08:39:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>新手哈基米搞不懂什么是作用域链？深入了解JS代码的执行过程让你秒懂作用域链！</p>
<h2 data-id="heading-1">经典案例</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">'南北绿豆'</span>
    <span class="hljs-title function_">fn</span>()
}
<span class="hljs-keyword">var</span> myName = <span class="hljs-string">'哈基米'</span>
<span class="hljs-title function_">fn2</span>()
</code></pre>
<ul>
<li>究竟是会出现"哈基米",还是"南北绿豆"呢？诶，先不要着急哈气。想要真正弄清输出结果是"哈基米"还是"南北绿豆"。我们先要深入理解一下这段js代码究竟是怎样的一个执行过程。</li>
</ul>
<h2 data-id="heading-2">作用域与它的动态载体</h2>
<h3 data-id="heading-3">作用域</h3>
<ul>
<li>在程序中定义变量的区域，该位置决定了变量的生命周期。通俗来讲，作用域就是变量和函数的可访问范围</li>
</ul>
<h3 data-id="heading-4">函数执行上下文 : 函数作用域的动态载体</h3>
<ol>
<li>什么是函数执行上下文？
<ul>
<li>当一个函数被调用时，js引擎会先创建一个对应的“函数执行上下文”对象，并将函数中声明的变量与函数都存在其中。供函数执行时使用，由此才实现了函数作用域的概念。</li>
</ul>
</li>
<li>其主要组成部分：
<ul>
<li>变量环境：保存使用var关键字声明的对象和函数内部声明的子函数，由此实现常见的“函数作用域”。</li>
<li>词法环境：保存使用let关键字声明的对象，主要用于实现“块级作用域”的功能，非本文重点，不做详细描述。</li>
</ul>
</li>
<li>例子：</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">'南北绿豆'</span>
    <span class="hljs-title function_">fn</span>()
}
</code></pre>
<p>图片的抽象表达：js引擎会为本函数创建一个函数上下文</p>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cdcc28cc26114fc0ad66c6318156df3d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=hwoF71y8tSAxALF1lkMbk9bJ%2B3A%3D" alt="75EE8152-FE72-438e-A284-A224F6A6E135.png" width="70%" loading="lazy"/>
<ol start="4">
<li>新手可能都会有个疑问？
<ul>
<li>为什么fn函数没有存在这个函数执行上下文当中呢？
<ul>
<li>欸，这就告诉你fn函数的声明被存在哪里。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 data-id="heading-5">全局执行上下文：全局作用域的动态载体</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">'南北绿豆'</span>
    <span class="hljs-title function_">fn</span>()
}
<span class="hljs-keyword">var</span> myName = <span class="hljs-string">'哈基米'</span>
<span class="hljs-title function_">fn2</span>()
</code></pre>
<ol>
<li>全局执行上下文与函数执行上下文类似</li>
</ol>
<ul>
<li>
<p>由这份代码可知，在该js文件的全局下，声明了两个函数：fn与fn2，声明了一个变量： myName。</p>
</li>
<li>
<p>所以js引擎同样会为其创建一个“全局执行上下文供全局参考，由此形成全局作用域。</p>
</li>
</ul>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5541e3a683b54beea6c49a6868512f22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=vD4lkRdalQB24TuMYC3xgqRVnrU%3D" alt="461C8CE8-56E8-431a-80AB-0A5FD7C8D366.png" width="70%" loading="lazy"/>
<h3 data-id="heading-6">待解决的疑问</h3>
<ul>
<li>光靠这些我们还无法得知fn2是如何调用到fn函数的，所以我们还得了解这两个执行上下文的出现顺序，以及js引擎是如何对他们进行处理，才能够正常的执行代码。所以我们的新朋友“调用栈”便可以登场了。</li>
</ul>
<h2 data-id="heading-7">js引擎的好兄弟：调用栈</h2>
<ul>
<li>帮助js引擎控制代码执行顺序的“无形态大手”</li>
</ul>
<h3 data-id="heading-8">什么是调用栈？</h3>
<ul>
<li>后进先出：它与我们所知的“栈”这一数据结构一样，有着“后进先出”（LIFO）的特点。</li>
<li>“函数执行上下文生命周期”的管理者：js引擎通过调用栈间接控制“函数执行上下文的生命周期”来管理“函数的执行顺序”，由此直接决定代码的执行流程。
<ul>
<li>具体过程是： 每当一个函数被调用时，js引擎会为其创建一个“函数执行上下文”，然后将该“函数执行上下文”压入栈顶，js引擎就会开始执行处于栈顶的函数，当函数执行完毕，便会让栈顶元素出栈。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-9">函数执行上下文被压入栈的过程</h3>
<ul>
<li>全局被编译时，js引擎创建全局执行上下文并将其压入调用栈，然后开始执行全局沿着全局一行一行往下执行。</li>
</ul>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/358b3cf9cdef45f59bd2289aae100160~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=TreJroaU7Ha4%2BepljARmCDIjgog%3D" alt="845D93CB-BD81-438d-A3B5-9D490ADB5C7A.png" width="50%" loading="lazy"/>
<ul>
<li>当准备执行fn2（）时，js引擎会在全局执行上下文中寻找fn2（）的定义，发现其存在。js引擎对其进行编译并创建对应函数执行上下文并将其压入调用栈，然后开始执行函数fn2，一行一行往下执行。</li>
</ul>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/02e9da1731114f0aa29a92bb1036bbbf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=fxnyu1jr4cnaHIKWdbwyGcU0P08%3D" alt="C06E8B4E-D793-49e6-9A11-21AEFA2F357C.png" width="50%" loading="lazy"/>
<ul>
<li>当准备执行fn（）时，js引擎会在fn2函数执行上下文中寻找fn（）的定义，未发现定义，于是继续向全局执行上下文中寻找fn（）的定义。发现fn（）定义，js引擎对其进行编译并创建对应函数执行上下文压入调用栈，然后开始执行fn，一行一行往下执行。</li>
</ul>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/966cd531e81740eea28e8aca67b5645a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=%2ByNFrpf7Oeck93JwTW%2BWAjSm3YY%3D" alt="9C03BEC2-0DD7-4b97-A119-037D2BC2A8C7.png" width="50%" loading="lazy"/>
<h3 data-id="heading-10">消失的“南北绿豆”：交流的失败？</h3>
<p>js引擎对变量与函数的寻找过程难道真的只是“由内向外寻找”？如果是这样输出的结果应该是“南北绿豆”才对。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e3b7cfac2e44af2903c235390a8383c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=IVZYRXakE%2BaKvhNOGc%2FpILajpL0%3D" alt="951C6781-E75B-4942-BB5D-BBEE88EA7C0E.png" loading="lazy"/></p>
<p>怎么是哈基米？</p>
<h2 data-id="heading-11">作用域链：作用域之间以outer指针为链接，形成的单向链表</h2>
<h3 data-id="heading-12">outer指针：函数执行上文间的链接者,向外寻找的罪魁祸首</h3>
<ul>
<li>outer指针：当一个函数执行上文被创建时，其内部存在一个指针outer指向该函数被定义时所在的词法作用域</li>
<li>词法作用域：一个函数被编译时一定会用一个outer指针记录该执行上下文（作用域）的外层（作用域）是谁。</li>
</ul>

<ul>
<li>例子：</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> num=<span class="hljs-number">0</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"/>)
{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);
}
<span class="hljs-title function_">fn1</span>()
</code></pre>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fdda3bbc54c84ba59cd73ab61f1df32d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=bwYsk0FbZFIt2mhId32V82tYZbM%3D" alt="9E981168-8FAF-4a64-AB56-40E2074FAC46.png" width="70%" loading="lazy"/> 
<p>由此形成了一个最简单的作用域链</p>
<ul>
<li>当执行函数内部时，在函数执行上文内部无法找到num的声明，js引擎便会沿着outer指针指向的全局执行上下文，寻找num的声明</li>
<li>全局执行上文中存在num的声明，且num为1</li>
<li>于是程序执行输出为1</li>
</ul>
<h3 data-id="heading-13">作用域链：作用域之间以outer指针为链接，形成的单向链表</h3>
<ul>
<li>由上述逻辑不断推导，最开始的“南北绿豆”消失之迷便迎刃而解了。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">'南北绿豆'</span>
    <span class="hljs-title function_">fn</span>()
}
<span class="hljs-keyword">var</span> myName = <span class="hljs-string">'哈基米'</span>
<span class="hljs-title function_">fn2</span>()
</code></pre>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b6b287f23fbc41f5a6620ac4e81b2ad3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=qvajKXFUHrK1c8q5Wtg3O3WLFng%3D" alt="882B21C2-CB2A-4e9b-8527-4C939FA5927E.png" width="70%" loading="lazy"/>
<h3 data-id="heading-14">执行fn（）函数时，寻找myName的定义的过程：</h3>
<ul>
<li>第一步：在fn函数执行上文中寻找，未查找到。</li>
<li>第二部：沿着outer指针指向查找上一级，在全局执行上下文中寻找到myName=“哈基米”</li>
<li>输出哈基米</li>
<li>由此我们发现：作用域链的形成与函数调用的过程无关。</li>
<li>作用域链的形成：依赖outer指针的指向。</li>
</ul>
<h2 data-id="heading-15">总结</h2>
<ol>
<li>作用域： 在程序中定义变量的区域，该位置决定了变量的生命周期。通俗来讲，作用域就是变量和函数的可访问范围</li>
<li>调用栈：LIFO（后进先出）的执行上下文栈，用于管理函数调用顺序</li>
<li>执行上下文：作用域的动态载体，存储变量的具体环境</li>
<li>outer指针：每一个函数内部都会存在一个指针outer，指向该函数的外层作用域（其所在的词法作用域）</li>
<li>词法作用域：函数或者变量被定义时的代码嵌套位置</li>
<li>作用域链：作用域之间以outer指针为链接，形成的单向链表</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大模型成本太高？阿里云Serverless AI原生架构，教你极致省钱又稳健部署！]]></title>    <link>https://juejin.cn/post/7573225720698339380</link>    <guid>https://juejin.cn/post/7573225720698339380</guid>    <pubDate>2025-11-17T08:54:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720698339380" data-draft-id="7572010680896176168" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大模型成本太高？阿里云Serverless AI原生架构，教你极致省钱又稳健部署！"/> <meta itemprop="keywords" content="Serverless"/> <meta itemprop="datePublished" content="2025-11-17T08:54:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大模型成本太高？阿里云Serverless AI原生架构，教你极致省钱又稳健部署！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:54:25.000Z" title="Mon Nov 17 2025 08:54:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：赵世振</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd49fd38d1b04d2da2cb476e52a16258~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=LruOxfCVqSnGg4EmRl7LLXiAokk%3D" alt="image.png" loading="lazy"/></p>
<p><em>本文整理自 2025 云栖大会，阿里云智能集团产品架构师</em> <em><strong>赵世振</strong></em> <em>的主题演讲《Serverless AI 原生应用架构》</em></p>
<p>在 AI 大模型浪潮席卷全球的今天，企业纷纷加速拥抱 AI，推动智能客服、内容生成、流程自动化等场景快速落地。然而，许多企业在实践中却遭遇了“三高困境”——<strong>成本高、复杂度高、风险高</strong>。</p>
<p>一位互联网公司 CTO 曾坦言：“智能客服流量暴增，模型服务很容易被打挂，紧急手动扩容后，GPU 闲置率高达 90%，月底账单翻倍，还有数据泄漏风险。”</p>
<p>这并非个例——大量企业仍在用“传统架构”承载“新型 AI 业务”，要让 AI 业务简单、稳定、安全落地，我们必须从基础设施到业务接入层，进行一场 <strong>AI 原生的架构重塑</strong>。</p>
<h2 data-id="heading-0">架构变革的底层逻辑</h2>
<p>过去十余年间，应用架构持续演进：从单体架构到垂直拆分，历经 SOA、微服务，走向云原生，直至今日的 AI 原生架构。这一进程的本质，是<strong>业务逻辑不断解耦、分布化与智能化的过程</strong>，旨在实现更快速的业务响应、更灵活的协同能力。</p>
<p>与此同时，底层基础设施也同步进化——从物理机、虚拟机到容器、Kubernetes，再到 Serverless，如今迈向 Serverless AI 的新阶段。其核心在于<strong>对资源与能力的极致抽象</strong>，实现按需弹性、自动伸缩，让计算如同水电一般随取随用、高效便捷。</p>
<p>两条演进主线共同揭示了一个清晰的趋势：未来的技术重心将愈发聚焦于业务逻辑本身的创新与实现，而基础设施则趋于全面抽象化、自动化和智能化。开发者无需再过多关注底层运维细节，而是可以专注于创造更高价值的业务场景。这不仅是技术的跃迁，更是生产力的一次深刻变革。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbe8ddfc320d486d85e28355da12993a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=AgSyJH%2BWQI38h5h5QccW31ZqzOI%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-1">AI 原生应用架构的三大核心需求</h2>
<p>通过与 300 余家企业的深度交流，AI 原生应用架构的核心需求可归纳为<strong>高模型算力</strong>、<strong>高可用性</strong>及<strong>严格安全管控</strong>三大维度：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/259ed5f1e65a4c249541b5bba4d73d60~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=myzycWolUlgi46Wd8hJhREMbWLk%3D" alt="图片" loading="lazy"/></p>
<p><strong>1. 算力需求</strong></p>
<ul>
<li><strong>成本优化：</strong> GPU 算力成本是 CPU 的数倍，且供应波动大。需提供灵活的卡型选择（如 N 分之一卡）、按需付费模式及预留闲置资源策略，以平衡成本与性能。</li>
<li><strong>稳定性保障：</strong> 通过多可用区部署与动态资源调度，确保模型调用的持续性与资源利用率最大化。</li>
</ul>
<p><strong>2. 高可用性需求</strong></p>
<ul>
<li><strong>全链路容灾：</strong> 支持多可用区部署，避免单点故障；</li>
<li><strong>限流与 fallback 机制：</strong> 突发流量时自动限流，模型服务异常时无缝切换至备用模型，保障业务连续性。</li>
</ul>
<p><strong>3. 安全管控需求</strong></p>
<ul>
<li><strong>输入输出合规性：</strong> 模型输入输出均设内容安全防护，过滤违规内容、敏感信息等；</li>
<li><strong>消费者鉴权：</strong> 不同团队或不同用户请求带有不同的鉴权凭证，权限最小化；</li>
<li><strong>全链路监控：</strong> 实现从网关到算力的全链路可观测体系；</li>
</ul>
<p>总结来说，AI 原生应用架构需要的是：<strong>简单易用的开发体验、生产级的性能、稳定性和安全保障。</strong></p>
<h2 data-id="heading-2">Serverless AI 原生架构的全栈能力支撑</h2>
<p>为满足上述需求，Serverless AI 原生应用架构应运而生。在该架构中，模型可通过 Serverless GPU（即函数计算 FC）进行部署，与 Agent 相关的 Sandbox、MCP Server、E2B 等服务也可托管于 FC。AI 网关作为模型与 MCP 服务的代理层，提供限流、鉴权、可观测性与安全护栏等功能。AI Agent 的开发支持低代码、零代码及高代码方式，可部署于 FC 或 SAE。Agent 前端通过网关进行代理，全链路配备 AI 应用观测能力，实现端到端可观测。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/286004560bb74cd6993c7024af971c4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=LAlZibIcB2x9%2FFDoTfesWjyKUAk%3D" alt="图片" loading="lazy"/></p>
<p>该架构具备以下特点：</p>
<h3 data-id="heading-3">特征一：全栈 Serverless，极致简化运维</h3>
<p>整个架构中，函数计算 FC、SAE（Serverless应用引擎）、MSE Nacos、RocketMQ、AI 网关等关键组件均为 Serverless 形态或具备 Serverless 特性。无需管理底层服务器，自动扩缩容真正做到“一键部署、开箱即用”。</p>
<h3 data-id="heading-4">特征二：全链路高可用，保障业务连续性</h3>
<p>架构中的每一个产品节点均支持多可用区部署，具备跨区域容灾能力。特别是函数计算 FC 提供的 Serverless GPU 实例，已实现三可用区冗余部署，并配备实例级健康检查与自动恢复机制，极大提升了模型服务的稳定性。</p>
<p>此外，AI 网关内置 Fallback 机制，在主模型不可用时可自动切换至备用模型，确保关键业务不中断。</p>
<h3 data-id="heading-5">特征三：双层安全保障，构筑可信 AI 防线</h3>
<p>安全贯穿整个调用链路：</p>
<ul>
<li><strong>运行时安全</strong>：FC 和 SAE 采用实例隔离机制，防止租户间干扰；</li>
<li><strong>调用层安全</strong>：AI 网关提供消费者鉴权、API Key 管理、内容审核等功能，有效防范未授权访问与恶意攻击。</li>
</ul>
<h3 data-id="heading-6">特征四：简单易用，加速 AI 创新落地</h3>
<p>所有产品都是云上托管，一键部署启动，常见模型与 MCP 服务已封装为模板，可在 <strong>FunctionAI 平台一键部署</strong>，不管你是零代码用户、低代码开发者，还是资深工程师，都能找到适合你的入口。</p>
<h2 data-id="heading-7">Serverless AI 架构的核心组件</h2>
<h3 data-id="heading-8">函数计算 FC：定义 Serverless 终极形态</h3>
<p>定位为弹性经济的全托管 Serverless 计算服务，专用于部署大模型与 MCP 工具：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb7e9a2d750c475aa4a1bd43c20f4de4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=qAJIv2A%2FhJh0YlehUjpPcT7MlHk%3D" alt="图片" loading="lazy"/></p>
<ul>
<li><strong>经济降本</strong>：支持卡切分（1/N GPU）、阶梯定价、常驻实例等策略，整体 GPU 利用率超 50%，成本更低。</li>
<li><strong>极致弹性</strong>：<strong>GPU 实例启动快（毫秒级/秒级）</strong> ，通过<strong>请求感知调度显著降低 RT 抖动，</strong> 支持定时/水位伸缩、延迟释放、会话亲和。</li>
<li><strong>开发框架集成</strong>：内置 MCP Server、Sandbox 等服务运行时，支持模型微调镜像一键部署；  </li>
<li><strong>运维能力</strong>：提供镜像加速、资源调度、请求级监控日志，实现零运维体验。</li>
</ul>
<h3 data-id="heading-9">AI 网关：企业级 AI 流量中枢</h3>
<p>作为<strong>模型、MCP、Agent 的统一接入入口</strong>，承担安全、治理与调度职责：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5be4c0ead99e4d3b909484dd08900a06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=f1%2FUq1Ri4N8nUDftJQmEiCo9w1k%3D" alt="图片" loading="lazy"/></p>
<ul>
<li><strong>统一代理</strong>：支持多模型路由、MCP 协议适配、Agent API 封装，简化调用复杂度；</li>
<li><strong>安全鉴权</strong>：集中管理 API-KEY，支持二次分发与消费者身份验证，设置 AI 安全护栏防范恶意输入与输出；</li>
<li><strong>高可用保障</strong>：多可用区部署 + fallback 机制，异常时自动切换备用模型，支持精细化限流，保障核心业务稳定性； </li>
<li><strong>成本优化</strong>：内置 AI 缓存减少算力资源消耗，结合观测能力实现 Token 级成本监控；</li>
<li><strong>灵活扩展</strong>：支持动态组装 MCP 新工具链，快速接入外部 AI 服务。</li>
</ul>
<h2 data-id="heading-10">总结展望</h2>
<p>Serverless AI 原生架构不仅是技术演进，更是企业智能化转型的关键基础设施。它让开发者聚焦业务逻辑，让企业告别“基建焦虑”，让 AI 真正“飞入寻常百姓家”。</p>
<p>正如本次演讲尾声所说：“<strong>让架构为业务赋能，让 AI 为世界创造更多可能。</strong> ”</p>
<p>阿里云将持续投入 Serverless 与 AI 原生架构研发，携手更多行业伙伴，共同构建开放、智能、安全的新一代 AI 应用生态。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude Code 是如何构建的]]></title>    <link>https://juejin.cn/post/7573225720698322996</link>    <guid>https://juejin.cn/post/7573225720698322996</guid>    <pubDate>2025-11-17T08:53:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720698322996" data-draft-id="7573273271798972456" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude Code 是如何构建的"/> <meta itemprop="keywords" content="Claude"/> <meta itemprop="datePublished" content="2025-11-17T08:53:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="是魔丸啊"/> <meta itemprop="url" content="https://juejin.cn/user/3217622495411292"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude Code 是如何构建的
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3217622495411292/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    是魔丸啊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:53:53.000Z" title="Mon Nov 17 2025 08:53:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fnewsletter.pragmaticengineer.com%2Fp%2Fhow-claude-code-is-built" target="_blank" title="https://newsletter.pragmaticengineer.com/p/how-claude-code-is-built" ref="nofollow noopener noreferrer">转载</a></p>
<p><strong>作者：</strong> Gergely Orosz
<strong>发布日期：</strong> 2025年9月24日
<strong>来源：</strong> The Pragmatic Engineer</p>
<hr/>
<h2 data-id="heading-0">概述</h2>
<p>Claude Code 自今年 5 月正式发布以来，在开发者世界中掀起了风暴。该工具目前年化收入超过 5 亿美元，自 5 月发布以来的三个月内，使用量增长了超过 10 倍。</p>
<p>我最近与 Claude Code 的两位创始工程师进行了深入交流：Boris Cherny（提出原始原型想法的项目创始工程师）和 Sid Bidasaria（Claude Code 的第 2 号工程师，subagents 功能的创建者），以及创始产品经理 Cat Wu。</p>
<p>我了解了 Claude Code 是如何构建的，并深入了解了成功的"AI 优先工程团队"是如何运作的。这有点像窥探水晶球，看到了快速发展的初创公司未来的运作方式。好消息是，软件工程师在这个未来中仍然非常有需求……</p>
<h2 data-id="heading-1">本文涵盖内容</h2>
<ol>
<li>
<p><strong>一切是如何开始的</strong> - Claude Code 的想法来源于一个使用 Claude 来告知工程师工作时正在听什么音乐的命令行工具。在获得文件系统访问权限后，它在 Anthropic 内部像野火一样传播开来。如今，Claude Code 已拥有自己成熟的团队。</p>
</li>
<li>
<p><strong>技术栈和架构</strong> - TypeScript、React、Ink、Yoga 和 Bun。技术栈的选择是为了"分布内"并发挥模型的优势。有趣的事实：Claude Code 中 90% 的代码是由其自身编写的！</p>
</li>
<li>
<p><strong>以天而不是周为单位构建和发布功能</strong> - 团队以极快的速度工作，每个工程师每天大约发布 5 个版本。原型制作速度惊人：我们为一个新功能制作了 10 多个实际原型。看起来 AI agents 确实加速了迭代过程。</p>
</li>
<li>
<p><strong>重新设计终端用户体验</strong> - Claude Code 为终端用户体验带来了许多创新功能，这些功能在我们能够与 LLM 驱动的终端交互之前是不需要的。让我们来看看其中的一些。</p>
</li>
<li>
<p><strong>"AI 优先"软件工程是什么样的</strong> - 使用 AI agents 进行代码审查和测试、测试驱动开发（TDD）的复兴、自动化事件响应，以及谨慎使用功能标志。这是否预示着未来"AI 优先"工程团队的工作方式？</p>
</li>
<li>
<p><strong>构建子代理</strong> - 深入了解 subagents 功能是如何在短短三天内构建完成的，其中两天的工作被废弃。</p>
</li>
<li>
<p><strong>AI 辅助工程团队的未来？</strong> - 工程团队可以从 Anthropic 的运作中学到什么，以及需要记住哪些使其独特但可能不太容易转移的东西。</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-2">1. 一切是如何开始的</h2>
<p>Boris Cherny 于 2024 年 9 月加入 Anthropic，并开始使用 Claude 3.6 模型构建一系列不同的原型。当时，他想更熟悉 Anthropic 的公共 API。Boris 回忆道：</p>
<p>"我开始在终端中使用 Claude 进行实验。第一个版本非常简陋：它无法读取文件，无法使用 bash，完全不能做任何工程相关的事情。但它可以与计算机交互。</p>
<p>我将这个原型连接到 AppleScript：它可以告诉我工作时正在听什么音乐。然后它还可以根据我的输入更改正在播放的音乐。</p>
<p>这是一个很酷的演示，但并不是很有趣。"</p>
<p>与此同时，Cat Wu 正在研究 AI agents 的计算机使用情况，以及 agents 使用它们时产生的新能力。在与 Cat 交谈后，Boris 有了给终端提供比仅使用 AppleScript 更多功能的想法。他说：</p>
<p>"我尝试给它一些与文件系统和批处理交互的工具；它可以读取文件、写入文件和运行批处理命令。</p>
<p>突然间，这个 agent 变得非常有趣。我在我们的代码库中运行它，并开始询问相关问题。Claude 然后开始探索文件系统并读取文件。它会读取一个文件，查看导入，然后读取导入中定义的文件！它一直继续，直到找到好的答案。Claude 探索文件系统对我来说是惊人的，因为我从未使用过这样的工具。</p>
<p>在 AI 中，我们谈论"产品过载"，这就是我们在原型中发现的。产品过载意味着模型能够做特定的事情，但 AI 运行其中的产品并没有以能够捕捉这种能力的方式构建。我发现 Claude 探索文件系统是纯粹的产品过载。模型已经能够做到这一点，但没有围绕这个能力构建产品！"</p>
<h3 data-id="heading-3">产品市场匹配</h3>
<p>Boris 开始在工作中每天使用他的原型。然后他与将成为 Claude Code 核心团队的成员分享了它，其他开发人员也开始每天使用它。</p>
<p>Boris 和 Claude Code 团队在 2024 年 11 月发布了适合内部测试的版本——距离第一个原型两个月后。第一天，大约 20% 的工程团队使用了它，到第五天，50% 的工程师都在使用 Claude Code。那时，Boris 相当确信 Claude Code 在外部世界也会成为热门产品。</p>
<p>但对于是否要发布这个工具，还是仅供内部使用，内部存在争议。Boris 回忆道：</p>
<p>"我们实际上甚至不确定是否要公开发布 Claude Code，因为我们认为这可能成为我们的竞争优势，就像我们的'秘密武器'：如果它给我们带来优势，为什么要发布它？</p>
<p>最终，我们达成了以下立场：</p>
<ul>
<li>Anthropic 的核心是一家模型安全公司</li>
<li>我们了解模型安全和能力的方式是制作人们使用的工具</li>
<li>Claude Code 几乎肯定会成为人们使用的工具，因为整个 Anthropic 都对它上了瘾</li>
</ul>
<p>因此，通过发布这个工具，我们可以更多地了解模型安全性和能力。"</p>
<h3 data-id="heading-4">组建 Claude Code 工程团队</h3>
<p>最初，团队只有 Boris。2024 年 11 月，Sid Bidasaria 加入 Anthropic 并遇到了早期版本的 Claude Code。他喜欢这个想法并加入了 Boris 的项目。</p>
<p>他们的两人团队工作方式有很多自由度。Sid 告诉我：</p>
<p>"我们大部分工作都是非常快速地制作原型，并构建展示底层模型强大能力的产品。团队内部没有正式流程：一切都超级灵活。我们可以几乎随心所欲地工作，所以我们一直选择最有前景的想法。"</p>
<p>到 7 月，团队增长到约 10 名工程师，此后招聘一直在继续。如今，它是一个成熟的完整产品团队，包括工程师、产品管理、设计和数据科学人员——而且他们还在招聘。</p>
<h3 data-id="heading-5">Claude Code 不仅面向编码人员</h3>
<p>如今，超过 80% 编写代码的 Anthropic 工程师日常使用 Claude Code，但不仅仅是他们。Boris 说：</p>
<p>"我走进办公室时，瞥了一眼一位数据科学家的屏幕。他正在运行 Claude Code。我说：'等等，你为什么在运行 Claude Code？'他说：'我搞清楚了如何让这个东西为我写查询。'</p>
<p>这些天，当我走过数据科学家的一排时，他们都在运行 Claude Code——其中许多人同时运行多个实例——运行查询、创建可视化以及做其他类型的有帮助的工作。"</p>
<p>有趣的一点是，Boris 心中只想着为软件工程师设计 Claude Code——因此得名！但该产品表明它在其他领域也有进一步的实用性。</p>
<h3 data-id="heading-6">团队规模翻倍的同时提高工程产出</h3>
<p>如果我们以每个工程师的 pull requests 作为指标；当工程团队规模迅速翻倍时，这个过程通常会拉低这个指标。这是因为现有工程师花更多时间培训新同事，编码时间更少，而新加入者需要先熟悉情况。像任何指标一样，每个工程师的 pull requests（PR）不是完美的指标，但它确实给人一种迭代节奏的感觉。PR 吞吐量被 GitHub、Dropbox、Monzo、Adyen 等公司衡量。</p>
<p>但 Anthropic 在团队规模翻倍的同时看到了 67% 的 PR 吞吐量增长——这要归功于 Claude Code。平均 PR 合并指标下降本来是正常的，但实际上却上升了！这归功于 Claude Code：工程师们使用它能更快地完成 PR。在一系列可能幸运的事件中，Anthropic 在 Claude Code 被整个工程部门采用的大致时间将工程人员数量翻了一番。</p>
<p>我也注意到，使用 Claude Code 完成工作明显更快，而且我在编码任务上取得了更好的进展。当我构建 Claude Code 可以通过运行程序并检查输出来验证代码正确性的东西时，它也很有帮助。</p>
<hr/>
<h2 data-id="heading-7">2. 技术栈和架构</h2>
<h3 data-id="heading-8">Claude Code 的技术栈：</h3>
<ul>
<li><strong>TypeScript</strong> - Claude Code 建立在这种语言之上</li>
<li><strong>React with Ink</strong> - UI 使用 React 编写，使用 Ink 框架实现交互式命令行元素</li>
<li><strong>Yoga</strong> - 布局系统，由 Meta 开源。它是一个基于约束的布局系统，效果很好。基于终端的应用程序有需要支持所有终端尺寸的缺点，所以你需要一个布局系统来实用地做到这一点</li>
<li><strong>Bun</strong> - 用于构建和打包。团队选择它是为了与 Webpack、Vite 等其他构建系统相比的速度优势</li>
</ul>
<p>Ink 框架是一个出色的组件，允许在终端中创建美观的 UI。例如，要创建这个 UI</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/def96c4814fb46108be9c19a2fdf388c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=vfe1K60ReUkVyWe7E%2Bx%2BRnJPLt0%3D" alt="image.png" loading="lazy"/></p>
<p>你可以用 React 编写代码：</p>
<pre><code class="hljs language-ini" lang="ini">import React, { useState, useEffect } from 'react'<span class="hljs-comment">;</span>
import { render, Text } from 'ink'<span class="hljs-comment">;</span>

const <span class="hljs-attr">Counter</span> = () =&gt; {
  const <span class="hljs-section">[counter, setCounter]</span> = useState(0)<span class="hljs-comment">;</span>

  useEffect(() =&gt; {
    const <span class="hljs-attr">timer</span> = setInterval(() =&gt; {
      setCounter(<span class="hljs-attr">previousCounter</span> =&gt; previousCounter + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
    }, 100)<span class="hljs-comment">;</span>

    return () =&gt; {
      clearInterval(timer)<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>
  }, <span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>

  return &lt;Text <span class="hljs-attr">color</span>=<span class="hljs-string">"green"</span>&gt;{counter} tests passed&lt;/Text&gt;<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

render(&lt;Counter /&gt;)<span class="hljs-comment">;</span>
</code></pre>
<p>npm 用于分发 Claude Code。它是 Node 生态系统中最流行的包管理器。要开始使用 Claude Code，你需要安装 Node 18 或更高版本，然后运行：</p>
<pre><code class="hljs language-bash" lang="bash">npm install -g @anthropic-ai/claude-code
</code></pre>
<p>完成后，你可以使用 claude 命令启动工具。</p>
<h3 data-id="heading-9">技术栈选择：分布内</h3>
<p>技术栈的选择是为了 Claude 模型的"分布内"。在 AI 中，有"分布内"和"分布外"这两个术语。"分布内"意味着模型已经知道如何做，"分布外"意味着它不擅长。</p>
<p>团队希望为 Claude 选择一个它已经很擅长的"分布内"技术栈。TypeScript 和 React 是模型非常擅长的两种技术，因此是合理的选择。然而，如果团队选择了 Claude 不太擅长的更奇特的技术栈，那将是"分布外"技术栈。Boris 总结道：</p>
<p>"使用分布外技术栈，模型仍然可以学习。但你必须指导它并投入工作。我们想要一个不需要我们教的技术栈：一个 Claude Code 可以自我构建的技术栈。而且效果很好；Claude Code 中大约 90% 的代码是用 Claude Code 编写的。"</p>
<h3 data-id="heading-10">架构：选择最简单的选项</h3>
<p>有趣的是，就模块、组件和复杂的客户端业务逻辑而言，Claude Code 并没有那么多内容。对于一个执行诸如遍历文件系统和代码库等相当复杂任务的工具来说，这有点令人惊讶！但 Claude Code 只是 Claude 模型之上的一个轻量级外壳。这是因为模型完成了几乎所有的工作：</p>
<ul>
<li>定义 UI，并暴露钩子让模型修改它</li>
<li>暴露工具供模型使用</li>
<li>……然后让开道路</li>
</ul>
<p>Claude Code 团队尝试编写尽可能少的业务逻辑。Boris 告诉我：</p>
<p>"这听起来可能很奇怪，但我们构建这个东西的方式是希望人们尽可能原始地感受模型。我们相信模型可以做比今天产品允许的更多的事情。</p>
<p>当你看到很多编码产品时，它们阻碍了模型；它们通过添加 UI 元素和其他混乱的部分来添加脚手架，所以在这些工具中运行的模型感觉像是在单腿跳跳。旨在对用户有帮助的功能最终限制了模型。因此，我们尽量使 UI 尽可能最小。</p>
<p>每次有新模型发布时，我们都会删除一堆代码。例如，对于 4.0 模型，我们删除了大约一半的系统提示，因为我们不再需要它了。我们尽量在模型周围放置尽可能少的代码，这包括最小化提示和最小化工具数量。我们不断删除工具并试验新的工具。"</p>
<h3 data-id="heading-11">本地运行而非虚拟化</h3>
<p>Claude Code 不使用虚拟化——它在本地运行。一个主要的设计决定是是否在虚拟机中运行 Claude Code——比如在 Docker 容器中，或在云端——从而创建沙箱环境。但团队决定使用本地运行的版本，因为：简单！Boris 说：</p>
<p>"对于每个设计决定，我们几乎总是选择最简单的选项。对于"在哪里运行批处理命令？"和"从哪里读取文件系统？"这些问题的最简单答案是什么？就是在本地做。</p>
<p>所以我们选择了这样：Claude Code 在本地运行批处理命令，并读写文件系统。没有虚拟化。"</p>
<h3 data-id="heading-12">权限系统</h3>
<p>Claude Code 最复杂的部分是权限系统。在本地运行 Claude Code 的风险是 agent 可能会做它不应该做的不可逆转的事情，比如删除文件。但这如何安全地完成呢？</p>
<p>再次，团队选择了简单性，并构建了一个在执行操作之前寻求权限的权限系统。然后用户可以决定：</p>
<ul>
<li>授予权限一次</li>
<li>为未来的会话也授予权限</li>
<li>拒绝权限</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7842479649748f9b7fcf83ef00e735c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=1d4AvNnNZu8LRP4%2B2ph62HsE6Kk%3D" alt="image.png" loading="lazy"/></p>
<p>Boris 告诉我，正确处理权限需要努力：</p>
<p>"我们最重要的原则是：如果你开始运行 Claude Code，它不应该在没有权限的情况下更改你系统上的东西。这可能是危险的。</p>
<p>但是，我们也应该给人们提供选择退出的方式，比如说出诸如"实际上，在我工作的上下文中，我不想每次都给予权限"这样的话。</p>
<p>不过，权限系统中有很多细微差别。例如，当命令进来时，我们对其进行静态分析，以检查这是否是设置文件中（settings.json 文件中）已经允许的内容。</p>
<p>设置系统是一个多层系统，可以按项目、按用户和按公司进行配置。你还可以与团队共享设置。我们观察到团队共享设置文件，将命令列入白名单，这样 Claude Code 就不会请求权限，比如检查到源代码控制中。"</p>
<h3 data-id="heading-13">其他功能</h3>
<p>Claude Code 在某些方面很简单，但有很多功能增加了其复杂性。其中一些已被记录。值得注意的是：</p>
<ul>
<li><strong>Hooks</strong>：为 Claude Code 创建自定义 shell 命令</li>
<li><strong>MCP 支持</strong>：通过连接到 MCP 服务器给 Claude Code 更多功能。请参阅我们关于模型上下文协议（MCP）的深度解析</li>
<li><strong>GitHub 和 GitLab 支持</strong>：使用 GitHub Actions 并将 Claude Code 集成到 GitLab CI/CD 中</li>
<li><strong>输出样式</strong>：能够切换输出样式，或定义自己的样式。可以切换的内置输出样式包括：
<ul>
<li>解释性：向你解释实现选择</li>
<li>学习性：协作风格，Claude 要求你自己做小任务。这是一个非常聪明的方法来保持参与度、动手实践和学习！对于经验较少的工程师或那些不熟悉的人来说，这可能是一个很好的学习方式</li>
</ul>
</li>
<li><strong>配置</strong>：使用各种配置文件和设置来配置你的终端、模型、状态行等</li>
<li><strong>Subagents</strong>：下文将详细介绍</li>
<li><strong>企业功能</strong>：设置身份和访问管理（IAM）以在整个组织中使用 Claude Code，并访问组织范围的分析以跟踪使用情况</li>
<li><strong>Claude Code SDK</strong>：使用驱动 Claude Code 的 agent 构建自定义 AI agents</li>
<li>……以及 Claude Code 中最近新功能的汇总</li>
</ul>
<hr/>
<h2 data-id="heading-14">3. 以天而不是周为单位构建和发布功能</h2>
<p>对于一个大约十几名工程师的团队来说，他们工作得非常快：</p>
<ul>
<li>
<p><strong>每天约 60-100 次内部发布</strong> - 每当工程师对 Claude Code 进行更改时，他们会在内部发布一个新的 npm 包。Anthropic 的每个人都使用内部版本，开发团队会获得快速反馈。</p>
</li>
<li>
<p><strong>夏季期间，工程师每天推动大约 5 个 pull requests</strong> - 这比大多数科技公司每天 1-2 个 pull requests 的正常速度快得多。</p>
</li>
<li>
<p><strong>每天 1 次外部发布</strong> - 几乎每天都会发布新版本作为部署的一部分。</p>
</li>
</ul>
<h3 data-id="heading-15">2 天内 20 个原型：构建 todo 列表</h3>
<p>这种开发让我惊讶的是，团队比我所习惯的看到的多得多地使用 Claude Code 进行原型制作。例如，Boris 向我展示了他在两天内几个小时内为新功能 todo 列表制作了大约 20 个原型。</p>
<p>他慷慨地分享了他为各种迭代使用的实际提示。每次之后，Boris 会：</p>
<ul>
<li>有时调整结果</li>
<li>尝试使用它</li>
<li>如果感觉良好，与同事分享以获得反馈</li>
<li>当感觉不对时，他用新的提示构建一个新原型</li>
</ul>
<h4 data-id="heading-16">原型 #1：显示完成的 todos</h4>
<p>想法：todo 列表是跟踪 Claude 进展的最简单方法之一，所以他们尝试将列表放在最近一次工具调用的正下方。</p>
<p>提示：</p>
<pre><code class="hljs language-rust" lang="rust">&gt; make it so instead of todos showing up <span class="hljs-keyword">as</span> they come <span class="hljs-keyword">in</span>, we hide the tool <span class="hljs-keyword">use</span> and result <span class="hljs-keyword">for</span> <span class="hljs-title class_">todos</span>, and render a fixed todo list above the input. title it <span class="hljs-string">"/todo (1 of 3)"</span> <span class="hljs-keyword">in</span> grey
</code></pre>
<p>看起来如何：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd446a74ef134c81add0f8715565d73a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=Yfp5Q9XMwbP8wpS15NmkU78V7bA%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-17">原型 #2：在底部显示进度</h4>
<p>另一个变体是内联显示每个 todo 更新。</p>
<p>提示：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">&gt; actually don<span class="hljs-comment">'t show a todo list at all, and instead render the tool used inline, as bold headings when the model starts working on a todo. keep the "step 2 of 4" or whatever, and add middot /todo to see after in grey</span>
</code></pre>
<p>看起来如何：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65ad0b72603a4d7c9ea47ba67ec1969d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=mAUXZ0F4xCn0qKUXIbq%2BuT5V9qY%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-18">原型 #3 和 #4：交互式药丸</h4>
<p>如果 todos 是一个交互式药丸（控制台底部的一个矩形），你可以拉起来查看进度，就像后台任务一样？</p>
<p>提示和输出：</p>
<pre><code class="hljs language-css" lang="css">&gt; also add <span class="hljs-selector-tag">a</span> todo pill under the text <span class="hljs-selector-tag">input</span>, similar <span class="hljs-selector-tag">to</span> bg tasks. it should render "todos: <span class="hljs-number">1</span> of <span class="hljs-number">3</span><span class="hljs-string">" or whatever
</span></code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d87087494c94dc1aa39cdbf2e38d053~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=PnS2Hpr8xL%2FPV1rXfJckJNjvDk0%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #3</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_">&gt; </span><span class="bash">make the pill interactive, like the <span class="hljs-built_in">bg</span> tasks pill</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/98bb7b0b63124c769da05da5fa59156c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=2hu%2FFcABJSxwV05FBGTTDcO3i%2B4%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #4</p>
<h4 data-id="heading-19">原型 #5 和 #6：使用抽屉</h4>
<p>如果我们有一个'抽屉'可以滑入并在旁边显示 todos 怎么样？</p>
<p>提示和输出：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-operator">&gt;</span> actually undo <span class="hljs-keyword">both</span> the pill <span class="hljs-keyword">and</span> headings. instead, make the todo list render <span class="hljs-keyword">to</span> the <span class="hljs-keyword">right</span> <span class="hljs-keyword">of</span> the input, vertically centered <span class="hljs-keyword">with</span> a grey divider. <span class="hljs-keyword">show</span> it <span class="hljs-keyword">when</span> todos <span class="hljs-keyword">are</span> active, hide it <span class="hljs-keyword">when</span> it<span class="hljs-string">'s done
</span></code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b33d9b316994e6fadd2da2f3df33f63~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=ROprZ%2FFVcnyIqPZbB1R102OfKyc%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #5，todos 作为右侧的"抽屉"。参见动画版本</p>
<pre><code class="hljs language-vbnet" lang="vbnet">&gt; it<span class="hljs-comment">'s a little jumpy, can you also animate it like a drawer</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/91f30daeffe641918fa48d17b9dffac7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=539TtgAXALaVXOnnNfC7Op9FSyY%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #6。参见<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.threads.com%2F%40boris_cherny%2Fpost%2FDOJ7j1yEinY%3Fxmt%3DAQF0ng_THawLvtKm-2ybaug10RNNwXP8l8I2TfS20BW2Vg" target="_blank" title="https://www.threads.com/@boris_cherny/post/DOJ7j1yEinY?xmt=AQF0ng_THawLvtKm-2ybaug10RNNwXP8l8I2TfS20BW2Vg" ref="nofollow noopener noreferrer">动画版本</a></p>
<h4 data-id="heading-20">原型 #7、8 和 9：可见性实验</h4>
<p>为了使 todo 列表尽可能可见，Boris 尝试让它始终显示在输入上方。</p>
<p>提示和输出：</p>
<pre><code class="hljs language-css" lang="css">&gt; actually what if you show the todo list above the <span class="hljs-selector-tag">input</span> instead
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c6602360b6f4f4db46405dd99c44902~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=joiCBqCpOWp0oLmPkB7SU5Zj%2BfA%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #7</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_">&gt; </span><span class="bash"><span class="hljs-built_in">truncate</span> at 5 and show <span class="hljs-string">"... and 4 more"</span> or whatever</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/908a75c22a9d4b7aa468dff622d948e7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=d0LCUFxGxOLdWMCPAtf0ZRAqOfk%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #8</p>
<pre><code class="hljs language-arduino" lang="arduino">&gt; add a heading <span class="hljs-string">"Todo:"</span> in grey text
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b275add6fc442d09ac7e9e820a7353f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=2xElmzWFteWa7eogF2BK2odwhMA%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #9</p>
<h4 data-id="heading-21">原型 #10-20：移动加载动画 UI 元素</h4>
<p>Boris 继续尝试 todo 列表可见性应该放在哪里，经过几个更多的原型后，最终将 todo 列表移到了加载动画，最大化了可见性，并开始感觉良好。经过几次迭代后，他们有了最终公开发布的版本。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8995909d1c604807af8c0a435fcf0054~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=P9N2ZWMzZ62IpyMwSA%2F7UXyU2uU%3D" alt="image.png" loading="lazy"/></p>
<p>在大约原型 #20 时，在尝试了可见性和加载动画后</p>
<h4 data-id="heading-22">再一次迭代</h4>
<p>团队从社区收到了很多反馈，他们希望能够看到所有的 todos。所以团队添加了用 CTRL + T 切换它们的能力。这就是现在实时运行的功能！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d42db374414140a5af5554ad6fe1ea38~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=8fjnf%2FwcecwWUSjMDkuIFeMNAqE%3D" alt="image.png" loading="lazy"/></p>
<p>这个迭代（大约 #21 左右）目前正在生产中——按 Tab 键切换正在执行的步骤列表</p>
<h3 data-id="heading-23">快速原型制作</h3>
<p>每天构建和测试 5-10 个原型想法是可能的，使用 AI agents。原型制作过去非常耗时，如果有两天时间进行原型制作，到结束时能构建两个不同的原型就很幸运了。但现在，agents 可以非常快地构建原型，所以每天测试 5-10 个原型很容易做到，就像 Claude Code 团队所做的那样。</p>
<p>我不建议每个人都能这么快地构建那么多原型，但我认为忘记原型制作过去需要多长时间是明智的：这些工具改变了原型制作可以多快！</p>
<p>这些原型制作中的很多都是关于让 UI"感觉良好"：你可以在这个线程中看到动画原型。我建议观看原型步骤的视频，以了解功能是如何演变的，以及 Boris 如何不断尝试新想法，将其缩小到今天工具中 todo 列表的样子。</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【穿越Effective C++】条款20：宁以pass-by-reference-to-const替换pass-by-value——参数传递的效率与语义]]></title>    <link>https://juejin.cn/post/7573506713866076211</link>    <guid>https://juejin.cn/post/7573506713866076211</guid>    <pubDate>2025-11-17T09:02:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573506713866076211" data-draft-id="7573310642960138278" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【穿越Effective C++】条款20：宁以pass-by-reference-to-const替换pass-by-value——参数传递的效率与语义"/> <meta itemprop="keywords" content="C++,面试"/> <meta itemprop="datePublished" content="2025-11-17T09:02:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="沐怡旸"/> <meta itemprop="url" content="https://juejin.cn/user/2875978146656750"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【穿越Effective C++】条款20：宁以pass-by-reference-to-const替换pass-by-value——参数传递的效率与语义
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2875978146656750/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    沐怡旸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:02:20.000Z" title="Mon Nov 17 2025 09:02:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这个条款揭示了C++函数参数传递的核心优化策略：通过const引用传递可以避免不必要的对象拷贝，同时保持语义的正确性。这是构建高性能C++系统的关键技巧，需要在效率、安全性和表达力之间找到平衡。</p>
<hr/>
<h3 data-id="heading-0"><strong>思维导图：参数传递策略的完整体系</strong></h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc2c977c9e2d4c8b8a2a1a3fd8758f89~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rKQ5oCh5pe4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974940&amp;x-signature=%2B207QpdK5z2kWIuWcOGUy191Xjk%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-1"><strong>关键洞见与行动指南</strong></h3>
<h4 data-id="heading-2"><strong>必须遵守的核心原则：</strong></h4>
<ol>
<li><strong>默认使用const引用</strong>：对于非内置类型，优先使用const引用传递</li>
<li><strong>避免对象切片</strong>：多态基类必须使用引用或指针传递</li>
<li><strong>考虑移动语义</strong>：对于可移动类型，评估传值与移动的权衡</li>
<li><strong>测量性能影响</strong>：基于实际性能数据做出传递策略决策</li>
</ol>
<h4 data-id="heading-3"><strong>现代C++开发建议：</strong></h4>
<ol>
<li><strong>移动语义利用</strong>：对于资源管理类，考虑传值+移动的优化模式</li>
<li><strong>完美转发应用</strong>：模板函数中使用通用引用保持值类别</li>
<li><strong>概念约束使用</strong>：通过概念在编译期选择最优传递策略</li>
<li><strong>拷贝省略依赖</strong>：利用RVO/NRVO优化返回值传递</li>
</ol>
<h4 data-id="heading-4"><strong>设计原则总结：</strong></h4>
<ol>
<li><strong>零开销抽象</strong>：在不牺牲性能的前提下提供高级抽象</li>
<li><strong>语义正确性</strong>：传递方式不应改变程序的逻辑行为</li>
<li><strong>接口清晰性</strong>：参数传递意图应该在接口中明确表达</li>
<li><strong>实践导向</strong>：基于实际性能特征而非理论假设做决策</li>
</ol>
<h4 data-id="heading-5"><strong>需要警惕的陷阱：</strong></h4>
<ol>
<li><strong>悬空引用</strong>：确保引用参数的生命周期覆盖使用范围</li>
<li><strong>意外修改</strong>：正确使用const避免接口契约违反</li>
<li><strong>重载困惑</strong>：避免传值与传引用的重载产生歧义</li>
<li><strong>模板陷阱</strong>：注意模板推导中引用折叠的意外结果</li>
</ol>
<p><strong>最终建议：</strong> 将参数传递策略视为性能优化与代码清晰度的平衡艺术。培养"传递语义思维"——在设计每个函数接口时都思考："这个参数会被修改吗？拷贝成本有多高？需要保持多态吗？" 这种思考方式是构建高效且正确C++代码的关键。</p>
<p>记住：<strong>在C++参数传递中，const引用通常是安全与效率的最佳平衡点，但了解例外情况同样重要。</strong> 条款20教会我们的不仅是一种技术选择，更是对C++对象模型深刻理解的体现。</p>
<hr/>
<h3 data-id="heading-6"><strong>深入解析：参数传递的核心机制</strong></h3>
<h4 data-id="heading-7"><strong>1. 问题根源：传值的隐藏代价</strong></h4>
<p><strong>昂贵的拷贝构造示例：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpensiveToCopy</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ExpensiveToCopy</span>() {
        data_.<span class="hljs-built_in">resize</span>(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 分配大量内存</span>
        std::cout &lt;&lt; <span class="hljs-string">"默认构造"</span> &lt;&lt; std::endl;
    }
    
    <span class="hljs-built_in">ExpensiveToCopy</span>(<span class="hljs-type">const</span> ExpensiveToCopy&amp; other) 
        : <span class="hljs-built_in">data_</span>(other.data_) {
        std::cout &lt;&lt; <span class="hljs-string">"拷贝构造 - 成本高昂!"</span> &lt;&lt; std::endl;
    }
    
    ExpensiveToCopy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ExpensiveToCopy&amp; other) {
        data_ = other.data_;
        std::cout &lt;&lt; <span class="hljs-string">"拷贝赋值 - 成本高昂!"</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    
    ~<span class="hljs-built_in">ExpensiveToCopy</span>() {
        std::cout &lt;&lt; <span class="hljs-string">"析构"</span> &lt;&lt; std::endl;
    }
    
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;
};

<span class="hljs-comment">// 糟糕的传值方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processByValue</span><span class="hljs-params">(ExpensiveToCopy obj)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"processByValue处理中..."</span> &lt;&lt; std::endl;
    <span class="hljs-comment">// 使用obj...</span>
}

<span class="hljs-comment">// 优秀的const引用方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> ExpensiveToCopy&amp; obj)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"processByConstRef处理中..."</span> &lt;&lt; std::endl;
    <span class="hljs-comment">// 使用obj，但不能修改</span>
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_copy_cost</span><span class="hljs-params">()</span> </span>{
    ExpensiveToCopy expensive_obj;
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 传值调用 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processByValue</span>(expensive_obj);  <span class="hljs-comment">// 触发拷贝构造 + 析构</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== const引用调用 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processByConstRef</span>(expensive_obj);  <span class="hljs-comment">// 零拷贝！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 临时对象传值 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processByValue</span>(<span class="hljs-built_in">ExpensiveToCopy</span>());  <span class="hljs-comment">// 默认构造 + 拷贝构造 + 析构×2!</span>
}
</code></pre>
<p><strong>对象切片问题示例：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">printType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Base"</span> &lt;&lt; std::endl;
    }
    
    <span class="hljs-comment">// 虚函数，需要多态行为</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::unique_ptr&lt;Base&gt; <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Base&gt;(*<span class="hljs-keyword">this</span>);
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Derived"</span> &lt;&lt; std::endl;
    }
    
    <span class="hljs-function">std::unique_ptr&lt;Base&gt; <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Derived&gt;(*<span class="hljs-keyword">this</span>);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derivedOnlyMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Derived特有方法"</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-comment">// 错误的传值方式 - 导致切片</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processBaseByValue</span><span class="hljs-params">(Base base)</span> </span>{
    base.<span class="hljs-built_in">printType</span>();  <span class="hljs-comment">// 总是输出"Base"，丢失多态！</span>
    
    <span class="hljs-comment">// 无法调用derivedOnlyMethod，即使传递的是Derived对象</span>
    <span class="hljs-comment">// base.derivedOnlyMethod();  // 编译错误！</span>
}

<span class="hljs-comment">// 正确的const引用方式 - 保持多态</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processBaseByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; base)</span> </span>{
    base.<span class="hljs-built_in">printType</span>();  <span class="hljs-comment">// 正确输出实际类型！</span>
    
    <span class="hljs-comment">// 可以安全地进行向下转型</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> derived = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> Derived*&gt;(&amp;base)) {
        derived-&gt;<span class="hljs-built_in">derivedOnlyMethod</span>();  <span class="hljs-comment">// 可以调用派生类方法</span>
    }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_slicing_problem</span><span class="hljs-params">()</span> </span>{
    Derived derived_obj;
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 传值导致切片 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processBaseByValue</span>(derived_obj);  <span class="hljs-comment">// 输出"Base" - 切片发生！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== const引用保持多态 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processBaseByConstRef</span>(derived_obj);  <span class="hljs-comment">// 输出"Derived" - 多态保持！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 临时对象多态测试 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processBaseByConstRef</span>(<span class="hljs-built_in">Derived</span>());  <span class="hljs-comment">// 输出"Derived" - 仍然多态！</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-8"><strong>解决方案：const引用传递</strong></h3>
<h4 data-id="heading-9"><strong>1. 基本const引用模式</strong></h4>
<p><strong>高效的对象传递：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Customer</span>(std::string name, <span class="hljs-type">int</span> id) 
        : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(name)), <span class="hljs-built_in">id_</span>(id) {}
    
    <span class="hljs-comment">// const引用访问器</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> name_; }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> id_; }
    
    <span class="hljs-comment">// 修改方法 - 非const引用返回</span>
    <span class="hljs-function">std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> name_; }
    
<span class="hljs-keyword">private</span>:
    std::string name_;
    <span class="hljs-type">int</span> id_;
};

<span class="hljs-comment">// 优秀的const引用接口设计</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 只读访问 - const引用</span>
    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculateTotal</span><span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; customer, 
                         <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; items)</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-type">double</span> total = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; price : items) {  <span class="hljs-comment">// 容器也使用const引用</span>
            total += price;
        }
        
        <span class="hljs-comment">// 可以读取customer但不能修改</span>
        std::cout &lt;&lt; <span class="hljs-string">"为客户 "</span> &lt;&lt; customer.<span class="hljs-built_in">getName</span>() 
                  &lt;&lt; <span class="hljs-string">" 计算总额: "</span> &lt;&lt; total &lt;&lt; std::endl;
        
        <span class="hljs-keyword">return</span> total;
    }
    
    <span class="hljs-comment">// 需要修改对象 - 非const引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateCustomerName</span><span class="hljs-params">(Customer&amp; customer, <span class="hljs-type">const</span> std::string&amp; newName)</span> </span>{
        customer.<span class="hljs-built_in">getName</span>() = newName;  <span class="hljs-comment">// 调用非const版本</span>
    }
    
    <span class="hljs-comment">// 多个相关对象的const引用</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateOrder</span><span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; customer,
                      <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; items,
                      <span class="hljs-type">const</span> std::string&amp; paymentMethod)</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">if</span> (items.<span class="hljs-built_in">empty</span>()) {
            std::cout &lt;&lt; customer.<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">" 的订单为空"</span> &lt;&lt; std::endl;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        
        <span class="hljs-keyword">if</span> (paymentMethod != <span class="hljs-string">"信用卡"</span> &amp;&amp; paymentMethod != <span class="hljs-string">"支付宝"</span>) {
            std::cout &lt;&lt; <span class="hljs-string">"不支持的支付方式: "</span> &lt;&lt; paymentMethod &lt;&lt; std::endl;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};

<span class="hljs-comment">// 标准库算法的const引用使用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_std_algorithm</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Customer&gt;&amp; customers)</span> </span>{
    <span class="hljs-comment">// 查找特定客户 - 谓词使用const引用</span>
    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(customers.<span class="hljs-built_in">begin</span>(), customers.<span class="hljs-built_in">end</span>(),
        [](<span class="hljs-type">const</span> Customer&amp; cust) {  <span class="hljs-comment">// const引用捕获</span>
            <span class="hljs-keyword">return</span> cust.<span class="hljs-built_in">getName</span>() == <span class="hljs-string">"张三"</span>;
        });
    
    <span class="hljs-keyword">if</span> (it != customers.<span class="hljs-built_in">end</span>()) {
        std::cout &lt;&lt; <span class="hljs-string">"找到客户: "</span> &lt;&lt; it-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;
    }
    
    <span class="hljs-comment">// 排序客户 - 比较器使用const引用</span>
    std::vector&lt;Customer&gt; sorted_customers = customers;
    std::<span class="hljs-built_in">sort</span>(sorted_customers.<span class="hljs-built_in">begin</span>(), sorted_customers.<span class="hljs-built_in">end</span>(),
        [](<span class="hljs-type">const</span> Customer&amp; a, <span class="hljs-type">const</span> Customer&amp; b) {
            <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">getId</span>() &lt; b.<span class="hljs-built_in">getId</span>();
        });
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_const_reference</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Customer <span class="hljs-title">customer</span><span class="hljs-params">(<span class="hljs-string">"李四"</span>, <span class="hljs-number">1001</span>)</span></span>;
    std::vector&lt;<span class="hljs-type">double</span>&gt; items = {<span class="hljs-number">19.99</span>, <span class="hljs-number">29.99</span>, <span class="hljs-number">9.99</span>};
    
    OrderProcessor processor;
    
    <span class="hljs-comment">// const引用调用 - 高效且安全</span>
    <span class="hljs-type">double</span> total = processor.<span class="hljs-built_in">calculateTotal</span>(customer, items);
    std::cout &lt;&lt; <span class="hljs-string">"订单总额: "</span> &lt;&lt; total &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 验证订单</span>
    <span class="hljs-type">bool</span> valid = processor.<span class="hljs-built_in">validateOrder</span>(customer, items, <span class="hljs-string">"支付宝"</span>);
    std::cout &lt;&lt; <span class="hljs-string">"订单验证: "</span> &lt;&lt; (valid ? <span class="hljs-string">"通过"</span> : <span class="hljs-string">"失败"</span>) &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 需要修改时使用非const引用</span>
    processor.<span class="hljs-built_in">updateCustomerName</span>(customer, <span class="hljs-string">"王五"</span>);
    std::cout &lt;&lt; <span class="hljs-string">"更新后姓名: "</span> &lt;&lt; customer.<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 容器操作演示</span>
    std::vector&lt;Customer&gt; customers = {
        <span class="hljs-built_in">Customer</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-number">1002</span>),
        <span class="hljs-built_in">Customer</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-number">1001</span>),
        <span class="hljs-built_in">Customer</span>(<span class="hljs-string">"王五"</span>, <span class="hljs-number">1003</span>)
    };
    
    <span class="hljs-built_in">demonstrate_std_algorithm</span>(customers);
}
</code></pre>
<h4 data-id="heading-10"><strong>2. 移动语义的现代方法</strong></h4>
<p><strong>传值+移动的优化模式：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernStringProcessor</span> {
<span class="hljs-keyword">private</span>:
    std::string data_;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 传统方式：const引用 + 拷贝</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>{
        data_ = data;  <span class="hljs-comment">// 拷贝赋值</span>
    }
    
    <span class="hljs-comment">// 改进方式：重载const引用和右值引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataOverloaded</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>{
        data_ = data;  <span class="hljs-comment">// 拷贝</span>
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataOverloaded</span><span class="hljs-params">(std::string&amp;&amp; data)</span> </span>{
        data_ = std::<span class="hljs-built_in">move</span>(data);  <span class="hljs-comment">// 移动</span>
    }
    
    <span class="hljs-comment">// 现代方式：传值 + 移动（对于移动成本低的类型）</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataByValue</span><span class="hljs-params">(std::string data)</span> </span>{
        data_ = std::<span class="hljs-built_in">move</span>(data);  <span class="hljs-comment">// 移动赋值</span>
    }
    
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> data_; }
};

<span class="hljs-comment">// 资源管理类的移动优化</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceHolder</span> {
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; resources_;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 对于已知要存储的参数，传值可能更优</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addResource</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; new_resources)</span> </span>{
        <span class="hljs-keyword">if</span> (resources_.<span class="hljs-built_in">empty</span>()) {
            resources_ = std::<span class="hljs-built_in">move</span>(new_resources);  <span class="hljs-comment">// 移动</span>
        } <span class="hljs-keyword">else</span> {
            resources_.<span class="hljs-built_in">insert</span>(resources_.<span class="hljs-built_in">end</span>(),
                            new_resources.<span class="hljs-built_in">begin</span>(), new_resources.<span class="hljs-built_in">end</span>());
        }
    }
    
    <span class="hljs-comment">// 只读访问仍然使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsResource</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">find</span>(resources_.<span class="hljs-built_in">begin</span>(), resources_.<span class="hljs-built_in">end</span>(), value) 
               != resources_.<span class="hljs-built_in">end</span>();
    }
    
    <span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; <span class="hljs-title">getResources</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> resources_; }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_move_semantics</span><span class="hljs-params">()</span> </span>{
    ModernStringProcessor processor;
    std::string large_data = <span class="hljs-string">"这是一个很长的字符串..."</span>;
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 测试各种传递方式 ==="</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 左值传递测试</span>
    std::cout &lt;&lt; <span class="hljs-string">"左值传递:"</span> &lt;&lt; std::endl;
    processor.<span class="hljs-built_in">setDataByConstRef</span>(large_data);        <span class="hljs-comment">// 拷贝</span>
    processor.<span class="hljs-built_in">setDataOverloaded</span>(large_data);        <span class="hljs-comment">// 拷贝</span>
    processor.<span class="hljs-built_in">setDataByValue</span>(large_data);           <span class="hljs-comment">// 拷贝</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"数据: "</span> &lt;&lt; processor.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 右值传递测试</span>
    std::cout &lt;&lt; <span class="hljs-string">"右值传递:"</span> &lt;&lt; std::endl;
    processor.<span class="hljs-built_in">setDataByConstRef</span>(<span class="hljs-string">"临时字符串"</span>);      <span class="hljs-comment">// 构造 + 拷贝</span>
    processor.<span class="hljs-built_in">setDataOverloaded</span>(<span class="hljs-string">"临时字符串"</span>);      <span class="hljs-comment">// 构造 + 移动</span>
    processor.<span class="hljs-built_in">setDataByValue</span>(<span class="hljs-string">"临时字符串"</span>);         <span class="hljs-comment">// 构造 + 移动</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"数据: "</span> &lt;&lt; processor.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 显式移动测试</span>
    std::cout &lt;&lt; <span class="hljs-string">"显式移动:"</span> &lt;&lt; std::endl;
    std::string movable_data = <span class="hljs-string">"可移动数据"</span>;
    processor.<span class="hljs-built_in">setDataByValue</span>(std::<span class="hljs-built_in">move</span>(movable_data));  <span class="hljs-comment">// 移动</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"数据: "</span> &lt;&lt; processor.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"移动后源数据: "</span> &lt;&lt; movable_data &lt;&lt; std::endl;  <span class="hljs-comment">// 有效但未指定状态</span>
    
    <span class="hljs-comment">// 资源持有者测试</span>
    ResourceHolder holder;
    std::vector&lt;<span class="hljs-type">int</span>&gt; resources = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    
    holder.<span class="hljs-built_in">addResource</span>(std::<span class="hljs-built_in">move</span>(resources));  <span class="hljs-comment">// 高效移动</span>
    std::cout &lt;&lt; <span class="hljs-string">"资源数量: "</span> &lt;&lt; holder.<span class="hljs-built_in">getResources</span>().<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;
}
</code></pre>
<hr/>
<h3 data-id="heading-11"><strong>适用场景与例外情况</strong></h3>
<h4 data-id="heading-12"><strong>1. 内置类型与小型对象</strong></h4>
<p><strong>传值更优的场景：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-comment">// 内置类型 - 传值更高效</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtils</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 内置类型直接传值</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">calculateDistance</span><span class="hljs-params">(<span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> y1, 
                                   <span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y2)</span> </span>{
        <span class="hljs-type">double</span> dx = x2 - x1;
        <span class="hljs-type">double</span> dy = y2 - y1;
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">sqrt</span>(dx * dx + dy * dy);
    }
    
    <span class="hljs-comment">// 小型的、拷贝成本低的结构体</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {
        <span class="hljs-type">double</span> x, y;
        
        <span class="hljs-comment">// 平凡拷贝构造，传值可能更好</span>
        <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) {}
    };
    
    <span class="hljs-comment">// 对于小型Point，传值可能比传引用更高效</span>
    <span class="hljs-function"><span class="hljs-type">static</span> Point <span class="hljs-title">midpoint</span><span class="hljs-params">(Point p1, Point p2)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>((p1.x + p2.x) / <span class="hljs-number">2</span>, (p1.y + p2.y) / <span class="hljs-number">2</span>);
    }
};

<span class="hljs-comment">// 编译期类型特性判断</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">smartPass</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_fundamental_v&lt;std::<span class="hljs-type">decay_t</span>&lt;T&gt;&gt;)</span> </span>{
        <span class="hljs-comment">// 内置类型：可以考虑传值</span>
        <span class="hljs-built_in">processFundamental</span>(std::forward&lt;T&gt;(param));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_trivially_copyable_v&lt;std::<span class="hljs-type">decay_t</span>&lt;T&gt;&gt; &amp;&amp; 
                        <span class="hljs-built_in">sizeof</span>(std::<span class="hljs-type">decay_t</span>&lt;T&gt;) &lt;= <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)) {
        <span class="hljs-comment">// 小型平凡类型：可以考虑传值</span>
        <span class="hljs-built_in">processSmallTrivial</span>(std::forward&lt;T&gt;(param));
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 其他类型：使用引用</span>
        <span class="hljs-built_in">processByReference</span>(std::forward&lt;T&gt;(param));
    }
}

<span class="hljs-comment">// 接口设计的最佳实践</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Configuration</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 内置类型传值</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTimeout</span><span class="hljs-params">(<span class="hljs-type">int</span> milliseconds)</span> </span>{
        timeout_ = milliseconds;
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPrecision</span><span class="hljs-params">(<span class="hljs-type">double</span> precision)</span> </span>{
        precision_ = precision;
    }
    
    <span class="hljs-comment">// 字符串使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>{
        name_ = name;
    }
    
    <span class="hljs-comment">// 或者使用传值+移动</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDescription</span><span class="hljs-params">(std::string description)</span> </span>{
        description_ = std::<span class="hljs-built_in">move</span>(description);
    }
    
    <span class="hljs-comment">// 返回const引用避免拷贝</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> name_; }
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> description_; }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> timeout_ = <span class="hljs-number">1000</span>;
    <span class="hljs-type">double</span> precision_ = <span class="hljs-number">0.001</span>;
    std::string name_;
    std::string description_;
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_appropriate_usage</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">MathUtils::Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span></span>;
    <span class="hljs-function">MathUtils::Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>)</span></span>;
    
    <span class="hljs-comment">// 小型对象传值 - 可能更高效</span>
    <span class="hljs-keyword">auto</span> mid = MathUtils::<span class="hljs-built_in">midpoint</span>(p1, p2);
    std::cout &lt;&lt; <span class="hljs-string">"中点: ("</span> &lt;&lt; mid.x &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; mid.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 内置类型传值</span>
    <span class="hljs-type">double</span> dist = MathUtils::<span class="hljs-built_in">calculateDistance</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
    std::cout &lt;&lt; <span class="hljs-string">"距离: "</span> &lt;&lt; dist &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 配置对象使用</span>
    Configuration config;
    config.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-number">5000</span>);           <span class="hljs-comment">// 内置类型传值</span>
    config.<span class="hljs-built_in">setPrecision</span>(<span class="hljs-number">0.0001</span>);       <span class="hljs-comment">// 内置类型传值</span>
    config.<span class="hljs-built_in">setName</span>(<span class="hljs-string">"高性能服务器"</span>);     <span class="hljs-comment">// const引用</span>
    config.<span class="hljs-built_in">setDescription</span>(<span class="hljs-string">"这是服务器的详细配置描述"</span>); <span class="hljs-comment">// 传值+移动</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"配置名称: "</span> &lt;&lt; config.<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;
}
</code></pre>
<h4 data-id="heading-13"><strong>2. 标准库容器的传递策略</strong></h4>
<p><strong>容器参数的最佳实践：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 只读访问容器 - const引用</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">calculateAverage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data)</span> </span>{
        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;
        
        <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; value : data) {  <span class="hljs-comment">// const引用遍历</span>
            sum += value;
        }
        <span class="hljs-keyword">return</span> sum / data.<span class="hljs-built_in">size</span>();
    }
    
    <span class="hljs-comment">// 需要修改容器 - 非const引用</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">normalizeData</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data)</span> </span>{
        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;
        
        <span class="hljs-type">double</span> avg = <span class="hljs-built_in">calculateAverage</span>(data);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; value : data) {  <span class="hljs-comment">// 非const引用修改</span>
            value -= avg;
        }
    }
    
    <span class="hljs-comment">// 创建新容器 - 考虑返回值优化</span>
    <span class="hljs-function"><span class="hljs-type">static</span> std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">filterPositive</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data)</span> </span>{
        std::vector&lt;<span class="hljs-type">double</span>&gt; result;
        std::<span class="hljs-built_in">copy_if</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">back_inserter</span>(result),
                    [](<span class="hljs-type">double</span> value) { <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">0</span>; });
        <span class="hljs-keyword">return</span> result;  <span class="hljs-comment">// 依赖RVO</span>
    }
    
    <span class="hljs-comment">// 大型容器的只读处理 - 始终使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">concatenateAll</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; strings)</span> </span>{
        std::string result;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; str : strings) {
            result += str;
        }
        <span class="hljs-keyword">return</span> result;
    }
};

<span class="hljs-comment">// 模板容器算法</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">findMaxValue</span><span class="hljs-params">(<span class="hljs-type">const</span> Container&amp; container)</span> -&gt; <span class="hljs-keyword">typename</span> Container::value_type </span>{
    <span class="hljs-keyword">if</span> (container.<span class="hljs-built_in">empty</span>()) {
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">"容器为空"</span>);
    }
    
    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">max_element</span>(container.<span class="hljs-built_in">begin</span>(), container.<span class="hljs-built_in">end</span>());
    <span class="hljs-keyword">return</span> *it;  <span class="hljs-comment">// 返回值的拷贝（假设value_type较小）</span>
}

<span class="hljs-comment">// 对于可能很大的返回值，提供引用版本</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">findMaxElement</span><span class="hljs-params">(<span class="hljs-type">const</span> Container&amp; container)</span> -&gt; <span class="hljs-type">const</span> <span class="hljs-keyword">typename</span> Container::value_type&amp; </span>{
    <span class="hljs-keyword">if</span> (container.<span class="hljs-built_in">empty</span>()) {
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">"容器为空"</span>);
    }
    
    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">max_element</span>(container.<span class="hljs-built_in">begin</span>(), container.<span class="hljs-built_in">end</span>());
    <span class="hljs-keyword">return</span> *it;  <span class="hljs-comment">// 返回const引用</span>
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_container_passing</span><span class="hljs-params">()</span> </span>{
    std::vector&lt;<span class="hljs-type">double</span>&gt; data = {<span class="hljs-number">1.5</span>, <span class="hljs-number">-2.3</span>, <span class="hljs-number">3.7</span>, <span class="hljs-number">-0.8</span>, <span class="hljs-number">4.1</span>};
    std::vector&lt;std::string&gt; strings = {<span class="hljs-string">"Hello"</span>, <span class="hljs-string">" "</span>, <span class="hljs-string">"World"</span>, <span class="hljs-string">"!"</span>};
    
    <span class="hljs-comment">// 只读处理 - const引用</span>
    <span class="hljs-type">double</span> avg = DataProcessor::<span class="hljs-built_in">calculateAverage</span>(data);
    std::cout &lt;&lt; <span class="hljs-string">"平均值: "</span> &lt;&lt; avg &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 修改处理 - 非const引用</span>
    DataProcessor::<span class="hljs-built_in">normalizeData</span>(data);
    std::cout &lt;&lt; <span class="hljs-string">"标准化后平均值: "</span> &lt;&lt; DataProcessor::<span class="hljs-built_in">calculateAverage</span>(data) &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 创建新容器 - 依赖RVO</span>
    <span class="hljs-keyword">auto</span> positive_data = DataProcessor::<span class="hljs-built_in">filterPositive</span>(data);
    std::cout &lt;&lt; <span class="hljs-string">"正数数量: "</span> &lt;&lt; positive_data.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 字符串拼接 - const引用避免拷贝</span>
    std::string concatenated = DataProcessor::<span class="hljs-built_in">concatenateAll</span>(strings);
    std::cout &lt;&lt; <span class="hljs-string">"拼接结果: "</span> &lt;&lt; concatenated &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 模板算法使用</span>
    <span class="hljs-type">double</span> max_val = <span class="hljs-built_in">findMaxValue</span>(data);
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; max_ref = <span class="hljs-built_in">findMaxElement</span>(data);  <span class="hljs-comment">// 避免拷贝</span>
    std::cout &lt;&lt; <span class="hljs-string">"最大值: "</span> &lt;&lt; max_val &lt;&lt; <span class="hljs-string">" (引用: "</span> &lt;&lt; max_ref &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; std::endl;
}
</code></pre>
<hr/>
<h3 data-id="heading-14"><strong>高级技巧与陷阱防范</strong></h3>
<h4 data-id="heading-15"><strong>1. 完美转发与通用引用</strong></h4>
<p><strong>现代C++的转发技术：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedProcessor</span> {
<span class="hljs-keyword">private</span>:
    std::string stored_value_;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 通用引用 + 完美转发</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T&amp;&amp; value)</span> </span>{
        stored_value_ = std::forward&lt;T&gt;(value);
        
        std::cout &lt;&lt; <span class="hljs-string">"设置值: "</span> &lt;&lt; stored_value_;
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_lvalue_reference_v&lt;T&amp;&amp;&gt;)</span> </span>{
            std::cout &lt;&lt; <span class="hljs-string">" (左值)"</span> &lt;&lt; std::endl;
        } <span class="hljs-keyword">else</span> {
            std::cout &lt;&lt; <span class="hljs-string">" (右值)"</span> &lt;&lt; std::endl;
        }
    }
    
    <span class="hljs-comment">// 带约束的通用引用</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    std::<span class="hljs-type">enable_if_t</span>&lt;std::is_constructible_v&lt;std::string, T&gt;&gt;
    <span class="hljs-built_in">setValueConstrained</span>(T&amp;&amp; value) {
        stored_value_ = std::forward&lt;T&gt;(value);
    }
    
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> stored_value_; }
};

<span class="hljs-comment">// 工厂函数中的完美转发</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;
std::unique_ptr&lt;T&gt; <span class="hljs-title">createObject</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;T&gt;(std::forward&lt;Args&gt;(args)...);
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ExampleClass</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> value) 
        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">value_</span>(value) {
        std::cout &lt;&lt; <span class="hljs-string">"ExampleClass构造: "</span> &lt;&lt; name_ &lt;&lt; std::endl;
    }
    
    <span class="hljs-built_in">ExampleClass</span>(std::string&amp;&amp; name, <span class="hljs-type">int</span> value) 
        : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(name)), <span class="hljs-built_in">value_</span>(value) {
        std::cout &lt;&lt; <span class="hljs-string">"ExampleClass移动构造: "</span> &lt;&lt; name_ &lt;&lt; std::endl;
    }
    
<span class="hljs-keyword">private</span>:
    std::string name_;
    <span class="hljs-type">int</span> value_;
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_perfect_forwarding</span><span class="hljs-params">()</span> </span>{
    AdvancedProcessor processor;
    std::string name = <span class="hljs-string">"测试名称"</span>;
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 完美转发演示 ==="</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 左值传递</span>
    processor.<span class="hljs-built_in">setValue</span>(name);                    <span class="hljs-comment">// 拷贝</span>
    std::cout &lt;&lt; <span class="hljs-string">"原值: "</span> &lt;&lt; name &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 右值传递</span>
    processor.<span class="hljs-built_in">setValue</span>(<span class="hljs-string">"临时字符串"</span>);            <span class="hljs-comment">// 移动</span>
    processor.<span class="hljs-built_in">setValue</span>(std::<span class="hljs-built_in">move</span>(name));         <span class="hljs-comment">// 移动</span>
    std::cout &lt;&lt; <span class="hljs-string">"移动后原值: "</span> &lt;&lt; name &lt;&lt; std::endl;  <span class="hljs-comment">// 有效但未指定状态</span>
    
    <span class="hljs-comment">// 工厂函数使用</span>
    <span class="hljs-keyword">auto</span> obj1 = <span class="hljs-built_in">createObject</span>&lt;ExampleClass&gt;(<span class="hljs-string">"对象1"</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">// 可能移动构造</span>
    <span class="hljs-keyword">auto</span> obj2 = <span class="hljs-built_in">createObject</span>&lt;ExampleClass&gt;(name, <span class="hljs-number">200</span>);     <span class="hljs-comment">// 拷贝构造</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 带约束的转发 ==="</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 只有能构造std::string的类型才被接受</span>
    processor.<span class="hljs-built_in">setValueConstrained</span>(<span class="hljs-string">"字符串字面量"</span>);  <span class="hljs-comment">// OK</span>
    processor.<span class="hljs-built_in">setValueConstrained</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"临时"</span>)); <span class="hljs-comment">// OK</span>
    <span class="hljs-comment">// processor.setValueConstrained(42);  // 编译错误！不能从int构造string</span>
}
</code></pre>
<h4 data-id="heading-16"><strong>2. 生命周期管理与陷阱防范</strong></h4>
<p><strong>悬空引用预防：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DangerousReferences</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 危险的接口：返回内部数据的引用</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> data_; }
    
    <span class="hljs-comment">// 更安全的接口：返回拷贝或共享指针</span>
    <span class="hljs-function">std::string <span class="hljs-title">getDataCopy</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> data_; }
    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">const</span> std::string&gt; <span class="hljs-title">getDataShared</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">const</span> std::string&gt;(data_);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>{ data_ = data; }
    
<span class="hljs-keyword">private</span>:
    std::string data_ = <span class="hljs-string">"默认数据"</span>;
};

<span class="hljs-comment">// 悬空引用的典型场景</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CallbackManager</span> {
<span class="hljs-keyword">private</span>:
    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">const</span> std::string&amp;)&gt; callback_;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">const</span> std::string&amp;)&gt;&amp; callback)</span> </span>{
        callback_ = callback;
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>{
        <span class="hljs-keyword">if</span> (callback_) {
            <span class="hljs-built_in">callback_</span>(input);
        }
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_dangling_reference</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"=== 悬空引用演示 ==="</span> &lt;&lt; std::endl;
    
    DangerousReferences obj;
    
    <span class="hljs-comment">// 安全的用法</span>
    std::string safe_copy = obj.<span class="hljs-built_in">getDataCopy</span>();
    <span class="hljs-keyword">auto</span> shared_data = obj.<span class="hljs-built_in">getDataShared</span>();
    
    <span class="hljs-comment">// 潜在的危险用法</span>
    <span class="hljs-type">const</span> std::string&amp; dangerous_ref = obj.<span class="hljs-built_in">getData</span>();
    obj.<span class="hljs-built_in">setData</span>(<span class="hljs-string">"新数据"</span>);  <span class="hljs-comment">// dangerous_ref可能悬空！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"安全拷贝: "</span> &lt;&lt; safe_copy &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"共享数据: "</span> &lt;&lt; *shared_data &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"危险引用: "</span> &lt;&lt; dangerous_ref &lt;&lt; std::endl;  <span class="hljs-comment">// 可能有问题！</span>
    
    <span class="hljs-comment">// 回调中的生命周期问题</span>
    CallbackManager manager;
    
    {
        std::string local_data = <span class="hljs-string">"局部数据"</span>;
        
        <span class="hljs-comment">// 捕获局部变量的引用 - 危险！</span>
        manager.<span class="hljs-built_in">setCallback</span>([&amp;](<span class="hljs-type">const</span> std::string&amp; input) {
            std::cout &lt;&lt; <span class="hljs-string">"回调处理: "</span> &lt;&lt; local_data &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; input &lt;&lt; std::endl;
        });
        
        manager.<span class="hljs-built_in">processData</span>(<span class="hljs-string">"输入数据"</span>);  <span class="hljs-comment">// 此时还安全</span>
    }  <span class="hljs-comment">// local_data离开作用域，被销毁</span>
    
    <span class="hljs-comment">// 此时回调中的local_data已经悬空！</span>
    <span class="hljs-comment">// manager.processData("再次输入");  // 未定义行为！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 安全的回调设计 ==="</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 安全的回调：通过值捕获或共享所有权</span>
    <span class="hljs-keyword">auto</span> safe_data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"安全数据"</span>);
    
    manager.<span class="hljs-built_in">setCallback</span>([safe_data](<span class="hljs-type">const</span> std::string&amp; input) {
        std::cout &lt;&lt; <span class="hljs-string">"安全回调: "</span> &lt;&lt; *safe_data &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; input &lt;&lt; std::endl;
    });
    
    manager.<span class="hljs-built_in">processData</span>(<span class="hljs-string">"安全输入"</span>);  <span class="hljs-comment">// 始终安全</span>
}

<span class="hljs-comment">// 返回局部对象引用的错误模式</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">WrongFactory</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 错误：返回局部对象的引用</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">createBadString</span><span class="hljs-params">()</span> </span>{
        std::string local = <span class="hljs-string">"局部字符串"</span>;
        <span class="hljs-keyword">return</span> local;  <span class="hljs-comment">// 返回悬空引用！</span>
    }
    
    <span class="hljs-comment">// 正确：返回值</span>
    <span class="hljs-function">std::string <span class="hljs-title">createGoodString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"安全字符串"</span>;  <span class="hljs-comment">// 返回值优化</span>
    }
    
    <span class="hljs-comment">// 正确：返回静态对象的引用</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getStaticString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">static</span> std::string static_str = <span class="hljs-string">"静态字符串"</span>;
        <span class="hljs-keyword">return</span> static_str;  <span class="hljs-comment">// 安全：静态对象生命周期到程序结束</span>
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_lifetime_management</span><span class="hljs-params">()</span> </span>{
    WrongFactory factory;
    
    <span class="hljs-comment">// 危险的调用</span>
    <span class="hljs-comment">// const auto&amp; bad_ref = factory.createBadString();  // 悬空引用！</span>
    <span class="hljs-comment">// std::cout &lt;&lt; bad_ref &lt;&lt; std::endl;  // 未定义行为</span>
    
    <span class="hljs-comment">// 安全的调用</span>
    <span class="hljs-keyword">auto</span> good_str = factory.<span class="hljs-built_in">createGoodString</span>();  <span class="hljs-comment">// 拷贝或移动</span>
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; static_ref = factory.<span class="hljs-built_in">getStaticString</span>();  <span class="hljs-comment">// 静态引用安全</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"好字符串: "</span> &lt;&lt; good_str &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"静态引用: "</span> &lt;&lt; static_ref &lt;&lt; std::endl;
}
</code></pre>
<hr/>
<h3 data-id="heading-17"><strong>性能测试与权衡决策</strong></h3>
<h4 data-id="heading-18"><strong>1. 实际性能测量</strong></h4>
<p><strong>基准测试示例：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceTest</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LargeData</span> {
        std::vector&lt;<span class="hljs-type">int</span>&gt; data;
        
        <span class="hljs-built_in">LargeData</span>() {
            data.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10000</span>, <span class="hljs-number">42</span>);  <span class="hljs-comment">// 大量数据</span>
        }
        
        <span class="hljs-comment">// 拷贝成本很高</span>
        <span class="hljs-built_in">LargeData</span>(<span class="hljs-type">const</span> LargeData&amp; other) : <span class="hljs-built_in">data</span>(other.data) {
            <span class="hljs-comment">// 模拟昂贵的拷贝</span>
        }
    };
    
    <span class="hljs-comment">// 传值版本</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">processByValue</span><span class="hljs-params">(LargeData data)</span> </span>{
        <span class="hljs-comment">// 一些处理...</span>
        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : data.data) {
            sum += val;
        }
    }
    
    <span class="hljs-comment">// const引用版本</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">processByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> LargeData&amp; data)</span> </span>{
        <span class="hljs-comment">// 相同的处理...</span>
        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : data.data) {
            sum += val;
        }
    }
    
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">runBenchmark</span><span class="hljs-params">()</span> </span>{
        LargeData test_data;
        <span class="hljs-type">const</span> <span class="hljs-type">int</span> iterations = <span class="hljs-number">1000</span>;
        
        std::cout &lt;&lt; <span class="hljs-string">"=== 性能基准测试 ==="</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"数据大小: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(test_data) &lt;&lt; <span class="hljs-string">" 字节"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"迭代次数: "</span> &lt;&lt; iterations &lt;&lt; std::endl;
        
        <span class="hljs-comment">// 测试传值性能</span>
        <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; ++i) {
            <span class="hljs-built_in">processByValue</span>(test_data);
        }
        <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">auto</span> value_duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);
        
        <span class="hljs-comment">// 测试const引用性能</span>
        start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; ++i) {
            <span class="hljs-built_in">processByConstRef</span>(test_data);
        }
        end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">auto</span> ref_duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);
        
        std::cout &lt;&lt; <span class="hljs-string">"传值耗时: "</span> &lt;&lt; value_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" μs"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"引用耗时: "</span> &lt;&lt; ref_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" μs"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"性能提升: "</span> 
                  &lt;&lt; (value_duration.<span class="hljs-built_in">count</span>() - ref_duration.<span class="hljs-built_in">count</span>()) * <span class="hljs-number">100.0</span> / value_duration.<span class="hljs-built_in">count</span>()
                  &lt;&lt; <span class="hljs-string">"%"</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-comment">// 小型对象的性能测试</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallObjectTest</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SmallData</span> {
        <span class="hljs-type">int</span> x, y, z;
        <span class="hljs-comment">// 小型平凡类型</span>
    };
    
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">processSmallByValue</span><span class="hljs-params">(SmallData data)</span> </span>{
        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> result = data.x + data.y + data.z;
    }
    
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">processSmallByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> SmallData&amp; data)</span> </span>{
        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> result = data.x + data.y + data.z;
    }
    
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">runBenchmark</span><span class="hljs-params">()</span> </span>{
        SmallData small_data{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
        <span class="hljs-type">const</span> <span class="hljs-type">int</span> iterations = <span class="hljs-number">1000000</span>;  <span class="hljs-comment">// 更多迭代以显示差异</span>
        
        std::cout &lt;&lt; <span class="hljs-string">"\n=== 小型对象性能测试 ==="</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"数据大小: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(small_data) &lt;&lt; <span class="hljs-string">" 字节"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"迭代次数: "</span> &lt;&lt; iterations &lt;&lt; std::endl;
        
        <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; ++i) {
            <span class="hljs-built_in">processSmallByValue</span>(small_data);
        }
        <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">auto</span> value_duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);
        
        start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; ++i) {
            <span class="hljs-built_in">processSmallByConstRef</span>(small_data);
        }
        end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">auto</span> ref_duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);
        
        std::cout &lt;&lt; <span class="hljs-string">"传值耗时: "</span> &lt;&lt; value_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" μs"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"引用耗时: "</span> &lt;&lt; ref_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" μs"</span> &lt;&lt; std::endl;
        
        <span class="hljs-keyword">if</span> (value_duration.<span class="hljs-built_in">count</span>() &lt; ref_duration.<span class="hljs-built_in">count</span>()) {
            std::cout &lt;&lt; <span class="hljs-string">"传值更快，优势: "</span>
                      &lt;&lt; (ref_duration.<span class="hljs-built_in">count</span>() - value_duration.<span class="hljs-built_in">count</span>()) * <span class="hljs-number">100.0</span> / ref_duration.<span class="hljs-built_in">count</span>()
                      &lt;&lt; <span class="hljs-string">"%"</span> &lt;&lt; std::endl;
        } <span class="hljs-keyword">else</span> {
            std::cout &lt;&lt; <span class="hljs-string">"引用更快，优势: "</span>
                      &lt;&lt; (value_duration.<span class="hljs-built_in">count</span>() - ref_duration.<span class="hljs-built_in">count</span>()) * <span class="hljs-number">100.0</span> / value_duration.<span class="hljs-built_in">count</span>()
                      &lt;&lt; <span class="hljs-string">"%"</span> &lt;&lt; std::endl;
        }
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_performance_measurement</span><span class="hljs-params">()</span> </span>{
    PerformanceTest::<span class="hljs-built_in">runBenchmark</span>();
    SmallObjectTest::<span class="hljs-built_in">runBenchmark</span>();
}
</code></pre>
<h4 data-id="heading-19"><strong>2. 实际应用总结</strong></h4>
<p><strong>最终决策框架：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-comment">// 编译期传递策略选择</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PassStrategy</span> {
    <span class="hljs-comment">// 默认策略：对于未知类型使用const引用</span>
    <span class="hljs-keyword">using</span> type = <span class="hljs-type">const</span> T&amp;;
};

<span class="hljs-comment">// 特化：内置类型使用传值</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PassStrategy</span>&lt;T, std::<span class="hljs-type">enable_if_t</span>&lt;std::is_fundamental_v&lt;T&gt;&gt;&gt; {
    <span class="hljs-keyword">using</span> type = T;
};

<span class="hljs-comment">// 特化：小型平凡类型使用传值</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PassStrategy</span>&lt;T, std::<span class="hljs-type">enable_if_t</span>&lt;
    <span class="hljs-function">std::is_trivially_copyable_v&lt;T&gt; &amp;&amp; 
    <span class="hljs-title">sizeof</span><span class="hljs-params">(T)</span> &lt;</span>= <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) &amp;&amp; 
    !std::is_fundamental_v&lt;T&gt;&gt;&gt; {
    <span class="hljs-keyword">using</span> type = T;
};

<span class="hljs-comment">// 特化：移动成本低的类型考虑传值</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PassStrategy</span>&lt;T, std::<span class="hljs-type">enable_if_t</span>&lt;
    <span class="hljs-function">std::is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; 
    <span class="hljs-title">sizeof</span><span class="hljs-params">(T)</span> &lt;</span>= <span class="hljs-number">4</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)&gt;&gt; {
    <span class="hljs-keyword">using</span> type = T;  <span class="hljs-comment">// 或者保持const T&amp;，根据性能测试决定</span>
};

<span class="hljs-comment">// 使用策略的模板函数</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">processWithStrategy</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> PassStrategy&lt;T&gt;::type param)</span> </span>{
    <span class="hljs-comment">// 使用param...</span>
}

<span class="hljs-comment">// 实际工程中的经验法则</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PracticalGuidelines</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 经验法则1：内置类型传值</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setIntParam</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDoubleParam</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoolParam</span><span class="hljs-params">(<span class="hljs-type">bool</span> value)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
    <span class="hljs-comment">// 经验法则2：迭代器传值（通常很小）</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRange</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator begin, 
                     std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator end)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
    <span class="hljs-comment">// 经验法则3：STL容器使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processVector</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
    <span class="hljs-comment">// 经验法则4：自定义大对象使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processLargeObject</span><span class="hljs-params">(<span class="hljs-type">const</span> LargeData&amp; obj)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
    <span class="hljs-comment">// 经验法则5：需要存储的参数考虑传值+移动</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">storeString</span><span class="hljs-params">(std::string str)</span> </span>{
        stored_string_ = std::<span class="hljs-built_in">move</span>(str);
    }
    
    <span class="hljs-comment">// 经验法则6：多态基类必须使用引用或指针</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processPolymorphic</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; obj)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
<span class="hljs-keyword">private</span>:
    std::string stored_string_;
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_practical_decision</span><span class="hljs-params">()</span> </span>{
    PracticalGuidelines guidelines;
    
    <span class="hljs-comment">// 遵循经验法则的调用</span>
    guidelines.<span class="hljs-built_in">setIntParam</span>(<span class="hljs-number">42</span>);                    <span class="hljs-comment">// 内置类型传值</span>
    guidelines.<span class="hljs-built_in">setDoubleParam</span>(<span class="hljs-number">3.14</span>);               <span class="hljs-comment">// 内置类型传值</span>
    
    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    guidelines.<span class="hljs-built_in">processRange</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 迭代器传值</span>
    
    guidelines.<span class="hljs-built_in">processVector</span>(numbers);             <span class="hljs-comment">// 容器const引用</span>
    
    std::string name = <span class="hljs-string">"测试名称"</span>;
    guidelines.<span class="hljs-built_in">processString</span>(name);                <span class="hljs-comment">// 字符串const引用</span>
    guidelines.<span class="hljs-built_in">storeString</span>(<span class="hljs-string">"要存储的字符串"</span>);      <span class="hljs-comment">// 传值+移动</span>
    
    <span class="hljs-comment">// 多态使用</span>
    Derived derived_obj;
    guidelines.<span class="hljs-built_in">processPolymorphic</span>(derived_obj);    <span class="hljs-comment">// 基类const引用</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"所有调用都遵循参数传递的最佳实践"</span> &lt;&lt; std::endl;
}

<span class="hljs-comment">// 最终建议的总结实现</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalRecommendation</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/*
     * 参数传递决策树：
     * 
     * 1. 参数会被修改吗？
     *    - 是：使用非const引用 (void modify(T&amp; param))
     *    - 否：继续判断
     *    
     * 2. 参数是内置类型或很小吗？(sizeof(T) &lt;= 2*sizeof(void*))
     *    - 是：考虑传值 (void process(T param))
     *    - 否：继续判断
     *    
     * 3. 需要多态行为吗？
     *    - 是：使用const引用 (void process(const Base&amp; param))
     *    - 否：继续判断
     *    
     * 4. 参数会被存储吗？
     *    - 是：考虑传值+移动 (void store(T param) { member_ = std::move(param); })
     *    - 否：使用const引用 (void process(const T&amp; param))
     *    
     * 5. 在性能关键路径上吗？
     *    - 是：进行基准测试，根据结果决定
     *    - 否：使用const引用（安全的默认选择）
     */</span>
    
    <span class="hljs-comment">// 安全的默认选择</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">safeDefault</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span> </span>{
        <span class="hljs-comment">// 大多数情况的正确选择</span>
    }
    
    <span class="hljs-comment">// 性能优化后的选择</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">optimizedChoice</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> PassStrategy&lt;T&gt;::type param)</span> </span>{
        <span class="hljs-comment">// 基于实际测量的优化选择</span>
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">demonstrate_copy_cost</span>();
    <span class="hljs-built_in">demonstrate_slicing_problem</span>();
    <span class="hljs-built_in">demonstrate_const_reference</span>();
    <span class="hljs-built_in">demonstrate_move_semantics</span>();
    <span class="hljs-built_in">demonstrate_appropriate_usage</span>();
    <span class="hljs-built_in">demonstrate_container_passing</span>();
    <span class="hljs-built_in">demonstrate_perfect_forwarding</span>();
    <span class="hljs-built_in">demonstrate_dangling_reference</span>();
    <span class="hljs-built_in">demonstrate_lifetime_management</span>();
    <span class="hljs-built_in">demonstrate_performance_measurement</span>();
    <span class="hljs-built_in">demonstrate_practical_decision</span>();
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[美团 LongCat 团队发布全模态一站式评测基准UNO-Bench]]></title>    <link>https://juejin.cn/post/7573299401046212654</link>    <guid>https://juejin.cn/post/7573299401046212654</guid>    <pubDate>2025-11-17T07:09:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573299401046212654" data-draft-id="7573242085609750579" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="美团 LongCat 团队发布全模态一站式评测基准UNO-Bench"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-17T07:09:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="美团技术团队"/> <meta itemprop="url" content="https://juejin.cn/user/3509296845313741"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            美团 LongCat 团队发布全模态一站式评测基准UNO-Bench
            <!----> <!----></h1> <div class="container team-follow" data-v-d326b38e="" data-v-61fb5e44=""><div class="left" data-v-d326b38e=""><a href="/team/6930512966122995712/posts" data-v-d326b38e=""><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47ccb42d726640a7889ba1e64ae203e6~tplv-k3u1fbpfcp-watermark.image" class="icon" data-v-d326b38e=""/></a> <div class="content" data-v-d326b38e=""><div style="display: flex" data-v-d326b38e=""><a href="/team/6930512966122995712/posts" data-v-d326b38e=""><p class="title-line" data-v-d326b38e=""><span title="美团技术团队" class="title" data-v-d326b38e="">美团技术团队</span> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/255e400027b783cbad76dc41527e7695.svg" alt="team icon" class="team-icon" data-v-d326b38e=""/></p></a></div> <div class="meta-box team" data-v-d326b38e="" data-v-61fb5e44=""><time datetime="2025-11-17T07:09:57.000Z" title="Mon Nov 17 2025 07:09:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-d326b38e="" data-v-61fb5e44="">
                2025-11-17
              </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-d326b38e="" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/></svg> <span class="views-count" style="display:none;" data-v-d326b38e="" data-v-61fb5e44="">
                0
              </span> <span class="read-time" data-v-d326b38e="" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-d326b38e="" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-d326b38e="" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-d326b38e="" data-v-61fb5e44=""/></svg>
                阅读16分钟
              </span> <!----> <!----></div></div></div> <button class="jj-follow-button follow-btn" style="display:none;" data-v-b60b2868="" data-v-d326b38e=""><span data-v-b60b2868="" data-v-d326b38e=""><i class="byte-icon byte-icon--plus" data-v-d326b38e=""><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 48 48"><path fill="none" d="M0 0h48v48H0z"/><path d="M24.7 4c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8V22h16.7c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8v1.4c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1H26v16.7c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1h-1.4c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8V26H5.3c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8v-1.4c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1H22V5.3c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1h1.4z"/></svg></i>
        关注
      </span></button></div> <div class="team-user block-hidden" data-v-61fb5e44=""><div class="avatar jj-avatar avatar" data-v-03256cc6="" data-v-61fb5e44=""><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="avatar" class="lazy avatar-img" data-v-5244ef91="" data-v-03256cc6=""/> </div> <!----> <span class="position ellipsis" data-v-61fb5e44="">
              美团小编 @美团
            </span></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>多模态人工智能正从单一感知能力迈向视觉、音频与文本的统一融合，即全模态大模型（Omni-models）时代。然而，相应的评测体系却相对滞后。现有的评测工具不仅稀缺、各自为战，且几乎完全以英文为中心，缺乏对中文场景的有效支持。此外，一些现存的数据集在设计上存在局限性，例如部分问题的解答路径并非严格依赖于多模态信息的融合，这为科学评估模型真实的跨模态能力带来了一定的复杂性。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bff55b80244b4ba090e0141758d5fa7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=VFamcUt9Xz8JdDsl1%2FkDl0cit2A%3D" alt="图1：UNO-Bench核心统计与发现概览" loading="lazy"/></p>
<p>针对这些痛点，美团LongCat团队提出了一套高质量、多样化的一站式全模态大模型评测基准——UNO-Bench。该基准通过一个统一的框架，不仅能同时精准衡量模型的单模态与全模态理解能力，更首次验证了全模态大模型的“组合定律”——该定律在能力较弱的模型上呈现为短板效应，而在能力较强的模型上则涌现出协同增益，为行业提供了一种全新的、跨越模型规模的分析范式。这一发现的背后，是其系统性的数据构建流程：通过完全人工标注确保高质量与丰富度，有效防止数据污染。此外，该团队还引入了创新的“多步开放式问题”，旨在突破传统选择题的局限，更具区分度地刻画模型在复杂链路上的推理能力。</p>
<p>接下来，我们将详细介绍UNO-Bench是如何构建的，以及它如何为推动下一代AI的智慧演进奠定基础。</p>
<h2 data-id="heading-0">01. 评测现状：从单模态繁荣到全模态挑战</h2>
<p>当前，面向单模态的评测基准已发展成熟且生态繁荣。无论是针对通用视觉理解的MMBench、检验复杂数理逻辑的MathVision，还是覆盖动态视频场景的MVBench，以及在音频领域进行探索的MMAU，这些高质量的评测资源极大地推动了AI在细分维度下的认知能力发展。然而，这些资源彼此独立，难以适应向全模态大模型演进的趋势。</p>
<p>当我们将目光投向新兴的全模态大模型评测领域，现状则面临挑战。尽管如Gemini、Qwen-3-Omni等兼容视听双模态的顶尖全模态大模型已崭露头角，但能够有效评估其综合能力的基准却稀缺且存在明显不足。例如，OmniBench的部分数据存在错误答案，而WorldSense中由于使用音视频同步数据，大部分题目无需跨模态信息即可解答，导致难以有效衡量全模态的整合能力。</p>
<p>正是在这样的背景下，UNO-Bench应运而生。LongCat团队通过1250条人工标注的全模态样本和2480个增强的单模态样本，构建了一个适用于中文场景、横跨44类任务的综合性评测体系。其中，高达98%的问题被严格设计为必须在跨模态条件下才能正确解答，这弥补了现有评测无法有效检验模型真实跨模态能力的痛点，为科学评估与推动全模态大模型的发展提供了坚实可靠的基石（详见表格1）。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d44f234d717f41329e093f7e3e033e03~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=layu8NS0PBWZlmQyWc2CULplDN4%3D" alt="表格1：多模态基准横向对比" loading="lazy"/></p>
<p><strong>说明</strong>：表格中，I、A、V、T分别代表图像、音频、视频和文本模态。Acc.代表问答对的准确率，Solvable代表需要全模态才能解决的问题比例。Source代表素材来源，分为可防止数据污染的私有数据集和公开数据集。QA Type代表问答类型，MC、MO分别代表选择题和多步开放式问答。EN和ZH分别代表英文和中文。</p>
<h2 data-id="heading-1">02. UNO-Bench构建：从顶层设计到创新实现</h2>
<p>一个卓越的评测基准始于一个科学的顶层设计。我们从定义模型核心能力体系出发，通过标准化的数据生产线确保高质量与多样性，并最终引入创新的评测方法与优化算法，共同构建了UNO-Bench的基石。</p>
<h3 data-id="heading-2">2.1 顶层设计：科学定义全模态大模型能力体系</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c824a4be30f146738ae68bad48464189~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=MPFhKvZ9DSkqCKLgHXt6qPajAgQ%3D" alt="图2：UNO-Bench统一能力体系图" loading="lazy"/></p>
<p>该团队首先将模型的综合智能系统性地解构为两大核心层面：感知层与推理层。</p>
<ul>
<li><strong>感知层</strong>：覆盖了从对象、属性、场景的基础识别，到空间关系判断、跨模态转换及语义理解等六大认知能力，并特别增设了跨模态对齐这一能力。</li>
<li><strong>推理层</strong>：在通用、STEM、代码等传统推理类别之上，着重加入了空间推理、时序推理、复杂推理等更能体现全模态大模型特色的高阶推理任务。其中通用推理细拆为常识推理和逻辑推理，空间推理细拆为静态推理和动态推理。</li>
</ul>
<p>这一双维能力框架不仅为后续的数据构建提供了清晰的蓝图，也使得对模型能力的细粒度剖析成为可能。</p>
<h3 data-id="heading-3">2.2 数据构建：标准化的高质量生产线</h3>
<p>为确保数据的顶尖品质，LongCat团队建立了一套包含精选数据素材、专家级问答标注、严苛的多轮质检三个关键环节的标准化生产流程。所有关键对话均由超过20位真人录制，以高度还原真实世界的声学特征（如普通话、四川话等）。其中最关键的质检环节是模态消融实验：通过移除任一模态的信息来检验问题是否依然可解，以此严格确保98%以上数据的“跨模态可解性”。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bc57d737ad845b58e6f1ce871a657cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=jT7HackCr9Y3eTz7BeRsoN8DwLc%3D" alt="图3：跨模态可解性问题示例" loading="lazy"/></p>
<p><strong>说明</strong>：图(a)展示了必须结合视听信息才能解答的问题，而图(b)和图(c)则分别展示了仅凭音频或视频即可解答的问题。</p>
<p>通过三个小案例（a, b, c）对比，清晰地展示了什么是必须由多个模态结合才能解答的问题，以及什么是仅凭单模态就能解答的问题。</p>
<p>数据生产流程的核心在于：</p>
<ul>
<li>针对现有数据集中普遍存在的两大问题——数据污染（视频素材可能已被模型在训练阶段“见过”）和信息冗余（视频自带的音频与画面高度同步，降低了跨模态推理的难度），我们采取了独特的素材构建策略。</li>
<li>UNO-Bench中超过90%私有化原创 。其中，大部分视觉素材来源于广泛的众包实拍，多样性、真实性更好的同时，也有效避免了模型因训练集覆盖而产生的“穿越”问题。</li>
<li>更关键的是，为了打破信息冗余，所有关键的音频内容（尤其是对话）均独立设计并由真人录制，然后与视觉素材进行人工组合。这种“视听分离再组合”的方式，确保了音频和视频各自承载着不可替代的关键信息，迫使模型必须进行真正的跨模态信息融合，而不是简单的同步确认。</li>
</ul>
<h3 data-id="heading-4">2.3 数据优化：单模态补全与高效压缩</h3>
<p>为构建全面的评测体系，我们不仅自建数据，还针对性地从AV-Odyssey、WorldSense等公开数据集中筛选了高质量样本进行补全（在整体全模态数据中占比11%）。此外，为降低大规模评测带来的算力消耗，我们独创了聚类引导的分层抽样法。实验证明，该方法在保持模型排名高度一致性的前提下，成功将评测成本降低了超过90%。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e40bfaa36c464ca6a21ee0e0a60530ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=hL6mUy1yk3rZBOqwtS8QhUURoJY%3D" alt="图4：数据构建流程图（说明：左边为全模态数据构建流程与统计信息，右边为单模态数据压缩流程与统计信息）" loading="lazy"/></p>
<h3 data-id="heading-5">2.4 评测创新：多步开放式问题与通用评分模型</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa7242fe04d840368740a828454710a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=Q9jFVowFf3GgU7ttVHtCEvvTUDs%3D" alt="图5：多步开放式问题（MO）构建示例" loading="lazy"/></p>
<p>为了打破传统选择题无法有效评估复杂推理的局限，引入了创新的多步开放式问题（MO，Multi-step Open-ended question）。这种题型将一个复杂的长链条推理任务，拆解为多个相互依赖、层层递进的子问题，并要求模型对每一步都给出开放式的文本答案。</p>
<p>评分则由专家根据每一步的难度与重要性进行加权赋分（满分10分）。这种设计能够直观地揭示模型在多步推理中的能力衰减现象，从而精准地区分出模型的“浅层猜测”与“深度思考”，是衡量顶尖模型推理能力的关键指标，具体示例如图5所示。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d46f33553c994ed2900ad90653575693~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=dwNv4NzBFWPQfsEinnQS4Yjs%2B7A%3D" alt="图6：通用评分模型训练流程图" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2465e5447ea44929827af2a1dfd6e17f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=d4ApAT21Wp5h5HxRfq154ZrN0hk%3D" alt="图7：通用评分模型的问题类型定义（说明：该图表展示了为提高评分准确率而定义的六种细分问题类型及其判断标准。）" loading="lazy"/></p>
<p>为实现自动化评估，LongCat团队还提出了一个通用评分模型，通过对问题类型进行细分（如图7所示），并结合人工和自动标注多轮质量迭代的数据集（如图6所示），使其能够支持6种通用问题类型的自动评分，在分布外的模型和基准测试中达到了95%的准确率。</p>
<h2 data-id="heading-6">03. 实验与分析：揭示全模态大模型的真实能力与演进规律</h2>
<p>LongCat团队在UNO-Bench上对包括Qwen、Baichuan、MiniCPM以及Gemini系列在内的多款主流全模态大模型进行了全面评测。实验设计旨在回答三个核心问题：</p>
<ol>
<li>当前全模态大模型的智能水平及其短板何在？</li>
<li>单模态与全模态能力之间存在何种关系？</li>
<li>UNO-Bench作为一站式评估方案的有效性如何？</li>
</ol>
<h3 data-id="heading-7">3.1 模型性能的全面剖析</h3>
<p><strong>总体格局：闭源模型优势显著，开源模型仍在追赶</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1945c0c76ee045739a944902e3087240~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=UEDvCd%2FI1gcddtUdHakpNuo%2B8XA%3D" alt="表格2：各全模态大模型在UNO-Bench上的评测结果（说明：表格展示了各模型在单模态（音频、视觉）和全模态（选择题Omni-MC、多步开放式题Omni-MO）上的得分。）" loading="lazy"/></p>
<p>如表格2所示，在本次评测的开源模型中，LongCat-Flash-Omni表现出开源SOTA（State-of-the-Art）的成绩。该模型在音频（80.20）、视觉（67.06）、全模态选择题（49.90）以及全模态开放题（42.68）四大核心维度上，全面超越了本次评测中的其他开源模型。</p>
<p>与此同时，以Gemini系列为代表的闭源模型在所有评测维度上，特别是在顶尖性能层面，依然保持着领先优势，其中Gemini-2.5-Pro稳居行业标杆。当面对难度更高的“多步开放式问题”（Omni-MO）时，所有模型的性能普遍下滑，这清晰地反映出，长链条、跨模态的深度推理依然是整个AI领域亟待攻克的难题。</p>
<p><strong>能力拆解：推理是区隔强弱的核心维度</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f99e279673d2461fb6917148dbf3c2f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=1NUambXSfqefIQQWw1Y%2Fl1D1Vxs%3D" alt="表格3： 基于能力体系的跨模态表现分析" loading="lazy"/></p>
<p>通过对感知与推理能力的细化分析（见表格3），我们发现：</p>
<ul>
<li>感知层面，跨模态同步对齐比单纯的跨模态识别更具挑战。</li>
<li>推理层面，空间推断是所有子任务中最难的一项，即使是表现最佳的Gemini-2.5-Pro得分也仅为45分。</li>
</ul>
<p>综合来看，模型的感知能力相对较强，而真正的性能差距主要体现在推理能力上。以Qwen-3-Omni-30B与Gemini-2.5-Pro为例，两者在感知能力上相差23分，但在推理能力上的差距则拉大到33分，这表明：推理能力是划分模型强弱的关键分水岭。</p>
<p><strong>顶尖梯队与人机对比剖析</strong></p>
<p>LongCat团队进一步对Gemini-2.5-Pro的卓越表现进行了剖析。一方面，这得益于其强大的单模态基础能力；另一方面，其内置的语音转写并自然融入推理链路的能力，是多数开源模型尚不具备的。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37d800370f5b4490b078f2997b7fe192~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=ybpKKcB%2FmW93Ml6SntXTWBbqfb0%3D" alt="图8：Gemini-2.5-Pro评测过程示例（说明：该图展示了Gemini-2.5-Pro利用音频转录文本辅助解决问题的过程。）" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f758d012e03481488d60d8df5be7825~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=b8JiLAFl1ZXo7Jzu9Fb8OnnoFXc%3D" alt="图9：人类专家与Gemini-2.5-Pro性能对比图" loading="lazy"/></p>
<p>说明: Gemini-2.5-Pro在感知能力上与人类相当，但在推理能力上仍有差距。</p>
<p>如图9所示，观察到一个有趣的现象：</p>
<ol>
<li>感知能力媲美人类：在全模态的感知任务上，Gemini-2.5-Pro的表现已能与人类专家相当。</li>
<li>推理能力仍存差距：然而，在更复杂的推理任务上，人类专家（81.3%）的表现依然优于Gemini-2.5-Pro（74.3%）。这揭示了AI与人脑在抽象归纳和复杂逻辑处理能力上的本质区别。</li>
</ol>
<h3 data-id="heading-8">3.2 全模态与单模态的内在关联</h3>
<p>得益于UNO-Bench统一的能力体系与高质量数据，通过回归与消融实验，揭示了单、全模态能力间的深刻关系。</p>
<p><strong>“组合定律”成立，且遵循幂律协同</strong></p>
<p>我们对各模型的单、全模态得分进行了回归分析，发现了一个强关联性，并将其形式化为一个科学定律。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1837fbe77ce140fd938532c9b71281f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=cX0zfBOgYaHdaziIk0cWO9W%2Bi%2F8%3D" alt="图10：全模态能力的组合定律关系图" loading="lazy"/></p>
<p>如图10所示，全模态的性能并非单模态能力的简单线性叠加，而是遵循一种乘积规律。通过严谨的数学推导和非线性拟合，得到了一个拟合度高达**97.59%**的幂律公式：</p>
<blockquote>
<p>POmni ≈ 1.0332 · (PA × PV)^2.1918 + 0.2422</p>
</blockquote>
<p>该幂律公式的指数大于1，使得函数曲线呈现为一条加速上升的凸形。这完美地解释了两种现象的涌现：</p>
<ol>
<li>短板效应 (Bottleneck Effect)：对于能力较弱的模型，其全模态性能的增长相对平缓。</li>
<li>协同增益 (Synergistic Promotion)：对于顶尖模型，单模态能力的增强会带来全模态性能的爆发式增长，实现了真正意义上的“1+1 &gt;&gt; 2”的多模态协同增益。</li>
</ol>
<p><strong>更重要的是，这个“组合定律”提供了一种全新的、跨越模型规模的分析范式</strong>。它允许研究人员将不同参数规模、不同架构的模型放置在同一个坐标系下进行比较，不再仅仅关注各自的绝对得分，而是通过它们在幂律曲线上的相对位置，来统一度量其“模态融合效率”。一个模型如果显著高于拟合曲线，则意味着其模态融合机制更为高效；反之，则可能存在融合瓶颈。这为评估和优化全模态大模型的内在融合能力，提供了一个极具价值的分析工具。</p>
<p>从图10的具体模型分布来看，其中参与拟合的模型由圆点表示，新增的LongCat-Flash-Omni模型表现较为突出。虽然Gemini系列的具体参数规模未知，但可以观测到LongCat-Flash-Omni的表现已非常接近Gemini-2.5-Flash，并显著领先于Qwen3-Omni-30B。其位置正处于曲线加速上升的“协同增益区”，且与理论拟合曲线高度吻合，这表明该模型展现出了高效的多模态融合能力。</p>
<p><strong>消融实验验证</strong></p>
<p>这再次印证了多通道互补与融合是通往更高智能的必经之路。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1664addd39de43228d02a216ee417bb3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=HDWFJkrZeeB1F02oVFDW%2B%2BTvmeI%3D" alt="表格4：视觉理解能力消融实验结果" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1784ce86391b495b85e865717f361302~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=fQlxhRPHOILdZSh6Oyho8nu6cHY%3D" alt="表格5：音频理解能力消融实验结果" loading="lazy"/></p>
<p>LongCat团队通过详尽的视觉与音频消融实验（具体数据参见表格4、5）进一步验证了这些发现。实验表明，对于多数模型，提供文本描述（Caption/ASR）比直接处理原始视听信息能获得更好的效果，但顶尖模型如Gemini-2.5-Pro则能从原始信号中提取比文本更丰富的信息。</p>
<h3 data-id="heading-9">3.3 UNO-Bench基准的有效性验证</h3>
<p>除了核心的实验发现，UNO-Bench作为一个评测基准本身的科学性和有效性，也通过以下几个方面得到了验证。</p>
<p><strong>多步开放式问题的卓越区分度</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95707f05b6cb429099fe87c59b60035d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=Upevlj9cxD5kU9Lf1R7FQ3yxzlc%3D" alt="表格6：各模型在多步开放式问题（MO）上的表现" loading="lazy"/></p>
<p>如表格6所示，创新的MO题型能够真实地刻画模型在长链条推理中的能力衰减，有效放大了模型间的认知鸿沟。</p>
<p><strong>高效的数据集压缩算法</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ec312163e7846b6adea77b19f2c237f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=k5fFZExhNj3b%2BTV2YZrmSNPJ04w%3D" alt="图11：数据集压缩性能评估图" loading="lazy"/></p>
<p>如图11所示，我们设计的聚类引导抽样法，能在保持模型排名一致性（SRCC/PLCC &gt; 0.98）的前提下，将评测算力消耗降低超过90%，实现了效率与准确性的平衡。</p>
<p><strong>卓越的数据质量与区分度</strong></p>
<p>一个评测基准的有效性，最终体现在其数据的质量和区分模型优劣的能力上。UNO-Bench在这两方面都表现出色。</p>
<ul>
<li>首先，在数据质量上，如前文表格1所示，UNO-Bench的全模态数据集问题准确率达到了100%，且有高达98%的问题被严格设计为必须跨模态才能解答，这确保了评测的公平性和对模型真实能力的有效检验。</li>
<li>其次，在区分度上，UNO-Bench的设计能够清晰地揭示不同模型间的性能梯度。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6078c3b3d4a3440fb54e1c52b7f8455b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=nfGKSUupCyG7eztPKTWjeXa0lP8%3D" alt="图12：UNO-Bench与其他全模态基准对比图" loading="lazy"/></p>
<p>而在与其他全模态基准的直接对比中（如图12所示），UNO-Bench的有效性也得到了进一步验证。它不仅通过更高的得分标准差（19.5 vs. 12.75）展现了比OmniBench更强的区分能力，还通过合理的难度设置，避免了像AV-Odyssey那样所有模型得分被压缩在狭窄低分区间的窘境。这确保了UNO-Bench既能有效评估当前模型，也为未来更强模型的涌现预留了足够的成长空间，是一个更可靠和富有洞察力的评测工具。</p>
<h2 data-id="heading-10">04. 总结与展望</h2>
<p>本文提出了一站式全模态大模型评测基准——UNO-Bench。该基准通过科学的评测框架，首次揭示了多模态智能并非简单的线性叠加，而是遵循着一种乘积规律，这一规律在能力较弱的模型上体现为瓶颈限制，而在顶尖模型上则表现为协同增益的特性，这个全模态大模型的“组合定律”为行业提供了一种全新的、跨越模型规模的分析范式。LongCat团队的评测结果进一步表明，以Gemini为代表的闭源模型在单模态及跨模态理解上仍远超主流开源阵营，其顶配版本虽在感知能力上已逼近人类专家，但在复杂的推理层面仍存在亟待突破的空间。而这些发现，正是得益于UNO-Bench自身的较高的数据质量与创新的评价机制，它有效扩展了模型表现的区分度，为新一代智能体的持续成长奠定了坚实基础。</p>
<p>面向未来，LongCat团队将通过自动化人机共建流程持续扩充数据规模，引入STEM、Code等更具挑战性的场景，并深入探索模态间的互动关系，为下一代通用人工智能的发展开辟新路径。</p>
<p><strong>开源资源</strong></p>
<ul>
<li><strong>GitHub</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmeituan-longcat%2FUNO-Bench" target="_blank" title="https://github.com/meituan-longcat/UNO-Bench" ref="nofollow noopener noreferrer">github.com/meituan-lon…</a></li>
<li><strong>Hugging Face</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fdatasets%2Fmeituan-longcat%2FUNO-Bench" target="_blank" title="https://huggingface.co/datasets/meituan-longcat/UNO-Bench" ref="nofollow noopener noreferrer">huggingface.co/datasets/me…</a></li>
<li><strong>论文下载</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmeituan-longcat%2FUNO-Bench%2Fblob%2Fmain%2FUNO-Bench.pdf" target="_blank" title="https://github.com/meituan-longcat/UNO-Bench/blob/main/UNO-Bench.pdf" ref="nofollow noopener noreferrer">github.com/meituan-lon…</a></li>
</ul>
<p>| 关注「美团技术团队」微信公众号，在公众号菜单栏对话框回复【2024年货】、【2023年货】、【2022年货】、【2021年货】、【2020年货】、【2019年货】、【2018年货】、【2017年货】等关键词，可查看美团技术团队历年技术文章合集。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1324c3f8b2974fbdac45cd334e5e5e32~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=Ewjob7lFhjwvnDkvA7L6EFdky2E%3D" alt="" loading="lazy"/></p>
<p>| 本文系美团技术团队出品，著作权归属美团。欢迎出于分享和交流等非商业目的转载或使用本文内容，敬请注明“内容转载自美团技术团队”。本文未经许可，不得进行商业性转载或者使用。任何商用行为，请发送邮件至 <a href="https://link.juejin.cn?target=mailto%3Atech%40meituan.com" target="_blank" title="mailto:tech@meituan.com" ref="nofollow noopener noreferrer">tech@meituan.com</a> 申请授权。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 应用加密工具的全面方案，从源码混淆到 IPA 成品加固的多层安全实践]]></title>    <link>https://juejin.cn/post/7573486671296102442</link>    <guid>https://juejin.cn/post/7573486671296102442</guid>    <pubDate>2025-11-17T07:12:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573486671296102442" data-draft-id="7573180788579401769" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 应用加密工具的全面方案，从源码混淆到 IPA 成品加固的多层安全实践"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-17T07:12:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="iOS开发上架哦"/> <meta itemprop="url" content="https://juejin.cn/user/3336394949004844"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 应用加密工具的全面方案，从源码混淆到 IPA 成品加固的多层安全实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3336394949004844/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    iOS开发上架哦
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T07:12:13.000Z" title="Mon Nov 17 2025 07:12:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Swift 项目的安全工作常被误解为“编译器已经做了优化，不会轻易被逆向”。
现实是：<strong>Swift 二进制仍然保留大量可读符号、类名、属性名以及可追踪的结构信息</strong>。
只要拿到 IPA，逆向人员仍能通过 Hopper / IDA / Frida 快速还原业务逻辑。</p>
<p>因此，对 Swift 应用进行加密/加固需要建立在“多工具组合、多层防护”的基础上，而非依赖单一方案。
本文以工程实践为核心，为开发者介绍 Swift 加固工具的职责划分、流程设计与可复制的命令级方案。</p>
<hr/>
<h2 data-id="heading-0">一、Swift 项目的三层安全架构（源码层 → 成品层 → 运行时层）</h2>
<h3 data-id="heading-1"><strong>1. 源码层（编译前）</strong></h3>
<p>主要解决 Swift 模块暴露的符号问题。
适用工具与方案：</p>
<ul>
<li><strong>Swift Shield</strong>：对 Swift 类/方法/属性进行符号重命名。</li>
<li><strong>obfuscator-llvm</strong>：在编译期进行控制流混淆、字符串加密（深度最高）。</li>
<li><strong>自定义脚本处理敏感字符串</strong>：对密钥、接口地址进行简单不可逆转换。</li>
</ul>
<p>源码混淆属于“深度保护”，在可控项目中效果最好，但并非所有团队都有源码权限。</p>
<hr/>
<h3 data-id="heading-2"><strong>2. 成品层（IPA 层）</strong></h3>
<p>用于无法修改源码、外包交付、二次加固或对上线包补充保护。</p>
<p>核心工具：</p>
<ul>
<li><strong>Ipa Guard（命令行版）</strong>
<ul>
<li>无需源码</li>
<li>可直接对 IPA 执行 Swift/ObjC 符号混淆</li>
<li>支持导出符号、编辑混淆策略、资源扰动（图片 MD5、JS 文件名等）</li>
<li>具备 CLI，可自动化纳入发布流水线</li>
</ul>
</li>
</ul>
<p>这种方式非常适合“Swift 项目 + 外包交付 + 要求简单稳定的商业混淆策略”的团队。</p>
<hr/>
<h3 data-id="heading-3"><strong>3. 运行时层（动态对抗）</strong></h3>
<p>Swift 项目在运行时同样需要保护，尤其是：</p>
<ul>
<li>Frida 注入</li>
<li>动态 Hook</li>
<li>调用替换</li>
<li>越狱环境运行</li>
</ul>
<p>常用的运行时工具：</p>
<ul>
<li><strong>Frida 自测脚本</strong>：用于验证防护是否有效</li>
<li><strong>轻量级反调试代码</strong></li>
<li><strong>二次启动校验（完整性校验）</strong></li>
</ul>
<p>运行时不属于“加密工具本体”，但属于 Swift 项目最常忽略的安全环节。</p>
<hr/>
<h2 data-id="heading-4">二、Swift 应用常用加固工具对比</h2>





















































<table><thead><tr><th>工具</th><th>层级</th><th>优势</th><th>限制</th></tr></thead><tbody><tr><td><strong>Swift Shield</strong></td><td>源码层</td><td>专为 Swift 设计，编译集成稳定</td><td>需源码，不能处理第三方产物</td></tr><tr><td><strong>obfuscator-llvm</strong></td><td>编译层</td><td>控制流混淆最深，逆向难度最高</td><td>改动大，需完整源码与构建链</td></tr><tr><td><strong>自定义字符串加密脚本</strong></td><td>源码层</td><td>保护敏感常量</td><td>防护强度有限</td></tr><tr><td><strong>Ipa Guard CLI</strong></td><td>成品层</td><td>无需源码即可混淆 Swift 符号和资源，可自动化</td><td>需谨慎配置符号策略</td></tr><tr><td><strong>MobSF / class-dump</strong></td><td>分析层</td><td>快速识别泄露符号、反编译点</td><td>不参与混淆，仅分析</td></tr><tr><td><strong>kxsign / Fastlane</strong></td><td>分发层</td><td>自动化重签与真机测试</td><td>不提供安全性本体</td></tr><tr><td><strong>Frida / Hopper</strong></td><td>动态层</td><td>安全验证与逆向测试</td><td>属于攻击工具，需要团队自测</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-5">三、Swift 项目的工程化加固流程（推荐）</h2>
<h3 data-id="heading-6"><strong>Step 1：静态分析，找出 Swift 可读符号</strong></h3>
<pre><code class="hljs language-bash" lang="bash">class-dump app.ipa &gt; symbols.txt
</code></pre>
<p>MobSF 也能扫描出敏感文件、Swift 模块结构、资源引用。</p>
<p>目的：
✔ 找出不能混淆的符号（桥接方法、Storyboard、协议回调）
✔ 提供编译或成品混淆策略依据</p>
<hr/>
<h3 data-id="heading-7"><strong>Step 2：若能修改源码，优先做 Swift 编译期混淆</strong></h3>
<p>示例（Swift Shield）：</p>
<ul>
<li>配置类名/属性名映射</li>
<li>在 Xcode 构建步骤中加入 Swift Shield</li>
<li>重新编译并全量回归</li>
</ul>
<blockquote>
<p>若无源码权限，直接进入 Step 3。</p>
</blockquote>
<hr/>
<h3 data-id="heading-8"><strong>Step 3：使用 Ipa Guard 执行 Swift 成品符号混淆</strong></h3>
<h4 data-id="heading-9">1. 导出可混淆符号清单</h4>
<pre><code class="hljs language-bash" lang="bash">ipaguard_cli parse App.ipa -o sym.json
</code></pre>
<p><code>sym.json</code> 会列出：</p>
<ul>
<li>Swift 类名</li>
<li>Swift 方法（含参数标识）</li>
<li>资源引用（如 js、bundle、asset）</li>
<li>需要谨慎处理的文件引用（fileReferences）</li>
</ul>
<h4 data-id="heading-10">2. 编辑策略（SYMBOL RULES）</h4>
<ul>
<li>禁止混淆的符号：</li>
</ul>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"confuse"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span>
</code></pre>
<ul>
<li>修改 Swift 符号映射：</li>
</ul>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"refactorName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"aBcD1234"</span>   <span class="hljs-comment">// 必须长度一致</span>
</code></pre>
<ul>
<li>若符号出现在 H5/JS 字符串中需同步替换</li>
</ul>
<h4 data-id="heading-11">3. 直接混淆 IPA</h4>
<pre><code class="hljs language-bash" lang="bash">ipaguard_cli protect App.ipa -c sym.json --email team@company.com --image --js -o App_protected.ipa
</code></pre>
<p>参数：</p>
<ul>
<li><code>--image</code> → 修改 Swift Bundle 和 App 资源的 MD5</li>
<li><code>--js</code> → 防止 WebView/混合应用资源泄露</li>
<li><code>-c</code> → 指定我们刚编辑的策略</li>
<li><code>--email</code> → CLI 登录验证</li>
</ul>
<hr/>
<h3 data-id="heading-12"><strong>Step 4：重签名与功能验证（关键）</strong></h3>
<pre><code class="hljs language-bash" lang="bash">kxsign sign App_protected.ipa \
  -c dev_cert.p12 \
  -p 123456 \
  -m dev.mobileprovision \
  -z App_signed.ipa \
  -i
</code></pre>
<p>测试重点：</p>
<ul>
<li>SwiftUI/Storyboard 是否正常</li>
<li>混淆后的模块是否仍能加载</li>
<li>支付、账号体系、SDK 初始化是否正常</li>
<li>真机冷启动速度是否保持稳定</li>
</ul>
<hr/>
<h3 data-id="heading-13"><strong>Step 5：动态验证（逆向成本评估）</strong></h3>
<p>使用 Frida：</p>
<pre><code class="hljs language-bash" lang="bash">frida -U -f com.company.app --no-pause -l hook.js
</code></pre>
<p>观察：</p>
<ul>
<li>混淆后的 Swift 符号是否可读？</li>
<li>Hook 关键函数是否困难？</li>
<li>Hopper 中的符号可视化是否显著下降？</li>
</ul>
<p>这部分用于验证加固效果。</p>
<hr/>
<h3 data-id="heading-14"><strong>Step 6：映射表治理（重要）</strong></h3>
<p>混淆映射必须：</p>
<ul>
<li>上传到 KMS 或 HSM（加密存储）</li>
<li>与版本号绑定</li>
<li>解密需要审批（开发/运维双人）</li>
<li>用于 Sentry/Bugly 崩溃符号化</li>
</ul>
<p>没有治理，就无法快速定位线上问题。</p>
<hr/>
<h2 data-id="heading-15">四、Swift 项目的常见加固风险点</h2>
<ul>
<li>Swift 模块名混淆错误 → App 无法启动</li>
<li>Storyboard id 被混淆 → 页面崩溃</li>
<li>Swift Protocol Selector 被误改 → 事件不触发</li>
<li>JS/H5 引用未同步修改 → WebView 白屏</li>
<li>混淆后 App 脱离签名 → 启动闪退</li>
<li>映射表丢失 → 崩溃分析无法恢复原始函数</li>
</ul>
<p>以上都是工程团队最常踩的坑。</p>
<hr/>
<h2 data-id="heading-16">Swift 安全加固不是“某个工具”，而是“体系”</h2>
<p>Swift 项目加固 =<strong>源码混淆 + 成品混淆 + 资源扰动 + 重签验证 + 动态对抗 + 映射治理</strong></p>
<p>推荐工具组合：</p>
<ul>
<li><strong>Swift Shield / obfuscator-llvm（深度）</strong></li>
<li><strong>Ipa Guard CLI（无源码 &amp; 成品层）</strong></li>
<li><strong>MobSF / class-dump（分析）</strong></li>
<li><strong>kxsign / Fastlane（发布链路）</strong></li>
<li><strong>Frida / Hopper（验证）</strong></li>
<li><strong>KMS + Sentry（治理）</strong></li>
</ul>
<p>落地后，无论是内部项目、外包交付还是闭源商业 App，都能建立稳定、可回滚、可审计的加固链路。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[国内也有 GPT 质感的 App 了，阿里做到了。]]></title>    <link>https://juejin.cn/post/7573310642959220774</link>    <guid>https://juejin.cn/post/7573310642959220774</guid>    <pubDate>2025-11-17T06:51:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573310642959220774" data-draft-id="7573234521364414490" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="国内也有 GPT 质感的 App 了，阿里做到了。"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-17T06:51:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苍何"/> <meta itemprop="url" content="https://juejin.cn/user/588993963763405"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            国内也有 GPT 质感的 App 了，阿里做到了。
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993963763405/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    苍何
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:51:23.000Z" title="Mon Nov 17 2025 06:51:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是苍何的第 450 篇原创！</p>
<p>大家好，我是苍何。</p>
<p>近日，阿里正式推出基于 Qwen 大模型的千问 APP，一款被视为可以与 GPT 正面竞争的国产个人 AI 应用。</p>
<p>这也代表着阿里全力进军 AI 原生应用市场。</p>
<p>我第一时间也去做了体验测试，你还别说，这次阿里一改往日什么都想要的风格，整个界面异常简洁，只聚焦在对话上。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8135febfada84fa48c811e1a17380c8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=VPmrmjheiVbTF7CNR8v05Kv9WMw%3D" alt="图片" loading="lazy"/></p>
<p>这很不阿里。</p>
<p>但也正因「极简」，它的核心体验才做的特别好，不仅主模型升级成了 Qwen 家族最强的旗舰模型，思维链、回答的结构化都做的非常棒，甚至还能直接生成可视化图表。</p>
<p>废话不多说，今天就来盘盘，这个被阿里寄予厚望的 APP，到底如何。</p>
<p>可以看到主对话模型为 Qwen3-千问和 Qwen3-Max，用户可自由选择。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ce5a12d90e54caa85184311183aa8c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=D0%2FJ3cf2IEDFE3kNwWdpOvJ7lCg%3D" alt="图片" loading="lazy"/></p>
<blockquote>
<p>但据说内部集成了 Qwen 3-VL、Qwen 3-Coder、Qwen-Image、Qwen 3-Omni 多款世界顶尖模型。</p>
</blockquote>
<p>先来一个需要深度思考的任务，在 Chat 上选择「深度思考」，输入以下问题：</p>
<pre><code class="hljs">在全球人口老龄化加剧、医疗资源分配不均且 AI 技术快速迭代的背景下，若要构建一套兼顾医疗公平性、数据隐私安全、伦理边界（如生命自主权、算法偏见）与经济可持续性的 AI 辅助养老医疗系统，你认为核心设计逻辑应如何搭建？
请结合技术可行性（如边缘计算、联邦学习的应用）、政策监管框架、不同地区的经济与文化差异，以及可能出现的社会矛盾（如人机信任危机、传统医疗从业者的职业转型），
说明关键决策点与妥协方案，并预判该系统落地后 5 年内可能引发的新社会问题及应对思路。
</code></pre>
<p>结果如下，整个回答的很全面，逻辑性很强。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e29be69478334fa48de940fd692f8878~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=JDuAt10azVK%2B8OKtp4HGpPceHNE%3D" alt="图片" loading="lazy"/></p>
<p>当我把周末橘子烧烤的图片丢进千问 APP，选择「AI 修图」，用嘴来修改图片中局部元素信息。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4d09dc9193842d09501d9cd67821d1d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=7bC3xJSheUCQEGtk77n%2BZ2HDVVg%3D" alt="图片" loading="lazy"/></p>
<p>你还别说，一次就很好的给橘子带了个很 cute 的帽子。</p>
<p>还可以直接换个背景，来一场雪地烧烤，哈哈哈：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f74a446ccc84e4c826a24b9602ea628~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=d3g5qb95pmf4sS73NYxApHMsXVE%3D" alt="图片" loading="lazy"/></p>
<p>在改完图片后，可以基于图片来创作视频，可以选择场景模板，也可以提示词描述场景。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/900be2984dd04cb1b05a8c688a171af2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=kD9R4YRj8or5v1SWuUEaAvbuBWI%3D" alt="图片" loading="lazy"/></p>
<p>然后出来了一个特别好玩的视频，声音和音效都完美配上了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89936acb4f034433b0a1785db6bf2b01~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=JKv7jtKgw19bhtc%2FECkThj7dgjM%3D" alt="wxv_4256493013809348616" loading="lazy"/></p>
<p>我测试下来，都可以直接使用，不需要积分什么的，感觉在千问 APP 上制作 AI 视频，速度更快了。</p>
<p>我最喜欢的是上面的同传翻译功能，比如在和老外会议或者听外教时，这个功能是真的爽，她说她的英语，我看的我的中文。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9df386e1bacf46bc91f8c8cf8a8b96fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=SD8qPUOgepmPvgnWGJu3x3cyIfg%3D" alt="图片" loading="lazy"/></p>
<p>同传翻译的内容可以直接保存，非常方便。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9c24ee6ae52f4c1082af2d6896a0f319~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=UYhttTzm9XLVHVL6%2BDT%2FIAbTTy8%3D" alt="图片" loading="lazy"/></p>
<p>以前在开会的时候，经常会用到通义听悟的录音及转写能力，但很多时候，电脑并不在身边。</p>
<p>现在在千问 APP 中也能直接录音，支持现场录音和手机音频录音，还能边录边翻译，非常实用的能力了。</p>
<p>我录了个视频，你可以感受一下。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/16e84033058547369a58e49edf98e598~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=6IDVh1YYz%2FVD2vUBGMQT8l0MSxw%3D" alt="wxv_4256491537212637197" loading="lazy"/></p>
<p>这个功能特别是在听一些国外直播的时候，就非常有用，直播实时翻译还没做的非常丝滑的。千问 APP 的这个玩法，非常棒。</p>
<p>当我点击「PPT 制作」，会发现千问又化身 PPT 制作小能手，快速棒生成 PPT，还能指定选择模板，快速导出。</p>
<pre><code class="hljs">帮我生成PPT，主题及要求：关于ai agent的ppt 
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1c4c9f66e1a4026a4b9b203294e0f93~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=GCIhd8seuh6RseuaPXEKgb78CQI%3D" alt="图片" loading="lazy"/></p>
<p>看了下，效果还不错，内容完善。</p>
<p>在写作上，当我点击「智能写作」，能帮我自动写报告、发言稿、申请书、论文、小红书笔记、朋友圈文案等常用场景。</p>
<p>比如我让他写一篇小红书笔记，就很快出来效果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7ceba6b23214e34b0636ad0f169fc21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=xAJPHPzFWGcH0nevl%2FZ5fi3oTnM%3D" alt="图片" loading="lazy"/></p>
<p>最后，还测了千问 APP 的「文档解读」能力，可以上传本地文件，也可以上传微信聊天记录文件，生成想要格式的文档解读。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/83ad8ec308e540b2a56bc72c5d11d657~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=SyhWVuOf0lSg2gX%2BGHpH0Bs08uY%3D" alt="图片" loading="lazy"/></p>
<p>还蛮有意思的，千问 APP 虽然界面更简洁了，但可以说是 All in One 的存在，能想到的不能想到的实用功能，通通都满足了。</p>
<p>千问 App 这次确实给了我一个惊喜，它证明了国产也能做出一个专注、好用、有国际范儿的 AI 产品。 </p>
<p>也难怪千问 App 发布同一时期，英国《金融时报》突然爆料，说拿到了一份所谓的美国白宫“绝密”备忘录，指控阿里“为军方提供技术支持”。</p>
<p>好家伙，帽子扣得一个比一个大。但搞笑的是，连《金融时报》自己都承认，这些指控他们无法独立核实。</p>
<p>这让我觉得很感慨。</p>
<p>一方面，我们的企业在努力做出能与世界抗衡的好产品、好技术；另一方面，却要时刻提防着来自外界的明枪暗箭。 </p>
<p>技术上的追赶已经够难了，没想到在国际舆论场上，还有一场更硬的仗要打。国产 AI 的崛起之路，注定不会平坦。  </p>
<p>不过三年来，阿里深耕 AI 技术研发，将 Qwen 打造成全球第一开源模型。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/784ed29a1c2948a58a4543270213d485~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=1fQnBX5680UJwE9EdJEBLI6vboY%3D" alt="图片" loading="lazy"/></p>
<p>9 月的一个 Hugging Face 趋势榜，阿里旗下 7 款模型跻身全球前十开源模型榜单，几乎实现了“屠榜”。</p>
<p>也因此，千问一直被称为是 AI 界的源神，目前，通义千问 Qwen 全球下载量超 6 亿，衍生模型数量已突破 17 万，超越美国 Llama 模型，成为全球第一 AI 开源模型。</p>
<p>在首届 AI 模型交易大赛中，Qwen3 Max 排名第一，收益率为 22.3%，其余模型均大幅亏损。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cc71ba65cbf4768b5117844c1ff3aab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=3Xz%2BjGTN67lXTBhbUjNoLMtGYg4%3D" alt="图片" loading="lazy"/></p>
<p>千问 APP 的发布代表着阿里正式进军 AI 原生应用市场，开始面向更多的 C 端用户，通过 C 端配合整个开源生态，去走 B 端市场。</p>
<p>这一步棋，我想阿里酝酿了很久。</p>
<p>体验下来，这一步确实走得很扎实。</p>
<p>好了，今天的文章就到这，感谢你的阅读，我们下一期见。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么我的页面布局总是乱糟糟？可能是浮动和BFC在作怪！]]></title>    <link>https://juejin.cn/post/7572481101711294518</link>    <guid>https://juejin.cn/post/7572481101711294518</guid>    <pubDate>2025-11-16T10:20:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572481101711294518" data-draft-id="7572493520004071458" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="为什么我的页面布局总是乱糟糟？可能是浮动和BFC在作怪！"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2025-11-16T10:20:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户28320967937"/> <meta itemprop="url" content="https://juejin.cn/user/1787121370143162"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            为什么我的页面布局总是乱糟糟？可能是浮动和BFC在作怪！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1787121370143162/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户28320967937
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T10:20:16.000Z" title="Sun Nov 16 2025 10:20:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在前端开发中，你是否曾经遇到过这样的困扰：明明代码写得很规范，但页面元素就是不听话，到处乱跑？今天我们就来聊聊这个让无数前端开发者头疼的问题——浮动布局和它的救星BFC。</p>
<h2 data-id="heading-0">什么是文档流？</h2>
<p>在深入探讨问题之前，我们需要先了解浏览器默认的布局方式——文档流。</p>
<p>想象一下浏览器渲染页面就像我们写字一样，遵循着<strong>从上往下，从左往右</strong>的排列规则，这就是普通文档流。在这种流式布局中，元素按照它们在HTML中出现的顺序依次排列。</p>
<h2 data-id="heading-1">浮动布局：天使与魔鬼的结合体</h2>
<h3 data-id="heading-2">浮动的设计初衷</h3>
<p>浮动最初被创造出来，其实是为了实现一个简单而实用的效果——<strong>文字环绕图片</strong>，就像杂志排版那样优雅。</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">img</span> {
  <span class="hljs-attribute">float</span>: left;
  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">15px</span>;
}
</code></pre>
<p>但随着网页设计的发展，开发者们发现浮动还可以用来实现<strong>多栏布局</strong>和<strong>水平排列元素</strong>，于是它便成了CSS布局的重要工具。</p>
<h3 data-id="heading-3">浮动的黑暗面</h3>
<p>然而，浮动的美好背后隐藏着一个巨大的陷阱——<strong>脱离文档流</strong>！</p>
<p>当一个元素被浮动时，它会从正常的文档流中被"抽离"出来，导致父容器无法感知它的存在，从而引发经典的<strong>高度塌陷</strong>问题。</p>
<p>想象一下这样的场景：</p>
<p>html</p>
<pre><code class="hljs language-ini" lang="ini">&lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;
  &lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span> style=<span class="hljs-string">"float: left;"</span>&gt;我是浮动元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>此时，父容器的高度会变成0，因为里面的浮动元素已经"飘"出去了，不在父容器的管辖范围内！</p>
<h4 data-id="heading-4">清除浮动：拯救布局的五大法宝</h4>
<p>面对浮动带来的布局灾难，前端开发者们探索出了多种解决方案：</p>
<h3 data-id="heading-5">1. 硬编码父容器高度 ❌</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.parent</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; <span class="hljs-comment">/* 不推荐 */</span>
}
</code></pre>
<p><strong>缺点</strong>：缺乏灵活性，内容变化时需要手动调整高度。</p>
<h3 data-id="heading-6">2. 添加空元素清理 ❌</h3>
<p>html</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"float: left;"</span>&gt;</span>浮动元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"clear: both;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 不推荐 --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><strong>缺点</strong>：增加了无意义的HTML元素，污染了文档结构。</p>
<h3 data-id="heading-7">3. 伪元素清除法 ✅</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
  <span class="hljs-attribute">display</span>: block;
  <span class="hljs-attribute">clear</span>: both;
}
</code></pre>
<p><strong>优点</strong>：语义清晰，无需额外HTML元素。</p>
<h3 data-id="heading-8">4. 受影响元素清除法 ❌</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.next-element</span> {
  <span class="hljs-attribute">clear</span>: both; <span class="hljs-comment">/* 不推荐 */</span>
}
</code></pre>
<p><strong>缺点</strong>：治标不治本，每个受影响的元素都需要单独处理。</p>
<h3 data-id="heading-9">5. 触发BFC ✅</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.parent</span> {
  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 创建BFC */</span>
}
</code></pre>
<p><strong>优点</strong>：一劳永逸，同时解决了其他布局问题。</p>
<h2 data-id="heading-10">BFC：布局世界的守护者</h2>
<h3 data-id="heading-11">什么是BFC？</h3>
<p>BFC（Block Formatting Context，块级格式化上下文）就像是页面中的一个<strong>独立王国</strong>，拥有自己的一套渲染规则，内部元素不会影响到外部元素。</p>
<h3 data-id="heading-12">如何创建BFC？</h3>
<p>创建BFC的方法多种多样：</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-comment">/* 任意一种即可 */</span>
  <span class="hljs-attribute">overflow</span>: hidden | auto | scroll;
  <span class="hljs-attribute">position</span>: absolute | fixed;
  <span class="hljs-attribute">float</span>: left | right;
  <span class="hljs-attribute">display</span>: inline-block | flex | grid;
}
</code></pre>
<h3 data-id="heading-13">BFC的三大超能力</h3>
<ol>
<li>
<p><strong>正常流排列</strong>：BFC内的元素依然按照从上往下、从左往右的顺序排列</p>
</li>
<li>
<p><strong>Margin折叠防护</strong>：解决了父子元素margin重叠的经典问题
html</p>
</li>
</ol>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span> <span class="hljs-comment">&lt;!-- 如果没有BFC，两个margin会重叠 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin-top: 50px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<ol start="3">
<li><strong>浮动元素收纳</strong>：BFC会自动计算内部浮动元素的高度，彻底解决高度塌陷问题</li>
</ol>
<h2 data-id="heading-14">实战演练：选择最佳方案</h2>
<p>在实际开发中，我强烈推荐两种方案：</p>
<h3 data-id="heading-15">方案一：伪元素清除法（兼容性好）</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
  <span class="hljs-attribute">display</span>: table;
  <span class="hljs-attribute">clear</span>: both;
}
</code></pre>
<h3 data-id="heading-16">方案二：BFC方案（现代推荐）</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 或者使用display: flow-root */</span>
}
</code></pre>
<p>特别是<code>display: flow-root</code>，它是专门为创建BFC而设计的属性，不会产生任何副作用：</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">display</span>: flow-root; <span class="hljs-comment">/* 创建BFC的最佳实践 */</span>
}
</code></pre>
<h2 data-id="heading-17">总结</h2>
<p>浮动布局虽然逐渐被Flexbox和Grid等现代布局技术所取代，但理解它的工作原理和相关问题仍然是前端开发者的必备技能。BFC作为解决浮动问题的利器，其价值不仅仅体现在清除浮动上，更在于它提供了一种隔离的布局环境。</p>
<p>记住，当你下次遇到布局问题时，不妨思考一下：是不是浮动在作怪？要不要请BFC来帮忙？</p>
<p>希望这篇文章能帮助你彻底理解浮动和BFC，让你的页面布局不再"飘忽不定"！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 Spring Bean 生命周期：从实例化到销毁]]></title>    <link>https://juejin.cn/post/7572697146287308850</link>    <guid>https://juejin.cn/post/7572697146287308850</guid>    <pubDate>2025-11-16T07:34:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572697146287308850" data-draft-id="7572749797468782601" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 Spring Bean 生命周期：从实例化到销毁"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-16T07:34:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OlahOlah"/> <meta itemprop="url" content="https://juejin.cn/user/1576016232062667"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 Spring Bean 生命周期：从实例化到销毁
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1576016232062667/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OlahOlah
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T07:34:42.000Z" title="Sun Nov 16 2025 07:34:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Spring 框架中，Bean 的生命周期是理解容器管理机制的核心。本文将通过图示和代码示例，详细解析 Spring Bean 从创建到销毁的完整流程，并解答常见疑问：是否可以在初始化前跳过属性赋值？</p>
<h2 data-id="heading-0">Bean 生命周期概览</h2>
<p>Spring Bean 的生命周期大致分为以下几个阶段：</p>
<ol>
<li><strong>实例化</strong>：通过构造方法创建 Bean 对象。</li>
<li><strong>属性赋值</strong>：为 Bean 的依赖和属性注入值。</li>
<li><strong>BeanNameAware</strong>：设置 Bean 名称。</li>
<li><strong>BeanFactoryAware</strong>：设置 BeanFactory。</li>
<li><strong>ApplicationContextAware</strong>：设置 ApplicationContext。</li>
<li><strong>初始化前处理</strong>：<code>BeanPostProcessor.postProcessBeforeInitialization</code>。</li>
<li><strong>@PostConstruct 注解方法</strong>：初始化逻辑执行。</li>
<li><strong>InitializingBean.afterPropertiesSet</strong>：属性设置完成后的回调。</li>
<li><strong>自定义 init 方法</strong>：通过 <code>@Bean(initMethod)</code> 指定。</li>
<li><strong>初始化后处理</strong>：<code>BeanPostProcessor.postProcessAfterInitialization</code>。</li>
<li><strong>Bean 使用阶段</strong>：Bean 已准备就绪，可用于业务逻辑。</li>
<li><strong>@PreDestroy 注解方法</strong>：销毁前回调。</li>
<li><strong>DisposableBean.destroy</strong>：销毁方法执行。</li>
<li><strong>自定义 destroy 方法</strong>：通过 <code>@Bean(destroyMethod)</code> 指定。</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc41a47faafd45a98f4e6ce59e248a18~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT2xhaE9sYWg=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763883346&amp;x-signature=zfF3OCOGIPLLZEWzskWbB3e%2FKAA%3D" alt="Spring Bean 生命周期" loading="lazy"/></p>
<h2 data-id="heading-1">代码示例</h2>
<h3 data-id="heading-2">1. 主配置类</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Configuration</span>
<span class="hljs-variable">@ComponentScan</span>(<span class="hljs-string">"com.example.lifecycle"</span>)
public class AppConfig {
    <span class="hljs-variable">@Bean</span>(initMethod = <span class="hljs-string">"customInit"</span>, destroyMethod = <span class="hljs-string">"customDestroy"</span>)
    public ExampleBean <span class="hljs-built_in">exampleBean</span>() {
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ExampleBean</span>();
    }
}
</code></pre>
<h3 data-id="heading-3">2. Bean 生命周期类</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> <span class="hljs-title">implements</span>
        <span class="hljs-title">BeanNameAware</span>,
        <span class="hljs-title">BeanFactoryAware</span>,
        <span class="hljs-title">ApplicationContextAware</span>,
        <span class="hljs-title">InitializingBean</span>,
        <span class="hljs-title">DisposableBean</span> {

    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExampleBean</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"1. Bean 实例化 - 构造函数执行"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(<span class="hljs-params">String name</span>)</span> {
        <span class="hljs-keyword">this</span>.name = name;
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"2. 属性赋值 - 设置属性值: "</span> + name);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span>(<span class="hljs-params">String name</span>)</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"3. BeanNameAware - Bean 名称: "</span> + name);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span>(<span class="hljs-params">BeanFactory beanFactory</span>) throws BeansException</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"4. BeanFactoryAware - 设置 BeanFactory"</span>);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span>(<span class="hljs-params">ApplicationContext applicationContext</span>) throws BeansException</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"5. ApplicationContextAware - 设置 ApplicationContext"</span>);
    }

    @PostConstruct
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postConstruct</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"7. @PostConstruct - 初始化方法"</span>);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span>() throws Exception</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"8. InitializingBean.afterPropertiesSet - 属性设置完成后"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customInit</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"9. 自定义 init 方法 - @Bean(initMethod)"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"11. Bean 使用中 - 业务方法执行"</span>);
    }

    @PreDestroy
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preDestroy</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"12. @PreDestroy - 销毁前方法"</span>);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>() throws Exception</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"13. DisposableBean.destroy - 销毁方法"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customDestroy</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"14. 自定义 destroy 方法 - @Bean(destroyMethod)"</span>);
    }
}
</code></pre>
<h3 data-id="heading-4">3. BeanPostProcessor 实现</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> {
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ExampleBean</span>) {
            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"6. BeanPostProcessor.postProcessBeforeInitialization - 初始化前处理"</span>);
        }
        <span class="hljs-keyword">return</span> bean;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> {
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ExampleBean</span>) {
            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"10. BeanPostProcessor.postProcessAfterInitialization - 初始化后处理"</span>);
        }
        <span class="hljs-keyword">return</span> bean;
    }
}
</code></pre>
<h3 data-id="heading-5">4. 测试类</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleTest</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>{
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"=== Spring Bean 生命周期演示 ==="</span>);
        
        AnnotationConfigApplicationContext context = 
            <span class="hljs-keyword">new</span> <span class="hljs-built_in">AnnotationConfigApplicationContext</span>(AppConfig.<span class="hljs-keyword">class</span>);
        
        ExampleBean exampleBean = context.<span class="hljs-built_in">getBean</span>(ExampleBean.<span class="hljs-keyword">class</span>);
        exampleBean.<span class="hljs-built_in">doSomething</span>();
        
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"=== 关闭 Spring 容器 ==="</span>);
        context.<span class="hljs-built_in">close</span>();
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-6">输出结果</h2>
<pre><code class="hljs language-markdown" lang="markdown">=== Spring Bean 生命周期演示 ===
<span class="hljs-bullet">1.</span> Bean 实例化 - 构造函数执行
<span class="hljs-bullet">2.</span> 属性赋值 - 设置属性值: null
<span class="hljs-bullet">3.</span> BeanNameAware - Bean 名称: exampleBean
<span class="hljs-bullet">4.</span> BeanFactoryAware - 设置 BeanFactory
<span class="hljs-bullet">5.</span> ApplicationContextAware - 设置 ApplicationContext
<span class="hljs-bullet">6.</span> BeanPostProcessor.postProcessBeforeInitialization - 初始化前处理
<span class="hljs-bullet">7.</span> @PostConstruct - 初始化方法
<span class="hljs-bullet">8.</span> InitializingBean.afterPropertiesSet - 属性设置完成后
<span class="hljs-bullet">9.</span> 自定义 init 方法 - @Bean(initMethod)
<span class="hljs-bullet">10.</span> BeanPostProcessor.postProcessAfterInitialization - 初始化后处理
<span class="hljs-bullet">11.</span> Bean 使用中 - 业务方法执行
=== 关闭 Spring 容器 ===
<span class="hljs-bullet">12.</span> @PreDestroy - 销毁前方法
<span class="hljs-bullet">13.</span> DisposableBean.destroy - 销毁方法
<span class="hljs-bullet">14.</span> 自定义 destroy 方法 - @Bean(destroyMethod)
</code></pre>
<h2 data-id="heading-7">初始化前是否可以跳过属性赋值？</h2>
<p>答案是否定的。Spring 的设计理念是：</p>
<blockquote>
<p><strong>属性赋值必须在初始化阶段之前完成</strong></p>
</blockquote>
<p>原因如下：</p>
<ol>
<li>初始化逻辑通常依赖 Bean 已经注入的属性。</li>
<li>如果初始化方法提前执行，未注入属性可能导致 <code>NullPointerException</code> 或状态不完整。</li>
<li>Bean 的生命周期有严格顺序，确保每个阶段都能安全执行。</li>
</ol>
<p>因此，即便在 <code>@PostConstruct</code>、<code>InitializingBean.afterPropertiesSet</code> 或自定义初始化方法中访问 Bean 属性，也可以放心使用，不会出现未赋值的情况。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[try...catch 核心与生态协作全解析]]></title>    <link>https://juejin.cn/post/7572757056438534153</link>    <guid>https://juejin.cn/post/7572757056438534153</guid>    <pubDate>2025-11-16T13:32:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572757056438534153" data-draft-id="7568425510793068544" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" try...catch 核心与生态协作全解析"/> <meta itemprop="keywords" content="JavaScript,前端,Vue.js"/> <meta itemprop="datePublished" content="2025-11-16T13:32:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="拉不动的猪"/> <meta itemprop="url" content="https://juejin.cn/user/1429793504759630"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             try...catch 核心与生态协作全解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1429793504759630/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    拉不动的猪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T13:32:23.000Z" title="Sun Nov 16 2025 13:32:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    16
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="arta">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#222}.hljs-subst,.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#aaa}.hljs-section{color:#fff}.hljs-comment,.hljs-meta,.hljs-quote{color:#444}.hljs-bullet,.hljs-regexp,.hljs-string,.hljs-symbol{color:#fc3}.hljs-addition,.hljs-number{color:#0c6}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-template-variable,.hljs-type{color:#32aaee}.hljs-keyword,.hljs-name,.hljs-selector-class,.hljs-selector-id,.hljs-selector-tag{color:#64a}.hljs-deletion,.hljs-template-tag,.hljs-title,.hljs-variable{color:#b16}.hljs-doctag,.hljs-section,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}</style><h2 data-id="heading-0">一、try...catch 本质：为何需要它？（从程序失控到可控）</h2>
<p>在 JavaScript 执行过程中，代码常因变量未定义、类型错误、API 调用失败等问题中断。若缺乏异常处理，同步代码会直接崩溃，异步代码会陷入不可预知状态。<code>try...catch</code> 的核心价值是<strong>将 “不可控的错误中断” 转化为 “可控的逻辑处理”</strong> ，避免程序崩溃并提供补救机会，是保障代码健壮性的基础机制。</p>
<h3 data-id="heading-1">1.1 无 try...catch 时的问题</h3>
<p>代码报错后直接终止，后续逻辑无法执行，影响用户体验。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'invalid json'</span>); <span class="hljs-comment">// 报错：Unexpected token i in JSON at position 0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'程序继续执行'</span>); <span class="hljs-comment">// 不会执行，代码中断</span>
</code></pre>
<h3 data-id="heading-2">1.2 有 try...catch 时的优化</h3>
<p>错误被捕获后，可执行补救逻辑，程序正常流转。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'invalid json'</span>);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'解析失败，使用默认数据'</span>); <span class="hljs-comment">// 执行补救操作</span>
  <span class="hljs-keyword">const</span> data = { <span class="hljs-attr">default</span>: <span class="hljs-string">'value'</span> }; 
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'程序继续执行'</span>); <span class="hljs-comment">// 正常执行，无中断</span>
</code></pre>
<h2 data-id="heading-3">二、try...catch 与核心技术的关联：从基础到扩展</h2>
<p><code>try...catch</code> 并非仅与 <code>Promise</code>、<code>axios</code> 相关，而是贯穿 JavaScript 全场景的通用机制，以下从核心关联、跨界场景两方面详细解析。</p>
<h3 data-id="heading-4">2.1 与 Promise、async/await 的底层关联</h3>
<p><code>try...catch</code> 本质是<strong>同步错误捕获工具</strong>，而 <code>Promise</code> 处理异步操作，二者需配合实现 “同步 + 异步” 全场景错误处理。</p>
<h4 data-id="heading-5">2.1.1 Promise 为何需要独立错误处理？</h4>
<p>异步代码（如定时器、网络请求）的错误发生在 “当前事件循环之外”，<code>try...catch</code> 无法直接捕获。<code>Promise</code> 设计 <code>.catch()</code> 方法，专门捕获异步执行中的错误（包括 <code>reject</code> 和执行器内同步错误）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// try...catch 无法捕获 Promise 内部异步错误</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'异步错误'</span>); <span class="hljs-comment">// 错误发生在定时器回调，属异步</span>
    }, <span class="hljs-number">100</span>);
  });
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获不到'</span>, error); <span class="hljs-comment">// 不执行</span>
}

<span class="hljs-comment">// 需用 Promise 的 .catch() 捕获</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'异步错误'</span>);
  }, <span class="hljs-number">100</span>);
}).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获到'</span>, error); <span class="hljs-comment">// 正常执行</span>
});
</code></pre>
<h4 data-id="heading-6">2.1.2 async/await 如何让 try...catch 接管异步错误？</h4>
<p><code>async/await</code> 是 <code>Promise</code> 语法糖，能将异步代码 “伪装” 成同步执行顺序，使 <code>try...catch</code> 可同时捕获 “同步错误” 和 “await 后的 Promise 错误”（<code>await</code> 等待 Promise 状态变更时，异步错误转化为 “等待阶段错误”）。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> function <span class="hljs-title">fetchData</span>()</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 同步错误：未定义变量</span>
    <span class="hljs-keyword">const</span> invalid = undefinedVariable; 
    <span class="hljs-comment">// 异步错误：axios 请求失败（返回 rejected Promise）</span>
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/invalid-api'</span>); 
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 同步、异步错误均被捕获</span>
    console.log(<span class="hljs-string">'捕获到所有错误：'</span>, error); 
  }
}
</code></pre>
<h3 data-id="heading-7">2.2 与 axios 的协作逻辑</h3>
<p><code>axios</code> 是基于 <code>Promise</code> 的 HTTP 客户端，其错误分两类，需通过 <code>try...catch</code> 或 <code>.catch()</code> 统一处理：</p>
<ul>
<li>网络错误（如断网）：直接触发 <code>reject</code>；</li>
<li>HTTP 错误（如 404/500）：默认触发 <code>reject</code>，可通过 <code>validateStatus</code> 配置修改。</li>
</ul>
<h4 data-id="heading-8">2.2.1 用 .catch () 处理 axios 错误</h4>
<pre><code class="hljs language-lua" lang="lua">axios.get(<span class="hljs-string">'/api/data'</span>)
  .<span class="hljs-keyword">then</span>(response =&gt; {
    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'请求成功:'</span>, response.data);
  })
  .catch(<span class="hljs-built_in">error</span> =&gt; {
    // 捕获网络错误或 HTTP 错误
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">error</span>.response) {
      console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'HTTP 错误状态码:'</span>, <span class="hljs-built_in">error</span>.response.<span class="hljs-built_in">status</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">error</span>.request) {
      console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'网络错误，无响应:'</span>, <span class="hljs-built_in">error</span>.request);
    }
  });
</code></pre>
<h4 data-id="heading-9">2.2.2 用 try...catch 处理 axios 错误（async/await 场景）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserData</span>(<span class="hljs-params">userId</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>);
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 统一捕获并细化处理</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>?.<span class="hljs-property">status</span> === <span class="hljs-number">404</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'用户不存在'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'获取用户数据失败:'</span>, error);
    <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 需上层处理时重新抛出</span>
  }
}
</code></pre>
<h3 data-id="heading-10">2.3 跨界关联场景：不止于 Promise、axios</h3>
<p><code>try...catch</code> 可捕获 “当前执行上下文” 中所有同步错误，覆盖 DOM 操作、Node.js 核心模块、第三方库等场景。</p>
<h4 data-id="heading-11">2.3.1 与 DOM 操作的协作</h4>
<p>DOM 操作易因 “元素不存在”“修改只读属性” 出错，<code>try...catch</code> 可避免页面功能瘫痪。</p>
<pre><code class="hljs language-ini" lang="ini">function renderUserList(users) {
  try {
    const <span class="hljs-attr">list</span> = document.getElementById(<span class="hljs-string">'user-list'</span>)<span class="hljs-comment">;</span>
    // 若 list 不存在或 users 格式异常，直接报错
    users.forEach(<span class="hljs-attr">user</span> =&gt; {
      const <span class="hljs-attr">item</span> = document.createElement(<span class="hljs-string">'li'</span>)<span class="hljs-comment">;</span>
      <span class="hljs-attr">item.textContent</span> = user.name<span class="hljs-comment">; // 若 user 无 name 属性，触发错误</span>
      list.appendChild(item)<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
  } catch (error) {
    console.error('渲染失败：', error)<span class="hljs-comment">;</span>
    // 降级处理：显示错误提示而非白屏
    <span class="hljs-attr">document.body.innerHTML</span> = <span class="hljs-string">'&lt;p&gt;加载用户列表失败，请刷新重试&lt;/p&gt;'</span><span class="hljs-comment">;</span>
  }
}
</code></pre>
<h4 data-id="heading-12">2.3.2 与 Node.js 核心模块的配合</h4>
<p>Node.js 中同步 API（如 <code>fs.readFileSync</code>）的错误需 <code>try...catch</code> 捕获，否则导致进程崩溃。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">readConfig</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 同步读取文件，文件不存在/权限不足时抛出错误</span>
    <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'./config.json'</span>, <span class="hljs-string">'utf8'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(content); <span class="hljs-comment">// 解析失败也被捕获</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'配置文件读取失败：'</span>, error);
    <span class="hljs-comment">// 返回默认配置，保证程序正常启动</span>
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">default</span>: <span class="hljs-string">'config'</span> }; 
  }
}
</code></pre>
<h4 data-id="heading-13">2.3.3 与第三方库的兼容</h4>
<p>第三方库（如 <code>moment</code>、<code>Redux</code>）的同步方法可能因无效参数抛出错误，<code>try...catch</code> 是通用防护手段。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">'moment'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params">dateString</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 若 dateString 格式无效，moment 格式化会报错</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">moment</span>(dateString).<span class="hljs-title function_">format</span>(<span class="hljs-string">'YYYY-MM-DD'</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'日期格式化失败：'</span>, error);
    <span class="hljs-comment">// 友好提示，避免暴露技术错误</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">'无效日期'</span>; 
  }
}
</code></pre>
<h2 data-id="heading-14">三、复杂项目场景：try...catch 的实战应用</h2>
<p>在多任务依赖、并行执行等复杂场景中，<code>try...catch</code> 与 <code>Promise</code> 组合可实现 “错误隔离”“流程可控”，避免局部错误影响全局。</p>
<h3 data-id="heading-15">3.1 分步依赖任务：串联式任务队列</h3>
<p>场景：先获取 Token → 用 Token 拉取用户 ID → 提交表单，某一步出错需中断并提示。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 任务1：获取 Token</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getToken</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/auth'</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>)
    .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`获取 Token 失败：<span class="hljs-subst">${err.message}</span>`</span>); <span class="hljs-comment">// 包装错误上下文</span>
    });
}

<span class="hljs-comment">// 任务2：用 Token 获取用户 ID</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params">token</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/user'</span>, { <span class="hljs-attr">headers</span>: { token } });
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>.<span class="hljs-property">id</span>;
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`获取用户 ID 失败：<span class="hljs-subst">${err.message}</span>`</span>); <span class="hljs-comment">// 补充错误信息</span>
  }
}

<span class="hljs-comment">// 任务3：提交表单（依赖用户 ID）</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">submitForm</span>(<span class="hljs-params">userId, formData</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/submit'</span>, { ...formData, userId });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'提交成功'</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`提交表单失败：<span class="hljs-subst">${err.message}</span>`</span>);
  }
}

<span class="hljs-comment">// 主流程：统一控制，汇总错误</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">formData</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getToken</span>();
    <span class="hljs-keyword">const</span> userId = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserId</span>(token);
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">submitForm</span>(userId, formData);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 所有步骤错误汇总到此处，统一提示+上报</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'流程中断：'</span>, error.<span class="hljs-property">message</span>);
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`操作失败：<span class="hljs-subst">${error.message}</span>`</span>);
    <span class="hljs-comment">// 上报错误到监控系统（附带用户/时间等上下文）</span>
    <span class="hljs-title function_">logErrorToServer</span>({
      <span class="hljs-attr">message</span>: error.<span class="hljs-property">message</span>,
      <span class="hljs-attr">stack</span>: error.<span class="hljs-property">stack</span>,
      <span class="hljs-attr">context</span>: { <span class="hljs-attr">userId</span>: <span class="hljs-string">'xxx'</span>, <span class="hljs-attr">time</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() }
    });
  }
}
</code></pre>
<h3 data-id="heading-16">3.2 并行任务：错误隔离不中断整体</h3>
<p>场景：页面同时渲染 3 个独立组件（用户信息、订单列表、消息通知），一个组件出错不影响其他组件。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 组件1：渲染用户信息</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">renderUserInfo</span>(<span class="hljs-params">userId</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/user/<span class="hljs-subst">${userId}</span>`</span>);
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'user-info'</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`&lt;p&gt;<span class="hljs-subst">${user.data.name}</span>&lt;/p&gt;`</span>;
      <span class="hljs-title function_">resolve</span>();
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-title function_">reject</span>(<span class="hljs-string">`用户信息组件失败：<span class="hljs-subst">${err.message}</span>`</span>);
    }
  });
}

<span class="hljs-comment">// 组件2：渲染订单列表</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">renderOrderList</span>(<span class="hljs-params">userId</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> orders = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/orders/<span class="hljs-subst">${userId}</span>`</span>);
      <span class="hljs-comment">// 渲染逻辑...</span>
      <span class="hljs-title function_">resolve</span>();
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-title function_">reject</span>(<span class="hljs-string">`订单列表组件失败：<span class="hljs-subst">${err.message}</span>`</span>);
    }
  });
}

<span class="hljs-comment">// 主流程：并行渲染，错误隔离</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderAllComponents</span>(<span class="hljs-params">userId</span>) {
  <span class="hljs-comment">// 用 Promise.allSettled 捕获所有结果，成功/失败均不中断</span>
  <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([
    <span class="hljs-title function_">renderUserInfo</span>(userId),
    <span class="hljs-title function_">renderOrderList</span>(userId),
    <span class="hljs-title function_">renderMessageList</span>(userId) <span class="hljs-comment">// 组件3：渲染消息通知</span>
  ]);

  <span class="hljs-comment">// 处理失败结果，单独提示</span>
  results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result, index</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">'rejected'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`组件<span class="hljs-subst">${index+<span class="hljs-number">1</span>}</span>渲染失败：`</span>, result.<span class="hljs-property">reason</span>);
      <span class="hljs-comment">// 标记失败组件，不影响其他组件展示</span>
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.component'</span>)[index].<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'error'</span>);
    }
  });
}
</code></pre>
<h2 data-id="heading-17">四、try...catch 的局限性：并非万能</h2>
<p>尽管 <code>try...catch</code> 是基础机制，但存在明显短板，需结合其他方案规避。</p>
<h3 data-id="heading-18">4.1 无法捕获的错误类型</h3>
<ul>
<li>
<p><strong>语法错误与解析错误</strong>：代码存在语法问题（如括号不匹配）或解析阶段错误（如 <code>import</code> 不存在的模块），脚本加载时直接报错，<code>try...catch</code> 无法捕获。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 语法错误：缺少右括号</span>
  <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a; 
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-comment">// 不执行，脚本解析阶段已报错</span>
}
</code></pre>
</li>
<li>
<p><strong>非 Promise 异步错误</strong>：不基于 <code>Promise</code> 的异步操作（如回调函数），错误无法被 <code>try...catch</code> 捕获。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">try</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'定时器错误'</span>); <span class="hljs-comment">// 异步回调错误，无法捕获</span>
  }, <span class="hljs-number">100</span>);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获不到'</span>, error); <span class="hljs-comment">// 不执行</span>
}
</code></pre>
</li>
</ul>
<h3 data-id="heading-19">4.2 功能上的不足</h3>
<ul>
<li>
<p><strong>过度捕获掩盖逻辑错误</strong>：包裹大段代码时，会捕获 “预期外错误”（如变量拼写错误），增加调试难度。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 逻辑错误：变量名拼写错误（应为 user.name）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uesr.<span class="hljs-property">name</span>); 
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'出错了，但无法定位是拼写错还是其他错'</span>); <span class="hljs-comment">// 掩盖真实问题</span>
}
</code></pre>
</li>
<li>
<p><strong>性能损耗</strong>：<code>try...catch</code> 会影响 JavaScript 引擎优化（如 V8 即时编译），高频执行场景（如循环）中过度使用会导致性能下降。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 反例：循环中频繁使用 try...catch，性能损耗明显</span>
for (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
  try {
    <span class="hljs-built_in">processData</span>(i); <span class="hljs-comment">// 高频执行，不建议包裹</span>
  } catch (error) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
</li>
</ul>
<h2 data-id="heading-20">五、try...catch 与其他机制的生态协作</h2>
<p>现代开发中，<code>try...catch</code> 需与全局错误监听、框架错误边界等配合，形成多层防护体系。</p>
<h3 data-id="heading-21">5.1 与全局错误监听的配合</h3>
<p><code>window.onerror</code> 或 <code>window.addEventListener('error')</code> 可捕获 <code>try...catch</code> 未处理的 “漏网之鱼”（如未被捕获的 Promise 错误、跨域脚本错误），作为最后兜底。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 全局错误兜底，捕获未处理错误</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-comment">// 过滤资源加载错误（如图片加载失败），只处理脚本错误</span>
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">message</span> !== <span class="hljs-string">'Script error.'</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'全局未捕获错误：'</span>, event.<span class="hljs-property">error</span>);
    <span class="hljs-comment">// 上报到监控系统，避免错误静默</span>
    <span class="hljs-title function_">logErrorToServer</span>(event.<span class="hljs-property">error</span>);
  }
});

<span class="hljs-comment">// 捕获未处理的 Promise 错误</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'unhandledrejection'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'未处理的 Promise 错误：'</span>, event.<span class="hljs-property">reason</span>);
  event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 阻止浏览器默认提示</span>
  <span class="hljs-title function_">logErrorToServer</span>(event.<span class="hljs-property">reason</span>);
});
</code></pre>
<h3 data-id="heading-22">5.2 与框架错误边界的协作</h3>
<p>在 React、Vue 等框架中，组件渲染错误需用 “错误边界” 处理，<code>try...catch</code> 负责逻辑错误，错误边界负责渲染错误，分工明确。</p>
<h4 data-id="heading-23">5.2.1 React 错误边界示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  state = { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> };

  <span class="hljs-comment">// 捕获子组件渲染错误</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// 更新状态，显示降级 UI</span>
  }

  <span class="hljs-comment">// 日志上报</span>
  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'组件渲染错误：'</span>, error, errorInfo);
    <span class="hljs-title function_">logErrorToServer</span>({ error, errorInfo });
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>组件加载失败，请刷新重试<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>; <span class="hljs-comment">// 降级 UI</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;
  }
}

<span class="hljs-comment">// 使用：包裹可能出错的组件</span>
&lt;<span class="hljs-title class_">ErrorBoundary</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">{123}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">ErrorBoundary</span>&gt;
</code></pre>
<h2 data-id="heading-24">六、总结</h2>
<h3 data-id="heading-25">6.1 核心定位</h3>
<p><code>try...catch</code> 是 <strong>JavaScript 错误处理的 “基础设施”</strong> ，而非 “最优解”：</p>
<ul>
<li>基础作用：捕获同步错误，配合 <code>async/await</code> 捕获 Promise 异步错误；</li>
<li>生态角色：与 <code>Promise.catch()</code>、全局监听、框架错误边界配合，形成 “多层防护”；</li>
<li>价值核心：保障程序可控性，实现优雅降级与错误上报。</li>
</ul>
<h3 data-id="heading-26">6.2 最佳应用</h3>
<ol>
<li>
<p><strong>精准捕获，避免过度包裹</strong>：只包裹 “预期可能出错的代码段”（如网络请求、JSON 解析），不包裹大段逻辑；</p>
</li>
<li>
<p><strong>保留错误上下文</strong>：捕获错误后需 <code>throw error</code> 重新抛出（需上层处理时），避免丢失错误栈信息；</p>
</li>
<li>
<p><strong>结合场景选择处理方式</strong>：</p>
<ul>
<li>同步代码：直接用 <code>try...catch</code>；</li>
<li>纯 Promise 异步：用 <code>.catch()</code>；</li>
<li><code>async/await</code> 场景：用 <code>try...catch</code> 统一处理；</li>
<li>并行任务：用 <code>Promise.allSettled</code> 配合 <code>try...catch</code> 隔离错误；</li>
</ul>
</li>
<li>
<p><strong>补充错误上下文</strong>：抛出错误时添加业务信息（如用户 ID、订单号），便于排查；</p>
</li>
<li>
<p><strong>兜底机制不可少</strong>：全局错误监听 + 框架错误边界，覆盖 <code>try...catch</code> 未处理的场景。</p>
</li>
</ol>
<h2 data-id="heading-27">七、实际应用场景举例</h2>
<h3 data-id="heading-28">1. 同步代码场景（基础）</h3>
<p><strong>适用</strong>：JSON 解析、变量类型转换、同步函数调用等。<strong>模板</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">function syncOperation(<span class="hljs-keyword">data</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 可能出错的同步操作（如解析、类型转换）</span>
    <span class="hljs-keyword">const</span> parsed = JSON.parse(<span class="hljs-keyword">data</span>); <span class="hljs-comment">// 可能抛错</span>
    <span class="hljs-keyword">const</span> result = parsed.value.toUpperCase(); <span class="hljs-comment">// 可能抛错（若 parsed.value 不存在）</span>
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 1. 补充上下文（必做）</span>
    error.context = { <span class="hljs-keyword">data</span>, operation: <span class="hljs-string">'syncOperation'</span> };
    <span class="hljs-comment">// 2. 可处理则补救，否则抛出</span>
    <span class="hljs-keyword">if</span> (error.name === <span class="hljs-string">'SyntaxError'</span>) {
      console.warn(<span class="hljs-string">'数据格式错误，使用默认值'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-string">'default'</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 传递给上层处理</span>
    }
  }
}
</code></pre>
<h3 data-id="heading-29">2. DOM 操作场景</h3>
<p><strong>适用</strong>：动态创建元素、修改 DOM 属性、事件绑定等（易因元素不存在 / 权限问题出错）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDOM</span>(<span class="hljs-params">elementId, content</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(elementId);
    <span class="hljs-keyword">if</span> (!el) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`元素 <span class="hljs-subst">${elementId}</span> 不存在`</span>); <span class="hljs-comment">// 主动抛错，明确上下文</span>
    
    <span class="hljs-comment">// 可能出错的 DOM 操作</span>
    el.<span class="hljs-property">textContent</span> = content; 
    el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'active'</span>); <span class="hljs-comment">// 若 classList 不支持（极旧浏览器）会抛错</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'DOM 更新失败：'</span>, error.<span class="hljs-property">message</span>);
    <span class="hljs-comment">// 降级处理：显示错误提示，不影响页面其他功能</span>
    <span class="hljs-keyword">const</span> errorEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
    errorEl.<span class="hljs-property">className</span> = <span class="hljs-string">'error'</span>;
    errorEl.<span class="hljs-property">textContent</span> = <span class="hljs-string">`加载失败：<span class="hljs-subst">${error.message}</span>`</span>;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(errorEl);
  }
}
</code></pre>
<h3 data-id="heading-30">3. Node.js 同步 API 场景</h3>
<p><strong>适用</strong>：文件读写（<code>fs.readFileSync</code>）、路径处理（<code>path.resolve</code>）等同步操作（出错会导致进程崩溃）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">readLocalFile</span>(<span class="hljs-params">filePath</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">resolve</span>(filePath); <span class="hljs-comment">// 路径解析可能抛错</span>
    <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(fullPath, <span class="hljs-string">'utf8'</span>); <span class="hljs-comment">// 文件不存在/权限不足会抛错</span>
    <span class="hljs-keyword">return</span> content;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 区分错误类型，针对性处理</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">code</span> === <span class="hljs-string">'ENOENT'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`文件不存在：<span class="hljs-subst">${filePath}</span>，返回空内容`</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">code</span> === <span class="hljs-string">'EACCES'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`权限不足，无法读取 <span class="hljs-subst">${filePath}</span>`</span>);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'文件访问权限不足，请检查配置'</span>); <span class="hljs-comment">// 上层需处理的严重错误</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> error;
    }
  }
}
</code></pre>
<h3 data-id="heading-31">4. 异步场景（<code>Promise</code> + <code>async/await</code>）</h3>
<h4 data-id="heading-32">4.1 单异步任务（<code>async/await</code>）</h4>
<p><strong>适用</strong>：单个网络请求、异步 API 调用（如 <code>axios</code> 请求）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchSingleData</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(url);
    <span class="hljs-comment">// 主动校验业务错误（如接口返回 code 非 0）</span>
    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> !== <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`业务错误：<span class="hljs-subst">${response.data.msg}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 区分网络错误和业务错误</span>
    <span class="hljs-keyword">let</span> errorMsg;
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) {
      <span class="hljs-comment">// HTTP 错误（404/500 等）</span>
      errorMsg = <span class="hljs-string">`请求失败[<span class="hljs-subst">${error.response.status}</span>]：<span class="hljs-subst">${url}</span>`</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">request</span>) {
      <span class="hljs-comment">// 网络错误（无响应）</span>
      errorMsg = <span class="hljs-string">`网络错误，无法连接：<span class="hljs-subst">${url}</span>`</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 业务错误或其他</span>
      errorMsg = error.<span class="hljs-property">message</span>;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(errorMsg);
    <span class="hljs-comment">// 非致命错误可返回默认值，避免流程中断</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; 
  }
}
</code></pre>
<h4 data-id="heading-33">4.2 多依赖异步任务（串联）</h4>
<p><strong>适用</strong>：任务 A → 任务 B（依赖 A 的结果）→ 任务 C（依赖 B 的结果）。<strong>模板</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">taskA</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* ... */</span> } <span class="hljs-comment">// 返回 Promise</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">taskB</span>(<span class="hljs-params">resultA</span>) { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">taskC</span>(<span class="hljs-params">resultB</span>) { <span class="hljs-comment">/* ... */</span> }

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runTasks</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> resA = <span class="hljs-keyword">await</span> <span class="hljs-title function_">taskA</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'任务 A 完成'</span>);
    
    <span class="hljs-keyword">const</span> resB = <span class="hljs-keyword">await</span> <span class="hljs-title function_">taskB</span>(resA);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'任务 B 完成'</span>);
    
    <span class="hljs-keyword">const</span> resC = <span class="hljs-keyword">await</span> <span class="hljs-title function_">taskC</span>(resB);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'所有任务完成'</span>);
    <span class="hljs-keyword">return</span> resC;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 任何一步失败都会中断，统一处理</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`任务中断：<span class="hljs-subst">${error.message}</span>`</span>);
    <span class="hljs-comment">// 记录中断位置（通过 error 上下文）</span>
    error.<span class="hljs-property">task</span> = error.<span class="hljs-property">task</span> || <span class="hljs-string">'未知任务'</span>; <span class="hljs-comment">// 可在子任务中添加 task 字段</span>
    <span class="hljs-title function_">logToMonitor</span>(error); <span class="hljs-comment">// 上报监控</span>
    <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 允许上层重试</span>
  }
}
</code></pre>
<h4 data-id="heading-34">4.3 多独立异步任务（并行）</h4>
<p><strong>适用</strong>：多个无依赖的异步任务（如同时渲染多个组件），需隔离错误。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentA</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentB</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentC</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* ... */</span> }

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderAll</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 用 Promise.allSettled 确保所有任务执行完毕（无论成功失败）</span>
  <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([
    <span class="hljs-title function_">componentA</span>().<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> ({ <span class="hljs-attr">error</span>: err, <span class="hljs-attr">component</span>: <span class="hljs-string">'A'</span> })),
    <span class="hljs-title function_">componentB</span>().<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> ({ <span class="hljs-attr">error</span>: err, <span class="hljs-attr">component</span>: <span class="hljs-string">'B'</span> })),
    <span class="hljs-title function_">componentC</span>().<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> ({ <span class="hljs-attr">error</span>: err, <span class="hljs-attr">component</span>: <span class="hljs-string">'C'</span> }))
  ]);

  <span class="hljs-comment">// 处理失败结果</span>
  results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">value</span>?.<span class="hljs-property">error</span>) { <span class="hljs-comment">// 捕获到的错误</span>
      <span class="hljs-keyword">const</span> { error, component } = result.<span class="hljs-property">value</span>;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`组件 <span class="hljs-subst">${component}</span> 失败：`</span>, error.<span class="hljs-property">message</span>);
      <span class="hljs-comment">// 单独标记失败组件，不影响其他</span>
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">`comp-<span class="hljs-subst">${component}</span>`</span>).<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'failed'</span>);
    }
  });
}
</code></pre>
<h3 data-id="heading-35">5. 第三方库调用场景</h3>
<p><strong>适用</strong>：调用外部库（如 <code>moment</code>、<code>lodash</code>）的同步方法（可能因参数错误抛错）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">'moment'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">formatWithLibrary</span>(<span class="hljs-params">dateInput</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 第三方库可能对无效参数抛错（如 moment(null) 格式化）</span>
    <span class="hljs-keyword">const</span> formatted = <span class="hljs-title function_">moment</span>(dateInput).<span class="hljs-title function_">format</span>(<span class="hljs-string">'YYYY-MM-DD HH:mm'</span>);
    <span class="hljs-comment">// 主动校验库返回的异常结果（如 moment 无效日期返回 'Invalid date'）</span>
    <span class="hljs-keyword">if</span> (formatted === <span class="hljs-string">'Invalid date'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`无效日期：<span class="hljs-subst">${dateInput}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> formatted;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'格式化失败：'</span>, error.<span class="hljs-property">message</span>);
    <span class="hljs-comment">// 降级为原生方法</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(dateInput).<span class="hljs-title function_">toLocaleString</span>() || <span class="hljs-string">'无法解析的日期'</span>;
  }
}
</code></pre>
<h3 data-id="heading-36">6. 框架场景（以 React 为例）</h3>
<p><strong>适用</strong>：组件逻辑错误（<code>try...catch</code>）与渲染错误（错误边界）分工：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 组件内逻辑错误用 try...catch</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ userId }</span>) {
  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadUser</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/user/<span class="hljs-subst">${userId}</span>`</span>);
        <span class="hljs-title function_">setUser</span>(res.<span class="hljs-property">data</span>);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'加载用户失败：'</span>, error);
        <span class="hljs-title function_">setUser</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">'用户信息加载失败'</span> }); <span class="hljs-comment">// 状态降级</span>
      }
    }
    <span class="hljs-title function_">loadUser</span>();
  }, [userId]);

  <span class="hljs-comment">// 2. 渲染错误交给错误边界处理（不直接用 try...catch 包裹 JSX）</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {user?.error ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{user.error}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 错误边界组件（处理渲染错误）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> { <span class="hljs-comment">/* ... */</span> }

<span class="hljs-comment">// 使用：错误边界包裹可能渲染失败的组件</span>
&lt;<span class="hljs-title class_">ErrorBoundary</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">{123}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">ErrorBoundary</span>&gt;
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[openGauss实战：Python开发与AI向量数据库应用]]></title>    <link>https://juejin.cn/post/7572714389943271476</link>    <guid>https://juejin.cn/post/7572714389943271476</guid>    <pubDate>2025-11-16T11:15:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572714389943271476" data-draft-id="7572534419880525859" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="openGauss实战：Python开发与AI向量数据库应用"/> <meta itemprop="keywords" content="数据库"/> <meta itemprop="datePublished" content="2025-11-16T11:15:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="倔强的石头_"/> <meta itemprop="url" content="https://juejin.cn/user/3168119757484368"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            openGauss实战：Python开发与AI向量数据库应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3168119757484368/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    倔强的石头_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T11:15:34.000Z" title="Sun Nov 16 2025 11:15:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>经过前两篇文章的铺垫，我们已经掌握了openGauss的部署安装和使用Data Studio进行可视化管理。现在，我们来到了本系列文章的终章，将目光聚焦于开发者最关心的环节——如何在应用程序中与openGauss进行交互，并探索其在AI领域的应用潜力。</p>
<p>本文将以目前最流行的编程语言之一Python为例，详细演示如何连接openGauss数据库，并围绕两个典型的业务场景——“用户管理系统”和“订单支付流程”，构建完整的CRUD（创建、读取、更新、删除）与事务处理代码示例。更进一步，我们将结合业界热点，探讨如何利用openGauss的向量计算能力，构建一个简单的以文搜图RAG（检索增强生成）应用，充分展现openGauss作为一款AI原生数据库的魅力。
@[toc]
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ecc742f65bf4188bba3c4639c39463e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=tVp0Zw4ALYTw94xR53Kq9KLvdLM%3D" alt="image.png" loading="lazy"/></p>
<p>本文的后端环境为“CentOS 7.9 + openGauss 极简版（simpleInstall，6.x）”，数据库运行在云服务器上，应用在本地开发机（Windows/macOS/Linux）运行并远程连接到数据库。若远程连接失败，请参考第二篇中关于<code>listen_addresses</code>与<code>pg_hba.conf</code>的配置说明。</p>
<h2 data-id="heading-1">Python连接openGauss：psycopg2驱动</h2>
<p>openGauss兼容PostgreSQL生态，因此，我们可以使用PostgreSQL最成熟的Python驱动<code>psycopg2</code>来连接和操作openGauss数据库。</p>
<h3 data-id="heading-2">1. 安装psycopg2</h3>
<p>首先，安装Python驱动。请根据环境选择以下命令：</p>
<ul>
<li>Python 3.8 及以上（推荐）：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">python3 -m pip install --user psycopg2-binary
</code></pre>
<ul>
<li>CentOS 7 + Python 3.6（需固定版本并使用国内镜像）：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">python3 -m pip install --upgrade <span class="hljs-string">"pip==21.3.1"</span> --user -i https://pypi.tuna.tsinghua.edu.cn/simple
python3 -m pip install --user -i https://mirrors.aliyun.com/pypi/simple <span class="hljs-string">"psycopg2-binary==2.8.6"</span>
<span class="hljs-comment"># 如网络较慢，可追加 --default-timeout=120</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31f000e4a5d84062a91348784cce2b50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=Cxbor0a7bzzELL%2BEAvA58M9X0p8%3D" alt="e1821a45e4b7bcadd15800e7f81934cf.png" loading="lazy"/></p>
<p>提示：尽量使用 <code>python3 -m pip</code>（或 <code>pip3</code>），并在非虚拟环境下加 <code>--user</code> 以避免权限冲突；若需源码编译，可改为安装 <code>psycopg2==2.8.6</code>，并提前安装构建依赖（如 <code>gcc</code>、<code>python3-devel</code>、<code>postgresql-libs</code>/<code>postgresql-devel</code>）。</p>
<p>常见安装问题排障：</p>
<ul>
<li>下载超时：加入 <code>--default-timeout=120</code> 或切换镜像源（如清华、阿里）。</li>
<li>证书/代理：在公司网络需配置 HTTPS 代理或临时关闭 MITM 检查；也可离线下载 <code>.whl</code> 后本地安装。</li>
<li>权限警告：在 root 环境下建议使用 <code>--user</code> 或创建虚拟环境。</li>
<li>Windows 与多版本 Python 映射：在 PowerShell 执行 <code>python -V</code>、<code>pip -V</code>、<code>py -0p</code>，确保 <code>pip</code> 与 <code>python</code> 指向同一解释器；优先使用 <code>python -m pip install --user psycopg2-binary</code>。</li>
<li>路径检查：<code>where python</code>、<code>where pip</code> 查看可执行路径；必要时使用目标解释器绝对路径，例如 <code>C:\Python39\python.exe -m pip install psycopg2-binary</code>。</li>
<li>快速验证安装：<code>python -c "import psycopg2, sys; print(psycopg2.__version__, sys.executable)"</code>，确认驱动版本与解释器路径匹配。</li>
<li>源码编译提示：若报缺少 <code>pg_config</code> 或开发头文件，优先使用 <code>psycopg2-binary</code>；或先安装 <code>postgresql-libs</code>/<code>postgresql-devel</code> 与 <code>python3-devel</code> 后再编译 <code>psycopg2</code>。</li>
</ul>
<h3 data-id="heading-3">2. 建立数据库连接</h3>
<p>连接openGauss数据库非常简单，只需提供主机、端口、用户名、密码和数据库名即可。下面的示例与入门篇默认参数保持一致（请替换为实际的服务器IP与密码）</p>
<p>实操步骤（本地开发机）：</p>
<ul>
<li>在本地任意工作目录创建项目并新建连接测试脚本：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Windows PowerShell</span>
<span class="hljs-built_in">mkdir</span> opengauss_demo
<span class="hljs-built_in">cd</span> opengauss_demo
<span class="hljs-comment"># Linux/macOS 可用：</span>
<span class="hljs-comment"># mkdir -p opengauss_demo</span>
<span class="hljs-comment"># 如尚未安装驱动，请先执行：</span>
python3 -m pip install --user psycopg2-binary
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a73c91a6b2046efa57f07c0755e335a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=loLG9NMvfbamgfIyenUsRAfTRpg%3D" alt="image.png" loading="lazy"/></p>
<p>在该目录中新建文件 <code>db_connect_test.py</code>，内容如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># db_connect_test.py</span>
<span class="hljs-keyword">import</span> psycopg2

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db_connection</span>():
    <span class="hljs-keyword">try</span>:
        conn = psycopg2.connect(
            host=<span class="hljs-string">"YOUR_SERVER_IP"</span>,   <span class="hljs-comment"># 替换为云服务器公网IP</span>
            port=<span class="hljs-number">5432</span>,
            user=<span class="hljs-string">"omm"</span>,
            password=<span class="hljs-string">"Gauss@123456"</span>, <span class="hljs-comment"># 替换为实际密码</span>
            database=<span class="hljs-string">"postgres"</span>,
            connect_timeout=<span class="hljs-number">5</span>
        )
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"数据库连接成功！"</span>)
        <span class="hljs-keyword">return</span> conn
    <span class="hljs-keyword">except</span> psycopg2.OperationalError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据库连接失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> conn:
        conn.close()
</code></pre>
<p>运行与验证（Windows/ macOS/ Linux）：</p>
<pre><code class="hljs language-bash" lang="bash">python3 db_connect_test.py
<span class="hljs-comment"># 若 Windows 上没有 python3 命令，可用：</span>
<span class="hljs-comment"># python db_connect_test.py</span>
</code></pre>
<p>预期输出：出现“数据库连接成功！”并退出；如报错，按下方“远程连接失败排查要点”逐项检查。</p>
<p>若出现连接超时或认证失败，请回到第二篇确认：</p>
<ul>
<li><code>postgresql.conf</code>的<code>listen_addresses</code>是否为<code>'*'</code>或对应IP；</li>
<li><code>pg_hba.conf</code>是否添加了允许远程访问的<code>host</code>条目（<code>md5</code>认证）；</li>
<li>云安全组是否开放<code>TCP 5432</code>入站规则到您的本地IP范围。</li>
</ul>
<p>连接失败快速排查：</p>
<ul>
<li>替换占位符：确认已将 <code>YOUR_SERVER_IP</code> 与 <code>Gauss@123456</code> 替换为真实值；若脚本报 <code>NoneType</code> 错误，通常是连接失败导致返回 <code>None</code>。</li>
<li>端口连通性：Windows 执行 <code>Test-NetConnection YOUR_SERVER_IP -Port 5432</code>；Linux/macOS 执行 <code>telnet YOUR_SERVER_IP 5432</code> 或 <code>nc -vz YOUR_SERVER_IP 5432</code>。</li>
<li>认证规则：在数据库侧 <code>pg_hba.conf</code> 添加合适的 <code>host</code> 条目（如 <code>md5</code>），修改后 <code>gs_ctl reload</code> 或重启实例。</li>
<li>初始用户远程连接说明：不建议用初始用户（如 <code>omm</code>）作为应用远程账号；推荐新建业务用户（如 <code>xsc</code>）并授予表/序列权限，见下文“用户管理”授权方案。</li>
<li>数据库/Schema：确认连接的 <code>database="postgres"</code> 与 <code>search_path</code> 包含 <code>public</code>；使用限定名 <code>public.t_user</code> 可避免路径问题。</li>
</ul>
<h2 data-id="heading-4">场景一：用户管理系统的CRUD实战</h2>
<p>用户管理是几乎所有应用的标配。下面，我们将实现一个简单的用户管理模块，包含增、删、改、查功能。</p>
<h3 data-id="heading-5">1. 创建用户表</h3>
<p>首先，在数据库中创建<code>t_user</code>表。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_user (
    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,
    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">WITH</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
);
</code></pre>
<p>实操步骤（数据库侧）：</p>
<ul>
<li>使用 <code>gsql</code> 远程连接到 openGauss：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">gsql -d postgres -h YOUR_SERVER_IP -p 5432 -U omm -W
</code></pre>
<ul>
<li>执行上述 <code>CREATE TABLE</code> 语句创建表。</li>
<li>验证：</li>
</ul>
<pre><code class="hljs language-sql" lang="sql">\dt
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user;
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/333ff30978cd4d66a3fdcc7ab7569942~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=fUIaxUTfyMWvpt9F%2FFh%2FTDrNf1g%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-6">2. Python代码实现</h3>
<p>在本地开发机创建目录（例如 <code>opengauss_demo</code>），新增文件 <code>user_crud.py</code>，内容如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># user_crud.py</span>

<span class="hljs-keyword">import</span> psycopg2
<span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> closing


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db_connection</span>():
    <span class="hljs-keyword">try</span>:
        conn = psycopg2.connect(
            host=<span class="hljs-string">"YOUR_SERVER_IP"</span>,
            port=<span class="hljs-number">5432</span>,
            user=<span class="hljs-string">"omm"</span>,
            password=<span class="hljs-string">"Gauss@123456"</span>,
            database=<span class="hljs-string">"postgres"</span>,
            connect_timeout=<span class="hljs-number">5</span>,
        )
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"数据库连接成功！"</span>)
        <span class="hljs-keyword">return</span> conn
    <span class="hljs-keyword">except</span> psycopg2.OperationalError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据库连接失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">username, email</span>):
    <span class="hljs-keyword">with</span> closing(get_db_connection()) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"INSERT INTO t_user (username, email) VALUES (%s, %s)"</span>,
                (username, email),
            )
            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"用户 '<span class="hljs-subst">{username}</span>' 创建成功。"</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_username</span>(<span class="hljs-params">username</span>):
    <span class="hljs-keyword">with</span> closing(get_db_connection()) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"SELECT id, username, email FROM t_user WHERE username = %s"</span>,
                (username,),
            )
            <span class="hljs-keyword">return</span> cursor.fetchone()


<span class="hljs-keyword">def</span> <span class="hljs-title function_">update_user_email</span>(<span class="hljs-params">username, new_email</span>):
    <span class="hljs-keyword">with</span> closing(get_db_connection()) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"UPDATE t_user SET email = %s WHERE username = %s"</span>,
                (new_email, username),
            )
            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"用户 '<span class="hljs-subst">{username}</span>' 的邮箱更新成功。"</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(<span class="hljs-params">username</span>):
    <span class="hljs-keyword">with</span> closing(get_db_connection()) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"DELETE FROM t_user WHERE username = %s"</span>,
                (username,),
            )
            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"用户 '<span class="hljs-subst">{username}</span>' 删除成功。"</span>)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    create_user(<span class="hljs-string">"john_doe"</span>, <span class="hljs-string">"john.doe@example.com"</span>)
    user = get_user_by_username(<span class="hljs-string">"john_doe"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"查询到用户: <span class="hljs-subst">{user}</span>"</span>)
    update_user_email(<span class="hljs-string">"john_doe"</span>, <span class="hljs-string">"john.doe.new@example.com"</span>)
    user = get_user_by_username(<span class="hljs-string">"john_doe"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"更新后用户: <span class="hljs-subst">{user}</span>"</span>)
    delete_user(<span class="hljs-string">"john_doe"</span>)
</code></pre>
<p>运行与验证（本地开发机）：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> opengauss_demo
python3 user_crud.py
</code></pre>
<p>预期输出：依次打印“数据库连接成功”、“创建成功”、“查询到用户”、“更新后用户”、“删除成功”。
如需数据库侧二次确认：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">'john_doe'</span>;
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7233e7af11948aab7c769fb30c3055a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=XwAJe6arZphy41IKFnd5LNjUOCE%3D" alt="image.png" loading="lazy"/></p>
<p>常见报错与解决（用户管理）：</p>
<p>我用应用账号 xsc 远程连库，但表 t_user 是初始用户 omm 创建和拥有；默认权限下， xsc 没有对该表的操作权限，因此出现 “permission denied for relation t_user”。另外 openGauss 不建议用初始用户做远程应用连接，这是安全最佳实践。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c525931642614098abb3198fab856355~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=KRp%2FQsUywXFXOOt%2B%2BO1es73%2Fx%2Bw%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p>报错 <code>psycopg2.errors.InsufficientPrivilege: permission denied for relation t_user</code>：业务用户（如 <code>xsc</code>）缺少权限。请在服务器上以所有者/管理员（通常为 <code>omm</code>）执行：</p>
<ul>
<li><code>GRANT USAGE ON SCHEMA public TO xsc;</code></li>
<li><code>GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.t_user TO xsc;</code></li>
<li><code>GRANT USAGE, SELECT ON SEQUENCE public.t_user_id_seq TO xsc;</code>
序列授权是因为 <code>SERIAL</code> 会创建隐式序列，插入时需读写序列。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d9d87773a7a46438c9d9bb8592dc554~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=XC2mEn4Zyoz7gtTm6mjmvIb1tn8%3D" alt="image.png" loading="lazy"/></li>
</ul>
</li>
<li>
<p>可选（需谨慎）：将所有者变更为业务用户以简化权限管理：</p>
<ul>
<li><code>ALTER TABLE public.t_user OWNER TO xsc;</code></li>
<li><code>ALTER SEQUENCE public.t_user_id_seq OWNER TO xsc;</code></li>
</ul>
</li>
<li>
<p>代码健壮性建议：在每个操作前判断连接是否成功，并使用表的限定名：</p>
</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">username, email</span>):
    conn = get_db_connection()  <span class="hljs-comment"># 可将 user 改为业务账号，如 xsc</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"连接失败，已跳过 insert"</span>)
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cur:
            cur.execute(
                <span class="hljs-string">"INSERT INTO public.t_user (username, email) VALUES (%s, %s)"</span>,
                (username, email),
            )
        conn.commit()
    <span class="hljs-keyword">finally</span>:
        conn.close()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_username</span>(<span class="hljs-params">username</span>):
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cur:
            cur.execute(
                <span class="hljs-string">"SELECT id, username, email FROM public.t_user WHERE username = %s"</span>,
                (username,),
            )
            <span class="hljs-keyword">return</span> cur.fetchone()
    <span class="hljs-keyword">finally</span>:
        conn.close()
</code></pre>
<ul>
<li>授权快速验证：
<ul>
<li><code>gsql -d postgres -h YOUR_SERVER_IP -p 5432 -U xsc -W</code></li>
<li>依次执行：<code>INSERT/SELECT/UPDATE/DELETE</code> 到 <code>public.t_user</code>，确认无权限报错。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-7">场景二：订单支付流程的事务处理</h2>
<p>在电商等金融敏感场景中，数据一致性至关重要。我们将模拟一个“用户下单扣减库存”的场景，来演示如何使用事务保证操作的原子性。</p>
<h3 data-id="heading-8">1. 创建商品表和订单表</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_product (
    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,
    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    stock <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>
);

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_order (
    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,
    product_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    quantity <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">WITH</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
);

<span class="hljs-comment">-- 插入一个商品</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_product (name, stock) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'openGauss T-shirt'</span>, <span class="hljs-number">100</span>);
</code></pre>
<p>实操步骤（数据库侧）：</p>
<ul>
<li>连接数据库（同上）：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">gsql -d postgres -h YOUR_SERVER_IP -p 5432 -U omm -W
</code></pre>
<ul>
<li>依次执行创建两张表与初始化数据的 SQL；可用下列查询验证：</li>
</ul>
<pre><code class="hljs language-sql" lang="sql">\dt
<span class="hljs-keyword">SELECT</span> id, name, stock <span class="hljs-keyword">FROM</span> t_product;  <span class="hljs-comment">-- 应看到一条库存为100的商品</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> t_order;           <span class="hljs-comment">-- 初始为0</span>
</code></pre>
<h3 data-id="heading-9">2. Python代码实现</h3>
<p>在本地开发机创建文件 <code>transaction_example.py</code>，内容如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># transaction_example.py</span>

<span class="hljs-keyword">import</span> psycopg2


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db_connection</span>():
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> psycopg2.connect(
            host=<span class="hljs-string">"YOUR_SERVER_IP"</span>,
            port=<span class="hljs-number">5432</span>,
            user=<span class="hljs-string">"omm"</span>,
            password=<span class="hljs-string">"Gauss@123456"</span>,
            database=<span class="hljs-string">"postgres"</span>,
            connect_timeout=<span class="hljs-number">5</span>,
        )
    <span class="hljs-keyword">except</span> psycopg2.OperationalError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据库连接失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">place_order</span>(<span class="hljs-params">product_id, quantity</span>):
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            <span class="hljs-comment"># 1. 检查库存并加行锁，避免并发下读到旧库存</span>
            cursor.execute(
                <span class="hljs-string">"SELECT stock FROM t_product WHERE id = %s FOR UPDATE"</span>,
                (product_id,),
            )
            row = cursor.fetchone()
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> row:
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"商品不存在！"</span>)
            stock = row[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> stock &lt; quantity:
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"库存不足！"</span>)

            <span class="hljs-comment"># 2. 扣减库存</span>
            cursor.execute(
                <span class="hljs-string">"UPDATE t_product SET stock = stock - %s WHERE id = %s"</span>,
                (quantity, product_id),
            )

            <span class="hljs-comment"># 3. 创建订单</span>
            cursor.execute(
                <span class="hljs-string">"INSERT INTO t_order (product_id, quantity) VALUES (%s, %s)"</span>,
                (product_id, quantity),
            )

            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"下单成功！"</span>)

    <span class="hljs-keyword">except</span> (Exception, psycopg2.Error) <span class="hljs-keyword">as</span> error:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"下单失败: <span class="hljs-subst">{error}</span>"</span>)
        conn.rollback()
    <span class="hljs-keyword">finally</span>:
        conn.close()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    place_order(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)   <span class="hljs-comment"># 成功下单，库存从100减到95</span>
    place_order(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>) <span class="hljs-comment"># 超卖示例，将抛出“库存不足！”并回滚</span>
</code></pre>
<p>运行与验证：</p>
<pre><code class="hljs language-bash" lang="bash">python3 transaction_example.py
</code></pre>
<p>可在数据库侧验证：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> id, stock <span class="hljs-keyword">FROM</span> t_product <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;   <span class="hljs-comment">-- 应为95</span>
<span class="hljs-keyword">SELECT</span> id, product_id, quantity <span class="hljs-keyword">FROM</span> t_order; <span class="hljs-comment">-- 应新增一条 quantity=5 的订单</span>
</code></pre>
<p>说明：<code>FOR UPDATE</code> 会在查询到的行上加排他锁，确保并发事务不会在你提交前修改该行，避免超卖；一旦发生异常，代码会执行 <code>rollback()</code> 保证库存与订单的一致性。</p>
<p>这段代码确保了“扣减库存”和“创建订单”这两个操作要么同时成功，要么同时失败，避免了数据不一致的问题。</p>
<p>常见报错与处理（事务）：</p>
<ul>
<li>权限问题：业务用户对 <code>t_product</code> 需至少 <code>SELECT, UPDATE</code>，对 <code>t_order</code> 需 <code>INSERT, SELECT</code>，并为隐式序列授予 <code>USAGE, SELECT</code>（例如 <code>t_product_id_seq</code>、<code>t_order_id_seq</code>）。</li>
<li>并发冲突：若遇到 <code>could not serialize access due to concurrent update</code>，说明并发更新冲突；保留 <code>FOR UPDATE</code>，在应用侧捕获并重试，或确认隔离级别为 <code>READ COMMITTED</code>。</li>
<li>异常处理：任何异常均应 <code>rollback()</code> 保证一致性，提交成功后再打印“下单成功”。</li>
</ul>
<h2 data-id="heading-10">场景三：AI赋能 - 基于向量的以文搜图（RAG）</h2>
<p>现在，让我们进入最激动人心的部分。openGauss 5.0版本后引入了对向量数据类型和向量计算的内置支持，使其成为构建AI应用的理想选择。我们将构建一个简单的RAG应用，通过文本描述来搜索相似的图片。</p>
<h3 data-id="heading-11">1. 开启向量插件并创建表</h3>
<p>首先，需要在数据库中开启<code>vectors</code>插件</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> EXTENSION vectors;
</code></pre>
<p>说明：部分发行版或构建中扩展名可能为 <code>vector</code>（pgvector），若上面的命令报未找到扩展，可尝试：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> EXTENSION vector;
</code></pre>
<p>然后，创建一个用于存储图片向量的表。本文使用<code>clip-ViT-B-32</code>模型，其默认输出维度为<code>512</code>，因此示例使用<code>VECTOR(512)</code>：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_image_vectors (
    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,
    image_path <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    image_vector VECTOR(<span class="hljs-number">512</span>)
);
</code></pre>
<p>验证与注意：</p>
<ul>
<li>使用 <code>\dx</code> 查看已启用的扩展；若显示 <code>vectors</code>/<code>vector</code> 即成功。</li>
<li><code>\d t_image_vectors</code> 可查看表结构；向量字段类型为 <code>vector(512)</code>。</li>
</ul>
<h3 data-id="heading-12">2. Python代码实现</h3>
<p>这个场景需要借助一个能够将文本和图片转换为向量的模型。这里我们使用<code>sentence-transformers</code>库作为示例。</p>
<pre><code class="hljs language-bash" lang="bash">python3 -m pip install --user -i https://mirrors.aliyun.com/pypi/simple sentence-transformers Pillow
</code></pre>
<p>前置说明：该步骤建议在本地开发机的 Python 3.8+ 环境执行（<code>sentence-transformers</code> 对 Py3.6 支持不佳）。首次运行会从 HuggingFace 下载模型，需联网。</p>
<p>在本地准备工程与图片：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> -p opengauss_demo/assets/images
<span class="hljs-comment"># 将两张示例图片保存为：opengauss_demo/assets/images/cat.jpg、dog.jpg</span>
</code></pre>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># rag_example.py</span>

<span class="hljs-keyword">import</span> psycopg2
<span class="hljs-keyword">from</span> sentence_transformers <span class="hljs-keyword">import</span> SentenceTransformer
<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db_connection</span>():
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> psycopg2.connect(
            host=<span class="hljs-string">"YOUR_SERVER_IP"</span>,
            port=<span class="hljs-number">5432</span>,
            user=<span class="hljs-string">"omm"</span>,
            password=<span class="hljs-string">"Gauss@123456"</span>,
            database=<span class="hljs-string">"postgres"</span>,
            connect_timeout=<span class="hljs-number">5</span>,
        )
    <span class="hljs-keyword">except</span> psycopg2.OperationalError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据库连接失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>


model = SentenceTransformer(<span class="hljs-string">"clip-ViT-B-32"</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_image_vector</span>(<span class="hljs-params">image_path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">try</span>:
        img_embedding = model.encode(Image.<span class="hljs-built_in">open</span>(image_path))  <span class="hljs-comment"># 512维</span>
        vector_str = <span class="hljs-string">"["</span> + <span class="hljs-string">","</span>.join(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">float</span>(x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> img_embedding.tolist()) + <span class="hljs-string">"]"</span>

        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"INSERT INTO t_image_vectors (image_path, image_vector) VALUES (%s, %s::vector)"</span>,
                (image_path, vector_str),
            )
            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"已入库向量：<span class="hljs-subst">{image_path}</span>"</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"处理图片失败: <span class="hljs-subst">{e}</span>"</span>)
        conn.rollback()
    <span class="hljs-keyword">finally</span>:
        conn.close()


<span class="hljs-keyword">def</span> <span class="hljs-title function_">search_images_by_text</span>(<span class="hljs-params">text_query: <span class="hljs-built_in">str</span>, top_k: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span></span>):
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-keyword">return</span> []

    <span class="hljs-keyword">try</span>:
        query_embedding = model.encode(text_query)
        vector_str = <span class="hljs-string">"["</span> + <span class="hljs-string">","</span>.join(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">float</span>(x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> query_embedding.tolist()) + <span class="hljs-string">"]"</span>

        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"SELECT image_path, image_vector &lt;-&gt; %s::vector AS dist FROM t_image_vectors ORDER BY dist LIMIT %s"</span>,
                (vector_str, top_k),
            )
            <span class="hljs-keyword">return</span> cursor.fetchall()
    <span class="hljs-keyword">finally</span>:
        conn.close()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># 将两张图片向量化并入库</span>
    insert_image_vector(<span class="hljs-string">"assets/images/cat.jpg"</span>)
    insert_image_vector(<span class="hljs-string">"assets/images/dog.jpg"</span>)

    <span class="hljs-comment"># 文本检索</span>
    query = <span class="hljs-string">"A photo of a cute animal sitting on the grass"</span>
    results = search_images_by_text(query, top_k=<span class="hljs-number">3</span>)

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n查询：<span class="hljs-subst">{query}</span>"</span>)
    <span class="hljs-keyword">for</span> path, dist <span class="hljs-keyword">in</span> results:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"- 图片: <span class="hljs-subst">{path}</span>，L2距离: <span class="hljs-subst">{dist:<span class="hljs-number">.4</span>f}</span>"</span>)
</code></pre>
<p>运行与验证：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> opengauss_demo
python3 rag_example.py
</code></pre>
<p>预期输出：打印两条“已入库向量：…”后，返回按距离排序的图片列表。距离越小表示越相似。</p>
<p>补充说明：</p>
<ul>
<li><code>&lt;-&gt;</code> 是向量相似度的距离操作符（L2距离）。若发行版提供 <code>l2_distance(v1,v2)</code>，也可替换为该函数。</li>
<li>如需加速检索，可建立向量索引（例如 <code>ivfflat</code>/<code>hnsw</code>），不同版本支持情况不一，配置前请确认。</li>
</ul>
<p>这个例子展示了openGauss如何无缝集成到AI工作流中。通过在数据库层面进行向量检索，可以简化RAG应用的架构，降低开发复杂度，并利用数据库的事务性和可靠性来管理AI数据。</p>
<p>小贴士：</p>
<ul>
<li>若您的版本提供<code>l2_distance(v1, v2)</code>函数，也可将示例中的<code>image_vector &lt;-&gt; %s::vector</code>替换为<code>l2_distance(image_vector, %s::vector)</code>；</li>
<li>向量索引（如<code>ivfflat</code>或<code>hnsw</code>）可显著提升检索性能，但不同版本支持情况可能不同，建议在功能确认后再配置索引。</li>
</ul>
<p>常见问题与解决（RAG 向量检索）：</p>
<ul>
<li>扩展不存在：<code>ERROR: extension "vectors" does not exist</code> 或 <code>type "vector" does not exist</code> → 执行 <code>CREATE EXTENSION vectors;</code>，若无则尝试 <code>CREATE EXTENSION vector;</code>，并用 <code>\dx</code> 检查扩展已启用。</li>
<li>操作符缺失：<code>operator does not exist: vector &lt;-&gt; vector</code> → 未启用向量扩展或版本不匹配；启用扩展或改用 <code>l2_distance(...)</code>。</li>
<li>向量文本格式错误：<code>invalid input syntax for type vector</code> → 确保是类似 <code>[0.1,0.2,...]</code> 的 JSON 风格列表，并在 SQL 中使用 <code>%s::vector</code> 显式类型转换。</li>
<li>模型下载失败：受公司网络限制可配置代理或离线下载模型；也可切换 pip 镜像安装依赖（示例已使用阿里镜像）。</li>
<li>Pillow 依赖：Linux 发行版可能需安装 <code>libjpeg</code>/<code>zlib</code> 等系统库；Windows/macOS 通常无需额外配置。</li>
</ul>
<p>常见错误速查表：</p>
<ul>
<li><code>ModuleNotFoundError: No module named psycopg2</code> → 用目标解释器执行 <code>python -m pip install --user psycopg2-binary</code>，并用 <code>python -c "import psycopg2"</code> 验证。</li>
<li>Windows <code>python3</code> 不识别 → 直接用 <code>python</code> 或 <code>py -3</code>，优先 <code>python -m pip</code>。</li>
<li><code>psycopg2.OperationalError: could not connect to server</code>/超时 → 检查 <code>listen_addresses</code>、<code>pg_hba.conf</code> 与安全组；本机用 <code>Test-NetConnection</code>/<code>telnet</code> 验证 5432 端口连通。</li>
<li><code>permission denied for relation/sequence ...</code> → 按上文为业务用户授予 <code>SCHEMA</code>、<code>TABLE</code> 与隐式序列权限。</li>
<li><code>relation "t_user" does not exist</code> → 确认已创建表、连接的数据库正确，或在 SQL 中使用 <code>public.t_user</code> 限定名。</li>
<li><code>extension "vectors" does not exist</code>/<code>type "vector" does not exist</code> → 安装并启用向量扩展，或使用兼容扩展名 <code>vector</code>。</li>
</ul>
<h2 data-id="heading-13">总结</h2>
<p>从基础的CRUD操作到复杂的事务管理，再到前沿的AI向量应用，openGauss通过其强大的功能和对主流开发生态的良好兼容性，证明了其在现代应用开发中的核心价值。特别是其原生的向量数据库能力，为企业在AI时代构建智能应用提供了坚实、高效且易于管理的数据底座。</p>
<p>希望这个系列的文章能帮助您对openGauss有一个全面而深入的了解。数据库的世界广阔无垠，而openGauss的探索之旅，才刚刚开始。欢迎您继续深入研究，发掘它更多的可能性！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C++循环结构探微：深入理解while与do...while]]></title>    <link>https://juejin.cn/post/7572749797469519881</link>    <guid>https://juejin.cn/post/7572749797469519881</guid>    <pubDate>2025-11-16T14:45:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572749797469519881" data-draft-id="7572793505900298291" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C++循环结构探微：深入理解while与do...while"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-16T14:45:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C++循环结构探微：深入理解while与do...while
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T14:45:46.000Z" title="Sun Nov 16 2025 14:45:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    19
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在C++编程中，循环是控制流程的基石，用于重复执行一段代码，直到满足特定条件。<code>while</code>和<code>do...while</code>是两种最基本的迭代结构，它们看似相似，但在语义和行为上存在关键差异。理解这些差异对于编写正确、高效和易于维护的代码至关重要。</p>
<hr/>
<h3 data-id="heading-0"><strong>第一章：<code>while</code>循环 - “先验”的迭代者</strong></h3>
<p><code>while</code>循环是一种<strong>前置条件</strong>循环。它首先评估条件，只有当条件为真时，才会执行循环体。</p>
<h4 data-id="heading-1"><strong>1.1 语法与执行流程</strong></h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">while</span> (condition) {
    <span class="hljs-comment">// 循环体：要重复执行的语句</span>
}
</code></pre>
<p><strong>执行流程：</strong></p>
<ol>
<li><strong>评估条件</strong>：计算<code>condition</code>表达式。如果结果为<code>true</code>（非零），继续步骤2；如果为<code>false</code>（零），循环终止，程序继续执行循环之后的代码。</li>
<li><strong>执行循环体</strong>：执行花括号<code>{}</code>内的所有语句。</li>
<li><strong>循环</strong>：完成循环体后，跳回步骤1，重新评估条件。</li>
</ol>
<p>这个流程形成了一个经典的“检查-执行”循环。</p>
<h4 data-id="heading-2"><strong>1.2 哲学与适用场景</strong></h4>
<p><code>while</code>循环的哲学是：<strong>“看不到绿灯，绝不前进”</strong>。它适用于那些<strong>可能一次都不需要执行</strong>的场景。</p>
<p><strong>经典用例：</strong></p>
<ul>
<li><strong>读取未知长度的输入</strong>：在读取文件或用户输入时，通常无法预先知道循环次数。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">int</span> value;
<span class="hljs-keyword">while</span> (std::cin &gt;&gt; value) { <span class="hljs-comment">// 当输入流有效时继续读取</span>
    <span class="hljs-comment">// 处理value</span>
}
</code></pre>
</li>
<li><strong>事件等待循环</strong>：等待某个外部条件成立（如硬件就绪、信号触发）。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isDataReady</span>()) {
    <span class="hljs-comment">// 等待，或者进行一些其他工作</span>
}
</code></pre>
</li>
<li><strong>遍历链表等动态数据结构</strong>：
<pre><code class="hljs language-cpp" lang="cpp">Node* current = head;
<span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-comment">// 处理当前节点</span>
    current = current-&gt;next;
}
</code></pre>
</li>
</ul>
<h4 data-id="heading-3"><strong>1.3 潜在陷阱：无限循环</strong></h4>
<p>如果循环条件永远不为<code>false</code>，<code>while</code>循环将无限执行下去。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 警告：无限循环！</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    std::cout &lt;&lt; <span class="hljs-string">"This will print forever!\n"</span>;
}

<span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;
<span class="hljs-comment">// 如果循环体内不修改count，这也将是无限循环</span>
<span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; <span class="hljs-string">"Oops! Count is still "</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-comment">// 忘记写 count--;</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-4"><strong>第二章：<code>do...while</code>循环 - “后验”的保证者</strong></h3>
<p><code>do...while</code>循环是一种<strong>后置条件</strong>循环。它首先无条件地执行一次循环体，然后再评估条件。</p>
<h4 data-id="heading-5"><strong>2.1 语法与执行流程</strong></h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// 循环体：要重复执行的语句</span>
} <span class="hljs-keyword">while</span> (condition); <span class="hljs-comment">// 注意结尾的分号</span>
</code></pre>
<p><strong>执行流程：</strong></p>
<ol>
<li><strong>执行循环体</strong>：无条件地执行循环体内的语句。</li>
<li><strong>评估条件</strong>：计算<code>condition</code>表达式。如果结果为<code>true</code>，跳回步骤1；如果为<code>false</code>，循环终止。</li>
</ol>
<p>这个流程形成了一个“执行-检查”循环。</p>
<h4 data-id="heading-6"><strong>2.2 哲学与适用场景</strong></h4>
<p><code>do...while</code>循环的哲学是：<strong>“无论如何，先做一次再说”</strong>。它保证了<strong>循环体至少被执行一次</strong>。</p>
<p><strong>经典用例：</strong></p>
<ul>
<li><strong>菜单驱动程序</strong>：总是先向用户显示菜单，然后根据用户输入决定是否继续。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">int</span> choice;
<span class="hljs-keyword">do</span> {
    std::cout &lt;&lt; <span class="hljs-string">"1. Option A\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"2. Option B\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"3. Exit\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"Enter your choice: "</span>;
    std::cin &gt;&gt; choice;

    <span class="hljs-comment">// 处理choice...</span>
} <span class="hljs-keyword">while</span> (choice != <span class="hljs-number">3</span>); <span class="hljs-comment">// 如果用户不选择3，则再次显示菜单</span>
</code></pre>
</li>
<li><strong>输入验证</strong>：确保用户至少输入一次有效数据。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">int</span> number;
<span class="hljs-keyword">do</span> {
    std::cout &lt;&lt; <span class="hljs-string">"Please enter a positive number: "</span>;
    std::cin &gt;&gt; number;
} <span class="hljs-keyword">while</span> (number &lt;= <span class="hljs-number">0</span>); <span class="hljs-comment">// 如果输入无效，要求重新输入</span>
</code></pre>
</li>
</ul>
<hr/>
<h3 data-id="heading-7"><strong>第三章：核心差异与深度对比</strong></h3>






























<table><thead><tr><th align="left">特性</th><th align="left"><code>while</code> 循环</th><th align="left"><code>do...while</code> 循环</th></tr></thead><tbody><tr><td align="left"><strong>条件检查时机</strong></td><td align="left">循环<strong>开始前</strong></td><td align="left">循环<strong>结束后</strong></td></tr><tr><td align="left"><strong>最少执行次数</strong></td><td align="left"><strong>0次</strong></td><td align="left"><strong>1次</strong></td></tr><tr><td align="left"><strong>语法</strong></td><td align="left">不需要结尾分号</td><td align="left"><strong>必须</strong>有结尾分号</td></tr><tr><td align="left"><strong>适用性</strong></td><td align="left">条件可能初始为假的情况</td><td align="left">至少需执行一次，且依赖循环体结果的情况</td></tr></tbody></table>
<h4 data-id="heading-8"><strong>3.1 从代码到汇编：底层视角</strong></h4>
<p>在底层（汇编级别），编译器通常会将这两种循环转换为相似的条件跳转指令，但跳转的逻辑点不同。</p>
<ul>
<li><strong><code>while</code>循环的近似逻辑</strong>：
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">start:</span>
  <span class="hljs-keyword">if</span> (condition <span class="hljs-built_in">is</span> <span class="hljs-literal">false</span>) <span class="hljs-keyword">goto</span> <span class="hljs-keyword">end</span>;
  // 循环体代码
  <span class="hljs-keyword">goto</span> start;
<span class="hljs-symbol">end:</span>
</code></pre>
</li>
<li><strong><code>do...while</code>循环的近似逻辑</strong>：
<pre><code class="hljs language-csharp" lang="csharp">start:
  <span class="hljs-comment">// 循环体代码</span>
  <span class="hljs-keyword">if</span> (condition <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">goto</span> start;
</code></pre>
</li>
</ul>
<p>可以看到，<code>do...while</code>循环在结构上更紧凑，它少了一次初始的条件跳转。这在某些情况下可以带来微小的性能优势，因为减少了一次分支预测。</p>
<hr/>
<h3 data-id="heading-9"><strong>第四章：最佳实践与陷阱规避</strong></h3>
<h4 data-id="heading-10"><strong>4.1 选择循环的原则</strong></h4>
<ol>
<li><strong>首选<code>while</code></strong>：在大多数情况下，特别是当循环可能为零次时，<code>while</code>是更安全、更直观的选择。</li>
<li><strong>需要至少一次执行时，使用<code>do...while</code></strong>：当逻辑上要求代码块必须先运行一次时，<code>do...while</code>能准确表达你的意图，使代码更清晰。</li>
<li><strong>避免在<code>do...while</code>中声明变量</strong>：在<code>do</code>块中声明的变量在条件部分不可见，这可能导致错误。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">do</span> {
    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-comment">// ...</span>
} <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 错误！x的作用域仅限于do块内</span>
</code></pre>
正确的做法是在循环外声明变量。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">int</span> x;
<span class="hljs-keyword">do</span> {
    x = <span class="hljs-number">5</span>;
    <span class="hljs-comment">// ...</span>
} <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>);
</code></pre>
</li>
</ol>
<h4 data-id="heading-11"><strong>4.2 通用循环设计建议</strong></h4>
<ul>
<li><strong>确保循环终止</strong>：总是检查循环条件是否最终会变为<code>false</code>。</li>
<li><strong>警惕浮点数条件</strong>：由于精度问题，使用<code>float</code>或<code>double</code>作为循环条件可能导致意外结果。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">double</span> d = <span class="hljs-number">0.0</span>;
<span class="hljs-keyword">while</span> (d != <span class="hljs-number">1.0</span>) { <span class="hljs-comment">// 危险的比较！</span>
    d += <span class="hljs-number">0.1</span>;
    <span class="hljs-comment">// 由于浮点误差，d可能永远不会精确等于1.0</span>
}
</code></pre>
应使用范围比较：
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">while</span> (d &lt; <span class="hljs-number">1.0</span>) {
    d += <span class="hljs-number">0.1</span>;
}
</code></pre>
</li>
<li><strong>使用<code>{}</code>明确作用域</strong>：即使循环体只有一条语句，也使用花括号，这能增强可读性并避免悬垂else等问题。</li>
</ul>
<hr/>
<h3 data-id="heading-12"><strong>第五章：性能考量（现代编译器优化）</strong></h3>
<p>在现代C++编译器中，对于简单的循环，<code>while</code>和<code>do...while</code>的性能差异通常可以忽略不计。编译器强大的优化器（如尾调用优化、循环展开、代码移动等）会生成高度优化的机器码。</p>
<p>性能优化的关键通常不在于选择哪种循环，而在于：</p>
<ul>
<li><strong>减少循环内部的冗余计算</strong>。</li>
<li><strong>优化循环体内的算法和数据结构访问模式</strong>（如缓存友好性）。</li>
<li><strong>在适当的时候使用<code>++i</code>而非<code>i++</code></strong>（对于自定义类型）。</li>
</ul>
<p>因此，在绝大多数场景下，<strong>代码的正确性和可读性应优先于对循环类型进行的微观优化</strong>。</p>
<hr/>
<h3 data-id="heading-13"><strong>结论</strong></h3>
<p><code>while</code>和<code>do...while</code>是C++中相辅相成的两种循环工具。</p>
<ul>
<li><strong><code>while</code></strong> 是你谨慎的伙伴，它坚持“先检查，后行动”的原则，适用于那些需要前置验证的场景。</li>
<li><strong><code>do...while</code></strong> 是你果断的伙伴，它奉行“先行动，后反思”的策略，在保证至少一次执行的情况下非常有用。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue2 和 Vue3 中 watch 用法和原理详解]]></title>    <link>https://juejin.cn/post/7573225720697503796</link>    <guid>https://juejin.cn/post/7573225720697503796</guid>    <pubDate>2025-11-17T06:42:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720697503796" data-draft-id="7573225720697487412" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue2 和 Vue3 中 watch 用法和原理详解"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2025-11-17T06:42:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="木易士心"/> <meta itemprop="url" content="https://juejin.cn/user/588993963763751"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue2 和 Vue3 中 watch 用法和原理详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993963763751/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    木易士心
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:42:31.000Z" title="Mon Nov 17 2025 06:42:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>@<a href="https://link.juejin.cn?target=%25E7%259B%25AE%25E5%25BD%2595" target="_blank" title="%E7%9B%AE%E5%BD%95" ref="nofollow noopener noreferrer">TOC</a></p>
<h2 data-id="heading-0">1. Vue2 中的 watch</h2>
<h3 data-id="heading-1">1. 基本用法</h3>
<p>在 Vue2 中，watch 是一个对象，其键是要观察的表达式，值是对应的回调函数或包含选项的对象。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 对象写法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">user</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
      }
    }
  },
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-comment">// 监听基本数据类型</span>
    <span class="hljs-title function_">count</span>(<span class="hljs-params">newVal, oldVal</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
    },
    
    <span class="hljs-comment">// 深度监听对象</span>
    <span class="hljs-attr">user</span>: {
      <span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal, oldVal</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'user changed:'</span>, newVal)
      },
      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 深度监听</span>
      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 立即执行</span>
    },
    
    <span class="hljs-comment">// 监听对象特定属性</span>
    <span class="hljs-string">'user.name'</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal, oldVal</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`name changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
    }
  }
}
</code></pre>
<h3 data-id="heading-2">2. 程序式监听</h3>
<p>Vue2 也提供了 $watch API，可以在实例的任何地方监听数据变化。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 使用 $watch API</span>
    <span class="hljs-keyword">const</span> unwatch = <span class="hljs-variable language_">this</span>.$watch(
      <span class="hljs-string">'count'</span>,
      <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count changed: <span class="hljs-subst">${oldVal}</span> -&gt; <span class="hljs-subst">${newVal}</span>`</span>)
      },
      {
        <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">deep</span>: <span class="hljs-literal">false</span>
      }
    )
    
    <span class="hljs-comment">// 取消监听</span>
    <span class="hljs-comment">// unwatch()</span>
  }
}
</code></pre>
<h2 data-id="heading-3">2. Vue3 中的 watch</h2>
<h3 data-id="heading-4">1. 组合式 API 用法</h3>
<p>Vue3 的 watch 更加灵活，支持监听 ref、reactive 对象、getter 函数等多种数据源。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { ref, reactive, watch, watchEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">reactive</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>,
      <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
    })
    
    <span class="hljs-comment">// 监听 ref</span>
    <span class="hljs-title function_">watch</span>(count, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
    })
    
    <span class="hljs-comment">// 监听 reactive 对象</span>
    <span class="hljs-title function_">watch</span>(
      <span class="hljs-function">() =&gt;</span> user.<span class="hljs-property">name</span>, <span class="hljs-comment">// getter 函数</span>
      <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`name changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
      }
    )
    
    <span class="hljs-comment">// 深度监听对象</span>
    <span class="hljs-title function_">watch</span>(
      <span class="hljs-function">() =&gt;</span> user,
      <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'user changed:'</span>, newVal)
      },
      { <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> }
    )
    
    <span class="hljs-comment">// 监听多个源</span>
    <span class="hljs-title function_">watch</span>(
      [<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span>, <span class="hljs-function">() =&gt;</span> user.<span class="hljs-property">name</span>],
      <span class="hljs-function">(<span class="hljs-params">[newCount, newName], [oldCount, oldName]</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count: <span class="hljs-subst">${oldCount}</span>-&gt;<span class="hljs-subst">${newCount}</span>, name: <span class="hljs-subst">${oldName}</span>-&gt;<span class="hljs-subst">${newName}</span>`</span>)
      }
    )
    
    <span class="hljs-comment">// watchEffect - 自动追踪依赖</span>
    <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count is <span class="hljs-subst">${count.value}</span>, name is <span class="hljs-subst">${user.name}</span>`</span>)
    })
    
    <span class="hljs-keyword">return</span> {
      count,
      user
    }
  }
}
</code></pre>
<h3 data-id="heading-5">2. 选项式 API 用法</h3>
<p>Vue3 也支持在选项式 API 中使用 watch，与 Vue2 的用法类似。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { watch } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">user</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
      }
    }
  },
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-title function_">count</span>(<span class="hljs-params">newVal, oldVal</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
    }
  },
  <span class="hljs-title function_">created</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 使用 watch 函数</span>
    <span class="hljs-title function_">watch</span>(
      <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>,
      <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`name changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
      }
    )
  }
}
</code></pre>
<h2 data-id="heading-6">3.核心原理分析</h2>
<h3 data-id="heading-7">1. Vue2 的 Watch 原理</h3>
<p>Vue2 的 watch 基于响应式系统的依赖收集和派发更新机制。</p>
<ul>
<li>在组件实例初始化阶段，遍历 watch 对象的每一个属性，为每一个监听表达式创建一个 watcher 实例。</li>
<li>watcher 的创建过程：解析表达式，生成 getter 函数；执行 getter 函数，触发依赖收集；保存旧值，等待数据变化。</li>
<li>当被监听的数据发生变化时，触发 setter，通知对应的 watcher 更新；watcher 执行 getter 获取新值，比较新值和旧值，如果不同则执行回调函数。</li>
</ul>
<h3 data-id="heading-8">2. Vue3 的 Watch 原理</h3>
<p>Vue3 的 watch 基于 effect 机制实现。</p>
<ul>
<li>将回调函数包装成一个 effect，当被监听的数据发生变化时，effect 会重新执行。</li>
<li>通过 track 函数进行依赖收集，trigger 函数触发更新。</li>
<li>使用调度器 scheduler 控制 effect 的执行时机，实现异步更新和 flush 选项。</li>
</ul>
<h2 data-id="heading-9">4. 主要差异对比</h2>
<h3 data-id="heading-10">1. 差异总结</h3>
<ul>
<li>Vue2 的 watch 语法较为简单直观，适合选项式 API；Vue3 的 watch 更加灵活，适合组合式 API。</li>
<li>Vue3 的 watch 基于 effect 机制实现，提供了更好的性能和更丰富的配置选项。</li>
<li>两者都支持深度监听、立即执行、异步回调等特性，但在语法和使用方式上有所不同。</li>
</ul>
<h3 data-id="heading-11">2. 特性对比</h3>








































<table><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>API 形式</td><td>选项式</td><td>组合式 + 选项式</td></tr><tr><td>监听 reactive</td><td>不支持</td><td>原生支持</td></tr><tr><td>深度监听</td><td>需要显式配置</td><td>reactive 对象默认深度监听</td></tr><tr><td>多源监听</td><td>不支持</td><td>支持监听多个数据源</td></tr><tr><td>清理副作用</td><td>不支持</td><td>支持 cleanup 函数</td></tr><tr><td>性能</td><td>相对较低</td><td>基于 Proxy，性能更好</td></tr></tbody></table>
<h2 data-id="heading-12">5. 使用建议</h2>
<h3 data-id="heading-13">1. 性能优化</h3>
<p>避免不必要的深度监听，只监听需要的属性。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vue3 - 避免不必要的深度监听</span>
<span class="hljs-keyword">const</span> largeObject = <span class="hljs-title function_">reactive</span>({ <span class="hljs-comment">/* 大量数据 */</span> })

<span class="hljs-comment">// 不好的做法</span>
<span class="hljs-title function_">watch</span>(largeObject, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 任何属性变化都会触发</span>
})

<span class="hljs-comment">// 好的做法 - 只监听需要的属性</span>
<span class="hljs-title function_">watch</span>(
  <span class="hljs-function">() =&gt;</span> largeObject.<span class="hljs-property">importantProp</span>,
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 只有 importantProp 变化时触发</span>
  }
)
</code></pre>
<h3 data-id="heading-14">2. 清理副作用</h3>
<p>Vue3 支持在 watch 中清理副作用，避免内存泄漏。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vue3 - 清理副作用</span>
<span class="hljs-title function_">watch</span>(
  data,
  <span class="hljs-keyword">async</span> (newVal, oldVal, onCleanup) =&gt; {
    <span class="hljs-keyword">let</span> cancelled = <span class="hljs-literal">false</span>
    <span class="hljs-title function_">onCleanup</span>(<span class="hljs-function">() =&gt;</span> {
      cancelled = <span class="hljs-literal">true</span>
    })
    
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(newVal)
    <span class="hljs-keyword">if</span> (!cancelled) {
      <span class="hljs-comment">// 处理结果</span>
    }
  }
)
</code></pre>
<h3 data-id="heading-15">3. 防抖处理</h3>
<p>使用防抖函数避免频繁触发 watch 回调。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { debounce } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>

<span class="hljs-comment">// Vue3 防抖监听</span>
<span class="hljs-title function_">watch</span>(
  searchQuery,
  <span class="hljs-title function_">debounce</span>(<span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> {
    <span class="hljs-title function_">searchAPI</span>(newVal)
  }, <span class="hljs-number">300</span>)
)
</code></pre>
<h2 data-id="heading-16">6.常见问题解答</h2>
<h3 data-id="heading-17">1. Vue2 和 Vue3 的 watch 混用？</h3>
<p>在 Vue3 的选项式 API 中，可以继续使用 Vue2 风格的 watch 选项，但不建议混用。</p>
<h3 data-id="heading-18">2. 什么时候用 watch，什么时候用 computed？</h3>
<p>watch 用于执行副作用（如 API 调用、DOM 操作），computed 用于派生数据。</p>
<h3 data-id="heading-19">3. watchEffect 和 watch 的区别？</h3>
<p>watchEffect 自动追踪依赖，立即执行；watch 需要明确指定监听源，默认懒执行。</p>
<p>通过深入理解 Vue2 和 Vue3 中 watch 的用法和原理，可以更好地根据项目需求选择合适的监听方式，并编写出更高效、可维护的代码。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Webpack 5.x 开发模式启动流程详解]]></title>    <link>https://juejin.cn/post/7573300346262388790</link>    <guid>https://juejin.cn/post/7573300346262388790</guid>    <pubDate>2025-11-17T06:49:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573300346262388790" data-draft-id="7573180788579024937" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Webpack 5.x 开发模式启动流程详解"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-17T06:49:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="拿不拿铁19"/> <meta itemprop="url" content="https://juejin.cn/user/3417747845299064"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Webpack 5.x 开发模式启动流程详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3417747845299064/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    拿不拿铁19
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:49:02.000Z" title="Mon Nov 17 2025 06:49:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读25分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">Webpack 5.x 开发模式启动流程详解</h2>
<p>本文介绍 Webpack 5.x 版本在 <code>development</code>（开发模式）下的完整启动流程，重点区分<strong>首次启动</strong>和<strong>代码更新（热更新）</strong> 两个核心场景。</p>
<h2 data-id="heading-1">前置知识：开发模式下的核心特征</h2>
<p>在配置文件中通过 <code>mode: 'development'</code> 启用开发模式后，Webpack 会默认开启以下核心特性，这些特性直接影响启动流程：</p>
<ul>
<li><strong>源码映射（Source Map）</strong> ：默认生成 <code>eval-cheap-module-source-map</code>，便于开发时调试源码（而非编译后的代码）。</li>
<li><strong>不压缩代码</strong>：跳过代码混淆、压缩等优化步骤，提升构建速度。</li>
<li><strong>热模块替换（HMR）支持</strong>：配合 <code>webpack-dev-server</code> 实现代码更新后局部刷新，无需全页重载。</li>
<li><strong>缓存机制</strong>：默认缓存模块解析结果和编译结果，加速二次构建。</li>
</ul>
<p>本文基于以下基础配置展开，后续步骤均围绕此配置示例：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>, <span class="hljs-comment">// 明确指定开发模式</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>, <span class="hljs-comment">// 入口文件</span>
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>, <span class="hljs-comment">// 输出文件名</span>
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>), <span class="hljs-comment">// 输出目录</span>
    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 每次构建前清空dist目录</span>
  },
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'eval-cheap-module-source-map'</span>, <span class="hljs-comment">// 开发模式推荐Source Map</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">static</span>: <span class="hljs-string">'./dist'</span>, <span class="hljs-comment">// 开发服务器静态资源目录</span>
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启热模块替换</span>
    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启动后自动打开浏览器</span>
    <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> <span class="hljs-comment">// 开发服务器端口</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.js$/</span>, <span class="hljs-comment">// 匹配JS文件</span>
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 排除第三方依赖</span>
        <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span> <span class="hljs-comment">// 使用Babel转译</span>
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>, <span class="hljs-comment">// 匹配CSS文件</span>
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>] <span class="hljs-comment">// 处理CSS（开发模式不提取CSS）</span>
      }
    ]
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({ <span class="hljs-comment">// 自动生成HTML文件</span>
      <span class="hljs-attr">template</span>: <span class="hljs-string">'./src/index.html'</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'index.html'</span>
    }),
    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>() <span class="hljs-comment">// 热更新核心插件</span>
  ]
};
</code></pre>
<h2 data-id="heading-2">场景一：首次启动流程</h2>
<p>首次启动是指 Webpack 从读取配置到启动开发服务器并生成初始构建结果的完整过程，可细分为 8 个核心步骤，流程链路为：<strong>启动命令解析 → 配置解析与合并 → 环境准备 → 入口解析 → 模块递归构建 → 资源优化 → 输出到内存 → 启动开发服务器</strong>。</p>
<h3 data-id="heading-3">步骤1：执行启动命令并初始化</h3>
<p>开发模式下通常通过 <code>webpack serve</code>（Webpack 5 内置，替代旧版 <code>webpack-dev-server</code> 命令）启动，命令执行后触发以下操作：</p>
<ol>
<li><strong>命令解析</strong>：Node.js 执行 <code>webpack</code> 可执行文件，解析 <code>serve</code> 命令参数（如端口、是否自动打开浏览器等，优先级：命令行参数 &gt; 配置文件 &gt; 默认值）。</li>
<li><strong>初始化 Compiler 实例</strong>：Webpack 核心类 <code>Compiler</code> 被创建，该实例负责统筹整个构建流程，保存构建过程中的所有状态。</li>
</ol>
<h3 data-id="heading-4">步骤2：配置解析与合并</h3>
<p>Compiler 实例初始化后，Webpack 会读取并处理配置信息，核心操作包括：</p>
<ol>
<li><strong>读取配置文件</strong>：默认读取项目根目录的 <code>webpack.config.js</code>，若指定 <code>--config</code> 参数则读取对应文件（如 <code>npx webpack serve --config webpack.dev.js</code>）。</li>
<li><strong>配置合并</strong>：将用户配置与开发模式默认配置（<code>webpack/lib/config/defaults.js</code> 中定义）合并，用户配置优先级更高。例如开发模式默认 <code>optimization.minimize: false</code>，若用户未配置则沿用默认值。</li>
<li><strong>插件初始化</strong>：实例化配置中 <code>plugins</code> 数组内的所有插件（如 <code>HtmlWebpackPlugin</code>、<code>HotModuleReplacementPlugin</code>），并调用插件的 <code>apply</code> 方法将其挂载到 Compiler 实例上，监听后续构建生命周期事件。</li>
</ol>
<p><strong>示例</strong>：开发模式默认配置与用户配置合并后，<code>optimization</code> 部分最终配置为：</p>
<pre><code class="hljs language-arduino" lang="arduino">{
  optimization: {
    minimize: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 开发模式默认关闭压缩</span>
    splitChunks: {
      chunks: <span class="hljs-string">'async'</span> <span class="hljs-comment">// 默认只拆分异步chunk</span>
    },
    runtimeChunk: <span class="hljs-string">'single'</span> <span class="hljs-comment">// 默认提取运行时chunk（Webpack 5默认）</span>
  }
}
</code></pre>
<h3 data-id="heading-5">步骤3：环境准备与缓存初始化</h3>
<p>配置合并完成后，Webpack 会准备构建环境并初始化缓存机制，为后续构建加速：</p>
<ol>
<li><strong>环境变量注入</strong>：通过 <code>DefinePlugin</code>（Webpack 内置，开发模式自动启用）注入 <code>process.env.NODE_ENV = 'development'</code> 到代码中，供业务代码判断环境。</li>
<li><strong>缓存初始化</strong>：开发模式默认启用 <code>cache: true</code>，缓存目录为 <code>node_modules/.cache/webpack</code>，用于缓存模块解析结果（如 <code>resolve</code> 解析的路径）和编译结果（如 Babel 转译后的代码）。首次启动时缓存为空，后续构建可复用缓存。</li>
</ol>
<p><strong>环境变量示例</strong>：业务代码中可通过环境变量判断环境：</p>
<pre><code class="hljs language-ini" lang="ini">// src/index.js
if (<span class="hljs-attr">process.env.NODE_ENV</span> === <span class="hljs-string">'development'</span>) {
  console.log('当前为开发环境，启用调试模式')<span class="hljs-comment">;</span>
}
// 构建后会被替换为：if (<span class="hljs-attr">'development'</span> === <span class="hljs-string">'development'</span>) { ... }
</code></pre>
<h4 data-id="heading-6">缓存初始化</h4>
<p><strong>1. 简单项目结构示例</strong>：以常见的前端开发项目为例，核心目录及文件如下，后续缓存结构将对应此项目的构建产物：</p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># 项目根目录</span>
<span class="hljs-keyword">my</span>-webpack-project/
├─ src/                  <span class="hljs-comment"># 源码目录（Webpack构建入口）</span>
│  ├─ index.js           <span class="hljs-comment"># 入口文件（对应配置entry: ./src/index.js）</span>
│  ├─ utils.js           <span class="hljs-comment"># 工具模块（被index.js依赖）</span>
│  ├─ style.css          <span class="hljs-comment"># 样式文件（被index.js依赖）</span>
│  └─ index.html         <span class="hljs-comment"># HTML模板（供HtmlWebpackPlugin使用）</span>
├─ node_modules/         <span class="hljs-comment"># 第三方依赖（如react、lodash等）</span>
├─ webpack.config.js     <span class="hljs-comment"># Webpack配置文件（开发模式配置）</span>
└─ package.json          <span class="hljs-comment"># 项目依赖配置（含webpack、webpack-cli等）</span>
</code></pre>
<p><strong>2. 对应 .cache/webpack 目录结构</strong>：上述项目首次启动后，<code>node_modules/.cache/webpack</code> 会生成与项目模块对应的缓存文件，核心结构及对应关系如下：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 缓存目录（对应my-webpack-project项目）</span>
node_modules/.cache/webpack/
├─ <span class="hljs-literal">default</span>-development/  <span class="hljs-meta"># 开发模式缓存（mode: development对应）</span>
│  ├─ <span class="hljs-number">0.</span>pack             <span class="hljs-meta"># 缓存1：项目源码模块解析结果（src/index.js等路径解析）</span>
│  ├─ <span class="hljs-number">1.</span>pack             <span class="hljs-meta"># 缓存2：项目源码编译结果（babel-loader转译后代码、css-loader处理结果）</span>
│  ├─ <span class="hljs-number">2.</span>pack             <span class="hljs-meta"># 缓存3：第三方依赖缓存（node_modules中模块的解析+编译结果）</span>
│  ├─ cache.<span class="hljs-keyword">lock</span>         <span class="hljs-meta"># 缓存锁：防止多进程同时操作缓存导致冲突</span>
│  ├─ metadata.json      <span class="hljs-meta"># 元数据：记录缓存版本、项目依赖哈希、缓存有效期等</span>
│  └─ modules/           <span class="hljs-meta"># 拆分模块缓存（当项目模块较多时自动生成，对应单个模块）</span>
│     ├─ <span class="hljs-number">10.</span>js.cache     <span class="hljs-meta"># 对应src/index.js的编译缓存（独立模块缓存，便于增量更新）</span>
│     ├─ <span class="hljs-number">11.</span>js.cache     <span class="hljs-meta"># 对应src/utils.js的编译缓存</span>
│     ├─ <span class="hljs-number">12.</span>css.cache    <span class="hljs-meta"># 对应src/style.css的编译缓存（经css-loader处理后）</span>
│     └─ <span class="hljs-number">20.</span>js.cache     <span class="hljs-meta"># 对应node_modules/lodash的编译缓存（第三方依赖独立缓存）</span>
└─ webpack-dev-server/   <span class="hljs-meta"># devServer专属缓存</span>
   └─ watch-state.json   <span class="hljs-meta"># 监听状态缓存（记录src目录文件监听状态，快速检测文件变化）</span>
</code></pre>
<p><strong>缓存与项目的核心对应关系</strong>： - 项目<code>src/</code>目录下的每个模块（index.js、utils.js等）会对应<code>modules/</code>下的独立缓存文件（如10.js.cache）； - 项目<code>node_modules/</code>中的第三方依赖会集中缓存或拆分为独立模块缓存（如20.js.cache），首次构建后后续复用； - <code>0.pack</code>、<code>1.pack</code>等打包缓存为聚合型缓存，提升批量模块的读取效率，<code>modules/</code>下为单模块缓存，便于热更新时精准替换。</p>
<p><strong>缓存文件名与项目原文件名差异大的核心原因</strong>：<code>.cache/webpack</code> 中的文件名（如 <code>0.pack</code>、<code>10.js.cache</code>）并非直接沿用项目原文件名，而是 Webpack 基于“缓存唯一性”“构建效率”和“模块管理”设计的标识，具体原因如下：</p>
<ol>
<li><strong>基于内容哈希的唯一性标识</strong>：缓存的核心需求是“模块内容未变则复用缓存”，Webpack 会计算模块的<strong>内容哈希值</strong>（如 MD5、SHA-1）作为缓存键。例如 <code>src/index.js</code> 会根据其文件内容、依赖关系、loader 配置等生成唯一哈希，对应缓存文件名可能为 <code>10.js.cache</code>。这种方式能精准判断模块是否变化，避免因原文件名相同但内容不同导致的缓存失效问题。</li>
<li><strong>模块 ID 映射机制</strong>：Webpack 会为每个参与构建的模块分配唯一的<strong>模块 ID</strong>（数字或哈希形式），替代原文件名作为模块的内部标识。例如 <code>src/utils.js</code> 可能被分配 ID 为 <code>11</code>，其缓存文件对应 <code>11.js.cache</code>。模块 ID 能简化依赖图的管理，减少构建产物体积（数字 ID 比长文件名更简洁），同时缓存文件名直接关联模块 ID，便于快速定位模块缓存。</li>
<li><strong>聚合缓存的优化设计</strong>：<code>0.pack</code>、<code>1.pack</code> 等打包缓存文件是 Webpack 对多个模块缓存的聚合优化。当项目模块较多时，若为每个模块生成独立缓存文件会导致文件数量爆炸，影响读取效率。Webpack 会将关联紧密的模块（如同一目录下的源码模块、同一第三方库的子模块）的缓存聚合到一个 <code>*.pack</code> 文件中，文件名采用递增数字标识，既简化管理又提升批量读取速度。</li>
<li><strong>环境与配置关联的动态标识</strong>：缓存文件名会隐含构建环境（如 <code>default-development</code> 目录对应开发模式）和配置信息。例如不同 <code>mode</code>（开发/生产）、<code>devtool</code> 或 <code>loader</code> 配置会导致同一模块的编译结果不同，Webpack 会通过缓存目录结构和文件名后缀区分这些差异，确保不同配置下的缓存互不干扰。</li>
<li><strong>避免文件系统兼容性问题</strong>：不同操作系统对文件名的长度、特殊字符（如 <code>@</code>、<code>#</code>）有不同限制，项目原文件名可能包含特殊字符（如 <code>component@2x.js</code>）。缓存文件名采用标准化的数字或哈希形式，可避免跨系统缓存读写异常，确保缓存机制的跨平台兼容性。</li>
</ol>
<p><strong>总的来说，</strong> 缓存文件名的设计核心是“脱离原文件名束缚，以更高效、唯一的方式关联模块缓存”。其与原文件的对应关系并非通过文件名直接体现，而是通过缓存元数据（如 <code>metadata.json</code>）中的“模块 ID-原文件路径-哈希值”映射表实现，Webpack 内部可通过该映射表快速匹配原文件与缓存文件。</p>
<h3 data-id="heading-7">步骤4：入口解析与模块依赖图构建</h3>
<p>这是构建的<strong>核心</strong>步骤，Webpack 从入口文件开始，递归解析所有模块依赖，构建出完整的模块依赖图：</p>
<ol>
<li><strong>入口文件定位</strong>：根据配置的 <code>entry</code>（本文示例为 <code>./src/index.js</code>），通过 <code>resolve</code> 配置解析出入口文件的绝对路径。</li>
<li><strong>模块解析</strong>：调用 <code>loader-runner</code> 执行入口文件对应的 <code>loader</code>（本文示例中 <code>.js</code> 文件对应 <code>babel-loader</code>），对文件进行转译（如将 ES6+ 转译为 ES5）。</li>
<li><strong>依赖递归解析</strong>：转译后的代码通过 <code>acorn</code> 解析为 AST（抽象语法树），遍历 AST 找到 <code>require</code>、<code>import</code> 等依赖声明，递归解析每个依赖模块，重复步骤 2-3，直到所有依赖模块都被解析完成，最终构建出模块依赖图。</li>
</ol>
<p><strong>示例</strong>：若入口文件依赖 <code>src/utils.js</code> 和 <code>src/style.css</code>，依赖图结构为：</p>
<pre><code class="hljs language-bash" lang="bash">./src/index.js
├─ ./src/utils.js
└─ ./src/style.css
</code></pre>
<p>终端输出的编译日志会显示解析的模块数量：</p>
<pre><code class="hljs language-bash" lang="bash">[webpack-cli] Compilation finished

asset bundle.js 1.25 MiB [emitted] (name: main)
asset index.html 289 bytes [emitted]
runtime modules 27.5 KiB 13 modules
cacheable modules 530 KiB
  modules by path ./src/ 1.87 KiB
    ./src/index.js 786 bytes [built] [code generated]
    ./src/utils.js 523 bytes [built] [code generated]
    ./src/style.css 577 bytes [built] [code generated]
  modules by path ./node_modules/ 528 KiB
    ...（第三方依赖模块列表）
</code></pre>
<p>这里逐行解释一下信息：</p>
<pre><code class="hljs language-bash" lang="bash">// Webpack命令行编译完成的提示信息
[webpack-cli] Compilation finished
// 输出的JS资源：bundle.js文件名，体积1.25MiB，已发射（生成），对应主chunk
asset bundle.js 1.25 MiB [emitted] (name: main)
// 输出的HTML资源：index.html文件名，体积289字节，已发射
asset index.html 289 bytes [emitted]
// 运行时模块：负责模块加载、HMR等逻辑，共27.5KiB，13个模块
runtime modules 27.5 KiB 13 modules
// 可缓存模块：共530KiB，后续构建可复用缓存
cacheable modules 530 KiB
// 项目src目录下的模块统计：共1.87KiB
  modules by path ./src/ 1.87 KiB
    // 入口模块index.js：体积786字节，已构建，代码已生成
    ./src/index.js 786 bytes [built] [code generated]
    // 工具模块utils.js：体积523字节，已构建，代码已生成
    ./src/utils.js 523 bytes [built] [code generated]
    // 样式模块style.css：体积577字节，已构建，代码已生成（经loader处理后）
    ./src/style.css 577 bytes [built] [code generated]
// node_modules目录下的第三方依赖统计：共528KiB
  modules by path ./node_modules/ 528 KiB
    ...（第三方依赖模块列表）
</code></pre>
<h3 data-id="heading-8">步骤5：模块编译与代码生成</h3>
<p>所有模块解析完成后，Webpack 会将模块依赖图转换为可在浏览器中运行的代码，核心操作包括：</p>
<ol>
<li>
<p><strong>模块封装</strong>：将每个模块封装为独立的函数（基于 <code>IIFE</code>），避免全局变量污染，同时通过模块 ID 建立依赖关联。</p>
</li>
<li>
<p><strong>运行时注入</strong>：注入 Webpack 运行时代码（负责模块加载、依赖解析、HMR 逻辑等），使浏览器能够识别并执行封装后的模块。</p>
</li>
<li>
<p><strong>资源处理</strong>：对于非 JS 资源（如 CSS、图片），根据 <code>loader</code> 配置处理：</p>
<ul>
<li><strong>CSS 模块</strong>：<code>css-loader</code> 解析 <code>@import</code> 和 <code>url()</code>，<code>style-loader</code> 将 CSS 转换为 JS 字符串，通过 <code>document.createElement('style')</code> 注入到页面。</li>
<li><strong>图片资源</strong>：若配置 <code>file-loader</code> 或 <code>url-loader</code>，会将图片转换为 Base64 或输出到指定目录（开发模式通常嵌入内存以提升速度）。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：编译后的 <code>bundle.js</code> 开头会包含运行时代码，模块部分类似：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 运行时代码（简化）</span>
(<span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>) {
  <span class="hljs-keyword">var</span> installedModules = {};
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) { ... } <span class="hljs-comment">// 模块加载逻辑</span>
  __webpack_require__.<span class="hljs-property">hmrM</span> = {}; <span class="hljs-comment">// HMR相关逻辑</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">__webpack_require__</span>(__webpack_require__.<span class="hljs-property">s</span> = <span class="hljs-string">"./src/index.js"</span>);
})({
  <span class="hljs-comment">// 模块封装（简化）</span>
  <span class="hljs-string">"./src/index.js"</span>: (<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, __webpack_require__</span>) {
    <span class="hljs-keyword">var</span> utils = <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-string">"./src/utils.js"</span>);
    <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-string">"./src/style.css"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前为开发环境，启用调试模式'</span>);
  }),
  <span class="hljs-string">"./src/utils.js"</span>: (<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span></span>) {
    <span class="hljs-built_in">exports</span>.<span class="hljs-property">formatDate</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">date</span>) { ... };
  }),
  <span class="hljs-string">"./src/style.css"</span>: (<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, __webpack_require__</span>) {
    <span class="hljs-keyword">var</span> style = <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-string">"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"</span>)(...);
  })
});
</code></pre>
<h3 data-id="heading-9">步骤6：插件执行（优化与输出）</h3>
<p>模块编译完成后，Webpack 会触发 <code>emit</code>（输出前）和 <code>afterEmit</code>（输出后）等生命周期事件，插件通过监听这些事件介入构建流程。需明确：Webpack 5 开发模式下<strong>无绝对“必须手动配置”的插件</strong>（核心能力已内置），但存在<strong>实现核心开发体验的“关键必选插件”</strong>（部分可通过配置自动注入），具体分类及执行逻辑如下：</p>
<h4 data-id="heading-10">一、开发模式核心必选插件（实现基础功能）</h4>
<p>这类插件是开发模式正常运行的基础，缺失会导致核心功能失效，部分可通过配置自动启用，推荐手动配置以确保兼容性：</p>
<ol>
<li>
<p><strong>HotModuleReplacementPlugin（热更新核心插件）触发时机</strong>：监听 <code>compile</code>（编译开始）、<code>make</code>（模块构建）、<code>emit</code>（输出前）等事件。</p>
<ul>
<li><strong>核心作用</strong>：注入热更新相关运行时代码（如模块变化检测、补丁生成逻辑），是 HMR 机制的核心。若不配置，即使 <code>devServer.hot: true</code>，也只能触发全页刷新，无法实现局部热更新。</li>
<li><strong>启用方式</strong>：Webpack 5 中配置 <code>devServer.hot: true</code> 会自动注入，但手动在 <code>plugins</code> 中配置可避免版本兼容问题，配置代码：<code>new webpack.HotModuleReplacementPlugin()</code>。</li>
</ul>
</li>
<li>
<p><strong>DefinePlugin（环境变量注入插件）触发时机</strong>：监听 <code>compile</code> 事件，在模块编译前注入环境变量。</p>
<ul>
<li><strong>核心作用</strong>：将 <code>process.env.NODE_ENV = 'development'</code> 等环境变量注入业务代码，供开发者判断环境（如调试逻辑开关）。这是开发模式“不压缩代码”“启用 Source Map”等默认行为的触发基础。</li>
<li><strong>启用方式</strong>：Webpack 5 配置 <code>mode: 'development'</code> 后自动启用，无需手动配置；若需自定义环境变量，可手动配置插件并传入参数。</li>
</ul>
</li>
</ol>
<h4 data-id="heading-11">二、提升开发体验的关键推荐插件（非强制但必备）</h4>
<p>这类插件不影响基础构建流程，但缺失会大幅降低开发效率，是实际开发中“必选”的体验增强插件：</p>
<ol>
<li>
<p><strong>HtmlWebpackPlugin（HTML 自动生成插件）触发时机</strong>：监听 <code>emit</code> 事件（输出前）。</p>
<ul>
<li><strong>核心作用</strong>：根据模板自动生成 HTML 文件，并将构建后的 JS/CSS 资源路径自动注入（如 <code>&lt;script src="bundle.js"&gt;&lt;/script&gt;</code>）。若不配置，需手动创建 HTML 并维护资源路径，模块拆分或文件名变化后需手动修改，极易出错。</li>
<li><strong>启用方式</strong>：需手动安装（<code>npm i html-webpack-plugin -D</code>）并配置，核心配置：<code>new HtmlWebpackPlugin({ template: './src/index.html' })</code>。</li>
</ul>
</li>
<li>
<p><strong>（替代 CleanWebpackPlugin）output.clean 配置触发时机</strong>：构建前清空 <code>output.path</code> 目录（对应原 CleanWebpackPlugin 的核心功能）。</p>
<ul>
<li><strong>核心作用</strong>：避免旧构建产物（如重命名后的旧 chunk 文件）残留，防止开发中手动访问磁盘资源时加载旧文件。</li>
<li><strong>启用方式</strong>：Webpack 5 已将 CleanWebpackPlugin 功能内置到 <code>output.clean: true</code>，无需安装插件；Webpack 4 及以下需手动安装 CleanWebpackPlugin 并配置。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：生成的 <code>index.html</code> 内容（自动注入 <code>bundle.js</code>）：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack Dev Mode<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"bundle.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 data-id="heading-12">步骤7：输出到内存（非磁盘）</h3>
<p>开发模式与生产模式的核心区别之一是输出目标：生产模式将构建结果输出到磁盘（<code>output.path</code> 目录），而开发模式为提升速度，将构建结果（JS、HTML、CSS 等）存储在<strong>内存</strong>中，由 <code>webpack-dev-server</code> 直接从内存读取资源并提供服务。</p>
<p>开发模式下通过 <code>memory-fs</code> 存储的文件结构，与配置的 <code>output</code> 目录逻辑一致，但仅存在于内存中，可通过开发服务器的资源访问路径映射。以本文基础配置为例，内存中的核心文件结构如下：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 内存中的虚拟文件系统结构（对应 output.path: dist 逻辑目录）</span>
<span class="hljs-selector-tag">dist</span>/  <span class="hljs-comment">// 虚拟根目录，对应配置的 output.path</span>
├─ <span class="hljs-selector-tag">bundle</span><span class="hljs-selector-class">.js</span>  <span class="hljs-comment">// 主构建产物（JS文件，含运行时+模块代码+Source Map信息）</span>
├─ <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.html</span>  <span class="hljs-comment">// HtmlWebpackPlugin生成的HTML文件（自动注入bundle.js路径）</span>
├─ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.abc123</span><span class="hljs-selector-class">.hot-update</span><span class="hljs-selector-class">.js</span>  <span class="hljs-comment">// 热更新补丁文件（代码修改后动态生成）</span>
├─ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.abc123</span><span class="hljs-selector-class">.hot-update</span><span class="hljs-selector-class">.json</span>  <span class="hljs-comment">// 热更新元数据（记录更新模块ID、哈希值）</span>
└─ <span class="hljs-selector-tag">assets</span>/  <span class="hljs-comment">// 若配置处理图片等资源（如url-loader），生成的虚拟资源目录</span>
   └─ <span class="hljs-selector-tag">logo</span><span class="hljs-selector-class">.efg456</span><span class="hljs-selector-class">.png</span>  <span class="hljs-comment">// 处理后的图片资源（可能为Base64编码或虚拟路径）</span>
</code></pre>
<p>  <strong>内存文件结构的核心特点</strong>：</p>
<ol>
<li><strong>逻辑映射性</strong>：虚拟目录 <code>dist/</code> 与配置的 <code>output.path</code> 完全对应，资源路径（如 <code>bundle.js</code>）与磁盘输出时一致，确保开发服务器可通过 <code>/bundle.js</code> 直接访问；</li>
<li><strong>动态性</strong>：热更新时会动态新增/修改补丁文件（如 <code>.hot-update.js</code>），无需重建整个目录结构，提升更新效率；</li>
<li><strong>无实际文件</strong>：无法通过文件管理器查看，需通过浏览器开发者工具的 <code>Network</code> 面板（如访问 <code>http://localhost:8080/bundle.js</code>）或 Webpack 插件（如 <code>webpack-dev-middleware</code> 的调试接口）查看；</li>
<li><strong>资源完整性</strong>：包含构建所需的所有资源（JS、HTML、补丁文件、处理后的静态资源），与磁盘输出的完整产物逻辑一致，确保浏览器可正常加载运行。</li>
</ol>
<p><strong>关键原理</strong>：Webpack 通过 <code>memory-fs</code>（内存文件系统）替代本地文件系统，构建结果写入内存后，<code>webpack-dev-server</code> 监听内存中的文件变化，无需等待磁盘 I/O，大幅提升响应速度。</p>
<p><strong>示例</strong>：首次构建完成后，项目根目录的 <code>dist</code> 目录可能为空（或仅存在非 Webpack 管理的静态资源），但浏览器访问 <code>http://localhost:8080</code> 可正常加载页面，因为资源来自内存。</p>
<h3 data-id="heading-13">步骤8：启动开发服务器并监听文件变化</h3>
<p>构建结果写入内存后，<code>webpack-dev-server</code> 会启动一个 HTTP 服务器（默认端口 8080），并完成以下操作：</p>
<ol>
<li><strong>启动服务器</strong>：绑定配置的端口（本文示例为 8080），并将内存中的资源作为静态资源提供服务。</li>
<li><strong>自动打开浏览器</strong>：若配置 <code>devServer.open: true</code>，会自动打开浏览器并访问服务器地址（如 <code>http://localhost:8080</code>）。</li>
<li><strong>监听文件变化</strong>：通过 <code>chokidar</code> 库监听 <code>src</code> 等源码目录的文件变化（可通过 <code>devServer.watchFiles</code> 配置监听范围），当文件修改时触发后续热更新流程。</li>
</ol>
<p><strong>示例</strong>：服务器启动完成后，终端输出日志：</p>
<pre><code class="hljs language-vbscript" lang="vbscript">[webpack-dev-<span class="hljs-built_in">server</span>] <span class="hljs-built_in">Server</span> started: Hot Module Replacement enabled, Live Reloading enabled, Progress disabled, Overlay enabled.
[webpack-dev-<span class="hljs-built_in">server</span>] Live Reloading enabled.
</code></pre>
<p>此时浏览器访问 <code>http://localhost:8080</code> 可看到页面，控制台输出 “当前为开发环境，启用调试模式”。</p>
<h2 data-id="heading-14">场景二：代码更新（热更新）流程</h2>
<p>当开发者修改源码后（如修改 <code>src/index.js</code>），Webpack 会通过热模块替换（HMR）机制实现局部更新，无需全页刷新，流程链路为：<strong>文件变化检测 → 增量构建 → 生成更新补丁 → 客户端接收补丁 → 局部模块替换</strong>。</p>
<p>以下步骤基于首次启动完成后的状态展开。</p>
<h3 data-id="heading-15">步骤1：检测文件变化</h3>
<p><code>webpack-dev-server</code> 通过 <code>chokidar</code> 监听配置的文件目录（默认监听 <code>context</code> 目录下的文件），当文件被修改并保存后，触发以下操作：</p>
<ol>
<li><strong>变化检测</strong>：<code>chokidar</code> 检测到文件变化（如 <code>src/index.js</code> 被修改），并将变化的文件路径通知给 Webpack。</li>
<li><strong>过滤无关变化</strong>：Webpack 会过滤掉非模块文件（如日志文件、临时文件）和配置中排除的文件（如 <code>node_modules</code>），仅处理源码模块的变化。</li>
</ol>
<p><strong>示例</strong>：修改 <code>src/index.js</code> 中的控制台输出内容，保存后终端输出：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-section">[webpack-dev-server]</span> <span class="hljs-section">[HMR]</span> File updated: ./src/index.js
<span class="hljs-section">[webpack-cli]</span> Compilation starting...
</code></pre>
<h3 data-id="heading-16">步骤2：增量构建（仅重新编译变化的模块）</h3>
<p>与首次启动的全量构建不同，热更新时 Webpack 会执行<strong>增量构建</strong>，仅重新处理变化的模块及其依赖，大幅提升构建速度，核心操作包括：</p>
<ol>
<li>
<p><strong>模块依赖分析</strong>：根据文件变化路径，找到对应的模块 ID，然后分析该模块在依赖图中的所有依赖和被依赖模块（即“依赖链”）。例如，若修改 <code>src/utils.js</code>，则所有依赖 <code>utils.js</code> 的模块（如 <code>index.js</code>）都需要重新编译。</p>
</li>
<li>
<p><strong>缓存复用</strong>：未变化的模块直接复用首次构建时的缓存结果，仅重新编译变化的模块及其依赖链上的模块。缓存结果来自 Webpack 开发模式默认的文件系统缓存目录 <code>node_modules/.cache/webpack</code>（首次启动时已初始化该目录及缓存文件）。具体来说，未变化模块的缓存分为两类，获取逻辑不同：</p>
<ol>
<li><strong>项目源码模块（如 utils.js、style.css）</strong> ：其缓存对应缓存目录中 <code>node_modules/</code> 下的独立文件（如 <code>11.js.cache</code> 对应 <code>src/utils.js</code>），缓存内容为模块的解析路径和经 loader 处理后的编译结果。Webpack 通过模块 ID 与原文件路径的映射关系（存储在 <code>metadata.json</code> 中），快速匹配并读取对应缓存。</li>
<li><strong>第三方依赖模块（如 node_modules 下的库）</strong> ：其缓存通常聚合在 <code>0.pack</code> 或 <code>2.pack</code> 等打包缓存文件中，缓存内容为依赖的解析结果和编译结果（若未排除转译）。因第三方依赖极少修改，Webpack 直接复用首次构建时生成的缓存，无需重新解析和转译。</li>
</ol>
</li>
<li>
<p><strong>代码重新生成</strong>：对变化的模块重新执行 <code>loader</code> 转译和模块封装，生成新的模块代码。</p>
</li>
</ol>
<p><strong>示例</strong>：修改 <code>src/index.js</code> 后，终端输出的增量构建日志（仅重新编译变化的模块）：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-attr">[webpack-cli]</span> Compilation finished
asset bundle<span class="hljs-selector-class">.js</span> <span class="hljs-number">1.25</span> MiB <span class="hljs-selector-attr">[emitted]</span> (name: main)
asset index<span class="hljs-selector-class">.html</span> <span class="hljs-number">289</span> bytes <span class="hljs-selector-attr">[emitted]</span>
runtime modules <span class="hljs-number">27.5</span> KiB <span class="hljs-number">13</span> modules
cacheable modules <span class="hljs-number">530</span> KiB
  modules by path ./<span class="hljs-attribute">src</span>/ <span class="hljs-number">1.87</span> KiB
    ./<span class="hljs-attribute">src</span>/index<span class="hljs-selector-class">.js</span> <span class="hljs-number">792</span> bytes <span class="hljs-selector-attr">[built]</span> <span class="hljs-selector-attr">[code generated]</span> <span class="hljs-selector-attr">[1 change]</span> <span class="hljs-comment">// 仅该模块变化</span>
    ./<span class="hljs-attribute">src</span>/utils<span class="hljs-selector-class">.js</span> <span class="hljs-number">523</span> bytes <span class="hljs-selector-attr">[built]</span> <span class="hljs-selector-attr">[code generated]</span> <span class="hljs-selector-attr">[cache hit]</span> <span class="hljs-comment">// 缓存命中，未重新编译</span>
    ./<span class="hljs-attribute">src</span>/style<span class="hljs-selector-class">.css</span> <span class="hljs-number">577</span> bytes <span class="hljs-selector-attr">[built]</span> <span class="hljs-selector-attr">[code generated]</span> <span class="hljs-selector-attr">[cache hit]</span>
  modules by path ./node_modules/ <span class="hljs-number">528</span> KiB
    ...（第三方依赖缓存命中）
</code></pre>
<h3 data-id="heading-17">步骤3：生成模块更新补丁（HMR Update）</h3>
<p>增量构建完成后，<code>HotModuleReplacementPlugin</code> 会生成模块更新补丁，核心内容包括：</p>
<ol>
<li><strong>变化模块信息</strong>：包含变化的模块 ID、新的模块代码、模块依赖关系等。</li>
<li><strong>更新策略</strong>：指定如何替换旧模块（如直接替换、删除后新增）。</li>
</ol>
<p>补丁文件通常以 <code>.hot-update.js</code> 结尾（如 <code>main.abc123.hot-update.js</code>），同时生成一个 <code>.hot-update.json</code> 文件记录更新信息（如更新的 chunk 名称、哈希值）。这些文件同样存储在内存中。</p>
<p><strong>示例</strong>：热更新构建完成后，终端输出补丁相关日志：</p>
<pre><code class="hljs language-csharp" lang="csharp">[<span class="hljs-meta">HMR</span>] Updated modules:
[<span class="hljs-meta">HMR</span>]  - ./src/index.js
[<span class="hljs-meta">HMR</span>] Webpack output <span class="hljs-keyword">is</span> served <span class="hljs-keyword">from</span> /
[<span class="hljs-meta">HMR</span>] Content <span class="hljs-keyword">not</span> <span class="hljs-keyword">from</span> webpack <span class="hljs-keyword">is</span> served <span class="hljs-keyword">from</span> <span class="hljs-string">'./dist'</span> directory
[<span class="hljs-meta">HMR</span>] App updated. Recompiling...
[<span class="hljs-meta">HMR</span>] Waiting <span class="hljs-keyword">for</span> update signal <span class="hljs-keyword">from</span> WDS...
</code></pre>
<h3 data-id="heading-18">步骤4：客户端（浏览器）接收更新通知</h3>
<p>开发服务器与客户端之间通过 <code>WebSocket</code> 建立长连接，实时同步更新信息，核心流程：</p>
<ol>
<li><strong>服务器发送更新通知</strong>：当补丁生成完成后，服务器通过 WebSocket 向客户端发送更新通知，包含更新的 <code>hash</code> 值（用于匹配补丁文件）。</li>
<li><strong>客户端请求补丁文件</strong>：客户端（浏览器）接收到通知后，根据 <code>hash</code> 值请求对应的 <code>.hot-update.json</code> 和 <code>.hot-update.js</code> 补丁文件（从内存中获取）。</li>
</ol>
<p><strong>示例</strong>：打开浏览器开发者工具的 <code>Network</code> 面板，可看到热更新时的请求：</p>
<pre><code class="hljs language-bash" lang="bash">GET http://localhost:8080/main.abc123.hot-update.json 200 OK
GET http://localhost:8080/main.abc123.hot-update.js 200 OK
</code></pre>
<h3 data-id="heading-19">步骤5：局部模块替换与页面更新</h3>
<p>客户端获取补丁文件后，由 Webpack 运行时的 HMR 逻辑执行局部模块替换，避免全页刷新，核心操作：</p>
<ol>
<li><strong>模块替换</strong>：运行时根据补丁文件中的模块信息，替换内存中对应的旧模块代码，并更新模块依赖关系。</li>
<li><strong>执行模块热替换回调</strong>：若业务代码中定义了 <code>module.hot.accept</code> 回调（用于处理模块更新后的逻辑），则执行该回调。例如，React 项目中 <code>react-refresh-webpack-plugin</code> 会通过该回调实现组件的热刷新。</li>
<li><strong>局部页面更新</strong>：若模块替换成功且无需全页刷新，则仅更新页面中受影响的部分（如修改 CSS 后实时更新样式，修改 JS 后执行新逻辑）；若模块无法热替换（如修改了运行时代码），则 <code>webpack-dev-server</code> 会自动触发全页刷新。</li>
</ol>
<p><strong>示例1：基础 JS 模块热更新</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/index.js</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前为开发环境，启用调试模式'</span>);

<span class="hljs-comment">// 定义HMR回调（可选，用于自定义更新逻辑）</span>
<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>) {
  <span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-string">'./utils.js'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'utils模块已更新，执行自定义逻辑'</span>);
    <span class="hljs-comment">// 重新调用utils模块的方法</span>
    <span class="hljs-keyword">const</span> { formatDate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./utils.js'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'更新后的日期格式：'</span>, <span class="hljs-title function_">formatDate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));
  });
}
</code></pre>
<p>修改 <code>src/utils.js</code> 后，浏览器控制台输出：</p>
<pre><code class="hljs language-csharp" lang="csharp">[<span class="hljs-meta">HMR</span>] Updated modules:
[<span class="hljs-meta">HMR</span>]  - ./src/utils.js
[<span class="hljs-meta">HMR</span>] App <span class="hljs-keyword">is</span> up to date.
utils模块已更新，执行自定义逻辑
更新后的日期格式：<span class="hljs-number">2025</span><span class="hljs-number">-11</span><span class="hljs-number">-15</span>
</code></pre>
<p><strong>示例2：CSS 热更新</strong>：由于 <code>style-loader</code> 会将 CSS 注入到 <code>style</code> 标签中，修改 <code>src/style.css</code> 后，HMR 会直接替换 <code>style</code> 标签中的内容，页面样式实时更新，无需刷新。</p>
<h2 data-id="heading-20">关键优化点与常见问题</h2>
<h3 data-id="heading-21">1. 开发模式构建速度优化</h3>
<ul>
<li><strong>合理配置缓存</strong>：默认启用的缓存已足够优化，若需自定义可配置 <code>cache</code> 选项（如指定缓存目录、缓存类型）。例如配置 <code>cache: { type: 'filesystem', cacheDirectory: path.resolve(__dirname, '.webpack-cache') }</code> 可将缓存存储到自定义目录，便于管理。</li>
<li><strong>排除第三方依赖</strong>：通过 <code>module.rules.exclude: /node_modules/</code> 排除第三方依赖，避免重复转译（第三方依赖通常已编译为 ES5）。进一步可结合 <code>cache-loader</code> 或 Webpack 5 内置缓存，缓存第三方依赖的处理结果。</li>
<li><strong><code>thread-loader</code></strong> <strong>使用</strong>：对耗时的 <code>loader</code>（如 <code>babel-loader</code>）启用多线程处理，提升转译速度。配置示例：<code>use: ['thread-loader', 'babel-loader']</code>，需注意线程启动有开销，适合处理大量文件时使用。</li>
<li><strong>减少监听文件范围</strong>：通过 <code>devServer.watchFiles</code> 仅监听源码目录，避免监听 <code>node_modules</code> 等目录。示例配置 <code>devServer: { watchFiles: ['src/**/*'] }</code>，精准监听 src 下所有文件变化。</li>
<li><strong>选择合适的 devtool</strong>：不同 <code>devtool</code> 类型对构建速度影响显著，开发模式推荐 <code>eval-cheap-module-source-map</code>（平衡速度与调试体验），若追求极致速度可临时使用 <code>eval</code>（调试信息较简略）。</li>
<li><strong>拆分公共代码</strong>：通过 <code>optimization.splitChunks</code> 拆分第三方依赖为独立 chunk（如 <code>vendors.js</code>），该 chunk 仅在依赖变化时重新构建，减少主 chunk 构建频率。配置示例：<code>splitChunks: { chunks: 'all', cacheGroups: { vendors: { test: /node_modules/, name: 'vendors', priority: -10 } } }</code>。</li>
<li><strong><code>webpack-dev-middleware</code></strong> <strong>使用 自定义服务</strong>：若需整合 Express 等 Node 服务，可使用 <code>webpack-dev-middleware</code> 替代 <code>webpack-dev-server</code>，灵活控制服务逻辑的同时保留内存构建特性。</li>
</ul>
<h3 data-id="heading-22">2. 热更新失效的常见原因</h3>
<ul>
<li><strong>未启用 HMR 插件</strong>：需在 <code>plugins</code> 中配置 <code>new webpack.HotModuleReplacementPlugin()</code>。Webpack 5 中 <code>devServer.hot: true</code> 会自动注入该插件，但手动配置插件可避免版本兼容问题。</li>
<li><strong>devServer.hot 未开启</strong>：需在 devServer 配置中设置 <code>hot: true</code>，确保开发服务器启用热更新功能，该配置与 HotModuleReplacementPlugin 需配合使用。若同时设置 <code>hotOnly: true</code>，则热更新失败时不触发全页刷新，便于排查问题。</li>
<li><strong>模块无法热替换</strong>：部分模块（如入口文件、运行时代码）或未适配 HMR 的第三方库，修改后无法实现局部替换，会触发全页刷新；可通过 <code>module.hot.accept</code> 自定义适配逻辑。例如入口文件无法直接热替换，可将核心逻辑抽离为子模块后对其配置热更新。</li>
<li><strong>文件监听异常</strong>：Windows 系统下可能因文件权限问题导致 chokidar 监听失效，或因 <code>node_modules</code> 等目录未排除导致监听负载过高，可通过 <code>devServer.watchFiles</code> 精确配置监听范围。此外，编辑器自动保存可能触发多次更新，可调整编辑器保存策略或配置 <code>devServer.watchOptions.ignored</code> 排除临时文件。</li>
<li><strong>缓存冲突</strong>：若之前的构建缓存未清理，可能导致旧模块缓存与新模块冲突，可通过删除 <code>node_modules/.cache/webpack</code> 目录或配置 <code>cache: false</code> 临时禁用缓存排查问题。若使用 <code>filesystem</code> 缓存，可配置 <code>cache.buildDependencies.config: [__filename]</code>，确保配置文件变化时清空缓存。</li>
<li><strong>第三方库兼容性问题</strong>：部分老旧第三方库使用全局变量或未采用模块化规范，修改其引用后可能导致热更新失效。解决方案：使用 <code>imports-loader</code> 或 <code>exports-loader</code> 适配模块化，或通过 <code>splitChunks</code> 将其拆分为独立 chunk 减少更新影响。</li>
<li><strong>WebSocket 连接失败</strong>：防火墙拦截、端口占用或代理配置错误可能导致 WebSocket 连接失败，热更新通知无法传递。排查方法：检查终端是否有 WebSocket 错误日志，确保 <code>devServer.client.webSocketURL</code> 配置正确，端口未被其他进程占用。</li>
<li><strong>loader 配置冲突</strong>：部分 loader 可能修改模块输出格式，导致 HMR 无法识别模块变化。例如使用 <code>babel-loader</code> 时未排除 <code>node_modules</code>，可能导致第三方模块转译后热更新异常，需确保 <code>exclude</code> 配置正确。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[4:2:1！老刘的三季度项目报告]]></title>    <link>https://juejin.cn/post/7573336057480757254</link>    <guid>https://juejin.cn/post/7573336057480757254</guid>    <pubDate>2025-11-17T07:57:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573336057480757254" data-draft-id="7573300346262765622" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="4:2:1！老刘的三季度项目报告"/> <meta itemprop="keywords" content="Flutter,客户端,HarmonyOS"/> <meta itemprop="datePublished" content="2025-11-17T07:57:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员老刘"/> <meta itemprop="url" content="https://juejin.cn/user/662360127965769"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            4:2:1！老刘的三季度项目报告
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/662360127965769/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员老刘
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T07:57:25.000Z" title="Mon Nov 17 2025 07:57:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>哈喽，我是老刘</strong></p>
<p>最近各大上市公司忙着晒三季度财报，老刘也整理了一下三季度的项目情况(<em>^▽^</em>)</p>
<p>4个Flutter、2个原生、1个鸿蒙，这个比例能否折射出一些客户端的技术选择逻辑？鸿蒙项目为何半路夭折，甲方爸爸付了一半钱就跑路？原生开发真的老了吗？</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/472175a1c6f7428a916ba973c1decc0f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP5ZGY6ICB5YiY:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763971044&amp;x-signature=Jg0YiwVOggmfoFgbdcHFHYdxo7w%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<p>今天老刘带你看看真实的企业开发里的技术选择逻辑。</p>
<p>这里我们不空谈理论，而是选择最实用成本最低的技术方案。</p>
<h2 data-id="heading-0">Flutter 4/7 的占有率不是偶然</h2>
<p>先说结论：Flutter能占到4/7，真不是老刘偏心，而是市场用脚投票的结果。</p>
<p><strong>公司内部项目，2个都是Flutter</strong></p>
<p>第一个是公司主力App，已经跑了6年，老刘入职前就在。</p>
<p>我入职后开始负责从原生代码迁移到Flutter，目前还是原生 + Flutter的混合开发状态，估计这种状态还会持续很长时间。</p>
<p>为啥不一次到位？因为迁移成本高而且没必要。</p>
<p>但是新功能全用Flutter开发，老功能会逐步完成替换。</p>
<p>最终的状态会是大部分功能都用Flutter实现了，只有一些底层功能长期保留在原生代码中。</p>
<p>第二个是小项目，面向普通用户。</p>
<p>直接Flutter开干，没有犹豫。</p>
<p>因为团队熟悉，开发效率高，一套代码多端运行，这买卖划算。</p>
<p><strong>外包客户项目，2个也都是Flutter</strong></p>
<p>第一个最有意思：客户直接指定Flutter，老刘从0到1搭建，交付后客户自己维护。</p>
<p>客户有开发团队，也知道Flutter是趋势，但缺乏大型项目经验。找老刘搭好框架，核心功能开发完，后续自己维护。</p>
<p>这不是能力问题，而是成本考量——传统行业不想养大型客户端团队，外包主体部分，留少数人维护升级。</p>
<p>第二个讨论了3轮设计和技术方案，客户最终接受建议用Flutter。</p>
<p>也是传统行业，但用户是非专业人员，典型的外包项目。</p>
<p>其实这种情况是最普遍的，客户这边没有专门的客户端开发团队。</p>
<p>你给他们讲哪个技术更先进其实他们是不太了解的。但是Flutter只需要一份开发人员，这个他们是很喜欢的。</p>
<p><strong>这不是技术选择，是商业选择</strong></p>
<p>企业不care你用什么技术，他们只关心开发快不快？稳定不稳定？后期维护麻烦不麻烦？</p>
<p>Flutter刚好满足了这些需求。</p>
<p>4/7的占有率不是偶然，这是市场选择的结果，是企业用脚投票。</p>
<h2 data-id="heading-1">原生开发的不可替代性</h2>
<p>这两个项目比较类似，都是基于Android端的pad进行数据展示的，只是展示的数据源好样式不一样。</p>
<p>这两个都是比较小型的项目，基本上投入2~3人几天就完成了。</p>
<p>其中第一个客户本来有意向使用Flutter进行开发，但是考虑到数据获取部分已经有原生的代码支持，而且UI方面的功能相对非常简单，所以老刘就建议客户先用原生了。</p>
<p>有些时候没必要提升整个架构的复杂度，保持简单，成本也会更低。</p>
<p>如果后续有更大规模的功能需求，再考虑是否迁移到Flutter或者切换到混合开发。</p>
<p>第二个其实就是延用第一个的技术方案，所以直接给客户建议使用原生开发。</p>
<p><strong>混合开发是更普适的方案</strong></p>
<p>老刘现在做的项目，很多都是混合开发。</p>
<p>Flutter负责业务逻辑，原生负责底层能力。</p>
<p>各取所长，谁也不抢谁的饭碗。</p>
<p>原生开发不会死，它只是变得更专精了。</p>
<p>就像现在还有人在用C语言写驱动一样。</p>
<p>技术不会消失，只会找到自己的位置。</p>
<h2 data-id="heading-2">鸿蒙项目翻车现场</h2>
<p>这个项目说来话长，简直是教科书级别的"客户跑路"案例。</p>
<p>原本是个PC端项目，客户领导说要在鸿蒙上开发个版本试试水。</p>
<p>方案讨论的挺明白：我们负责UI和业务逻辑，底层数据通信和文件处理客户自己搞定。</p>
<p>主要是底层有一些客户自己的逻辑，不方便外包的。</p>
<p>结果项目开发了一大半了，客户那边开发的底层出了不少问题，那边找了个借口就放弃了。</p>
<p>最后协商结果：客户付一半钱，项目结束。</p>
<p>说白了就是烂尾了，甲方爸爸付了一半钱跑路。</p>
<p>话说这种“领导想试试水”的项目从一开始就有种不祥的预感。</p>
<p>另一方面把一个平台的应用的底层代码迁移到另一个平台也确实是一个比较复杂的任务。</p>
<p>对一些不是很熟悉的团队来说，确实有可能会遇到不少问题，然后发现实际的项目周期和需要的资源比预定的计划要超出很多。</p>
<h2 data-id="heading-3">这3个坑，老刘踩过，你别再踩了</h2>
<ol>
<li><strong>Flutter不是银弹</strong></li>
</ol>
<p>我们团队目前最熟悉的技术栈是Flutter。</p>
<p>因此习惯性的会更优先的选择Flutter作为项目的技术栈。</p>
<p>但是在一些底层依赖原生功能的场景下，Flutter + 原生的混合开发模式确实也会增加项目的复杂度。</p>
<p>这时候一定要综合考量各种因素，比如项目的规模、客户的后期维护需求、项目的时间周期等等，有时候直接选择原生可能是最好的。</p>
<p>总的原则是简化问题，除非有明确的需求，否则不要过度设计。</p>
<p>等项目规模扩大，或者客户有更复杂的需求，才考虑是否迁移到Flutter。</p>
<ol start="2">
<li><strong>鸿蒙生态还不成熟</strong></li>
</ol>
<p>偏底层功能迁移需要预留多一些时间和资源。</p>
<p>避免项目的周期超出预期，这是一个比较大的风险。</p>
<ol start="3">
<li><strong>外包项目要做好预期管理</strong></li>
</ol>
<p>和大公司合作一般比较稳妥，而且客户一般也会有自己的技术团队，维护成本会比较低。</p>
<p>小机构和个人的项目，前期一定要做好沟通和异常情况的说明。</p>
<p>很多小项目，尤其是个人项目，客户想象中的开发进度时很美好的。</p>
<p>但是现实总会和预期有很大的差距。</p>
<p>为了避免后期扯皮，前期的需求规格说明、设计文档等交付一定要非常详细，把可能的异常情况和处理方案都列出来。</p>
<p>这可以避免后期因为沟通不及时导致的项目的问题。</p>
<h2 data-id="heading-4">总结</h2>
<p>回顾这7个项目，4个Flutter、2个原生、1个鸿蒙夭折。有这么几点感想：</p>
<ul>
<li>Flutter不是万能的，但在多数场景下确实是最优解。</li>
<li>原生开发不会消失。</li>
<li>鸿蒙很有潜力，但生态成熟需要时间。</li>
</ul>
<p>总的来说就是一句话，<strong>合适的技术才是最优解。</strong></p>
<p>如果看到这里的同学对客户端或者Flutter开发感兴趣，欢迎联系老刘，我们互相学习。
私信免费领老刘整理的《Flutter开发手册》，覆盖90%应用开发场景。
可以作为Flutter学习的知识地图。</p>
<p>—— laoliu_dev</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Cesium.js基本使用]]></title>    <link>https://juejin.cn/post/7573225720697421876</link>    <guid>https://juejin.cn/post/7573225720697421876</guid>    <pubDate>2025-11-17T06:35:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720697421876" data-draft-id="7573170756868915252" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Cesium.js基本使用"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-17T06:35:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Harlen"/> <meta itemprop="url" content="https://juejin.cn/user/2606281407074829"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Cesium.js基本使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2606281407074829/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Harlen
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:35:05.000Z" title="Mon Nov 17 2025 06:35:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h2 data-id="heading-0"><strong>整体效果如下：</strong></h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bff7f3e607c344c6b962d2c9c54d01db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=M0UodecEjIuYocS%2BL1JFPHLAc%2FY%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/67e02a73351145adaf614404e22bb5ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=er8%2Buuuc9n4mBXMoE3GQN7M8Vjw%3D" alt="image.png" loading="lazy"/></p>
<h6 data-id="heading-1">对于cesium的一些初始工作，可在前几篇博客中自行参考，本文不做过多阐述；</h6>
<h4 data-id="heading-2"/>
<h3 data-id="heading-3">点、线、模型（及运动轨道）的添加</h3>
<p>在cesium官网文档<a href="https://link.juejin.cn?target=https%3A%2F%2Fcesium.com%2Flearn%2Fcesiumjs%2Fref-doc%2FEntity.html" title="https://cesium.com/learn/cesiumjs/ref-doc/Entity.html" target="_blank" ref="nofollow noopener noreferrer">cesium.com/learn/cesiu…</a>中可看到一些相关属性</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/240bd513779d4915a7a70c9c41eb6ad0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=tIVNzZj%2BzmtSvxLh4LJbeLJc%2BUM%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c317fba32fb4ae6aef13f0d38114553~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=ZlUvXkv3OMFYj28rokNvD8cWdCg%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cda7b82701234be78054c4b3c54bcbd4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=f%2BxJD9pgD%2FugSsC7dDZt%2F0dqqpI%3D" alt="image.png" loading="lazy"/></p>
<p>这里我们只取最常用的几个：</p>
<p><strong>点的添加：</strong></p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">viewer</span><span class="hljs-selector-class">.entities</span><span class="hljs-selector-class">.add</span>({
    name: '添加点',
    <span class="hljs-attribute">position</span>: Cesium.Cartesian3.<span class="hljs-built_in">fromDegrees</span>(lng, lat, <span class="hljs-attribute">height</span>), <span class="hljs-comment">//经、纬、高度</span>
    <span class="hljs-attribute">point</span>: {
        <span class="hljs-attribute">color</span>: new Cesium.<span class="hljs-built_in">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>), <span class="hljs-comment">// 颜色</span>
        <span class="hljs-attribute">pixelSize</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 大小</span>
        <span class="hljs-attribute">outlineColor</span>: Cesium.Color.RED, <span class="hljs-comment">// 轮廓颜色</span>
        <span class="hljs-attribute">outlineWidth</span>: <span class="hljs-number">5</span> <span class="hljs-comment">//轮廓宽度</span>
    }
})
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>线的添加：</strong></p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">//起始点</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">startPosition</span> = Cesium.Cartesian3.<span class="hljs-title function_ invoke__">fromDegrees</span>(lng, lat, height);
<span class="hljs-comment">//结束点</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">endPosition</span> = Cesium.Cartesian3.<span class="hljs-title function_ invoke__">fromDegrees</span>(lng, lat, height);


viewer.entities.<span class="hljs-title function_ invoke__">add</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'添加线'</span>,
    <span class="hljs-attr">polyline</span>: {
        <span class="hljs-attr">positions</span>: Cesium.Cartesian3.<span class="hljs-title function_ invoke__">fromDegreesArray</span>([startPosition, endPosition]),
        <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">material</span>: Cesium.Color.RED,
    }
})
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>模型的添加：</strong></p>
<pre><code class="hljs language-php" lang="php"> shipEntity.value = viewer.entities.<span class="hljs-title function_ invoke__">add</span>({
    <span class="hljs-attr">id</span>: <span class="hljs-string">"shipEntity"</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"shipEntity"</span>,
    <span class="hljs-attr">position</span>: Cesium.Cartesian3.<span class="hljs-title function_ invoke__">fromDegrees</span>(<span class="hljs-number">122.35782164573101</span>, <span class="hljs-number">34.12</span>, <span class="hljs-number">100</span>),
    <span class="hljs-attr">model</span>: {
      <span class="hljs-attr">uri</span>: <span class="hljs-string">'/data/model/hwj.gltf'</span>, //模型相对路径  放在<span class="hljs-keyword">public</span>目录下
      <span class="hljs-attr">minimumPixelSize</span>: <span class="hljs-number">100</span>,
      <span class="hljs-attr">maximumScale</span>: <span class="hljs-number">20000</span>,
    },
    <span class="hljs-attr">properties</span>: {         //属性存放
      <span class="hljs-attr">name</span>: <span class="hljs-string">"test-name"</span>,
      <span class="hljs-attr">description</span>: <span class="hljs-string">"test-desc"</span>
    }
  })

  shipEntity2.value = viewer.entities.<span class="hljs-title function_ invoke__">add</span>({
    <span class="hljs-attr">id</span>: <span class="hljs-string">"shipEntity2"</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"shipEntity2"</span>,
    <span class="hljs-attr">position</span>: Cesium.Cartesian3.<span class="hljs-title function_ invoke__">fromDegrees</span>(<span class="hljs-number">122.35782164573101</span>, <span class="hljs-number">34.9</span>, <span class="hljs-number">100</span>),
    <span class="hljs-attr">model</span>: {
      <span class="hljs-attr">uri</span>: <span class="hljs-string">'/data/model/hm.gltf'</span>, //模型相对路径  放在<span class="hljs-keyword">public</span>目录下
      <span class="hljs-attr">minimumPixelSize</span>: <span class="hljs-number">100</span>,
      <span class="hljs-attr">maximumScale</span>: <span class="hljs-number">20000</span>,
    },
    <span class="hljs-attr">properties</span>: {        //属性存放
      <span class="hljs-attr">name</span>: <span class="hljs-string">"test-name"</span>,
      <span class="hljs-attr">description</span>: <span class="hljs-string">"test-desc"</span>
    }
  })
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>飞行路线及飞行模型添加</strong></p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">createAirplane</span> = () =&gt; {
  if (!window.viewer || airplaneEntity.value) return<span class="hljs-comment">;</span>

  // 初始化时间
  <span class="hljs-attr">startTime.value</span> = Cesium.JulianDate.fromDate(new Date())<span class="hljs-comment">;</span>
  <span class="hljs-attr">stopTime.value</span> = Cesium.JulianDate.addSeconds(startTime.value, <span class="hljs-number">360</span>, new Cesium.JulianDate())<span class="hljs-comment">;</span>

  // 设置时钟
  <span class="hljs-attr">window.viewer.clock.startTime</span> = startTime.value.clone()<span class="hljs-comment">;</span>
  <span class="hljs-attr">window.viewer.clock.currentTime</span> = startTime.value.clone()<span class="hljs-comment">;</span>
  <span class="hljs-attr">window.viewer.clock.stopTime</span> = stopTime.value.clone()<span class="hljs-comment">;</span>
  <span class="hljs-attr">window.viewer.clock.multiplier</span> = <span class="hljs-number">5</span><span class="hljs-comment">;</span>
  window.viewer.timeline.zoomTo(startTime.value, stopTime.value)<span class="hljs-comment">;</span>
  <span class="hljs-attr">window.viewer.clock.clockRange</span> = Cesium.ClockRange.LOOP_STOP<span class="hljs-comment">;</span>

  // 计算飞行路线
  const <span class="hljs-attr">property</span> = computeFlyRoute()<span class="hljs-comment">;</span>
  const <span class="hljs-attr">orientation</span> = new Cesium.VelocityOrientationProperty(property)<span class="hljs-comment">;</span>

  // 设置视角偏移
  const <span class="hljs-attr">viewFrom</span> = new Cesium.Cartesian3()<span class="hljs-comment">;</span>
  <span class="hljs-attr">viewFrom.z</span> = <span class="hljs-number">1466.61814287398</span><span class="hljs-comment">;</span>
  <span class="hljs-attr">viewFrom.x</span> = -<span class="hljs-number">3306.272590514738</span><span class="hljs-comment">;</span>
  <span class="hljs-attr">viewFrom.y</span> = <span class="hljs-number">135.03403439279646</span><span class="hljs-comment">;</span>

  // 创建飞机实体
  <span class="hljs-attr">airplaneEntity.value</span> = window.viewer.entities.add({
    name: 'airplane',
    availability: new Cesium.TimeIntervalCollection(<span class="hljs-section">[
      new Cesium.TimeInterval({
        start: startTime.value,
        stop: stopTime.value
      })
    ]</span>),
    position: property,
    orientation: orientation,
    viewFrom: viewFrom,
    model: {
      uri: '/data/model/feiji.glb',
      minimumPixelSize: 100,
      maximumScale: 2000,
    },
    path: {
      resolution: 1,
      material: new Cesium.PolylineGlowMaterialProperty({
        glowPower: 0.1,
        color: Cesium.Color.GREEN.withAlpha(1),
      }),
      width: 9,
    },
  })<span class="hljs-comment">;</span>
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>测试文件数据：</strong></p>
<p>这里创建一个json文件（包含点和线）</p>
<p>测试数据如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dad7d1c9fcc44a849c17c53fae07e8f7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=2dFOUWRZEcswdH%2F7HmCnOsHKtus%3D" alt="image.png" loading="lazy"/></p>
<p><strong>点线整合代码：</strong></p>
<pre><code class="hljs language-ini" lang="ini">/**
 * 创建边的数据源（提取的独立函数）
 * @param {Object} viewer - Cesium 实例
 * @param {Array} nodes - 节点数据
 * @param {Array} edges - 边数据
 * @param {String} dataSourceName - 数据源名称
 * @param {Boolean} clampToGround - 是否贴合地面
 * @param {String} color - 线条颜色
 */
const <span class="hljs-attr">createEdgesDataSource</span> = function (viewer, nodes = [], edges = [], dataSourceName = <span class="hljs-string">'edgesDataSource'</span>, clampToGround = <span class="hljs-literal">true</span>, color = null) {
    // 查找是否已存在同名的数据源
    let <span class="hljs-attr">dataSource</span> = viewer.dataSources.getByName(dataSourceName)<span class="hljs-comment">;</span>

    if (<span class="hljs-attr">dataSource.length</span> === <span class="hljs-number">0</span>) {
        // 创建新的数据源
        <span class="hljs-attr">dataSource</span> = new Cesium.CustomDataSource(dataSourceName)<span class="hljs-comment">;</span>
        viewer.dataSources.add(dataSource)<span class="hljs-comment">;</span>
    } else {
        <span class="hljs-attr">dataSource</span> = dataSource[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
    }

    // 清空现有实体
    dataSource.entities.removeAll()<span class="hljs-comment">;</span>

    // 创建边（连接线）- 使用优化后的逻辑
    if (edges &amp;&amp; edges.length &gt; 0) {
        edges.forEach((item, index) =&gt; {
            const <span class="hljs-attr">lineArr</span> = []<span class="hljs-comment">;</span>

            // 查找源节点和目标节点的坐标
            for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; nodes.length; i++) {</span>
                const <span class="hljs-attr">node</span> = nodes[i]<span class="hljs-comment">;</span>
                const <span class="hljs-attr">hasCoordinates</span> = (node.hasOwnProperty(<span class="hljs-string">'longitude'</span>) &amp;&amp; node.hasOwnProperty(<span class="hljs-string">'latitude'</span>)) ||
                    (node.hasOwnProperty('经度') &amp;&amp; node.hasOwnProperty('纬度'))<span class="hljs-comment">;</span>

                if (hasCoordinates) {
                    if (<span class="hljs-attr">item.source</span> == node.id) {
                        const <span class="hljs-attr">lng</span> = node[<span class="hljs-string">'经度'</span>] !== undefined ? node[<span class="hljs-string">'经度'</span>] : node.longitude<span class="hljs-comment">;</span>
                        const <span class="hljs-attr">lat</span> = node[<span class="hljs-string">'纬度'</span>] !== undefined ? node[<span class="hljs-string">'纬度'</span>] : node.latitude<span class="hljs-comment">;</span>
                        const <span class="hljs-attr">height</span> = node[<span class="hljs-string">'高度'</span>] !== undefined ? node[<span class="hljs-string">'高度'</span>] : (node.height || <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>

                        lineArr.push(lng || 0, lat || 0, height || 0)<span class="hljs-comment">;</span>
                    }

                    if (<span class="hljs-attr">item.target</span> == node.id) {
                        const <span class="hljs-attr">lng</span> = node[<span class="hljs-string">'经度'</span>] !== undefined ? node[<span class="hljs-string">'经度'</span>] : node.longitude<span class="hljs-comment">;</span>
                        const <span class="hljs-attr">lat</span> = node[<span class="hljs-string">'纬度'</span>] !== undefined ? node[<span class="hljs-string">'纬度'</span>] : node.latitude<span class="hljs-comment">;</span>
                        const <span class="hljs-attr">height</span> = node[<span class="hljs-string">'高度'</span>] !== undefined ? node[<span class="hljs-string">'高度'</span>] : (node.height || <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>

                        lineArr.push(lng || 0, lat || 0, height || 0)<span class="hljs-comment">;</span>
                    }
                }
            }

            // 如果成功获取了两个点的坐标，创建连线
            if (<span class="hljs-attr">lineArr.length</span> === <span class="hljs-number">6</span>) { // 两个点，每个点有<span class="hljs-number">3</span>个坐标值
                const <span class="hljs-attr">startPosition</span> = Cesium.Cartesian3.fromDegrees(lineArr[<span class="hljs-number">0</span>], lineArr[<span class="hljs-number">1</span>], lineArr[<span class="hljs-number">2</span>])<span class="hljs-comment">;</span>
                const <span class="hljs-attr">endPosition</span> = Cesium.Cartesian3.fromDegrees(lineArr[<span class="hljs-number">3</span>], lineArr[<span class="hljs-number">4</span>], lineArr[<span class="hljs-number">5</span>])<span class="hljs-comment">;</span>

                let <span class="hljs-attr">polylineColor</span> = Cesium.Color.YELLOW<span class="hljs-comment">;</span>
                if (color) {
                    <span class="hljs-attr">polylineColor</span> = Cesium.Color.fromCssColorString(color)<span class="hljs-comment">;</span>
                } else if (item.color) {
                    <span class="hljs-attr">polylineColor</span> = Cesium.Color.fromCssColorString(item.color)<span class="hljs-comment">;</span>
                }

                dataSource.entities.add({
                    id: `edge_${item.source}_${item.target}_${index}`,
                    name: item.name || '连接线',
                    polyline: {
                        positions: <span class="hljs-section">[startPosition, endPosition]</span>,
                        width: item.width || 7,
                        material: new Cesium.PolylineArrowMaterialProperty(polylineColor),
                        clampToGround: item.clampToGround !== undefined ? item.clampToGround : clampToGround,
                        arcType: Cesium.ArcType.GEODESIC
                    }
                })<span class="hljs-comment">;</span>
            } else {
                console.warn(`无法创建边: 节点 ${item.source} 或 ${item.target} 的坐标不完整`)<span class="hljs-comment">;</span>
            }
        })<span class="hljs-comment">;</span>
    }

    return dataSource<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

/**
 * Cesium 加载点的方法（改进版，贴合地球表面）
 * viewer: cesium实例
 * array: 节点数据需要id，经纬度
 * dataSourceName: 数据源名称，用于统一管理
 * edges: 边数据，包含连接的节点id
 * clampToGround: 是否贴合地面，默认为true
 */
const <span class="hljs-attr">createNodesDataSource</span> = function (viewer, nodes = [], height = <span class="hljs-number">0</span>, dataSourceName = <span class="hljs-string">'nodesDataSource'</span>, clampToGround = <span class="hljs-literal">true</span>) {
    // 查找是否已存在同名的数据源
    let <span class="hljs-attr">dataSource</span> = viewer.dataSources.getByName(dataSourceName)<span class="hljs-comment">;</span>

    if (<span class="hljs-attr">dataSource.length</span> === <span class="hljs-number">0</span>) {
        // 创建新的数据源
        <span class="hljs-attr">dataSource</span> = new Cesium.CustomDataSource(dataSourceName)<span class="hljs-comment">;</span>
        viewer.dataSources.add(dataSource)<span class="hljs-comment">;</span>
    } else {
        <span class="hljs-attr">dataSource</span> = dataSource[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
    }

    // 清空现有实体
    dataSource.entities.removeAll()<span class="hljs-comment">;</span>

    // 存储节点位置，用于边的连接
    const <span class="hljs-attr">nodePositions</span> = {}<span class="hljs-comment">;</span>

    // 创建节点
    nodes.forEach((item) =&gt; {
        // 使用地形高度采样获取准确的地面高度
        const <span class="hljs-attr">longitude</span> = item.经度 !== undefined ? item.经度 : item.longitude<span class="hljs-comment">;</span>
        const <span class="hljs-attr">latitude</span> = item.纬度 !== undefined ? item.纬度 : item.latitude<span class="hljs-comment">;</span>

        const <span class="hljs-attr">cartographicPosition</span> = Cesium.Cartographic.fromDegrees(longitude, latitude)<span class="hljs-comment">;</span>
        const <span class="hljs-attr">sampledHeight</span> = viewer.scene.globe.getHeight(cartographicPosition) || <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        const <span class="hljs-attr">finalHeight</span> = clampToGround ? sampledHeight + (height || <span class="hljs-number">0</span>) : height<span class="hljs-comment">;</span>

        const <span class="hljs-attr">position</span> = Cesium.Cartesian3.fromDegrees(longitude, latitude, finalHeight)<span class="hljs-comment">;</span>
        nodePositions<span class="hljs-section">[item.id]</span> = position<span class="hljs-comment">;</span>

        dataSource.entities.add({
            id: item.id,
            name: item.name,
            position: position,
            point: {
                pixelSize: 20,
                color: new Cesium.Color(1, 1, 0, 1),
                heightReference: clampToGround ? Cesium.HeightReference.CLAMP_TO_GROUND : Cesium.HeightReference.NONE
            },
            label: {
                text: item.name || '暂无名称',
                font: '10px',
                fillColor: Cesium.Color.WHITE,
                backgroundColor: Cesium.Color.SKYBLUE,
                showBackground: false,
                outlineWidth: 2,
                pixelOffset: new Cesium.Cartesian2(1, -34),
                verticalOrigin: Cesium.VerticalOrigin.TOP,
                horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                heightReference: clampToGround ? Cesium.HeightReference.CLAMP_TO_GROUND : Cesium.HeightReference.NONE
            },
        })<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
    

    return dataSource<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-4">效果如下：</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad162452a30a4285868c8335162af5a0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=vZE89OGu2ReXNmoVi%2BCj3JIlwEY%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/68a13fafbe06495488e298cc3f8c965e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=P38nJjBBsPutLVK7K6Jm8Fil9M4%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-5">指北针添加</h3>
<p>可参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fcesium-navigation-es6" title="https://www.npmjs.com/package/cesium-navigation-es6" target="_blank" ref="nofollow noopener noreferrer">www.npmjs.com/package/ces…</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a262770ec12745078928d3bab4834009~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=EWL%2FWqVDaczj%2B2QkO0PRrK%2F8gUg%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/20b6f66500104e38b885f374eb0c533d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=PH3lGdYogoOYwAwwafgkYBY7hTY%3D" alt="image.png" loading="lazy"/></p>
<pre><code class="hljs language-css" lang="css">npm install cesium-navigation-es6 <span class="hljs-attr">--save</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<pre><code class="hljs language-ini" lang="ini">import {  Viewer,Rectangle} from "cesium"<span class="hljs-comment">;</span>
import 'cesium/Build/Cesium/Widgets/widgets.css'<span class="hljs-comment">;</span>
import CesiumNavigation from "cesium-navigation-es6"<span class="hljs-comment">;</span>

const <span class="hljs-attr">viewer</span> = new Viewer(<span class="hljs-string">"cesiumContainer"</span>,{
    animation:false,
    timeline:false
})<span class="hljs-comment">;</span>

const <span class="hljs-attr">options</span> = {}<span class="hljs-comment">;</span>
// 用于在使用重置导航重置地图视图时设置默认视图控制。接受的值是Cesium.Cartographic 和 Cesium.Rectangle.
// <span class="hljs-attr">options.defaultResetView</span> = Rectangle.fromDegrees(<span class="hljs-number">80</span>, <span class="hljs-number">22</span>, <span class="hljs-number">130</span>, <span class="hljs-number">50</span>)
<span class="hljs-attr">options.defaultResetView</span> = new Cartographic(CesiumMath.toRadians(<span class="hljs-number">111.50623801848565</span>), CesiumMath.toRadians(<span class="hljs-number">2.8997206760441205</span>), <span class="hljs-number">8213979.400955964</span>)
//相机方向
<span class="hljs-attr">options.orientation</span> = {
    heading: CesiumMath.toRadians(350.94452087411315),
    pitch: CesiumMath.toRadians(-66.6402342251215),
    roll: CesiumMath.toRadians(360)
}
//相机延时
<span class="hljs-attr">options.duration</span> = <span class="hljs-number">4</span>//默认为<span class="hljs-number">3</span>s

// 用于启用或禁用罗盘。true是启用罗盘，false是禁用罗盘。默认值为true。如果将选项设置为false，则罗盘将不会添加到地图中。
<span class="hljs-attr">options.enableCompass</span>= <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
// 用于启用或禁用缩放控件。true是启用，false是禁用。默认值为true。如果将选项设置为false，则缩放控件将不会添加到地图中。
<span class="hljs-attr">options.enableZoomControls</span>= <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
// 用于启用或禁用距离图例。true是启用，false是禁用。默认值为true。如果将选项设置为false，距离图例将不会添加到地图中。
<span class="hljs-attr">options.enableDistanceLegend</span>= <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
// 用于启用或禁用指南针外环。true是启用，false是禁用。默认值为true。如果将选项设置为false，则该环将可见但无效。
<span class="hljs-attr">options.enableCompassOuterRing</span>= <span class="hljs-literal">true</span><span class="hljs-comment">;</span>

//修改重置视图的tooltip
<span class="hljs-attr">options.resetTooltip</span> = <span class="hljs-string">"重置视图"</span><span class="hljs-comment">;</span>
//修改放大按钮的tooltip
<span class="hljs-attr">options.zoomInTooltip</span> = <span class="hljs-string">"放大"</span><span class="hljs-comment">;</span>
//修改缩小按钮的tooltip
<span class="hljs-attr">options.zoomOutTooltip</span> = <span class="hljs-string">"缩小"</span><span class="hljs-comment">;</span>

//如需自定义罗盘控件，请看下面的自定义罗盘控件
new CesiumNavigation(viewer, options)<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-6"/>
<h3 data-id="heading-7">CZML文件加载</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ace7558ccfd44ad92af9d26cf5eb8ab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGFybGVu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966104&amp;x-signature=qPReb25bk1dUp1XMxN1USvFS7Qo%3D" alt="image.png" loading="lazy"/></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">entitiesCzmlInit</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">//测试文件路径</span>
  <span class="hljs-keyword">let</span> czmlFiles = [<span class="hljs-string">`1`</span>, <span class="hljs-string">`2`</span>, <span class="hljs-string">`3`</span>, <span class="hljs-string">`4`</span>,<span class="hljs-string">`5`</span>,<span class="hljs-string">`6`</span>,<span class="hljs-string">'7'</span>,<span class="hljs-string">`8`</span>, <span class="hljs-string">`9`</span>, <span class="hljs-string">`10`</span>, <span class="hljs-string">`11`</span>,<span class="hljs-string">`12`</span>,<span class="hljs-string">`13`</span>,<span class="hljs-string">'14'</span>,<span class="hljs-string">`15`</span>, <span class="hljs-string">`16`</span>, <span class="hljs-string">`17`</span>, <span class="hljs-string">`18`</span>,<span class="hljs-string">`19`</span>,<span class="hljs-string">`20`</span>,<span class="hljs-string">'21'</span>,<span class="hljs-string">`22`</span>, <span class="hljs-string">`23`</span>, <span class="hljs-string">`24`</span>, <span class="hljs-string">`25`</span>,<span class="hljs-string">`26`</span>];
  <span class="hljs-comment">// 测试</span>
  czmlFiles.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {
    viewer.<span class="hljs-property">dataSources</span>.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Cesium</span>.<span class="hljs-property">CzmlDataSource</span>.<span class="hljs-title function_">load</span>(<span class="hljs-string">`/czmlFile/<span class="hljs-subst">${file}</span>.czml`</span>));
  });
};

<span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">Ion</span>.<span class="hljs-property">defaultAccessToken</span> =
    <span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyYTNkYjhhNC04NDQ4LTRiMDItYTg4OS03YWU3ZWVjNjBiNTgiLCJpZCI6ODYyMDMsImlhdCI6MTY4MTM3ODA5M30.M1tBPd6f5Of1l2ElUqecFjv9GcZ-Ntcwm2iain-fvkk"</span>;
  <span class="hljs-keyword">const</span> viewer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Viewer</span>(<span class="hljs-string">"cesiumContainer"</span>, {
    <span class="hljs-attr">infoBox</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">animation</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否显示动画控件</span>
    <span class="hljs-attr">homeButton</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否显示home键</span>
    <span class="hljs-attr">geocoder</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否显示地名查找控件</span>
    <span class="hljs-attr">baseLayerPicker</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否显示图层选择控件</span>
    <span class="hljs-attr">timeline</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否显示时间线控件</span>
    <span class="hljs-attr">fullscreenButton</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否全屏显示</span>
    <span class="hljs-attr">infoBox</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否显示点击要素之后显示的信息</span>
    <span class="hljs-attr">sceneModePicker</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否显示投影方式控件  三维/二维</span>
    <span class="hljs-attr">navigationInstructionsInitiallyVisible</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">navigationHelpButton</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否显示帮助信息控件</span>
    <span class="hljs-attr">orderIndependentTranslucency</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">shouldAnimate</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">scene3DOnly</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 每个几何实例将只能以3D渲染以节省GPU内存</span>
    <span class="hljs-attr">selectionIndicator</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 取消点击有绿框</span>
    <span class="hljs-comment">// imageryProvider: false, // 不提供地图</span>
    <span class="hljs-attr">baseLayerPicker</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否显示图层选择控件</span>
    <span class="hljs-attr">sceneMode</span>: <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">SceneMode</span>.<span class="hljs-property">SCENE3D</span>, <span class="hljs-comment">// 设置场景为3D模式</span>
  });
 
  <span class="hljs-comment">// 设置开始时间</span>
  viewer.<span class="hljs-property">clock</span>.<span class="hljs-property">startTime</span> = <span class="hljs-title class_">Cesium</span>.<span class="hljs-property">JulianDate</span>.<span class="hljs-title function_">fromDate</span>(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2024</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">30</span>)
  ); <span class="hljs-comment">// 设置为2024年10月10日 08:30</span>
  <span class="hljs-comment">// 控制播放状态</span>
  <span class="hljs-comment">// viewer.clock.shouldAnimate = true;  // 启用动画（时间流动）</span>
  <span class="hljs-comment">//设置版权等信息不显示</span>
  viewer.<span class="hljs-property">_cesiumWidget</span>.<span class="hljs-property">_creditContainer</span>.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">"none"</span>;


  cesiumViewer.<span class="hljs-property">value</span> = viewer;
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">viewer</span> = viewer;
  
  
  <span class="hljs-title function_">entitiesCzmlInit</span>();
});
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>声明：</strong></p>
<p><strong>本数据的发布仅为技术演示和学习目的，不对使用本数据引发的任何误用或误解负责。</strong></p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[scala中trait基本使用]]></title>    <link>https://juejin.cn/post/7573310642959581222</link>    <guid>https://juejin.cn/post/7573310642959581222</guid>    <pubDate>2025-11-17T07:30:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573310642959581222" data-draft-id="7573192460869877770" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="scala中trait基本使用"/> <meta itemprop="keywords" content="Scala"/> <meta itemprop="datePublished" content="2025-11-17T07:30:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="零碎岛11"/> <meta itemprop="url" content="https://juejin.cn/user/863580330146204"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            scala中trait基本使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/863580330146204/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    零碎岛11
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T07:30:14.000Z" title="Mon Nov 17 2025 07:30:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0">（一）trait定义和作用</h4>
<p><strong>[讲]</strong> Scala没有Java中接口的概念，所以Scala的trait就类比Java中的接口。Scala的特质定义如下：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">identified </span></span>{  
    属性； 方法

}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/63e33f1186514afcb28f3a9c0afd468d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zu256KO5bKbMTE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969414&amp;x-signature=2Ng%2FGsviQYTYzbjLCHFxgwUG2ow%3D" alt="屏幕截图 2025-11-17 152748.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6bf649338b79442bacf397c8b21128d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zu256KO5bKbMTE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969414&amp;x-signature=%2FVmE%2F6KbuUzxQdsQY2TLqZHj11Q%3D" alt="屏幕截图 2025-11-17 152753.png" loading="lazy"/></p>
<p>trait是关键字，identified 表示一个合法的标记。</p>
<h4 data-id="heading-1">（二）实现单个特质</h4>
<p>[码] 用一个类去实现单个特质</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-keyword">package</span> level02

<span class="hljs-comment">/*
 * 特质
 * trait: 实现多继承
 **/</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">class16</span> </span>{

  <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">BeautifulEye</span> </span>{
    <span class="hljs-keyword">val</span> eye: <span class="hljs-type">String</span> = <span class="hljs-string">"眼睛漂亮"</span>
  }

  <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Tall</span> </span>{
    <span class="hljs-keyword">val</span> height: <span class="hljs-type">String</span> = <span class="hljs-string">"大高个"</span>
  }

  <span class="hljs-comment">// 继承 with</span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeautifulEye</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Tall</span> </span>{
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = {
    <span class="hljs-keyword">val</span> child = <span class="hljs-keyword">new</span> <span class="hljs-type">Child</span>()
    println(child.eye)
    println(child.height)
  }
}
</code></pre>
<h4 data-id="heading-2">（三）实现多个特质</h4>
<p>格式：<strong>类名 extends 特质1 with 特质2 with 特质3</strong>  其中多个特质的顺序可以交换。</p>
<p>【代码示范】</p>
<p>定义两个特质，使用一个类来实现他们。</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-keyword">package</span> level02

<span class="hljs-comment">/*
 * 特质
 * trait: 实现多继承
 **/</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">class16</span> </span>{

  <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">BeautifulEye</span> </span>{
    <span class="hljs-keyword">val</span> eye: <span class="hljs-type">String</span> = <span class="hljs-string">"眼睛漂亮"</span>  <span class="hljs-comment">// 具体属性</span>
    <span class="hljs-keyword">val</span> name:<span class="hljs-type">String</span>  <span class="hljs-comment">// 抽象属性</span>
  }

  <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Tall</span> </span>{
    <span class="hljs-keyword">val</span> height: <span class="hljs-type">String</span> = <span class="hljs-string">"大高个"</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>():<span class="hljs-type">Unit</span>={
      println(<span class="hljs-string">"run......"</span>)
    }
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span></span>():<span class="hljs-type">Unit</span>
  }

  <span class="hljs-comment">// 继承 with</span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeautifulEye</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Tall</span> </span>{
    <span class="hljs-keyword">val</span> name :<span class="hljs-type">String</span>=<span class="hljs-string">"小花"</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jump</span></span>():<span class="hljs-type">Unit</span>={
      println(<span class="hljs-string">s"<span class="hljs-subst">${name}</span>,jump......."</span>)
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = {
    <span class="hljs-keyword">val</span> child = <span class="hljs-keyword">new</span> <span class="hljs-type">Child</span>()
    println(child.eye)
    println(child.height)
    child.run()
    child.jump()
  }
}
</code></pre>
<p>结果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94f6873833b547259c17183ddaa1ac5b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zu256KO5bKbMTE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969414&amp;x-signature=1wRLCxdDBFSynCao%2B%2F8tLVVzzKM%3D" alt="屏幕截图 2025-11-17 152703.png" loading="lazy"/></p>
<h4 data-id="heading-3">（四）特质成员的处理方式</h4>
<p>一个类继承了一个特质之后，如何处理它的属性和方法呢？</p>
<p>分成四种情况：</p>
<p>1.特质中的抽象属性：可以通过val或var修饰来重写</p>
<p>2.特质中的抽象方法：一定要实现方法体。</p>
<p>3.特质中的具体属性：重写var不需override和var，只需要属性名即可；重写val需要加上override关键字。</p>
<p>4.特质中的具体方法：使用override重写，且保持名称，参数，返回值一致。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[React常见hooks及运用场景梳理（一）——useState、useEffect]]></title>    <link>https://juejin.cn/post/7573192460870385674</link>    <guid>https://juejin.cn/post/7573192460870385674</guid>    <pubDate>2025-11-17T07:52:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573192460870385674" data-draft-id="7572757056439025673" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="React常见hooks及运用场景梳理（一）——useState、useEffect"/> <meta itemprop="keywords" content="React.js"/> <meta itemprop="datePublished" content="2025-11-17T07:52:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Jseeza"/> <meta itemprop="url" content="https://juejin.cn/user/2601912558697392"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            React常见hooks及运用场景梳理（一）——useState、useEffect
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2601912558697392/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Jseeza
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T07:52:53.000Z" title="Mon Nov 17 2025 07:52:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文用于梳理React开发中使用较多的hooks。</p>
<p>仅作为入门快速了解hooks从而开发所用，不涉及很多原理性的东西。</p>
<p>这次先讲<code>useState</code>和<code>useEffect</code>。</p>
<h2 data-id="heading-0">一、useState</h2>
<p>useState：用于管理组件内部状态，是React开发中最常用的hook，可以让函数组件拥有内部可更新的状态（对比纯js开发，就是用class的this.state）。</p>
<h3 data-id="heading-1">1.1 什么是状态</h3>
<p>虽然看起来很像无关的话题，但是在理解useState的时候，很有必要去理解一下state（状态），从而帮助我们更好地理解<code>useState</code>的实现机制和React的渲染逻辑。</p>
<p>在React中，state是一个非常核心的概念，可以理解为，state驱动页面变化：只要state改变，React就会自动重新渲染界面。</p>
<p>看起来似乎一般场景也能做到，但让我们设想一下：假设有一个上下翻页的组件，你点击了下一页，state发生了变化，在React中，每当state发生了变化，React就会重新调用组件函数，组件函数中的代码会从头执行，因此普通变量会重新初始化。</p>
<p>很显然，这是不符合实际运用的，因为一般的变量在组件重新渲染了之后，记录翻页的一般变量也被恢复到初始状态了。</p>
<p>以下是上述示例的代码，在我们狂点下一页的时候，页面始终只能看到初始化的index=0：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">index</span>) =&gt; {
    index = index + <span class="hljs-number">1</span>;
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>下一页<span class="hljs-tag">&lt;/<span class="hljs-name">abutton</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>index={index}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
</code></pre>
<p>所以，我们需要引入<code>useState</code>，记住需要被记住的state，防止被初始化。<code>useState</code>返回的值并不是局部变量，而是React在内部保存的一个状态单元，被记住的state在渲染之间不会丢失。
也就是这样：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [index, setIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">setIndex</span>(index + <span class="hljs-number">1</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>下一页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>index={index}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
</code></pre>
<p>现在在我们狂戳的时候，就会发现index也随之变化了，显然，<code>useState</code>帮助组件记住了我们想要的状态。</p>
<p>强调：state不是普通的局部变量，普通变量存储在函数的执行上下文里，而state存储在React的内部数据结构中（Fiber），它独立于组件函数的执行，下面会再次提到这个，可以这么理解：</p>
<ul>
<li>普通变量=每次渲染都会重新生成。</li>
<li>state=React管理，在渲染之间保持不变。</li>
</ul>
<h3 data-id="heading-2">1.2 useState的实现机制是什么呢</h3>
<p>上一节我们在讲述state时，已经初步引入了<code>useState</code>。让我们参考一下官方的说法：<code>useState</code>是一个React Hook，它允许你向组件添加一个状态变量。</p>
<p><code>useState</code>本质上做了三件事情：</p>
<ol>
<li>分配一个“状态单元”来存储数据</li>
<li>按调用顺序记录这个state单元的位置</li>
<li>在调用setState时触发组件重新渲染</li>
</ol>
<h4 data-id="heading-3">1.2.1 React如何保存state——“状态单元”</h4>
<p>函数组件本身只是一个普通函数，函数执行完了，一般来说，内部的局部变量就会销毁，这是由函数执行的生命周期决定的。
但是下述函数的count不会丢：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">demo</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p>为什么呢？</p>
<p>因为：<strong>React把state存在组件对应的Fiber节点中，而不是函数内部。</strong>
我们可以抽象理解一下，一个组件可能有多个state，React对这些state私下维护一个作用域高于组件的数组（Fiber），里面存放这些state。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> [a, setA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// state[0]</span>
<span class="hljs-keyword">const</span> [b, setB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// state[1]</span>
<span class="hljs-keyword">const</span> [c, setC] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// state[2]</span>
</code></pre>
<p>React内部对上述会存在一个这样的数组：</p>
<pre><code class="hljs language-cpp" lang="cpp">fiber.state = [
  { memoizedState: <span class="hljs-number">1</span> }, <span class="hljs-comment">// a</span>
  { memoizedState: <span class="hljs-number">2</span> }, <span class="hljs-comment">// b</span>
  { memoizedState: <span class="hljs-number">3</span> }, <span class="hljs-comment">// c</span>
]
</code></pre>
<p>这个数组的作用域范围高于函数组件，所以state在渲染时不会消失。</p>
<h4 data-id="heading-4">1.2.2 React如何知道每个state对应哪个useState——“按顺序记录与调用”</h4>
<p>React规定：</p>
<ul>
<li>首次渲染时，按照遇到的<code>useState</code>顺序，依次将对应的state存放在state数组中</li>
<li>接下来渲染时，根据遇到的<code>useState</code>顺序，依次将对应的state从state数组中取出。</li>
</ul>
<p>这里有严格的调用顺序，<strong>React根据“调用顺序”匹配state，state的顺序决定一切</strong>。</p>
<p>因此，这里也会引出一个“老生常谈”的问题：为什么<code>useState</code>不能写在if里面——因为顺序会乱。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">if</span> (someCondition) {
  <span class="hljs-keyword">const</span> [a, setA] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 有时候执行，有时候不执行</span>
}
<span class="hljs-keyword">const</span> [b, setB] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>);
</code></pre>
<p>这种写法就是错误的：因为someCondition影响a的执行，从而导致b的顺序发生改变。</p>
<blockquote>
<p>someCondition为true: state[0] = a, state[1] = b
someCondition为false: state[0] = b</p>
</blockquote>
<p>someCondition的执行与否导致初始化与后续渲染时a可能存在可能不存在，只有初始化时是存state，后续是取state，b的位置会发生错位，React无法精准匹配到b对应的state，从而报错。</p>
<h4 data-id="heading-5">1.2.3 setState如何触发更新</h4>
<p>setState触发更新本质在做两件事情：</p>
<ol>
<li>向state对应的队列里push一次更新（Update）</li>
<li>标记当前的Fiber需要重新渲染，并触发更新</li>
</ol>
<p>翻译成人话就是：把state的新值记录下来，并通知React重新渲染组件。这样当下一次渲染发生时：</p>
<ol>
<li>React按顺序再次执行useState</li>
<li>发现对应的state有更新</li>
<li>更新并返回新的state</li>
</ol>
<h4 data-id="heading-6">1.2.4 补充：一些遇到的疑难杂症</h4>
<h5 data-id="heading-7">1. 为什么React的state更新是“异步”的</h5>
<p>不是因为setState真的是异步操作，而是因为React会把多个state更新合并批处理：在一次事件循环中，React会收集所有的setState，最后统一重新渲染组件，从而提高性能。</p>
<p>在React18后，React在更多场景下（Promise、定时器等）也会进行批处理，表现得更加异步。</p>
<h5 data-id="heading-8">2. 为什么我更新了状态，但是屏幕没有更新</h5>
<p>这是由React的内部机制（<code>Object.is</code>比较）决定的，React会比较新旧状态是否相同，如果下一个状态等于先前的状态，则React会忽略这次更新，这是一种默认的“浅比较”，从而避免频繁的更新，实现防抖的效果，如果想要解决这个问题，需要始终保证在状态中<strong>替换</strong>对象和数组，而不是对它们进行<strong>更改</strong>。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> [index, setIndex] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

<span class="hljs-comment">// 错误写法</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-title function_">setIndex</span>(index+<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span>
  <span class="hljs-title function_">setIndex</span>(index+<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span>
  <span class="hljs-title function_">setIndex</span>(index+<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span>
}

<span class="hljs-comment">// 正确写法</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-title function_">setIndex</span>(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> index + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span>
  <span class="hljs-title function_">setIndex</span>(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> index + <span class="hljs-number">1</span>); <span class="hljs-comment">// 2</span>
  <span class="hljs-title function_">setIndex</span>(<span class="hljs-function"><span class="hljs-params">index</span> =&gt;</span> index + <span class="hljs-number">1</span>); <span class="hljs-comment">// 3</span>
}
</code></pre>
<h5 data-id="heading-9">3. 为什么setState后，工作日志打印出来的还是旧值</h5>
<p>调用set函数不能改变运行中的代码的状态。因为状态表现就像一个快照，更新状态会使用新的状态值去请求另一个渲染，但是并不影响在已经运行的事件处理函数中的变量。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);  <span class="hljs-comment">// 0</span>
  
  <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);  <span class="hljs-comment">// 0</span>
  
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);  <span class="hljs-comment">// 0</span>
  }, <span class="hljs-number">5000</span>);
}
</code></pre>
<p>如果需要下一个状态，可以在将其传递给set函数之前保存在一个变量中：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> nextCount = count + <span class="hljs-number">1</span>;
  <span class="hljs-title function_">setCount</span>(nextCount);
  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 0</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nextCount); <span class="hljs-comment">// 1</span>
}
</code></pre>
<h2 data-id="heading-10">二、useEffect</h2>
<p>useEffect：用于实现组件与外部系统同步。</p>
<h2 data-id="heading-11">2.1 为什么要用useEffect</h2>
<blockquote>
<p>有些组件需要与外部系统同步。例如，你可能希望根据React state控制非React组件、建立服务器连接或当组件在页面显示时发送分析日志。Effect允许你在渲染结束后执行一些代码，以便将组件与React外部的某个系统相同步。</p>
</blockquote>
<p>以上话语摘自官方文档，我觉得有些拗口，但是其实翻译成大白话就是：组件已经渲染好了，但是在渲染好了后我还希望执行一些逻辑，这些逻辑不能写在渲染流程中，这个时候就可以使用<code>useEffect</code>来实现这些逻辑。</p>
<p>这部分逻辑我们称作副作用（Side Effect，和渲染UI无关但必须做的事情），常见的副作用有：</p>
<ul>
<li>发请求</li>
<li>订阅、监听事件</li>
<li>添加定时器</li>
<li>操作DOM</li>
<li>打日志</li>
<li>手动更新某些外部变量</li>
</ul>
<p>这些不能直接写在函数组件里面，因为组件会反复执行，但这些副作用不需要反复执行，比如不需要反复请求接口发送请求，反复执行可能会带来一些问题。</p>
<h3 data-id="heading-12">2.2 该如何使用useEffect</h3>
<p><code>useEffect</code>本质上只有一种格式：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 副作用</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 清理副作用</span>
  };
}, [deps]);
</code></pre>
<p>在上述代码中，deps数组存放执行<code>useEffect</code>的依赖，<code>useEffect</code>根据依赖数组判断是否需要执行副作用函数。</p>
<h4 data-id="heading-13">2.2.1 什么是依赖</h4>
<p>新手常见问题：什么是依赖？</p>
<p>一句话总结：用于告诉React哪些值必须变化时，这个effect需要执行，这就是<strong>依赖</strong>（dependency）。</p>
<p>没有依赖，会导致<code>useEffect</code>认为每次渲染都需要执行副作用函数，轻则带来糟糕的性能，重则影响页面逻辑。</p>
<p>怎么界定依赖，很简单，看effect内部“访问”到的state或者props，谁被访问，谁就是依赖。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);
}, [user.<span class="hljs-property">name</span>, age]);
</code></pre>
<p>effect访问了<code>user.name</code>和<code>age</code>，所以依赖数组就是这两个。</p>
<p>开发中要时刻注意依赖有没有写对，因为依赖的存在会影响<code>useEffect</code>的执行逻辑。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);
}, [user.<span class="hljs-property">name</span>]);
</code></pre>
<p>比如这样，依赖中没有写age，那么age的变化不会调用<code>useEffect</code>执行副作用函数，<code>useEffect</code>中的age也永远只是初始化的值。</p>
<p>如何保证依赖一定写对：记住依赖就是<code>useEffect</code>里面用的来自外界的东西，只要在effect中用到了需要从<code>useEffect</code>这个钩子之外的变量、state、props、函数等，就要把这些东西放在依赖数组中。</p>
<h4 data-id="heading-14">2.2.2 useEffect怎么用</h4>
<p>根据依赖数组，可以把<code>useEffect</code>分成三类使用。</p>
<h5 data-id="heading-15">1. 没有依赖数组</h5>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'每次渲染都执行'</span>);
});
</code></pre>
<p>没有依赖数组，那么<code>useEffect</code>在首次渲染和每次更新后都会执行。不过这种比较少，因为大部分逻辑不需要这么频繁的运行。</p>
<h5 data-id="heading-16">2. 依赖数组为空</h5>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'只在初始化的时候调用一下'</span>);
}, []);
</code></pre>
<p>依赖数组为空，那么只有在初始化的时候会执行一次<code>useEffect</code>，后续变化都不再执行，因为对比依赖数组发现变量不需要被依赖，当然因为依赖为空，所以<code>useEffect</code>中永远保持初始值的样子。</p>
<h5 data-id="heading-17">3. 有依赖数组</h5>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'count变了就调用一下'</span>);
}, [count]);
</code></pre>
<p>这种才是最常用的，根据count来调用<code>useEffect</code>，依赖变了则需要执行副作用函数。这种时候，就是依赖数组有啥，useEffect就根据依赖数组的内容是否变化判断要不要执行effect。</p>
<h5 data-id="heading-18">4. 给一个粗糙的demo</h5>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Demo</span>(<span class="hljs-params">{ count, age }</span>) {
  <span class="hljs-comment">// 无依赖数组</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"每次都执行"</span>);
  });

  <span class="hljs-comment">// 依赖数组为空</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"初始化时候执行一下"</span>);
  }, []);

  <span class="hljs-comment">// 依赖数组不为空</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"根据count执行一下"</span>);
  }, [count]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      被调用了{count}次，今年{age}岁
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> [age, setAge] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
  };

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAge</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>count变一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleAge}</span>&gt;</span>age变一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Demo</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{count}</span> <span class="hljs-attr">age</span>=<span class="hljs-string">{age}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Demo</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
</code></pre>
<h3 data-id="heading-19">2.3 useEffect不是每次都需要的</h3>
<p>这里参考了官方文档。</p>
<blockquote>
<p>如果你<strong>没有打算与某个外部系统同步</strong>，那么你可能不需要Effect。</p>
</blockquote>
<p>人言翻译：<code>useEffect</code>不是用来做所有逻辑的，只是用来做“渲染之外”的事情。这里的外界系统，指无法通过只依赖React内部（state、props）和渲染自动完成。</p>
<p>useEffect是用来处理副作用的，但是很多人把本来是“渲染逻辑”的东西也写进了副作用中，导致了不必要的<code>useEffect</code>。</p>
<p>我们需要明白，<code>useEffect</code>≠业务逻辑&amp;计算逻辑</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">setTotal</span>(a + b);
}, [a, b]);
</code></pre>
<p>看起来这个的意思是，根据a、b是否变化判断要不要重新算total，但是这种写法是没必要的，state不需要你重新计算，当a、b变化时，UI自己就会更新。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> total = a + b;
</code></pre>
<p>写成这样就可以了，没有副作用就不要引入<code>useEffect</code>。</p>
<p>React渲染组件=执行函数，但是副作用不能写在渲染时执行的代码中，所以使用<code>useEffect</code>来延迟处理他们。</p>
<p>我遇到过的一个比较典型的例子是：一个页面需要从ctx中拿到某个机构的一些参数，这个ctx中的参数也是通过接口拿到的，并用这些参数来发送请求，由于我没有使用<code>useEffect</code>来保证在拿到参数后再发送请求，以及没有给页面留下差错处理，于是页面崩溃了。这里的正确做法是，在<code>useEffect</code>中发送请求，监听参数是否拿到了，拿到了再发请求。</p>
<h3 data-id="heading-20">2.4 useEffect闭包陷阱</h3>
<p><code>useEffect</code>闭包陷阱是React中常见的一个问题，特别在处理异步问题、事件监听或者计时器时。这个问题源于JavaScript闭包特性，当在<code>useEffect</code>内部使用外部的变了时，可能会捕获旧值，从而导致代码中的副作用没有按照预期的行为执行。</p>
<p>典型的闭包陷阱一般发生在依赖组件的state，且state是异步更新的。</p>
<p>假设我们有这样一个计时器，每秒更新一次：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 闭包陷阱</span>
    }, <span class="hljs-number">1000</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(interval);
  }, []);  <span class="hljs-comment">// 依赖为空，effect只会在挂载时执行一次</span>

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p>在这段代码中，<code>setCount(count + 1)</code>要用到<code>count</code>，但<code>count</code>由<code>useState</code>管理，并且是异步更新的。<code>useEffect</code>会在首次渲染后执行，并且每次渲染都会“捕获”<code>count</code>当前的值，但它并不会随着<code>count</code>的变化自动更新。所以<code>setCount(count + 1)</code>总是使用组件渲染时捕获的“旧值”。因此，<code>count</code>值没有递增，而是一直停留在初值。</p>
<p>为什么会这样呢？因为在<code>useEffect</code>中使用的<code>count</code>被闭包捕获，而<code>useEffect</code>在组件首次渲染时就被调用了，并且闭包里捕获的<code>count</code>永远不会更新，因此<code>useState</code>中的回调总是访问初次渲染的<code>count</code>，而不是组件更新后的最新值。无论<code>count</code>如何变化，都只会更新旧值。</p>
<p>解决方法也是有的：React提供了函数式更新作为<code>setState</code>的一种方式，这样，React可以确保在<code>setState</code>时，始终拿到最新的state。</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">prevCount</span>) =&gt;</span> prevCount + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 使用函数式更新</span>
    }, <span class="hljs-number">1000</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(interval);
  }, []);  <span class="hljs-comment">// 依赖为空，effect只会在挂载时执行一次</span>

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p>当然，我们也可以加上显式依赖。</p>
<p>闭包陷阱的解决的关键在于：确保<code>useEffect</code>中的state始终是最新的，尤其是异步操作也要是新的。使用函数式更新和正确的依赖项，可以有效地解决闭包问题。</p>
<p><strong>暂时先讲到这里，希望各位大佬有问题务必狠狠指正！</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Activity结束动画与System.exit(0)的黑屏之谜]]></title>    <link>https://juejin.cn/post/7573180788578992169</link>    <guid>https://juejin.cn/post/7573180788578992169</guid>    <pubDate>2025-11-17T06:20:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573180788578992169" data-draft-id="7573336057480183814" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Activity结束动画与System.exit(0)的黑屏之谜"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2025-11-17T06:20:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Android童话镇"/> <meta itemprop="url" content="https://juejin.cn/user/2716247406161241"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Activity结束动画与System.exit(0)的黑屏之谜
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2716247406161241/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Android童话镇
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:20:28.000Z" title="Mon Nov 17 2025 06:20:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>让我用一个有趣的故事来解释这个技术问题：</p>
<h2 data-id="heading-0">故事：游乐园的闭园风波</h2>
<p>想象一下，你在一家游乐园（<strong>Android系统</strong>）里，正在玩"旋转木马"（<strong>Activity</strong>）。木马正在优雅地旋转结束（<strong>退出动画</strong>），突然，园方直接<strong>拉闸断电</strong>（<code>System.exit(0)</code>）！</p>
<h3 data-id="heading-1">场景还原：</h3>
<pre><code class="hljs language-text" lang="text">旋转木马正常关闭流程：
1. 木马开始减速旋转（动画开始）
2. 音乐渐渐变小（动画进行中）
3. 木马完全停止（动画结束）
4. 游客有序离场（Activity正常销毁）

突然断电的流程：
1. 木马正在旋转（动画进行中）
2. 突然"啪"的一声，全园停电！（System.exit(0)）
3. 瞬间一片漆黑！（黑屏现象）
4. 游客被困在黑暗中！
</code></pre>
<h2 data-id="heading-2">技术原理深度解析</h2>
<h3 data-id="heading-3">代码演示</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> {
        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        <span class="hljs-type">Button</span> <span class="hljs-variable">exitButton</span> <span class="hljs-operator">=</span> findViewById(R.id.exit_button);
        exitButton.setOnClickListener(v -&gt; {
            <span class="hljs-comment">// 开始退出动画</span>
            startExitAnimation();
            
            <span class="hljs-comment">// 在动画完成前强制退出 - 这就是问题所在！</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>().postDelayed(() -&gt; {
                System.exit(<span class="hljs-number">0</span>); <span class="hljs-comment">// 危险操作！</span>
            }, <span class="hljs-number">500</span>); <span class="hljs-comment">// 假如动画需要1000ms，我们在500ms时强制退出</span>
        });
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startExitAnimation</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 一个优雅的退出动画</span>
        <span class="hljs-type">View</span> <span class="hljs-variable">rootView</span> <span class="hljs-operator">=</span> getWindow().getDecorView();
        rootView.animate()
                .alpha(<span class="hljs-number">0f</span>)
                .scaleX(<span class="hljs-number">0.8f</span>)
                .scaleY(<span class="hljs-number">0.8f</span>)
                .setDuration(<span class="hljs-number">1000</span>)
                .setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccelerateInterpolator</span>())
                .start();
    }
}
</code></pre>
<h3 data-id="heading-4">正确的做法</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">properExit</span><span class="hljs-params">()</span> {
    <span class="hljs-type">View</span> <span class="hljs-variable">rootView</span> <span class="hljs-operator">=</span> getWindow().getDecorView();
    rootView.animate()
            .alpha(<span class="hljs-number">0f</span>)
            .scaleX(<span class="hljs-number">0.8f</span>)
            .scaleY(<span class="hljs-number">0.8f</span>)
            .setDuration(<span class="hljs-number">1000</span>)
            .setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccelerateInterpolator</span>())
            .withEndAction(() -&gt; {
                <span class="hljs-comment">// 等动画完全结束后再结束Activity</span>
                finish();
            })
            .start();
}
</code></pre>
<h2 data-id="heading-5">详细原理分析</h2>
<h3 data-id="heading-6">为什么会出现黑屏？</h3>
<ol>
<li>
<p><strong>动画系统与进程生命周期的冲突</strong></p>
<ul>
<li>动画由<code>Choreographer</code>驱动，依赖VSync信号</li>
<li><code>System.exit(0)</code>直接杀死进程，包括渲染线程</li>
<li>动画被强行中断，界面停留在中间状态</li>
</ul>
</li>
<li>
<p><strong>窗口管理器的清理过程</strong></p>
<ul>
<li><code>System.exit(0)</code> → <code>Process.killProcess(Process.myPid())</code></li>
<li>窗口管理器立即移除所有窗口</li>
<li>但动画还在GPU中渲染，造成视觉断层</li>
</ul>
</li>
<li>
<p><strong>SurfaceFlinger的缓冲处理</strong></p>
<ul>
<li>动画帧还在Surface的buffer中</li>
<li>进程死亡导致buffer无法正常提交</li>
<li>显示系统回退到默认黑色背景</li>
</ul>
</li>
</ol>
<h2 data-id="heading-7">时序图：完整的调用过程</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31f7f7674a614721af2b42cbd2662df6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQW5kcm9pZOerpeivnemVhw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965228&amp;x-signature=5BMMU1e%2Bf2BL7XdlnLMTZ8Mm%2FvA%3D" alt="processChain.png" loading="lazy"/></p>
<h2 data-id="heading-8">更深层的技术细节</h2>
<h3 data-id="heading-9">Android窗口系统架构</h3>
<pre><code class="hljs language-text" lang="text">应用进程 (我们的App)
    ↓
ViewRootImpl (管理窗口)
    ↓
WindowManagerService (系统服务)
    ↓
SurfaceFlinger (图形合成器)
    ↓
显示硬件 (屏幕)
</code></pre>
<h3 data-id="heading-10">System.exit(0)的破坏性调用链</h3>
<pre><code class="hljs language-java" lang="java">System.exit(<span class="hljs-number">0</span>)
    ↓
Runtime.getRuntime().exit(<span class="hljs-number">0</span>)
    ↓
Process.killProcess(Process.myPid())
    ↓  <span class="hljs-comment">// 这里开始出现问题！</span>
ActivityThread.scheduleDestroyActivity() <span class="hljs-comment">// 被跳过！</span>
WindowManager.removeViewImmediate() <span class="hljs-comment">// 强制立即移除</span>
    ↓
Surface.release() <span class="hljs-comment">// 表面被立即销毁</span>
    ↓
黑屏！
</code></pre>
<h3 data-id="heading-11">动画系统的正常流程</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 正常动画结束流程</span>
ValueAnimator.animate()
    → Choreographer.postFrameCallback()
    → doFrame() → applyTransformation()
    → View.invalidate() → draw() 
    → Surface.unlockAndPost()
    → SurfaceFlinger合成显示

<span class="hljs-comment">// System.exit(0)打断后</span>
ValueAnimator.animate()
    → Choreographer.postFrameCallback()
    → System.exit(<span class="hljs-number">0</span>) ← 在这里打断！
    → 进程死亡，回调无法执行
    → 动画卡在半途
</code></pre>
<h2 data-id="heading-12">最佳实践建议</h2>
<h3 data-id="heading-13">1. 优雅退出Activity</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gracefulExit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 方法1：使用动画结束回调</span>
    <span class="hljs-type">View</span> <span class="hljs-variable">rootView</span> <span class="hljs-operator">=</span> getWindow().getDecorView();
    rootView.animate()
            .alpha(<span class="hljs-number">0f</span>)
            .setDuration(<span class="hljs-number">300</span>)
            .withEndAction(() -&gt; finish())
            .start();
    
    <span class="hljs-comment">// 方法2：Override pending transition</span>
    finish();
    overridePendingTransition(R.anim.fade_in, R.anim.slide_out);
}
</code></pre>
<h3 data-id="heading-14">2. 需要强制退出的场景处理</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">safeForceExit</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 先完成界面相关的清理</span>
    getWindow().getDecorView().setVisibility(View.INVISIBLE);
    
    <span class="hljs-comment">// 给系统一点时间处理界面变更</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>().postDelayed(() -&gt; {
        <span class="hljs-comment">// 然后再退出</span>
        System.exit(<span class="hljs-number">0</span>);
    }, <span class="hljs-number">300</span>); <span class="hljs-comment">// 短暂的延迟</span>
}
</code></pre>
<h2 data-id="heading-15">总结</h2>
<p>记住这个游乐园的教训：<strong>永远不要在有动画进行时突然拉闸断电</strong>！给系统足够的时间完成视觉过渡，用户就能获得流畅的体验，而不是被吓人的黑屏打断。</p>
<p>就像让旋转木马自然停止，而不是在高速旋转时直接切断电源。优雅的退出和及时的响应，才是良好用户体验的关键！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[cURL变量管理中的缓冲区越界读取漏洞分析]]></title>    <link>https://juejin.cn/post/7573180788579074089</link>    <guid>https://juejin.cn/post/7573180788579074089</guid>    <pubDate>2025-11-17T06:29:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573180788579074089" data-draft-id="7573300346262208566" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="cURL变量管理中的缓冲区越界读取漏洞分析"/> <meta itemprop="keywords" content="人工智能,AIGC"/> <meta itemprop="datePublished" content="2025-11-17T06:29:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="qife122"/> <meta itemprop="url" content="https://juejin.cn/user/1743174852185579"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            cURL变量管理中的缓冲区越界读取漏洞分析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1743174852185579/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    qife122
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:29:59.000Z" title="Mon Nov 17 2025 06:29:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">漏洞概述</h2>
<p>在cURL的<code>addvariable()</code>函数（由<code>setvariable()</code>调用）中，代码为<code>p-&gt;name</code>分配内存时未为NUL终止符预留空间，直接复制<code>nlen</code>字节。随后，<code>varcontent()</code>等函数对此名称调用<code>strlen()</code>，假设其为NUL终止，这可能导致越界内存读取，造成程序崩溃（DoS）或潜在信息泄露。</p>
<h2 data-id="heading-1">源代码分析</h2>
<p><strong>问题代码位置</strong>：<code>https://github.com/curl/curl/blob/master/src/var.c</code></p>
<pre><code class="hljs language-c" lang="c">p = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> tool_var) + nlen);
<span class="hljs-keyword">if</span>(p) {
  <span class="hljs-built_in">memcpy</span>(p-&gt;name, name, nlen);
}
</code></pre>
<p><strong>数据结构定义</strong>：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tool_var</span> {</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tool_var</span> *<span class="hljs-title">next</span>;</span>
  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *content;
  <span class="hljs-type">size_t</span> clen; <span class="hljs-comment">/* content长度 */</span>
  <span class="hljs-type">char</span> name[<span class="hljs-number">1</span>]; <span class="hljs-comment">/* 作为结构体的一部分分配 */</span>
};
</code></pre>
<h2 data-id="heading-2">复现步骤</h2>
<ol>
<li>
<p><strong>克隆仓库并进入目录</strong></p>
<pre><code class="hljs language-bash" lang="bash">git <span class="hljs-built_in">clone</span> https://github.com/curl/curl.git
<span class="hljs-built_in">cd</span> curl
CFLAGS=<span class="hljs-string">"-fsanitize=address,undefined -g -O1"</span> ./configure
make -j$(<span class="hljs-built_in">nproc</span>)
</code></pre>
</li>
<li>
<p><strong>通过setvariable()添加变量</strong>（例如："TESTVAR=value"）</p>
</li>
<li>
<p><strong>使用varcontent()或varexpand()查找变量</strong></p>
</li>
<li>
<p><strong>通过ASAN/UBSAN日志观察崩溃或越界读取</strong></p>
</li>
</ol>
<h2 data-id="heading-3">影响评估</h2>
<p><code>addvariable()</code>未能对存储的变量名进行NUL终止，因此后续对<code>strlen()</code>的调用可能读取超出分配缓冲区的内存，导致程序立即崩溃。这会产生可用性影响（如果代码路径可访问，容易造成DoS），且越界读取可能暴露相邻内存，造成潜在的机密性问题。</p>
<h2 data-id="heading-4">项目方回应</h2>
<p>cURL开发团队指出代码实际上是安全的，因为：</p>
<ul>
<li><code>name[1]</code>大小为1字节</li>
<li>使用<code>calloc</code>分配结构体大小加上名称长度时，分配的最后一个字节在<code>memcpy</code>后保持为零</li>
</ul>
<p>开发团队已添加注释以帮助后续代码阅读者理解：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcurl%2Fcurl%2Fpull%2F19287" target="_blank" title="https://github.com/curl/curl/pull/19287" ref="nofollow noopener noreferrer">github.com/curl/curl/p…</a></p>
<h2 data-id="heading-5">报告状态</h2>
<ul>
<li><strong>状态</strong>：不适用（Not Applicable）</li>
<li><strong>严重性</strong>：无评级</li>
<li><strong>CVE ID</strong>：无</li>
<li><strong>赏金</strong>：无</li>
<li><strong>披露时间</strong>：2025年10月31日 11:35 UTC</li>
</ul>
<p>报告最终被认定为非安全问题，但按照项目透明度政策被公开披露。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kratos 下使用 Protobuf FieldMask 完全指南]]></title>    <link>https://juejin.cn/post/7573336057480069126</link>    <guid>https://juejin.cn/post/7573336057480069126</guid>    <pubDate>2025-11-17T06:07:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573336057480069126" data-draft-id="7573187591224459318" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kratos 下使用 Protobuf FieldMask 完全指南"/> <meta itemprop="keywords" content="后端,Go"/> <meta itemprop="datePublished" content="2025-11-17T06:07:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="喵个咪"/> <meta itemprop="url" content="https://juejin.cn/user/1350630784901262"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kratos 下使用 Protobuf FieldMask 完全指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1350630784901262/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    喵个咪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:07:25.000Z" title="Mon Nov 17 2025 06:07:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Kratos 下使用 Protobuf FieldMask 完全指南</h2>
<p>当我们使用 gRPC 进行跨服务通讯时，调用方往往只需要响应中的部分字段 —— 冗余字段不仅会增加网络传输成本，更可能触发不必要的下游依赖调用（比如为了返回一个非核心字段，需要额外调用 2 个服务）。​</p>
<p>在微服务场景中，这种「无效计算 + 无效传输」的开销会被放大：一次 RPC 级联 3~5 个下游是常态，而响应体中 60% 以上的字段可能都是调用方不需要的。​</p>
<p>此时，我们需要一种「字段按需筛选」机制：</p>
<ul>
<li><code>GraphQL</code> 用「字段选择器」实现​</li>
<li><code>JSON:API</code> 用「稀疏字段集」实现​</li>
<li>而 gRPC 生态中，<code>Protobuf FieldMask</code> 是标准且高效的解决方案。</li>
</ul>
<h3 data-id="heading-1">一、核心认知：FieldMask 是什么？为什么必要？​</h3>
<h4 data-id="heading-2">1.1 定义与核心价值​</h4>
<p>Protobuf 的 <code>FieldMask</code>（定义在 <code>google.protobuf.FieldMask</code> 中）是一种「字段选择器」，本质是一个字符串列表，用于明确指定「需要返回 / 更新的字段」。其核心价值体现在四方面：​</p>

























<table><thead><tr><th>价值维度</th><th>具体收益</th></tr></thead><tbody><tr><td>计算成本优化</td><td>避免非必要字段的计算（如关联查询、复杂序列化、加密解密）</td></tr><tr><td>网络传输优化</td><td>减少响应包体积，跨服务 / 跨地域调用场景下收益尤为明显</td></tr><tr><td>依赖链解耦</td><td>无需为冗余字段依赖下游服务（如 A 服务无需依赖 B 服务的非核心字段逻辑）</td></tr><tr><td>接口灵活性提升</td><td>调用方自主选择所需字段，服务端无需频繁变更接口（减少版本迭代成本）</td></tr></tbody></table>
<h4 data-id="heading-3">1.2 语法规则（必记！避坑关键）​</h4>
<ul>
<li>字段名必须与 Protobuf 定义一致（使用下划线命名法，而非驼峰）​</li>
<li>嵌套字段用 . 分隔（如 user.profile.avatar，对应嵌套消息结构）​</li>
<li>通配符 * 表示「所有直接子字段」（不含嵌套字段，如 user.* 仅包含 user 的一级字段）​</li>
<li>示例：field_mask: ["id", "product.price", "order.items.*"]​</li>
</ul>
<h4 data-id="heading-4">1.3 微服务场景的量化收益​</h4>

































<table><thead><tr><th>业务场景</th><th>无效字段占比</th><th>延迟优化效果</th><th>带宽优化效果</th><th>下游 QPS 优化</th></tr></thead><tbody><tr><td>商品详情页（APP 首屏）</td><td>71%</td><td>P99 延迟 -35%</td><td>18 KB → 4.8 KB（-73%）</td><td>下游 QPS -40%</td></tr><tr><td>订单列表页（PC 端）</td><td>68%</td><td>P99 延迟 -28%</td><td>12 KB → 3.7 KB（-69%）</td><td>下游 QPS -35%</td></tr><tr><td>用户中心基础信息查询</td><td>82%</td><td>P99 延迟 -42%</td><td>23 KB → 3.9 KB（-83%）</td><td>下游 QPS -50%</td></tr></tbody></table>
<p><strong>核心原因：</strong> 减少了无效的下游调用、序列化开销，同时提升了缓存命中率（字段粒度缓存更易命中）。​</p>
<h3 data-id="heading-5">二、IDL 设计：规范定义 FieldMask（遵循 AIP-161 标准）​</h3>
<p>IDL 设计是 FieldMask 落地的基础，必须遵循「查询用 <code>field_mask</code>、更新用 <code>update_mask</code>」的规范（对齐 Google AIP-161 标准），确保接口一致性和可维护性。​</p>
<h4 data-id="heading-6">2.1 依赖引入​</h4>
<pre><code class="hljs language-protobuf" lang="protobuf">syntax = "proto3";​
package product.v1;

import "google/protobuf/field_mask.proto";
</code></pre>
<h4 data-id="heading-7">2.2 规范定义请求字段​</h4>
<h5 data-id="heading-8">2.2.1 查询场景（Get/List）：用 <code>field_mask</code> 指定返回字段​</h5>
<p>查询接口中，field_mask 作为可选字段，允许调用方自主选择返回字段（未指定时返回核心字段）：​</p>
<pre><code class="hljs language-protobuf" lang="protobuf">// 商品查询请求（单条）
message GetProductRequest {
  string id = 1; // 资源唯一标识
  // 字段选择器：指定需要返回的字段（如 ["id", "name", "price"]）
  google.protobuf.FieldMask field_mask = 2;
}

// 商品查询响应
message GetProductResponse {
  message Product {
    string id = 1;        // 核心字段
    string name = 2;      // 核心字段
    string description = 3; // 非核心字段（长文本）
    double price = 4;     // 核心字段
    message Inventory {   // 嵌套字段（库存信息）
      int32 stock = 1;
      string warehouse = 2;
    }
    Inventory inventory = 5; // 非核心字段（需调用库存服务）
    repeated string tags = 6; // 重复字段
  }
  Product product = 1;
}
</code></pre>
<h5 data-id="heading-9">2.2.2 更新场景（Update）：用 update_mask 指定更新字段​</h5>
<pre><code class="hljs language-protobuf" lang="protobuf">// 商品更新请求
message UpdateProductRequest {
  string id = 1; // 资源唯一标识（推荐单独透出，而非嵌套在 data 中）
  Product data = 2; // 待更新的字段数据（仅填充需要更新的内容）
  // 字段选择器：明确指定需要更新的字段（如 ["price", "inventory.stock"]）
  google.protobuf.FieldMask update_mask = 3; // 必填字段
}

// 商品更新响应
message UpdateProductResponse {
  bool success = 1;
  Product updated_product = 2; // 返回更新后的完整数据（或按需求返回指定字段）
}
</code></pre>
<h4 data-id="heading-10">2.4 IDL 设计最佳实践​</h4>
<ol>
<li><strong>字段命名规范：</strong> 查询用 field_mask，更新用 update_mask，避免混淆（如 mask 这种模糊命名）。​</li>
<li><strong>核心字段默认返回：</strong> 未指定 field_mask 时，服务端返回核心字段（如 id、name），避免返回空数据。​</li>
<li><strong>嵌套字段合理拆分：</strong> 将「高开销字段」（如需要跨服务查询的字段）拆分为嵌套消息，便于单独筛选（如 inventory 字段）。​</li>
<li><strong>避免过度拆分：</strong> 字段粒度不宜过细（如将 user.name 拆分为 user.first_name+user.last_name 是合理的，但拆分为单个字符则无意义）。​</li>
</ol>
<h3 data-id="heading-11">三、Kratos 集成落地</h3>
<h4 data-id="heading-12">查询场景：从 SQL 到响应的全链路字段筛选</h4>
<p>核心优化：数据层（ent）只查询 FieldMask 指定的字段，服务层只返回指定字段，避免「查询冗余字段 + 响应裁剪」的无效开销。​</p>
<p>在查询当中，主要就是注入到SQL语句的<code>SELECT</code>参数，我为ent封装了一个方法：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildFieldSelect</span><span class="hljs-params">(s *sql.Selector, fields []<span class="hljs-type">string</span>)</span></span> {
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fields) &gt; <span class="hljs-number">0</span> {
		<span class="hljs-keyword">for</span> i, field := <span class="hljs-keyword">range</span> fields {
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-keyword">case</span> field == <span class="hljs-string">"id_"</span> || field == <span class="hljs-string">"_id"</span>:
				field = <span class="hljs-string">"id"</span>
			}
			fields[i] = stringcase.ToSnakeCase(field)
		}
		s.Select(fields...)
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildFieldSelector</span><span class="hljs-params">(fields []<span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">error</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *sql.Selector)</span></span>) {
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fields) &gt; <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *sql.Selector)</span></span> {
			BuildFieldSelect(s, fields)
		}
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>
	}
}
</code></pre>
<p>使用的时候只需要把<code>FieldMask</code>传入：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">var</span> fieldSelector <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *sql.Selector)</span></span>
err, fieldSelector = BuildFieldSelector(req.GetFieldMask().GetPaths())
</code></pre>
<h4 data-id="heading-13">更新场景：安全更新 + NULL 字段处理</h4>
<p>核心需求：仅更新 FieldMask 指定的字段，支持将字段设为 NULL（如清空描述），避免全量覆盖。​</p>
<p>更新需要做两步：</p>
<ol>
<li>把不需要更新的字段过滤掉；</li>
<li>把需要更新为NULL的字段的SQL添加上。</li>
</ol>
<p>过滤字段，我这里有封装一个工具集：</p>
<pre><code class="hljs language-bash" lang="bash">go get github.com/tx7do/go-utils/fieldmaskutil
</code></pre>
<p>调用<code>fieldmaskutil.FilterByFieldMask</code>方法：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">if</span> err := fieldmaskutil.FilterByFieldMask(trans.Ptr(proto.Message(req.GetData())), req.UpdateMask); err != <span class="hljs-literal">nil</span> {
  r.log.Errorf(<span class="hljs-string">"invalid field mask [%v], error: %s"</span>, req.UpdateMask, err.Error())
  <span class="hljs-keyword">return</span> userV1.ErrorBadRequest(<span class="hljs-string">"invalid field mask"</span>)
}
</code></pre>
<p>在这里我们拿ent作为一个示例，同样的，对于ent的一些常规操作，我也封装了一个工具集：</p>
<pre><code class="hljs language-bash" lang="bash">go get github.com/tx7do/go-utils/entgo
</code></pre>
<p>直接在<code>builder.Exec</code>之前调用方法：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">import</span> entgoUpdate <span class="hljs-string">"github.com/tx7do/go-utils/entgo/update"</span>

entgoUpdate.ApplyNilFieldMask(proto.Message(req.GetData()), req.UpdateMask, builder)
</code></pre>
<h3 data-id="heading-14">参考资料</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fyeqown.xyz%2F2022%2F01%2F25%2Fprotoc-gen-fieldmask%25E6%258F%2592%25E4%25BB%25B6%2F" target="_blank" title="https://yeqown.xyz/2022/01/25/protoc-gen-fieldmask%E6%8F%92%E4%BB%B6/" ref="nofollow noopener noreferrer">protoc-gen-fieldmask插件</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcloud.google.com%2Fdialogflow%2Fcx%2Fdocs%2Fhow%2Ffield-mask%3Fhl%3Dzh-cn" target="_blank" title="https://cloud.google.com/dialogflow/cx/docs/how/field-mask?hl=zh-cn" ref="nofollow noopener noreferrer">使用 FieldMask 更新数据</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgoogle.aip.dev%2F161" target="_blank" title="https://google.aip.dev/161" ref="nofollow noopener noreferrer">Field masks AIP-161</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fvlkppbqar4tffhfwv9ke" target="_blank" title="https://www.infoq.cn/article/vlkppbqar4tffhfwv9ke" ref="nofollow noopener noreferrer">Netflix 实用 API 设计第 1 部分：使用 Protobuf FieldMask</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnetflixtechblog.com%2Fpractical-api-design-at-netflix-part-1-using-protobuf-fieldmask-35cfdc606518" target="_blank" title="https://netflixtechblog.com/practical-api-design-at-netflix-part-1-using-protobuf-fieldmask-35cfdc606518" ref="nofollow noopener noreferrer">Practical API Design at Netflix, Part 1: Using Protobuf FieldMask</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnetflixtechblog.com%2Fpractical-api-design-at-netflix-part-2-protobuf-fieldmask-for-mutation-operations-2e75e1d230e4" target="_blank" title="https://netflixtechblog.com/practical-api-design-at-netflix-part-2-protobuf-fieldmask-for-mutation-operations-2e75e1d230e4" ref="nofollow noopener noreferrer">Practical API Design at Netflix, Part 2: Protobuf FieldMask for Mutation Operations</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🎯 Flutter 拖拽选择组件：flutter_drag_selector —— 像选文件一样选择列表项]]></title>    <link>https://juejin.cn/post/7573332163387506742</link>    <guid>https://juejin.cn/post/7573332163387506742</guid>    <pubDate>2025-11-17T06:08:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573332163387506742" data-draft-id="7573187591223820342" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🎯 Flutter 拖拽选择组件：flutter_drag_selector —— 像选文件一样选择列表项"/> <meta itemprop="keywords" content="前端,Flutter"/> <meta itemprop="datePublished" content="2025-11-17T06:08:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="达达尼昂"/> <meta itemprop="url" content="https://juejin.cn/user/747323637640237"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🎯 Flutter 拖拽选择组件：flutter_drag_selector —— 像选文件一样选择列表项
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/747323637640237/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    达达尼昂
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:08:33.000Z" title="Mon Nov 17 2025 06:08:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Flutter 开发桌面端应用中，我们经常需要在一个滚动列表（如 <code>ListView</code>、<code>GridView</code> 或 <code>Wrap</code>）中让用户<strong>批量选择多个项目</strong>。传统的做法是点击每个项目逐一选中，或使用“全选”按钮，但这在项目数量多、布局密集的场景下体验不佳。</p>
<p><strong><code>flutter_drag_selector</code></strong> 正是为解决这一痛点而生的轻量级 Flutter 插件。它让你<strong>像在桌面系统中用鼠标框选文件一样</strong>，通过拖拽鼠标（或手指）划出一个区域，自动选中该区域内的所有子组件，大幅提升交互效率。</p>
<h2 data-id="heading-0">✨ 核心功能概览</h2>
<ul>
<li><strong>拖拽框选</strong>：按住鼠标左键（或触摸屏长按）并拖动，实时绘制一个半透明选择框。</li>
<li><strong>自动识别</strong>：自动检测拖拽区域内所有被 <code>SelectableItem</code> 包裹的子组件，并动态选中/取消选中。</li>
<li><strong>可定制</strong>：支持自定义选择区域的样式（颜色、圆角、边框）、选中状态回调、滚动容器控制等。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b37fbc6dc2af48bfb8b6449325d53a50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L6-6L6-5bC85piC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964512&amp;x-signature=J%2FwqkcMU6gdj6LJkcZXRP0jOfK0%3D" alt="img_introduce.gif" loading="lazy"/></p>
<h2 data-id="heading-1">🛠️ 如何使用？</h2>
<h3 data-id="heading-2">1. 添加依赖</h3>
<p>在你的 <code>pubspec.yaml</code> 文件中添加：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-attr">flutter_drag_selector:</span> <span class="hljs-string">^latest</span>
</code></pre>
<h3 data-id="heading-3">2. 包装你的列表</h3>
<p>将你的滚动容器（如 <code>SingleChildScrollView</code> + <code>Wrap</code>）用 <code>CursorSelectorWidget</code> 包裹，并用 <code>SelectableItem</code> 包裹每一个可选项目。</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_drag_selector/flutter_drag_selector.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});
  <span class="hljs-meta">@override</span>
  State&lt;MyApp&gt; createState() =&gt; _MyAppState();
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyAppState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyApp</span>&gt; </span>{
  <span class="hljs-keyword">final</span> _list = <span class="hljs-built_in">List</span>.generate(<span class="hljs-number">50</span>, (i) =&gt; i);
  <span class="hljs-keyword">final</span> _controller = StreamController&lt;(Key?, <span class="hljs-built_in">bool</span>)&gt;.broadcast(); <span class="hljs-comment">// 用于更新 UI 状态</span>
  <span class="hljs-keyword">final</span> scrollController = ScrollController();

  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> initState() {
    <span class="hljs-keyword">super</span>.initState();
  }

  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> dispose() {
    _controller.close();
    scrollController.dispose();
    <span class="hljs-keyword">super</span>.dispose();
  }

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    Widget buildBox(<span class="hljs-built_in">int</span> index) {
      <span class="hljs-keyword">final</span> id = ValueKey&lt;<span class="hljs-built_in">int</span>&gt;(index);
      <span class="hljs-keyword">return</span> StreamBuilder&lt;(Key?, <span class="hljs-built_in">bool</span>)&gt;(
        stream: _controller.stream.where((e) =&gt; e.$<span class="hljs-number">1</span> == id),
        builder: (ctx, snapshot) {
          <span class="hljs-keyword">return</span> SelectableItem(
            key: id,
            child: GestureDetector(
              onTap: () {
                debugPrint(<span class="hljs-string">'tap -&gt; <span class="hljs-subst">$index</span>'</span>);
              },
              child: Container(
                width: <span class="hljs-number">200</span>,
                height: <span class="hljs-number">200</span>,
                decoration: BoxDecoration(
                  color: index % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? Colors.yellow : Colors.lightBlueAccent,
                ),
                alignment: Alignment.center,
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(<span class="hljs-string">'<span class="hljs-subst">$index</span>'</span>, style: <span class="hljs-keyword">const</span> TextStyle(fontSize: <span class="hljs-number">20</span>)),
                    <span class="hljs-keyword">const</span> SizedBox(width: <span class="hljs-number">20</span>),
                    Icon(
                      (snapshot.data?.$<span class="hljs-number">2</span> ?? <span class="hljs-keyword">false</span>)
                          ? Icons.check_box
                          : Icons.check_box_outline_blank,
                      size: <span class="hljs-number">40</span>,
                      color: Colors.red,
                    )
                  ],
                ),
              ),
            ),
          );
        },
      );
    }

    <span class="hljs-keyword">return</span> MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'拖拽选择示例'</span>)),
        body: CursorSelectorTheme(
          data: CursorSelectorThemeData(
            selectedAreaDecoration: BoxDecoration(
              color: Colors.blue.withOpacity(<span class="hljs-number">0.4</span>),
              borderRadius: BorderRadius.circular(<span class="hljs-number">10</span>),
            ),
          ),
          child: CursorSelectorWidget(
            scrollController: scrollController, <span class="hljs-comment">// 控制滚动</span>
            selectedChangedCallback: (selection) {
              <span class="hljs-comment">// 选中状态变更回调，用于更新 UI</span>
              _controller.add(selection);
            },
            child: SingleChildScrollView(
              controller: scrollController,
              child: Wrap(
                spacing: <span class="hljs-number">10</span>,
                runSpacing: <span class="hljs-number">10</span>,
                children: _list.map&lt;Widget&gt;(buildBox).toList(),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
</code></pre>
<h3 data-id="heading-4">3. 效果说明</h3>
<ul>
<li>用户<strong>按住鼠标左键</strong>（或在移动端长按）并拖动，会看到一个蓝色半透明矩形框跟随鼠标移动。</li>
<li>每次<code>SelectableItem</code>的选中状态变化，都会通过 <code>selectedChangedCallback</code> 回调返回 <code>(Key, isSelected)</code>，开发者可据此更新数据模型或 UI。</li>
</ul>
<h2 data-id="heading-5">🎨 自定义主题</h2>
<p>你可以通过 <code>CursorSelectorTheme</code> 和 <code>CursorSelectorThemeData</code> 自定义选择框的视觉样式：</p>
<pre><code class="hljs language-dart" lang="dart">CursorSelectorTheme(
  data: CursorSelectorThemeData(
    selectedAreaDecoration: BoxDecoration(
      color: Colors.green.withOpacity(<span class="hljs-number">0.3</span>),
      border: Border.all(color: Colors.green, width: <span class="hljs-number">2</span>),
      borderRadius: BorderRadius.circular(<span class="hljs-number">8</span>),
    )
  ),
  child: CursorSelectorWidget(...),
)
</code></pre>
<h2 data-id="heading-6">结语</h2>
<p>如有设计不佳的点，欢迎指出。</p>
<p>👉 <strong>GitHub 地址</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbladeofgod%2Fflutter_drag_selector" target="_blank" title="https://github.com/bladeofgod/flutter_drag_selector" ref="nofollow noopener noreferrer">github.com/bladeofgod/…</a></p>
<p>👉 <strong>Pub 地址</strong>   ：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fflutter_drag_selector" target="_blank" title="https://pub.dev/packages/flutter_drag_selector" ref="nofollow noopener noreferrer">pub.dev/packages/fl…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[vue3.x 使用vue3-tree-org实现组织架构图 + 自定义模版内容 - 附完整示例]]></title>    <link>https://juejin.cn/post/7573241978901512207</link>    <guid>https://juejin.cn/post/7573241978901512207</guid>    <pubDate>2025-11-17T06:08:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573241978901512207" data-draft-id="7572775409726308352" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="vue3.x 使用vue3-tree-org实现组织架构图 + 自定义模版内容 - 附完整示例"/> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"/> <meta itemprop="datePublished" content="2025-11-17T06:08:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="bug爱好者"/> <meta itemprop="url" content="https://juejin.cn/user/4019470243992782"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            vue3.x 使用vue3-tree-org实现组织架构图 + 自定义模版内容 - 附完整示例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4019470243992782/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    bug爱好者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:08:55.000Z" title="Mon Nov 17 2025 06:08:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>组织树形结构架构图，如果是vue2项目，请移步<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2F10ve%2Fp%2F12573772.html" target="_blank" title="https://www.cnblogs.com/10ve/p/12573772.html" ref="nofollow noopener noreferrer">www.cnblogs.com/10ve/p/1257…</a></strong></p>
<p><strong>本文主要讲解在vue3项目中使用，废话不多说，直接上代码。</strong></p>
<p><strong>实际完成效果图</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd6ab4f62eb542e8918afb9c9b280685~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnVn54ix5aW96ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964595&amp;x-signature=ERgE0QZ94LzhKh4lHZEzpO%2BAR8o%3D" alt="a106a8797916fda0c2faf2501698f655.png" loading="lazy"/></p>
<p><strong>官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsangtian152.github.io%2Fvue3-tree-org%2F" title="https://sangtian152.github.io/vue3-tree-org/" target="_blank" ref="nofollow noopener noreferrer">sangtian152.github.io/vue3-tree-o…</a></strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc1f074c3b1648939892c90e68e221f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnVn54ix5aW96ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964595&amp;x-signature=%2BPztpKXB85QgzaOmSn75AXAgyls%3D" alt="image.png" loading="lazy"/></p>
<p><strong>安装</strong></p>
<pre><code class="hljs language-csharp" lang="csharp">npm i vue3-tree-org -S
<span class="hljs-meta"># or</span>
yarn <span class="hljs-keyword">add</span> vue3-tree-org
</code></pre>
<p><strong>安装版本号</strong></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"vue3-tree-org"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^4.2.2"</span><span class="hljs-punctuation">,</span>
</code></pre>
<p><strong>全局使用共有两种方法：</strong></p>
<ol>
<li>main.js直接使用：</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript">
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> vue3TreeOrg <span class="hljs-keyword">from</span> <span class="hljs-string">'vue3-tree-org'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"vue3-tree-org/lib/vue3-tree-org.css"</span>;
 
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
 
app.<span class="hljs-title function_">use</span>(vue3TreeOrg)
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<ol start="2">
<li>main.js封装使用（推荐）：</li>
</ol>

<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>;
<span class="hljs-keyword">import</span> router, { setupRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/router'</span>;
<span class="hljs-keyword">import</span> { setupStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/store'</span>;
<span class="hljs-keyword">import</span> { setupDirectives } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/directives'</span>;
<span class="hljs-keyword">import</span> setupPlugins <span class="hljs-keyword">from</span> <span class="hljs-string">'@/plugins'</span>;

<span class="hljs-comment">// 引入动画</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'animate.css/animate.min.css'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'animate.css/animate.compat.css'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'@/styles/common/base.scss'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'@/styles/common/element_edit_after.scss'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'@/styles/common/el-button.scss'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">appInit</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);

  <span class="hljs-comment">// 挂载状态管理</span>
  <span class="hljs-title function_">setupStore</span>(app);

  <span class="hljs-comment">// 挂载路由</span>
  <span class="hljs-title function_">setupRouter</span>(app);

  <span class="hljs-comment">// 挂载插件</span>
  <span class="hljs-title function_">setupPlugins</span>(app);

  <span class="hljs-comment">// 自定义指令</span>
  <span class="hljs-title function_">setupDirectives</span>(app);

  <span class="hljs-comment">// 路由准备就绪后挂载APP实例</span>
  <span class="hljs-keyword">await</span> router.<span class="hljs-title function_">isReady</span>();

  <span class="hljs-comment">// 挂载到页面</span>
  app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>, <span class="hljs-literal">true</span>);
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">appInit</span>();
</code></pre>
<p>3.  plugins文件下的treeOrg.ts</p>

<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">App</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">import</span> vue3TreeOrg <span class="hljs-keyword">from</span> <span class="hljs-string">'vue3-tree-org'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"vue3-tree-org/lib/vue3-tree-org.css"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">setupTreeOrg</span>(<span class="hljs-params">app: App</span>) {
  app.<span class="hljs-title function_">use</span>(vue3TreeOrg)
}
</code></pre>
<p><strong>整体文件对应图</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11e5f2f52e8e4a91af1a6d2e3f878f92~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnVn54ix5aW96ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964595&amp;x-signature=UpONSzp96kJXwssQs1ThvQ%2FAJKI%3D" alt="image.png" loading="lazy"/></p>
<p><strong>如果不需要自定义内容，可以这样使用</strong></p>
<pre><code class="hljs language-xml" lang="xml">
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tree-wrap"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: 400px"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"search-box"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>搜索：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"keyword"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入搜索内容"</span> @<span class="hljs-attr">keydown.enter</span>=<span class="hljs-string">"filter"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">vue3-tree-org</span>
      <span class="hljs-attr">ref</span>=<span class="hljs-string">"treeRef"</span>
      <span class="hljs-attr">:data</span>=<span class="hljs-string">"data"</span>
      <span class="hljs-attr">:horizontal</span>=<span class="hljs-string">"horizontal"</span>
      <span class="hljs-attr">:collapsable</span>=<span class="hljs-string">"collapsable"</span>
      <span class="hljs-attr">:label-style</span>=<span class="hljs-string">"style"</span>
      <span class="hljs-attr">:node-draggable</span>=<span class="hljs-string">"true"</span>
      <span class="hljs-attr">:scalable</span>=<span class="hljs-string">"false"</span>
      <span class="hljs-attr">:only-one-node</span>=<span class="hljs-string">"onlyOneNode"</span>
      <span class="hljs-attr">:default-expand-level</span>=<span class="hljs-string">"1"</span>
      <span class="hljs-attr">:filter-node-method</span>=<span class="hljs-string">"filterNodeMethod"</span>
      <span class="hljs-attr">:clone-node-drag</span>=<span class="hljs-string">"cloneNodeDrag"</span>
      @<span class="hljs-attr">on-restore</span>=<span class="hljs-string">"restore"</span>
      @<span class="hljs-attr">on-contextmenu</span>=<span class="hljs-string">"onMenus"</span>
      @<span class="hljs-attr">on-node-click</span>=<span class="hljs-string">"onNodeClick"</span>
    /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
 
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span>
 
<span class="hljs-keyword">const</span> treeRef = <span class="hljs-title function_">ref</span>()
<span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>({
  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">label</span>: <span class="hljs-string">'xxx科技有限公司'</span>,
  <span class="hljs-attr">children</span>: [
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">label</span>: <span class="hljs-string">'产品研发部'</span>,
      <span class="hljs-attr">style</span>: { <span class="hljs-attr">color</span>: <span class="hljs-string">'#fff'</span>, <span class="hljs-attr">background</span>: <span class="hljs-string">'#108ffe'</span> },
      <span class="hljs-attr">children</span>: [
        { <span class="hljs-attr">id</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'禁止编辑节点'</span>, <span class="hljs-attr">disabled</span>: <span class="hljs-literal">true</span> },
        { <span class="hljs-attr">id</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'禁止拖拽节点'</span>, <span class="hljs-attr">noDragging</span>: <span class="hljs-literal">true</span> },
        { <span class="hljs-attr">id</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'测试'</span> }
      ]
    },
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">label</span>: <span class="hljs-string">'客服部'</span>,
      <span class="hljs-attr">children</span>: [
        { <span class="hljs-attr">id</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'客服一部'</span> },
        { <span class="hljs-attr">id</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'客服二部'</span> }
      ]
    },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">'业务部'</span> }
  ]
})
<span class="hljs-keyword">const</span> keyword = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
<span class="hljs-keyword">const</span> horizontal = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
<span class="hljs-keyword">const</span> collapsable = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">const</span> onlyOneNode = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">const</span> cloneNodeDrag = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">const</span> expandAll = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">const</span> style = <span class="hljs-title function_">ref</span>({
  <span class="hljs-attr">background</span>: <span class="hljs-string">'#fff'</span>,
  <span class="hljs-attr">color</span>: <span class="hljs-string">'#5e6d82'</span>
})
 
<span class="hljs-keyword">const</span> <span class="hljs-title function_">onMenus</span> = (<span class="hljs-params">{ node, command }</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(node, command)
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">restore</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'restore'</span>)
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">filter</span> = (<span class="hljs-params"/>) =&gt; {
  treeRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(keyword.<span class="hljs-property">value</span>)
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">filterNodeMethod</span> = (<span class="hljs-params">value, data</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value, data)
  <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  <span class="hljs-keyword">return</span> data.<span class="hljs-property">label</span>.<span class="hljs-title function_">indexOf</span>(value) !== -<span class="hljs-number">1</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">onNodeClick</span> = (<span class="hljs-params">e, data</span>) =&gt; {
  <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">info</span>(data.<span class="hljs-property">label</span>)
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">expandChange</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-title function_">toggleExpand</span>(data.<span class="hljs-property">value</span>, expandAll.<span class="hljs-property">value</span>)
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.tree-wrap</span> {
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">52px</span>;
}
<span class="hljs-selector-class">.search-box</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-selector-tag">input</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">32px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;
    <span class="hljs-attribute">outline</span>: none;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">10px</span>;
  }
}
<span class="hljs-selector-class">.tree-org-node__text</span> {
  <span class="hljs-attribute">text-align</span>: left;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;
  <span class="hljs-selector-class">.custom-content</span> {
    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">8px</span>;
    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">8px</span>;
    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid currentColor;
  }
}
</span></code></pre>
<p><strong>效果图为：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1ccc4d9ec27d4ca1804a393e0e259808~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnVn54ix5aW96ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964595&amp;x-signature=hVS2Z6JUedBHOSHAAOvB5mu1IEI%3D" alt="image.png" loading="lazy"/></p>
<p><strong>如果需要自定义，可以这样使用</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{node}"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tree-org-node__text node-label"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"custom-content"</span>&gt;</span>自定义内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>节点ID：{{node.id}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>节点名称：{{node.label}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p><strong>注意：</strong></p>
<ol>
<li>这样只能只能取id和label</li>
<li>如果你有其他的，如createTime,gross这些额外的字段，在使用node.createTime，或node.gross，将不会生效，你需要使用$$data字段进行解析</li>
<li>由来$$data：:render-content函数进行渲染打印，你会得到：</li>
</ol>

<pre><code class="hljs language-typescript" lang="typescript">&lt;template&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">vue3-tree-org</span> 
        <span class="hljs-attr">:render-content</span>=<span class="hljs-string">"renderContent"</span>
    &gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">vue3-tree-org</span>&gt;</span></span>
&lt;/template&gt;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">renderContent</span> = (<span class="hljs-params">h: <span class="hljs-built_in">any</span>, node: <span class="hljs-built_in">any</span></span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(node, <span class="hljs-string">'11111111111111111'</span>)
}
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bcf38fcc4a4f4cc7b87cdd6615281ed9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnVn54ix5aW96ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964595&amp;x-signature=FekTADVcF6F9b5cWdWyM4tDJ6eE%3D" alt="image.png" loading="lazy"/></p>
<ol start="4">
<li>此时你就可以这样使用：</li>
</ol>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{node}"</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tree-org-node__text node-label"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"custom-content"</span>&gt;</span>自定义内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>节点ID：{{node.$$data.id}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>节点名称：{{node.$$data.label}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>节点时间：{{node.$$data.createTime}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>节点增长：{{node.$$data.gross}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p><strong>注意：如果你在使用renderContent函数进行数据渲染打印时，控制台无输出，请暂时删掉template模版内所有内容后重试，原因如官网所示：</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b8b29834eb45471a9dc60437cc43385e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYnVn54ix5aW96ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964595&amp;x-signature=0AKBdB41301sNIyeOAHo6w39sRs%3D" alt="image.png" loading="lazy"/></p>
<p><strong>项目中使用(完整代码)</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tree-wrap"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">vue3-tree-org</span>
      <span class="hljs-attr">center</span>
      <span class="hljs-attr">ref</span>=<span class="hljs-string">"treeRef"</span>
      <span class="hljs-attr">:data</span>=<span class="hljs-string">"treeData"</span>
      <span class="hljs-attr">:horizontal</span>=<span class="hljs-string">"horizontal"</span>
      <span class="hljs-attr">:collapsable</span>=<span class="hljs-string">"collapsable"</span>
      <span class="hljs-attr">:label-style</span>=<span class="hljs-string">"style"</span>
      <span class="hljs-attr">:node-draggable</span>=<span class="hljs-string">"true"</span>
      <span class="hljs-attr">:scalable</span>=<span class="hljs-string">"scalable"</span>
      <span class="hljs-attr">:only-one-node</span>=<span class="hljs-string">"onlyOneNode"</span>
      <span class="hljs-attr">:default-expand-level</span>=<span class="hljs-string">"1"</span>
      <span class="hljs-attr">:clone-node-drag</span>=<span class="hljs-string">"cloneNodeDrag"</span>
      <span class="hljs-attr">:before-drag-end</span>=<span class="hljs-string">"beforeDragEnd"</span>
    &gt;</span>
    <span class="hljs-comment">&lt;!-- 自定义节点内容，实现可配置 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{node}"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tree-org-node__text"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb12"</span>&gt;</span>提煤计划号：{{ node.$$data.no || '--' }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb12 myb-cursor-pointer"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"no-cursor-pointer"</span>&gt;</span>转发张数：{{node.$$data.num || 0}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ml15"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"getClick('4', node.$$data.id)"</span>&gt;</span>接单张数：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"c409eff"</span>&gt;</span>{{node.$$data.receive || 0}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ml15"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"getClick('7', node.$$data.id)"</span>&gt;</span>过空张数：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"c409eff"</span>&gt;</span>{{node.$$data.tare || 0}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ml15"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"getClick('8', node.$$data.id)"</span>&gt;</span>过重张数：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"c409eff"</span>&gt;</span>{{node.$$data.gross || 0}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ml15"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"getClick('9', node.$$data.id)"</span>&gt;</span>作废张数：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"c409eff"</span>&gt;</span>{{node.$$data.cancel || 0}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb5 box"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"myb-ellipsis-1"</span>&gt;</span>转出方：{{ node.$$data.partyBname || '--' }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ml15"</span>&gt;</span>转出时间：{{ formatTime(node.$$data.createTime, node.$$data.partyBname) }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb5 box"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"myb-ellipsis-1"</span>&gt;</span>转入方：{{ node.$$data.preName || '--' }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ml15"</span>&gt;</span>转入时间：{{ formatTime(node.$$data.createTime, node.$$data.preName) }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 节点展开数量 --&gt;</span>
      <span class="hljs-comment">&lt;!-- &lt;template v-slot:expand="{node}"&gt;
        &lt;div&gt;{{node.children.length}}&lt;/div&gt;
      &lt;/template&gt; --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">vue3-tree-org</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">'moment'</span>
<span class="hljs-keyword">import</span> { ref, onBeforeMount, h } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> { coalPlanTreeDetail, statByCoalPlan } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/service-api/coalDeliveryNote"</span>;

<span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>({
 <span class="hljs-attr">coalPlanId</span>: {
    <span class="hljs-comment">// 提煤计划id</span>
    <span class="hljs-attr">type</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],
    <span class="hljs-attr">default</span>: <span class="hljs-string">""</span>,
  },
});

<span class="hljs-keyword">const</span> treeData = <span class="hljs-title function_">ref</span>({})
<span class="hljs-keyword">const</span> scalable = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 是否可缩放</span>
<span class="hljs-keyword">const</span> horizontal = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 是否水平布局</span>
<span class="hljs-keyword">const</span> collapsable = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 是否可折叠</span>
<span class="hljs-keyword">const</span> onlyOneNode = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 是否仅拖动当前节点，如果true，仅拖动当前节点，子节点自动添加到当前节点父节点，如果false，则当前节点及子节点一起拖动</span>
<span class="hljs-keyword">const</span> cloneNodeDrag = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// 是否拷贝节点拖拽</span>
<span class="hljs-comment">// tree整体样式配置</span>
<span class="hljs-keyword">const</span> style = <span class="hljs-title function_">ref</span>({
  <span class="hljs-attr">background</span>: <span class="hljs-string">'#fff'</span>,
  <span class="hljs-attr">color</span>: <span class="hljs-string">'#606266'</span>
})

<span class="hljs-comment">// 递归获取所有节点ID</span>
<span class="hljs-keyword">const</span> getAllNodeIds = (<span class="hljs-attr">node</span>: any): number[] =&gt; {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">ids</span>: number[] = [];
  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">id</span>) {
    ids.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">id</span>);
  }
  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span> &amp;&amp; node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
    node.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child: any</span>) =&gt;</span> {
      ids = ids.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">getAllNodeIds</span>(child));
    });
  }
  <span class="hljs-keyword">return</span> ids;
};

<span class="hljs-comment">// 递归更新节点数据</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">updateNodeData</span> = (<span class="hljs-params">node: any, statDataMap: <span class="hljs-built_in">Map</span>&lt;number, any&gt;</span>) =&gt; {
  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">id</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; statDataMap.<span class="hljs-title function_">has</span>(node.<span class="hljs-property">id</span>)) {
    <span class="hljs-keyword">const</span> statData = statDataMap.<span class="hljs-title function_">get</span>(node.<span class="hljs-property">id</span>);
    node.<span class="hljs-property">receive</span> = statData.<span class="hljs-property">receive</span>;
    node.<span class="hljs-property">tare</span> = statData.<span class="hljs-property">tare</span>;
    node.<span class="hljs-property">gross</span> = statData.<span class="hljs-property">gross</span>;
    node.<span class="hljs-property">cancel</span> = statData.<span class="hljs-property">cancel</span>;
  }
  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span> &amp;&amp; node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
    node.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child: any</span>) =&gt;</span> {
      <span class="hljs-title function_">updateNodeData</span>(child, statDataMap);
    });
  }
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">getTreeData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">coalPlanTreeDetail</span>({
    <span class="hljs-comment">// id: props.coalPlanId</span>
    <span class="hljs-attr">id</span>: <span class="hljs-number">35</span>
  });

  <span class="hljs-comment">// 注意：因为本项目中的接单张数，过空张数，过重张数，作废张数，是在接口请求之后，在同步请求statByCoalPlan接口，将数据同步到节点数据中，如果你的项目部需要这步骤，则直接用下面代码：</span>
  <span class="hljs-keyword">if</span> (data) {
    <span class="hljs-comment">// 获取所有节点ID</span>
    <span class="hljs-keyword">const</span> allIds = <span class="hljs-title function_">getAllNodeIds</span>(data);
    <span class="hljs-keyword">const</span> statDataMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;number, any&gt;();
    <span class="hljs-comment">// 并行请求所有统计数据</span>
    <span class="hljs-keyword">const</span> promises = allIds.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> <span class="hljs-title function_">statByCoalPlan</span>({ <span class="hljs-attr">coalPlanId</span>: id }));
    <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);
    <span class="hljs-comment">// 将结果存入映射</span>
    results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result, index</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (result.<span class="hljs-property">data</span>) {
        statDataMap.<span class="hljs-title function_">set</span>(allIds[index], result.<span class="hljs-property">data</span>);
      }
    });
    <span class="hljs-comment">// 更新节点数据</span>
    <span class="hljs-title function_">updateNodeData</span>(data, statDataMap);
    treeData.<span class="hljs-property">value</span> = data;
  }

  <span class="hljs-comment">// 如果不需要这个步骤，则直接使用下面代码：</span>
  treeData.<span class="hljs-property">value</span> = data;
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">beforeDragEnd</span> = (<span class="hljs-params">node: any, targetNode: any</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!targetNode) <span class="hljs-title function_">reject</span>()
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">id</span> === targetNode.<span class="hljs-property">id</span>) {
      <span class="hljs-title function_">reject</span>()
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">resolve</span>()
    }
  })
};

<span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">'handleSwitchTab'</span>])
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getClick</span> = (<span class="hljs-params">type: string, id: string</span>) =&gt; {
  <span class="hljs-title function_">emit</span>(<span class="hljs-string">'handleSwitchTab'</span>, type, id)
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">formatTime</span> = (<span class="hljs-params">time: string, name: string</span>) =&gt; {
  <span class="hljs-keyword">return</span> time &amp;&amp; name ? <span class="hljs-title function_">moment</span>(time).<span class="hljs-title function_">format</span>(<span class="hljs-string">"YYYY-MM-DD HH:mm:ss"</span>) : <span class="hljs-string">'--'</span>;
};

<span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">getTreeData</span>();
});

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.tree-wrap</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;
  <span class="hljs-attribute">position</span>: relative;
  :<span class="hljs-built_in">deep</span>(.zm-tree-org) {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
    <span class="hljs-selector-class">.zoom-container</span> {
      <span class="hljs-attribute">overflow</span>: auto; // 在允许视图滚动的同时，影藏未满足滚动时的滚动槽 
      <span class="hljs-selector-class">.tree-org</span>&gt;<span class="hljs-selector-class">.tree-org-node</span> {
        <span class="hljs-attribute">padding</span>: <span class="hljs-number">3px</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;  // tree-org 组件节点间距调整
        <span class="hljs-selector-class">.tree-org-node__children</span> {
          <span class="hljs-attribute">display</span>: flex;
        }
      }
      <span class="hljs-selector-class">.tree-org-node</span> {
        <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>; // 防止盒子被压缩
        <span class="hljs-selector-class">.tree-org-node__text</span> {
          <span class="hljs-attribute">text-align</span>: left;
          <span class="hljs-selector-class">.myb-ellipsis-1</span> {
            <span class="hljs-attribute">max-width</span>: <span class="hljs-number">370px</span>;
            <span class="hljs-attribute">display</span>: inline-block;
          }
          <span class="hljs-selector-class">.no-cursor-pointer</span> {
            <span class="hljs-attribute">cursor</span>: default;
          }
        }
      }
    }
  }
}
// 影藏放大图标
:<span class="hljs-built_in">deep</span>(.zoom-out) {
  <span class="hljs-attribute">display</span>: none;
}
// 影藏缩小图标
:<span class="hljs-built_in">deep</span>(.zoom-in) {
  <span class="hljs-attribute">display</span>: none;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p><strong>END...</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[十分钟搞定Nestjs上传文件到阿里云OSS]]></title>    <link>https://juejin.cn/post/7573234521364168730</link>    <guid>https://juejin.cn/post/7573234521364168730</guid>    <pubDate>2025-11-17T06:00:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573234521364168730" data-draft-id="7573299401045688366" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="十分钟搞定Nestjs上传文件到阿里云OSS"/> <meta itemprop="keywords" content="后端,Node.js"/> <meta itemprop="datePublished" content="2025-11-17T06:00:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="zyfts"/> <meta itemprop="url" content="https://juejin.cn/user/1292681406582968"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            十分钟搞定Nestjs上传文件到阿里云OSS
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1292681406582968/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    zyfts
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:00:30.000Z" title="Mon Nov 17 2025 06:00:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>背景：接到产品需求，需要将运营数据生成excel,再上传到阿里云的oss，再返回可下载的连接。此处使用Nestjs简化操作，放核心代码。</p>
<p>这也是后台系统中常见的操作，现在开始十分钟教大家完成此项功能。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>生成excel</li>
<li>文件上传到阿里云: 使用oss sdk将文件Buffer上传的到oss</li>
<li>整合到Nestjs服务</li>
</ol>
<p><strong>注意事项：</strong> 如果是私有桶，需要获取带签名的下载链接才能正常下载哈。</p>
<p>先浏览下成果</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/724d003d1e4849058de8dc0a7ffdd0c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgenlmdHM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966083&amp;x-signature=L7kFOAAopAa670yE%2BWmDzgk5M%2Fg%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/00537dac9d9240b5a3a8a4741470890d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgenlmdHM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966083&amp;x-signature=3gH%2Fyo108OQpJrukjZ96sLMBbbI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">1. 生成excel</h2>
<p>先安装包<code>pnpm i xlsx</code></p>
<p>生成excel, 这一步比较简单，可直接写在服务里</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">XLSX</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'xlsx'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Buffer</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'buffer'</span>; <span class="hljs-comment">// 明确导入 Buffer</span>

  <span class="hljs-comment">// 创建Excel</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">createExcel</span>(<span class="hljs-params">{ sheetName = <span class="hljs-string">'test1'</span> }: any</span>) {
    <span class="hljs-keyword">const</span> users = [
      { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'张三2'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">'zhangsan@example.com'</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'李四'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">'lisi@example.com'</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'王五'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">'wangwu@example.com'</span> },
    ];
    <span class="hljs-keyword">const</span> worksheet = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">json_to_sheet</span>(users);
    <span class="hljs-comment">// 新建表格</span>
    <span class="hljs-keyword">const</span> workbook = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">book_new</span>();
    <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">book_append_sheet</span>(workbook, worksheet, sheetName);
    <span class="hljs-keyword">const</span> buffer = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-title function_">write</span>(workbook, { <span class="hljs-attr">bookType</span>: <span class="hljs-string">'xlsx'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'buffer'</span> });
    <span class="hljs-keyword">return</span> buffer <span class="hljs-keyword">as</span> <span class="hljs-title class_">Buffer</span>;
  }
</code></pre>
<h2 data-id="heading-1">2. 封装阿里云OSS上传工具函数</h2>
<p>先安装包<code>pnpm i ali-oss</code></p>
<p>在 util 中封装上传函数 oss.util.ts</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">OSS</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ali-oss'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OssUtil</span> {
  private <span class="hljs-keyword">static</span> <span class="hljs-attr">client</span>: <span class="hljs-variable constant_">OSS</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">/**
   * 初始化，必须在应用启动时或首次使用是完成初始化
   * config: 阿里云配置
   */</span>
  public <span class="hljs-keyword">static</span> <span class="hljs-title function_">init</span>(<span class="hljs-attr">config</span>: any): <span class="hljs-keyword">void</span> {
    <span class="hljs-comment">// 如果已初始化，跳过初始化</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">client</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 从配置文件中取oss配置</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">client</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">OSS</span>({
      <span class="hljs-attr">region</span>: config.<span class="hljs-property">region</span>,
      <span class="hljs-attr">accessKeyId</span>: config.<span class="hljs-property">accessKeyId</span>,
      <span class="hljs-attr">accessKeySecret</span>: config.<span class="hljs-property">accessKeySecret</span>,
      <span class="hljs-attr">bucket</span>: config.<span class="hljs-property">bucket</span>,
    });
  }

  <span class="hljs-comment">/**
   * 获取 OSS 客户端实例，如果未初始化则抛出错误
   */</span>
  private <span class="hljs-keyword">static</span> <span class="hljs-title function_">getClient</span>(): <span class="hljs-variable constant_">OSS</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">client</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'OSS 客户端未初始化，请先调用 OssUtil.initialize(config) 方法。'</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">client</span>;
  }

  <span class="hljs-comment">/**
   * 上传文件 Buffer 到阿里云 OSS
   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">objectName</span> - 在 OSS 中的目标路径和文件名 (e.g., 'exports/report_timestamp.xlsx')
   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">buffer</span> - 要上传的文件内容的 Node.js Buffer
   * <span class="hljs-doctag">@returns</span> 包含文件 URL 的 Promise
   */</span>
  public <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">uploadBuffer</span>(<span class="hljs-attr">objectName</span>: string, <span class="hljs-attr">buffer</span>: <span class="hljs-title class_">Buffer</span>): <span class="hljs-title class_">Promise</span>&lt;string&gt; {
    <span class="hljs-keyword">const</span> client = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getClient</span>();

    <span class="hljs-keyword">const</span> <span class="hljs-attr">options</span>: <span class="hljs-variable constant_">OSS</span>.<span class="hljs-property">PutObjectOptions</span> = {
      <span class="hljs-comment">// 如果需要，可以在这里设置 Content-Type, 例如 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'</span>
      <span class="hljs-comment">// headers: { 'Content-Type': 'application/octet-stream' }, </span>
    };

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">put</span>(objectName, buffer, options);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'==== oss.util result: '</span>, result);
      <span class="hljs-comment">// result.url 是文件在 OSS 上的完整访问地址</span>
      <span class="hljs-keyword">return</span> result.<span class="hljs-property">url</span>;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[OSS ERROR] 上传文件 <span class="hljs-subst">${objectName}</span> 失败:`</span>, error);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`文件上传到 OSS 失败: <span class="hljs-subst">${error.message}</span>`</span>);
    }
  }
  
  <span class="hljs-comment">/**
   * 生成带有访问权限的签名 URL
   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">objectName</span> - OSS 中的文件路径和名称
   * <span class="hljs-doctag">@param</span> <span class="hljs-variable">expirationSeconds</span> - 链接的有效期 (秒), 默认 30 天
   * <span class="hljs-doctag">@returns</span> 签名 URL
   */</span>
  public <span class="hljs-keyword">static</span> <span class="hljs-title function_">getSignedUrl</span>(<span class="hljs-attr">objectName</span>: string, <span class="hljs-attr">expirationSeconds</span>: number = <span class="hljs-number">2592000</span>): string {
    <span class="hljs-keyword">const</span> client = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getClient</span>();

    <span class="hljs-keyword">const</span> url = client.<span class="hljs-title function_">signatureUrl</span>(objectName, {
      <span class="hljs-attr">expires</span>: expirationSeconds, <span class="hljs-comment">// 有效期 (秒)</span>
      <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
    });
    <span class="hljs-keyword">return</span> url;
  }
}
</code></pre>
<h3 data-id="heading-2">2.1. 初始化OssUtil</h3>
<p>在main.ts中初始化，然后才能在业务服务中使用</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">OssUtil</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./util/oss.util'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 初始化oss</span>
  <span class="hljs-keyword">const</span> ossConfig = {
    <span class="hljs-attr">region</span>: configService.<span class="hljs-property">get</span>&lt;string&gt;(<span class="hljs-string">'ALIYUN_OSS_REGION'</span>),
    <span class="hljs-attr">accessKeyId</span>: configService.<span class="hljs-property">get</span>&lt;string&gt;(<span class="hljs-string">'ALIYUN_OSS_ACCESS_KEY_ID'</span>),
    <span class="hljs-attr">accessKeySecret</span>: configService.<span class="hljs-property">get</span>&lt;string&gt;(<span class="hljs-string">'ALIYUN_OSS_ACCESS_KEY_SECRET'</span>),
    <span class="hljs-attr">bucket</span>: configService.<span class="hljs-property">get</span>&lt;string&gt;(<span class="hljs-string">'ALIYUN_OSS_BUCKET'</span>),
  };
  <span class="hljs-title class_">OssUtil</span>.<span class="hljs-title function_">init</span>(ossConfig);

}
<span class="hljs-title function_">bootstrap</span>();
</code></pre>
<p>在业务服务中使用，简单示例</p>
<pre><code class="hljs language-csharp" lang="csharp">  <span class="hljs-comment">// 3. 上传到 OSS</span>
  <span class="hljs-keyword">const</span> ossResult = <span class="hljs-keyword">await</span> OssUtil.uploadBuffer(objectName, excelBuffer);
</code></pre>
<h2 data-id="heading-3">3. 整合Service，完成最终上传</h2>
<p>在红果服务中使用生成excel+上传阿里云</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">XLSX</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'xlsx'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Buffer</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'buffer'</span>; <span class="hljs-comment">// 明确导入 Buffer</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">OssUtil</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/util/oss.util'</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HongguoService</span> {
  <span class="hljs-comment">// 业务</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">zyf_create_short_url</span>(<span class="hljs-params">params: any</span>) {
    <span class="hljs-comment">// 1. 创建Excel</span>
    <span class="hljs-keyword">const</span> excelBuffer = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createExcel</span>({ <span class="hljs-attr">sheetName</span>: <span class="hljs-string">'test1'</span> });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'===excelBuffer: '</span>, excelBuffer);

    <span class="hljs-comment">// 2. 上传到 OSS</span>
    <span class="hljs-keyword">const</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();
    <span class="hljs-keyword">const</span> fileName = <span class="hljs-string">`node/test_<span class="hljs-subst">${timestamp}</span>.xlsx`</span>;
    <span class="hljs-comment">// 如果是私有桶，此处返回的连接无法下载，需要获取带签名的下载链接</span>
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">OssUtil</span>.<span class="hljs-title function_">uploadBuffer</span>(fileName, excelBuffer);
    <span class="hljs-comment">// 获取带签名的下载链接（30天有效期）</span>
    <span class="hljs-keyword">const</span> signedUrl = <span class="hljs-title class_">OssUtil</span>.<span class="hljs-title function_">getSignedUrl</span>(fileName);

    <span class="hljs-keyword">return</span> {
      signedUrl
    }
  }

  <span class="hljs-comment">// 创建Excel</span>
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">createExcel</span>(<span class="hljs-params">{ sheetName = <span class="hljs-string">'test1'</span> }: any</span>) {
    <span class="hljs-keyword">const</span> users = [
      { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'张三2'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">'zhangsan@example.com'</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'李四'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">'lisi@example.com'</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'王五'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">'wangwu@example.com'</span> },
    ];
    <span class="hljs-keyword">const</span> worksheet = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">json_to_sheet</span>(users);
    <span class="hljs-comment">// 新建表格</span>
    <span class="hljs-keyword">const</span> workbook = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">book_new</span>();
    <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-property">utils</span>.<span class="hljs-title function_">book_append_sheet</span>(workbook, worksheet, sheetName);
    <span class="hljs-keyword">const</span> buffer = <span class="hljs-variable constant_">XLSX</span>.<span class="hljs-title function_">write</span>(workbook, { <span class="hljs-attr">bookType</span>: <span class="hljs-string">'xlsx'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'buffer'</span> });
    <span class="hljs-keyword">return</span> buffer <span class="hljs-keyword">as</span> <span class="hljs-title class_">Buffer</span>;
  }
  
}
</code></pre>
<p>搞定，控制器就不演示了，直接调这个服务即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/101a430506ef412ba547fe714caaec7b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgenlmdHM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966083&amp;x-signature=Dg52LIqhedSEvfXfhvScAkNNGF0%3D" alt="博客-每天进步一点点.jpg" loading="lazy"/></p>
<p>对你有帮助的话请一键三连哈</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34a4741fe50d44f2a354cf0f42ae3b22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgenlmdHM=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966083&amp;x-signature=L3LqeforHzSNcuuvB24qn%2F0PJng%3D" alt="博客-谢谢.gif" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C# 自动化生成 PowerPoint 演示文稿]]></title>    <link>https://juejin.cn/post/7573172586838966324</link>    <guid>https://juejin.cn/post/7573172586838966324</guid>    <pubDate>2025-11-17T06:04:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573172586838966324" data-draft-id="7572844326390743074" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C# 自动化生成 PowerPoint 演示文稿"/> <meta itemprop="keywords" content="后端,C#"/> <meta itemprop="datePublished" content="2025-11-17T06:04:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户835629078051"/> <meta itemprop="url" content="https://juejin.cn/user/3150554985403516"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C# 自动化生成 PowerPoint 演示文稿
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3150554985403516/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户835629078051
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:04:17.000Z" title="Mon Nov 17 2025 06:04:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f8b694d709a4a77ba48d8e9c53abaa1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3ODM1NjI5MDc4MDUx:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964257&amp;x-signature=Z%2BYhAA%2BUGGL02Bl%2FIU1ks0sh46E%3D" alt="用C#创建PowerPoint演示文稿" loading="lazy"/></p>
<p>在当今快节奏的商业环境中，演示文稿是信息传递和沟通的关键工具。然而，手动创建和更新PowerPoint演示文稿往往耗时且易出错，尤其当需要批量生成或根据动态数据更新内容时，其低效性更是显而易见。对于C#开发者而言，这正是自动化解决方案大展身手之处。通过编程方式生成和操作PowerPoint，我们不仅能显著提升效率，还能确保内容的一致性和精确性。</p>
<p>本文将深入探讨如何利用C#语言结合功能强大的第三方库 <strong>Spire.Presentation for .NET</strong>，从零开始创建、编辑和保存PowerPoint演示文稿。我们将提供详细的步骤指导和可直接运行的代码示例，帮助您掌握自动化生成PPT的核心技术，从而将繁琐的手动工作转化为高效的编程任务。</p>
<h2 data-id="heading-0">环境准备与Spire.Presentation安装</h2>
<p>要开始使用C#进行PowerPoint自动化，我们首先需要引入Spire.Presentation for .NET库。这是一个专业的.NET组件，专为处理PowerPoint文件而设计，提供了丰富的API接口来创建、读取、写入和修改PPT/PPTX文档。</p>
<p><strong>安装步骤：</strong></p>
<ol>
<li><strong>创建C#项目：</strong> 在Visual Studio中创建一个新的C#控制台应用程序或任何您需要的项目类型。</li>
<li><strong>通过NuGet安装Spire.Presentation：</strong>
<ul>
<li>在Visual Studio中，右键点击您的项目，选择“管理NuGet程序包”。</li>
<li>在“浏览”选项卡中搜索“Spire.Presentation”。</li>
<li>找到“Spire.Presentation”包并点击“安装”。</li>
</ul>
</li>
</ol>
<p>安装完成后，您需要在代码文件中添加必要的<code>using</code>声明：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">using</span> Spire.Presentation;
<span class="hljs-keyword">using</span> Spire.Presentation.Drawing;
<span class="hljs-keyword">using</span> Spire.Presentation.Drawing.Shapes;
<span class="hljs-keyword">using</span> System.Drawing; <span class="hljs-comment">// 用于图像处理</span>
<span class="hljs-keyword">using</span> System.IO;    <span class="hljs-comment">// 用于文件操作</span>
</code></pre>
<p><strong>第一个“Hello World”示例：创建并保存空白演示文稿</strong></p>
<p>让我们从一个最简单的例子开始，创建一个空白的演示文稿并将其保存为PPTX文件。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">using</span> Spire.Presentation;
<span class="hljs-keyword">using</span> System.IO;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>
    {
        <span class="hljs-comment">// 创建一个新的演示文稿实例</span>
        Presentation presentation = <span class="hljs-keyword">new</span> Presentation();

        <span class="hljs-comment">// 获取第一张幻灯片（默认会有一张空白幻灯片）</span>
        ISlide slide = presentation.Slides[<span class="hljs-number">0</span>];

        <span class="hljs-comment">// 在幻灯片上添加一个简单的文本框</span>
        IAutoShape shape = slide.Shapes.AppendShape(ShapeType.Rectangle, <span class="hljs-keyword">new</span> RectangleF(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">600</span>, <span class="hljs-number">150</span>));
        shape.Fill.FillType = FillFormatType.None; <span class="hljs-comment">// 无填充</span>
        shape.ShapeStyle.LineColor.Color = Color.White; <span class="hljs-comment">// 无边框</span>

        <span class="hljs-comment">// 设置文本框内容</span>
        shape.TextFrame.Text = <span class="hljs-string">"Hello from C# Automated PowerPoint!"</span>;
        shape.TextFrame.Paragraphs[<span class="hljs-number">0</span>].TextRanges[<span class="hljs-number">0</span>].Fill.FillType = FillFormatType.Solid;
        shape.TextFrame.Paragraphs[<span class="hljs-number">0</span>].TextRanges[<span class="hljs-number">0</span>].Fill.SolidColor.Color = Color.Black;
        shape.TextFrame.Paragraphs[<span class="hljs-number">0</span>].TextRanges[<span class="hljs-number">0</span>].FontHeight = <span class="hljs-number">30</span>;

        <span class="hljs-comment">// 保存到文件系统</span>
        <span class="hljs-built_in">string</span> outputPath = <span class="hljs-string">"MyFirstAutomatedPresentation.pptx"</span>;
        presentation.SaveToFile(outputPath, FileFormat.Pptx2016); <span class="hljs-comment">// 选择保存格式</span>
        Console.WriteLine(<span class="hljs-string">$"演示文稿已保存到: <span class="hljs-subst">{outputPath}</span>"</span>);

        <span class="hljs-comment">// 也可以保存到流</span>
        <span class="hljs-keyword">using</span> (FileStream to_stream = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">"SaveToStream.pptx"</span>, FileMode.Create))
        {
            presentation.SaveToFile(to_stream, FileFormat.Pptx2013);
        }
        Console.WriteLine(<span class="hljs-string">"演示文稿已保存到流: SaveToStream.pptx"</span>);
    }
}
</code></pre>
<h2 data-id="heading-1">核心操作：添加与编辑幻灯片元素</h2>
<p>掌握了基础的创建和保存，接下来我们将深入探讨如何向演示文稿中添加和操作各种元素。</p>
<h3 data-id="heading-2">添加幻灯片</h3>
<p>Spire.Presentation允许您添加空白幻灯片或基于预定义布局的幻灯片。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 添加一张空白幻灯片</span>
ISlide newBlankSlide = presentation.Slides.Append();

<span class="hljs-comment">// 添加一张基于标题和内容布局的幻灯片</span>
<span class="hljs-comment">// 获取布局模板</span>
IMasterSlide master = presentation.Masters[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 通常第一个是默认母版</span>
ISlideLayout titleAndContentLayout = master.SlideLayouts[SlideLayoutType.TitleAndContent];
ISlide newTitleContentSlide = presentation.Slides.Append(titleAndContentLayout);

<span class="hljs-comment">// 设置新幻灯片的标题</span>
ITextBox titleShape = newTitleContentSlide.Shapes.AddAutoShape(ShapeType.Rectangle, <span class="hljs-keyword">new</span> RectangleF(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">900</span>, <span class="hljs-number">100</span>));
titleShape.TextFrame.Text = <span class="hljs-string">"我的第二张幻灯片：标题和内容"</span>;
titleShape.TextFrame.Paragraphs[<span class="hljs-number">0</span>].TextRanges[<span class="hljs-number">0</span>].FontHeight = <span class="hljs-number">40</span>;
titleShape.TextFrame.Paragraphs[<span class="hljs-number">0</span>].TextRanges[<span class="hljs-number">0</span>].Fill.SolidColor.Color = Color.DarkBlue;
</code></pre>
<h3 data-id="heading-3">文本操作</h3>
<p>添加文本框并设置其格式是PPT中最常见的操作之一。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 在第一张幻灯片上添加一个文本框</span>
IAutoShape textBox = presentation.Slides[<span class="hljs-number">0</span>].Shapes.AppendShape(ShapeType.Rectangle, <span class="hljs-keyword">new</span> RectangleF(<span class="hljs-number">50</span>, <span class="hljs-number">200</span>, <span class="hljs-number">600</span>, <span class="hljs-number">100</span>));
textBox.Fill.FillType = FillFormatType.None;
textBox.TextFrame.Text = <span class="hljs-string">"这是一段示例文本，用于演示格式设置。"</span>;

<span class="hljs-comment">// 获取文本段落和文本范围</span>
ITextParagraph paragraph = textBox.TextFrame.Paragraphs[<span class="hljs-number">0</span>];
ITextRange textRange = paragraph.TextRanges[<span class="hljs-number">0</span>];

<span class="hljs-comment">// 设置字体、大小和颜色</span>
textRange.FontHeight = <span class="hljs-number">24</span>;
textRange.Fill.FillType = FillFormatType.Solid;
textRange.Fill.SolidColor.Color = Color.Red;
textRange.LatinFont = <span class="hljs-keyword">new</span> TextFont(<span class="hljs-string">"Arial"</span>); <span class="hljs-comment">// 设置字体</span>

<span class="hljs-comment">// 设置加粗和斜体</span>
textRange.IsBold = <span class="hljs-literal">true</span>;
textRange.IsItalic = <span class="hljs-literal">true</span>;

<span class="hljs-comment">// 文本对齐</span>
paragraph.Alignment = TextAlignmentType.Center;

<span class="hljs-comment">// 添加更多段落</span>
paragraph = textBox.TextFrame.Paragraphs.Append(<span class="hljs-string">"这是第二个段落。"</span>);
paragraph.Alignment = TextAlignmentType.Left;
paragraph.TextRanges[<span class="hljs-number">0</span>].FontHeight = <span class="hljs-number">18</span>;
paragraph.TextRanges[<span class="hljs-number">0</span>].Fill.SolidColor.Color = Color.Green;
</code></pre>
<h3 data-id="heading-4">图片插入</h3>
<p>从文件或流中插入图片，并调整其位置和大小。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 假设图片文件存在</span>
<span class="hljs-built_in">string</span> imagePath = <span class="hljs-string">"sample.png"</span>; <span class="hljs-comment">// 替换为您的图片路径</span>
<span class="hljs-keyword">if</span> (File.Exists(imagePath))
{
    <span class="hljs-comment">// 将图片添加到演示文稿的图片集合中</span>
    IImageData imageData = presentation.Images.Append(File.ReadAllBytes(imagePath));

    <span class="hljs-comment">// 在第二张幻灯片上插入图片</span>
    newTitleContentSlide.Shapes.AddPicture(imageData, <span class="hljs-keyword">new</span> RectangleF(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">400</span>, <span class="hljs-number">300</span>)); <span class="hljs-comment">// 位置和大小</span>
}
<span class="hljs-keyword">else</span>
{
    Console.WriteLine(<span class="hljs-string">$"图片文件 <span class="hljs-subst">{imagePath}</span> 不存在。"</span>);
}
</code></pre>
<h3 data-id="heading-5">形状与图表（示例）</h3>
<p>Spire.Presentation也支持添加各种形状和图表。这里我们以添加一个矩形和简要提及图表为例。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 在第一张幻灯片上添加一个蓝色矩形</span>
IAutoShape rectangle = presentation.Slides[<span class="hljs-number">0</span>].Shapes.AppendShape(ShapeType.Rectangle, <span class="hljs-keyword">new</span> RectangleF(<span class="hljs-number">700</span>, <span class="hljs-number">100</span>, <span class="hljs-number">150</span>, <span class="hljs-number">80</span>));
rectangle.Fill.FillType = FillFormatType.Solid;
rectangle.Fill.SolidColor.Color = Color.Blue;
rectangle.TextFrame.Text = <span class="hljs-string">"自定义形状"</span>;
rectangle.TextFrame.Paragraphs[<span class="hljs-number">0</span>].TextRanges[<span class="hljs-number">0</span>].Fill.SolidColor.Color = Color.White;

<span class="hljs-comment">// 添加一个简单的柱状图 (需要更多数据和配置，这里仅作示意)</span>
<span class="hljs-comment">// IChart chart = presentation.Slides[0].Shapes.AppendChart(ChartType.ColumnClustered, new RectangleF(100, 400, 700, 300));</span>
<span class="hljs-comment">// chart.ChartData[0, 0].Text = "类别 A";</span>
<span class="hljs-comment">// chart.ChartData[1, 0].Text = "系列 1";</span>
<span class="hljs-comment">// ... 更多图表数据和样式配置 ...</span>
</code></pre>
<h2 data-id="heading-6">高级技巧与最佳实践</h2>
<h3 data-id="heading-7">模板应用</h3>
<p>为了保持演示文稿的专业外观和一致性，通常会基于现有模板创建。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 加载一个现有模板文件</span>
<span class="hljs-comment">// string templatePath = "MyTemplate.pptx"; // 替换为您的模板路径</span>
<span class="hljs-comment">// Presentation templatePres = new Presentation();</span>
<span class="hljs-comment">// templatePres.LoadFromFile(templatePath);</span>

<span class="hljs-comment">// // 从模板中创建一个新演示文稿</span>
<span class="hljs-comment">// Presentation newPresentationFromTemplate = new Presentation(templatePres);</span>
<span class="hljs-comment">// // 现在可以在 newPresentationFromTemplate 上进行操作，它会继承模板的样式和母版</span>
</code></pre>
<h3 data-id="heading-8">保存与导出</h3>
<p>除了保存为PPTX文件，Spire.Presentation还支持将演示文稿导出为其他常用格式，例如PDF。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 保存为PDF</span>
<span class="hljs-built_in">string</span> pdfPath = <span class="hljs-string">"OutputPresentation.pdf"</span>;
presentation.SaveToFile(pdfPath, FileFormat.Pdf);
Console.WriteLine(<span class="hljs-string">$"演示文稿已导出为PDF: <span class="hljs-subst">{pdfPath}</span>"</span>);
</code></pre>
<h3 data-id="heading-9">错误处理与资源释放</h3>
<p>在进行文件操作时，错误处理至关重要。同时，确保及时释放资源是一个良好的编程习惯。Spire.Presentation的<code>Presentation</code>对象实现了<code>IDisposable</code>接口，建议使用<code>using</code>语句来确保资源被正确释放。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">using</span> (Presentation presentation = <span class="hljs-keyword">new</span> Presentation())
{
    <span class="hljs-comment">// 执行所有PPT操作</span>
    <span class="hljs-comment">// ...</span>

    presentation.SaveToFile(<span class="hljs-string">"output.pptx"</span>, FileFormat.Pptx2016);
} <span class="hljs-comment">// presentation 对象在此处自动被释放</span>
</code></pre>
<p>对于可能抛出异常的操作，使用<code>try-catch</code>块来捕获和处理错误，以增强程序的健壮性。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">try</span>
{
    <span class="hljs-comment">// 尝试执行某些可能失败的操作，例如加载不存在的文件</span>
    <span class="hljs-comment">// presentation.LoadFromFile("non_existent_file.pptx");</span>
}
<span class="hljs-keyword">catch</span> (FileNotFoundException ex)
{
    Console.WriteLine(<span class="hljs-string">$"文件未找到错误: <span class="hljs-subst">{ex.Message}</span>"</span>);
}
<span class="hljs-keyword">catch</span> (Exception ex)
{
    Console.WriteLine(<span class="hljs-string">$"发生了一个错误: <span class="hljs-subst">{ex.Message}</span>"</span>);
}
</code></pre>
<h2 data-id="heading-10">总结</h2>
<p>本文详细介绍了如何利用C#和Spire.Presentation for .NET库自动化生成和操作PowerPoint演示文稿。从环境搭建到核心元素操作，再到高级技巧和最佳实践，我们提供了实用的代码示例和深入的解释。通过这些技术，C#开发者可以轻松实现批量报告生成、数据可视化演示、动态内容更新等多种PowerPoint自动化需求，极大地提升工作效率和数据呈现的专业度。</p>
<p>掌握PowerPoint自动化，将使您能够将重复性的演示文稿创建工作转化为可编程、可扩展的解决方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java高级面试题及答案]]></title>    <link>https://juejin.cn/post/7573332163387523126</link>    <guid>https://juejin.cn/post/7573332163387523126</guid>    <pubDate>2025-11-17T06:09:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573332163387523126" data-draft-id="7573336057480085510" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java高级面试题及答案"/> <meta itemprop="keywords" content="后端,面试,Java"/> <meta itemprop="datePublished" content="2025-11-17T06:09:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java水解"/> <meta itemprop="url" content="https://juejin.cn/user/2441349519143037"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java高级面试题及答案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2441349519143037/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java水解
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:09:16.000Z" title="Mon Nov 17 2025 06:09:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    19
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">List和Set比较，各自的子类比较</h3>
<p><strong>对比一：</strong> <strong>Arraylist与LinkedList的比较</strong></p>
<p>1、ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高(在内存里是连着放的)。</p>
<p>2、因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。</p>
<p>3、LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。</p>
<p>4、因为LinkedList要移动指针,所以查询操作性能比较低。</p>
<p><strong>适用场景分析：</strong></p>
<p>当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。</p>
<p><strong>对比二：</strong> <strong>ArrayList与Vector的比较</strong></p>
<p>1、Vector的方法都是同步的，是线程安全的，而ArrayList的方法不是，由于线程的同步必然要影响性能。因此，ArrayList的性能比Vector好。<br/>
2、当Vector或ArrayList中的元素超过它的初始大小时，Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样。ArrayList就有利于节约内存空间。</p>
<p>3、大多数情况不使用Vector，因为性能不好，但是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性。</p>
<p>4、Vector可以设置增长因子，而ArrayList不可以。</p>
<p><strong>适用场景分析：</strong></p>
<p>1、Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。</p>
<p>2、如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。</p>
<p><strong>对比三：</strong> <strong>HashSet与TreeSet的比较</strong></p>
<p>1.TreeSet 是二叉树实现的，Treeset中的数据是自动排好序的，不允许放入null值 。</p>
<p>2.HashSet 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束 。</p>
<p>3.HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例。</p>
<blockquote>
<p><strong>篇幅限制下面就只能给大家展示小册部分内容了。整理了一份核心面试笔记包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p>
<blockquote>
<blockquote>
<p><strong>需要全套面试笔记及答案【扫一扫】</strong>                           即可免费获取**</p>
</blockquote>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed34312e67a044408ac1e8b347b6263a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965679&amp;x-signature=zloizXhd%2BEuPR0CbA8diQyNWQr0%3D" alt="c25310b285cd7198a33a66f22a71890.png" loading="lazy"/></p>
</blockquote>
<p><strong>3.1 线程</strong></p>
<p><strong>适用场景分析：</strong></p>
<p>HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</p>
<h3 data-id="heading-1"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>HashMap和ConcurrentHashMap的区别</h3>
<p>1、HashMap不是线程安全的，而ConcurrentHashMap是线程安全的。</p>
<p>2、ConcurrentHashMap采用锁分段技术，将整个Hash桶进行了分段segment，也就是将这个大的数组分成了几个小的片段segment，而且每个小的片段segment上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段segment，然后再在这个片段上面进行插入，而且这里还需要获取segment锁。</p>
<p>3、ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。</p>
<h3 data-id="heading-2"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>JVM的内存结构</h3>
<p>根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p>
<p><strong>1、Java虚拟机栈：</strong></p>
<p>线程私有；每个方法在执行的时候会创建一个栈帧，存储了局部变量表，操作数栈，动态连接，方法返回地址等；每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。</p>
<p><strong>2、堆：</strong></p>
<p>线程共享；被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。</p>
<p><strong>3、方法区：</strong></p>
<p>线程共享；被所有线程共享的一块内存区域；用于存储已被虚拟机加载的类信息，常量，静态变量等。</p>
<p><strong>4、程序计数器：</strong></p>
<p>线程私有；是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。</p>
<p><strong>5、本地方法栈：</strong></p>
<p>线程私有；主要为虚拟机使用到的Native方法服务。</p>
<h3 data-id="heading-3"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>强引用，软引用和弱引用的区别</h3>
<p><strong>强引用：</strong></p>
<p>只有这个引用被释放之后，对象才会被释放掉，只要引用存在，垃圾回收器永远不会回收，这是最常见的New出来的对象。</p>
<p><strong>软引用：</strong></p>
<p>内存溢出之前通过代码回收的引用。软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</p>
<p><strong>弱引用：</strong></p>
<p>第二次垃圾回收时回收的引用，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。</p>
<h3 data-id="heading-4"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>springmvc的核心是什么，请求的流程是怎么处理的，控制反转怎么实现的</h3>
<p><strong>核心：</strong></p>
<p>控制反转和面向切面</p>
<p><strong>请求处理流程：</strong></p>
<p>1、首先用户发送请求到前端控制器，前端控制器根据请求信息(如URL)来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；</p>
<p>2、页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个ModelAndView(模型数据和逻辑视图名)；</p>
<p>3、前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；</p>
<p>4、前端控制器再次收回控制权，将响应返回给用户。</p>
<blockquote>
<p><strong>篇幅限制下面就只能给大家展示小册部分内容了。整理了一份核心面试笔记包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p>
<blockquote>
<blockquote>
<p><strong>需要全套面试笔记及答案【扫一扫】</strong>                           即可免费获取**</p>
</blockquote>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed34312e67a044408ac1e8b347b6263a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965679&amp;x-signature=zloizXhd%2BEuPR0CbA8diQyNWQr0%3D" alt="c25310b285cd7198a33a66f22a71890.png" loading="lazy"/></p>
</blockquote>
<p><strong>控制反转如何实现：</strong></p>
<p>我们每次使用spring框架都要配置xml文件，这个xml配置了bean的id和class。</p>
<p>spring中默认的bean为单实例模式，通过bean的class引用反射机制可以创建这个实例。</p>
<p>因此，spring框架通过反射替我们创建好了实例并且替我们维护他们。</p>
<p>A需要引用B类，spring框架就会通过xml把B实例的引用传给了A的成员变量。</p>
<h3 data-id="heading-5"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>BIO、NIO和AIO的区别</h3>
<p>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p>
<p>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p>
<p>Java AIO： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p>
<p>NIO比BIO的改善之处是把一些无效的连接挡在了启动线程之前，减少了这部分资源的浪费(因为我们都知道每创建一个线程，就要为这个线程分配一定的内存空间)</p>
<p>AIO比NIO的进一步改善之处是将一些暂时可能无效的请求挡在了启动线程之前，比如在NIO的处理方式中，当一个请求来的话，开启线程进行处理，但这个请求所需要的资源还没有就绪，此时必须等待后端的应用资源，这时线程就被阻塞了。</p>
<p><strong>适用场景分析：</strong></p>
<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解，如之前在Apache中使用。</p>
<p>NIO方式适用于连接数目多且连接比较短(轻操作)的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持，如在 Nginx，Netty中使用。</p>
<p>AIO方式使用于连接数目多且连接比较长(重操作)的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持，在成长中，Netty曾经使用过，后来放弃。</p>
<h3 data-id="heading-6"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>为什么要用线程池</h3>
<p><strong>那先要明白什么是线程池</strong></p>
<p>线程池是指在初始化一个多线程应用程序过程中创建一个线程集合，然后在需要执行新的任务时重用这些线程而不是新建一个线程。</p>
<p><strong>使用线程池的好处</strong></p>
<p>1、线程池改进了一个应用程序的响应时间。由于线程池中的线程已经准备好且等待被分配任务，应用程序可以直接拿来使用而不用新建一个线程。</p>
<p>2、线程池节省了CLR 为每个短生存周期任务创建一个完整的线程的开销并可以在任务完成后回收资源。</p>
<p>3、线程池根据当前在系统中运行的进程来优化线程时间片。</p>
<p>4、线程池允许我们开启多个任务而不用为每个线程设置属性。</p>
<p>5、线程池允许我们为正在执行的任务的程序参数传递一个包含状态信息的对象引用。</p>
<p>6、线程池可以用来解决处理一个特定请求最大线程数量限制问题。</p>
<h3 data-id="heading-7"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>悲观锁和乐观锁的区别，怎么实现</h3>
<p>悲观锁：一段执行逻辑加上悲观锁,不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待,直到锁被释放。</p>
<p>乐观锁：一段执行逻辑加上乐观锁,不同线程同时执行时,可以同时进入执行,在最后更新数据的时候要检查这些数据是否被其他线程修改了(版本和执行初是否相同),没有修改则进行更新,否则放弃本次操作。</p>
<p>悲观锁的实现：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">begin</span>;<span class="hljs-operator">/</span><span class="hljs-keyword">begin</span> work;<span class="hljs-operator">/</span><span class="hljs-keyword">start</span> transaction; (三者选一就可以)
<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>查询出商品信息
<span class="hljs-keyword">select</span> status <span class="hljs-keyword">from</span> t_goodswhere id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;
<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span>根据商品信息生成订单
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_orders (id,goods_id) <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>,<span class="hljs-number">1</span>);
<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3.</span>修改商品status为<span class="hljs-number">2</span>
<span class="hljs-keyword">update</span> t_goods <span class="hljs-keyword">set</span> status<span class="hljs-operator">=</span><span class="hljs-number">2</span>;
<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">4.</span>提交事务
<span class="hljs-keyword">commit</span>;<span class="hljs-operator">/</span><span class="hljs-keyword">commit</span> work;
复制代码
AI写代码
</code></pre>
<p>乐观锁的实现：</p>
<pre><code class="hljs language-bash" lang="bash">1.查询出商品信息
select (status,status,version) from t_goodswhere <span class="hljs-built_in">id</span>=<span class="hljs-comment">#{id}</span>
2.根据商品信息生成订单
3.修改商品status为2
update t_goods 
<span class="hljs-built_in">set</span> status=2,version=version+1
<span class="hljs-built_in">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-comment">#{id} and version=#{version};</span>
复制代码
AI写代码
</code></pre>
<h3 data-id="heading-8"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>什么是线程死锁？死锁如何产生？如何避免线程死锁？</h3>
<p><strong>死锁的介绍：</strong></p>
<p>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才释放资源，在此期间，其他线程将不能进入该代码块。当线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。</p>
<p><strong>死锁的产生的一些特定条件：</strong></p>
<p>1、互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放 。</p>
<p>2、请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</p>
<p>3、不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用。</p>
<p>4、循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路(类似于死循环)，造成永久阻塞。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[QGIS开发笔记（五）：qgis加载标记点功能，基础标记数量与性能对比测试]]></title>    <link>https://juejin.cn/post/7573299401045721134</link>    <guid>https://juejin.cn/post/7573299401045721134</guid>    <pubDate>2025-11-17T05:56:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573299401045721134" data-draft-id="7573002274324627502" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="QGIS开发笔记（五）：qgis加载标记点功能，基础标记数量与性能对比测试"/> <meta itemprop="keywords" content="C++"/> <meta itemprop="datePublished" content="2025-11-17T05:56:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="长沙红胖子Qt_长沙创微智科"/> <meta itemprop="url" content="https://juejin.cn/user/1714893872175704"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            QGIS开发笔记（五）：qgis加载标记点功能，基础标记数量与性能对比测试
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1714893872175704/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    长沙红胖子Qt_长沙创微智科
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T05:56:55.000Z" title="Mon Nov 17 2025 05:56:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>  对地图增加标记点、标记图标、线条、图形等等，都是常规通用操作，本篇先实现添加标记点，然后对比点数量性能，同时由于像素大小对性能也有较大印象，测试了1、2像素超大数量绘图时，拽托性能与显示效果。</p>
<br/>
<h2 data-id="heading-1">Demo</h2>
<h3 data-id="heading-2">1000标记点1像素大小</h3>
<p>  <img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/381a78dd2fb34dabb7fdbd12023a7f97~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZW_5rKZ57qi6IOW5a2QUXRf6ZW_5rKZ5Yib5b6u5pm656eR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763963815&amp;x-signature=cG3IHF2cfBeCR0W1eq107WTYt2I%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<p>  Cpu和内存大小：
  <img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8827875138574b0e888010bdd94c80fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZW_5rKZ57qi6IOW5a2QUXRf6ZW_5rKZ5Yib5b6u5pm656eR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763963815&amp;x-signature=yNpzAB%2BwPnxQE3XorH3O3pA1ur4%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<p>  拽托缩放不间断操作的CPU和内存大小：
  <img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd8a04f089d04e8dbe022b01c2accac7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZW_5rKZ57qi6IOW5a2QUXRf6ZW_5rKZ5Yib5b6u5pm656eR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763963815&amp;x-signature=2QotUgkUOnGMh34Xd8jTJzrMJwE%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-3">10000标记点1像素大小</h3>
<p>  <img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e0c7da4cc7654ecda6783ea0a4e94cb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZW_5rKZ57qi6IOW5a2QUXRf6ZW_5rKZ5Yib5b6u5pm656eR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763963815&amp;x-signature=dzepk9bftyVaMfUA9OY2aTrgY%2Bc%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-4">1000标记点2像素大小</h3>
<p>  <img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/723950df01404ef9b55760cd87f757ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZW_5rKZ57qi6IOW5a2QUXRf6ZW_5rKZ5Yib5b6u5pm656eR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763963815&amp;x-signature=JatrM%2Fe7vMQE4mCmb%2Bz9sTRsJxk%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-5">10000标记点2像素大小</h3>
<p>  <img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1f3eb3abc37a4ea3afafa31bba04bfd1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZW_5rKZ57qi6IOW5a2QUXRf6ZW_5rKZ5Yib5b6u5pm656eR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763963815&amp;x-signature=0Uz9i2MwmC6zrbUXRVs7aYEv14k%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<br/>
<h2 data-id="heading-6">QsgVectorLayer</h2>
<h3 data-id="heading-7">概述</h3>
<p>  QgsVectorLayer是QGIS中用于处理矢量数据的核心类，它负责加载、管理和操作各种矢量空间数据（点、线、面等几何类型）。
  其作为矢量数据的容器，连接数据源（如 Shapefile、PostGIS、GeoJSON 等）并提供数据访问接口。加载矢量数据、管理属性表、处理几何对象、实现空间查询等。继承自QgsMapLayer，与QgsRasterLayer共同构成QGIS中两种主要的图层类型。</p>
<h3 data-id="heading-8">数据源连接字符串</h3>
<p>  创建QgsVectorLayer时需要指定数据源字符串（data source string），格式因数据格式而异：
  </p>
<h3 data-id="heading-9">常用驱动（Provider）</h3>
<p>  </p>
<h3 data-id="heading-10">注意事项</h3>
<h4 data-id="heading-11">内存管理</h4>
<p>  QgsVectorLayer对象通常由QgsProject管理，调用 QgsProject::addMapLayer后无需手动删除。</p>
<h4 data-id="heading-12">非线程安全</h4>
<p>  QGIS 核心类（包括QgsVectorLayer）不保证线程安全，避免在非主线程中直接操作。</p>
<h4 data-id="heading-13">性能优化</h4>
<ul>
<li>对大数据集使用空间索引（layer-&gt;createSpatialIndex()）。</li>
<li>批量操作时使用QgsVectorLayerUtils::addFeatures()替代循环添加。</li>
<li>避免频繁调用 commitChanges()，建议批量修改后一次性提交。
  通过QgsVectorLayer，可以在C++中实现QGI 几乎所有矢量数据处理功能，结合QgsGeometry、QgsFeature 等类可完成复杂的空间分析任务。</li>
</ul>
<h3 data-id="heading-14">常用属性和操作</h3>
<h4 data-id="heading-15">构造与初始化</h4>
<p>  通过数据源字符串（URI）、图层名、数据提供者类型构造 QgsVectorLayer。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 加载 Shapefile</span>
QString uri = <span class="hljs-string">"/path/to/data.shp"</span>;
QgsVectorLayer* layer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QgsVectorLayer</span>(uri, <span class="hljs-string">"my_layer"</span>, <span class="hljs-string">"ogr"</span>);
<span class="hljs-keyword">if</span> (!layer-&gt;<span class="hljs-built_in">isValid</span>()) {
    <span class="hljs-comment">// 处理加载失败</span>
}
<span class="hljs-comment">// 添加到地图画布</span>
QgsProject::<span class="hljs-built_in">instance</span>()-&gt;<span class="hljs-built_in">addMapLayer</span>(layer);
</code></pre>
<h4 data-id="heading-16">图层基本信息</h4>
<ul>
<li>geometryType()：返回图层几何类型（QgsWkbTypes::GeometryType）。</li>
<li>crs()：返回图层坐标系（QgsCoordinateReferenceSystem）。</li>
<li>fields()：返回属性字段集合（QgsFields）。</li>
<li>featureCount()：返回要素总数。</li>
</ul>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 图层名称</span>
QString name = layer-&gt;<span class="hljs-built_in">name</span>();

<span class="hljs-comment">// 几何类型（点/线/面等）</span>
QgsWkbTypes::Type geomType = layer-&gt;<span class="hljs-built_in">wkbType</span>();
QString geomTypeName = QgsWkbTypes::<span class="hljs-built_in">displayString</span>(geomType); <span class="hljs-comment">// 如 "Point"</span>

<span class="hljs-comment">// 坐标参考系（CRS）</span>
QgsCoordinateReferenceSystem crs = layer-&gt;<span class="hljs-built_in">crs</span>();
QString crsId = crs.<span class="hljs-built_in">authid</span>(); <span class="hljs-comment">// 如 "EPSG:4326"</span>

<span class="hljs-comment">// 要素总数</span>
<span class="hljs-type">int</span> featureCount = layer-&gt;<span class="hljs-built_in">featureCount</span>();

<span class="hljs-comment">// 空间范围</span>
QgsRectangle extent = layer-&gt;<span class="hljs-built_in">extent</span>();
</code></pre>
<h4 data-id="heading-17">属性表操作</h4>
<p>  属性表由QgsFields管理，每个字段对应QgsField：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 获取所有字段</span>
<span class="hljs-type">const</span> QgsFields&amp; fields = layer-&gt;<span class="hljs-built_in">fields</span>();

<span class="hljs-comment">// 遍历字段</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fields.<span class="hljs-built_in">count</span>(); ++i) {
    <span class="hljs-type">const</span> QgsField&amp; field = fields.<span class="hljs-built_in">at</span>(i);
    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"字段名:"</span> &lt;&lt; field.<span class="hljs-built_in">name</span>() 
             &lt;&lt; <span class="hljs-string">"类型:"</span> &lt;&lt; field.<span class="hljs-built_in">typeName</span>();
}

<span class="hljs-comment">// 根据名称查找字段索引</span>
<span class="hljs-type">int</span> fieldIndex = fields.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">"population"</span>);
</code></pre>
<h4 data-id="heading-18">要素迭代与访问</h4>
<p>  通过QgsFeatureIterator遍历要素：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 获取要素迭代器（默认遍历所有要素）</span>
QgsFeatureIterator it = layer-&gt;<span class="hljs-built_in">getFeatures</span>();

QgsFeature feature;
<span class="hljs-keyword">while</span> (it.<span class="hljs-built_in">nextFeature</span>(feature)) {
    <span class="hljs-comment">// 要素 ID</span>
    QgsFeatureId fid = feature.<span class="hljs-built_in">id</span>();

    <span class="hljs-comment">// 几何对象（转为 WKT 字符串）</span>
    QgsGeometry geom = feature.<span class="hljs-built_in">geometry</span>();
    QString wkt = geom.<span class="hljs-built_in">asWkt</span>();

    <span class="hljs-comment">// 属性值（通过索引或字段名访问）</span>
    QVariant population = feature.<span class="hljs-built_in">attribute</span>(<span class="hljs-string">"population"</span>); <span class="hljs-comment">// 字段名</span>
    QVariant id = feature.<span class="hljs-built_in">attribute</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 字段索引</span>

    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"FID:"</span> &lt;&lt; fid &lt;&lt; <span class="hljs-string">"几何:"</span> &lt;&lt; wkt 
             &lt;&lt; <span class="hljs-string">"人口:"</span> &lt;&lt; population.<span class="hljs-built_in">toInt</span>();
}
</code></pre>
<h4 data-id="heading-19">查询与过滤</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 1. 属性查询（例如：population &gt; 100000）</span>
<span class="hljs-function">QgsExpression <span class="hljs-title">expr</span><span class="hljs-params">(<span class="hljs-string">"\"population\" &gt; 100000"</span>)</span></span>;
<span class="hljs-keyword">if</span> (expr.<span class="hljs-built_in">hasParserError</span>()) {
    <span class="hljs-built_in">qWarning</span>() &lt;&lt; <span class="hljs-string">"表达式错误:"</span> &lt;&lt; expr.<span class="hljs-built_in">parserErrorString</span>();
}

<span class="hljs-function">QgsFeatureRequest <span class="hljs-title">request</span><span class="hljs-params">(expr)</span></span>;
QgsFeatureIterator attrIt = layer-&gt;<span class="hljs-built_in">getFeatures</span>(request);

<span class="hljs-comment">// 2. 空间查询（例如：在指定范围内的要素）</span>
<span class="hljs-function">QgsRectangle <span class="hljs-title">rect</span><span class="hljs-params">(<span class="hljs-number">116.0</span>, <span class="hljs-number">39.0</span>, <span class="hljs-number">117.0</span>, <span class="hljs-number">40.0</span>)</span></span>; <span class="hljs-comment">// 北京附近范围</span>
QgsFeatureRequest spatialRequest;
spatialRequest.<span class="hljs-built_in">setFilterRect</span>(rect);
QgsFeatureIterator spatialIt = layer-&gt;<span class="hljs-built_in">getFeatures</span>(spatialRequest);
</code></pre>
<h4 data-id="heading-20">编辑要素</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 开启编辑</span>
<span class="hljs-keyword">if</span> (!layer-&gt;<span class="hljs-built_in">startEditing</span>()) {
    <span class="hljs-built_in">qWarning</span>() &lt;&lt; <span class="hljs-string">"无法开启编辑模式"</span>;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-comment">// 1. 添加新要素</span>
<span class="hljs-function">QgsFeature <span class="hljs-title">newFeature</span><span class="hljs-params">(layer-&gt;fields())</span></span>;
newFeature.<span class="hljs-built_in">setGeometry</span>(QgsGeometry::<span class="hljs-built_in">fromPointXY</span>(<span class="hljs-built_in">QgsPointXY</span>(<span class="hljs-number">116.4</span>, <span class="hljs-number">39.9</span>))); <span class="hljs-comment">// 点坐标</span>
newFeature.<span class="hljs-built_in">setAttribute</span>(<span class="hljs-string">"name"</span>, <span class="hljs-string">"Beijing"</span>);
newFeature.<span class="hljs-built_in">setAttribute</span>(<span class="hljs-string">"population"</span>, <span class="hljs-number">21540000</span>);
<span class="hljs-keyword">if</span> (!layer-&gt;<span class="hljs-built_in">addFeature</span>(newFeature)) {
    <span class="hljs-built_in">qWarning</span>() &lt;&lt; <span class="hljs-string">"添加要素失败"</span>;
}

<span class="hljs-comment">// 2. 更新现有要素</span>
QgsFeature feature;
<span class="hljs-keyword">if</span> (layer-&gt;<span class="hljs-built_in">getFeature</span>(<span class="hljs-number">1</span>, feature)) { <span class="hljs-comment">// 获取 ID=1 的要素</span>
    feature.<span class="hljs-built_in">setAttribute</span>(<span class="hljs-string">"population"</span>, <span class="hljs-number">22000000</span>);
    <span class="hljs-keyword">if</span> (!layer-&gt;<span class="hljs-built_in">updateFeature</span>(feature)) {
        <span class="hljs-built_in">qWarning</span>() &lt;&lt; <span class="hljs-string">"更新要素失败"</span>;
    }
}

<span class="hljs-comment">// 3. 删除要素</span>
<span class="hljs-keyword">if</span> (!layer-&gt;<span class="hljs-built_in">deleteFeature</span>(<span class="hljs-number">2</span>)) { <span class="hljs-comment">// 删除 ID=2 的要素</span>
    <span class="hljs-built_in">qWarning</span>() &lt;&lt; <span class="hljs-string">"删除要素失败"</span>;
}

<span class="hljs-comment">// 提交编辑（保存修改）</span>
<span class="hljs-keyword">if</span> (!layer-&gt;<span class="hljs-built_in">commitChanges</span>()) {
    <span class="hljs-built_in">qWarning</span>() &lt;&lt; <span class="hljs-string">"提交修改失败:"</span> &lt;&lt; layer-&gt;<span class="hljs-built_in">commitErrors</span>();
    layer-&gt;<span class="hljs-built_in">rollBack</span>(); <span class="hljs-comment">// 回滚</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">"修改已保存"</span>;
}
</code></pre>
<h4 data-id="heading-21">样式设置</h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 从 QML 文件加载样式</span>
<span class="hljs-keyword">if</span> (!layer-&gt;<span class="hljs-built_in">loadNamedStyle</span>(<span class="hljs-string">"/path/to/style.qml"</span>)) {
    <span class="hljs-built_in">qWarning</span>() &lt;&lt; <span class="hljs-string">"加载样式失败"</span>;
}
layer-&gt;<span class="hljs-built_in">triggerRepaint</span>(); <span class="hljs-comment">// 刷新图层</span>
</code></pre>
<br/>
<h2 data-id="heading-22">Demo源码</h2>
<h3 data-id="heading-23">QGisManager.cpp</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QGisManager::addMakerPointToCanvas</span><span class="hljs-params">(QgsMapCanvas * pMapCanvas, <span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, QString baseName, QString name, QString crs, QColor color, <span class="hljs-type">int</span> size)</span>
</span>{
    <span class="hljs-comment">// 步骤一：创建点图层</span>
    QgsVectorLayer *pMarkerLayer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QgsVectorLayer</span>(
                <span class="hljs-built_in">QString</span>(<span class="hljs-string">"Point?crs=%1"</span>).<span class="hljs-built_in">arg</span>(crs),   <span class="hljs-comment">// 坐标系</span>
                name,                               <span class="hljs-comment">// 名称</span>
                <span class="hljs-string">"memory"</span>);
    <span class="hljs-keyword">if</span>(!pMarkerLayer-&gt;<span class="hljs-built_in">isValid</span>())
    {
        LOG &lt;&lt; <span class="hljs-string">"Failed to"</span> &lt;&lt; <span class="hljs-string">"new QgsVectorLayer("</span> &lt;&lt; <span class="hljs-built_in">QString</span>(<span class="hljs-string">"Point?crs=%1"</span>).<span class="hljs-built_in">arg</span>(crs) &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; <span class="hljs-string">"memory)"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// 步骤二：添加属性字段，用于存储标记名称</span>
    <span class="hljs-function">QgsField <span class="hljs-title">nameFiled</span><span class="hljs-params">(baseName, QVariant::String)</span></span>;
    pMarkerLayer-&gt;<span class="hljs-built_in">dataProvider</span>()-&gt;<span class="hljs-built_in">addAttributes</span>({nameFiled});
    pMarkerLayer-&gt;<span class="hljs-built_in">updateFields</span>();

    <span class="hljs-comment">// 步骤三：创建一个点要素</span>
    QgsFeature feature;
    feature.<span class="hljs-built_in">setGeometry</span>(QgsGeometry::<span class="hljs-built_in">fromPointXY</span>(<span class="hljs-built_in">QgsPointXY</span>(x, y)));
    feature.<span class="hljs-built_in">setAttributes</span>(<span class="hljs-built_in">QgsAttributes</span>({name}));

    <span class="hljs-comment">// 步骤四：将要素添加到图层</span>
    pMarkerLayer-&gt;<span class="hljs-built_in">dataProvider</span>()-&gt;<span class="hljs-built_in">addFeature</span>(feature);
    pMarkerLayer-&gt;<span class="hljs-built_in">updateExtents</span>();

    <span class="hljs-comment">// 步骤五：创建配置标记符号</span>
    QgsMarkerSymbol * pMarkerSymbol = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QgsMarkerSymbol</span>();
    pMarkerSymbol-&gt;<span class="hljs-built_in">setColor</span>(color);
    pMarkerSymbol-&gt;<span class="hljs-built_in">setSize</span>(size);

    <span class="hljs-comment">// 步骤六：设置图层渲染器</span>
    QgsSingleSymbolRenderer * pSingleSymbolRenderer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QgsSingleSymbolRenderer</span>(pMarkerSymbol);
    pMarkerLayer-&gt;<span class="hljs-built_in">setRenderer</span>(pSingleSymbolRenderer);


    <span class="hljs-comment">// 步骤七：添加到地图</span>
    QList&lt;QgsMapLayer *&gt; listMapLayer = pMapCanvas-&gt;<span class="hljs-built_in">layers</span>();
    <span class="hljs-keyword">if</span>(!listMapLayer.<span class="hljs-built_in">contains</span>(pMarkerLayer))
    {
        listMapLayer.<span class="hljs-built_in">push_front</span>(pMarkerLayer);
    }
    pMapCanvas-&gt;<span class="hljs-built_in">setLayers</span>(listMapLayer);
    <span class="hljs-comment">//pMapCanvas-&gt;refresh();</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<h3 data-id="heading-24">QGisWidget.cpp</h3>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QGisWidget::test_demo3</span><span class="hljs-params">(QString filePath, <span class="hljs-type">int</span> pointNum)</span>
</span>{
    <span class="hljs-comment">// 步骤一：创建画布层</span>
    QgsMapCanvas *pMapCanvas = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QgsMapCanvas</span>();
    <span class="hljs-comment">// 启用并行渲染</span>
    pMapCanvas-&gt;<span class="hljs-built_in">setParallelRenderingEnabled</span>(<span class="hljs-literal">true</span>);
    <span class="hljs-comment">// 强制始终允许渲染</span>
    pMapCanvas-&gt;<span class="hljs-built_in">setRenderFlag</span>(<span class="hljs-literal">true</span>);

    <span class="hljs-comment">// 步骤二：创建图片数据影像层</span>
    QgsRasterLayer *pLayer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QgsRasterLayer</span>(filePath);
    <span class="hljs-keyword">if</span>(!pLayer-&gt;<span class="hljs-built_in">isValid</span>())
    {
        LOG &lt;&lt; <span class="hljs-string">"Failed to load:"</span> &lt;&lt; filePath;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 步骤三：设置图层进入画布</span>
    pMapCanvas-&gt;<span class="hljs-built_in">setLayers</span>({pLayer});    <span class="hljs-comment">// 并不会影响QgsProject::instance()-&gt;mapLayers()的数量</span>
    <span class="hljs-comment">// 步骤四：设置画布范围</span>
    pMapCanvas-&gt;<span class="hljs-built_in">setExtent</span>(pLayer-&gt;<span class="hljs-built_in">extent</span>());
    <span class="hljs-comment">// 步骤五：刷新画布</span>
    pMapCanvas-&gt;<span class="hljs-built_in">refresh</span>();

    <span class="hljs-comment">// 步骤六：需要拽托移动，则需要QgsMapToolPan，否则无法移动只能滚轮缩放</span>
    QgsMapToolPan *pMapToolPan = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QgsMapToolPan</span>(pMapCanvas);
    pMapCanvas-&gt;<span class="hljs-built_in">setMapTool</span>(pMapToolPan);

    <span class="hljs-comment">// 步骤七：随机生成点，pointNum</span>
    <span class="hljs-type">double</span> step = <span class="hljs-number">1</span>;
    <span class="hljs-type">int</span> col = <span class="hljs-number">100</span>;
    LOG &lt;&lt; <span class="hljs-string">"add"</span> &lt;&lt; pointNum &lt;&lt; <span class="hljs-string">"points,"</span> &lt;&lt; <span class="hljs-string">"step:"</span> &lt;&lt; step &lt;&lt; <span class="hljs-string">", col:"</span> &lt;&lt; col;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; pointNum; index++)
    {

        QGisManager::<span class="hljs-built_in">addMakerPointToCanvas</span>(pMapCanvas,
                                           index % col * step,
                                           index / col * step,
                                           <span class="hljs-string">"point"</span>,
                                           <span class="hljs-built_in">QString</span>(<span class="hljs-string">"point_%1"</span>).<span class="hljs-built_in">arg</span>(index),
                                           <span class="hljs-string">"EPSG:3857"</span>,
                                           Qt::green,
                                           <span class="hljs-number">1</span>);
        LOG &lt;&lt; (index % col * step) &lt;&lt; (index / col * step) &lt;&lt; <span class="hljs-built_in">QString</span>(<span class="hljs-string">"point_%1"</span>).<span class="hljs-built_in">arg</span>(index);
    }

    <span class="hljs-comment">// 布局初始化</span>
    QHBoxLayout *pHBoxLayout = <span class="hljs-built_in">dynamic_cast</span>&lt;QHBoxLayout *&gt;(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">layout</span>());
    <span class="hljs-keyword">if</span>(!pHBoxLayout)
    {
        pHBoxLayout = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>(<span class="hljs-keyword">this</span>);
    }
    pHBoxLayout-&gt;<span class="hljs-built_in">addWidget</span>(pMapCanvas, <span class="hljs-number">1</span>);
    pHBoxLayout-&gt;<span class="hljs-built_in">setMargin</span>(<span class="hljs-number">0</span>);
    <span class="hljs-built_in">setLayout</span>(pHBoxLayout);
}
</code></pre>
<br/>
<h2 data-id="heading-25">工程模板v1.2.0</h2>
<p>  <img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39a6e5fc084447be908f64e2f71c04eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6ZW_5rKZ57qi6IOW5a2QUXRf6ZW_5rKZ5Yib5b6u5pm656eR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763963815&amp;x-signature=Hbz47gZ0Ix7f2umgvTEF5qdV68c%3D" alt="在这里插入图片描述" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[怎么在 Windows 上架 iOS App？跨平台开发者完整实战流程解析]]></title>    <link>https://juejin.cn/post/7573172586839048244</link>    <guid>https://juejin.cn/post/7573172586839048244</guid>    <pubDate>2025-11-17T06:14:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573172586839048244" data-draft-id="7573225720697274420" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="怎么在 Windows 上架 iOS App？跨平台开发者完整实战流程解析"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-17T06:14:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aiopencode"/> <meta itemprop="url" content="https://juejin.cn/user/1898230261493865"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            怎么在 Windows 上架 iOS App？跨平台开发者完整实战流程解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1898230261493865/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aiopencode
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:14:43.000Z" title="Mon Nov 17 2025 06:14:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>过去很长一段时间，“上架 iOS App” 几乎等同于 “必须用 Mac”。
无论是证书生成、应用打包还是上传 IPA，大多数官方工具都严格依赖 macOS。
然而，在如今跨平台开发普及的背景下——Flutter、uni-app、React Native、Cocos、Unity 等框架都支持在 <strong>Windows</strong> 上工作，许多开发团队并没有 Mac 设备，甚至全部成员都在 Windows 环境开发。</p>
<p>那么，<strong>有没有办法在 Windows 完成整个 iOS 上架流程？</strong> 答案是——可以，而且流程已经越来越成熟。</p>
<p>下面从实际开发者视角出发，完整拆解如何在 Windows 环境中完成从 IPA 构建、证书管理、到 App Store 上传的全流程。</p>
<hr/>
<h2 data-id="heading-0">上架流程拆解：Windows 也能覆盖哪些环节？</h2>
<p>无论使用什么系统，iOS 上架流程本质上包括：</p>
<ol>
<li>Apple 开发者账号注册</li>
<li>App ID、证书、描述文件准备</li>
<li>构建 IPA 安装包</li>
<li>上传 IPA 至 App Store Connect</li>
<li>填写元数据、截图、隐私说明</li>
<li>提交审核</li>
</ol>
<p>其中最容易被误以为“需要 Mac”的是 <strong>证书处理</strong> 和 <strong>IPA 上传</strong>。
但这两项已经可以通过跨平台工具来完成。</p>
<hr/>
<h2 data-id="heading-1">在 Windows 开发 iOS 项目：跨平台框架是关键</h2>
<p>要想在 Windows 上最终拿到可上传的 IPA 文件，一般会依靠跨平台打包方式。</p>
<h3 data-id="heading-2">1. uni-app（HBuilderX 云打包）</h3>
<p>开发者直接上传项目到云端即可完成打包，无需本地 Xcode。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a337b1862844bf6b7da2cc9a358e065~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWlvcGVuY29kZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964883&amp;x-signature=2ohGoPUVykTgTQhFdW9NOH9cPcY%3D" alt="hb打包" loading="lazy"/></p>
<h3 data-id="heading-3">2. Flutter</h3>
<p>可使用如下云构建服务：</p>
<ul>
<li>Codemagic</li>
<li>Bitrise</li>
<li>Appflow</li>
<li>GitHub Actions（远程 Mac 构建镜像）</li>
</ul>
<p>这些服务能自动产出 iOS Release IPA。</p>
<h3 data-id="heading-4">3. React Native / Ionic / Capacitor</h3>
<p>类似方式也支持云构建产物（expo build / CI 构建）。</p>
<h3 data-id="heading-5">4. Unity / Cocos Creator</h3>
<p>通过导出工程并结合远程构建服务，也能生成 IPA 文件。</p>
<p>综上，<strong>在 Windows 生成 IPA 已经不是难点</strong>，只要选择匹配的构建方式即可。</p>
<hr/>
<h2 data-id="heading-6">证书与描述文件：在 Windows 如何完成？</h2>
<p>过去开发者必须：</p>
<ul>
<li>打开 Mac 钥匙串助手</li>
<li>生成 CSR</li>
<li>创建 p12</li>
<li>下载描述文件</li>
</ul>
<p>这个流程本质上与系统绑定，所以很多人误以为必须用 Mac。</p>
<h3 data-id="heading-7">如今的替代方案：开心上架（Appuploader）跨平台处理证书</h3>
<p>新版开心上架支持：</p>
<ul>
<li>创建 iOS 发布证书</li>
<li>创建 iOS 开发证书</li>
<li>创建描述文件</li>
<li>自动绑定 Apple Developer 账号
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7bfb800ea284a1d82d78bf9b80cdc6e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWlvcGVuY29kZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964883&amp;x-signature=VGEQlodB17AVj23%2Fdya7Kadw450%3D" alt="证书" loading="lazy"/></li>
</ul>
<p>它能在 Windows、Linux、macOS 全平台使用，不依赖钥匙串助手。</p>
<p>这意味着：<strong>即使全团队没有一台 Mac，也能完成证书体系搭建</strong>。</p>
<hr/>
<h2 data-id="heading-8">四、在 Windows 上传 IPA：使用开心上架命令行（免 Mac）</h2>
<p>上传 IPA 是很多开发者最关心的地方，因为官方工具全部被限制在 Mac 上：</p>
<ul>
<li>Xcode Organizer</li>
<li>Transporter</li>
<li>altool（已弃用）</li>
</ul>
<p>但苹果的上传接口并不限制操作系统，只要使用正确协议即可。</p>
<h3 data-id="heading-9">开心上架 CLI：真正实现全平台上传 IPA</h3>
<p>命令示例：</p>
<pre><code class="hljs language-bash" lang="bash">appuploader_cli -u ios@team.com -p xxx-xxx-xxx-xxx -c 2 -f ./build/MyApp.ipa
</code></pre>
<p>参数说明：</p>

























<table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-u</code></td><td>Apple 开发者账号</td></tr><tr><td><code>-p</code></td><td>App 专用密码</td></tr><tr><td><code>-c</code></td><td>上传通道（1 旧协议 / 2 新协议）</td></tr><tr><td><code>-f</code></td><td>需要上传的 IPA 文件</td></tr></tbody></table>
<p>功能特点：</p>
<ul>
<li>Windows / Linux / macOS 均可运行</li>
<li>支持新旧两种上传通道</li>
<li>上传稳定，日志详细</li>
<li>不携带本机设备信息</li>
<li>可结合 CI/CD 自动化运行</li>
</ul>
<p>上传完成后，构建会自动出现在：</p>
<ul>
<li>TestFlight</li>
<li>“App Store → 构建版本”</li>
</ul>
<p>开发者只需在 App Store Connect 中继续配置信息即可。</p>
<hr/>
<h2 data-id="heading-10">五、App Store Connect 配置：网页端即可完成</h2>
<p>应用上传后，需要配置：</p>
<ul>
<li>应用描述</li>
<li>隐私政策网址</li>
<li>权限说明</li>
<li>截图（不同设备尺寸）</li>
<li>App 信息与关键词</li>
<li>版本号、构建版本选择</li>
</ul>
<p>这些都在网页端操作，与系统无关，Windows 完全可以处理。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1239eaa513ac4c069548728cb72f9701~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYWlvcGVuY29kZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763964883&amp;x-signature=eK10%2BP2IlImIvPUAmv5nA6IDh1s%3D" alt="asc" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-11">六、真实开发者的典型 Windows 上架流程示例</h2>
<p>某团队的完整流程大致如下：</p>
<ol>
<li>
<p><strong>在 Windows 中使用 uni-app/HBuilderX 开发项目</strong></p>
</li>
<li>
<p><strong>云打包生成 IPA 文件</strong></p>
</li>
<li>
<p><strong>通过 Appuploader CLI 生成证书</strong></p>
</li>
<li>
<p><strong>执行上传命令，将 IPA 上传至 App Store：</strong></p>
<pre><code class="hljs language-sql" lang="sql">appuploader_cli <span class="hljs-operator">-</span>u dev<span class="hljs-variable">@icloud</span>.com <span class="hljs-operator">-</span>p xxx <span class="hljs-operator">-</span>c <span class="hljs-number">2</span> <span class="hljs-operator">-</span>f .<span class="hljs-operator">/</span><span class="hljs-keyword">release</span><span class="hljs-operator">/</span>app.ipa
</code></pre>
</li>
<li>
<p><strong>在 App Store Connect 配置元数据与截图</strong></p>
</li>
<li>
<p><strong>提交审核并等待通过</strong></p>
</li>
</ol>
<p>整个流程无需任何一台 Mac，即可完成上架。</p>
<hr/>
<h2 data-id="heading-12">七、Windows 上架的常见问题与解决方案</h2>



































<table><thead><tr><th>问题</th><th>原因</th><th>解决方法</th></tr></thead><tbody><tr><td>上传失败（Invalid Credentials）</td><td>用了登录密码</td><td>必须使用 “App 专用密码”</td></tr><tr><td>构建不显示</td><td>Bundle ID 不匹配</td><td>重新检查证书与项目配置</td></tr><tr><td>隐私合规被拒</td><td>权限用途描述缺失</td><td>Info.plist 必须补充说明</td></tr><tr><td>IPA 上传断线</td><td>网络不稳定</td><td>用 <code>-c 2</code> 新通道更稳</td></tr><tr><td>审核慢/被拒</td><td>元数据不准确</td><td>确保截图与功能一致</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-13">八、CI/CD 自动化发布：Windows 也能全自动上架</h2>
<p>大型项目往往需要自动化流水线，例如：</p>
<ul>
<li>GitLab CI</li>
<li>GitHub Actions</li>
<li>Jenkins</li>
</ul>
<p>示例自动化流程：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 构建 IPA（由云端构建服务完成）</span>
<span class="hljs-comment"># 下载构建产物后上传：</span>

appuploader_cli -u ios@team.com -p xxx-xxx-xxx-xxx -c 2 -f ./build/MyApp.ipa
</code></pre>
<p>这样，不管项目成员使用什么设备，都能共享统一的发布流程。</p>
<hr/>
<h2 data-id="heading-14">Windows 完全可以独立完成 iOS 上架</h2>
<p>通过云打包 + 跨平台证书工具 + 跨平台上传工具的组合，开发者已经不再被操作系统限制。</p>
<p>今天的 iOS 发布流程可以这样描述：</p>
<ul>
<li><strong>开发不依赖 Mac</strong></li>
<li><strong>打包不依赖 Mac</strong></li>
<li><strong>证书生成不依赖 Mac</strong></li>
<li><strong>上传不依赖 Mac</strong></li>
<li><strong>审核更不依赖 Mac</strong></li>
</ul>
<p>对于跨系统团队来说，这样的流程既减少硬件依赖，又提高协作效率。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[通过接口获取携程酒店详情数据的技术实现]]></title>    <link>https://juejin.cn/post/7573310642958942246</link>    <guid>https://juejin.cn/post/7573310642958942246</guid>    <pubDate>2025-11-17T06:15:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573310642958942246" data-draft-id="7572961448538210331" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="通过接口获取携程酒店详情数据的技术实现"/> <meta itemprop="keywords" content="API"/> <meta itemprop="datePublished" content="2025-11-17T06:15:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="电商api2467742810"/> <meta itemprop="url" content="https://juejin.cn/user/2147781265591291"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            通过接口获取携程酒店详情数据的技术实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2147781265591291/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    电商api2467742810
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:15:24.000Z" title="Mon Nov 17 2025 06:15:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h3 data-id="heading-0"> 技术分享：</h3>
<p>在开发旅游类应用时，整合酒店数据是常见需求。本文将以技术视角探讨如何通过接口获取携程平台的酒店详情数据（注：实际商用需获得官方授权）。</p>
<hr/>
<h4 data-id="heading-1">一、接口调用基础</h4>
<ol>
<li>
<p><strong>认证机制</strong><br/>
通常需要申请<code>access_token</code>，每次请求需携带认证参数：</p>
<pre><code class="hljs language-ini" lang="ini">GET /hotel/detail?<span class="hljs-attr">hotel_id</span>=H123456 HTTP/<span class="hljs-number">1.1</span>
Authorization: Bearer your_access_token
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
</li>
<li>
<p><strong>请求参数</strong><br/>
核心参数包括：</p>
<ul>
<li><code>hotel_id</code>：酒店唯一标识</li>
<li><code>check_in</code>：入住日期（格式：<code>YYYY-MM-DD</code>）</li>
<li><code>check_out</code>：离店日期</li>
</ul>
</li>
</ol>
<hr/>
<h4 data-id="heading-2">二、响应数据结构示例</h4>
<p>典型JSON响应包含多层嵌套数据：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"hotel_name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"上海外滩悦榕庄"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"address"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"上海市虹口区中山北路88号"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"rating"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4.8</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"rooms"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"room_type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"豪华江景房"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"price"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1588</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"facilities"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"WIFI"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"早餐"</span><span class="hljs-punctuation">]</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<hr/>
<h4 data-id="heading-3">三、Python调用示例</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_ctrip_hotel_detail</span>(<span class="hljs-params">hotel_id, access_token</span>):
    url = <span class="hljs-string">"https://api.ctrip.com/hotel/detail"</span>
    headers = {<span class="hljs-string">"Authorization"</span>: <span class="hljs-string">f"Bearer <span class="hljs-subst">{access_token}</span>"</span>}
    params = {
        <span class="hljs-string">"hotel_id"</span>: hotel_id,
        <span class="hljs-string">"check_in"</span>: <span class="hljs-string">"2023-12-01"</span>,
        <span class="hljs-string">"check_out"</span>: <span class="hljs-string">"2023-12-03"</span>
    }
    
    <span class="hljs-keyword">try</span>:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        <span class="hljs-keyword">return</span> response.json()[<span class="hljs-string">'data'</span>]
    <span class="hljs-keyword">except</span> requests.exceptions.HTTPError <span class="hljs-keyword">as</span> err:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"接口调用失败: <span class="hljs-subst">{err}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># 示例调用</span>
hotel_data = fetch_ctrip_hotel_detail(<span class="hljs-string">"H123456"</span>, <span class="hljs-string">"your_access_token"</span>)
<span class="hljs-built_in">print</span>(hotel_data[<span class="hljs-string">'hotel_name'</span>])
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<hr/>
<h4 data-id="heading-4">四、常见问题处理</h4>
<ol>
<li>
<p><strong>限流应对</strong><br/>
建议实现请求队列控制，确保每秒请求数不超过接口限制：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Semaphore

semaphore = Semaphore(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 限制并发数</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">safe_request</span>():
    <span class="hljs-keyword">with</span> semaphore:
        <span class="hljs-comment"># 执行请求</span>
        time.sleep(<span class="hljs-number">0.2</span>)  <span class="hljs-comment"># 主动延迟</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
</li>
<li>
<p><strong>数据更新策略</strong><br/>
酒店价格动态变化，建议采用：</p>
<ul>
<li>定时任务更新（如每30分钟）</li>
<li>缓存机制减少重复请求</li>
</ul>
</li>
</ol>
<hr/>
<h4 data-id="heading-5">五、合规建议</h4>
<ol>
<li>商用场景需通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fopen.ctrip.com%2F" title="https://open.ctrip.com/" target="_blank" ref="nofollow noopener noreferrer">携程开放平台</a>申请正式接入</li>
<li>遵守数据使用条款，禁止存储敏感用户信息</li>
<li>对于个人开发者，可考虑使用公开数据源替代（如政府开放平台的酒店备案数据）</li>
</ol>
<p>  <a href="https://link.juejin.cn?target=https%3A%2F%2Fo0b.cn%2Fevan" title="https://o0b.cn/evan" target="_blank" ref="nofollow noopener noreferrer">  如有任何疑问，欢迎大家留言探讨。</a></p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI编程从入门到精通]]></title>    <link>https://juejin.cn/post/7573300346262159414</link>    <guid>https://juejin.cn/post/7573300346262159414</guid>    <pubDate>2025-11-17T06:16:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573300346262159414" data-draft-id="7573187591224475702" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI编程从入门到精通"/> <meta itemprop="keywords" content="代码规范,后端,前端"/> <meta itemprop="datePublished" content="2025-11-17T06:16:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="花生Peadar"/> <meta itemprop="url" content="https://juejin.cn/user/3227821867563735"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI编程从入门到精通
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3227821867563735/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    花生Peadar
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:16:46.000Z" title="Mon Nov 17 2025 06:16:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读30分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>❌ 错误的 AI 编程：告诉 AI 要做什么，AI 写代码，发现完全没法用</p>
<p>✅ 正确的 AI 编程：与 AI 共同迭代 PRP，AI 连续编程数小时，<strong>一发入魂</strong>！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f08026b9aea4f28be597b124b1f4f2f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iqx55SfUGVhZGFy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965006&amp;x-signature=z9zYkalVd3p%2FktyQYRQ9HENVNqU%3D" alt="不正确使用AI编程" loading="lazy"/></p>
<p>你可能从未接触过 AI 编程工具，也可能已经尝试过 AI 编程但是碰了一鼻子灰，不论哪种群体，本文足以扫清你对于 AI 编程的所有阻碍，让你足以驾驭最先进的 AI 工具，提升 3x 生产力！</p>
<ol>
<li>具体实操步骤：<strong>全面拥抱业界最佳实践！</strong></li>
<li>AI 编程方法论：<strong>知其然，也知其所以然！</strong></li>
<li>团队如何全面拥抱 AI：<strong>下个季度的KPI有了！</strong></li>
</ol>
<p>全文上万字，前百度现某宇宙厂工程师倾力打造，历经数月业务实践沉淀！</p>
<h2 data-id="heading-0">AI 编程</h2>
<h3 data-id="heading-1">正确的方法论</h3>
<p>我理解在当今碎片化的时代大家都很急，笔者<strong>能不能不卖关子，直接告诉我</strong>正确的 AI 编程流程是什么</p>
<p>当然可以！下面是开发一个需求的 AI 编程业界最佳实践：</p>
<ol>
<li>将自己的需求写出一份 initial.md</li>
<li>让 AI 根据 initial.md 生成一份 PRP</li>
<li>AI 阅读规则文件、项目总览文件、项目代码、外部信息源，收集必要的信息，产出 PRP</li>
<li>开发者理解 PRP，与 AI 一同迭代 PRP，直至完美</li>
<li>AI 花费大概一小时时间，自主编程和测试，完成 PRP</li>
<li>此时功能已经基本可用</li>
<li>开发者介入，与 AI 进行小修小补，跑完最后一公里</li>
</ol>
<p>本文接下来将会一步一步的讲解上述的各个步骤的原理和实操过程，但是有一点我必须要强调：</p>
<blockquote>
<p>AI 编程<em><strong>并不是</strong></em>一个开箱即用的美图秀秀一般的工具，它更像 Photoshop、VS Code 这种专业工具，需要一定的理论基础和学习，用起来才能得心应手</p>
</blockquote>
<p>对于这种专业工具，虽然它不如学习一门语言一样困难，但是也不是一天学习或一次尝试就可以掌握的。我经常被问到“有没有什么方法可以快速让团队接入，让大家先用起来，提升生产力”，答案显然是没有的。AI 编程是需要一定的基础知识和学习才能掌握的</p>
<h3 data-id="heading-2">所需要的基础知识</h3>
<p>首先我们改个名字，不叫 AI 编程了，目前业界的主流叫法叫做 Vibe Coding （氛围编程）.那么为了驾驭 Vibe Coding 工具，你需要了解 LLM 的基础知识和 PE 技巧，比如说如果下面的概念你都理解，那么你就拥有了足够的基础知识：</p>
<ul>
<li>令牌（Token）</li>
<li>上下文窗口（Context Window）</li>
<li>系统和用户提示词（System / User Prompt）</li>
<li>少样本提示（Few-shot Prompting）</li>
</ul>
<p>不了解也没关系，笔者写过另一篇文章，专门介绍 LLM 各种基础知识，请移步 -&gt; <a href="https://juejin.cn/post/7288607375731818553" target="_blank" title="https://juejin.cn/post/7288607375731818553">juejin.cn/post/728860…</a></p>
<p>可以说 PE（Prompt Engineering） 是 Vibe Coding 的语言。字母都不认识的人，自然无法也写出文章</p>
<h3 data-id="heading-3">最好的工具</h3>
<p>目前大概有两种类型的工具可供选择</p>























<table><thead><tr><th>类型</th><th>说明</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>开源方案</td><td>使用开源的工具（如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcline.bot%2F" target="_blank" title="https://cline.bot/" ref="nofollow noopener noreferrer">Cline</a>），配合自购LLM API (如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fopenrouter.ai%2F" target="_blank" title="https://openrouter.ai/" ref="nofollow noopener noreferrer">OpenRouter</a>)</td><td>功能迭代快，适合喜欢折腾的高级用户可以根据需求灵活切换模型</td><td>需要手动配置按 Token 计费价格较贵，长期使用个人几乎无法承担，需要有团队预算</td></tr><tr><td>商业化方案</td><td>自购或团队采购成熟的商业化方案，比如 Claude Code，Codex，Cursor</td><td>功能成熟，使用体验极佳高频使用情况下，总成本十分便宜</td><td>无法切换模型，和某个供应商绑死</td></tr></tbody></table>
<p>开源 Agent 的选择可以参考下面的流行度排行：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4eac99f230664892a471dff33391c842~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iqx55SfUGVhZGFy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965006&amp;x-signature=WyDEwnCTpdCHY7xtedvGCYOreik%3D" alt="img" loading="lazy"/></p>
<p>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenrouter.ai%2Frankings%23apps" target="_blank" title="https://openrouter.ai/rankings#apps" ref="nofollow noopener noreferrer">LLM Rankings | OpenRouter</a>）</p>
<p>新手建议从 Cline 开始，学成之后开始长期使用时，切换成 Claude Code</p>
<blockquote>
<p>扩展阅读：</p>
<p>Roo Code 是从 Cline 派生而来，而 Kilo Code 是 Roo Code 派生而来</p>
</blockquote>
<p>这里本来想点名几个比较糟糕的工具，但是担心有点风险，因此还是仅仅简单写一写什么样的工具不适合用来做全自动的 Vibe Coding 吧：</p>
<ul>
<li>有强硬的对话限制（最常见）。很多工具因为成本原因，自动对话有强硬的时间或Token限制，不论开发任务是否完成，超过一定时间会自动停止编程</li>
<li>是助手而不是全全能代理。很多工具仅仅能做基本的对话和代码修改建议，没办法从0开发一个大功能，这种工具实际上更像是一个编程助手，而不是可以全自动的代理</li>
<li>内置 Prompt 糟糕。如果你发现你模型用到很好的模型，比如说 Claude，但是 LLM 还是不听话，那么可能是工具本身的 Prompt 很糟糕。或者你发现每次压缩，上下文都会丢失的非常夸张，LLM 完全不记得之前要干嘛，那么也可能是 Prompt 太糟糕                     |</li>
</ul>
<p>部分工具可以选择模型，接下来是模型的推荐：</p>
<ol>
<li><strong>Claude Sonnet 4.5</strong> （需要科学）</li>
<li>Grok Code Fast 1（需要科学）</li>
<li>Qwen3 Coder （千问，国内模型）</li>
</ol>
<p>下面是 Cline 官方指南推荐的模型：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9718aba9370b4227829b14a28934a9b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iqx55SfUGVhZGFy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965006&amp;x-signature=AMRp7smiKyTWuesRKG9w%2FtWcswg%3D" alt="img" loading="lazy"/></p>
<p>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.cline.bot%2Fgetting-started%2Fmodel-selection-guide" target="_blank" title="https://docs.cline.bot/getting-started/model-selection-guide" ref="nofollow noopener noreferrer">Model Selection Guide - Cline</a>）</p>
<p>你也可以根据你使用的工具，选择最多人选择的模型。如下图是 Cline 的模型使用情况：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d97876c15df9459899f601d2aefc404b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iqx55SfUGVhZGFy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965006&amp;x-signature=guj4DA8Q2PMkdZFN4s%2FFpgQuIGM%3D" alt="img" loading="lazy"/></p>
<p>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fopenrouter.ai%2Fapps%3Furl%3Dhttps%253A%252F%252Fkilocode.ai%252F%25EF%25BC%2589" target="_blank" title="https://openrouter.ai/apps?url=https%3A%2F%2Fkilocode.ai%2F%EF%BC%89" ref="nofollow noopener noreferrer">openrouter.ai/apps?url=ht…</a></p>
<blockquote>
<p>注意：</p>
<p>模型和工具的推荐有时效性，建议读者点击本文提供的原链接，自行查看当今什么最流行</p>
</blockquote>
<h3 data-id="heading-4">具体怎么配置环境？</h3>
<p>我们这次使用的环境如下，推荐读者安装配置相同的环境</p>

























<table><thead><tr><th>类别</th><th>选择</th><th>安装 / 配置步骤</th></tr></thead><tbody><tr><td>编程工具</td><td>VS Coding</td><td>下载安装 VS Code</td></tr><tr><td>Vibe Coding 工具</td><td>Cline</td><td>打开 VS Code 插件，搜索 <code>cline</code> 安装</td></tr><tr><td>模型 &amp; 提供商</td><td>千问3 - 阿里云</td><td>打开下面的链接，生成一个 akhttps://bailian.console.aliyun.com/?tab=model#/api-key</td></tr></tbody></table>
<p>然后在 VS Code 界面打开 Cline 配置，配置如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/deb8d10269ca45a9babdf4fb1e53fff5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iqx55SfUGVhZGFy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965006&amp;x-signature=rbMvIRT4eOhWizAQ7h9LdEatLjc%3D" alt="img" loading="lazy"/></p>
<p>（Cline 配置）</p>
<p>回到 Cline 主界面，测试一下，能收到来自 LLM 的回复即成功：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/afc3d5e2ac144a6e9570a9529ed8b131~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iqx55SfUGVhZGFy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965006&amp;x-signature=CBPUXn3WBi9pQdMAI5W8%2BAGBIbw%3D" alt="img" loading="lazy"/></p>
<p>（Cline 回复你好）</p>
<p>至此，我们的 Vibe Coding 工具配置已经完成。接下来是本文的核心——如何正确的使用工具。如何使用工具非常重要，就像一台相机，有人可以拍出精妙绝伦的照片，而有的人却怎么拍都不好看</p>
<p>工具的选择只是第一步，重点在于如何使用工具</p>
<h2 data-id="heading-5">上下文管理</h2>
<p>这里介绍一个非常重要的概念——上下文管理（Context Engineering）。良好上下文管理是 Vibe Coding 不可或缺的一部分</p>
<p>LLM 的行为和人类非常类似。现在我们情景模拟一下：</p>
<blockquote>
<p>你刚刚加入公司，现在被要求修改一个线上项目的 Bug，你要怎么做？</p>
</blockquote>
<p>首先，你确实对于这个项目本身一无所知，根本无法动手写代码对吧？你至少需要：</p>
<ol>
<li>了解项目：你需要知道这个项目是干嘛的，用了什么技术栈，怎么跑起来，怎么测试等等。你需要确保你对于项目有个大致理解，不能说我们在修复一个数据库问题，你放着已有的 MySQL 不用，新拉起了一个 MangoDB</li>
<li>明确你的任务：你需要了解这个 Bug，比如说 Bug 的预期和现状是什么，修改后是不是会影响其他模块等等。确保你实际修改的时候是正确的</li>
</ol>
<p>类似的，上下文管理主要解决两个问题：</p>
<ol>
<li>低成本、快速地获取到 LLM 需要的上下文</li>
<li>确保 LLM 编程时，上下文窗口里面的内容尽可能都是 LLM 需要的</li>
</ol>
<p>假设我们现在让 LLM 修复一个购物车功能相关的 Bug，下面有两个 LLM 和它们的上下文窗口：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9447b0232f754b3eb7e0058259148bca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iqx55SfUGVhZGFy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965006&amp;x-signature=IT0K7Lkuiggyt6QiJqTbaWT2yxU%3D" alt="img" loading="lazy"/></p>
<p>很显然，第二个 LLM 的上下文窗口都是和购物车 Bug 无关的内容，那么在实际编辑代码时，第二个 LLM 更容易产出错误的代码、使用不存在的模块、重复造轮子</p>
<h3 data-id="heading-6">项目上下文</h3>
<h4 data-id="heading-7">项目总览文档</h4>
<p>一般来说，引入 Vibe Coding 的仓库需要维护一个<em><strong>项目总览文档</strong></em>，并提交进 git。该文件主要由 LLM 生成维护，也主要供 LLM 阅读，通常包含：项目的业务背景、技术栈、各个模块说明、环境说明，等等各种需要动手写代码前最好都了解的信息</p>
<p>这是目前业界的普遍的实践，有和没有项目总览文档的区别非常大！它可以有效的帮助 LLM 来</p>
<ul>
<li>完成任务更加迅速，且节约 Token</li>
<li>可以更加有效的复用代码，而不是重新造轮子</li>
<li>该文件可以跨工具跨模型使用</li>
</ul>
<p>推荐将项目总览文档放到 <code>vibe/getting-started.md</code></p>
<blockquote>
<p>扩展阅读：</p>
<p>部分工具也提供项目总览文件的自动维护，比如 Serena MCP。但是由于这个文件通常需要跨工具跨模型使用，因此单独建立维护是有必要的</p>
</blockquote>
<h4 data-id="heading-8">链接文档和工具</h4>
<p>大部分工具都支持 Rule 文件，该文件是一个每次任务开始前都会注入给 LLM 的文件</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/064766baab9f456b9872f6c6688af065~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Iqx55SfUGVhZGFy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965006&amp;x-signature=ytWUSgS%2FYBLcxw048Xv69pvGIBg%3D" alt="img" loading="lazy"/></p>
<p>（Cline 中添加 <em>Rule 文件</em>）</p>
<p>我们需要在 Rule 文件里面明确要求 LLM：</p>
<ol>
<li>任务开始时，读取项目总览文档</li>
<li>任务结束时，根据情况，更新项目总览文档</li>
</ol>
<p>下面是一个简化版示例 Prompt。将它添加进 <em>Rule 文件</em> 里面，这样 LLM 就可以自动的读取和维护该文件了</p>
<pre><code class="hljs language-Plain" lang="Plain">## 项目总览文档

我们的项目总览文档在 `vibe/getting-started.md`

每当开始进行任何任务时，你永远会在任务开始前阅读这个文件。同时，每当任何任务结束前，你也需要检查这个文件，评估是否需要将本次改动更新进改文件
</code></pre>
<blockquote>
<p>该 Prompt 仅仅为一个简化版示例，本文的末尾提供了一个完整模板，读者可以直接克隆，里面包含了完整的 Prompt 的文件目录</p>
</blockquote>
<h4 data-id="heading-9">生成/更新项目总览文档</h4>
<p>为了生成和更新项目总览文件，推荐定义一个任务说明，描述如何生成或更新该文件。当开发者发现该文件过时时，或者第一次生成项目总览文件，可以运行该任务，LLM将会自动的生成/更新项目总览文档。下面是一个任务描述的简化版示例 Prompt：</p>
<pre><code class="hljs language-Plain" lang="Plain">## 任务 - 生成/更新项目总览文档

接下来你需要生成/更新我们的项目总览文档 `vibe/getting-started.md`

- 如果改文档已经存在，你需要阅读它，然后更新，去重。确保其内容实时性和有效性
- 如果改文档不存在，你需要创建它

你需要阅读必要的代码和项目结构，尽可能多多的阅读，然后生成/更新我们的项目总览文档
</code></pre>
<h3 data-id="heading-10">任务上下文</h3>
<p>在动手写代码之前，最好先充分调研整理出一份技术方案。同样的，当要求 LLM 完成一个任务时，要求 LLM 首先在宏观角度生成一份技术文档是目前业界最普遍的实践，效果也十分显著</p>
<p>目前操作 LLM 来完成编程任务大概有这几种流程：</p>

































<table><thead><tr><th>类型</th><th>说明</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>直接对话执行</td><td>直接打字让 LLM 动手写代码</td><td>完成速度快</td><td>可能会因为缺乏项目理解，而一步错步步错;难以人工介入任务执行方案</td><td>简单任务</td></tr><tr><td>计划模式</td><td>几乎所有的工具都有一个 Plan 模式来首先根据任务来生成一份文档。比如 Roo Code 的 Architect 模式，Claude 的 Plan Mode</td><td>开箱即用</td><td>极度依赖工具本身对于 Plan Mode 的支持度，性能不稳定（目前大部分的 Plan Mode 仅仅针对任务进行计划，不主动调研现有的项目结构，经常重复造轮子）</td><td>建议用 PRP 代替</td></tr><tr><td>PRP-based**(推荐)**</td><td>将一个任务拆解为：撰写需求INITIAL.md -&gt; 生成详细方案（PRP） -&gt; 执行详细方案</td><td>调研彻底；任务完成度极高；自动记录 PRP</td><td>需要手动介入两次，任务周期通常较长</td><td>功能开发</td></tr></tbody></table>
<p>PRP (Product Requirements Prompts) 对于复杂任务的效果十分惊艳，远超目前所有工具的计划模式，且效果可以跨工具跨模型使用。并且由于 PRP 的效果实在是太好了，虽然现在工具并没有原生支持 PRP，但过不了多久工具一定陆续原生支持 PRP</p>
<p>下面是一个示例，分别是我的需求输入（INITIAL.md），以及 LLM 经过详细调研后生成的 PRP（PRPs/mcp-publishing-data-format-fix.md）</p>
<p>在 PRP 中你会发现 PRP 里面的方案非常详细！包含了实实在在的完整上下文以及完整方案：事情的前因后果、功能的现状和预期、需要注意的坑、多层次测试方案、关键代码示例、要改的文件和结构等等等</p>
<p>推荐读者大概一眼，不需要彻底读懂里面的信息，仅了解 INITIAL 和 PRP 大概长什么样，包含什么内容即可：</p>
<pre><code class="hljs language-Markdown" lang="Markdown"><span class="hljs-section">## FEATURE:</span>

现在 Schema MCP 发布的时候，写入的数据是 {"type":"schema","schema":{}}
Remote 写入的格式也不对，现在是 {"protocol":"sse","version":"1.0.0"}

预期是：
{"url": "http://std-mcp-boe.example.net/sse", "type": "sse"} 或者 {"url":
"http://std-mcp-boe.example.net/mcp-server-relay", "type": "streamable<span class="hljs-emphasis">_http"}

Remote 就直接用第一个生产网地址，Schema 也是，只是它有自己的生成规则

## DOCUMENTATION:

使用
APP_</span>ENV=boei18n.ip npm run db:query -- 'select * from aiai<span class="hljs-emphasis">_mcp'
看线上的结构，也就是我们的目标

使用
APP_</span>ENV=local npm run db:query -- 'select * from aiai<span class="hljs-emphasis">_mcp'
看我们本地的数据

你可以在
- http://localhost:3000/mcps/1?tab=versions 点击发布，发布 Schema 来测试，然后查看db数据
- http://localhost:3000/mcps/3?tab=versions 点击发布，发布 Remote 来测试，然后查看db数据

## OTHER CONSIDERATIONS:

不需要考虑数据迁移问题
# MCP 发布数据格式修复

## 目标
修复 MCP 发布操作时写入 `aiai_</span>mcp` 表的错误数据格式，使其符合生产环境要求并确保与 Agent 模块的正确集成。

<span class="hljs-section">## 为什么</span>
<span class="hljs-bullet">-</span> <span class="hljs-strong">**生产环境兼容性**</span>：本地 MCP 发布目前写入的格式不正确，与生产数据库结构不匹配
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Agent 集成**</span>：Agent 模块依赖 <span class="hljs-code">`aiai_mcp`</span> 表具有正确格式以进行 MCP 选择和执行
<span class="hljs-bullet">-</span> <span class="hljs-strong">**远程服务连接**</span>：错误的 URL 和类型格式会阻止在生产环境中正确连接 MCP 服务器

<span class="hljs-section">## 什么</span>
修复 <span class="hljs-code">`src/server/actions/mcp-versions.ts`</span> 中的 <span class="hljs-code">`syncRemoteMCPToAivoTable`</span> 和 <span class="hljs-code">`syncSchemaMCPToAivoTable`</span> 函数，使其在发布操作期间向 <span class="hljs-code">`aiai_mcp`</span> 表写入正确的配置格式。

<span class="hljs-section">### 成功标准</span>
<span class="hljs-bullet">-</span> [ ] Remote MCP 发布写入：<span class="hljs-code">`{"url": "http://production-url", "type": "sse"}`</span> 或 <span class="hljs-code">`{"url": "http://production-url", "type": "streamable_http"}`</span>
<span class="hljs-bullet">-</span> [ ] Schema MCP 发布写入与 Remote MCP 相同的格式：<span class="hljs-code">`{"url": "http://schema-url", "type": "sse"}`</span>，而不是 <span class="hljs-code">`{"type":"schema","schema":{}}`</span>
<span class="hljs-bullet">-</span> [ ] 本地数据库查询显示与生产环境匹配的正确格式
<span class="hljs-bullet">-</span> [ ] Remote 和 Schema MCP 的发布操作都能无错误工作
<span class="hljs-bullet">-</span> [ ] 现有功能保持完整（无回归）

<span class="hljs-section">## 所需上下文</span>

<span class="hljs-section">### 文档和参考</span>
<span class="hljs-code">```yaml
# 必须阅读 - 包含在上下文窗口中
- file: src/server/actions/mcp-versions.ts
  why: 包含需要修复的损坏同步函数（第 269-354 行）
  critical: buildRemoteConfig 返回错误格式，syncSchemaMCPToAivoTable 使用错误的 legacyConfig

- file: src/server/models/aiai-mcp.ts
  why: 目标表结构的数据库模型定义
  critical: config 字段是 JSON 类型，comment 显示应包含 URL, protocol, endpoints 等

- file: src/lib/utils/mcp-schema-endpoints.ts
  why: Schema MCP URL 生成工具，getSchemaEndpoints() 函数
  critical: 返回 {url, connectivity, protocol} 格式，需要映射到 {url, type}

- file: src/types/mcp-enhanced.ts
  why: 类型定义，包含 MCPConnectivity 枚举和 MCPRemoteEndpoint 接口
  critical: protocol 字段类型是 'sse' | 'streamable_http'

- file: INITIAL.md
  why: 包含确切的问题描述和预期格式示例
  critical: 明确指出当前错误格式和目标格式

- url: https://modelcontextprotocol.io/specification/2025-06-18
  why: 官方 MCP 规范文档
  critical: 传输类型（SSE vs streamable_http）和配置标准
```</span>

<span class="hljs-section">### 当前代码库结构（相关 MCP 文件）</span>
<span class="hljs-code">```bash
src/server/
├── actions/
│   ├── mcp.ts              # 旧版 MCP 操作
│   └── mcp-versions.ts     # 包含损坏的同步函数（目标文件）
├── models/
│   ├── aiai-mcp.ts        # 目标表模型
│   ├── mcp.ts             # 新 MCP 模型
│   └── mcp-version-v2.ts  # 包含配置数据的版本模型
├── db/
│   └── index.ts           # 数据库初始化
└── lib/
    ├── utils/
    │   └── mcp-schema-endpoints.ts  # Schema URL 生成工具
    └── types/
        └── mcp-enhanced.ts         # 类型定义
```</span>

<span class="hljs-section">### 已知的代码库陷阱和库特性</span>
<span class="hljs-code">```typescript
// 关键：生产数据库使用特定格式
// 目标格式（Remote 和 Schema 都相同）：{"url": "https://example.com/sse", "type": "sse"}
// Schema MCP 只是 URL 生成规则不同，但格式结构完全一样

// 关键：当前错误的返回格式 - buildRemoteConfig 函数（第 313-319 行）
return {
  url: primaryUrl,
  protocol: config.protocol || 'sse',  // ❌ 应该是 'type' 而不是 'protocol'
  endpoints: config.endpoints,          // ❌ 不应该包含在 aiai_mcp 表中
  authentication: config.authentication, // ❌ 不应该包含在 aiai_mcp 表中
  version: version.version,             // ❌ 不应该包含在 aiai_mcp 表中
};

// 关键：当前错误的 Schema 配置（第 329-332 行）
const legacyConfig = {
  type: 'schema',                      // ❌ 应该是传输类型，不是 MCP 类型
  schema: version.config?.schemaConfig?.schema || {}, // ❌ 不应该包含 schema 内容
};

// 关键：版本配置结构是嵌套的
// Remote MCP 使用 version.config.remoteConfig.endpoints[]
// Schema MCP 使用 version.config.schemaConfig.schema

// 关键：URL 生成模式差异
// Remote MCP：从 remoteConfig.endpoints[] 中提取（优先 production 环境）
// Schema MCP：通过 getSchemaEndpoints(mcpId) 生成 Firefly 服务 URL

// 关键：协议类型映射
// MCPRemoteEndpoint.protocol: 'sse' | 'streamable_http'
// aiai_mcp.config.type: 'sse' | 'streamable_http' (相同值)

// 关键：MCPConnectivity 枚举值
// PRODUCTION = 'production'  // 优先选择
// OFFICE = 'office'          // 备选

// 关键：数据库事务处理
// publishMCPVersion 使用事务 - 同步函数必须参与
// 事务失败时必须正确回滚

// 关键：导入依赖
import { MCPConnectivity } from "@/types/mcp-enhanced";
import { getSchemaEndpoints } from "@/lib/utils/mcp-schema-endpoints";
```</span>

<span class="hljs-section">## 实现蓝图</span>

<span class="hljs-section">### 数据模型和结构</span>
当前错误格式 vs 目标格式：

<span class="hljs-code">```typescript
// 当前错误 - Remote MCP 同步（buildRemoteConfig 返回）
{
  "url": "https://example.com/sse",
  "protocol": "sse",            // ❌ 应该是 "type"
  "endpoints": [...],           // ❌ 不应该存在
  "authentication": {...},      // ❌ 不应该存在
  "version": "1.0.0"           // ❌ 不应该存在
}

// 当前错误 - Schema MCP 同步（legacyConfig）
{
  "type": "schema",            // ❌ 应该是传输类型，不是 MCP 类型
  "schema": {...}              // ❌ 不应该存在
}

// 目标格式 - 两种类型都应该使用相同的格式
// Remote MCP 目标格式
{
  "url": "https://aiai-boe.example.net/api/openapi/v1/mcp/mcp.builtin.pms/sse",
  "type": "sse"
}

// Schema MCP 目标格式（格式相同，只是 URL 生成规则不同）
{
  "url": "https://firefly-va.byteintl.net/api/firefly/mcp_server/dynamic/mcp.v2.builtin.pms/mcp/firefly.example.org",
  "type": "streamable_http"
}
```</span>

<span class="hljs-section">### 按顺序完成 PRP 的任务列表</span>

<span class="hljs-code">```yaml
任务 1：验证生产数据库格式
查询生产数据库确认目标格式：
  - 运行：APP_ENV=boei18n.ip npm run db:query -- 'select id, mcp_id, config from aiai_mcp limit 5'
  - 分析：确认所有记录都使用 {url, type} 格式
  - 记录：验证没有 protocol, endpoints, version, schema 等字段

任务 2：修复 buildRemoteConfig 函数
修改 src/server/actions/mcp-versions.ts（第 303-320 行）：
  - 查找：function buildRemoteConfig
  - 修复：返回格式只包含 {url, type}，移除其他字段
  - 更新：从 config.remoteConfig.endpoints[] 正确提取 URL
  - 映射：protocol 字段正确映射到 type 字段

任务 3：创建 buildSchemaConfig 函数
添加新函数到 src/server/actions/mcp-versions.ts：
  - 位置：在 buildRemoteConfig 函数之后
  - 功能：使用 getSchemaEndpoints(mcpId) 生成 Schema URL
  - 格式：返回与 buildRemoteConfig 相同的 {url, type} 格式
  - 导入：添加必要的 import 语句

任务 4：修复 syncSchemaMCPToAivoTable 函数
修改 src/server/actions/mcp-versions.ts（第 326-354 行）：
  - 替换：legacyConfig 改为调用 buildSchemaConfig(mcp, version)
  - 移除：第 329-332 行的错误 legacyConfig 定义
  - 保持：其他逻辑不变（更新插入逻辑等）

任务 5：添加错误处理
增强错误处理机制：
  - Remote MCP：检查 endpoints 数组是否为空
  - Schema MCP：检查 getSchemaEndpoints 返回值
  - 事务：确保同步失败时正确回滚

任务 6：测试和验证
运行完整测试：
  - 单元测试：验证新函数返回正确格式
  - 集成测试：验证发布操作写入正确数据
  - 回归测试：确保现有功能不受影响
```</span>

<span class="hljs-section">### 每个任务的具体实现代码</span>

<span class="hljs-code">```typescript
// 任务 2：修复 buildRemoteConfig 函数
function buildRemoteConfig(mcp: any, version: any): any {
  const config = version.config as any;

  // 从 remoteConfig.endpoints 中提取端点
  const endpoints = config.remoteConfig?.endpoints || [];

  if (endpoints.length === 0) {
    throw new Error(`No endpoints found for Remote MCP: ${mcp.mcpId}`);
  }

  // 优先选择 production 环境的端点
  const productionEndpoints = endpoints.filter(
    (endpoint: any) =&gt; endpoint.connectivity === 'production'
  );

  // 使用第一个生产端点，如果没有则使用第一个可用端点
  const primaryEndpoint = productionEndpoints[0] || endpoints[0];

  if (!primaryEndpoint?.url) {
    throw new Error(`No valid URL found for Remote MCP: ${mcp.mcpId}`);
  }

  // 映射协议类型：保持 sse 和 streamable_http，其他默认为 sse
  const protocol = primaryEndpoint.protocol || 'sse';
  const transportType = ['sse', 'streamable_http'].includes(protocol)
    ? protocol
    : 'sse';

  // 目标格式：只返回 {url, type}
  return {
    url: primaryEndpoint.url,
    type: transportType
  };
}

// 任务 3：创建 buildSchemaConfig 函数
function buildSchemaConfig(mcp: any, version: any): any {
  // 使用现有的 getSchemaEndpoints 函数获取 URL
  const schemaEndpoints = getSchemaEndpoints(mcp.mcpId);

  if (schemaEndpoints.length === 0) {
    throw new Error(`No schema endpoints found for Schema MCP: ${mcp.mcpId}`);
  }

  // 优先选择 production 环境端点
  const productionEndpoint = schemaEndpoints.find(
    endpoint =&gt; endpoint.connectivity === MCPConnectivity.PRODUCTION
  ) || schemaEndpoints[0];

  if (!productionEndpoint?.url) {
    throw new Error(`No valid schema URL found for Schema MCP: ${mcp.mcpId}`);
  }

  // 映射协议类型：Streamable HTTP -&gt; streamable_http
  const transportType = productionEndpoint.protocol === "Streamable HTTP"
    ? "streamable_http"
    : "sse";

  // 目标格式：与 Remote MCP 相同的 {url, type} 格式
  return {
    url: productionEndpoint.url,
    type: transportType
  };
}

// 任务 4：修复 syncSchemaMCPToAivoTable 函数
async function syncSchemaMCPToAivoTable(mcp: any, version: any): Promise&lt;void&gt; {
  const { AivoMCP } = await initializeDatabase();

  // 使用新的 buildSchemaConfig 函数，而不是错误的 legacyConfig
  const config = buildSchemaConfig(mcp, version);

  const syncData = {
    mcp_id: mcp.mcpId,
    name: mcp.name,
    description: mcp.description || '',
    config: config,  // 现在使用正确的 {url, type} 格式
    documentation: mcp.documentation || '',
    updated_at: new Date(),
  };

  const existingRecord = await AivoMCP.findOne({
    where: { mcp_id: mcp.mcpId }
  });

  if (existingRecord) {
    await existingRecord.update(syncData);
    console.log(`[syncSchemaMCPToAivoTable] Schema MCP 更新成功: ${mcp.mcpId}`);
  } else {
    await AivoMCP.create({ ...syncData, created_at: new Date() } as any);
    console.log(`[syncSchemaMCPToAivoTable] Schema MCP 创建成功: ${mcp.mcpId}`);
  }
}

// 必须添加的导入语句（文件顶部）
import { MCPConnectivity } from "@/types/mcp-enhanced";
import { getSchemaEndpoints } from "@/lib/utils/mcp-schema-endpoints";
```</span>

<span class="hljs-section">### 集成点</span>
<span class="hljs-code">```yaml
数据库：
  - 表：aiai_mcp
  - 列：config（JSON 类型）
  - 约束：必须维护向后兼容性

发布：
  - 触发器：publishMCPVersion 函数
  - 事务：必须参与现有事务
  - 回滚：如果同步失败，整个发布应该失败

测试：
  - 命令：APP_ENV=local npm run db:query -- 'select * from aiai_mcp'
  - 验证：比较本地 vs 生产格式
  - 端点：测试 http://localhost:3000/mcps/1?tab=versions 和 /mcps/3?tab=versions
```</span>

<span class="hljs-section">## 验证循环</span>

<span class="hljs-section">### 第 1 级：语法和样式</span>
<span class="hljs-code">```bash
# 首先运行这些 - 修复任何错误后再继续
npm run lint
npm run type-check

# 预期：无错误。如有错误，阅读错误并修复。
```</span>

<span class="hljs-section">### 第 2 级：数据库查询验证</span>
<span class="hljs-code">```bash
# 测试生产格式理解
APP_ENV=boei18n.ip npm run db:query -- 'select id, mcp_id, config from aiai_mcp limit 10'

# 测试本地发布 - 修复前
APP_ENV=local npm run db:query -- 'select id, mcp_id, config from aiai_mcp'
# 预期：显示错误格式（如果有记录）

# 清空测试数据
APP_ENV=local npm run db:query -- 'delete from aiai_mcp where mcp_id like "test.%"'

# 测试本地发布 - 修复后
# 1. 启动服务：PORT=3000 npm run dev
# 2. 发布 Remote MCP：访问 http://localhost:3000/mcps/3?tab=versions 点击发布
# 3. 发布 Schema MCP：访问 http://localhost:3000/mcps/1?tab=versions 点击发布
# 4. 查询验证：APP_ENV=local npm run db:query -- 'select id, mcp_id, config from aiai_mcp'
# 预期：显示正确的 {"url": "...", "type": "..."} 格式
```</span>

<span class="hljs-section">### 第 3 级：集成测试</span>
<span class="hljs-code">```typescript
// 创建测试文件：tests/integration/mcp-publishing-fix.test.ts
import { publishMCPVersion } from '@/server/actions/mcp-versions';
import { initializeDatabase } from '@/server/db';
import assert from 'assert';

async function testMCPPublishingFormat() {
  console.log('🚀 开始 MCP 发布格式测试...\n');

  const { AivoMCP } = await initializeDatabase();

  // 测试 Remote MCP 发布格式
  console.log('📝 测试 Remote MCP 发布格式...');

  // 这里需要创建测试 Remote MCP 和版本
  // 发布后查询数据库验证格式

  const remoteMCPRecord = await AivoMCP.findOne({
    where: { mcp_id: 'test.remote.mcp' }
  });

  if (remoteMCPRecord) {
    const config = remoteMCPRecord.config as any;
    assert(config.url, 'Remote MCP config 应该有 url 字段');
    assert(config.type, 'Remote MCP config 应该有 type 字段');
    assert(['sse', 'streamable_http'].includes(config.type), 'type 应该是 sse 或 streamable_http');
    assert(!config.protocol, 'config 不应该包含 protocol 字段');
    assert(!config.endpoints, 'config 不应该包含 endpoints 字段');
    assert(!config.version, 'config 不应该包含 version 字段');
    console.log('✅ Remote MCP 格式正确');
  }

  // 测试 Schema MCP 发布格式
  console.log('📝 测试 Schema MCP 发布格式...');

  const schemaMCPRecord = await AivoMCP.findOne({
    where: { mcp_id: 'test.schema.mcp' }
  });

  if (schemaMCPRecord) {
    const config = schemaMCPRecord.config as any;
    assert(config.url, 'Schema MCP config 应该有 url 字段');
    assert(config.type, 'Schema MCP config 应该有 type 字段');
    assert(['sse', 'streamable_http'].includes(config.type), 'type 应该是 sse 或 streamable_http');
    assert(!config.schema, 'config 不应该包含 schema 字段');
    assert(config.type !== 'schema', 'type 不应该是 schema');
    console.log('✅ Schema MCP 格式正确');
  }

  console.log('🎉 所有测试通过！');
}

// 运行测试
testMCPPublishingFormat().catch(console.error);
```</span>

<span class="hljs-code">```bash
# 运行集成测试
npx tsx tests/integration/mcp-publishing-fix.test.ts

# 预期：所有断言通过，无错误输出
```</span>

<span class="hljs-section">### 第 4 级：端到端验证</span>
<span class="hljs-code">```bash
# 启动服务
PORT=3000 npm run dev

# 手动测试流程：
# 1. 访问 http://localhost:3000/mcps/3?tab=versions
# 2. 点击"发布"按钮
# 3. 验证无错误，发布成功
# 4. 访问 http://localhost:3000/mcps/1?tab=versions
# 5. 点击"发布"按钮
# 6. 验证无错误，发布成功

# 验证数据库格式
APP_ENV=local npm run db:query -- 'select id, mcp_id, config from aiai_mcp order by updated_at desc limit 5'

# 预期输出示例：
# | id | mcp_id | config |
# | 1  | mcp.builtin.pms | {"url":"https://aiai-boe.example.net/...","type":"sse"} |
# | 2  | mcp.v2.builtin.pms | {"url":"https://firefly-va.example.net/...","type":"streamable_http"} |
```</span>

<span class="hljs-section">## 最终验证清单</span>
<span class="hljs-bullet">-</span> [ ] 语法检查通过：<span class="hljs-code">`npm run lint`</span>
<span class="hljs-bullet">-</span> [ ] 类型检查通过：<span class="hljs-code">`npm run type-check`</span>
<span class="hljs-bullet">-</span> [ ] 生产格式研究完成：确认目标 {url, type} 结构
<span class="hljs-bullet">-</span> [ ] buildRemoteConfig 函数修复：只返回 {url, type}
<span class="hljs-bullet">-</span> [ ] buildSchemaConfig 函数创建：使用 getSchemaEndpoints
<span class="hljs-bullet">-</span> [ ] syncSchemaMCPToAivoTable 函数修复：使用新的配置函数
<span class="hljs-bullet">-</span> [ ] 导入语句添加：MCPConnectivity 和 getSchemaEndpoints
<span class="hljs-bullet">-</span> [ ] 错误处理添加：空数组和无效 URL 检查
<span class="hljs-bullet">-</span> [ ] 集成测试通过：配置格式验证正确
<span class="hljs-bullet">-</span> [ ] 手动测试通过：Remote 和 Schema MCP 发布成功
<span class="hljs-bullet">-</span> [ ] 数据库验证通过：本地与生产格式匹配
<span class="hljs-bullet">-</span> [ ] 现有功能无回归：其他 MCP 功能正常工作
<span class="hljs-bullet">-</span> [ ] 事务处理正确：失败时能正确回滚

---

<span class="hljs-section">## 要避免的反模式</span>
<span class="hljs-bullet">-</span> ❌ 不要保留 protocol, endpoints, version 等字段在 aiai<span class="hljs-emphasis">_mcp.config 中
- ❌ 不要使用 {"type": "schema"} 格式 - 这是 MCP 类型，不是传输类型
- ❌ 不要硬编码 URL - 必须从配置或 getSchemaEndpoints 中提取
- ❌ 不要破坏事务处理 - 确保同步函数正确参与事务
- ❌ 不要忽略错误情况 - 必须处理空数组、无效 URL 等边界情况
- ❌ 不要忘记添加导入语句 - MCPConnectivity 和 getSchemaEndpoints 是必需的
- ❌ 不要更改无关代码 - 只修改明确损坏的同步函数

## 信心等级：9/10
此 PRP 提供了全面的上下文，包括：
- 具体的代码位置和行号
- 真实的错误代码示例和正确的目标代码
- 完整的导入依赖和类型定义
- 可执行的验证命令和测试用例
- 详细的错误处理策略
- 明确的实现步骤和代码示例

唯一的不确定性是特定环境下的 URL 生成，但已通过现有的 `getSchemaEndpoints` 函数解决。
</span></code></pre>
<p>PRP 生成、PRP 执行通常有专门的任务说明（一个大 Prompt）来做，目前有很多开源方案，比如：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcoleam00%2Fcontext-engineering-intro" target="_blank" title="https://github.com/coleam00/context-engineering-intro" ref="nofollow noopener noreferrer">github.com/coleam00/co…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWirasm%2FPRPs-agentic-eng" target="_blank" title="https://github.com/Wirasm/PRPs-agentic-eng" ref="nofollow noopener noreferrer">github.com/Wirasm/PRPs…</a></li>
</ul>
<p>由于现在工具不原生支持 PRP，开发需要阅读挑选，将自己喜欢的生成 PRP 和 执行 PRP 的文件拷贝到自己的 Repo 之中，当需要执行或生成 PRP 时，将该任务说明发给 LLM 即可，类似于：</p>
<pre><code class="hljs language-Plain" lang="Plain">请根据 @generate-prp.md 的说明，为我的需求 @INITIAL.md 生成 PRP
</code></pre>
<blockquote>
<p>本文末尾给出了完整的 Vibe Coding 模板，包含 PRP 相关的支持。读者可以开箱即用</p>
</blockquote>
<p>PRP 生成后执行前，这里是绝佳的人工介入纠错时机。一定要彻底审查 PRP，纠正所有错误，保证 PRP 质量非常高。审查 PRP 可以最大程度避免：<strong>AI</strong> <strong>花了几个小时，烧了上百刀，结果跑出来的完全没法用</strong></p>
<h3 data-id="heading-11">第三方上下文</h3>
<p>有时候 LLM 需要一些第三方的信息来辅助判断，比如查询 next.js 文档，理解公司某个私有基建。目前有如下方案</p>




















<table><thead><tr><th>类型</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td>本地管理</td><td>建立 <code>./vibe/external/</code> 文件夹，将需要的文档保存其中，并在 Rule 文件中说明</td><td>所有场景</td></tr><tr><td>文档 MCP</td><td>一些 MCP Server 提供文档查询功能，比如 context 7 和 deepwiki</td><td>通用第三方文档</td></tr></tbody></table>
<p>推荐都用，需要哪个用哪个。常见的文档 MCP 如下：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fupstash%2Fcontext7" target="_blank" title="https://github.com/upstash/context7" ref="nofollow noopener noreferrer">github.com/upstash/con…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fregenrek%2Fdeepwiki-mcp" target="_blank" title="https://github.com/regenrek/deepwiki-mcp" ref="nofollow noopener noreferrer">github.com/regenrek/de…</a></li>
</ul>
<p>同时也将你常用的文档，比如你项目中使用框架的文档，下载下来放到  <code>./vibe/external/</code> 之中，然后可以在 Rule 中明确要求 LLM 遇到框架相关的问题，首先差异文档。类似于：</p>
<pre><code class="hljs language-Markdown" lang="Markdown"><span class="hljs-section">## 项目框架</span>

本项目使用 Next.js 框架，如果你遇到任何的 Next.js 问题，你应该先去 vibe/external/nextjs 中查找对应的问题，然后再制定解决方案
</code></pre>
<h2 data-id="heading-12">反馈回路</h2>
<p>当我们写代码的时候，通常会在功能完成后进行简单的自测，通常来说会发现很多问题，所以需要再迭代几轮，最终交付。同样的，LLM 编程也很难做到第一次就成功，我们需要保证 LLM 有丰富的自测手段，可以“看到”自己写代码的问题</p>
<p>而想办法能让 LLM 有办法自测，看到问题，自行迭代，这个方向的建设，我称为“<em>反馈回路</em>”</p>
<p>良好的反馈回路可以避免“Vibe Coding 十分钟，Debug 两小时”，避免 Vibe Coding 实际上是<strong>把编码工作换成了</strong> <strong>Code Review</strong> <strong>和手动测试</strong>，确保交付产物可以在无人为干预情况下直接达到可用状态</p>
<p>接下来本文将列举几个常见的可以建设反馈回路的方向，读者可以根据自己使用的技术栈来思考——有哪些反馈回路可以建设，让 LLM 可以“看得见”</p>
<h3 data-id="heading-13">运行日志</h3>
<p>不论你是什么方向的开发，通常会有一个地方可以拿到程序的运行日志，如：</p>
<ul>
<li>前端开发：编译日志</li>
<li>后端开发：服务器进程 stdio</li>
<li>安卓开发：adb 日志</li>
</ul>
<p>这些日志在开发过程中非常有用，需要让 LLM 也看得到。那么，我们其实可以修改启动命令，使用 tee 命令将所有的日志不仅仅在控制台输出，也收集到一个文件之中：</p>
<pre><code class="hljs language-Bash" lang="Bash"><span class="hljs-comment"># 假设我们原本是使用 ./start-dev.bash 来启动开发环境</span>
<span class="hljs-comment"># 增加 tee 管道来收集开发环境的日志</span>
./start-dev.bash 2&gt;&amp;1 | <span class="hljs-built_in">tee</span> -a <span class="hljs-built_in">log</span>/dev-console.log
</code></pre>
<p>然后在基础 rule 文件之中增加相关的描述：</p>
<pre><code class="hljs language-Markdown" lang="Markdown"><span class="hljs-section">## 开发环境日志</span>

<span class="hljs-bullet">-</span> 开发服务器的控制台输出在 @/log/dev-console.log 里面
<span class="hljs-bullet">-</span> @/log/dev-console.log 文件可能比较大，必要时使用 tail -100 命令来读取输出（不要使用 tail -f）
<span class="hljs-bullet">-</span> 如果你需要观察一次的session的输出，记得首先使用 echo '' &gt; @/log/dev-console.log 首先清空日志文件，然后再 cat
</code></pre>
<p>这样，LLM 就会在遇到问题时有能力自行捞日志定位修复问题了</p>
<h3 data-id="heading-14">静态分析</h3>
<p>很多代码中的问题可以通过静态分析来自动找到问题。最常见的无疑是拥有静态类型系统的语言，比如C++、Java、TypeScript。如果你使用的编程语言支持类型系统，那么你可以在 Rule 文件中要求 LLM：</p>
<ol>
<li>定义和使用严格的类型</li>
<li>在任务完成前运行类型检查，确保没有类型错误</li>
</ol>
<p>除了类型检查，你可以手动的去构建一些静态分析。比如要求 LLM 编写一个脚本，解析所有代码文件的</p>
<p>AST（Abstract Syntax Tree，抽象语法树），找到可以静态扫描的点，将运行时错误改造成编译错误。比如说：</p>
<ol>
<li>在多语言支持中，解析 key，然后检查是否在多语言翻译中包含这个 key、</li>
<li>让代码符合项目某些约定俗成，比如不要使用某个第三方包的某个函数，使用项目自己包装过的函数。很多 lint 工具都支持开箱即用的配置，无需自己写脚本分析</li>
</ol>
<p>这些都是可以通过静态分析 AST 来完成，中心思想也很简单：尽可能将运行时错误转变为编译时错误</p>
<blockquote>
<p>关于静态分析这个其实是一个大话题，常见的就只有本文提到的类型检查、i18n键、lint。这里就不进一步展开了</p>
</blockquote>
<h3 data-id="heading-15">集成 / E2E 测试</h3>
<p>在软件开发中，通常来说，自动化测试的建设不是一个必选项，项目可以通过 RD 自测、QA 测试来保证质量。但是在 Vibe Coding 场景下，建设自动化测试成了一个必选项。LLM 需要在每个功能开发时，充分考虑到如何测试，将测试方案作为技术方案的一部分来进行</p>
<p>E2E 测试最好，集成测试也可以，但是单元测试不行（容易先射箭后画靶）</p>
<p>你可以根据自己项目的自动化测试方案，在 Rule 文件中要求 LLM 每次都要为功能编写测试，验证测试通过后才能交付，各个 PRP 的模板大多也会包含渐进式测试的方案部分</p>
<p>如果仅仅想关注一部分的代码，在 Vibe Coding 场景下，<strong>Review 测试的方案和代码比 Review 功能实现更有价值</strong></p>
<h2 data-id="heading-16">团队接入</h2>
<h3 data-id="heading-17">文件目录</h3>
<p>统一组内 Vibe Coding 工具和 Rule 文件就像统一组内代码编辑器一样困难，因此不建议在项目内提交任何 Vibe Coding 工具相关的文件，以防冲突。但是项目将 Vibe Coding 的模板和通用文件提交到仓库并维护，以下是建议的目录结构：</p>
<pre><code class="hljs language-Markdown" lang="Markdown">vibe/ # 存放所有 vibe coding 相关文件
 ├── externals/ # 第三方文档
 ├── prompts # 沉淀常用的任务说明
 │   ├── update-getting-started.md # 更新/生成项目总览文档
 │   ├── execute-prp.md # 执行 PRP
 │   └── generate-prp.md # 生成 PRP
 ├── PRPs # 存放 PRP 模板和所有历史 PRP
 │   └── template.md
 ├── getting-started.md # 项目总览文档
 ├── initial.example.md # 生成 PRP 的需求文档的模板
 ├── mcp.example.json # MCP 服务器配置模板
 ├── rules.example.md # 工具基础 Rule 规则模板
 └── READMD.md # 目录说明
</code></pre>
<p>我在 Github 上创建了一个中文版模板，读者可以直接下载，然后将 vibe/ 目录拷贝到自己的项目之中即可~</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpea3nut%2Fvibe-coding-template" target="_blank" title="https://github.com/pea3nut/vibe-coding-template" ref="nofollow noopener noreferrer">github.com/pea3nut/vib…</a></p>
<h3 data-id="heading-18">Vibe Coding 流程</h3>
<p>当开始一个任务时，如果是一个非常小的修改，可以直接通过对话的方式来进行沟通，而如果是一个稍大的改动，或者完整功能开发，则需要</p>
<ol>
<li>撰写需求说明 Initial.md</li>
<li>使用 <code>./vibe/prompts/generate-prp.md</code> 来生成 PRP</li>
<li>理解 PRP，必要时迭代</li>
<li>使用 <code>./vibe/prompts/execute-prp.md</code> 来执行 PRP</li>
</ol>
<p>而关于如何接受代码，我观察到其实有很多人喜欢手动的 Review 然后接受每个 LLM 提交的改动，这个其实是一个非常糟糕的 Vibe Coding 方式，很容易导致“要不是用 Vibe Coding，我功能早开发完了”</p>
<p>正确的打开方式是：让 LLM <strong>自动、无监督、纯脱手</strong>的方式完成大部分工作，然后再切换到手动模式，与 LLM 完成“最后一公里”</p>
<h3 data-id="heading-19">个人，团队和协作</h3>
<p>使用 Vibe Coding 后，由于“写代码”资源不再稀缺，且可以并行开发，传统的“先迭代出完美的产品和技术方案，后续不再修改”的方式已经不再适用。LLM 可以快速的理解需求，根据项目现状生成完整的 PRP 包含PRD、TRD、测试方案。因此，针对需求开发流程我觉得可以有如下修改：</p>
<ol>
<li>使用 PRP 代替技术方案的流程</li>
<li>在 PRP 完成后，直接拉业务方进行一轮原型展示，对齐基本功能和交互</li>
<li>大大简化 Code Review，仅 Review 跨模块的修改，模块内部的修改和新增不再 Code Review</li>
</ol>
<p>而各个开发团队也可以着重建设下面几方面来增强 Vibe Coding 体验：</p>
<ol>
<li>全栈项目 / Monorepo：LLM 对于全栈修改的能力极强，使用 Monorepo 可大大减少上下文沟通</li>
<li>PE 能力培训：Vibe Coding 水平与 PE 水平强相关，建议团队对于开发者进行 PE 培训。可以参考 <a href="https://juejin.cn/post/7288607375731818553" target="_blank" title="https://juejin.cn/post/7288607375731818553">juejin.cn/post/728860…</a></li>
</ol>
<h3 data-id="heading-20">中文模板</h3>
<p>笔者为大家创建了一个中文版 Vibe Coding 模板，可以开箱即用。包含了基本 Prompt 和文件目录，后续也会将笔者的各种方法论继续沉淀于此，欢迎 Star：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpea3nut%2Fvibe-coding-template" target="_blank" title="https://github.com/pea3nut/vibe-coding-template" ref="nofollow noopener noreferrer">github.com/pea3nut/vib…</a></p>
<p>其中关于 PRP 的生成和执行也有很多第三方的选择，读者可以自行阅读：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcoleam00%2Fcontext-engineering-intro" target="_blank" title="https://github.com/coleam00/context-engineering-intro" ref="nofollow noopener noreferrer">github.com/coleam00/co…</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FWirasm%2FPRPs-agentic-eng" target="_blank" title="https://github.com/Wirasm/PRPs-agentic-eng" ref="nofollow noopener noreferrer">github.com/Wirasm/PRPs…</a></li>
</ul>
<h2 data-id="heading-21">后记</h2>
<p>这里是【花生派】，可以在这里找到我：</p>
<ul>
<li>个人资料网站：<a href="https://link.juejin.cn?target=http%3A%2F%2Fpea3nut.info" title="https://link.juejin.cn?target=http%3A%2F%2Fpea3nut.info" target="_blank"><code>pea3nut.info</code></a></li>
<li>个人博客：<a href="https://link.juejin.cn?target=http%3A%2F%2Fpea3nut.blog" title="https://link.juejin.cn?target=http%3A%2F%2Fpea3nut.blog" target="_blank"><code>pea3nut.blog</code></a></li>
<li><a href="https://juejin.cn/user/3227821867563735" title="https://juejin.cn/user/3227821867563735" target="_blank">掘金：花生Peadar</a></li>
</ul>
<p>转载请随意，但需保留此小节，感谢理解~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[低代码高频实践场景系列之一——EHS系统]]></title>    <link>https://juejin.cn/post/7572844326390890530</link>    <guid>https://juejin.cn/post/7572844326390890530</guid>    <pubDate>2025-11-17T06:34:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572844326390890530" data-draft-id="7573241978901676047" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="低代码高频实践场景系列之一——EHS系统"/> <meta itemprop="keywords" content="低代码"/> <meta itemprop="datePublished" content="2025-11-17T06:34:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="得帆云低代码"/> <meta itemprop="url" content="https://juejin.cn/user/2254449849150557"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            低代码高频实践场景系列之一——EHS系统
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2254449849150557/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    得帆云低代码
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:34:42.000Z" title="Mon Nov 17 2025 06:34:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文作者：得帆信息联合创始人兼CTO徐翔轩</p>
<h2 data-id="heading-0">EHS建设正在成为“必答题”</h2>
<p>过去几年，随着国家监管要求趋严、审计频率增加、企业社会责任强化，内部安全管理要求不断细化，EHS系统在很多行业内的存在感明显提升。无论是制造业、化工、能源等传统行业，还是医药、电子等新兴领域，EHS系统已从最初的“合规性选择”逐步转变为“建设性刚需”。EHS是环境（Environment）、健康（Health）、安全（Safety）三个英文单词的缩写，代表一种整合管理体系。该系统旨在帮助企业管控生产运营中的环境保护、员工健康与安全生产风险，核心目标是实现零事故。越来越多企业意识到，EHS系统绝不仅仅是满足检查与报表要求而存在的工具，而是保障生产安全、降低运营风险、强化企业治理能力的关键支撑。</p>
<h2 data-id="heading-1">直接采购EHS商业软件，为什么“水土不服”？</h2>
<p>当前市场上虽存在多款成熟的EHS商业软件，但企业在实际采购与使用过程中，仍面临诸多典型挑战。</p>
<p>01 
难以完全契合业务特点</p>
<p>不同企业乃至同一企业的不同厂区，其安全组织架构、业务流程、考核指标存在显著差异。而商业软件多以"标准模板"为核心设计，虽然能快速上线，却难以深度契合企业个性化需求，导致系统与实际业务场景脱节。</p>
<p>02 
调整成本高</p>
<p>EHS管理机制经常随着企业要求、法规政策变化而更新。传统软件每项流程变更均需依赖厂商定制开发，伴随追加费用与实施周期延长，很多企业因此陷入“上线容易，维护艰难”的困境。</p>
<p>03 扩展与集成受限</p>

<p>当企业尝试将EHS系统与生产管理、设备运维、培训管理、HR等系统深度打通时，常遭遇接口标准不统一、数据孤岛、权限体系重复建设等问题，难以构建跨系统的风险安全数据全景视图。</p>
<p>这些挑战产生的根本原因是：</p>
<p>EHS系统既需要“结构稳定”，又必须“灵活应变”，既需承载核心管理逻辑的长期稳定性，又要具备快速响应业务变化的能力。然而，传统软件架构往往难以兼顾二者，导致系统功能与企业管理需求产生结构性矛盾。</p>
<h2 data-id="heading-2">低代码：一种更平衡的建设方式</h2>
<p>正因如此，越来越多企业开始采用低代码平台来建设专属的EHS管理系统。低代码并不是“替代软件”，而是一种更符合EHS复杂性与变动性的建设路径。</p>
<p>01 灵活搭建与快速调整</p>
<p>安全巡检、隐患上报、整改追踪、风险分级、事故报告……这些模块都能基于低代码模板快速搭建、复用，并根据实际情况随时调整。当新法规出台或审计要求变更时，低代码系统能在数日内完成同步更新，确保管理要求与系统功能实时匹配。</p>
<p>02 持续迭代的进化能力</p>
<p>EHS管理逻辑具有显著的动态特征，低代码平台赋予团队内部优化系统的能力，使EHS系统从"项目交付"转变为"体系演进"，实现管理策略与技术工具的同步升级。</p>
<p>03 一体化的连接与数据治理</p>
<p>EHS系统绝非孤立存在，而是企业安全管理的枢纽。通过低代码平台，EHS可无缝对接生产管理、设备运维、HR等系统，打通业务流程与数据壁垒，构建安全管理闭环。</p>
<h2 data-id="heading-3">从“项目上线”到“体系建设”</h2>
<p>在以往的项目逻辑中，EHS系统往往被视作“一次性项目”。而低代码技术的引入彻底改变了这一范式，将其转化为一种"持续进化的管理能力"。</p>
<p>使用低代码搭建EHS系统，企业可以先从某个环节切入：比如隐患排查、巡检计划、整改跟踪。随着业务成熟度提升，再逐步扩展到风险评估、环境监测、职业健康、安全培训等模块。</p>
<p>这种分阶段实施模式具有显著优势：</p>
<ul>
<li>节奏可控性‌：分阶段部署确保建设进度与业务需求同步</li>
<li>经济可见性‌：快速实现核心功能，缩短投资回报周期</li>
<li>系统稳定性‌：渐进式迭代降低整体实施风险</li>
<li>团队协同性‌：业务部门与IT团队在共建中实现能力跃升</li>
</ul>
<p>最终形成的，不仅是一个系统，而是一套具备自我进化能力的EHS管理框架，能够随企业战略调整、法规变化及业务拓展持续优化。</p>
<h2 data-id="heading-4">结语</h2>
<p>EHS数字化的目标，绝不只是“合规通过”，而是让安全成为企业的核心管理能力。</p>
<p>在此过程中，低代码提供了一种更贴近现实的解决思路——既尊重行业标准，又保留灵活性；既能快速搭建，又能持续演进。</p>
<p>对于多数行业而言，EHS管理已从"可选项"转变为"必选项"。而对数字化团队而言，低代码平台正是将这一"必选项"转化为"价值项"的关键工具——它让复杂的EHS系统变得易用、易管、可持续。</p>
<p>大家还对哪些内容感兴趣，或者是希望一起探讨相关的方法，欢迎留言和私信联系。希望得帆低代码和我们的实践心得，能帮到越来越多的朋友、客户。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[使用 Trae AI 开发完整的开源 npm 包：snail-git-add]]></title>    <link>https://juejin.cn/post/7573239644155019291</link>    <guid>https://juejin.cn/post/7573239644155019291</guid>    <pubDate>2025-11-17T06:58:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573239644155019291" data-draft-id="7573299401046130734" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="使用 Trae AI 开发完整的开源 npm 包：snail-git-add"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-17T06:58:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="蜗牛前端"/> <meta itemprop="url" content="https://juejin.cn/user/1662117310637757"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            使用 Trae AI 开发完整的开源 npm 包：snail-git-add
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1662117310637757/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    蜗牛前端
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:58:18.000Z" title="Mon Nov 17 2025 06:58:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>体验Trae AI开发工具，全部代码均由Trae开发工具完成包括调试</p>
</blockquote>
<h2 data-id="heading-0">引言</h2>
<p>在现代前端开发中，高效的 Git 工作流工具对于团队协作和代码质量至关重要。今天，我将向大家介绍一个功能强大的交互式 Git 工作流工具——<code>snail-git-add</code>，它不仅简化了 Git 操作流程，还支持智能文件选择和约定式提交规范。更特别的是，这个工具是使用 Trae AI 开发完成的，展示了 AI 辅助开发如何大幅提升开发效率和代码质量。</p>
<h2 data-id="heading-1">项目概述：snail-git-add</h2>
<p><code>snail-git-add</code> 是一个功能丰富的交互式 Git 工作流工具，旨在简化开发者的日常 Git 操作，提供可视化的文件选择和规范的提交流程。</p>
<h3 data-id="heading-2">核心特性</h3>
<ul>
<li>🎯 <strong>交互式文件选择</strong>：可视化选择要暂存的文件，支持文件状态高亮显示</li>
<li>📝 <strong>约定式提交</strong>：遵循标准提交规范，生成一致的提交信息</li>
<li>🎨 <strong>彩色终端输出</strong>：文件状态使用不同颜色区分（修改-黄色，新增-绿色，删除-红色，重命名-蓝色）</li>
<li>🔄 <strong>完整工作流</strong>：从文件选择、提交到推送的一站式解决方案</li>
<li>📋 <strong>交互式菜单</strong>：提供主菜单和高级工具菜单，方便管理 Git 仓库</li>
<li>🌿 <strong>分支管理</strong>：创建、切换、删除和合并分支</li>
<li>📜 <strong>提交历史</strong>：查看和管理提交历史</li>
<li>🗂️ <strong>Stash 管理</strong>：暂存和恢复工作区更改</li>
<li>🏷️ <strong>标签管理</strong>：创建、删除和推送标签</li>
<li>🔗 <strong>远程管理</strong>：管理远程仓库和分支</li>
<li>⚙️ <strong>灵活配置</strong>：支持多种使用场景和自定义选项</li>
<li>🛡️ <strong>类型安全</strong>：使用 TypeScript 开发，提供完整的类型定义</li>
</ul>
<h2 data-id="heading-3">使用 Trae AI 开发的过程</h2>
<p>开发 <code>snail-git-add</code> 的过程中，Trae AI 扮演了关键角色，从项目规划到最终部署，AI 辅助贯穿始终。</p>
<h3 data-id="heading-4">1. 需求分析与架构设计</h3>
<p>首先，通过与 Trae AI 的对话，我明确了项目需求和架构设计：</p>
<ul>
<li>确定了核心功能模块：交互式文件选择、约定式提交、分支管理等</li>
<li>设计了模块化的代码结构，便于扩展和维护</li>
<li>选择了合适的技术栈：TypeScript、Node.js、inquirer 等</li>
</ul>
<h3 data-id="heading-5">2. 代码实现与优化</h3>
<p>在代码实现阶段，Trae AI 提供了以下帮助：</p>
<ul>
<li>快速生成基础代码框架和核心功能模块</li>
<li>提供 TypeScript 类型定义和接口设计</li>
<li>优化用户交互逻辑和命令行输出</li>
<li>解决开发过程中遇到的技术问题</li>
</ul>
<h3 data-id="heading-6">3. 测试与调试</h3>
<p>Trae AI 协助完成了测试和调试工作：</p>
<ul>
<li>生成测试用例和调试脚本</li>
<li>分析和修复代码中的错误</li>
<li>优化命令执行逻辑和错误处理</li>
</ul>
<h3 data-id="heading-7">4. 自动化部署脚本</h3>
<p>使用 Trae AI 创建了自动化部署脚本，实现了：</p>
<ul>
<li>npm 登录状态检查和交互式登录</li>
<li>Git 工作目录状态验证</li>
<li>版本号自动更新（支持 patch/minor/major）</li>
<li>项目构建和 npm 发布</li>
<li>Git 仓库推送和标签管理</li>
</ul>
<h2 data-id="heading-8">snail-git-add 功能详解</h2>
<h3 data-id="heading-9">1. 交互式文件选择</h3>
<p><code>snail-git-add</code> 提供了直观的交互式文件选择界面，让开发者可以轻松选择要暂存的文件：</p>
<ul>
<li>使用空格键选择文件，回车键确认</li>
<li>文件状态使用不同颜色标识，一目了然</li>
<li>支持全选/反选功能，提高操作效率</li>
</ul>
<h3 data-id="heading-10">2. 约定式提交</h3>
<p>工具内置了约定式提交规范，帮助团队保持一致的提交风格：</p>
<ul>
<li>支持多种提交类型：feat、fix、docs、style、refactor 等</li>
<li>可选的提交作用域，便于区分不同模块</li>
<li>提交主题和详细描述的结构化输入</li>
<li>自动生成符合规范的提交信息</li>
</ul>
<h3 data-id="heading-11">3. 完整的 Git 工作流</h3>
<p>从文件管理到远程同步，<code>snail-git-add</code> 提供了完整的 Git 工作流支持：</p>
<h4 data-id="heading-12">分支管理</h4>
<ul>
<li>创建、切换、删除和合并分支</li>
<li>显示分支状态和提交信息</li>
<li>支持远程分支管理</li>
</ul>
<h4 data-id="heading-13">提交历史</h4>
<ul>
<li>查看完整的提交历史</li>
<li>搜索和筛选特定提交</li>
<li>查看提交详情和变更文件</li>
</ul>
<h4 data-id="heading-14">Stash 管理</h4>
<ul>
<li>暂存当前工作区的更改</li>
<li>恢复之前的暂存内容</li>
<li>管理多个 stash 记录</li>
</ul>
<h4 data-id="heading-15">标签管理</h4>
<ul>
<li>创建、删除和推送标签</li>
<li>支持语义化版本标签</li>
<li>查看所有标签信息</li>
</ul>
<h2 data-id="heading-16">快速开始：安装与使用</h2>
<h3 data-id="heading-17">安装</h3>
<p><code>snail-git-add</code> 支持多种安装方式，您可以根据需要选择：</p>
<h4 data-id="heading-18">全局安装（推荐，可在任何目录使用）</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用 npm</span>
npm install -g snail-git-add

<span class="hljs-comment"># 使用 yarn</span>
yarn global add snail-git-add

<span class="hljs-comment"># 使用 pnpm</span>
pnpm add -g snail-git-add

<span class="hljs-comment"># 使用 bun</span>
bun add -g snail-git-add
</code></pre>
<h4 data-id="heading-19">局部安装（用于当前项目）</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 使用 npm</span>
npm install -D snail-git-add

<span class="hljs-comment"># 使用 yarn</span>
yarn add -D snail-git-add

<span class="hljs-comment"># 使用 pnpm</span>
pnpm add -D snail-git-add

<span class="hljs-comment"># 使用 bun</span>
bun add -D snail-git-add
</code></pre>
<h3 data-id="heading-20">基本使用</h3>
<p>安装完成后，您可以在任何 Git 仓库中使用以下命令启动工具：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 交互式选择文件并提交</span>
snail-git-add

<span class="hljs-comment"># 或使用 npx（局部安装时）</span>
npx snail-git-add
</code></pre>
<h3 data-id="heading-21">完整工作流示例</h3>
<ol>
<li><strong>启动工具</strong>：运行 <code>snail-git-add</code> 命令</li>
<li><strong>选择文件</strong>：在交互式界面中选择要暂存的文件</li>
<li><strong>填写提交信息</strong>：
<ul>
<li>选择提交类型（feat、fix、docs 等）</li>
<li>输入作用域（可选）</li>
<li>编写提交主题</li>
<li>添加详细描述（可选）</li>
</ul>
</li>
<li><strong>确认提交</strong>：查看提交信息并确认</li>
<li><strong>推送代码</strong>：选择是否推送到远程仓库</li>
</ol>
<h2 data-id="heading-22">命令行选项</h2>
<p><code>snail-git-add</code> 提供了丰富的命令行选项，满足不同的使用场景：</p>







































































<table><thead><tr><th>参数</th><th>简写</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>--help</code></td><td><code>-h</code></td><td>显示帮助信息</td><td><code>snail-git-add --help</code></td></tr><tr><td><code>--version</code></td><td><code>-V</code></td><td>显示版本信息</td><td><code>snail-git-add --version</code></td></tr><tr><td><code>--auto-commit</code></td><td>-</td><td>添加文件后自动进入提交流程</td><td><code>snail-git-add --auto-commit</code></td></tr><tr><td><code>--commit-only</code></td><td>-</td><td>只提交已暂存的文件</td><td><code>snail-git-add --commit-only</code></td></tr><tr><td><code>--push-only</code></td><td>-</td><td>只执行推送操作</td><td><code>snail-git-add --push-only</code></td></tr><tr><td><code>--all</code></td><td><code>-a</code></td><td>默认选择所有修改的文件</td><td><code>snail-git-add --all</code></td></tr><tr><td><code>--auto-push</code></td><td>-</td><td>提交后自动推送到远程仓库</td><td><code>snail-git-add --auto-push</code></td></tr><tr><td><code>--status</code></td><td><code>-s</code></td><td>只显示 Git 状态</td><td><code>snail-git-add --status</code></td></tr><tr><td><code>--branches</code></td><td>-</td><td>直接进入分支管理</td><td><code>snail-git-add --branches</code></td></tr><tr><td><code>--log</code></td><td>-</td><td>查看提交历史</td><td><code>snail-git-add --log</code></td></tr></tbody></table>
<h2 data-id="heading-23">实际应用场景</h2>
<h3 data-id="heading-24">日常开发工作流</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 启动主菜单，进行完整的 Git 操作</span>
snail-git-add

<span class="hljs-comment"># 快速提交当前改动，自动进入提交流程</span>
snail-git-add --auto-commit

<span class="hljs-comment"># 提交所有修改的文件并自动推送到远程仓库</span>
snail-git-add --all --auto-commit --auto-push
</code></pre>
<h3 data-id="heading-25">代码审查前整理</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 选择性提交部分文件，保持提交的原子性</span>
snail-git-add

<span class="hljs-comment"># 只提交已暂存的文件（用于拆分大提交）</span>
snail-git-add --commit-only

<span class="hljs-comment"># 查看提交历史，确保提交记录清晰</span>
snail-git-add --<span class="hljs-built_in">log</span>
</code></pre>
<h3 data-id="heading-26">分支管理</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建新分支</span>
snail-git-add --branches

<span class="hljs-comment"># 切换到其他分支</span>
snail-git-add --branches

<span class="hljs-comment"># 合并分支</span>
snail-git-add --branches
</code></pre>
<h2 data-id="heading-27">为什么选择 snail-git-add？</h2>
<ol>
<li><strong>提高开发效率</strong>：简化了 Git 操作流程，减少了命令行输入</li>
<li><strong>规范提交信息</strong>：强制遵循约定式提交规范，提高代码质量</li>
<li><strong>可视化操作</strong>：直观的交互式界面，降低学习成本</li>
<li><strong>完整功能支持</strong>：涵盖从文件管理到远程同步的所有 Git 操作</li>
<li><strong>类型安全</strong>：使用 TypeScript 开发，提供可靠的类型支持</li>
<li><strong>灵活配置</strong>：支持多种使用场景和自定义选项</li>
</ol>
<h2 data-id="heading-28">开发心得与 AI 辅助的价值</h2>
<p>使用 Trae AI 开发 <code>snail-git-add</code> 的过程中，我深刻体会到了 AI 辅助开发的巨大价值：</p>
<ol>
<li><strong>加速开发过程</strong>：快速生成代码框架和核心功能，节省了大量编码时间</li>
<li><strong>提高代码质量</strong>：AI 提供的代码建议和类型定义更加规范和可靠</li>
<li><strong>解决技术难题</strong>：遇到问题时，AI 可以提供多种解决方案和最佳实践</li>
<li><strong>优化用户体验</strong>：AI 协助设计了更加友好的用户交互和命令行输出</li>
<li><strong>降低学习成本</strong>：通过与 AI 的对话，快速掌握新的技术和工具</li>
</ol>
<h2 data-id="heading-29">总结</h2>
<p><code>snail-git-add</code> 是一个功能强大的交互式 Git 工作流工具，它不仅简化了开发者的日常 Git 操作，还通过约定式提交规范提高了代码质量。更重要的是，这个工具展示了 Trae AI 在开发过程中的巨大潜力，从需求分析到最终部署，AI 辅助贯穿始终，大幅提升了开发效率和代码质量。</p>
<p>如果您还在为繁琐的 Git 命令和不规范的提交信息而烦恼，不妨试试 <code>snail-git-add</code>，它将为您带来全新的 Git 工作流体验！</p>
<h2 data-id="heading-30">项目链接</h2>
<ul>
<li>GitHub 仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhu-snail%2Fsnail-git-add" target="_blank" title="https://github.com/hu-snail/snail-git-add" ref="nofollow noopener noreferrer">github.com/hu-snail/sn…</a></li>
<li>npm 包地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsnail-git-add" target="_blank" title="https://www.npmjs.com/package/snail-git-add" ref="nofollow noopener noreferrer">www.npmjs.com/package/sna…</a></li>
</ul>
<p>欢迎大家下载使用并提出宝贵的意见和建议！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[iOS 文件管理的深度实践，多工具协同构建从沙盒到系统级的完整文件操作与调试体系]]></title>    <link>https://juejin.cn/post/7573332163387916342</link>    <guid>https://juejin.cn/post/7573332163387916342</guid>    <pubDate>2025-11-17T07:00:06.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573332163387916342" data-draft-id="7573336057480429574" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="iOS 文件管理的深度实践，多工具协同构建从沙盒到系统级的完整文件操作与调试体系"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-17T07:00:06.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aiopencode"/> <meta itemprop="url" content="https://juejin.cn/user/1898230261493865"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            iOS 文件管理的深度实践，多工具协同构建从沙盒到系统级的完整文件操作与调试体系
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1898230261493865/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aiopencode
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T07:00:06.000Z" title="Mon Nov 17 2025 07:00:06 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 iOS 生态中，<strong>文件管理（File Management）</strong> 一直是开发者最关心、同时也是限制最多的领域之一。
由于苹果的沙盒安全体系、文件权限控制、隐私机制不断增强，如何在不越狱的前提下安全、稳定、高效地访问 App 文件、系统日志、缓存数据、用户目录等，就成为开发调试过程中必须解决的问题。</p>
<p>相比 Android 的开放式文件系统，iOS 文件结构更严格、更难以直接访问，这意味着开发者必须掌握一套<strong>多工具组合的文件管理方法</strong>，才能更好地进行：</p>
<ul>
<li>App 调试与数据验证</li>
<li>日志分析与崩溃排查</li>
<li>性能优化与文件读写监控</li>
<li>配置文件管理与数据迁移</li>
<li>用户行为分析与历史记录调阅</li>
</ul>
<p>本篇文章将基于开发者常用的 <strong>Xcode、克魔（KeyMob）、iMazing、macOS Finder、Apple Configurator</strong> 等工具，构建一套从沙盒到系统级的“iOS 文件管理全流程方案”，适合原生、跨端（Flutter、uni-app）与多场景调试需求。</p>
<hr/>
<h2 data-id="heading-0">一、iOS 文件系统结构：理解沙盒是核心起点</h2>
<p>即便使用工具，你仍需要理解 iOS 的文件体系。一个 iOS App 的沙盒通常包含：</p>
<pre><code class="hljs">App.app（可执行文件）
 ├── Documents/（可写，可同步）
 ├── Library/
 │     ├── Preferences/（配置）
 │     └── Caches/（缓存）
 ├── tmp/（临时文件）
 └── Container Metadata（系统维护）
</code></pre>
<p>以及系统级路径（受权限限制）：</p>
<ul>
<li>/var/mobile/Media/</li>
<li>/var/mobile/Containers/Data/</li>
<li>/private/var/logs/（系统日志）</li>
<li>/private/var/mobile/Library/（系统配置）</li>
</ul>
<p>开发者最常见的需求如：</p>
<ul>
<li>查看 App 数据结构</li>
<li>导出数据库（SQLite）</li>
<li>分析缓存、日志和配置文件</li>
<li>导入测试数据</li>
<li>清理 App 文件以测试某个场景</li>
</ul>
<p>接下来介绍如何利用不同工具实现这些任务。</p>
<hr/>
<h2 data-id="heading-1">二、Xcode：基础但有限的沙盒访问方式</h2>
<p>很多初学者忽略了 Xcode 的文件管理能力，但它确实提供了最原生的沙盒访问方式：</p>
<h3 data-id="heading-2"><strong>1. 通过 Xcode → Devices and Simulators 导出沙盒</strong></h3>
<p>适用于开发签名的 App，可导出：</p>
<ul>
<li>Documents</li>
<li>Library</li>
<li>Caches</li>
<li>tmp</li>
</ul>
<p>操作方式：</p>
<pre><code class="hljs language-bash" lang="bash">Xcode → Window → Devices and Simulators → 选中设备 → Installed Apps → Download Container
</code></pre>
<h3 data-id="heading-3"><strong>优势：</strong></h3>
<ul>
<li>官方工具可靠</li>
<li>适合开发阶段</li>
<li>可快速查看容器内容</li>
</ul>
<h3 data-id="heading-4"><strong>不足：</strong></h3>
<ul>
<li>无法查看系统级文件</li>
<li>无法查看非调试安装的 App</li>
<li>不能实时查看或修改文件</li>
</ul>
<p>适合初期调试，但不适合深入分析。</p>
<hr/>
<h2 data-id="heading-5">三、克魔（KeyMob）：非越狱条件下最强的多维文件管理工具</h2>
<p>相比其他工具，<strong>克魔（KeyMob）</strong> 在 iOS 文件管理领域更偏“开发者工具链”角色，具备大量其他工具做不到的能力。</p>
<h3 data-id="heading-6"><strong>1. 查看与管理多个文件区域</strong></h3>
<p>可查看：</p>
<ul>
<li>App 沙盒（Documents / Caches / tmp / Library）</li>
<li>用户文件（照片、媒体、下载等）</li>
<li>系统文件（日志、诊断、缓存）</li>
<li>设备运行日志文件夹</li>
</ul>
<h3 data-id="heading-7"><strong>2. 文件操作能力强（无需越狱）</strong></h3>
<ul>
<li>创建 / 修改 / 删除 文件</li>
<li>上传电脑文件至 iPhone</li>
<li>下载 App 整个数据目录</li>
<li>修改配置文件（如 JSON、plist）</li>
</ul>
<h3 data-id="heading-8"><strong>3. 独特的 App 文件解密能力</strong></h3>
<p>这是大多数工具没有的功能：</p>
<p>可导出 App 内部加密后的数据，包括但不限于：</p>
<ul>
<li>视频、音频缓存</li>
<li>配置文件</li>
<li>聊天记录</li>
<li>历史数据目录</li>
</ul>
<p>适合调试数据落盘是否正常、网络缓存策略是否生效等场景。</p>
<h3 data-id="heading-9"><strong>4. 多平台支持</strong></h3>
<p>Windows / macOS / Linux 均可使用。</p>
<h3 data-id="heading-10"><strong>适合场景：</strong></h3>
<ul>
<li>深入调试 App 文件结构</li>
<li>查看系统日志</li>
<li>导出大规模文件</li>
<li>分析线上用户问题</li>
<li>iOS 开发者必备的日常工具</li>
</ul>
<hr/>
<h2 data-id="heading-11">四、iMazing：可视化文件管理的经典工具</h2>
<p>对于需要查看手机内容（而不仅限于 App 沙盒）的开发者，<strong>iMazing 是经典选择</strong>。</p>
<h3 data-id="heading-12">功能包括：</h3>
<ul>
<li>App 沙盒访问</li>
<li>应用备份与还原</li>
<li>导出短信、通讯录、照片等用户数据</li>
<li>管理系统日志与诊断信息</li>
</ul>
<h3 data-id="heading-13">优点：</h3>
<ul>
<li>用户体验友好</li>
<li>适合产品测试人员</li>
<li>可查看系统侧目录</li>
</ul>
<h3 data-id="heading-14">不足：</h3>
<ul>
<li>文件访问层级有限</li>
<li>不支持实时日志</li>
<li>不适合作为开发者深度调试工具</li>
</ul>
<p>适合非开发人员或轻量级文件访问场景。</p>
<hr/>
<h2 data-id="heading-15">五、macOS Finder：最符合用户习惯的轻量方式</h2>
<p>从 iOS 13 开始，iPhone 可以直接通过 Finder 管理部分 App 文件，但前提是 App 开启了 File Sharing。</p>
<h3 data-id="heading-16">Finder 可查看：</h3>
<ul>
<li>Document 目录</li>
<li>挂载的用户可编辑文件</li>
</ul>
<h3 data-id="heading-17">优点：</h3>
<ul>
<li>原生、安全</li>
<li>简单易用</li>
</ul>
<h3 data-id="heading-18">不足：</h3>
<ul>
<li>只能访问 File Sharing 暴露的目录</li>
<li>App 大多不会开放</li>
</ul>
<p>适合特定测试用途，不适合开发者使用。</p>
<hr/>
<h2 data-id="heading-19">六、Apple Configurator：系统级文件与描述文件管理</h2>
<p>很多企业项目会接触到 <strong>Apple Configurator 2</strong>。</p>
<p>可用于：</p>
<ul>
<li>批量导入配置文件（描述文件）</li>
<li>管理 MDM 配置</li>
<li>导出设备诊断日志</li>
<li>安装企业证书 / App</li>
</ul>
<p>虽然不适合日常文件管理，但在企业项目中非常重要。</p>
<hr/>
<h2 data-id="heading-20">七、网络工具：用于验证文件下载/上传逻辑</h2>
<p>例如：</p>
<ul>
<li>Charles</li>
<li>Proxyman</li>
</ul>
<p>可调试：</p>
<ul>
<li>文件下载走 CDN 是否正常</li>
<li>文件上传接口是否有问题</li>
<li>缓存策略是否生效</li>
</ul>
<p>常用于调试 App 的文件业务功能。</p>
<hr/>
<h2 data-id="heading-21">八、多工具协同构建的“iOS 文件管理体系”</h2>













































<table><thead><tr><th>功能需求</th><th>推荐工具组合</th><th>适用场景</th></tr></thead><tbody><tr><td>沙盒数据修改/查看</td><td>KeyMob + Xcode</td><td>开发与调试</td></tr><tr><td>系统日志分析</td><td>KeyMob + Console.app</td><td>性能与崩溃分析</td></tr><tr><td>文件加密内容导出</td><td>KeyMob</td><td>数据调试</td></tr><tr><td>测试人员文件管理</td><td>iMazing + Finder</td><td>非开发人员</td></tr><tr><td>企业设备调试</td><td>Apple Configurator</td><td>MDM/配置管理</td></tr><tr><td>网络文件调试</td><td>Charles + KeyMob</td><td>下载、缓存验证</td></tr><tr><td>上线问题排查</td><td>KeyMob + Crashlytics</td><td>用户问题定位</td></tr></tbody></table>
<p>通过组合工具，你可以从<strong>底层 → 系统 → 沙盒 → 用户端</strong> 构建完整调试链路。</p>
<hr/>
<h2 data-id="heading-22">九、实战案例：如何定位“文件未成功落盘”的问题？</h2>
<p>某聊天类App出现用户反馈“历史消息会丢失”。
调试过程：</p>
<h3 data-id="heading-23">Xcode 导出沙盒</h3>
<p>未看到预期数据库文件。</p>
<h3 data-id="heading-24">KeyMob 实时查看文件变化</h3>
<p>发现写入失败时系统日志出现：</p>
<pre><code class="hljs language-objectivec" lang="objectivec"><span class="hljs-built_in">NSFileWriteOutOfSpaceError</span>
</code></pre>
<h3 data-id="heading-25">KeyMob 查看系统日志</h3>
<p>发现磁盘空间清理机制频繁启动。</p>
<h3 data-id="heading-26">Charles 验证同步 API</h3>
<p>接口无异常。</p>
<p>最终确认原因：
<strong>App 在写文件前没有检查可用磁盘空间，导致写入失败。</strong></p>
<p>经过改动后，问题彻底解决。</p>
<hr/>
<h2 data-id="heading-27">文件管理能力，是 iOS 调试的基础与核心</h2>
<p>优秀开发者不仅要会写代码，更要能够：</p>
<p><strong>看到 App 存了什么、丢了什么、写进去什么、从哪里读出来。</strong></p>
<p>而这离不开工具链协同：</p>
<ul>
<li>Xcode：基础容器导出</li>
<li>KeyMob：系统级、深度级管理</li>
<li>iMazing/Finder：轻量级访问</li>
<li>Charles：网络层文件调试</li>
<li>Configurator：企业级调试</li>
</ul>
<p>当你掌握这套文件管理体系，iOS 调试效率会提升数倍以上。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>