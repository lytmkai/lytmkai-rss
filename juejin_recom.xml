<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[Guava 迭代器增强类介绍]]></title>    <link>https://juejin.cn/post/7570903763722453002</link>    <guid>https://juejin.cn/post/7570903763722453002</guid>    <pubDate>2025-11-10T16:17:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570903763722453002" data-draft-id="7570897638441320475" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Guava 迭代器增强类介绍"/> <meta itemprop="keywords" content="后端,Java,设计模式"/> <meta itemprop="datePublished" content="2025-11-10T16:17:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="桦说编程"/> <meta itemprop="url" content="https://juejin.cn/user/2212689394274136"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Guava 迭代器增强类介绍
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2212689394274136/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    桦说编程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T16:17:00.000Z" title="Mon Nov 10 2025 16:17:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Guava 库为 Java 开发者提供了一系列强大的迭代器增强工具，它们简化了复杂迭代模式的实现。本文将深入探讨 Guava 的 PeekingIterator、AbstractIterator 和 AbstractSequentialIterator。</p>
<h3 data-id="heading-0">1. PeekingIterator：洞察先机</h3>
<p>标准的 Iterator 接口仅提供 hasNext() 和 next() 方法，这在某些场景下显得力不从心。当需要“预读”下一个元素以做出决策，但又不想立即消耗它时，PeekingIterator 应运而生。</p>
<p><strong>核心功能：</strong></p>
<ul>
<li><code>Iterators.peekingIterator(Iterator)</code> 方法用于将现有的 <code>Iterator</code> 包装成一个 <code>PeekingIterator</code>。</li>
<li>其核心方法是 <code>peek()</code>，允许在不推进迭代器的情况下，查看下一个调用 <code>next()</code> 时将返回的元素。</li>
</ul>
<p><strong>它带来的便利：</strong></p>
<p>PeekingIterator 的 <code>peek()</code> 方法能够支持更灵活的迭代逻辑，尤其是在需要根据当前元素和“下一个”元素关系进行判断的场景中。它允许在一次迭代过程中完成复杂的逻辑判断和数据处理，避免了传统方法中可能出现的冗余 <code>next()</code> 调用或额外的状态变量管理。</p>
<p><strong>示例：消除连续重复元素</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PeekingIteratorExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        List&lt;Integer&gt; source = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
        List&lt;Integer&gt; result = Lists.newArrayList();

        PeekingIterator&lt;Integer&gt; iter = Iterators.peekingIterator(source.iterator());

        <span class="hljs-keyword">while</span> (iter.hasNext()) {
            <span class="hljs-type">Integer</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> iter.next(); <span class="hljs-comment">// 获取当前元素</span>
            result.add(current); <span class="hljs-comment">// 将当前元素添加到结果</span>

            <span class="hljs-comment">// 利用 peek() 提前判断，如果下一个元素与当前元素重复，则跳过。</span>
            <span class="hljs-keyword">while</span> (iter.hasNext() &amp;&amp; iter.peek().equals(current)) {
                iter.next(); <span class="hljs-comment">// 跳过这个重复元素</span>
            }
        }
        System.out.println(<span class="hljs-string">"Original: "</span> + source);
        System.out.println(<span class="hljs-string">"Deduplicated: "</span> + result); <span class="hljs-comment">// Output: [1, 2, 3, 4, 5]</span>
    }
}
</code></pre>
<p>在此示例中，我们仅对 <code>source</code> 列表进行了一次逻辑遍历。PeekingIterator 使得我们能够在处理 <code>current</code> 元素的同时，预判并跳过所有后续的重复项，而无需将它们存储到任何中间结构或进行后续的去重处理。这简化了去重逻辑的实现。</p>
<p><strong>注意事项：</strong> 由 <code>Iterators.peekingIterator</code> 返回的 <code>PeekingIterator</code> 不支持在调用 <code>peek()</code> 之后执行 <code>remove()</code> 操作。</p>
<h3 data-id="heading-1">2. AbstractIterator：一个方法定义迭代器</h3>
<p>当需要实现一个自定义的 Iterator，例如对数据进行过滤、转换或从复杂数据源中提取时，手动管理 <code>hasNext()</code> 和 <code>next()</code> 的内部状态会引入大量样板代码。AbstractIterator 极大地简化了这一过程。</p>
<p><strong>核心功能：</strong></p>
<ul>
<li>开发者只需实现一个方法：<code>computeNext()</code>。此方法负责计算并返回序列中的下一个值。</li>
<li>当迭代序列完成时，<code>computeNext()</code> 应返回 <code>endOfData()</code> 以标记迭代结束。</li>
</ul>
<p><strong>它带来的便利：</strong></p>
<p>AbstractIterator 采用惰性求值（lazy evaluation）机制。它确保 <code>computeNext()</code> 方法仅在真正需要下一个元素（即 <code>next()</code> 被调用时）才会被执行。这使得迭代器能够按需生成元素，避免了在迭代器未被完全消费时进行不必要的计算。同时，Guava 负责处理 <code>hasNext()</code> 和 <code>next()</code> 之间的状态同步，简化了自定义迭代器的实现。</p>
<p><strong>示例：惰性过滤 Null 值</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractIteratorExample</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Iterator&lt;String&gt; <span class="hljs-title function_">skipNulls</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Iterator&lt;String&gt; in)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractIterator</span>&lt;String&gt;() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">computeNext</span><span class="hljs-params">()</span> {
                <span class="hljs-keyword">while</span> (in.hasNext()) {
                    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> in.next();
                    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">return</span> s; <span class="hljs-comment">// 找到非 null 元素，返回</span>
                    }
                }
                <span class="hljs-keyword">return</span> endOfData(); <span class="hljs-comment">// 内部迭代器耗尽，返回 endOfData()</span>
            }
        };
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        List&lt;String&gt; source = Arrays.asList(<span class="hljs-string">"hello"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"world"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"guava"</span>, <span class="hljs-string">"java"</span>);
        Iterator&lt;String&gt; filteredIterator = skipNulls(source.iterator());

        System.out.println(<span class="hljs-string">"Filtered elements (only consuming first 3):"</span>);
        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (filteredIterator.hasNext() &amp;&amp; count &lt; <span class="hljs-number">3</span>) { <span class="hljs-comment">// 假设我们只消费前3个元素</span>
            System.out.println(filteredIterator.next());
            count++;
        }
        <span class="hljs-comment">// Output:</span>
        <span class="hljs-comment">// hello</span>
        <span class="hljs-comment">// world</span>
        <span class="hljs-comment">// guava</span>
    }
}
</code></pre>
<p>在此示例中，即使 <code>source</code> 列表中有更多元素，我们只消费了前 3 个非空字符串。AbstractIterator 确保了 <code>in.next()</code> 和 <code>if (s != null)</code> 这样的操作仅执行了刚好足以找到这 3 个元素所需的最小次数。这种按需计算的模式，使得迭代器只在需要时才处理数据。</p>
<p><strong>限制：</strong> AbstractIterator 继承自 <code>UnmodifiableIterator</code>，这意味着它禁止实现 <code>remove()</code> 方法。如果您的迭代器必须支持 <code>remove()</code>，则不应继承 AbstractIterator。</p>
<pre><code class="hljs language-java" lang="java"/></pre>
<h3 data-id="heading-2">3. AbstractSequentialIterator</h3>
<p>对于那些下一个值很容易根据前一个值计算出来的迭代器，AbstractSequentialIterator 提供了一种表达迭代的替代方式。</p>
<p><strong>核心功能：</strong></p>
<ul>
<li>开发者实现的方法是 <code>computeNext(T previous)</code>，它接受序列中的前一个值作为参数。</li>
<li>必须在构造函数中提供一个初始值（或者如果迭代器应立即终止，则传入 <code>null</code>）。</li>
<li><code>computeNext()</code> 方法约定，返回 <code>null</code> 意味着迭代结束。</li>
</ul>
<p><strong>它带来的便利：</strong></p>
<p>AbstractSequentialIterator 适用于那些下一个值可以根据前一个值计算出来的序列。它通过**按需生成（on-demand generation）**机制，仅在 <code>next()</code> 被调用时才计算下一个元素。这使得它非常适合处理可能非常长甚至无限的序列，因为它避免了预先计算和存储整个序列。</p>
<p><strong>示例：惰性计算 2 的幂次</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSequentialIteratorExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 从1开始生成2的幂次方，直到达到 1 &lt;&lt; 30</span>
        Iterator&lt;Integer&gt; powersOfTwo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractSequentialIterator</span>&lt;Integer&gt;(<span class="hljs-number">1</span>) {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">computeNext</span><span class="hljs-params">(Integer previous)</span> {
                <span class="hljs-comment">// 如果 previous 已经达到最大值，则返回 null 结束迭代</span>
                <span class="hljs-keyword">return</span> (previous == <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) ? <span class="hljs-literal">null</span> : previous * <span class="hljs-number">2</span>;
            }
        };

        System.out.println(<span class="hljs-string">"Powers of two (only consuming first 7):"</span>);
        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (powersOfTwo.hasNext() &amp;&amp; count &lt; <span class="hljs-number">7</span>) { <span class="hljs-comment">// 假设我们只消费前7个元素</span>
            System.out.println(powersOfTwo.next());
            count++;
        }
        <span class="hljs-comment">// Output: 1, 2, 4, 8, 16, 32, 64</span>
    }
}
</code></pre>
<p>在此示例中，我们仅消费了序列的前 7 个元素。AbstractSequentialIterator 确保了只有这 7 次乘法操作被执行，并且在内存中只维护了当前 <code>previous</code> 元素的状态。这种惰性生成方式，避免了对整个序列进行预计算和存储的需要。</p>
<p><strong>关键限制：</strong> 由于返回 <code>null</code> 标志着迭代的结束，因此 AbstractSequentialIterator 不能用于实现一个可以合法返回 <code>null</code> 元素的迭代器。</p>
<p>笔者遇到一个按需深拷贝的需求，简单描述为：已获得对象a，需要深拷贝若干份，同时需要标记序号，a已经实现deepCopy方法。实现如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 实现1</span>
<span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> getA();
<span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x: request.getXList()) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (first) {
            x.setA(a);
            first = <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-type">A</span> <span class="hljs-variable">newA</span> <span class="hljs-operator">=</span> a.deepCopy();
            newA.seq++;
            x.setA(newA);
        }
    }
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 实现2，修改引用a</span>
<span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> getA();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x: request.getXList()) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) {
        x.setA(a);
        a = a.deepCopy(); <span class="hljs-comment">//会多复制一次</span>
        a.seq++;
    }
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 新实现</span>
<span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> getA();
<span class="hljs-comment">// copy iter</span>
Iterator&lt;A&gt; aIter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractSequentialIterator</span>&lt;&gt;(a) {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> A <span class="hljs-title function_">computeNext</span><span class="hljs-params">(A prev)</span> {
        <span class="hljs-type">A</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> prev.deepCopy();
        result.seq++;
        <span class="hljs-keyword">return</span> result;
    }
};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x: request.getXList()) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span>) {
        x.setA(aIter.next());
    }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>和原有实现相比，新实现抽取出了A的迭代逻辑，更好理解。</p>
<h3 data-id="heading-3">总结</h3>
<p>Guava 的 PeekingIterator、AbstractIterator 和 AbstractSequentialIterator 为 Java 开发者提供了强大的工具，用于简化和增强迭代器的使用。它们通过以下方式提升代码的健壮性和可维护性：</p>
<ul>
<li><strong>PeekingIterator：</strong> 允许在单次遍历中进行预判和复杂逻辑处理，减少了状态管理和冗余操作。</li>
<li><strong>AbstractIterator：</strong> 强制惰性求值，简化了自定义迭代器的实现，并按需处理数据。</li>
<li><strong>AbstractSequentialIterator：</strong> 实现按需生成序列，适用于处理长序列，避免了不必要的预计算和存储。</li>
</ul>
<p>在处理数据流、构建数据管道或实现复杂业务逻辑时，合理利用这些迭代器，可以使代码更加清晰、灵活，并更好地管理资源。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[测试自动化Replay：让数据库迁移测试回归真实场景的一把“利器”]]></title>    <link>https://juejin.cn/post/7570903763722321930</link>    <guid>https://juejin.cn/post/7570903763722321930</guid>    <pubDate>2025-11-10T15:05:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570903763722321930" data-draft-id="7570912420568367114" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="测试自动化Replay：让数据库迁移测试回归真实场景的一把“利器”"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T15:05:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="我是杰尼"/> <meta itemprop="url" content="https://juejin.cn/user/4200579899599495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            测试自动化Replay：让数据库迁移测试回归真实场景的一把“利器”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4200579899599495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    我是杰尼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T15:05:41.000Z" title="Mon Nov 10 2025 15:05:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">测试自动化Replay：让数据库迁移测试回归真实场景的一把“利器”</h2>
<p>在当前数据库国产化的大趋势下，越来越多的企业开始从传统进口数据库向国产数据库进行替代。然而，真正影响迁移进度的往往不是数据迁移本身，而是 <strong>测试验证环节</strong>。</p>
<p>如果测试不能覆盖真实业务场景，迁移后的系统上线后很可能出现：</p>
<ul>
<li>性能明显下降</li>
<li>并发冲突和慢查询频发</li>
<li>数据一致性异常难以定位</li>
</ul>
<p>很多企业迁移项目延期 1~3 个月，根本原因都指向了同一个问题：<strong>测试不够真实</strong>。</p>
<p>那么，是否有办法把“生产环境正在发生的真实行为”，直接搬进测试环境中来复现？
这便是本文要介绍的实践方向：<strong>生产负载回放（Replay）技术</strong>。</p>
<hr/>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61cb0ad2efe74364b0b6762d536b7b81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv5p2w5bC8:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763391940&amp;x-signature=Dc6XybQ1Aqqp1rO2fgcVtBIiyKs%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-1"><strong>一、迁移测试为何总是难以做好？</strong></h3>
<p>数据库迁移测试，传统方式多依赖人力编写 SQL、脚本模拟业务场景，但这类手段存在天然限制：</p>





















<table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td><strong>场景覆盖不足</strong></td><td>人工用例只关注核心流程，真实环境中大量边缘并发场景无法覆盖</td></tr><tr><td><strong>性能测试失真</strong></td><td>自制压力脚本无法复现业务峰值特征与并发模型</td></tr><tr><td><strong>回归测试成本高</strong></td><td>配置变更 / 参数调优后，需要重复大量验证工作</td></tr></tbody></table>
<p>简单来说：<strong>你测到的系统和你要上线的系统不是同一个系统。</strong></p>
<p>就像有句话说的：</p>
<blockquote>
<p><em>“在实验室跑得再顺，也不代表能扛住双十一。”</em></p>
</blockquote>
<p>迁移测试缺的，就是 <strong>真实业务负载本身</strong>。</p>
<hr/>
<h3 data-id="heading-2"><strong>二、解决思路：把生产环境“录下来，再放一遍”</strong></h3>
<p>为了让测试贴近真实业务，技术团队采用了 <strong>KReplay 生产负载回放工具</strong>，其核心思路可概括为四步：</p>
<blockquote>
<p><strong>采 → 转 → 放 → 核</strong></p>
<p>即：采集真实流量 → 转换适配 → 回放执行 → 结果比对</p>
</blockquote>
<h4 data-id="heading-3"><strong>1. 业务负载采集（Capture）</strong></h4>
<p>从旧数据库（如 Oracle）中持续记录真实业务操作，包括：</p>
<ul>
<li>SQL 语句 + 入参变量</li>
<li>会话 ID、事务边界</li>
<li>执行时序与并发关系</li>
</ul>
<p>示例（Oracle 端开启负载采集）：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">BEGIN</span>
  DBMS_WORKLOAD_CAPTURE.START_CAPTURE(
    name <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">'daily_load_capture'</span>,
    dir  <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">'CAP_DIR'</span>,
    duration <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-number">72000</span>   <span class="hljs-comment">-- 采集 20小时</span>
  );
<span class="hljs-keyword">END</span>;
<span class="hljs-operator">/</span>
</code></pre>
<p>此过程对生产环境影响极低（CPU &lt; 5%），可安全运行。</p>
<hr/>
<h4 data-id="heading-4"><strong>2. 负载转换（Convert）</strong></h4>
<p>由于不同数据库在语法、类型、函数上存在差异，需要自动转换：</p>





















<table><thead><tr><th>Oracle</th><th>KingbaseES</th></tr></thead><tbody><tr><td><code>ROWNUM</code></td><td><code>LIMIT</code></td></tr><tr><td><code>NVL(a,b)</code></td><td><code>COALESCE(a,b)</code></td></tr><tr><td><code>DATE</code> 精度</td><td><code>TIMESTAMP</code> 精度扩展</td></tr></tbody></table>
<p>该步骤由工具自动完成，实测自动化适配率可达 <strong>99%+</strong>，大幅减少人工改写。</p>
<hr/>
<h4 data-id="heading-5"><strong>3. 高保真负载回放（Replay）</strong></h4>
<p>转换后的负载在新数据库上按原始执行节奏复现。</p>
<p>支持三种模式：</p>





















<table><thead><tr><th>模式</th><th>用途</th></tr></thead><tbody><tr><td>原速回放</td><td>验证稳定性</td></tr><tr><td>加速回放（例如 ×2）</td><td>短时间内压测性能瓶颈</td></tr><tr><td>减速回放（例如 ÷2）</td><td>用于定位复杂慢 SQL / 锁等待问题</td></tr></tbody></table>
<p>同时生成 <strong>KWR 性能分析报告</strong>（类似 Oracle AWR），覆盖：</p>
<ul>
<li>I/O 压力情况</li>
<li>缓存命中率</li>
<li>锁等待关系</li>
<li>Top SQL 分布</li>
</ul>
<p>让 DBA 能够直观看到性能差异根因。</p>
<hr/>
<h4 data-id="heading-6"><strong>4. 数据一致性比对（Validate）</strong></h4>
<p>通过 <strong>KDTS 数据比对工具</strong>，实现源库与目标库的数据结构 &amp; 内容双向验证：</p>
<ul>
<li>表行数是否一致</li>
<li>字段值逐条比对（含 BLOB / CLOB）</li>
<li>索引 / 外键 / 触发器等元信息检查</li>
</ul>
<p>一旦发现差异，自动生成差异报告，定位到表 + 行 + 字段。</p>
<p>不再需要熬夜查日志、写脚本、做人工抽查。</p>
<hr/>
<h3 data-id="heading-7"><strong>三、实战案例：某大型汽车制造集团 ERP 迁移</strong></h3>






























<table><thead><tr><th>指标</th><th>引入 Replay 前</th><th>引入后</th></tr></thead><tbody><tr><td>测试周期</td><td>6 周</td><td><strong>3 周（缩短 50%）</strong></td></tr><tr><td>场景覆盖率</td><td>约 40%</td><td><strong>达到 100%（真实业务全量复现）</strong></td></tr><tr><td>人工测试工作量</td><td>高</td><td><strong>减少 70%+</strong></td></tr><tr><td>上线风险</td><td>迁移后仍需线上观察</td><td><strong>迁移前风险可提前暴露与修复</strong></td></tr></tbody></table>
<p>一句话：
<strong>他们不再“靠运气上线”，而是“上线前就知道会不会出事”。</strong></p>
<hr/>
<h3 data-id="heading-8"><strong>四、总结：迁移测试的未来属于“真实验证”</strong></h3>
<p>传统迁移测试的上限是“可用”，而生产负载回放的目标是 <strong>“可放心上线”</strong>。</p>
<h4 data-id="heading-9"><strong>Replay 技术带来的改变</strong></h4>
<p>✅ 测试从“模拟”升级为“实战复刻”
✅ 性能瓶颈能提前暴露，而不是上线后报警
✅ 回归测试不再是耗时黑洞
✅ 迁移成功率显著提升</p>
<p>随着 AI 与自动诊断能力逐步融入，未来负载回放将不仅能“复现问题”，还将能“提前预测问题”。</p>
<blockquote>
<p><strong>测试不再只是验证，而是决策可信性的核心依据。</strong></p>
</blockquote>
<p>在数据库国产化迁移进入深水区的今天，问题不再只是“能否平替”，而是 能否稳定上线、可控运维、长期可靠运行。传统测试方式由于脱离真实业务环境，无法有效暴露潜在性能瓶颈和兼容性风险，已逐渐成为迁移项目的主要阻碍。而以 KReplay 为代表的 生产负载回放技术，通过“真实负载采集 + 自动化转换 + 高保真回放 + 完整结果比对”的闭环能力，让测试从“静态验证”走向“真实预演”，显著提升了迁移效率、可控性与系统上线成功率。</p>
<p>事实证明，真实负载本身就是最好的测试用例。在可预见的未来，企业级系统的迁移与回归验证将越来越依赖这类场景复刻与智能分析的技术体系。对于正在推进数据库国产化或大型系统平台迁移的企业而言，尽早将生产级回放能力纳入测试体系，将不只是提升效率的选择，更是降低风险、保障业务连续性的关键一步。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[FastAPI × Loguru：从“能跑”到“可运维”的日志实战]]></title>    <link>https://juejin.cn/post/7570912420568350730</link>    <guid>https://juejin.cn/post/7570912420568350730</guid>    <pubDate>2025-11-10T14:57:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570912420568350730" data-draft-id="7570912420568334346" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="FastAPI × Loguru：从“能跑”到“可运维”的日志实战"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T14:57:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java私教"/> <meta itemprop="url" content="https://juejin.cn/user/3394924618197325"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            FastAPI × Loguru：从“能跑”到“可运维”的日志实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3394924618197325/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java私教
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T14:57:18.000Z" title="Mon Nov 10 2025 14:57:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>一句话总结<br/>
把散落在 Uvicorn / FastAPI / 业务代码里的所有日志，<strong>全部收敛到 Loguru 一个管道</strong>，统一格式、统一分级、统一落盘，并解决重复输出、异步安全、请求溯源三大痛点。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">1. 为什么要“多此一举”？</h2>






























<table><thead><tr><th>痛点</th><th>原生 logging 的表现</th><th>Loguru 的改进</th></tr></thead><tbody><tr><td><strong>重复输出</strong></td><td>Uvicorn 与 FastAPI 各用各的 Handler，一条请求在终端出现 2~3 次</td><td>拦截标准库，彻底干掉重复 Handler</td></tr><tr><td><strong>格式不统一</strong></td><td>access 日志无颜色，业务日志难加字段</td><td>一份模板控制所有目的地，支持彩色/JSON</td></tr><tr><td><strong>异步安全</strong></td><td>多 worker 下文件锁竞争，出现错乱</td><td><code>enqueue=True</code> 内部队列 + 协程安全</td></tr><tr><td><strong>可观测性</strong></td><td>报错时只能看到框架栈，找不到业务参数</td><td>中间件注入 request_id，一次 grep 定位全链路</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-1">2. 最小可运行版本（MVP）</h2>
<p><strong>安装依赖</strong></p>
<pre><code class="hljs language-bash" lang="bash">pip install fastapi uvicorn[standard] loguru
</code></pre>
<p><strong>main.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger
<span class="hljs-keyword">import</span> uvicorn, sys

<span class="hljs-comment"># 1. 移除默认 handler，防止重复</span>
logger.remove()
logger.add(sys.stdout,
           colorize=<span class="hljs-literal">True</span>,
           <span class="hljs-built_in">format</span>=<span class="hljs-string">"&lt;green&gt;{time:HH:mm:ss}&lt;/green&gt; | &lt;lvl&gt;{level: &lt;8}&lt;/lvl&gt; | {message}"</span>)

app = FastAPI()

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/ping"</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">ping</span>():
    logger.info(<span class="hljs-string">"pong"</span>)
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"msg"</span>: <span class="hljs-string">"pong"</span>}

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># 2. 关键：禁用 uvicorn 的默认日志配置</span>
    uvicorn.run(<span class="hljs-string">"main:app"</span>, host=<span class="hljs-string">"0.0.0.0"</span>, port=<span class="hljs-number">8000</span>, log_config=<span class="hljs-literal">None</span>)
</code></pre>
<blockquote>
<p>终端现在只有一行带颜色的 <code>pong</code>，世界安静了。</p>
</blockquote>
<hr/>
<h2 data-id="heading-2">3. 生产级脚手架：七步统一日志</h2>
<p>把下面代码放到 <code>app/core/logging.py</code>，项目启动时一次 <code>setup_logging()</code> 即可。</p>













































<table><thead><tr><th>步骤</th><th>目的</th><th>关键参数</th></tr></thead><tbody><tr><td>① 清空默认</td><td>防止重复</td><td><code>logger.remove()</code></td></tr><tr><td>② 彩色终端</td><td>开发调试</td><td><code>colorize=True</code></td></tr><tr><td>③ 文件轮转</td><td>避免打爆磁盘</td><td><code>rotation="100 MB", retention="30 days"</code></td></tr><tr><td>④ 错误分流</td><td>error.log 单独分析</td><td><code>level="ERROR"</code></td></tr><tr><td>⑤ 异步写入</td><td>高并发不阻塞</td><td><code>enqueue=True</code></td></tr><tr><td>⑥ 拦截标准库</td><td>收编 Uvicorn</td><td><code>InterceptHandler</code></td></tr><tr><td>⑦ 注入 request_id</td><td>全链路追踪</td><td><code>bind(request_id=...)</code></td></tr></tbody></table>
<p><strong>完整代码（可直接复用）</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> logging, sys, os
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger
<span class="hljs-keyword">from</span> contextvars <span class="hljs-keyword">import</span> ContextVar

<span class="hljs-comment"># 全链路 request_id</span>
request_id: ContextVar[<span class="hljs-built_in">str</span>] = ContextVar(<span class="hljs-string">"request_id"</span>, default=<span class="hljs-string">"-"</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptHandler</span>(logging.Handler):
    <span class="hljs-string">"""把标准库日志无缝转到 loguru"""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">emit</span>(<span class="hljs-params">self, record: logging.LogRecord</span>):
        <span class="hljs-keyword">try</span>:
            level = logger.level(record.levelname).name
        <span class="hljs-keyword">except</span> ValueError:
            level = record.levelno
        frame, depth = logging.currentframe(), <span class="hljs-number">2</span>
        <span class="hljs-keyword">while</span> frame <span class="hljs-keyword">and</span> frame.f_code.co_filename == logging.__file__:
            frame = frame.f_back
            depth += <span class="hljs-number">1</span>
        logger.opt(depth=depth, exception=record.exc_info).log(
            level, record.getMessage()
        )

<span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_logging</span>():
    log_dir = Path(<span class="hljs-string">"logs"</span>)
    log_dir.mkdir(exist_ok=<span class="hljs-literal">True</span>)

    <span class="hljs-comment"># 统一格式</span>
    fmt = (<span class="hljs-string">"&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSS}&lt;/green&gt; | "</span>
           <span class="hljs-string">"{extra[request_id]} | &lt;lvl&gt;{level: &lt;8}&lt;/lvl&gt; | "</span>
           <span class="hljs-string">"&lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt;:&lt;cyan&gt;{line}&lt;/cyan&gt; - &lt;lvl&gt;{message}&lt;/lvl&gt;"</span>)

    logger.remove()
    logger.add(sys.stdout, <span class="hljs-built_in">format</span>=fmt, level=<span class="hljs-string">"INFO"</span>, colorize=<span class="hljs-literal">True</span>)
    logger.add(log_dir / <span class="hljs-string">"app.log"</span>, rotation=<span class="hljs-string">"100 MB"</span>, retention=<span class="hljs-string">"30 days"</span>, enqueue=<span class="hljs-literal">True</span>, <span class="hljs-built_in">format</span>=fmt)
    logger.add(log_dir / <span class="hljs-string">"error.log"</span>, level=<span class="hljs-string">"ERROR"</span>, rotation=<span class="hljs-string">"100 MB"</span>, retention=<span class="hljs-string">"30 days"</span>, enqueue=<span class="hljs-literal">True</span>, <span class="hljs-built_in">format</span>=fmt)

    <span class="hljs-comment"># 收编三方库</span>
    logging.basicConfig(handlers=[InterceptHandler()], level=logging.INFO)
    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> [<span class="hljs-string">"uvicorn"</span>, <span class="hljs-string">"uvicorn.access"</span>, <span class="hljs-string">"uvicorn.error"</span>, <span class="hljs-string">"fastapi"</span>]:
        _log = logging.getLogger(name)
        _log.handlers = [InterceptHandler()]
        _log.propagate = <span class="hljs-literal">False</span>
</code></pre>
<p><strong>FastAPI 中间件：自动注入 request_id</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Request
<span class="hljs-keyword">import</span> uuid

<span class="hljs-meta">@app.middleware(<span class="hljs-params"><span class="hljs-string">"http"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_request_id</span>(<span class="hljs-params">request: Request, call_next</span>):
    rid = request.headers.get(<span class="hljs-string">"X-Request-ID"</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">str</span>(uuid.uuid4())
    request_id.<span class="hljs-built_in">set</span>(rid)
    <span class="hljs-keyword">with</span> logger.contextualize(request_id=rid):
        logger.info(<span class="hljs-string">f"<span class="hljs-subst">{request.method}</span> <span class="hljs-subst">{request.url.path}</span>"</span>)
        response = <span class="hljs-keyword">await</span> call_next(request)
    response.headers[<span class="hljs-string">"X-Request-ID"</span>] = rid
    <span class="hljs-keyword">return</span> response
</code></pre>
<blockquote>
<p>一次 <code>grep &lt;request_id&gt;</code> 即可把 access + 业务 + 错误 日志全部拉出来。</p>
</blockquote>
<hr/>
<h2 data-id="heading-3">4. 常见问题 FAQ</h2>






























<table><thead><tr><th>现象</th><th>根因</th><th>解法</th></tr></thead><tbody><tr><td>终端仍然出现双份</td><td>旧 handler 未清干净</td><td>确保 <code>logger.remove()</code> 在新增 add 之前执行</td></tr><tr><td>多进程日志错乱</td><td>未开异步队列</td><td>所有 <code>logger.add(..., enqueue=True)</code></td></tr><tr><td>422 报错无请求体</td><td>框架提前抛错</td><td>在中间件里 <code>try/except</code> 并 <code>logger.bind(body=...)</code></td></tr><tr><td>日志文件中文乱码</td><td>Windows 默认 GBK</td><td>显式 <code>encoding="utf-8"</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-4">5. 一键启动脚本</h2>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># run.py</span>
<span class="hljs-keyword">import</span> uvicorn, asyncio
<span class="hljs-keyword">from</span> app.core.logging <span class="hljs-keyword">import</span> setup_logging

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">await</span> setup_logging()
    config = uvicorn.Config(<span class="hljs-string">"app.main:app"</span>, host=<span class="hljs-string">"0.0.0.0"</span>, port=<span class="hljs-number">8000</span>, log_config=<span class="hljs-literal">None</span>)
    server = uvicorn.Server(config)
    <span class="hljs-keyword">await</span> server.serve()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    asyncio.run(main())
</code></pre>
<blockquote>
<p>把 <code>log_config=None</code> 写死，彻底断绝 Uvicorn 自建 handler 的机会。</p>
</blockquote>
<hr/>
<h2 data-id="heading-5">6. 结语</h2>
<p>日志不是“打印字符串”，而是<strong>可观测性的地基</strong>。<br/>
用 Loguru 把格式、分级、轮转、追踪一次做到位，以后查问题只需带上 <code>request_id</code> 和 <code>grep</code>，再也不用面对满屏重复、格式乱糟糟的终端发呆。Happy logging!</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[FastAPI × SQLAlchemy 2.0 Async：从“能跑”到“可压测”的完整工程实践]]></title>    <link>https://juejin.cn/post/7570903763722289162</link>    <guid>https://juejin.cn/post/7570903763722289162</guid>    <pubDate>2025-11-10T15:02:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570903763722289162" data-draft-id="7570897638441238555" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="FastAPI × SQLAlchemy 2.0 Async：从“能跑”到“可压测”的完整工程实践"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T15:02:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java私教"/> <meta itemprop="url" content="https://juejin.cn/user/3394924618197325"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            FastAPI × SQLAlchemy 2.0 Async：从“能跑”到“可压测”的完整工程实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3394924618197325/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java私教
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T15:02:02.000Z" title="Mon Nov 10 2025 15:02:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>一句话总结<br/>
用 <strong>SQLAlchemy 2.0 AsyncIO</strong> 模式，把 FastAPI 的并发优势兑现成 <strong>真正的数据库吞吐</strong>；再叠上连接池、事务、迁移、测试四件套，<strong>直接上线不踩坑</strong>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">1. 为什么要“异步 ORM”？</h2>

























<table><thead><tr><th>场景</th><th>同步 SQLAlchemy</th><th>异步 SQLAlchemy</th></tr></thead><tbody><tr><td>100 个并发上传</td><td>开 100 线程 → 100 个连接 → DB 被打爆</td><td>单线程 20 连接即可跑满 CPU</td></tr><tr><td>请求等待 I/O</td><td>线程上下文切换 8 ms</td><td>协程切换 0.3 ms</td></tr><tr><td>代码风格</td><td>到处 <code>run_in_threadpool</code></td><td>原生 <code>await</code> 一路到底</td></tr></tbody></table>
<blockquote>
<p>一句话：<strong>同步模式把 FastAPI 的异步事件循环拖回解放前</strong>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-1">2. 最小可运行版本（MVP）</h2>
<p><strong>安装依赖</strong></p>
<pre><code class="hljs language-bash" lang="bash">pip install <span class="hljs-string">"fastapi[all]"</span> \
            <span class="hljs-string">"sqlalchemy[asyncio]&gt;=2.0"</span> \
            asyncpg alembic pydantic[email]
</code></pre>
<blockquote>
<p>数据库以 PostgreSQL 为例，MySQL 换成 <code>asyncmy</code> 即可。</p>
</blockquote>
<p><strong>项目骨架</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">app/
 ├─ api/
 │   └─ user.py
 ├─ core/
 │   ├─ db.py
 │   └─ config.py
 ├─ models/
 │   └─ user.py
 ├─ schemas/
 │   └─ user.py
 └─ main.py
</code></pre>
<hr/>
<h2 data-id="heading-2">3. 核心代码：Session 生命周期一条龙</h2>
<p><strong>app/core/config.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseSettings

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Settings</span>(<span class="hljs-title class_ inherited__">BaseSettings</span>):
    database_url: <span class="hljs-built_in">str</span> = <span class="hljs-string">"postgresql+asyncpg://user:pass@localhost:5432/demo"</span>
    pool_size: <span class="hljs-built_in">int</span> = <span class="hljs-number">20</span>
    max_overflow: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>
    echo_sql: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>

    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:
        env_file = <span class="hljs-string">".env"</span>

settings = Settings()
</code></pre>
<p><strong>app/core/db.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> sqlalchemy.ext.asyncio <span class="hljs-keyword">import</span> (
    AsyncEngine, AsyncSession, async_sessionmaker, create_async_engine
)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncDatabaseSession</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, url: <span class="hljs-built_in">str</span>, *, pool_size: <span class="hljs-built_in">int</span> = <span class="hljs-number">20</span>, max_overflow: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>, echo: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span></span>):
        self.engine: AsyncEngine = create_async_engine(
            url,
            pool_size=pool_size,
            max_overflow=max_overflow,
            echo=echo,
            pool_pre_ping=<span class="hljs-literal">True</span>,          <span class="hljs-comment"># 心跳保活</span>
        )
        self.session_factory = async_sessionmaker(
            self.engine,
            expire_on_commit=<span class="hljs-literal">False</span>,      <span class="hljs-comment"># 防止懒加载异常</span>
            class_=AsyncSession,
        )

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">await</span> self.engine.dispose()

db = AsyncDatabaseSession(
    settings.database_url,
    pool_size=settings.pool_size,
    echo=settings.echo_sql,
)
</code></pre>
<p><strong>main.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> app.core.db <span class="hljs-keyword">import</span> db
<span class="hljs-keyword">from</span> app.api <span class="hljs-keyword">import</span> user

app = FastAPI(title=<span class="hljs-string">"Async SQLAlchemy Demo"</span>)

app.include_router(user.router)

<span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">"startup"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">startup</span>():
    <span class="hljs-comment"># 可选：建表</span>
    <span class="hljs-comment"># from app.models import Base</span>
    <span class="hljs-comment"># async with db.engine.begin() as conn:</span>
    <span class="hljs-comment">#     await conn.run_sync(Base.metadata.create_all)</span>
    <span class="hljs-keyword">pass</span>

<span class="hljs-meta">@app.on_event(<span class="hljs-params"><span class="hljs-string">"shutdown"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">shutdown</span>():
    <span class="hljs-keyword">await</span> db.close()
</code></pre>
<hr/>
<h2 data-id="heading-3">4. 依赖注入：每次请求一个 Session，自动回滚</h2>
<p><strong>app/core/deps.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> AsyncGenerator
<span class="hljs-keyword">from</span> app.core.db <span class="hljs-keyword">import</span> db
<span class="hljs-keyword">from</span> sqlalchemy.ext.asyncio <span class="hljs-keyword">import</span> AsyncSession
<span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_session</span>() -&gt; AsyncGenerator[AsyncSession, <span class="hljs-literal">None</span>]:
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> db.session_factory() <span class="hljs-keyword">as</span> session:
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">yield</span> session
        <span class="hljs-keyword">except</span> Exception:
            <span class="hljs-keyword">await</span> session.rollback()
            <span class="hljs-keyword">raise</span>
        <span class="hljs-keyword">finally</span>:
            <span class="hljs-keyword">await</span> session.close()
</code></pre>
<blockquote>
<p>用 <code>yield</code> + <code>rollback</code> 保证<strong>请求级事务</strong>；抛异常自动回滚，正常则 commit。</p>
</blockquote>
<hr/>
<h2 data-id="heading-4">5. Model / Schema / CRUD 一条龙</h2>
<p><strong>app/models/user.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> String
<span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> DeclarativeBase, Mapped, mapped_column

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>(<span class="hljs-title class_ inherited__">DeclarativeBase</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Base</span>):
    __tablename__ = <span class="hljs-string">"users"</span>

    <span class="hljs-built_in">id</span>: Mapped[<span class="hljs-built_in">int</span>] = mapped_column(primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>)
    email: Mapped[<span class="hljs-built_in">str</span>] = mapped_column(String(<span class="hljs-number">320</span>), unique=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>)
    full_name: Mapped[<span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span>]
</code></pre>
<p><strong>app/schemas/user.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, EmailStr

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCreate</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    email: EmailStr
    full_name: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRead</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span>
    email: EmailStr
    full_name: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span>

    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:
        orm_mode = <span class="hljs-literal">True</span>
</code></pre>
<p><strong>app/api/user.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Depends, HTTPException
<span class="hljs-keyword">from</span> sqlalchemy.ext.asyncio <span class="hljs-keyword">import</span> AsyncSession
<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> select
<span class="hljs-keyword">from</span> app.models <span class="hljs-keyword">import</span> User
<span class="hljs-keyword">from</span> app.schemas <span class="hljs-keyword">import</span> UserCreate, UserRead
<span class="hljs-keyword">from</span> app.core.deps <span class="hljs-keyword">import</span> get_session

router = APIRouter(prefix=<span class="hljs-string">"/users"</span>, tags=[<span class="hljs-string">"users"</span>])

<span class="hljs-meta">@router.post(<span class="hljs-params"><span class="hljs-string">""</span>, response_model=UserRead</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">payload: UserCreate, session: AsyncSession = Depends(<span class="hljs-params">get_session</span>)</span>):
    user = User(**payload.<span class="hljs-built_in">dict</span>())
    session.add(user)
    <span class="hljs-keyword">await</span> session.flush()          <span class="hljs-comment"># 获取 id</span>
    <span class="hljs-keyword">await</span> session.commit()
    <span class="hljs-keyword">await</span> session.refresh(user)
    <span class="hljs-keyword">return</span> user

<span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">"/{uid}"</span>, response_model=UserRead</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_user</span>(<span class="hljs-params">uid: <span class="hljs-built_in">int</span>, session: AsyncSession = Depends(<span class="hljs-params">get_session</span>)</span>):
    user = <span class="hljs-keyword">await</span> session.get(User, uid)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:
        <span class="hljs-keyword">raise</span> HTTPException(<span class="hljs-number">404</span>, <span class="hljs-string">"User not found"</span>)
    <span class="hljs-keyword">return</span> user
</code></pre>
<hr/>
<h2 data-id="heading-5">6. 迁移：Alembic 同样能异步</h2>
<p><strong>初始化</strong></p>
<pre><code class="hljs language-bash" lang="bash">alembic init -t async migrations
</code></pre>
<p><strong>修改 <code>alembic.ini</code> 中的 <code>sqlalchemy.url</code> 为 <code>postgresql+asyncpg://...</code></strong></p>
<p><strong>migrations/env.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> app.core.config <span class="hljs-keyword">import</span> settings
<span class="hljs-keyword">from</span> app.models <span class="hljs-keyword">import</span> Base
target_metadata = Base.metadata

<span class="hljs-keyword">def</span> <span class="hljs-title function_">do_run_migrations</span>(<span class="hljs-params">connection</span>):
    context.configure(connection=connection, target_metadata=target_metadata)
    <span class="hljs-keyword">with</span> context.begin_transaction():
        context.run_migrations()

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_async_migrations</span>():
    <span class="hljs-keyword">from</span> sqlalchemy.ext.asyncio <span class="hljs-keyword">import</span> AsyncEngine
    connectable = AsyncEngine(create_async_engine(settings.database_url))
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> connectable.connect() <span class="hljs-keyword">as</span> connection:
        <span class="hljs-keyword">await</span> connection.run_sync(do_run_migrations)
    <span class="hljs-keyword">await</span> connectable.dispose()
</code></pre>
<p><strong>生成 / 升级</strong></p>
<pre><code class="hljs language-bash" lang="bash">alembic revision --autogenerate -m <span class="hljs-string">"init"</span>
alembic upgrade <span class="hljs-built_in">head</span>
</code></pre>
<hr/>
<h2 data-id="heading-6">7. 测试：pytest-asyncio + 异步数据库事务</h2>
<p><strong>tests/conftest.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">from</span> httpx <span class="hljs-keyword">import</span> AsyncClient
<span class="hljs-keyword">from</span> app.main <span class="hljs-keyword">import</span> app
<span class="hljs-keyword">from</span> app.core.db <span class="hljs-keyword">import</span> db <span class="hljs-keyword">as</span> db_instance
<span class="hljs-keyword">from</span> sqlalchemy.pool <span class="hljs-keyword">import</span> StaticPool
<span class="hljs-keyword">from</span> sqlalchemy.ext.asyncio <span class="hljs-keyword">import</span> AsyncEngine, create_async_engine

<span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">"session"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">engine</span>() -&gt; AsyncEngine:
    <span class="hljs-comment"># 内存 SQLite 也可以异步，但 PostgreSQL 更真实</span>
    engine = create_async_engine(
        <span class="hljs-string">"postgresql+asyncpg://test:test@localhost:5432/test"</span>,
        poolclass=StaticPool,
    )
    <span class="hljs-keyword">yield</span> engine
    <span class="hljs-keyword">await</span> engine.dispose()

<span class="hljs-meta">@pytest.fixture</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">session</span>(<span class="hljs-params">engine: AsyncEngine</span>):
    conn = <span class="hljs-keyword">await</span> engine.begin()
    sess = db_instance.session_factory(bind=conn)
    <span class="hljs-keyword">yield</span> sess
    <span class="hljs-keyword">await</span> sess.close()
    <span class="hljs-keyword">await</span> conn.rollback()
    <span class="hljs-keyword">await</span> conn.close()

<span class="hljs-meta">@pytest.fixture</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">client</span>() -&gt; AsyncGenerator[AsyncClient, <span class="hljs-literal">None</span>]:
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> AsyncClient(app=app, base_url=<span class="hljs-string">"http://test"</span>) <span class="hljs-keyword">as</span> c:
        <span class="hljs-keyword">yield</span> c
</code></pre>
<p><strong>tests/test_user.py</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> select
<span class="hljs-keyword">from</span> app.models <span class="hljs-keyword">import</span> User

<span class="hljs-meta">@pytest.mark.asyncio</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_create_user</span>(<span class="hljs-params">client, session</span>):
    res = <span class="hljs-keyword">await</span> client.post(<span class="hljs-string">"/users"</span>, json={<span class="hljs-string">"email"</span>: <span class="hljs-string">"a@b.com"</span>, <span class="hljs-string">"full_name"</span>: <span class="hljs-string">"abc"</span>})
    <span class="hljs-keyword">assert</span> res.status_code == <span class="hljs-number">201</span>
    data = res.json()
    <span class="hljs-keyword">assert</span> data[<span class="hljs-string">"email"</span>] == <span class="hljs-string">"a@b.com"</span>

    user = <span class="hljs-keyword">await</span> session.get(User, data[<span class="hljs-string">"id"</span>])
    <span class="hljs-keyword">assert</span> user <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>
</code></pre>
<hr/>
<h2 data-id="heading-7">8. 性能调优 checklist</h2>



































<table><thead><tr><th>参数</th><th>建议值</th><th>说明</th></tr></thead><tbody><tr><td><code>pool_size</code></td><td>CPU 核心 × 2</td><td>20 并发已能压到 10k RPS</td></tr><tr><td><code>max_overflow</code></td><td>0</td><td>防止突发连接打爆 DB</td></tr><tr><td><code>pool_pre_ping=True</code></td><td>必须</td><td>网络闪断后自动重连</td></tr><tr><td><code>expire_on_commit=False</code></td><td>必须</td><td>否则 commit 后属性失效</td></tr><tr><td><code>echo=False</code></td><td>生产关闭</td><td>减少序列化开销</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-8">9. 常见错误速查表</h2>






























<table><thead><tr><th>异常</th><th>原因</th><th>解法</th></tr></thead><tbody><tr><td><code>greenlet_spawn has not been called</code></td><td>用了同步引擎</td><td><code>create_async_engine</code></td></tr><tr><td><code>DetachedInstanceError</code></td><td>会话关闭后访问属性</td><td><code>expire_on_commit=False</code> + <code>await session.refresh()</code></td></tr><tr><td><code>InterfaceError: connection already closed</code></td><td>协程间复用 Session</td><td>一个请求一个 Session，禁止全局单例</td></tr><tr><td><code>ImportError: asyncmy</code></td><td>MySQL 驱动未装</td><td><code>pip install asyncmy</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-9">10. 结语</h2>
<p>FastAPI 的异步生态里，<strong>数据库是最后一道闸门</strong>。<br/>
用上 SQLAlchemy 2.0 AsyncIO 之后，<strong>I/O 等待不再是瓶颈</strong>，压测曲线直接多一个量级。<br/>
把本文的 <code>db.py</code> + <code>deps.py</code> 复制走，<strong>10 分钟就能让老项目原地起飞</strong>。Happy async coding!</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【穿越Effective C++】条款16：成对使用new和delete时要采用相同形式——内存管理的精确匹配原则]]></title>    <link>https://juejin.cn/post/7570909641682780200</link>    <guid>https://juejin.cn/post/7570909641682780200</guid>    <pubDate>2025-11-10T13:14:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570909641682780200" data-draft-id="7570940025580568616" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【穿越Effective C++】条款16：成对使用new和delete时要采用相同形式——内存管理的精确匹配原则"/> <meta itemprop="keywords" content="C++,面试"/> <meta itemprop="datePublished" content="2025-11-10T13:14:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="沐怡旸"/> <meta itemprop="url" content="https://juejin.cn/user/2875978146656750"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【穿越Effective C++】条款16：成对使用new和delete时要采用相同形式——内存管理的精确匹配原则
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2875978146656750/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    沐怡旸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T13:14:55.000Z" title="Mon Nov 10 2025 13:14:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这个条款揭示了C++动态内存管理中最基本但常被忽视的规则：new/delete形式必须严格匹配。理解这一原则是避免内存泄漏和未定义行为的关键。</p>
<hr/>
<h3 data-id="heading-0"><strong>思维导图：new/delete配对使用的完整体系</strong></h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/294e89093b45496b8b2215e315e05f97~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rKQ5oCh5pe4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763385295&amp;x-signature=p68QUDVmtXnFF9vTKtJN7M3os1U%3D" alt="16成对使用new和delete的相同形式.png" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-1"><strong>关键洞见与行动指南</strong></h3>
<h4 data-id="heading-2"><strong>必须遵守的核心原则：</strong></h4>
<ol>
<li><strong>严格形式匹配</strong>：<code>new</code>配<code>delete</code>，<code>new[]</code>配<code>delete[]</code></li>
<li><strong>避免多态数组</strong>：不要通过基类指针删除派生类数组</li>
<li><strong>使用标准库</strong>：优先使用容器和智能指针替代手动内存管理</li>
<li><strong>明确类型信息</strong>：使用清晰的类型别名，避免混淆</li>
</ol>
<h4 data-id="heading-3"><strong>现代C++开发建议：</strong></h4>
<ol>
<li><strong>禁止裸new/delete</strong>：在代码规范中明确禁止手动内存管理</li>
<li><strong>使用make_unique/make_shared</strong>：工厂函数自动选择正确的分配形式</li>
<li><strong>容器优先原则</strong>：使用<code>std::vector</code>、<code>std::array</code>替代动态数组</li>
<li><strong>静态分析集成</strong>：在CI/CD流水线中集成内存检测工具</li>
</ol>
<h4 data-id="heading-4"><strong>设计原则总结：</strong></h4>
<ol>
<li><strong>RAII原则</strong>：资源获取即初始化，利用析构函数自动释放</li>
<li><strong>零规则</strong>：让编译器生成正确的拷贝控制成员</li>
<li><strong>明确所有权</strong>：使用智能指针明确表达资源所有权语义</li>
<li><strong>防御性编程</strong>：假设所有手动内存管理都可能出错</li>
</ol>
<h4 data-id="heading-5"><strong>需要警惕的陷阱：</strong></h4>
<ol>
<li><strong>typedef隐藏的数组</strong>：类型别名可能隐藏数组本质</li>
<li><strong>多态数组删除</strong>：通过基类指针删除派生类数组</li>
<li><strong>跨模块边界</strong>：在不同DLL中分配和释放内存</li>
<li><strong>异常安全</strong>：在异常发生时确保资源正确释放</li>
</ol>
<p><strong>最终建议：</strong> 将new/delete配对规则视为C++内存管理的"物理定律"。培养"自动管理思维"——在需要动态内存时首先问自己："能否用标准库容器或智能指针替代手动管理？" 这种预防性的思考方式是构建健壮C++系统的关键。</p>
<p>记住：<strong>在C++内存管理中，正确的配对不是最佳实践，而是避免灾难的基本要求。</strong> 条款16教会我们的不仅是一个语法规则，更是对C++内存模型深刻理解的体现。</p>
<hr/>
<h3 data-id="heading-6"><strong>深入解析：内存布局的核心差异</strong></h3>
<h4 data-id="heading-7"><strong>1. 问题根源：内存分配的内部机制</strong></h4>
<p><strong>单个对象 vs 对象数组的内存布局：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Widget</span>() { std::cout &lt;&lt; <span class="hljs-string">"Widget构造 "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl; }
    ~<span class="hljs-built_in">Widget</span>() { std::cout &lt;&lt; <span class="hljs-string">"Widget析构 "</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> data[<span class="hljs-number">10</span>];
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_memory_layout</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 单个对象的内存分配</span>
    Widget* singleObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>();
    <span class="hljs-comment">// 内存布局: [Widget对象数据]</span>
    
    <span class="hljs-comment">// 对象数组的内存分配  </span>
    Widget* arrayObj = <span class="hljs-keyword">new</span> Widget[<span class="hljs-number">3</span>];
    <span class="hljs-comment">// 内存布局: [数组大小][Widget][Widget][Widget]</span>
    <span class="hljs-comment">// 大多数编译器会在数组前面存储元素数量</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"单个对象地址: "</span> &lt;&lt; singleObj &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"数组对象地址: "</span> &lt;&lt; arrayObj &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 正确的释放</span>
    <span class="hljs-keyword">delete</span> singleObj;      <span class="hljs-comment">// 释放单个对象</span>
    <span class="hljs-keyword">delete</span>[] arrayObj;     <span class="hljs-comment">// 释放对象数组</span>
}
</code></pre>
<p><strong>危险的错误配对示例：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_dangerous_mismatch</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 场景1：new[] 配 delete</span>
    std::cout &lt;&lt; <span class="hljs-string">"=== 错误1: new[] 配 delete ==="</span> &lt;&lt; std::endl;
    Widget* widgets = <span class="hljs-keyword">new</span> Widget[<span class="hljs-number">3</span>];
    
    <span class="hljs-comment">// delete widgets;  // 灾难！</span>
    <span class="hljs-comment">// 实际发生：</span>
    <span class="hljs-comment">// 1. 只调用第一个元素的析构函数</span>
    <span class="hljs-comment">// 2. 试图释放错误的内存地址（数组开始位置 - 数组大小存储偏移）</span>
    <span class="hljs-comment">// 3. 堆数据结构破坏</span>
    
    <span class="hljs-comment">// 场景2：new 配 delete[]</span>
    std::cout &lt;&lt; <span class="hljs-string">"\n=== 错误2: new 配 delete[] ==="</span> &lt;&lt; std::endl;
    Widget* single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>();
    
    <span class="hljs-comment">// delete[] single;  // 同样灾难！</span>
    <span class="hljs-comment">// 实际发生：</span>
    <span class="hljs-comment">// 1. 试图读取数组大小（在对象前面）</span>
    <span class="hljs-comment">// 2. 调用多个不存在的对象的析构函数</span>
    <span class="hljs-comment">// 3. 释放错误大小的内存块</span>
    
    <span class="hljs-comment">// 正确释放</span>
    <span class="hljs-keyword">delete</span>[] widgets;
    <span class="hljs-keyword">delete</span> single;
}
</code></pre>
<h4 data-id="heading-8"><strong>2. 编译器实现的差异</strong></h4>
<p><strong>不同编译器的数组大小存储：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_compiler_differences</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span> {
    <span class="hljs-keyword">public</span>:
        ~<span class="hljs-built_in">Simple</span>() {}  <span class="hljs-comment">// 有析构函数，编译器必须记录数组大小</span>
    };
    
    Simple* array1 = <span class="hljs-keyword">new</span> Simple[<span class="hljs-number">5</span>];
    
    <span class="hljs-comment">// 在大多数编译器中，内存布局类似：</span>
    <span class="hljs-comment">// [size_t n=5][Simple][Simple][Simple][Simple][Simple]</span>
    <span class="hljs-comment">// 数组开始的实际地址是 &amp;array1 - sizeof(size_t)</span>
    
    <span class="hljs-keyword">delete</span>[] array1;  <span class="hljs-comment">// 编译器知道要调用5次析构函数</span>
    
    <span class="hljs-comment">// 对于没有析构函数的类型，编译器可能优化</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDestructor</span> {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-comment">// 没有用户定义的析构函数</span>
    };
    
    NoDestructor* array2 = <span class="hljs-keyword">new</span> NoDestructor[<span class="hljs-number">5</span>];
    <span class="hljs-comment">// 编译器可能不存储数组大小，因为不需要调用析构函数</span>
    
    <span class="hljs-keyword">delete</span>[] array2;  <span class="hljs-comment">// 可能只是释放内存，不调用析构函数</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-9"><strong>解决方案：严格的配对规则</strong></h3>
<h4 data-id="heading-10"><strong>1. 基本配对规则</strong></h4>
<p><strong>正确的new/delete配对：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Investment</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Investment</span>() { std::cout &lt;&lt; <span class="hljs-string">"Investment构造"</span> &lt;&lt; std::endl; }
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Investment</span>() { std::cout &lt;&lt; <span class="hljs-string">"Investment析构"</span> &lt;&lt; std::endl; }
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> : <span class="hljs-keyword">public</span> Investment {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ 
        std::cout &lt;&lt; <span class="hljs-string">"计算股票收益"</span> &lt;&lt; std::endl; 
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_correct_pairing</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"=== 单个对象 ==="</span> &lt;&lt; std::endl;
    Investment* single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Stock</span>();
    single-&gt;<span class="hljs-built_in">calculate</span>();
    <span class="hljs-keyword">delete</span> single;  <span class="hljs-comment">// 正确：new 配 delete</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"\n=== 对象数组 ==="</span> &lt;&lt; std::endl;
    Investment* array = <span class="hljs-keyword">new</span> Stock[<span class="hljs-number">3</span>];
    <span class="hljs-comment">// 注意：这里有多态数组的问题，后面会讨论</span>
    <span class="hljs-keyword">delete</span>[] array;  <span class="hljs-comment">// 正确：new[] 配 delete[]</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"\n=== 内置类型数组 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-type">int</span>* intArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];
    <span class="hljs-keyword">delete</span>[] intArray;  <span class="hljs-comment">// 正确：即使没有析构函数也要匹配</span>
    
    <span class="hljs-type">double</span>* singleDouble = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>;
    <span class="hljs-keyword">delete</span> singleDouble;  <span class="hljs-comment">// 正确：new 配 delete</span>
}
</code></pre>
<h4 data-id="heading-11"><strong>2. typedef带来的陷阱</strong></h4>
<p><strong>typedef隐藏的数组本质：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 危险的typedef定义</span>
<span class="hljs-keyword">typedef</span> Investment* InvestmentPtr;
<span class="hljs-keyword">typedef</span> Investment* InvestmentArray[<span class="hljs-number">10</span>];  <span class="hljs-comment">// 大小为10的Investment指针数组</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_typedef_danger</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 情况1：看起来像单个对象，实际上是数组</span>
    InvestmentArray investments;  <span class="hljs-comment">// Investment* investments[10]</span>
    
    <span class="hljs-comment">// 错误的分配方式</span>
    InvestmentPtr* badAlloc = <span class="hljs-keyword">new</span> InvestmentArray;  <span class="hljs-comment">// 实际上是 new Investment*[10]</span>
    <span class="hljs-comment">// 看起来像单个对象，但实际上是数组！</span>
    
    <span class="hljs-comment">// delete badAlloc;  // 错误：应该用 delete[]</span>
    <span class="hljs-keyword">delete</span>[] badAlloc;   <span class="hljs-comment">// 正确</span>
    
    <span class="hljs-comment">// 情况2：更清晰的现代替代</span>
    <span class="hljs-keyword">using</span> InvestmentPtr = Investment*;
    <span class="hljs-keyword">using</span> InvestmentArray = std::array&lt;Investment*, <span class="hljs-number">10</span>&gt;;
    
    InvestmentArray safeInvestments;  <span class="hljs-comment">// 明确的容器类型</span>
    <span class="hljs-comment">// 不需要手动内存管理！</span>
}
</code></pre>
<p><strong>现代C++的解决方案：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 使用using替代typedef，更清晰</span>
<span class="hljs-keyword">using</span> SingleInvestment = Investment;
<span class="hljs-keyword">using</span> InvestmentArray = Investment[<span class="hljs-number">10</span>];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_modern_solution</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// C++11 using语法更清晰</span>
    <span class="hljs-keyword">auto</span> single = <span class="hljs-keyword">new</span> SingleInvestment;  <span class="hljs-comment">// 明确是单个对象</span>
    <span class="hljs-keyword">delete</span> single;
    
    <span class="hljs-comment">// 但更好的方案是使用标准库容器</span>
    std::vector&lt;std::unique_ptr&lt;Investment&gt;&gt; investments;
    investments.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Stock&gt;());
    <span class="hljs-comment">// 自动管理内存，无需担心new/delete配对</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-12"><strong>现代C++的改进方案</strong></h3>
<h4 data-id="heading-13"><strong>1. 智能指针自动管理</strong></h4>
<p><strong>unique_ptr的数组特化：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_smart_pointers</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"=== unique_ptr 单对象 ==="</span> &lt;&lt; std::endl;
    {
        std::unique_ptr&lt;Investment&gt; investment = std::<span class="hljs-built_in">make_unique</span>&lt;Stock&gt;();
        investment-&gt;<span class="hljs-built_in">calculate</span>();
        <span class="hljs-comment">// 自动调用delete，无需手动管理</span>
    }
    
    std::cout &lt;&lt; <span class="hljs-string">"\n=== unique_ptr 对象数组 ==="</span> &lt;&lt; std::endl;
    {
        <span class="hljs-comment">// unique_ptr的数组特化版本</span>
        <span class="hljs-function">std::unique_ptr&lt;Investment[]&gt; <span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Stock[<span class="hljs-number">3</span>])</span></span>;
        <span class="hljs-comment">// 会自动调用delete[]</span>
        
        <span class="hljs-comment">// C++20支持make_unique对于数组（有限制）</span>
        <span class="hljs-comment">// auto array = std::make_unique&lt;Investment[]&gt;(3);</span>
    }
    
    std::cout &lt;&lt; <span class="hljs-string">"\n=== shared_ptr 需要自定义删除器 ==="</span> &lt;&lt; std::endl;
    {
        <span class="hljs-comment">// shared_ptr默认使用delete，不是delete[]</span>
        std::shared_ptr&lt;Investment&gt; single = std::<span class="hljs-built_in">make_shared</span>&lt;Stock&gt;();
        
        <span class="hljs-comment">// 对于数组，需要提供自定义删除器</span>
        <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">array</span><span class="hljs-params">(
            <span class="hljs-keyword">new</span> Stock[<span class="hljs-number">3</span>],
            [](Investment* p) { <span class="hljs-keyword">delete</span>[] p; }
        )</span></span>;
    }
}
</code></pre>
<h4 data-id="heading-14"><strong>2. 标准库容器优先</strong></h4>
<p><strong>完全避免手动内存管理：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_standard_containers</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"=== std::vector 替代动态数组 ==="</span> &lt;&lt; std::endl;
    {
        <span class="hljs-function">std::vector&lt;Stock&gt; <span class="hljs-title">stocks</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;  <span class="hljs-comment">// 创建3个Stock对象</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; stock : stocks) {
            stock.<span class="hljs-built_in">calculate</span>();
        }
        <span class="hljs-comment">// 自动管理内存，正确调用所有析构函数</span>
    }
    
    std::cout &lt;&lt; <span class="hljs-string">"\n=== std::array 替代固定大小数组 ==="</span> &lt;&lt; std::endl;
    {
        std::array&lt;Stock, 5&gt; fixedStocks;  <span class="hljs-comment">// 固定大小数组</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; stock : fixedStocks) {
            stock.<span class="hljs-built_in">calculate</span>();
        }
        <span class="hljs-comment">// 栈上分配，自动析构</span>
    }
    
    std::cout &lt;&lt; <span class="hljs-string">"\n=== 多态对象使用智能指针容器 ==="</span> &lt;&lt; std::endl;
    {
        std::vector&lt;std::unique_ptr&lt;Investment&gt;&gt; portfolio;
        portfolio.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Stock&gt;());
        <span class="hljs-comment">// portfolio.push_back(std::make_unique&lt;Bond&gt;());</span>
        
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; investment : portfolio) {
            investment-&gt;<span class="hljs-built_in">calculate</span>();
        }
        <span class="hljs-comment">// 自动正确释放所有对象</span>
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-15"><strong>特殊场景与陷阱规避</strong></h3>
<h4 data-id="heading-16"><strong>1. 多态对象数组的问题</strong></h4>
<p><strong>多态数组的危险性：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bond</span> : <span class="hljs-keyword">public</span> Investment {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"计算债券收益"</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_polymorphic_array_danger</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 危险：多态数组</span>
    Investment* investments = <span class="hljs-keyword">new</span> Stock[<span class="hljs-number">3</span>];
    
    <span class="hljs-comment">// delete[] investments;  // 未定义行为！</span>
    <span class="hljs-comment">// 问题：</span>
    <span class="hljs-comment">// 1. 通过基类指针删除派生类数组</span>
    <span class="hljs-comment">// 2. 派生类对象大小可能与基类不同</span>
    <span class="hljs-comment">// 3. 析构函数调用不正确</span>
    
    <span class="hljs-comment">// 正确做法：使用指针数组</span>
    Investment** safeInvestments = <span class="hljs-keyword">new</span> Investment*[<span class="hljs-number">3</span>];
    safeInvestments[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Stock</span>();
    safeInvestments[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bond</span>();
    safeInvestments[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Stock</span>();
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {
        <span class="hljs-keyword">delete</span> safeInvestments[i];  <span class="hljs-comment">// 正确调用虚析构函数</span>
    }
    <span class="hljs-keyword">delete</span>[] safeInvestments;  <span class="hljs-comment">// 释放指针数组</span>
    
    <span class="hljs-comment">// 更好的做法：使用智能指针容器</span>
    std::vector&lt;std::unique_ptr&lt;Investment&gt;&gt; bestInvestments;
    bestInvestments.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Stock&gt;());
    bestInvestments.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Bond&gt;());
}
</code></pre>
<h4 data-id="heading-17"><strong>2. 字符串内存管理</strong></h4>
<p><strong>C风格字符串的正确管理：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_string_management</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"=== C风格字符串数组 ==="</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 字符数组</span>
    <span class="hljs-type">char</span>* str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];
    std::<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">"Hello World"</span>);
    std::cout &lt;&lt; <span class="hljs-string">"C字符串: "</span> &lt;&lt; str &lt;&lt; std::endl;
    <span class="hljs-keyword">delete</span>[] str;  <span class="hljs-comment">// 必须使用delete[]</span>
    
    <span class="hljs-comment">// 字符串指针数组</span>
    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span>* strings = <span class="hljs-keyword">new</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>*[<span class="hljs-number">3</span>] {
        <span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>, <span class="hljs-string">"!"</span>
    };
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {
        std::cout &lt;&lt; strings[i] &lt;&lt; <span class="hljs-string">" "</span>;
    }
    std::cout &lt;&lt; std::endl;
    
    <span class="hljs-keyword">delete</span>[] strings;  <span class="hljs-comment">// 释放指针数组</span>
    
    <span class="hljs-comment">// 现代C++：使用std::string和std::vector</span>
    std::vector&lt;std::string&gt; modernStrings = {<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>, <span class="hljs-string">"!"</span>};
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; s : modernStrings) {
        std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">" "</span>;
    }
    std::cout &lt;&lt; std::endl;
}
</code></pre>
<hr/>
<h3 data-id="heading-18"><strong>实战案例：复杂系统的内存管理</strong></h3>
<h4 data-id="heading-19"><strong>案例1：图形系统资源管理</strong></h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Texture</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> textureId;
    <span class="hljs-type">int</span> width, height;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Texture</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h) : <span class="hljs-built_in">width</span>(w), <span class="hljs-built_in">height</span>(h) {
        <span class="hljs-comment">// 模拟OpenGL纹理创建</span>
        textureId = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(w * h); <span class="hljs-comment">// 模拟ID生成</span>
        std::cout &lt;&lt; <span class="hljs-string">"创建纹理 "</span> &lt;&lt; textureId &lt;&lt; <span class="hljs-string">" ("</span> &lt;&lt; w &lt;&lt; <span class="hljs-string">"x"</span> &lt;&lt; h &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; std::endl;
    }
    
    ~<span class="hljs-built_in">Texture</span>() {
        std::cout &lt;&lt; <span class="hljs-string">"销毁纹理 "</span> &lt;&lt; textureId &lt;&lt; std::endl;
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bind</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"绑定纹理 "</span> &lt;&lt; textureId &lt;&lt; std::endl;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TextureManager</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 使用智能指针管理单个纹理</span>
    std::vector&lt;std::unique_ptr&lt;Texture&gt;&gt; textures;
    
    <span class="hljs-comment">// 纹理数组的专门管理</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextureArray</span> {
    <span class="hljs-keyword">private</span>:
        std::unique_ptr&lt;Texture[]&gt; array;
        <span class="hljs-type">size_t</span> count;
        
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">TextureArray</span>(<span class="hljs-type">size_t</span> n) : <span class="hljs-built_in">array</span>(<span class="hljs-keyword">new</span> Texture[n]), <span class="hljs-built_in">count</span>(n) {
            std::cout &lt;&lt; <span class="hljs-string">"创建纹理数组，大小: "</span> &lt;&lt; n &lt;&lt; std::endl;
        }
        
        <span class="hljs-comment">// 自动调用delete[]</span>
        ~<span class="hljs-built_in">TextureArray</span>() = <span class="hljs-keyword">default</span>;
        
        Texture&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) {
            <span class="hljs-keyword">return</span> array[index];
        }
        
        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> count; }
    };
    
    std::vector&lt;std::unique_ptr&lt;TextureArray&gt;&gt; textureArrays;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 添加单个纹理</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTexture</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>{
        textures.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Texture&gt;(width, height));
    }
    
    <span class="hljs-comment">// 添加纹理数组</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTextureArray</span><span class="hljs-params">(<span class="hljs-type">size_t</span> count, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>{
        <span class="hljs-keyword">auto</span> array = std::<span class="hljs-built_in">make_unique</span>&lt;TextureArray&gt;(count);
        textureArrays.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(array));
    }
    
    <span class="hljs-comment">// 使用所有纹理</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useAllTextures</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"=== 使用单个纹理 ==="</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; texture : textures) {
            texture-&gt;<span class="hljs-built_in">bind</span>();
        }
        
        std::cout &lt;&lt; <span class="hljs-string">"=== 使用纹理数组 ==="</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; array : textureArrays) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; array-&gt;<span class="hljs-built_in">size</span>(); ++i) {
                (*array)[i].<span class="hljs-built_in">bind</span>();
            }
        }
    }
    
    <span class="hljs-comment">// 自动正确释放所有资源</span>
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_graphics_resource_management</span><span class="hljs-params">()</span> </span>{
    TextureManager manager;
    
    <span class="hljs-comment">// 添加单个纹理</span>
    manager.<span class="hljs-built_in">addTexture</span>(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>);
    manager.<span class="hljs-built_in">addTexture</span>(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>);
    
    <span class="hljs-comment">// 添加纹理数组</span>
    manager.<span class="hljs-built_in">addTextureArray</span>(<span class="hljs-number">3</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>);
    manager.<span class="hljs-built_in">addTextureArray</span>(<span class="hljs-number">5</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>);
    
    manager.<span class="hljs-built_in">useAllTextures</span>();
    
    std::cout &lt;&lt; <span class="hljs-string">"TextureManager离开作用域，自动释放所有资源..."</span> &lt;&lt; std::endl;
}
</code></pre>
<h4 data-id="heading-20"><strong>案例2：数据库连接池</strong></h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseConnection</span> {
<span class="hljs-keyword">private</span>:
    std::string connectionString;
    <span class="hljs-type">bool</span> connected;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DatabaseConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; connStr)</span> 
        : connectionString(connStr), connected(false) {</span>
        <span class="hljs-built_in">connect</span>();
    }
    
    ~<span class="hljs-built_in">DatabaseConnection</span>() {
        <span class="hljs-built_in">disconnect</span>();
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!connected) {
            connected = <span class="hljs-literal">true</span>;
            std::cout &lt;&lt; <span class="hljs-string">"连接数据库: "</span> &lt;&lt; connectionString &lt;&lt; std::endl;
        }
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (connected) {
            connected = <span class="hljs-literal">false</span>;
            std::cout &lt;&lt; <span class="hljs-string">"断开数据库连接: "</span> &lt;&lt; connectionString &lt;&lt; std::endl;
        }
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; query)</span> </span>{
        <span class="hljs-keyword">if</span> (connected) {
            std::cout &lt;&lt; <span class="hljs-string">"执行查询: "</span> &lt;&lt; query &lt;&lt; <span class="hljs-string">" on "</span> &lt;&lt; connectionString &lt;&lt; std::endl;
        }
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// 固定大小连接池 - 使用std::array</span>
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> POOL_SIZE = <span class="hljs-number">5</span>;
    std::array&lt;std::unique_ptr&lt;DatabaseConnection&gt;, POOL_SIZE&gt; connections;
    
    <span class="hljs-comment">// 动态扩展连接 - 使用std::vector</span>
    std::vector&lt;std::unique_ptr&lt;DatabaseConnection&gt;&gt; extraConnections;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ConnectionPool</span>() {
        <span class="hljs-comment">// 初始化固定连接池</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; POOL_SIZE; ++i) {
            connections[i] = std::<span class="hljs-built_in">make_unique</span>&lt;DatabaseConnection&gt;(
                <span class="hljs-string">"Server=DB"</span> + std::<span class="hljs-built_in">to_string</span>(i) + <span class="hljs-string">";Database=App"</span>
            );
        }
        std::cout &lt;&lt; <span class="hljs-string">"初始化连接池，大小: "</span> &lt;&lt; POOL_SIZE &lt;&lt; std::endl;
    }
    
    <span class="hljs-comment">// 获取固定连接池中的连接</span>
    <span class="hljs-function">DatabaseConnection* <span class="hljs-title">getConnection</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> </span>{
        <span class="hljs-keyword">if</span> (index &lt; POOL_SIZE) {
            <span class="hljs-keyword">return</span> connections[index].<span class="hljs-built_in">get</span>();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    }
    
    <span class="hljs-comment">// 创建新的动态连接</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createExtraConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; connStr)</span> </span>{
        extraConnections.<span class="hljs-built_in">push_back</span>(
            std::<span class="hljs-built_in">make_unique</span>&lt;DatabaseConnection&gt;(connStr)
        );
    }
    
    <span class="hljs-comment">// 使用所有连接</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useAllConnections</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"=== 使用固定连接池 ==="</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; POOL_SIZE; ++i) {
            connections[i]-&gt;<span class="hljs-built_in">execute</span>(<span class="hljs-string">"SELECT * FROM users"</span>);
        }
        
        std::cout &lt;&lt; <span class="hljs-string">"=== 使用动态连接 ==="</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; conn : extraConnections) {
            conn-&gt;<span class="hljs-built_in">execute</span>(<span class="hljs-string">"UPDATE stats SET value = 1"</span>);
        }
    }
    
    <span class="hljs-comment">// 自动正确释放所有连接</span>
    ~<span class="hljs-built_in">ConnectionPool</span>() {
        std::cout &lt;&lt; <span class="hljs-string">"连接池销毁，自动释放所有连接..."</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_connection_pool_management</span><span class="hljs-params">()</span> </span>{
    ConnectionPool pool;
    
    <span class="hljs-comment">// 使用固定连接</span>
    <span class="hljs-keyword">auto</span>* conn1 = pool.<span class="hljs-built_in">getConnection</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">auto</span>* conn2 = pool.<span class="hljs-built_in">getConnection</span>(<span class="hljs-number">1</span>);
    
    <span class="hljs-keyword">if</span> (conn1 &amp;&amp; conn2) {
        conn1-&gt;<span class="hljs-built_in">execute</span>(<span class="hljs-string">"BEGIN TRANSACTION"</span>);
        conn2-&gt;<span class="hljs-built_in">execute</span>(<span class="hljs-string">"COMMIT"</span>);
    }
    
    <span class="hljs-comment">// 添加动态连接</span>
    pool.<span class="hljs-built_in">createExtraConnection</span>(<span class="hljs-string">"Server=EXTRA;Database=Backup"</span>);
    pool.<span class="hljs-built_in">createExtraConnection</span>(<span class="hljs-string">"Server=ANALYTICS;Database=Reports"</span>);
    
    pool.<span class="hljs-built_in">useAllConnections</span>();
    
    std::cout &lt;&lt; <span class="hljs-string">"ConnectionPool离开作用域..."</span> &lt;&lt; std::endl;
}
</code></pre>
<hr/>
<h3 data-id="heading-21"><strong>调试与检测技术</strong></h3>
<h4 data-id="heading-22"><strong>1. 内存检测工具使用</strong></h4>
<p><strong>Valgrind检测示例：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_memory_debugging</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 这些错误会在Valgrind/Memcheck中被检测到</span>
    
    <span class="hljs-comment">// 错误1：new[] 配 delete</span>
    <span class="hljs-type">int</span>* array1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];
    <span class="hljs-comment">// delete array1;  // Valgrind会报告：mismatched free() / delete / delete[]</span>
    
    <span class="hljs-comment">// 错误2：内存泄漏</span>
    <span class="hljs-type">int</span>* leaked = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];
    <span class="hljs-comment">// 忘记delete[] leaked</span>
    
    <span class="hljs-comment">// 错误3：重复释放</span>
    <span class="hljs-type">int</span>* doubleFree = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;
    <span class="hljs-keyword">delete</span> doubleFree;
    <span class="hljs-comment">// delete doubleFree;  // Valgrind会报告：invalid free()</span>
    
    <span class="hljs-comment">// 正确释放</span>
    <span class="hljs-keyword">delete</span>[] array1;
    <span class="hljs-comment">// delete[] leaked;  // 修复泄漏</span>
    <span class="hljs-comment">// 第二个delete注释掉</span>
}
</code></pre>
<h4 data-id="heading-23"><strong>2. 编译器诊断选项</strong></h4>
<p><strong>利用编译器警告：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 编译时使用这些选项检测问题：</span>
<span class="hljs-comment">// g++ -Wall -Wextra -Werror main.cpp</span>
<span class="hljs-comment">// clang++ -Weverything -Werror main.cpp</span>
<span class="hljs-comment">// MSVC /W4 /WX</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_compiler_warnings</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 某些编译器可以检测到明显的类型不匹配</span>
    <span class="hljs-type">int</span>* single = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;
    
    <span class="hljs-comment">// delete[] single;  // 某些编译器会警告：不匹配的删除形式</span>
    
    <span class="hljs-keyword">delete</span> single;  <span class="hljs-comment">// 正确</span>
}
</code></pre>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android输入法框架的Binder通信机制剖析]]></title>    <link>https://juejin.cn/post/7570897638440894491</link>    <guid>https://juejin.cn/post/7570897638440894491</guid>    <pubDate>2025-11-10T13:22:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570897638440894491" data-draft-id="7570897638440878107" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android输入法框架的Binder通信机制剖析"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2025-11-10T13:22:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="WAsbry"/> <meta itemprop="url" content="https://juejin.cn/user/3413335797139511"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android输入法框架的Binder通信机制剖析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3413335797139511/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    WAsbry
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T13:22:56.000Z" title="Mon Nov 10 2025 13:22:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Android输入法框架的Binder通信机制剖析</h2>
<h3 data-id="heading-1">问题背景</h3>
<ul>
<li>
<p>终端设备：用户操作：</p>
<ol>
<li>输入数字 "123456"</li>
<li>切换到字母键盘（百度/搜狗输入法）</li>
<li>连续点击字母 'q'</li>
</ol>
</li>
<li>
<p>异常结果：
点击第1次 'q': "123456" (不变)
点击第2次 'q': "12345"  (删除1位)
点击第3次 'q': "123"    (删除2位)
点击第4次 'q': ""       (全部删除)</p>
</li>
</ul>
<blockquote>
<p>很奇妙，小米手机是没有这些问题的，无论是自带的输入法还是安装的百度输入法均没有此问题</p>
</blockquote>
<p><strong>以Android 10 源码进行分析</strong></p>
<h3 data-id="heading-2">💡 本文精华</h3>
<ul>
<li><strong>现象</strong>：EditText设置<code>inputType="number"</code>后，切换字母键盘输入字母导致数字内容被删除</li>
<li><strong>本质</strong>：输入法与应用是两个独立进程，通过Binder IPC通信，存在天然的信息不对称</li>
<li><strong>核心机制</strong>：AIDL接口定义 → Stub/Proxy自动生成 → Binder驱动跨进程传输 → Handler线程切换</li>
<li><strong>关键洞察</strong>：异步通信导致输入法无法获知文本操作的实际执行结果，引发后续一系列问题</li>
<li><strong>价值</strong>：理解Android输入法架构，为后续两篇文章（设计缺陷、工程实践）奠定基础</li>
</ul>
<hr/>
<h3 data-id="heading-3">一、问题现象：一个"不应该存在"的Bug</h3>
<h4 data-id="heading-4">1.1 复现步骤</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- activity_main.xml --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">EditText</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/edit_number"</span>
    <span class="hljs-attr">android:inputType</span>=<span class="hljs-string">"number"</span>
    <span class="hljs-attr">android:hint</span>=<span class="hljs-string">"请输入数字"</span> /&gt;</span>
</code></pre>
<pre><code class="hljs language-arduino" lang="arduino">用户操作：
<span class="hljs-number">1.</span> 输入数字 <span class="hljs-string">"123456"</span>
<span class="hljs-number">2.</span> 切换到字母键盘（百度/搜狗输入法）
<span class="hljs-number">3.</span> 连续点击字母 <span class="hljs-string">'q'</span>

异常结果：
点击第<span class="hljs-number">1</span>次 <span class="hljs-string">'q'</span>: <span class="hljs-string">"123456"</span> (不变)
点击第<span class="hljs-number">2</span>次 <span class="hljs-string">'q'</span>: <span class="hljs-string">"12345"</span>  (删除<span class="hljs-number">1</span>位)
点击第<span class="hljs-number">3</span>次 <span class="hljs-string">'q'</span>: <span class="hljs-string">"123"</span>    (删除<span class="hljs-number">2</span>位)
点击第<span class="hljs-number">4</span>次 <span class="hljs-string">'q'</span>: <span class="hljs-string">""</span>       (全部删除)
</code></pre>
<h4 data-id="heading-5">1.2 第一直觉的困惑</h4>
<ul>
<li><strong>InputFilter已生效</strong>：DigitsKeyListener拒绝了字母插入</li>
<li><strong>日志显示正常</strong>：insert("q")确实被拒绝</li>
<li><strong>但数字却丢失了</strong>：为什么合法内容被删除？</li>
</ul>
<p>这不是应用层Bug，而是<strong>跨进程通信机制导致的系统级问题</strong>。</p>
<hr/>
<h3 data-id="heading-6">二、输入法框架的三进程架构</h3>
<h4 data-id="heading-7">2.1 为什么输入法要独立进程？</h4>
<pre><code class="hljs language-scss" lang="scss">假设没有进程隔离：
┌─────────────────────────────────────┐
│  应用进程                            │
│  ├─ EditText (密码: "MyPassword")   │
│  └─ 输入法代码 (直接运行在应用内)     │
│       ↓                             │
│    恶意输入法可以：                  │
│    - 读取 EditText<span class="hljs-selector-class">.getText</span>()        │
│    - 访问 Activity<span class="hljs-selector-class">.findViewById</span>()   │
│    - 窃取应用内存数据                │
└─────────────────────────────────────┘
</code></pre>
<p><strong>安全风险</strong>：输入法是第三方应用，不能信任。</p>
<h4 data-id="heading-8">2.2 实际的三层架构</h4>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────────────┐
│               应用进程 (com.example.app)                 │
│  ┌────────────────────────────────────────────────────┐ │
│  │ EditText                                           │ │
│  │   └─ InputConnection (BaseInputConnection)        │ │
│  │        - Binder Stub (IInputConnectionWrapper)    │ │
│  └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
                        ↕ Binder IPC
┌─────────────────────────────────────────────────────────┐
│          系统服务进程 (system_server)                     │
│  ┌────────────────────────────────────────────────────┐ │
│  │ InputMethodManagerService (IMMS)                   │ │
│  │   - 管理输入法生命周期                               │ │
│  │   - 转发Binder调用                                  │ │
│  └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
                        ↕ Binder IPC
┌─────────────────────────────────────────────────────────┐
│            输入法进程 (com.baidu.input)                   │
│  ┌────────────────────────────────────────────────────┐ │
│  │ InputMethodService                                 │ │
│  │   └─ InputConnection (Binder Proxy)               │ │
│  └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>核心要点</strong>：</p>
<ol>
<li><strong>进程隔离</strong>：输入法无法直接访问应用内存</li>
<li><strong>唯一通道</strong>：InputConnection是两者通信的唯一桥梁</li>
<li><strong>权限受限</strong>：InputConnection接口只暴露文本编辑方法，不暴露UI访问</li>
</ol>
<hr/>
<h3 data-id="heading-9">三、InputConnection的Binder实现</h3>
<h4 data-id="heading-10">3.1 AIDL接口定义</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// IInputContext.aidl (系统内部接口)</span>
<span class="hljs-keyword">package</span> com.android.internal.view;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">IInputContext</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteSurroundingText</span><span class="hljs-params">(<span class="hljs-type">int</span> beforeLength, <span class="hljs-type">int</span> afterLength)</span>;

    CharSequence <span class="hljs-title function_">getTextBeforeCursor</span><span class="hljs-params">(<span class="hljs-type">int</span> length, <span class="hljs-type">int</span> flags)</span>;
    CharSequence <span class="hljs-title function_">getTextAfterCursor</span><span class="hljs-params">(<span class="hljs-type">int</span> length, <span class="hljs-type">int</span> flags)</span>;
    <span class="hljs-comment">// ... 更多方法</span>
}
</code></pre>
<p><strong>AIDL的作用</strong>：</p>
<ul>
<li>定义跨进程接口</li>
<li>编译后自动生成Stub（服务端）和Proxy（客户端）</li>
</ul>
<h4 data-id="heading-11">3.2 应用进程：Binder Stub</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// IInputConnectionWrapper.java (应用进程)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">IInputConnectionWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IInputContext</span>.Stub {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InputConnection mInputConnection; <span class="hljs-comment">// BaseInputConnection</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Handler mH;                      <span class="hljs-comment">// 主线程Handler</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
        <span class="hljs-comment">// 当前线程：Binder线程池中的线程（如 Binder:12345_3）</span>

        <span class="hljs-comment">// 发送到主线程执行</span>
        mH.post(() -&gt; {
            <span class="hljs-comment">// 主线程执行</span>
            mInputConnection.setComposingText(text, newCursorPosition);
        });

        <span class="hljs-comment">// 立即返回，不等待执行完成！</span>
    }
}
</code></pre>
<p><strong>关键点1</strong>：线程切换</p>
<ul>
<li>Binder调用发生在Binder线程（非主线程）</li>
<li>EditText操作必须在主线程（ViewRootImpl检查）</li>
<li>通过Handler.post切换线程</li>
</ul>
<p><strong>关键点2</strong>：异步执行</p>
<ul>
<li><code>post()</code>后立即返回，不阻塞Binder线程</li>
<li>输入法认为调用"成功"，但实际尚未执行</li>
<li>这是后续Bug的根源之一</li>
</ul>
<h4 data-id="heading-12">3.3 输入法进程：Binder Proxy</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 输入法进程中的代理对象</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputConnectionProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InputConnection</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IInputContext mIInputContext; <span class="hljs-comment">// Binder代理</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 看似本地调用，实际跨进程</span>
            mIInputContext.setComposingText(text, newCursorPosition);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">catch</span> (RemoteException e) {
            <span class="hljs-comment">// 应用进程崩溃或连接断开</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<p><strong>关键点</strong>：透明的跨进程</p>
<ul>
<li>输入法调用本地方法</li>
<li>Binder驱动自动转发到应用进程</li>
<li>返回值只表示"Binder调用成功"，不表示"文本操作成功"</li>
</ul>
<hr/>
<h3 data-id="heading-13">四、完整的Binder调用链路</h3>
<h4 data-id="heading-14">4.1 详细时序图</h4>
<p>用户点击字母'q'的完整流程：</p>
<pre><code class="hljs language-scss" lang="scss">输入法进程                Binder驱动           应用进程
(Baidu IME)                                   (Your App)
     │                                            │
     │ <span class="hljs-number">1</span>. <span class="hljs-built_in">onKeyClick</span>('q')                         │
     │    ↓                                       │
     │ <span class="hljs-number">2</span>. <span class="hljs-built_in">getCurrentInputConnection</span>()             │
     │    → InputConnectionProxy                  │
     │    ↓                                       │
     │ <span class="hljs-number">3</span>. proxy<span class="hljs-selector-class">.setComposingText</span>("q", <span class="hljs-number">1</span>)          │
     │    ↓                                       │
     │ <span class="hljs-number">4</span>. Parcel<span class="hljs-selector-class">.obtain</span>()                         │
     │    写入参数到Parcel                         │
     │    ↓                                       │
     │ <span class="hljs-number">5</span>. mRemote<span class="hljs-selector-class">.transact</span>()                      │
     ├─────────────→ Binder驱动                   │
     │               ├─ 拷贝数据到内核缓冲区        │
     │               ├─ 查找目标进程 (PID)         │
     │               ├─ 唤醒Binder线程             │
     │               └──────────→ Binder线程池     │
     │                              ↓             │
     │                          <span class="hljs-number">6</span>. <span class="hljs-built_in">onTransact</span>()   │
     │                              ↓             │
     │                          <span class="hljs-number">7</span>. 解析Parcel     │
     │                              ↓             │
     │                          <span class="hljs-number">8</span>. Handler<span class="hljs-selector-class">.post</span>() │
     │                              ↓             │
     │                          返回成功           │
     │◄─────────────────────────────┘             │
     │                                            │
     │ <span class="hljs-number">9</span>. 输入法认为调用成功                        │
     │    继续执行后续逻辑                          │
     │                                            │
     │                              消息队列       │
     │                              ↓             │
     │                          <span class="hljs-number">10</span>. 主线程         │
     │                              Handler<span class="hljs-selector-class">.handleMessage</span>()
     │                              ↓             │
     │                          <span class="hljs-number">11</span>. BaseInputConnection
     │                              <span class="hljs-selector-class">.setComposingText</span>()
     │                              ↓             │
     │                          <span class="hljs-number">12</span>. <span class="hljs-built_in">replaceText</span>() │
     │                              ↓             │
     │                          <span class="hljs-number">13</span>. Editable操作  │
     │                              ↓             │
     │                          <span class="hljs-number">14</span>. UI刷新        │
</code></pre>
<h4 data-id="heading-15">4.2 Binder transact的实现</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// Proxy端（输入法进程）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
    <span class="hljs-type">Parcel</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> Parcel.obtain();   <span class="hljs-comment">// 数据包</span>
    <span class="hljs-type">Parcel</span> <span class="hljs-variable">reply</span> <span class="hljs-operator">=</span> Parcel.obtain();  <span class="hljs-comment">// 返回包</span>

    <span class="hljs-keyword">try</span> {
        data.writeInterfaceToken(DESCRIPTOR);

        <span class="hljs-comment">// 序列化参数</span>
        TextUtils.writeToParcel(text, data, <span class="hljs-number">0</span>);
        data.writeInt(newCursorPosition);

        <span class="hljs-comment">// 发起Binder调用（阻塞等待返回）</span>
        mRemote.transact(TRANSACTION_setComposingText, data, reply, <span class="hljs-number">0</span>);

        reply.readException(); <span class="hljs-comment">// 读取异常（如果有）</span>
    } <span class="hljs-keyword">finally</span> {
        data.recycle();
        reply.recycle();
    }
}
</code></pre>
<p><strong>性能数据</strong>：</p>
<ul>
<li>序列化：~10μs</li>
<li>Binder transact：~100μs</li>
<li>总耗时：~110μs</li>
</ul>
<p>但这只是到达应用进程Binder线程的时间，实际执行还要等主线程调度。</p>
<h4 data-id="heading-16">4.3 线程切换的延迟</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// Stub端（应用进程）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
    <span class="hljs-comment">// 当前：Binder线程</span>

    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mH.obtainMessage(DO_SET_COMPOSING_TEXT);
    msg.obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeArgs</span>(text, newCursorPosition);
    msg.sendToTarget();

    <span class="hljs-comment">// 立即返回（总耗时 ~110μs）</span>
}

<span class="hljs-comment">// 主线程 Handler</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> {
    <span class="hljs-comment">// 当前：主线程</span>
    <span class="hljs-comment">// 延迟：取决于主线程消息队列</span>
    <span class="hljs-comment">//      正常情况：&lt; 16ms (一帧)</span>
    <span class="hljs-comment">//      繁忙情况：&gt; 100ms</span>

    mInputConnection.setComposingText(...);
}
</code></pre>
<p><strong>信息不对称的根源</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">输入法视角：
  调用 <span class="hljs-built_in">setComposingText</span>() → 返回 <span class="hljs-literal">true</span> → <span class="hljs-string">"成功"</span>

实际情况：
  Binder调用成功 ≠ 文本操作成功
  可能还在消息队列中排队
  可能被InputFilter拒绝

输入法无从得知真实结果！
</code></pre>
<hr/>
<h3 data-id="heading-17">五、Binder机制的性能考量</h3>
<h4 data-id="heading-18">5.1 一次拷贝 vs 两次拷贝</h4>
<p><strong>传统IPC（管道/Socket）</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">发送进程用户空间 → 内核缓冲区 → 接收进程用户空间
     (拷贝<span class="hljs-number">1</span>)           (拷贝<span class="hljs-number">2</span>)
</code></pre>
<p><strong>Binder IPC</strong>：</p>
<pre><code class="hljs language-markdown" lang="markdown">发送进程用户空间 → Binder内核缓冲区（mmap映射）
<span class="hljs-code">     (拷贝1)            ↓
                 接收进程直接访问（零拷贝）
</span></code></pre>
<p><strong>mmap的作用</strong>：</p>
<ul>
<li>内核缓冲区映射到接收进程地址空间</li>
<li>接收进程读取时无需拷贝</li>
<li>减少50%的数据拷贝开销</li>
</ul>
<h4 data-id="heading-19">5.2 CharSequence的传输成本</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// TextUtils.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToParcel</span><span class="hljs-params">(CharSequence cs, Parcel p, <span class="hljs-type">int</span> flags)</span> {
    <span class="hljs-keyword">if</span> (cs <span class="hljs-keyword">instanceof</span> Spanned) {
        <span class="hljs-comment">// 包含富文本样式</span>
        p.writeInt(<span class="hljs-number">1</span>);
        p.writeString(cs.toString());

        <span class="hljs-comment">// 序列化Span信息</span>
        <span class="hljs-type">Spanned</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> (Spanned) cs;
        Object[] spans = sp.getSpans(<span class="hljs-number">0</span>, cs.length(), Object.class);
        p.writeInt(spans.length);

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; spans.length; i++) {
            <span class="hljs-type">Object</span> <span class="hljs-variable">span</span> <span class="hljs-operator">=</span> spans[i];
            <span class="hljs-type">int</span> <span class="hljs-variable">spanStart</span> <span class="hljs-operator">=</span> sp.getSpanStart(span);
            <span class="hljs-type">int</span> <span class="hljs-variable">spanEnd</span> <span class="hljs-operator">=</span> sp.getSpanEnd(span);
            <span class="hljs-type">int</span> <span class="hljs-variable">spanFlags</span> <span class="hljs-operator">=</span> sp.getSpanFlags(span);

            <span class="hljs-comment">// 每个Span: 类型 + 起始 + 结束 + 标志</span>
            <span class="hljs-comment">// 约 20-50 bytes</span>
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 纯文本</span>
        p.writeInt(<span class="hljs-number">0</span>);
        p.writeString(cs.toString());
    }
}
</code></pre>
<p><strong>性能对比</strong>：</p>
<pre><code class="hljs language-python" lang="python">纯文本 <span class="hljs-string">"hello"</span>:
  <span class="hljs-number">5</span>个字符 × <span class="hljs-number">2</span> <span class="hljs-built_in">bytes</span> (UTF-<span class="hljs-number">16</span>) = <span class="hljs-number">10</span> <span class="hljs-built_in">bytes</span>
  + 长度信息 = <span class="hljs-number">14</span> <span class="hljs-built_in">bytes</span>

富文本 <span class="hljs-string">"hello"</span> (红色 + 粗体):
  文本: <span class="hljs-number">14</span> <span class="hljs-built_in">bytes</span>
  + <span class="hljs-number">2</span>个Span × <span class="hljs-number">40</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-number">80</span> <span class="hljs-built_in">bytes</span>
  总计: <span class="hljs-number">94</span> <span class="hljs-built_in">bytes</span> (<span class="hljs-number">6.7</span>倍)
</code></pre>
<p><strong>优化建议</strong>：输入法尽量发送纯文本，避免Span。</p>
<h4 data-id="heading-20">5.3 高频调用的性能影响</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 用户快速输入 "hello"</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : <span class="hljs-string">"hello"</span>.toCharArray()) {
    ic.commitText(String.valueOf(c), <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 每次调用：~110μs Binder + ~200μs 主线程执行</span>
}

<span class="hljs-comment">// 5个字符 × 310μs = 1.55ms (可接受)</span>

<span class="hljs-comment">// 但如果输入法还读取上下文：</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : <span class="hljs-string">"hello"</span>.toCharArray()) {
    <span class="hljs-type">CharSequence</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> ic.getTextBeforeCursor(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// +110μs</span>
    ic.commitText(String.valueOf(c), <span class="hljs-number">1</span>);              <span class="hljs-comment">// +310μs</span>
}

<span class="hljs-comment">// 5个字符 × 420μs = 2.1ms (仍可接受)</span>
</code></pre>
<p><strong>结论</strong>：Binder性能足够好，不是瓶颈。</p>
<hr/>
<h3 data-id="heading-21">六、从Binder视角看Bug的触发</h3>
<h4 data-id="heading-22">6.1 正常场景：输入数字</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 输入法进程</span>
ic.commitText(<span class="hljs-string">"1"</span>, <span class="hljs-number">1</span>);

<span class="hljs-comment">// Binder传输到应用进程</span>
<span class="hljs-comment">// ↓</span>

<span class="hljs-comment">// 应用进程主线程</span>
BaseInputConnection.commitText(<span class="hljs-string">"1"</span>, <span class="hljs-number">1</span>)
  → Editable.insert(<span class="hljs-number">0</span>, <span class="hljs-string">"1"</span>)
  → InputFilter.filter(<span class="hljs-string">"1"</span>, ...)  <span class="hljs-comment">// DigitsKeyListener</span>
  → 检查：<span class="hljs-string">'1'</span> 是数字 → 返回 <span class="hljs-literal">null</span> (接受)
  → 插入成功
</code></pre>
<p><strong>结果</strong>：✓ 正常</p>
<h4 data-id="heading-23">6.2 Bug场景：输入字母</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 第1次：setComposingText("q")</span>
输入法进程：
  ic.setComposingText(<span class="hljs-string">"q"</span>, <span class="hljs-number">1</span>)
  ↓ Binder IPC
应用进程 Binder线程：
  IInputConnectionWrapper.onTransact()
  → Handler.post(runnable)
  → 返回成功
  ↓
输入法：认为成功，继续
  ↓
应用进程主线程（延迟执行）：
  BaseInputConnection.setComposingText(<span class="hljs-string">"q"</span>, <span class="hljs-number">1</span>)
  → replaceText(<span class="hljs-string">"q"</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)
  → 组合范围: a=-<span class="hljs-number">1</span>, b=-<span class="hljs-number">1</span> (无)
  → delete: 不执行
  → insert(<span class="hljs-string">"q"</span>): 被DigitsKeyListener拒绝
  → setComposingSpans(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 设置了空范围</span>

<span class="hljs-comment">// 第2次：setComposingText("qq")</span>
输入法进程：
  ic.setComposingText(<span class="hljs-string">"qq"</span>, <span class="hljs-number">1</span>)
  ↓ Binder IPC
应用进程主线程：
  BaseInputConnection.setComposingText(<span class="hljs-string">"qq"</span>, <span class="hljs-number">1</span>)
  → replaceText(<span class="hljs-string">"qq"</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)
  → 组合范围: a=<span class="hljs-number">5</span>, b=<span class="hljs-number">6</span> ← 上次设置的
  → delete(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>): 删除字符<span class="hljs-string">'6'</span> ✗ (绕过了Filter!)
  → insert(<span class="hljs-string">"qq"</span>): 被DigitsKeyListener拒绝
  → 结果: <span class="hljs-string">"12345"</span> (丢失了<span class="hljs-string">'6'</span>)
</code></pre>
<p><strong>Binder层面的问题</strong>：</p>
<pre><code class="hljs language-sql" lang="sql">输入法发送：setComposingText("qq")
  ↓ 期望：替换为"qq"
  ↓ 实际：<span class="hljs-keyword">delete</span>成功 <span class="hljs-operator">+</span> <span class="hljs-keyword">insert</span>失败
  ↓ 结果：数据丢失
  ↓ 反馈：返回 <span class="hljs-literal">true</span> (成功)

输入法不知道实际发生了什么！
</code></pre>
<h4 data-id="heading-24">6.3 信息不对称的本质</h4>
<pre><code class="hljs language-sql" lang="sql">┌─────────────────────────────────────────────────┐
│          Binder接口的局限性                       │
├─────────────────────────────────────────────────┤
│                                                 │
│  接口定义：                                      │
│  <span class="hljs-type">boolean</span> setComposingText(CharSequence, <span class="hljs-type">int</span>)   │
│                                                 │
│  返回值含义：                                    │
│  <span class="hljs-operator">-</span> <span class="hljs-literal">true</span>:  Binder调用成功                        │
│  <span class="hljs-operator">-</span> <span class="hljs-literal">false</span>: Binder调用失败（RemoteException）     │
│                                                 │
│  无法表达：                                      │
│  <span class="hljs-operator">-</span> 文本是否真的被插入                            │
│  <span class="hljs-operator">-</span> 被InputFilter过滤掉多少字符                   │
│  <span class="hljs-operator">-</span> 实际光标位置                                 │
│  <span class="hljs-operator">-</span> <span class="hljs-keyword">delete</span><span class="hljs-operator">/</span><span class="hljs-keyword">insert</span>的详细结果                      │
│                                                 │
└─────────────────────────────────────────────────┘
</code></pre>
<p><strong>设计缺陷</strong>：</p>
<ul>
<li>接口过于简单，无法传递详细信息</li>
<li>异步执行，无法等待实际结果</li>
<li>输入法与应用状态不同步</li>
</ul>
<hr/>
<h3 data-id="heading-25">七、总结：Binder通信的本质</h3>
<h4 data-id="heading-26">7.1 核心架构回顾</h4>
<pre><code class="hljs language-scss" lang="scss">输入法进程 ←─ Binder IPC ─→ 应用进程
   ↓                          ↓
透明代理                    线程切换
(以为是本地调用)          (Binder线程 → 主线程)
   ↓                          ↓
调用返回 true               异步执行
(只表示IPC成功)            (可能失败，但无反馈)
   ↓                          ↓
继续后续操作                 实际文本操作
(基于错误假设)              (结果未知)
</code></pre>
<h4 data-id="heading-27">7.2 关键技术点</h4>



































<table><thead><tr><th>技术点</th><th>实现</th><th>影响</th></tr></thead><tbody><tr><td><strong>进程隔离</strong></td><td>输入法独立进程</td><td>安全性↑，需要IPC</td></tr><tr><td><strong>Binder IPC</strong></td><td>AIDL生成Stub/Proxy</td><td>一次拷贝，性能好</td></tr><tr><td><strong>线程切换</strong></td><td>Binder线程→Handler→主线程</td><td>异步执行，延迟</td></tr><tr><td><strong>返回值</strong></td><td>boolean (成功/失败)</td><td>信息不足，无细节</td></tr><tr><td><strong>信息不对称</strong></td><td>输入法不知道实际结果</td><td>引发后续Bug</td></tr></tbody></table>
<h4 data-id="heading-28">7.3 为后续文章铺垫</h4>
<p><strong>第一篇（本文）</strong>：</p>
<ul>
<li>✓ 理解了三进程架构</li>
<li>✓ 理解了Binder IPC机制</li>
<li>✓ 理解了异步通信导致的信息不对称</li>
</ul>
<p><strong>第二篇预告</strong>：</p>
<ul>
<li>从应用进程内部看：replaceText()为什么先delete后insert？</li>
<li>delete为什么能绕过InputFilter？</li>
<li>Span范围为什么会异常扩展？</li>
<li>→ 深入Editable、InputFilter、Span的设计缺陷</li>
</ul>
<p><strong>第三篇预告</strong>：</p>
<ul>
<li>如何在应用层解决这个问题？</li>
<li>完整的解决方案（保留数字键盘）</li>
<li>工程实践的最佳做法</li>
<li>→ 从架构设计到代码实现</li>
</ul>
<hr/>
<h3 data-id="heading-29">参考资料</h3>
<ol>
<li>Android源码：<code>frameworks/base/core/java/android/view/inputmethod/</code></li>
<li>Binder驱动：<code>kernel/drivers/android/binder.c</code></li>
<li>AIDL文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Fguide%2Fcomponents%2Faidl" target="_blank" title="https://developer.android.com/guide/components/aidl" ref="nofollow noopener noreferrer">Android Interface Definition Language</a></li>
<li>Binder原理：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsource.android.com%2Fdevices%2Farchitecture%2Fhidl%2Fbinder-ipc" target="_blank" title="https://source.android.com/devices/architecture/hidl/binder-ipc" ref="nofollow noopener noreferrer">Android Binder Design</a></li>
</ol>
<hr/>
<p><strong>下一篇</strong>：《从一个Bug看Android文本编辑的设计缺陷》- 深入应用进程内部，剖析Editable、InputFilter、Span机制的不对称性</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从一个Bug看Android文本编辑的设计缺陷]]></title>    <link>https://juejin.cn/post/7570932873131294747</link>    <guid>https://juejin.cn/post/7570932873131294747</guid>    <pubDate>2025-11-10T13:24:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570932873131294747" data-draft-id="7570932873131278363" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从一个Bug看Android文本编辑的设计缺陷"/> <meta itemprop="keywords" content="Android,Linux"/> <meta itemprop="datePublished" content="2025-11-10T13:24:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="WAsbry"/> <meta itemprop="url" content="https://juejin.cn/user/3413335797139511"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从一个Bug看Android文本编辑的设计缺陷
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3413335797139511/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    WAsbry
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T13:24:41.000Z" title="Mon Nov 10 2025 13:24:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">从一个Bug看Android文本编辑的设计缺陷</h2>
<h3 data-id="heading-1">💡 本文精华</h3>
<ul>
<li><strong>承接上文</strong>：第一篇解析了跨进程通信，本篇深入应用进程内部，剖析文本操作的设计缺陷</li>
<li><strong>核心矛盾</strong>：InputFilter期望控制所有文本操作，但delete()绕过了过滤机制</li>
<li><strong>关键发现</strong>：<code>replaceText()</code>先delete后insert，delete传入空字符串""，InputFilter认为合法放行</li>
<li><strong>深层原因</strong>：Span范围在insert失败后与实际文本不同步，导致范围异常扩展，吞噬更多字符</li>
<li><strong>价值</strong>：理解Android文本编辑框架的设计局限，为第三篇的工程解决方案做准备</li>
</ul>
<hr/>
<h3 data-id="heading-2">一、应用进程内部的文本编辑架构</h3>
<h4 data-id="heading-3">1.1 三大核心组件</h4>
<p>上一篇我们理解了Binder如何将输入法的调用传递到应用进程。现在聚焦应用进程内部：</p>
<pre><code class="hljs language-scss" lang="scss">应用进程内部架构：
┌─────────────────────────────────────────┐
│  TextView / EditText                    │
│    ├─ Editable (SpannableStringBuilder)│ ← 文本缓冲区
│    │    - char<span class="hljs-selector-attr">[]</span> mText                  │
│    │    - <span class="hljs-selector-tag">Object</span><span class="hljs-selector-attr">[]</span> mSpans               │
│    │                                    │
│    ├─ InputFilter<span class="hljs-selector-attr">[]</span>                    │ ← 过滤器链
│    │    - DigitsKeyListener             │
│    │    - LengthFilter                  │
│    │                                    │
│    └─ InputConnection                  │ ← 外部接口
│         - BaseInputConnection           │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>上一篇已讲</strong>：InputConnection是跨进程接口
<strong>本篇聚焦</strong>：Editable、InputFilter、Span如何协同工作</p>
<h4 data-id="heading-4">1.2 Editable接口设计</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Editable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CharSequence</span>, Spannable {
    <span class="hljs-comment">// 核心的三个操作</span>
    Editable <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> where, CharSequence text)</span>;
    Editable <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> en)</span>;
    Editable <span class="hljs-title function_">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> st, <span class="hljs-type">int</span> en, CharSequence text)</span>;

    <span class="hljs-comment">// 过滤器管理</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFilters</span><span class="hljs-params">(InputFilter[] filters)</span>;
    InputFilter[] getFilters();
}
</code></pre>
<p><strong>实现类</strong>：SpannableStringBuilder</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpannableStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Editable</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span>[] mText;           <span class="hljs-comment">// 存储字符</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> mGapStart;          <span class="hljs-comment">// Gap Buffer优化</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> mGapLength;

    <span class="hljs-keyword">private</span> Object[] mSpans;        <span class="hljs-comment">// 存储Span对象</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] mSpanStarts;      <span class="hljs-comment">// Span起始位置</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] mSpanEnds;        <span class="hljs-comment">// Span结束位置</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] mSpanFlags;       <span class="hljs-comment">// Span标志</span>

    <span class="hljs-comment">// 核心实现</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> SpannableStringBuilder <span class="hljs-title function_">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end,
                                          CharSequence tb, <span class="hljs-type">int</span> tbstart, <span class="hljs-type">int</span> tbend)</span> {
        <span class="hljs-comment">// 关键：这里会调用InputFilter链</span>
        InputFilter[] filters = getFilters();
        <span class="hljs-keyword">if</span> (filters != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; filters.length; i++) {
                <span class="hljs-type">CharSequence</span> <span class="hljs-variable">repl</span> <span class="hljs-operator">=</span> filters[i].filter(tb, tbstart, tbend,
                                                      <span class="hljs-built_in">this</span>, start, end);
                <span class="hljs-keyword">if</span> (repl != <span class="hljs-literal">null</span>) {
                    tb = repl;
                    tbstart = <span class="hljs-number">0</span>;
                    tbend = repl.length();
                }
            }
        }

        <span class="hljs-comment">// 执行实际的文本替换</span>
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>insert/delete最终都调用replace()</li>
<li>replace()会触发InputFilter链</li>
<li>但有个例外...</li>
</ul>
<hr/>
<h3 data-id="heading-5">二、设计缺陷的核心：不对称的控制权</h3>
<h4 data-id="heading-6">2.1 InputFilter的接口设计</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InputFilter</span> {
    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@param</span> source 要插入的新文本
     * <span class="hljs-doctag">@param</span> start  source的起始位置
     * <span class="hljs-doctag">@param</span> end    source的结束位置
     * <span class="hljs-doctag">@param</span> dest   目标文本(当前EditText内容)
     * <span class="hljs-doctag">@param</span> dstart 插入位置的起始
     * <span class="hljs-doctag">@param</span> dend   插入位置的结束
     * <span class="hljs-doctag">@return</span> null  = 接受source
     *         ""    = 拒绝source
     *         其他  = 替换为返回的内容
     */</span>
    CharSequence <span class="hljs-title function_">filter</span><span class="hljs-params">(CharSequence source, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end,
                       Spanned dest, <span class="hljs-type">int</span> dstart, <span class="hljs-type">int</span> dend)</span>;
}
</code></pre>
<p><strong>DigitsKeyListener的实现</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// NumberKeyListener.java (父类)</span>
<span class="hljs-keyword">public</span> CharSequence <span class="hljs-title function_">filter</span><span class="hljs-params">(CharSequence source, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end,
                           Spanned dest, <span class="hljs-type">int</span> dstart, <span class="hljs-type">int</span> dend)</span> {
    <span class="hljs-type">char</span>[] accept = getAcceptedChars(); <span class="hljs-comment">// ['0'-'9']</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i++) {
        <span class="hljs-keyword">if</span> (!ok(accept, source.charAt(i))) {
            <span class="hljs-comment">// 发现非法字符 (如字母 'q')</span>
            <span class="hljs-keyword">if</span> (end - start == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>; <span class="hljs-comment">// 单个字符，直接拒绝</span>
            }
            <span class="hljs-comment">// 多个字符，过滤掉非法的</span>
            <span class="hljs-comment">// ...</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 全部合法，接受</span>
}

<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ok</span><span class="hljs-params">(<span class="hljs-type">char</span>[] accept, <span class="hljs-type">char</span> c)</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> accept.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        <span class="hljs-keyword">if</span> (accept[i] == c) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<h4 data-id="heading-7">2.2 delete()的特殊实现</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// SpannableStringBuilder.java</span>
<span class="hljs-keyword">public</span> SpannableStringBuilder <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {
    <span class="hljs-comment">// 关键：delete本质是replace操作，传入空字符串""</span>
    <span class="hljs-keyword">return</span> replace(start, end, <span class="hljs-string">""</span>);
}

<span class="hljs-comment">// 调用链</span>
delete(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
  ↓
replace(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
  ↓
filter(<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)  ← InputFilter看到的是空字符串
  ↓
<span class="hljs-comment">// DigitsKeyListener的检查</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0</span>; i++) {  <span class="hljs-comment">// start=0, end=0，循环不执行</span>
    <span class="hljs-comment">// 检查字符合法性</span>
}
  ↓
<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 接受！</span>
</code></pre>
<p><strong>问题本质</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────┐
│         InputFilter的视角                        │
├─────────────────────────────────────────────────┤
│                                                 │
│  <span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>, "abc"):                             │
│    <span class="hljs-built_in">filter</span>(<span class="hljs-string">"abc"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, dest, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>)            │
│    → 检查 <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span> → 拒绝 ✓               │
│                                                 │
│  <span class="hljs-built_in">delete</span>(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>):                                 │
│    <span class="hljs-built_in">filter</span>(<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, dest, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)               │
│    → 检查空字符串 → 接受 ✗                     │
│                                                 │
│  InputFilter无法区分：                          │
│  - 插入空字符串 (应接受)                        │
│  - 删除操作 (应该也能拦截吗?)                   │
│                                                 │
└─────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-8">2.3 设计假设 vs 实际情况</h4>



































<table><thead><tr><th>场景</th><th>设计假设</th><th>实际情况</th><th>是否合理</th></tr></thead><tbody><tr><td><strong>用户按删除键</strong></td><td>delete应该无条件执行</td><td>delete绕过InputFilter</td><td>✓ 合理（尊重用户意图）</td></tr><tr><td><strong>InputFilter拦截insert</strong></td><td>拦截非法字符插入</td><td>只能拦截insert</td><td>✓ 符合预期</td></tr><tr><td><strong>组合文本替换</strong></td><td>替换应该原子执行</td><td>delete先于insert，分离执行</td><td>✗ 不合理</td></tr><tr><td><strong>delete+insert组合</strong></td><td>应该保持一致性</td><td>delete绕过，insert拦截</td><td>✗ 不对称</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-9">三、BaseInputConnection的replaceText()实现</h3>
<h4 data-id="heading-10">3.1 核心代码分析</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// BaseInputConnection.java</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition, <span class="hljs-type">boolean</span> composing)</span> {
    <span class="hljs-keyword">final</span> <span class="hljs-type">Editable</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> getEditable();
    <span class="hljs-keyword">if</span> (content == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>;
    }

    beginBatchEdit();

    <span class="hljs-comment">// ========== 步骤1: 获取旧的组合文本范围 ==========</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> getComposingSpanStart(content);
    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> getComposingSpanEnd(content);

    <span class="hljs-keyword">if</span> (b &lt; a) {
        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;
        a = b;
        b = tmp;
    }

    <span class="hljs-keyword">if</span> (a != -<span class="hljs-number">1</span> &amp;&amp; b != -<span class="hljs-number">1</span>) {
        removeComposingSpans(content);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果没有组合范围，使用选中范围</span>
        a = Selection.getSelectionStart(content);
        b = Selection.getSelectionEnd(content);
    }

    <span class="hljs-comment">// ========== 步骤2: 先删除旧范围 ==========</span>
    <span class="hljs-keyword">if</span> (b != a) {
        content.delete(a, b);  <span class="hljs-comment">// ← 关键: 先删除，不经过InputFilter验证！</span>
    }

    <span class="hljs-comment">// ========== 步骤3: 再插入新文本 ==========</span>
    <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span>) {
        content.insert(a, text);  <span class="hljs-comment">// ← 经过InputFilter，可能被拒绝</span>
    }

    <span class="hljs-comment">// ========== 步骤4: 设置新的组合范围 ==========</span>
    <span class="hljs-keyword">if</span> (composing) {
        setComposingSpans(content, a, a + text.length());
    }

    endBatchEdit();
}
</code></pre>
<h4 data-id="heading-11">3.2 Bug触发的完整流程</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 前提：EditText内容 "123456"，光标在末尾</span>

<span class="hljs-comment">// ========== 第1次：setComposingText("q") ==========</span>
replaceText(<span class="hljs-string">"q"</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)
  ↓
步骤<span class="hljs-number">1</span>: 获取组合范围
  a = getComposingSpanStart() → -<span class="hljs-number">1</span> (无旧范围)
  b = getComposingSpanEnd() → -<span class="hljs-number">1</span>
  使用光标位置: a=<span class="hljs-number">6</span>, b=<span class="hljs-number">6</span>
  ↓
步骤<span class="hljs-number">2</span>: 删除
  <span class="hljs-keyword">if</span> (<span class="hljs-number">6</span> != <span class="hljs-number">6</span>) → <span class="hljs-literal">false</span>，不执行delete
  ↓
步骤<span class="hljs-number">3</span>: 插入
  content.insert(<span class="hljs-number">6</span>, <span class="hljs-string">"q"</span>)
    → filter(<span class="hljs-string">"q"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>)
    → 检查: <span class="hljs-string">'q'</span> 不是数字
    → 返回 <span class="hljs-string">""</span> (拒绝)
    → 插入失败
  ↓
步骤<span class="hljs-number">4</span>: 设置组合范围
  setComposingSpans(<span class="hljs-number">6</span>, <span class="hljs-number">6</span> + <span class="hljs-number">0</span>) → [<span class="hljs-number">6</span>, <span class="hljs-number">6</span>)
  ↓
结果: <span class="hljs-string">"123456"</span> (未变)

<span class="hljs-comment">// ========== 第2次：setComposingText("qq") ==========</span>
replaceText(<span class="hljs-string">"qq"</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)
  ↓
步骤<span class="hljs-number">1</span>: 获取组合范围
  a = getComposingSpanStart() → <span class="hljs-number">5</span> ← 为什么是<span class="hljs-number">5</span>? (稍后分析)
  b = getComposingSpanEnd() → <span class="hljs-number">6</span>
  ↓
步骤<span class="hljs-number">2</span>: 删除 ← Bug开始！
  <span class="hljs-keyword">if</span> (<span class="hljs-number">6</span> != <span class="hljs-number">5</span>) → <span class="hljs-literal">true</span>
  content.delete(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
    → replace(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
    → filter(<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
    → 循环不执行 (start=<span class="hljs-number">0</span>, end=<span class="hljs-number">0</span>)
    → 返回 <span class="hljs-literal">null</span> (接受)
    → 删除成功！字符<span class="hljs-string">'6'</span>被删除
  content = <span class="hljs-string">"12345"</span>
  ↓
步骤<span class="hljs-number">3</span>: 插入
  content.insert(<span class="hljs-number">5</span>, <span class="hljs-string">"qq"</span>)
    → filter(<span class="hljs-string">"qq"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-string">"12345"</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>)
    → 检查: <span class="hljs-string">'q'</span> 不是数字
    → 返回 <span class="hljs-string">""</span> (拒绝)
    → 插入失败
  ↓
步骤<span class="hljs-number">4</span>: 设置组合范围
  setComposingSpans(<span class="hljs-number">5</span>, <span class="hljs-number">5</span> + <span class="hljs-number">0</span>) → [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)
  ↓
结果: <span class="hljs-string">"12345"</span> ✗ (丢失了<span class="hljs-string">'6'</span>)
</code></pre>
<h4 data-id="heading-12">3.3 为什么先delete后insert？</h4>
<p><strong>设计意图</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 组合文本的替换逻辑</span>
<span class="hljs-comment">// 例如：拼音输入 "zhongguo" → 候选词 "中国"</span>

<span class="hljs-comment">// 旧组合文本: "zhongguo" (8个字符)</span>
<span class="hljs-comment">// 新组合文本: "中国" (2个字符)</span>

<span class="hljs-comment">// 如果先insert后delete：</span>
insert(<span class="hljs-string">"中国"</span>)    → <span class="hljs-string">"123456zhongguo中国"</span>
delete(<span class="hljs-number">6</span>, <span class="hljs-number">14</span>)    → <span class="hljs-string">"123456中国"</span>

<span class="hljs-comment">// 如果先delete后insert：</span>
delete(<span class="hljs-number">6</span>, <span class="hljs-number">14</span>)    → <span class="hljs-string">"123456"</span>
insert(<span class="hljs-string">"中国"</span>)   → <span class="hljs-string">"123456中国"</span>

<span class="hljs-comment">// 两种方式结果相同，但先delete后insert更高效</span>
<span class="hljs-comment">// (避免临时创建过长的字符串)</span>
</code></pre>
<p><strong>问题</strong>：</p>
<ul>
<li>假设了insert总是成功</li>
<li>没有考虑InputFilter拒绝的情况</li>
<li>没有回滚机制</li>
</ul>
<hr/>
<h3 data-id="heading-13">四、Span机制导致的范围异常扩展</h3>
<h4 data-id="heading-14">4.1 COMPOSING Span的作用</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// BaseInputConnection.java</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">COMPOSING</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComposingText</span>();

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComposingText</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NoCopySpan</span> {
    <span class="hljs-comment">// 空实现，只作为标记</span>
}

<span class="hljs-comment">// 获取组合文本范围</span>
<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getComposingSpanStart</span><span class="hljs-params">(Spannable text)</span> {
    <span class="hljs-keyword">return</span> text.getSpanStart(COMPOSING);
}

<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getComposingSpanEnd</span><span class="hljs-params">(Spannable text)</span> {
    <span class="hljs-keyword">return</span> text.getSpanEnd(COMPOSING);
}

<span class="hljs-comment">// 设置组合文本范围</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">setComposingSpans</span><span class="hljs-params">(Spannable text, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {
    <span class="hljs-comment">// 移除旧的COMPOSING Span</span>
    removeComposingSpans(text);

    <span class="hljs-comment">// 设置新的COMPOSING Span</span>
    text.setSpan(COMPOSING, start, end,
                 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
}
</code></pre>
<h4 data-id="heading-15">4.2 Span范围的动态变化</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 初始状态</span>
<span class="hljs-type">SpannableStringBuilder</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpannableStringBuilder</span>(<span class="hljs-string">"123456"</span>);
<span class="hljs-comment">// 无COMPOSING Span</span>

<span class="hljs-comment">// 第1次 setComposingText("q")</span>
setComposingSpans(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>)  <span class="hljs-comment">// 设置空范围Span</span>
<span class="hljs-comment">// text: "123456"</span>
<span class="hljs-comment">// Span: [6, 6) ← 空范围，但Span存在</span>

<span class="hljs-comment">// 第2次 setComposingText("qq")</span>
<span class="hljs-comment">// 1. 获取范围</span>
<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> getComposingSpanStart() → 返回 <span class="hljs-number">5</span> ← 为什么？
<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> getComposingSpanEnd() → 返回 <span class="hljs-number">6</span>

<span class="hljs-comment">// 2. delete(5, 6)</span>
text.delete(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
<span class="hljs-comment">// text: "12345"</span>
<span class="hljs-comment">// Span被自动调整...</span>

<span class="hljs-comment">// 3. insert("qq") 失败</span>

<span class="hljs-comment">// 4. setComposingSpans(5, 5)</span>
<span class="hljs-comment">// text: "12345"</span>
<span class="hljs-comment">// Span: [5, 5)</span>
</code></pre>
<h4 data-id="heading-16">4.3 为什么Span范围会从[6,6)变成[5,6)?</h4>
<p><strong>关键代码</strong>：setComposingSpans的实现</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setComposingSpans</span><span class="hljs-params">(Spannable text, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {
    <span class="hljs-comment">// 获取[start, end)范围内的所有Span</span>
    <span class="hljs-keyword">final</span> Object[] sps = text.getSpans(start, end, Object.class);
    <span class="hljs-keyword">if</span> (sps != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sps.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> sps[i];
            <span class="hljs-keyword">if</span> (o == COMPOSING) {
                text.removeSpan(o);
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">fl</span> <span class="hljs-operator">=</span> text.getSpanFlags(o);
            <span class="hljs-comment">// 关键：修改其他Span的范围和标志</span>
            <span class="hljs-keyword">if</span> ((fl &amp; (Spanned.SPAN_COMPOSING | Spanned.SPAN_POINT_MARK_MASK))
                    != (Spanned.SPAN_COMPOSING | SPAN_EXCLUSIVE_EXCLUSIVE)) {
                text.setSpan(o, start, end,
                    (fl &amp; ~SPAN_POINT_MARK_MASK)
                    | SPAN_COMPOSING | SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }
    }

    <span class="hljs-comment">// 设置新的COMPOSING Span</span>
    text.setSpan(COMPOSING, start, end,
        SPAN_EXCLUSIVE_EXCLUSIVE | SPAN_COMPOSING);
}
</code></pre>
<p><strong>问题根源</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">第<span class="hljs-number">1</span>次 <span class="hljs-built_in">setComposingSpans</span>(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>):
  - 设置 COMPOSING Span [<span class="hljs-number">6</span>, <span class="hljs-number">6</span>)
  - text长度: <span class="hljs-number">6</span>
  - 期望: Span在文本末尾

第<span class="hljs-number">2</span>次 <span class="hljs-built_in">insert</span>(<span class="hljs-string">"q"</span>) 失败:
  - text长度仍是<span class="hljs-number">6</span>
  - 但 <span class="hljs-built_in">setComposingSpans</span>(<span class="hljs-number">6</span>, <span class="hljs-number">6</span> + <span class="hljs-string">"q"</span>.<span class="hljs-built_in">length</span>()) 期望长度是<span class="hljs-number">7</span>
  - Span范围计算出现偏差

第<span class="hljs-number">3</span>次 <span class="hljs-built_in">getComposingSpanStart</span>():
  - SpannableStringBuilder内部的Span位置计算
  - 由于text长度与预期不符
  - 返回了错误的起始位置 (<span class="hljs-number">5</span>而不是<span class="hljs-number">6</span>)

连锁反应:
  [<span class="hljs-number">6</span>, <span class="hljs-number">6</span>) → delete不执行 → [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) → <span class="hljs-built_in">delete</span>(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>) → [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) → <span class="hljs-built_in">delete</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) → ...
  范围逐渐向前扩展，吞噬更多字符！
</code></pre>
<h4 data-id="heading-17">4.4 Span范围扩展的可视化</h4>
<pre><code class="hljs language-sql" lang="sql">文本:     "123456"
索引:      <span class="hljs-number">012345</span>

第<span class="hljs-number">1</span>次操作后:
  text:  "123456"
  Span:  [<span class="hljs-number">6</span>, <span class="hljs-number">6</span>)  ← 空范围，在<span class="hljs-string">'6'</span>之后

第<span class="hljs-number">2</span>次操作:
  <span class="hljs-number">1.</span> 获取范围: [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) ← 异常！为什么变了？
  <span class="hljs-number">2.</span> <span class="hljs-keyword">delete</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>): "12345" ← 删除<span class="hljs-string">'6'</span>
  <span class="hljs-number">3.</span> <span class="hljs-keyword">insert</span>失败
  <span class="hljs-number">4.</span> 设置Span: [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>) ← 在<span class="hljs-string">'5'</span>之后

第<span class="hljs-number">3</span>次操作:
  <span class="hljs-number">1.</span> 获取范围: [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) ← 继续扩展
  <span class="hljs-number">2.</span> <span class="hljs-keyword">delete</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>): "123" ← 删除<span class="hljs-string">'4'</span>和<span class="hljs-string">'5'</span>
  <span class="hljs-number">3.</span> <span class="hljs-keyword">insert</span>失败
  <span class="hljs-number">4.</span> 设置Span: [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)

第<span class="hljs-number">4</span>次操作:
  <span class="hljs-number">1.</span> 获取范围: [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
  <span class="hljs-number">2.</span> <span class="hljs-keyword">delete</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>): "" ← 删除全部
</code></pre>
<p><strong>底层原因</strong>：SpannableStringBuilder的Span位置计算依赖文本长度，当实际长度与预期不符时，Span的<code>start/end</code>会被错误地调整。</p>
<hr/>
<h3 data-id="heading-18">五、设计缺陷的层次分析</h3>
<h4 data-id="heading-19">5.1 接口层：filter()无法区分操作类型</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 当前接口</span>
CharSequence <span class="hljs-title function_">filter</span><span class="hljs-params">(CharSequence source, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end,
                   Spanned dest, <span class="hljs-type">int</span> dstart, <span class="hljs-type">int</span> dend)</span>;
</code></pre>
<p><strong>缺陷</strong>：</p>
<ul>
<li>只看到<code>source</code>（要插入的内容）</li>
<li>看不到操作类型（insert? delete? replace?）</li>
<li>看不到操作来源（用户? 输入法? 系统?）</li>
<li>无法区分"插入空字符串"和"删除操作"</li>
</ul>
<p><strong>理想接口</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">OperationType</span> { INSERT, DELETE, REPLACE }
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">OperationSource</span> { USER_KEY, IME, SYSTEM }

CharSequence <span class="hljs-title function_">filter</span><span class="hljs-params">(CharSequence source, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end,
                   Spanned dest, <span class="hljs-type">int</span> dstart, <span class="hljs-type">int</span> dend,
                   OperationType type,     // 操作类型
                   OperationSource source)</span>; <span class="hljs-comment">// 操作来源</span>
</code></pre>
<h4 data-id="heading-20">5.2 实现层：replaceText()缺乏原子性</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 当前实现（有缺陷）</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceText</span><span class="hljs-params">(CharSequence text, ...)</span> {
    <span class="hljs-keyword">if</span> (b != a) {
        content.delete(a, b); <span class="hljs-comment">// 可能删除合法内容</span>
    }
    <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span>) {
        content.insert(a, text); <span class="hljs-comment">// 可能被过滤</span>
    }
    <span class="hljs-comment">// 没有回滚机制！</span>
}
</code></pre>
<p><strong>改进方向1</strong>：先验证</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceText</span><span class="hljs-params">(CharSequence text, ...)</span> {
    <span class="hljs-comment">// 先检查新文本是否合法</span>
    <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span>) {
        <span class="hljs-type">CharSequence</span> <span class="hljs-variable">filtered</span> <span class="hljs-operator">=</span> applyFilters(text, a, a);
        <span class="hljs-keyword">if</span> (filtered.length() == <span class="hljs-number">0</span> &amp;&amp; text.length() &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 新文本被完全过滤，放弃替换</span>
            <span class="hljs-keyword">return</span>;
        }
        text = filtered; <span class="hljs-comment">// 使用过滤后的内容</span>
    }

    <span class="hljs-comment">// 再执行替换</span>
    <span class="hljs-keyword">if</span> (b != a) {
        content.delete(a, b);
    }
    <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span>) {
        content.insert(a, text);
    }
}
</code></pre>
<p><strong>改进方向2</strong>：使用原子replace</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 不要分开delete和insert，使用Editable.replace()</span>
content.replace(a, b, text);
<span class="hljs-comment">// replace()内部一次性调用filter</span>
<span class="hljs-comment">// filter可以同时看到删除范围[a,b)和插入内容text</span>
</code></pre>
<h4 data-id="heading-21">5.3 协议层：Span范围不可靠</h4>
<p><strong>当前机制</strong>：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">setComposingSpans</span>(start, end)
  → 假设文本长度会变为start + text<span class="hljs-selector-class">.length</span>()
  → 实际: insert失败，长度不变
  → Span范围与实际不符
  → 下次getComposingSpanStart/<span class="hljs-built_in">End</span>()返回错误值
</code></pre>
<p><strong>改进方向</strong>：引入版本号</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ComposingState</span> {
    <span class="hljs-type">int</span> start;
    <span class="hljs-type">int</span> end;
    <span class="hljs-type">int</span> textVersion; <span class="hljs-comment">// 文本版本号</span>

    <span class="hljs-comment">// 每次文本操作增加版本号</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> {
        textVersion++;
    }

    <span class="hljs-comment">// 验证Span范围是否仍有效</span>
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> currentVersion)</span> {
        <span class="hljs-keyword">return</span> textVersion == currentVersion;
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-22">六、对比：正常场景 vs Bug场景</h3>
<h4 data-id="heading-23">6.1 正常场景：用户主动删除</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 用户按删除键</span>
onKeyDown(KeyEvent.KEYCODE_DEL)
  ↓
BaseInputConnection.deleteSurroundingText(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
  ↓
Editable.delete(cursorPos - <span class="hljs-number">1</span>, cursorPos)
  ↓
replace(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
  ↓
filter(<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)
  ↓
返回 <span class="hljs-literal">null</span> (接受)
  ↓
删除成功 ✓
</code></pre>
<p><strong>这种情况下，delete应该被允许</strong>（用户主动操作）。</p>
<h4 data-id="heading-24">6.2 Bug场景：输入法自动替换</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 输入法调用 setComposingText("qq", 1)</span>
BaseInputConnection.setComposingText(<span class="hljs-string">"qq"</span>, <span class="hljs-number">1</span>)
  ↓
replaceText(<span class="hljs-string">"qq"</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)
  ↓
delete(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) + insert(<span class="hljs-string">"qq"</span>)
  ↓
delete成功 + insert失败
  ↓
数据丢失 ✗
</code></pre>
<p><strong>这种情况下，delete是"替换的一部分"，应该与insert保持一致</strong>。</p>
<h4 data-id="heading-25">6.3 核心差异</h4>






























<table><thead><tr><th>维度</th><th>用户删除</th><th>输入法替换</th></tr></thead><tbody><tr><td><strong>操作意图</strong></td><td>删除内容</td><td>替换内容（delete+insert）</td></tr><tr><td><strong>原子性</strong></td><td>单个操作</td><td>组合操作</td></tr><tr><td><strong>是否应拦截</strong></td><td>否（尊重用户）</td><td>是（保持一致性）</td></tr><tr><td><strong>实际行为</strong></td><td>delete通过 ✓</td><td>delete通过，insert被拒 ✗</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-26">七、总结：设计的不对称性</h3>
<h4 data-id="heading-27">7.1 核心矛盾</h4>
<pre><code class="hljs language-sql" lang="sql">┌─────────────────────────────────────────────────┐
│         文本编辑框架的不对称性                    │
├─────────────────────────────────────────────────┤
│                                                 │
│  InputFilter 的期望:                            │
│    控制所有文本操作                              │
│                                                 │
│  Editable 的实现:                               │
│    <span class="hljs-keyword">insert</span>() → 经过<span class="hljs-keyword">filter</span> ✓                     │
│    <span class="hljs-keyword">delete</span>() → 绕过<span class="hljs-keyword">filter</span> ✗                     │
│                                                 │
│  replaceText() 的假设:                          │
│    <span class="hljs-keyword">delete</span>() 总是成功                            │
│    <span class="hljs-keyword">insert</span>() 也总是成功                          │
│                                                 │
│  实际场景:                                       │
│    <span class="hljs-keyword">delete</span>() 成功                                │
│    <span class="hljs-keyword">insert</span>() 被InputFilter拒绝                  │
│    → 数据丢失                                   │
│                                                 │
│  Span 的副作用:                                 │
│    范围计算依赖文本长度                          │
│    <span class="hljs-keyword">insert</span>失败导致长度不符                        │
│    → 范围异常扩展                               │
│                                                 │
└─────────────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-28">7.2 循序渐进的知识链</h4>
<p><strong>第一篇</strong>：Binder通信机制</p>
<ul>
<li>✓ 理解了输入法→应用的跨进程调用</li>
<li>✓ 理解了异步执行导致的信息不对称</li>
<li>→ setComposingText("qq")被传递到应用进程</li>
</ul>
<p><strong>第二篇（本文）</strong>：文本编辑设计缺陷</p>
<ul>
<li>✓ 理解了replaceText()的先delete后insert</li>
<li>✓ 理解了delete绕过InputFilter的机制</li>
<li>✓ 理解了Span范围异常扩展的原因</li>
<li>→ 理解了为什么数字会被删除</li>
</ul>
<p><strong>第三篇预告</strong>：工程解决方案</p>
<ul>
<li>如何在InputConnection层拦截非法组合文本？</li>
<li>完整的解决方案（保留数字键盘）</li>
<li>三种方案对比与最佳实践</li>
<li>→ 从理论到实践</li>
</ul>
<hr/>
<h3 data-id="heading-29">参考资料</h3>
<ol>
<li>Android源码：<code>frameworks/base/core/java/android/text/SpannableStringBuilder.java</code></li>
<li>Android源码：<code>frameworks/base/core/java/android/view/inputmethod/BaseInputConnection.java</code></li>
<li>Android源码：<code>frameworks/base/core/java/android/text/method/DigitsKeyListener.java</code></li>
<li>官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Ftext%2FInputFilter" target="_blank" title="https://developer.android.com/reference/android/text/InputFilter" ref="nofollow noopener noreferrer">InputFilter</a></li>
</ol>
<hr/>
<p><strong>下一篇</strong>：《InputConnection机制与跨进程文本操作的工程实践》- 完整的解决方案，既保留数字键盘，又避免数据丢失</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[你知道npm create vite 怎么运作的吗？和我一起来写一个cli]]></title>    <link>https://juejin.cn/post/7570908785293557779</link>    <guid>https://juejin.cn/post/7570908785293557779</guid>    <pubDate>2025-11-10T13:23:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570908785293557779" data-draft-id="7569798982942228516" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="你知道npm create vite 怎么运作的吗？和我一起来写一个cli"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2025-11-10T13:23:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="奈德丽"/> <meta itemprop="url" content="https://juejin.cn/user/620537392934711"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            你知道npm create vite 怎么运作的吗？和我一起来写一个cli
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/620537392934711/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    奈德丽
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T13:23:05.000Z" title="Mon Nov 10 2025 13:23:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    21
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>大家好，我是奈德丽。</p>
<p>周末闲着没事，突然想研究一下 <code>create-vite</code> 是怎么实现的。打开源码一看，我人都傻了——核心逻辑就几百行代码！这让我突然来了兴致：既然这么简单，为什么不自己撸一个呢？</p>
<p>于是我花了一个周末的时间，从零开始实现了一个简化版的脚手架工具 <code>custom-create-vite</code>。虽然功能没有官方的全面，但该有的都有，而且还加了一些自己觉得好用的特性，比如eslint、tailwind等。</p>
<p>今天就来和大家分享一下整个实现过程，以及我踩过的那些坑，如果你也想有一个自己的cli工具，不妨花几分钟看一看。</p>
<h2 data-id="heading-1">为什么要造这个轮子？</h2>
<p>可能有人会问：官方的 <code>create-vite</code> 不是挺好用的吗？干嘛要自己写？</p>
<p>说实话，我主要是出于这几个原因：</p>
<p><strong>1. 学习目的</strong></p>
<p>学习当然是为了解决自己的疑惑，以前通过<code>npm create vite</code>，不知道实际上是怎么运行的，之前一直以为我执行了这个命令之后，vite cli是根据用户选择实时动态生成内容，简单点说，就是当你在Vue、React等众多框架中选择Vue时，cli是动态生成了vue模板，其实不是这样，它是提前创建了很多个template，比如js和ts就对应了不同模板，而React和Vue也是，他俩组合就有4个模板。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3b5488ad30d46b3a23de17eb09f1bb9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWI5b635Li9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763386516&amp;x-signature=b%2B9krr%2F0kckRX55KtXlXkQSwIMI%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/892a06b59f9c43f297f797bd930445bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWI5b635Li9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763386516&amp;x-signature=rfCnateS2kLJx2rpmoyxmdX%2F7xc%3D" alt="image.png" loading="lazy"/></p>
<p><strong>2. 团队定制需求</strong></p>
<p>我们团队有一些固定的开发规范，比如统一用 Antfu 的 ESLint 配置、Tailwind CSS v4 等等。每次创建新项目都要手动配置这些东西，贼烦。如果能在脚手架里预置这些选项，那就爽歪歪了。</p>
<p><strong>3. 插件化扩展</strong></p>
<p>我想实现一个插件系统，让用户在创建项目的时候就能选择要不要装 ESLint、Tailwind CSS、UnoCSS 这些工具。这样新项目开箱即用，不用再手动配置。</p>
<p>基于这些想法，我开始动手了。</p>
<h2 data-id="heading-2">技术选型</h2>
<p>既然是 2025 年了，那必须得用现代化的技术栈：</p>
<ul>
<li><strong>prompts</strong>：交互式命令行工具，API 简单，体积小</li>
<li><strong>picocolors</strong>：给终端输出加点颜色，提升用户体验</li>
</ul>
<p>没错，整个项目只依赖这两个包：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"prompts"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^2.4.2"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"picocolors"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.1.1"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 data-id="heading-3">项目结构设计</h2>
<p>在动手写代码之前，我先规划了一下项目主要结构：</p>
<pre><code class="hljs language-bash" lang="bash">mini-vite/
├── index.js                    <span class="hljs-comment"># 主入口文件</span>
├── plugins/                    <span class="hljs-comment"># 插件系统</span>
│   ├── index.js               <span class="hljs-comment"># 插件管理器</span>
│   ├── eslint.js              <span class="hljs-comment"># ESLint 插件</span>
│   ├── tailwind.js            <span class="hljs-comment"># Tailwind CSS 插件</span>
│   └── unocss.js              <span class="hljs-comment"># UnoCSS 插件</span>
├── template-vue/              <span class="hljs-comment"># Vue JavaScript 模板</span>
├── template-vue-ts/           <span class="hljs-comment"># Vue TypeScript 模板</span>
├── template-react/            <span class="hljs-comment"># React JavaScript 模板</span>
├── template-react-ts/         <span class="hljs-comment"># React TypeScript 模板</span>
└── package.json
</code></pre>
<p>结构很清晰：</p>
<ul>
<li>主逻辑放在 <code>index.js</code></li>
<li>插件系统独立成 <code>plugins</code> 目录，方便扩展</li>
<li>每个模板都是独立的目录，包含完整的项目文件</li>
</ul>
<p>除了主要目录，我还搭建了工作流，以及github 原生dependabot，如果有小伙伴感兴趣的话，后期可以写一篇文章专门讲一讲如何配置。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/373a8ee2d0794daea52d5f85c3c6591c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWI5b635Li9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763386516&amp;x-signature=4r4KzwW503x2myF5tiqinM0Q68g%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-4">核心流程实现</h2>
<p>下面讲讲具体的实现细节。整个流程可以分为 7 个步骤：</p>
<h3 data-id="heading-5">第一步：配置命令行入口</h3>
<p>首先在 <code>package.json</code> 里声明 bin 字段：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"mini-vite"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"bin"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"mini-vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"create-mini-vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"index.js"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>注意两点：</p>
<ol>
<li><strong>type 必须设置为 module</strong>，这样才能用 ES Module 语法</li>
<li>我配置了两个命令名，用户可以用 <code>mini-vite</code> 或 <code>create-mini-vite</code>，怎么顺手怎么来</li>
</ol>
<p>然后在 <code>index.js</code> 开头加上 shebang：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-meta">#!/usr/bin/env node</span>
</code></pre>
<p>这一行告诉系统用 Node.js 来执行这个文件。没有这一行，直接运行会报错。</p>
<h3 data-id="heading-6">第二步：询问项目名称</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> prompts <span class="hljs-keyword">from</span> <span class="hljs-string">'prompts'</span>
<span class="hljs-keyword">import</span> colors <span class="hljs-keyword">from</span> <span class="hljs-string">'picocolors'</span>

<span class="hljs-keyword">const</span> { cyan, green, yellow, red, reset } = colors

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\n<span class="hljs-subst">${cyan(<span class="hljs-string">'Mini Vite'</span>)}</span> - A minimal scaffolding tool\n`</span>)

  <span class="hljs-keyword">let</span> targetDir = <span class="hljs-string">'mini-vite-project'</span>

  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'text'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'projectName'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-title function_">reset</span>(<span class="hljs-string">'Project name:'</span>),
    <span class="hljs-attr">initial</span>: targetDir,
    <span class="hljs-attr">onState</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
      targetDir = state.<span class="hljs-property">value</span>?.<span class="hljs-title function_">trim</span>() || targetDir
    }
  })

  <span class="hljs-keyword">if</span> (!result.<span class="hljs-property">projectName</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n'</span> + <span class="hljs-title function_">red</span>(<span class="hljs-string">'✖'</span>) + <span class="hljs-string">' Operation cancelled'</span>)
    <span class="hljs-keyword">return</span>
  }
}

<span class="hljs-title function_">init</span>().<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-title function_">red</span>(<span class="hljs-string">'Error:'</span>), e)
  process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)
})
</code></pre>
<p>用 <code>prompts</code> 询问用户输入项目名称，默认是 <code>mini-vite-project</code>。如果用户直接按回车或者 Ctrl+C 取消，就退出程序。</p>
<h3 data-id="heading-7">第三步：检查目录是否存在</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>

<span class="hljs-keyword">const</span> root = path.<span class="hljs-title function_">join</span>(process.<span class="hljs-title function_">cwd</span>(), targetDir)

<span class="hljs-comment">// 判断目录是否为空</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params">path</span>) {
  <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(path)
  <span class="hljs-keyword">return</span> files.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || (files.<span class="hljs-property">length</span> === <span class="hljs-number">1</span> &amp;&amp; files[<span class="hljs-number">0</span>] === <span class="hljs-string">'.git'</span>)
}

<span class="hljs-comment">// 清空目录</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">emptyDir</span>(<span class="hljs-params">dir</span>) {
  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(dir)) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> fs.<span class="hljs-title function_">readdirSync</span>(dir)) {
    <span class="hljs-keyword">if</span> (file === <span class="hljs-string">'.git'</span>) <span class="hljs-keyword">continue</span>
    fs.<span class="hljs-title function_">rmSync</span>(path.<span class="hljs-title function_">resolve</span>(dir, file), { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">force</span>: <span class="hljs-literal">true</span> })
  }
}

<span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(root) &amp;&amp; !<span class="hljs-title function_">isEmpty</span>(root)) {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'select'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'overwrite'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">`Target directory "<span class="hljs-subst">${targetDir}</span>" is not empty. Please choose:`</span>,
    <span class="hljs-attr">choices</span>: [
      { <span class="hljs-attr">title</span>: <span class="hljs-string">'Cancel'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'no'</span> },
      { <span class="hljs-attr">title</span>: <span class="hljs-string">'Remove existing files'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'yes'</span> }
    ]
  })

  <span class="hljs-keyword">if</span> (response.<span class="hljs-property">overwrite</span> === <span class="hljs-string">'no'</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n'</span> + <span class="hljs-title function_">red</span>(<span class="hljs-string">'✖'</span>) + <span class="hljs-string">' Operation cancelled'</span>)
    <span class="hljs-keyword">return</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.<span class="hljs-property">overwrite</span> === <span class="hljs-string">'yes'</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\nRemoving existing files in <span class="hljs-subst">${targetDir}</span>...`</span>)
    <span class="hljs-title function_">emptyDir</span>(root)
  }
}
</code></pre>
<p>这里我踩了个坑！一开始我用 <code>fs.rmdirSync()</code>，结果发现如果目录非空就会报错。后来改成 <code>fs.rmSync()</code> 配合 <code>recursive: true</code>，才能递归删除整个目录。</p>
<h3 data-id="heading-8">第四步：验证包名</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidPackageName</span>(<span class="hljs-params">projectName</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^(?:@[a-z\d\-*~][a-z\d\-*._~]*\/)?[a-z\d\-~][a-z\d\-._~]*$/</span>.<span class="hljs-title function_">test</span>(projectName)
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">toValidPackageName</span>(<span class="hljs-params">projectName</span>) {
  <span class="hljs-keyword">return</span> projectName
    .<span class="hljs-title function_">trim</span>()
    .<span class="hljs-title function_">toLowerCase</span>()
    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">'-'</span>)
    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^[._]/</span>, <span class="hljs-string">''</span>)
    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[^a-z\d\-~]+/g</span>, <span class="hljs-string">'-'</span>)
}

<span class="hljs-keyword">let</span> packageName = path.<span class="hljs-title function_">basename</span>(root)

<span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidPackageName</span>(packageName)) {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'text'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'packageName'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-title function_">reset</span>(<span class="hljs-string">'Package name:'</span>),
    <span class="hljs-attr">initial</span>: <span class="hljs-title function_">toValidPackageName</span>(packageName),
    <span class="hljs-attr">validate</span>: <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-title function_">isValidPackageName</span>(name) || <span class="hljs-string">'Invalid package name'</span>
  })
  packageName = response.<span class="hljs-property">packageName</span>
}
</code></pre>
<p>npm 包名有一定的规范，不能有大写字母、空格、特殊字符等。所以需要验证一下，如果不合法就提示用户重新输入。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f3dcf8b3e3046d7bd9ae62a55b9ea7f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aWI5b635Li9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763386516&amp;x-signature=mCg2bucE19LkPNHly0wD6lIb31o%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-9">第五步：选择框架和变体</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FRAMEWORKS</span> = [
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vue'</span>,
    <span class="hljs-attr">display</span>: <span class="hljs-string">'Vue'</span>,
    <span class="hljs-attr">color</span>: green,
    <span class="hljs-attr">variants</span>: [
      { <span class="hljs-attr">name</span>: <span class="hljs-string">'vue-ts'</span>, <span class="hljs-attr">display</span>: <span class="hljs-string">'TypeScript'</span>, <span class="hljs-attr">color</span>: blue },
      { <span class="hljs-attr">name</span>: <span class="hljs-string">'vue'</span>, <span class="hljs-attr">display</span>: <span class="hljs-string">'JavaScript'</span>, <span class="hljs-attr">color</span>: yellow }
    ]
  },
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'react'</span>,
    <span class="hljs-attr">display</span>: <span class="hljs-string">'React'</span>,
    <span class="hljs-attr">color</span>: cyan,
    <span class="hljs-attr">variants</span>: [
      { <span class="hljs-attr">name</span>: <span class="hljs-string">'react-ts'</span>, <span class="hljs-attr">display</span>: <span class="hljs-string">'TypeScript'</span>, <span class="hljs-attr">color</span>: blue },
      { <span class="hljs-attr">name</span>: <span class="hljs-string">'react'</span>, <span class="hljs-attr">display</span>: <span class="hljs-string">'JavaScript'</span>, <span class="hljs-attr">color</span>: yellow }
    ]
  }
]

<span class="hljs-comment">// 选择框架</span>
<span class="hljs-keyword">const</span> frameworkResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'select'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'framework'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-title function_">reset</span>(<span class="hljs-string">'Select a framework:'</span>),
  <span class="hljs-attr">choices</span>: <span class="hljs-variable constant_">FRAMEWORKS</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">framework</span> =&gt;</span> ({
    <span class="hljs-attr">title</span>: framework.<span class="hljs-title function_">color</span>(framework.<span class="hljs-property">display</span>),
    <span class="hljs-attr">value</span>: framework
  }))
})

<span class="hljs-keyword">const</span> framework = frameworkResponse.<span class="hljs-property">framework</span>

<span class="hljs-keyword">if</span> (!framework) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n'</span> + <span class="hljs-title function_">red</span>(<span class="hljs-string">'✖'</span>) + <span class="hljs-string">' Operation cancelled'</span>)
  <span class="hljs-keyword">return</span>
}

<span class="hljs-comment">// 选择变体（TypeScript 或 JavaScript）</span>
<span class="hljs-keyword">const</span> variantResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'select'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'variant'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-title function_">reset</span>(<span class="hljs-string">'Select a variant:'</span>),
  <span class="hljs-attr">choices</span>: framework.<span class="hljs-property">variants</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">variant</span> =&gt;</span> ({
    <span class="hljs-attr">title</span>: variant.<span class="hljs-title function_">color</span>(variant.<span class="hljs-property">display</span>),
    <span class="hljs-attr">value</span>: variant.<span class="hljs-property">name</span>
  }))
})

<span class="hljs-keyword">const</span> template = variantResponse.<span class="hljs-property">variant</span>
</code></pre>
<p>这里我用了两级选择：先选框架（Vue 或 React），再选变体（TypeScript 或 JavaScript）。这样交互更清晰，用户体验更好。</p>
<p>每个选项都用不同的颜色标识，视觉效果更友好。</p>
<h3 data-id="heading-10">第六步：选择增强功能（插件系统）</h3>
<p>这是我觉得最有意思的部分！一开始我vite cli 的swc也是动态插入的，但是并没有这种插件模块，我想了一下还是通过单独的模块来实现一个插件系统，因为后续会扩展更多的插件，这样可扩展性也更高点</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 5. 选择增强功能（可选）</span>
  <span class="hljs-keyword">const</span> featuresResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>([
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'multiselect'</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'features'</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-title function_">reset</span>(<span class="hljs-string">'Select additional features:'</span>),
      <span class="hljs-comment">//把多选一的插件排除掉</span>
      <span class="hljs-attr">choices</span>: <span class="hljs-title function_">getPluginChoices</span>().<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">choice</span> =&gt;</span> ![<span class="hljs-string">'tailwind'</span>, <span class="hljs-string">'unocss'</span>].<span class="hljs-title function_">includes</span>(choice.<span class="hljs-property">value</span>)),
      <span class="hljs-attr">hint</span>: <span class="hljs-string">'- Space to select. Return to submit'</span>,
      <span class="hljs-attr">instructions</span>: <span class="hljs-literal">false</span>
    }
  ])

  <span class="hljs-keyword">const</span> selectedFeatures = featuresResponse.<span class="hljs-property">features</span> || []

  <span class="hljs-comment">// 6. 选择 CSS 框架（单选，可选）</span>
  <span class="hljs-keyword">const</span> cssFrameworkResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'select'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'cssFramework'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-title function_">reset</span>(<span class="hljs-string">'Select a CSS framework (optional):'</span>),
    <span class="hljs-attr">choices</span>: [
      { <span class="hljs-attr">title</span>: <span class="hljs-string">'None'</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> },
      { <span class="hljs-attr">title</span>: <span class="hljs-string">'Tailwind CSS v4'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'tailwind'</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">'Utility-first CSS framework'</span> },
      { <span class="hljs-attr">title</span>: <span class="hljs-string">'UnoCSS'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'unocss'</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">'Instant on-demand Atomic CSS'</span> }
    ]
  })

  <span class="hljs-keyword">if</span> (cssFrameworkResponse.<span class="hljs-property">cssFramework</span>) {
    selectedFeatures.<span class="hljs-title function_">push</span>(cssFrameworkResponse.<span class="hljs-property">cssFramework</span>)
  }
</code></pre>
<p>我把插件分成了两类：</p>
<ol>
<li><strong>通用功能</strong>：ESLint（多选）等不能同时选择的扩展</li>
<li><strong>CSS 框架</strong>：Tailwind CSS 或 UnoCSS（单选）</li>
</ol>
<p>为什么要分开呢？因为 CSS 框架是互斥的，不能同时装 Tailwind 和 UnoCSS，会冲突。所以必须用单选。</p>
<h3 data-id="heading-11">第七步：复制模板并应用插件</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>
<span class="hljs-keyword">import</span> { applyPlugins } <span class="hljs-keyword">from</span> <span class="hljs-string">'./plugins/index.js'</span>

<span class="hljs-keyword">const</span> currentDir = path.<span class="hljs-title function_">dirname</span>(<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>))
<span class="hljs-keyword">const</span> templateDir = path.<span class="hljs-title function_">resolve</span>(currentDir, <span class="hljs-string">`template-<span class="hljs-subst">${template}</span>`</span>)

<span class="hljs-comment">// 复制文件的工具函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">src, dest</span>) {
  <span class="hljs-keyword">const</span> stat = fs.<span class="hljs-title function_">statSync</span>(src)
  <span class="hljs-keyword">if</span> (stat.<span class="hljs-title function_">isDirectory</span>()) {
    <span class="hljs-title function_">copyDir</span>(src, dest)
  } <span class="hljs-keyword">else</span> {
    fs.<span class="hljs-title function_">copyFileSync</span>(src, dest)
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">copyDir</span>(<span class="hljs-params">srcDir, destDir</span>) {
  fs.<span class="hljs-title function_">mkdirSync</span>(destDir, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> fs.<span class="hljs-title function_">readdirSync</span>(srcDir)) {
    <span class="hljs-keyword">const</span> srcFile = path.<span class="hljs-title function_">resolve</span>(srcDir, file)
    <span class="hljs-keyword">const</span> destFile = path.<span class="hljs-title function_">resolve</span>(destDir, file)
    <span class="hljs-title function_">copy</span>(srcFile, destFile)
  }
}

<span class="hljs-comment">// 创建目标目录</span>
fs.<span class="hljs-title function_">mkdirSync</span>(root, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })

<span class="hljs-comment">// 复制模板文件</span>
<span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(templateDir)
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> files.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f !== <span class="hljs-string">'package.json'</span>)) {
  <span class="hljs-keyword">const</span> srcFile = path.<span class="hljs-title function_">join</span>(templateDir, file)
  <span class="hljs-keyword">const</span> destFile = path.<span class="hljs-title function_">join</span>(root, file)
  <span class="hljs-title function_">copy</span>(srcFile, destFile)
}

<span class="hljs-comment">// 读取并修改 package.json</span>
<span class="hljs-keyword">const</span> pkgPath = path.<span class="hljs-title function_">join</span>(templateDir, <span class="hljs-string">'package.json'</span>)
<span class="hljs-keyword">const</span> pkg = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(pkgPath, <span class="hljs-string">'utf-8'</span>))
pkg.<span class="hljs-property">name</span> = packageName

<span class="hljs-comment">// 应用选中的插件</span>
<span class="hljs-title function_">applyPlugins</span>(selectedFeatures, root, template, pkg)

<span class="hljs-comment">// 写入 package.json</span>
fs.<span class="hljs-title function_">writeFileSync</span>(
  path.<span class="hljs-title function_">join</span>(root, <span class="hljs-string">'package.json'</span>),
  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(pkg, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>) + <span class="hljs-string">'\n'</span>
)
</code></pre>
<p>这里有个小细节：因为用了 ES Module，没有 <code>__dirname</code> 变量，所以要用 <code>import.meta.url</code> 配合 <code>fileURLToPath</code> 来获取当前文件路径。</p>
<p>复制文件的逻辑很简单：递归遍历模板目录，把每个文件都复制到目标目录。</p>
<p>最关键的是 <code>applyPlugins</code> 这一步，它会根据用户选择的插件，动态修改项目配置。</p>
<h2 data-id="heading-12">插件系统的设计</h2>
<p>插件系统是整个项目的核心，我花了不少时间来设计它的架构。</p>
<h3 data-id="heading-13">插件的标准结构</h3>
<p>每个插件都是一个独立的 JS 文件，导出一个对象：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// plugins/eslint.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> eslintPlugin = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'eslint'</span>,
  <span class="hljs-attr">title</span>: <span class="hljs-string">'ESLint + Prettier (Antfu Config)'</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">'Code quality and formatting'</span>,
  
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">root, template, pkg</span>) {
    <span class="hljs-comment">// 1. 添加依赖</span>
    pkg.<span class="hljs-property">devDependencies</span> = pkg.<span class="hljs-property">devDependencies</span> || {}
    pkg.<span class="hljs-property">devDependencies</span>[<span class="hljs-string">'eslint'</span>] = <span class="hljs-string">'^9.39.1'</span>
    pkg.<span class="hljs-property">devDependencies</span>[<span class="hljs-string">'@antfu/eslint-config'</span>] = <span class="hljs-string">'^6.2.0'</span>
  
    <span class="hljs-comment">// 2. 创建配置文件</span>
    <span class="hljs-keyword">const</span> configContent = <span class="hljs-string">`import antfu from '@antfu/eslint-config'

export default antfu()`</span>
  
    fs.<span class="hljs-title function_">writeFileSync</span>(
      path.<span class="hljs-title function_">join</span>(root, <span class="hljs-string">'eslint.config.js'</span>),
      configContent
    )
  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${green(<span class="hljs-string">'✔'</span>)}</span> ESLint configured`</span>)
  }
}
</code></pre>
<p>每个插件包含：</p>
<ul>
<li><strong>name</strong>：插件标识</li>
<li><strong>title</strong>：显示给用户看的名称</li>
<li><strong>description</strong>：简短描述</li>
<li><strong>setup</strong>：安装函数，接收 <code>root</code>（项目目录）、<code>template</code>（模板名称）、<code>pkg</code>（package.json 对象）三个参数</li>
</ul>
<h3 data-id="heading-14">插件管理器</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// plugins/index.js</span>
<span class="hljs-keyword">import</span> { eslintPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">'./eslint.js'</span>
<span class="hljs-keyword">import</span> { tailwindPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">'./tailwind.js'</span>
<span class="hljs-keyword">import</span> { unocssPlugin } <span class="hljs-keyword">from</span> <span class="hljs-string">'./unocss.js'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> plugins = {
  <span class="hljs-attr">eslint</span>: eslintPlugin,
  <span class="hljs-attr">tailwind</span>: tailwindPlugin,
  <span class="hljs-attr">unocss</span>: unocssPlugin
}

<span class="hljs-comment">// 插件执行顺序</span>
<span class="hljs-keyword">const</span> pluginOrder = {
  <span class="hljs-attr">eslint</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">tailwind</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">unocss</span>: <span class="hljs-number">2</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">applyPlugins</span>(<span class="hljs-params">selectedPlugins, root, template, pkg</span>) {
  <span class="hljs-comment">// 按优先级排序</span>
  <span class="hljs-keyword">const</span> sortedPlugins = [...selectedPlugins].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> orderA = pluginOrder[a] || <span class="hljs-number">999</span>
    <span class="hljs-keyword">const</span> orderB = pluginOrder[b] || <span class="hljs-number">999</span>
    <span class="hljs-keyword">return</span> orderA - orderB
  })
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> pluginName <span class="hljs-keyword">of</span> sortedPlugins) {
    <span class="hljs-keyword">const</span> plugin = plugins[pluginName]
  
    <span class="hljs-keyword">if</span> (!plugin) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">${red(<span class="hljs-string">'✖'</span>)}</span> Plugin "<span class="hljs-subst">${pluginName}</span>" not found`</span>)
      <span class="hljs-keyword">continue</span>
    }
  
    <span class="hljs-keyword">try</span> {
      plugin.<span class="hljs-title function_">setup</span>(root, template, pkg)
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">${red(<span class="hljs-string">'✖'</span>)}</span> Failed to configure <span class="hljs-subst">${plugin.title}</span>`</span>)
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`   <span class="hljs-subst">${error.message}</span>`</span>)
    }
  }
}
</code></pre>
<p>插件管理器负责：</p>
<ol>
<li>按优先级排序插件（ESLint 要先执行，CSS 框架后执行）</li>
<li>依次调用每个插件的 <code>setup</code> 方法</li>
<li>错误处理，防止某个插件失败导致整个流程崩溃</li>
</ol>
<h3 data-id="heading-15">Tailwind CSS v4 插件</h3>
<p>这里我又踩了个坑！</p>
<p>Tailwind CSS v4 的配置方式和 v3 完全不同。v3 需要创建 <code>tailwind.config.js</code> 和 <code>postcss.config.js</code>，但 v4 简化了很多：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// plugins/tailwind.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> tailwindPlugin = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'tailwind'</span>,
  <span class="hljs-attr">title</span>: <span class="hljs-string">'Tailwind CSS v4'</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">'Utility-first CSS framework'</span>,
  
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">root, template, pkg</span>) {
    <span class="hljs-comment">// 1. 添加依赖</span>
    pkg.<span class="hljs-property">devDependencies</span>[<span class="hljs-string">'tailwindcss'</span>] = <span class="hljs-string">'^4.1.0'</span>
    pkg.<span class="hljs-property">devDependencies</span>[<span class="hljs-string">'@tailwindcss/vite'</span>] = <span class="hljs-string">'^4.1.0'</span>
  
    <span class="hljs-comment">// 2. 创建 CSS 文件</span>
    <span class="hljs-keyword">const</span> cssPath = path.<span class="hljs-title function_">join</span>(root, <span class="hljs-string">'src/index.css'</span>)
    fs.<span class="hljs-title function_">writeFileSync</span>(cssPath, <span class="hljs-string">'@import "tailwindcss";\n'</span>)
  
    <span class="hljs-comment">// 3. 修改 vite.config.js</span>
    <span class="hljs-keyword">const</span> viteConfigPath = path.<span class="hljs-title function_">join</span>(root, <span class="hljs-string">'vite.config.js'</span>)
    <span class="hljs-keyword">let</span> viteConfig = fs.<span class="hljs-title function_">readFileSync</span>(viteConfigPath, <span class="hljs-string">'utf-8'</span>)
  
    <span class="hljs-comment">// 在 import 区域添加</span>
    viteConfig = viteConfig.<span class="hljs-title function_">replace</span>(
      <span class="hljs-regexp">/(import .+ from .+\n)/</span>,
      <span class="hljs-string">`$1import tailwindcss from '@tailwindcss/vite'\n`</span>
    )
  
    <span class="hljs-comment">// 在 plugins 数组添加</span>
    viteConfig = viteConfig.<span class="hljs-title function_">replace</span>(
      <span class="hljs-regexp">/plugins:\s*\[/</span>,
      <span class="hljs-string">'plugins: [tailwindcss(), '</span>
    )
  
    fs.<span class="hljs-title function_">writeFileSync</span>(viteConfigPath, viteConfig)
  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${green(<span class="hljs-string">'✔'</span>)}</span> Tailwind CSS v4 configured`</span>)
  }
}
</code></pre>
<p>这里采用的最新版的v4 tailwindcss，v4 的配置步骤：</p>
<ol>
<li>安装 <code>tailwindcss</code> 和 <code>@tailwindcss/vite</code></li>
<li>在 CSS 文件里写 <code>@import "tailwindcss";</code></li>
<li>在 <code>vite.config.js</code> 引入 Vite 插件</li>
</ol>
<p><strong>不需要</strong>创建 <code>tailwind.config.js</code> 和 <code>postcss.config.js</code>！</p>
<h3 data-id="heading-16">UnoCSS 插件</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// plugins/unocss.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> unocssPlugin = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'unocss'</span>,
  <span class="hljs-attr">title</span>: <span class="hljs-string">'UnoCSS'</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">'Instant on-demand Atomic CSS'</span>,
  
  <span class="hljs-title function_">setup</span>(<span class="hljs-params">root, template, pkg</span>) {
    <span class="hljs-comment">// 1. 添加依赖</span>
    pkg.<span class="hljs-property">devDependencies</span>[<span class="hljs-string">'unocss'</span>] = <span class="hljs-string">'^0.64.6'</span>
  
    <span class="hljs-comment">// 2. 创建配置文件</span>
    <span class="hljs-keyword">const</span> configContent = <span class="hljs-string">`import { defineConfig } from 'unocss'

export default defineConfig({
  // 你的配置
})`</span>
  
    fs.<span class="hljs-title function_">writeFileSync</span>(
      path.<span class="hljs-title function_">join</span>(root, <span class="hljs-string">'uno.config.ts'</span>),
      configContent
    )
  
    <span class="hljs-comment">// 3. 修改 vite.config.js</span>
    <span class="hljs-keyword">const</span> viteConfigPath = path.<span class="hljs-title function_">join</span>(root, <span class="hljs-string">'vite.config.js'</span>)
    <span class="hljs-keyword">let</span> viteConfig = fs.<span class="hljs-title function_">readFileSync</span>(viteConfigPath, <span class="hljs-string">'utf-8'</span>)
  
    viteConfig = viteConfig.<span class="hljs-title function_">replace</span>(
      <span class="hljs-regexp">/(import .+ from .+\n)/</span>,
      <span class="hljs-string">`$1import UnoCSS from 'unocss/vite'\n`</span>
    )
  
    viteConfig = viteConfig.<span class="hljs-title function_">replace</span>(
      <span class="hljs-regexp">/plugins:\s*\[/</span>,
      <span class="hljs-string">'plugins: [UnoCSS(), '</span>
    )
  
    fs.<span class="hljs-title function_">writeFileSync</span>(viteConfigPath, viteConfig)
  
    <span class="hljs-comment">// 4. 修改 main 入口文件</span>
    <span class="hljs-keyword">const</span> isVue = template.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'vue'</span>)
    <span class="hljs-keyword">const</span> mainFile = isVue ? <span class="hljs-string">'main.js'</span> : <span class="hljs-string">'main.jsx'</span>
    <span class="hljs-keyword">const</span> mainPath = path.<span class="hljs-title function_">join</span>(root, <span class="hljs-string">'src'</span>, mainFile)
    <span class="hljs-keyword">let</span> mainContent = fs.<span class="hljs-title function_">readFileSync</span>(mainPath, <span class="hljs-string">'utf-8'</span>)
  
    mainContent = <span class="hljs-string">`import 'virtual:uno.css'\n<span class="hljs-subst">${mainContent}</span>`</span>
  
    fs.<span class="hljs-title function_">writeFileSync</span>(mainPath, mainContent)
  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${green(<span class="hljs-string">'✔'</span>)}</span> UnoCSS configured`</span>)
  }
}
</code></pre>
<p>UnoCSS 的配置相对复杂一点：</p>
<ol>
<li>创建 <code>uno.config.ts</code></li>
<li>修改 <code>vite.config.js</code> 引入插件</li>
<li>在入口文件（<code>main.js</code> 或 <code>main.jsx</code>）引入 <code>virtual:uno.css</code></li>
</ol>
<h2 data-id="heading-17">模板设计</h2>
<p>因为平常主要用Vue和React比较多，我为 Vue 和 React 各准备了 JS 和 TS 两个版本，一共 4 个模板。</p>
<h3 data-id="heading-18">Vue 模板</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">template</span>-vue/
├── index.html
├── vite.config.js
├── package.json
├── <span class="hljs-keyword">public</span>/
│   └── vite.svg
└── src/
    ├── main.js
    ├── App.vue
    ├── style.css
    ├── components/
    │   └── HelloWorld.vue
    └── assets/
        └── vue.svg
</code></pre>
<p><strong>package.json</strong>：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite-project"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"preview"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite preview"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"vue"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^3.5.13"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@vitejs/plugin-vue"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^5.2.1"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^6.0.5"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>vite.config.js</strong>：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()]
})
</code></pre>
<h3 data-id="heading-19">React 模板</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">template</span>-react/
├── index.html
├── vite.config.js
├── package.json
├── <span class="hljs-keyword">public</span>/
│   └── vite.svg
└── src/
    ├── main.jsx
    ├── App.jsx
    ├── index.css
    ├── components/
    │   └── Counter.jsx
    └── assets/
        └── react.svg
</code></pre>
<p><strong>package.json</strong>：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite-project"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"private"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"preview"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite preview"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^18.3.1"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"react-dom"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^18.3.1"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@vitejs/plugin-react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^4.3.4"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@types/react"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^18.3.18"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"@types/react-dom"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^18.3.5"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^6.0.5"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>TypeScript 版本就是在上面的基础上：</p>
<ol>
<li>添加 <code>tsconfig.json</code> 和 <code>tsconfig.node.json</code></li>
<li>文件后缀改成 <code>.ts</code> 或 <code>.tsx</code></li>
<li><code>package.json</code> 里加上 <code>typescript</code> 依赖</li>
</ol>
<h2 data-id="heading-20">使用方式</h2>
<p>开发阶段，可以用<code>node index.js</code>或则是使用 <code>npm link</code> 把命令链接到全局：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> mini-vite
npm <span class="hljs-built_in">link</span>
</code></pre>
<p>然后就可以在任意目录使用了：</p>
<pre><code class="hljs language-bash" lang="bash">mini-vite my-app
</code></pre>
<p>或者：</p>
<pre><code class="hljs language-bash" lang="bash">create-mini-vite my-app
</code></pre>
<p>执行后会看到交互式界面：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">Mini Vite - A minimal scaffolding tool

? Project name: › my-app
? <span class="hljs-keyword">Select</span> a framework: › 
  Vue
  React
? <span class="hljs-keyword">Select</span> a variant: › 
  TypeScript
  JavaScript
? <span class="hljs-keyword">Select</span> additional features: › 
◯ ESLint + Prettier (Antfu Config)
? <span class="hljs-keyword">Select</span> a CSS framework (<span class="hljs-keyword">optional</span>): › 
  None
  Tailwind CSS v4
  UnoCSS

✔ Scaffolding project <span class="hljs-keyword">in</span> /path/<span class="hljs-keyword">to</span>/my-app...

✔ ESLint configured
✔ Tailwind CSS v4 configured

✔ Done!

Now run:

  cd my-app
  npm install
  npm run dev
</code></pre>
<h2 data-id="heading-21">踩过的坑</h2>
<h3 data-id="heading-22">1. ES Module 的 __dirname 问题</h3>
<p>在 ES Module 里没有 <code>__dirname</code> 和 <code>__filename</code>，要这样获取：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>

<span class="hljs-keyword">const</span> __filename = <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>)
<span class="hljs-keyword">const</span> __dirname = path.<span class="hljs-title function_">dirname</span>(__filename)
</code></pre>
<p>我一开始直接用 <code>__dirname</code>，结果报错说未定义。查了文档才知道要用 <code>import.meta.url</code>。</p>
<h3 data-id="heading-23">2. Tailwind CSS v4 的配置变化</h3>
<p>v4 不再需要 <code>tailwind.config.js</code> 和 <code>postcss.config.js</code>，直接在 CSS 里引入就行：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">"tailwindcss"</span>;
</code></pre>
<p>然后在 <code>vite.config.js</code> 引入 Vite 插件：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> tailwindcss <span class="hljs-keyword">from</span> <span class="hljs-string">'@tailwindcss/vite'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">tailwindcss</span>()]
})
</code></pre>
<p>我一开始还按 v3 的方式创建配置文件，浪费了好长时间。</p>
<h3 data-id="heading-24">3. 正则表达式修改 vite.config.js</h3>
<p>用正则表达式修改配置文件的时候要特别小心：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 不好的写法（假设格式固定）</span>
content.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'plugins: ['</span>, <span class="hljs-string">'plugins: [tailwindcss(), '</span>)

<span class="hljs-comment">// 好的写法（考虑各种空格情况）</span>
content.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/plugins:\s*\[/</span>, <span class="hljs-string">'plugins: [tailwindcss(), '</span>)
</code></pre>
<p>因为不同人写代码的格式可能不一样，有人写 <code>plugins:[</code>，有人写 <code>plugins: [</code>。用正则的 <code>\s*</code> 可以匹配任意空格。</p>
<h2 data-id="heading-25">和官方工具的对比</h2>













































<table><thead><tr><th>特性</th><th>create-vite</th><th>mini-vite</th></tr></thead><tbody><tr><td>支持的框架</td><td>8+</td><td>2（Vue、React）</td></tr><tr><td>模板数量</td><td>18+</td><td>4</td></tr><tr><td>依赖数量</td><td>3</td><td>2</td></tr><tr><td>插件系统</td><td>✗</td><td>✓（ESLint、Tailwind、UnoCSS）</td></tr><tr><td>代码量</td><td>~500 行</td><td>~300 行</td></tr><tr><td>团队定制</td><td>困难</td><td>容易</td></tr><tr><td>学习难度</td><td>中等</td><td>简单</td></tr></tbody></table>
<p>官方工具功能更全面，适合生产环境。我这个更轻量、更灵活，适合学习和团队定制。</p>
<h2 data-id="heading-26">写在最后</h2>
<p>后续我会补充更多plugin，支持h5端不同机型适配、router和跨页面应用存储等通用功能
大家也可以尝试写一个自己的cli工具，无论是团队开发还是个人独立开发，我觉得都挺有用的，虽然现在ai很牛，有时候让它创建项目，也会出错，还得不断调试才能做好（吐槽一下）</p>
<p>emm 懦夫的味道...</p>
<hr/>
<h2 data-id="heading-27">参考资料</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Ftree%2Fmain%2Fpackages%2Fcreate-vite" target="_blank" title="https://github.com/vitejs/vite/tree/main/packages/create-vite" ref="nofollow noopener noreferrer">create-vite 源码</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fterkelg%2Fprompts" target="_blank" title="https://github.com/terkelg/prompts" ref="nofollow noopener noreferrer">prompts</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falexeyraspopov%2Fpicocolors" target="_blank" title="https://github.com/alexeyraspopov/picocolors" ref="nofollow noopener noreferrer">picocolors</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantfu%2Feslint-config" target="_blank" title="https://github.com/antfu/eslint-config" ref="nofollow noopener noreferrer">@antfu/eslint-config</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fblog%2Ftailwindcss-v4-alpha" target="_blank" title="https://tailwindcss.com/blog/tailwindcss-v4-alpha" ref="nofollow noopener noreferrer">Tailwind CSS v4</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Funocss.dev%2F" target="_blank" title="https://unocss.dev/" ref="nofollow noopener noreferrer">UnoCSS</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【底层机制】Android低内存管理机制深度解析]]></title>    <link>https://juejin.cn/post/7570901172527415331</link>    <guid>https://juejin.cn/post/7570901172527415331</guid>    <pubDate>2025-11-10T13:24:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570901172527415331" data-draft-id="7570909641682812968" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【底层机制】Android低内存管理机制深度解析"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2025-11-10T13:24:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="沐怡旸"/> <meta itemprop="url" content="https://juejin.cn/user/2875978146656750"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【底层机制】Android低内存管理机制深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2875978146656750/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    沐怡旸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T13:24:02.000Z" title="Mon Nov 10 2025 13:24:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、低内存管理架构概述</h2>
<h3 data-id="heading-1">1.1 系统级内存压力响应</h3>
<p>Android低内存管理是一个多层次、协同工作的系统，核心目标是在内存压力下维持系统响应性和稳定性。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/03b8018a7d404502ba3ebd625cdcf2c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rKQ5oCh5pe4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763385842&amp;x-signature=2EgAwvUn24hfcdDX6kDD4NMx3bE%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-2">二、低内存杀手（LMK）核心实现</h2>
<h3 data-id="heading-3">2.1 LMK驱动架构</h3>
<h4 data-id="heading-4">2.1.1 内核空间实现</h4>
<p>LMK作为Linux内核模块实现，主要组件包括：</p>
<p><strong>内存压力检测</strong>：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lmk_metrics</span> {</span>
    <span class="hljs-type">long</span> free_pages;           <span class="hljs-comment">// 系统空闲页面</span>
    <span class="hljs-type">long</span> file_cache;           <span class="hljs-comment">// 页面缓存大小</span>
    <span class="hljs-type">long</span> swap_used;            <span class="hljs-comment">// 交换空间使用</span>
    <span class="hljs-type">long</span> anon_pages;           <span class="hljs-comment">// 匿名页面数量</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone_watermarks</span> <span class="hljs-title">wm</span>;</span> <span class="hljs-comment">// 内存区域水位线</span>
};
</code></pre>
<p><strong>进程评分机制</strong>：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_score</span> {</span>
    <span class="hljs-type">pid_t</span> pid;                 <span class="hljs-comment">// 进程ID</span>
    <span class="hljs-type">int</span> oom_score_adj;         <span class="hljs-comment">// OOM调整分数</span>
    <span class="hljs-type">long</span> rss;                  <span class="hljs-comment">// 驻留内存大小</span>
    <span class="hljs-type">long</span> swap_usage;           <span class="hljs-comment">// 交换使用量</span>
    <span class="hljs-type">long</span> last_visible_time;    <span class="hljs-comment">// 最后可见时间</span>
    <span class="hljs-type">int</span> importance;            <span class="hljs-comment">// 进程重要性</span>
};
</code></pre>
<h4 data-id="heading-5">2.1.2 杀进程决策算法</h4>
<p>LMK使用综合评分系统选择目标进程：</p>
<p><strong>评分公式</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">score</span> = base_oom_score × memory_pressure × time_factor

其中：
<span class="hljs-attr">base_oom_score</span> = f(oom_score_adj, process_state)
<span class="hljs-attr">memory_pressure</span> = current_free_pages / low_memory_threshold
<span class="hljs-attr">time_factor</span> = time_since_last_visible / time_constant
</code></pre>
<p><strong>选择策略</strong>：</p>
<ul>
<li>优先选择高oom_score_adj的进程</li>
<li>考虑进程内存占用大小</li>
<li>平衡杀进程的成本与收益</li>
</ul>
<h3 data-id="heading-6">2.2 用户空间协作</h3>
<h4 data-id="heading-7">2.2.1 ActivityManagerService集成</h4>
<p>AMS维护进程状态并动态调整OOM分数：</p>
<p><strong>进程状态映射</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessRecord</span> {
    <span class="hljs-type">int</span> curAdj;          <span class="hljs-comment">// 当前OOM调整分数</span>
    <span class="hljs-type">int</span> setAdj;          <span class="hljs-comment">// 设置的OOM分数</span>
    ProcessState state;  <span class="hljs-comment">// 进程状态</span>
    <span class="hljs-type">boolean</span> foreground;  <span class="hljs-comment">// 是否前台</span>
    <span class="hljs-type">long</span> lastVisibleTime;<span class="hljs-comment">// 最后可见时间</span>
}
</code></pre>
<p><strong>动态分数调整</strong>：</p>
<ul>
<li>前台进程：0 (ADJ_MEM_FACTOR_NORMAL)</li>
<li>可见进程：100 (ADJ_MEM_FACTOR_VISIBLE)</li>
<li>服务进程：200-400 (基于服务重要性)</li>
<li>后台进程：600-900</li>
<li>缓存进程：900+</li>
</ul>
<h2 data-id="heading-8">三、内存压力检测与响应</h2>
<h3 data-id="heading-9">3.1 多级水位线监控</h3>
<h4 data-id="heading-10">3.1.1 内核水位线定义</h4>
<p>Linux内核定义了三层内存水位线：</p>
<p><strong>水位线计算</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">high_wmark</span> = total_pages × <span class="hljs-number">0.9</span>    // 开始回收缓存
<span class="hljs-attr">low_wmark</span> = total_pages × <span class="hljs-number">0.7</span>     // 积极回收
<span class="hljs-attr">min_wmark</span> = total_pages × <span class="hljs-number">0.5</span>     // 直接回收和OOM
</code></pre>
<h4 data-id="heading-11">3.1.2 Android扩展水位线</h4>
<p>Android在标准水位线基础上添加移动设备特定扩展：</p>
<p><strong>移动优化水位线</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">critical_wmark</span> = total_pages × <span class="hljs-number">0.3</span>    // 触发LMK
<span class="hljs-attr">super_critical</span> = total_pages × <span class="hljs-number">0.2</span>    // 激进LMK
<span class="hljs-attr">emergency_wmark</span> = total_pages × <span class="hljs-number">0.1</span>   // 系统稳定性措施
</code></pre>
<h3 data-id="heading-12">3.2 内存压力传播机制</h3>
<h4 data-id="heading-13">3.2.1 压力状态通知</h4>
<p><strong>vmpressure事件</strong>：</p>
<pre><code class="hljs language-c" lang="c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">vmpressure_level</span> {</span>
    VMPRESSURE_LOW,      <span class="hljs-comment">// 低压力</span>
    VMPRESSURE_MEDIUM,   <span class="hljs-comment">// 中等压力</span>
    VMPRESSURE_CRITICAL, <span class="hljs-comment">// 临界压力</span>
    VMPRESSULE_OOM       <span class="hljs-comment">// OOM状态</span>
};
</code></pre>
<p><strong>事件传递路径</strong>：
内核vmpressure → 用户空间lmkd → ActivityManagerService → 应用进程</p>
<h4 data-id="heading-14">3.2.2 分级响应策略</h4>
<p>基于压力级别实施不同强度的内存回收：</p>
<p><strong>低压力响应</strong>：</p>
<ul>
<li>后台进程压缩</li>
<li>缓存清理</li>
<li>温和的交换</li>
</ul>
<p><strong>中等压力响应</strong>：</p>
<ul>
<li>杀死部分后台进程</li>
<li>积极回收文件缓存</li>
<li>压缩匿名内存</li>
</ul>
<p><strong>临界压力响应</strong>：</p>
<ul>
<li>杀死可见进程之外的所有进程</li>
<li>强制内存压缩</li>
<li>系统服务降级</li>
</ul>
<h2 data-id="heading-15">四、进程生命周期管理</h2>
<h3 data-id="heading-16">4.1 进程状态机</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/799354e4b136464eb7ce112a75efe333~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rKQ5oCh5pe4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763385842&amp;x-signature=1bp13nVliHZAJyDntw1bR3%2Ftqds%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-17">4.2 重要性计算算法</h3>
<h4 data-id="heading-18">4.2.1 基础重要性分数</h4>
<p>基于进程包含的组件类型计算基础分数：</p>
<p><strong>组件权重</strong>：</p>
<ul>
<li>前台Activity：+100</li>
<li>可见Activity：+50</li>
<li>前台服务：+30</li>
<li>绑定服务：+20</li>
<li>内容提供者：+10</li>
<li>广播接收器：+5</li>
</ul>
<h4 data-id="heading-19">4.2.2 动态调整因素</h4>
<p><strong>用户交互因素</strong>：</p>
<ul>
<li>最近用户交互时间</li>
<li>交互频率和持续时间</li>
<li>用户显式重要性设置</li>
</ul>
<p><strong>系统策略因素</strong>：</p>
<ul>
<li>电源管理状态</li>
<li>热状态约束</li>
<li>系统负载水平</li>
</ul>
<h2 data-id="heading-20">五、内存回收策略</h2>
<h3 data-id="heading-21">5.1 分层回收机制</h3>
<h4 data-id="heading-22">5.1.1 应用层回收</h4>
<p><strong>主动内存释放</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// ComponentCallbacks2接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ComponentCallbacks2</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onTrimMemory</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>;  <span class="hljs-comment">// 内存修剪通知</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLowMemory</span><span class="hljs-params">()</span>;           <span class="hljs-comment">// 低内存通知</span>
}
</code></pre>
<p><strong>修剪级别</strong>：</p>
<ul>
<li>TRIM_MEMORY_COMPLETE：进程可能很快被杀死</li>
<li>TRIM_MEMORY_MODERATE：建议释放非关键资源</li>
<li>TRIM_MEMORY_BACKGROUND：释放容易重建的资源</li>
</ul>
<h4 data-id="heading-23">5.1.2 系统层回收</h4>
<p><strong>缓存管理</strong>：</p>
<ul>
<li>文件系统缓存清理</li>
<li>字体和资源缓存回收</li>
<li>ZRAM压缩内存释放</li>
</ul>
<p><strong>服务降级</strong>：</p>
<ul>
<li>减少后台服务运行频率</li>
<li>限制广播发送</li>
<li>推迟非紧急任务</li>
</ul>
<h3 data-id="heading-24">5.2 交换与压缩策略</h3>
<h4 data-id="heading-25">5.2.1 ZRAM交换优化</h4>
<p>Android使用压缩的RAM作为交换设备：</p>
<p><strong>压缩策略</strong>：</p>
<ul>
<li>匿名页面优先压缩</li>
<li>冷页面优先换出</li>
<li>保持热页面在物理内存</li>
</ul>
<p><strong>压缩算法选择</strong>：</p>
<ul>
<li>LZ4：快速压缩，适合交互场景</li>
<li>LZO：平衡压缩比和速度</li>
<li>ZSTD：高压缩比，适合后台任务</li>
</ul>
<h4 data-id="heading-26">5.2.2 KSM页面合并</h4>
<p>内核同页合并优化重复内存：</p>
<p><strong>合并策略</strong>：</p>
<ul>
<li>零页面优先合并</li>
<li>库代码页面合并</li>
<li>应用间共享资源合并</li>
</ul>
<h2 data-id="heading-27">六、自适应优化机制</h2>
<h3 data-id="heading-28">6.1 学习型内存管理</h3>
<h4 data-id="heading-29">6.1.1 使用模式分析</h4>
<p><strong>用户行为建模</strong>：</p>
<ul>
<li>应用使用频率和时长</li>
<li>内存访问模式识别</li>
<li>预测性内存预分配</li>
</ul>
<p><strong>自适应阈值调整</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">dynamic_threshold</span> = base_threshold × usage_factor × behavior_factor

<span class="hljs-attr">usage_factor</span> = f(historical_memory_usage)
<span class="hljs-attr">behavior_factor</span> = f(user_interaction_pattern)
</code></pre>
<h4 data-id="heading-30">6.1.2 预测性管理</h4>
<p><strong>内存需求预测</strong>：</p>
<ul>
<li>基于历史数据的应用启动预测</li>
<li>周期性任务的执行时间预测</li>
<li>用户工作负载模式识别</li>
</ul>
<h3 data-id="heading-31">6.2 设备特定优化</h3>
<h4 data-id="heading-32">6.2.1 内存容量适配</h4>
<p><strong>分级配置策略</strong>：</p>
<ul>
<li>小内存设备（2GB以下）：激进回收策略</li>
<li>中等内存设备（2-6GB）：平衡策略</li>
<li>大内存设备（6GB以上）：宽松策略</li>
</ul>
<h4 data-id="heading-33">6.2.2 硬件特性利用</h4>
<p><strong>内存架构优化</strong>：</p>
<ul>
<li>NUMA感知的内存分配</li>
<li>大页面支持</li>
<li>内存带宽管理</li>
</ul>
<h2 data-id="heading-34">七、系统稳定性保障</h2>
<h3 data-id="heading-35">7.1 防抖动机制</h3>
<h4 data-id="heading-36">7.1.1 杀进程频率限制</h4>
<p>防止过于频繁的进程杀死导致系统不稳定：</p>
<p><strong>时间窗口限制</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">if (time_since_last_kill &lt; min_kill_interval) {
    <span class="hljs-built_in">delay_kill_decision</span>();
}
</code></pre>
<p><strong>成本效益分析</strong>：</p>
<ul>
<li>评估杀进程的系统开销</li>
<li>考虑进程重启成本</li>
<li>平衡内存收益与性能损失</li>
</ul>
<h4 data-id="heading-37">7.1.2 关键进程保护</h4>
<p><strong>系统核心服务</strong>：</p>
<ul>
<li>System Server进程</li>
<li>输入法服务</li>
<li>电话服务</li>
<li>显示服务</li>
</ul>
<p><strong>保护机制</strong>：</p>
<ul>
<li>最低OOM调整分数</li>
<li>内存使用限制豁免</li>
<li>紧急情况特殊处理</li>
</ul>
<h3 data-id="heading-38">7.2 监控与诊断</h3>
<h4 data-id="heading-39">7.2.1 实时监控</h4>
<p><strong>性能指标收集</strong>：</p>
<ul>
<li>LMK触发频率和时机</li>
<li>进程杀死统计信息</li>
<li>内存压力持续时间</li>
<li>用户感知的卡顿情况</li>
</ul>
<h4 data-id="heading-40">7.2.2 问题诊断</h4>
<p><strong>内存泄漏检测</strong>：</p>
<ul>
<li>可疑的内存增长模式识别</li>
<li>引用链分析</li>
<li>泄漏模式分类</li>
</ul>
<h2 data-id="heading-41">技术总结</h2>
<p>Android低内存管理机制是一个复杂而精密的系统，通过多层次协作在有限的内存资源下维持系统性能和稳定性。其核心创新在于：</p>
<ol>
<li><strong>智能的进程重要性评估</strong>：基于用户交互和系统状态的动态评分</li>
<li><strong>分级的压力响应</strong>：从温和的资源回收到激进的进程杀死</li>
<li><strong>自适应的阈值调整</strong>：基于使用模式和设备特性的动态优化</li>
<li><strong>系统稳定性保障</strong>：防止过度回收和关键服务保护</li>
</ol>
<p>这套机制使得Android能够在各种内存约束条件下提供一致的用户体验，是移动操作系统内存管理的典范实现。随着设备内存容量的增长和用户需求的提升，低内存管理机制仍在持续演进，以更好地平衡性能、功耗和用户体验。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[InputConnection机制与跨进程文本操作的工程实践]]></title>    <link>https://juejin.cn/post/7570923924364853311</link>    <guid>https://juejin.cn/post/7570923924364853311</guid>    <pubDate>2025-11-10T13:26:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570923924364853311" data-draft-id="7571060853353824266" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="InputConnection机制与跨进程文本操作的工程实践"/> <meta itemprop="keywords" content="Android,Linux"/> <meta itemprop="datePublished" content="2025-11-10T13:26:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="WAsbry"/> <meta itemprop="url" content="https://juejin.cn/user/3413335797139511"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            InputConnection机制与跨进程文本操作的工程实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3413335797139511/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    WAsbry
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T13:26:16.000Z" title="Mon Nov 10 2025 13:26:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">InputConnection机制与跨进程文本操作的工程实践</h2>
<h3 data-id="heading-1">💡 本文精华</h3>
<ul>
<li><strong>承接前文</strong>：第一篇讲Binder通信，第二篇讲设计缺陷，本篇给出完整的工程解决方案</li>
<li><strong>核心需求</strong>：既保留数字键盘（inputType="number"），又避免字母输入导致数字丢失</li>
<li><strong>最佳方案</strong>：自定义InputConnection在<code>setComposingText()</code>层拦截非法字符，阻止进入delete-insert流程</li>
<li><strong>三种方案对比</strong>：InputConnection拦截（推荐⭐⭐⭐⭐⭐）、TextWatcher过滤（⭐⭐⭐）、自定义InputFilter（⭐⭐⭐⭐）</li>
<li><strong>价值</strong>：提供可直接使用的完整代码，分析方案优劣，指导工程实践</li>
</ul>
<hr/>
<h3 data-id="heading-2">一、需求分析与约束条件</h3>
<h4 data-id="heading-3">1.1 核心需求</h4>
<pre><code class="hljs language-markdown" lang="markdown">用户需求:
<span class="hljs-bullet">1.</span> 点击EditText时，弹出数字键盘（不是全键盘）
<span class="hljs-bullet">2.</span> 只允许输入数字字符
<span class="hljs-bullet">3.</span> 切换到字母键盘输入字母时，不应导致已有数字丢失

技术约束:
<span class="hljs-bullet">1.</span> 必须使用 android:inputType="number" (保证数字键盘)
<span class="hljs-bullet">2.</span> 不能修改Android框架代码
<span class="hljs-bullet">3.</span> 需要兼容主流输入法（百度、搜狗、讯飞等）
<span class="hljs-bullet">4.</span> 性能开销要小
</code></pre>
<h4 data-id="heading-4">1.2 问题回顾</h4>
<p><strong>前两篇已分析的根本原因</strong>：</p>
<pre><code class="hljs language-css" lang="css">输入法进程:
  ic.<span class="hljs-built_in">setComposingText</span>(<span class="hljs-string">"qq"</span>, <span class="hljs-number">1</span>)
  ↓ Binder IPC
应用进程:
  BaseInputConnection.<span class="hljs-built_in">replaceText</span>(<span class="hljs-string">"qq"</span>, <span class="hljs-number">1</span>, true)
  ↓
  <span class="hljs-number">1</span>. <span class="hljs-built_in">delete</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) → 成功（绕过InputFilter）
  <span class="hljs-number">2</span>. <span class="hljs-built_in">insert</span>(<span class="hljs-string">"qq"</span>) → 失败（被DigitsKeyListener拒绝）
  ↓
  结果: 数据丢失
</code></pre>
<p><strong>解决方向</strong>：</p>
<ul>
<li>在delete执行之前拦截</li>
<li>判断新文本是否合法</li>
<li>如果非法，不进入delete-insert流程</li>
</ul>
<hr/>
<h3 data-id="heading-5">二、解决方案一：InputConnection拦截（推荐⭐⭐⭐⭐⭐）</h3>
<h4 data-id="heading-6">2.1 核心思路</h4>
<pre><code class="hljs language-css" lang="css">原始流程（有Bug）:
<span class="hljs-built_in">setComposingText</span>(<span class="hljs-string">"qq"</span>)
  → <span class="hljs-built_in">replaceText</span>()
  → <span class="hljs-built_in">delete</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) ← 删除数字
  → <span class="hljs-built_in">insert</span>(<span class="hljs-string">"qq"</span>) ← 被拒绝
  → Bug!

优化后流程:
<span class="hljs-built_in">setComposingText</span>(<span class="hljs-string">"qq"</span>)
  → NumberInputConnectionWrapper.<span class="hljs-built_in">setComposingText</span>()
  → 检测到字母 <span class="hljs-string">'q'</span>
  → 调用 <span class="hljs-built_in">finishComposingText</span>() ← 直接完成组合，不执行delete-insert
  → 数字保持不变 ✓
</code></pre>
<h4 data-id="heading-7">2.2 完整实现代码</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecommendedNumberEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecommendedNumberEditText</span><span class="hljs-params">(Context context)</span> {
        <span class="hljs-built_in">super</span>(context);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecommendedNumberEditText</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> {
        <span class="hljs-built_in">super</span>(context, attrs);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecommendedNumberEditText</span><span class="hljs-params">(Context context, AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> {
        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> InputConnection <span class="hljs-title function_">onCreateInputConnection</span><span class="hljs-params">(EditorInfo outAttrs)</span> {
        <span class="hljs-comment">// 获取父类创建的InputConnection</span>
        <span class="hljs-type">InputConnection</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.onCreateInputConnection(outAttrs);
        <span class="hljs-keyword">if</span> (base == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-comment">// 包装成我们的自定义InputConnection</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberInputConnectionWrapper</span>(base, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-comment">/**
     * 自定义InputConnection包装类
     * 拦截setComposingText，检查是否包含非数字字符
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberInputConnectionWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputConnectionWrapper</span> {

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberInputConnectionWrapper</span><span class="hljs-params">(InputConnection target, <span class="hljs-type">boolean</span> mutable)</span> {
            <span class="hljs-built_in">super</span>(target, mutable);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
            <span class="hljs-comment">// 关键：在执行delete-insert之前检查</span>
            <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span> &amp;&amp; containsNonDigit(text)) {
                <span class="hljs-comment">// 包含非数字字符，直接完成组合（不执行delete-insert）</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.finishComposingText();
            }

            <span class="hljs-comment">// 纯数字或null，正常处理</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setComposingText(text, newCursorPosition);
        }

        <span class="hljs-comment">/**
         * 检查CharSequence是否包含非数字字符
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNonDigit</span><span class="hljs-params">(CharSequence text)</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; text.length(); i++) {
                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> text.charAt(i);
                <span class="hljs-keyword">if</span> (!Character.isDigit(c)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 发现非数字字符</span>
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 全部是数字</span>
        }
    }
}
</code></pre>
<h4 data-id="heading-8">2.3 使用方法</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- activity_main.xml --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">com.yourpackage.RecommendedNumberEditText</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/edit_number"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:hint</span>=<span class="hljs-string">"请输入数字"</span>
    <span class="hljs-attr">android:inputType</span>=<span class="hljs-string">"number"</span> /&gt;</span>
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// MainActivity.java</span>
<span class="hljs-type">RecommendedNumberEditText</span> <span class="hljs-variable">editText</span> <span class="hljs-operator">=</span> findViewById(R.id.edit_number);
<span class="hljs-comment">// 正常使用，无需额外代码</span>
</code></pre>
<h4 data-id="heading-9">2.4 方案优势</h4>

































<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td><strong>拦截时机早</strong></td><td>在delete之前拦截，从源头解决问题</td></tr><tr><td><strong>性能最优</strong></td><td>不执行delete-insert，避免无效操作</td></tr><tr><td><strong>对输入法透明</strong></td><td>返回true，输入法认为成功，不影响正常流程</td></tr><tr><td><strong>不影响正常输入</strong></td><td>数字输入不受影响，仍走原有逻辑</td></tr><tr><td><strong>代码简洁</strong></td><td>只需重写一个方法</td></tr><tr><td><strong>数字键盘保留</strong></td><td>inputType="number"保证数字键盘弹出</td></tr></tbody></table>
<h4 data-id="heading-10">2.5 工作流程图</h4>
<pre><code class="hljs language-css" lang="css">用户操作：
  输入数字 "<span class="hljs-number">123456</span>"
  ↓
  切换到字母键盘
  ↓
  点击 '<span class="hljs-selector-tag">q</span>'

输入法进程:
  ic.<span class="hljs-built_in">setComposingText</span>(<span class="hljs-string">"q"</span>, <span class="hljs-number">1</span>)
  ↓ Binder IPC

应用进程:
  NumberInputConnectionWrapper.<span class="hljs-built_in">setComposingText</span>(<span class="hljs-string">"q"</span>, <span class="hljs-number">1</span>)
  ↓
  <span class="hljs-built_in">containsNonDigit</span>(<span class="hljs-string">"q"</span>) → true (检测到字母)
  ↓
  调用 <span class="hljs-built_in">finishComposingText</span>()
  ↓
  BaseInputConnection.<span class="hljs-built_in">finishComposingText</span>()
    - 移除COMPOSING Span
    - 不执行delete
    - 不执行insert
  ↓
  返回 true
  ↓
  内容保持 <span class="hljs-string">"123456"</span> ✓

继续点击 <span class="hljs-string">'q'</span>:
  同样流程，每次都调用 <span class="hljs-built_in">finishComposingText</span>()
  内容始终保持 <span class="hljs-string">"123456"</span> ✓
</code></pre>
<hr/>
<h3 data-id="heading-11">三、解决方案二：TextWatcher过滤（⭐⭐⭐）</h3>
<h4 data-id="heading-12">3.1 核心思路</h4>
<pre><code class="hljs">原理：
不依赖InputFilter，而是监听文本变化
在文本改变后，过滤掉非数字字符
</code></pre>
<h4 data-id="heading-13">3.2 完整实现代码</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleNumberEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isFiltering</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 防止递归</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleNumberEditText</span><span class="hljs-params">(Context context)</span> {
        <span class="hljs-built_in">super</span>(context);
        init();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleNumberEditText</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> {
        <span class="hljs-built_in">super</span>(context, attrs);
        init();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleNumberEditText</span><span class="hljs-params">(Context context, AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> {
        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);
        init();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 不设置inputType为number，避免DigitsKeyListener</span>
        <span class="hljs-comment">// 但会丢失数字键盘，需要手动设置</span>
        setRawInputType(InputType.TYPE_CLASS_NUMBER);

        addTextChangedListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextWatcher</span>() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeTextChanged</span><span class="hljs-params">(CharSequence s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> count, <span class="hljs-type">int</span> after)</span> {
                <span class="hljs-comment">// 不需要处理</span>
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onTextChanged</span><span class="hljs-params">(CharSequence s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> before, <span class="hljs-type">int</span> count)</span> {
                <span class="hljs-comment">// 不需要处理</span>
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterTextChanged</span><span class="hljs-params">(Editable s)</span> {
                <span class="hljs-keyword">if</span> (isFiltering) {
                    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 避免递归</span>
                }

                <span class="hljs-comment">// 过滤掉非数字字符</span>
                <span class="hljs-type">String</span> <span class="hljs-variable">filtered</span> <span class="hljs-operator">=</span> s.toString().replaceAll(<span class="hljs-string">"[^0-9]"</span>, <span class="hljs-string">""</span>);

                <span class="hljs-keyword">if</span> (!s.toString().equals(filtered)) {
                    isFiltering = <span class="hljs-literal">true</span>;

                    <span class="hljs-comment">// 保存光标位置</span>
                    <span class="hljs-type">int</span> <span class="hljs-variable">cursorPos</span> <span class="hljs-operator">=</span> getSelectionStart();
                    <span class="hljs-type">int</span> <span class="hljs-variable">lengthBefore</span> <span class="hljs-operator">=</span> s.length();

                    <span class="hljs-comment">// 替换为过滤后的内容</span>
                    setText(filtered);

                    <span class="hljs-comment">// 调整光标位置</span>
                    <span class="hljs-type">int</span> <span class="hljs-variable">lengthAfter</span> <span class="hljs-operator">=</span> filtered.length();
                    <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> lengthBefore - lengthAfter;
                    <span class="hljs-type">int</span> <span class="hljs-variable">newCursorPos</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, cursorPos - diff);
                    setSelection(Math.min(newCursorPos, filtered.length()));

                    isFiltering = <span class="hljs-literal">false</span>;
                }
            }
        });
    }
}
</code></pre>
<h4 data-id="heading-14">3.3 方案优劣</h4>





























<table><thead><tr><th>维度</th><th>评价</th></tr></thead><tbody><tr><td><strong>优点</strong></td><td>实现简单，易于理解</td></tr><tr><td><strong>优点</strong></td><td>不依赖InputConnection，逻辑独立</td></tr><tr><td><strong>缺点</strong></td><td>需要额外的setText操作，性能略差</td></tr><tr><td><strong>缺点</strong></td><td>光标位置处理复杂</td></tr><tr><td><strong>缺点</strong></td><td>会触发额外的TextWatcher回调</td></tr></tbody></table>
<h4 data-id="heading-15">3.4 性能对比</h4>
<pre><code class="hljs language-css" lang="css">方案一（InputConnection拦截）:
  <span class="hljs-built_in">setComposingText</span>(<span class="hljs-string">"qq"</span>)
    → 检测到字母
    → <span class="hljs-built_in">finishComposingText</span>()
    → <span class="hljs-number">1</span>次操作

方案二（TextWatcher）:
  <span class="hljs-built_in">setComposingText</span>(<span class="hljs-string">"qq"</span>)
    → <span class="hljs-built_in">delete</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) → 删除<span class="hljs-string">'6'</span>
    → <span class="hljs-built_in">insert</span>(<span class="hljs-string">"qq"</span>) → 被拒绝
    → afterTextChanged触发
    → <span class="hljs-built_in">setText</span>(<span class="hljs-string">"123456"</span>) → 恢复
    → <span class="hljs-number">3</span>次操作

性能差距：方案二约<span class="hljs-number">3</span>倍于方案一
</code></pre>
<hr/>
<h3 data-id="heading-16">四、解决方案三：自定义InputFilter（⭐⭐⭐⭐）</h3>
<h4 data-id="heading-17">4.1 核心思路</h4>
<pre><code class="hljs language-sql" lang="sql">原理：
不仅拦截<span class="hljs-keyword">insert</span>，也拦截<span class="hljs-keyword">delete</span>
通过判断source是否为空来区分操作类型
</code></pre>
<h4 data-id="heading-18">4.2 完整实现代码</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeNumberEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SafeNumberEditText</span><span class="hljs-params">(Context context)</span> {
        <span class="hljs-built_in">super</span>(context);
        init();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SafeNumberEditText</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> {
        <span class="hljs-built_in">super</span>(context, attrs);
        init();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SafeNumberEditText</span><span class="hljs-params">(Context context, AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> {
        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);
        init();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 设置自定义Filter，替换系统的DigitsKeyListener</span>
        setFilters(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputFilter</span>[]{<span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeNumberInputFilter</span>()});
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> InputConnection <span class="hljs-title function_">onCreateInputConnection</span><span class="hljs-params">(EditorInfo outAttrs)</span> {
        <span class="hljs-type">InputConnection</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.onCreateInputConnection(outAttrs);
        <span class="hljs-keyword">if</span> (base == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-comment">// 同时使用InputConnection拦截（双重保护）</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeInputConnectionWrapper</span>(base, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-comment">/**
     * 自定义InputFilter
     * 拦截非数字字符的插入
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeNumberInputFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InputFilter</span> {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> CharSequence <span class="hljs-title function_">filter</span><span class="hljs-params">(CharSequence source, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end,
                                   Spanned dest, <span class="hljs-type">int</span> dstart, <span class="hljs-type">int</span> dend)</span> {
            <span class="hljs-comment">// 过滤掉非数字字符</span>
            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">filtered</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i++) {
                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> source.charAt(i);
                <span class="hljs-keyword">if</span> (Character.isDigit(c)) {
                    filtered.append(c);
                }
            }

            <span class="hljs-comment">// 如果全部被过滤掉，返回空字符串</span>
            <span class="hljs-keyword">if</span> (filtered.length() == <span class="hljs-number">0</span> &amp;&amp; end &gt; start) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
            }

            <span class="hljs-comment">// 如果有字符被过滤掉，返回过滤后的内容</span>
            <span class="hljs-keyword">if</span> (filtered.length() &lt; (end - start)) {
                <span class="hljs-keyword">return</span> filtered.toString();
            }

            <span class="hljs-comment">// 全部合法，返回null（接受原始内容）</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }

    <span class="hljs-comment">/**
     * InputConnection包装类
     * 作为第二层防护
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeInputConnectionWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputConnectionWrapper</span> {

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SafeInputConnectionWrapper</span><span class="hljs-params">(InputConnection target, <span class="hljs-type">boolean</span> mutable)</span> {
            <span class="hljs-built_in">super</span>(target, mutable);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
            <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span> &amp;&amp; containsNonDigit(text)) {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.finishComposingText();
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setComposingText(text, newCursorPosition);
        }

        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNonDigit</span><span class="hljs-params">(CharSequence text)</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; text.length(); i++) {
                <span class="hljs-keyword">if</span> (!Character.isDigit(text.charAt(i))) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<h4 data-id="heading-19">4.3 方案特点</h4>

























<table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td><strong>双重保护</strong></td><td>InputFilter + InputConnection两层拦截</td></tr><tr><td><strong>灵活性高</strong></td><td>可以自定义过滤规则（如允许小数点）</td></tr><tr><td><strong>兼容性好</strong></td><td>适配各种输入场景</td></tr><tr><td><strong>代码复杂</strong></td><td>需要同时实现Filter和Wrapper</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-20">五、三种方案对比与选型指南</h3>
<h4 data-id="heading-21">5.1 全面对比</h4>





















































<table><thead><tr><th>维度</th><th>方案一：InputConnection</th><th>方案二：TextWatcher</th><th>方案三：自定义Filter</th></tr></thead><tbody><tr><td><strong>实现复杂度</strong></td><td>⭐⭐ (简单)</td><td>⭐ (最简单)</td><td>⭐⭐⭐⭐ (复杂)</td></tr><tr><td><strong>性能</strong></td><td>⭐⭐⭐⭐⭐ (最优)</td><td>⭐⭐⭐ (一般)</td><td>⭐⭐⭐⭐ (好)</td></tr><tr><td><strong>拦截时机</strong></td><td>早（delete之前）</td><td>晚（文本已改变）</td><td>早（但有局限）</td></tr><tr><td><strong>数字键盘</strong></td><td>✓ 自动</td><td>✓ 手动设置</td><td>✓ 自动</td></tr><tr><td><strong>光标处理</strong></td><td>✓ 自动</td><td>✗ 需手动</td><td>✓ 自动</td></tr><tr><td><strong>代码量</strong></td><td>~40行</td><td>~60行</td><td>~80行</td></tr><tr><td><strong>推荐度</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐</td></tr></tbody></table>
<h4 data-id="heading-22">5.2 选型建议</h4>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">场景1: 普通数字输入框</span>
  推荐: 方案一（InputConnection拦截）
  理由: 性能最优，代码最简洁

<span class="hljs-section">场景2: 需要自定义过滤规则（如电话号码：数字 + '-'）</span>
  推荐: 方案三（自定义Filter + InputConnection）
  理由: 灵活性高，可自定义allowed字符集

<span class="hljs-section">场景3: 快速原型开发</span>
  推荐: 方案二（TextWatcher）
  理由: 最简单，快速实现

<span class="hljs-section">场景4: 高性能要求（如大量EditText）</span>
  推荐: 方案一（InputConnection拦截）
  理由: 性能开销最小

<span class="hljs-section">场景5: 复杂输入验证（如金额：数字 + 小数点，最多2位小数）</span>
  推荐: 方案三（自定义Filter）
  理由: 可以在filter()中实现复杂规则
</code></pre>
<h4 data-id="heading-23">5.3 实际项目中的使用</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 示例：金额输入框（允许数字和小数点，最多2位小数）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MoneyEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> InputConnection <span class="hljs-title function_">onCreateInputConnection</span><span class="hljs-params">(EditorInfo outAttrs)</span> {
        <span class="hljs-type">InputConnection</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.onCreateInputConnection(outAttrs);
        <span class="hljs-keyword">if</span> (base == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MoneyInputConnectionWrapper</span>(base, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MoneyInputConnectionWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputConnectionWrapper</span> {

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MoneyInputConnectionWrapper</span><span class="hljs-params">(InputConnection target, <span class="hljs-type">boolean</span> mutable)</span> {
            <span class="hljs-built_in">super</span>(target, mutable);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
            <span class="hljs-comment">// 检查是否符合金额格式</span>
            <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span> &amp;&amp; !isValidMoneyInput(text)) {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.finishComposingText();
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setComposingText(text, newCursorPosition);
        }

        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidMoneyInput</span><span class="hljs-params">(CharSequence text)</span> {
            <span class="hljs-comment">// 允许：数字、小数点</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> text.toString();
            <span class="hljs-comment">// 简单验证：只包含[0-9.]</span>
            <span class="hljs-keyword">return</span> str.matches(<span class="hljs-string">"[0-9.]*"</span>);
        }
    }

    <span class="hljs-comment">// 可以配合InputFilter做更复杂的验证（如最多2位小数）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MoneyInputFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InputFilter</span> {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> CharSequence <span class="hljs-title function_">filter</span><span class="hljs-params">(CharSequence source, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end,
                                   Spanned dest, <span class="hljs-type">int</span> dstart, <span class="hljs-type">int</span> dend)</span> {
            <span class="hljs-comment">// 组合后的完整文本</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">beforeInsert</span> <span class="hljs-operator">=</span> dest.subSequence(<span class="hljs-number">0</span>, dstart).toString();
            <span class="hljs-type">String</span> <span class="hljs-variable">afterInsert</span> <span class="hljs-operator">=</span> dest.subSequence(dend, dest.length()).toString();
            <span class="hljs-type">String</span> <span class="hljs-variable">newText</span> <span class="hljs-operator">=</span> beforeInsert + source.subSequence(start, end) + afterInsert;

            <span class="hljs-comment">// 验证：最多一个小数点</span>
            <span class="hljs-keyword">if</span> (newText.indexOf(<span class="hljs-string">'.'</span>) != newText.lastIndexOf(<span class="hljs-string">'.'</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>; <span class="hljs-comment">// 拒绝（多个小数点）</span>
            }

            <span class="hljs-comment">// 验证：小数点后最多2位</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">dotIndex</span> <span class="hljs-operator">=</span> newText.indexOf(<span class="hljs-string">'.'</span>);
            <span class="hljs-keyword">if</span> (dotIndex != -<span class="hljs-number">1</span> &amp;&amp; newText.length() - dotIndex &gt; <span class="hljs-number">3</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>; <span class="hljs-comment">// 拒绝（超过2位小数）</span>
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 接受</span>
        }
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-24">六、工程实践的最佳实践</h3>
<h4 data-id="heading-25">6.1 性能监控</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitoredNumberEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> InputConnection <span class="hljs-title function_">onCreateInputConnection</span><span class="hljs-params">(EditorInfo outAttrs)</span> {
        <span class="hljs-type">InputConnection</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.onCreateInputConnection(outAttrs);
        <span class="hljs-keyword">if</span> (base == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonitoredInputConnectionWrapper</span>(base, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitoredInputConnectionWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputConnectionWrapper</span> {

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MonitoredInputConnectionWrapper</span><span class="hljs-params">(InputConnection target, <span class="hljs-type">boolean</span> mutable)</span> {
            <span class="hljs-built_in">super</span>(target, mutable);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
            <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();

            <span class="hljs-type">boolean</span> result;
            <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span> &amp;&amp; containsNonDigit(text)) {
                result = <span class="hljs-built_in">super</span>.finishComposingText();
            } <span class="hljs-keyword">else</span> {
                result = <span class="hljs-built_in">super</span>.setComposingText(text, newCursorPosition);
            }

            <span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;
            <span class="hljs-keyword">if</span> (duration &gt; <span class="hljs-number">1_000_000</span>) { <span class="hljs-comment">// 超过1ms</span>
                Log.w(<span class="hljs-string">"InputMonitor"</span>, <span class="hljs-string">"setComposingText slow: "</span> + duration / <span class="hljs-number">1_000_000.0</span> + <span class="hljs-string">"ms"</span>);
            }

            <span class="hljs-keyword">return</span> result;
        }

        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNonDigit</span><span class="hljs-params">(CharSequence text)</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; text.length(); i++) {
                <span class="hljs-keyword">if</span> (!Character.isDigit(text.charAt(i))) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<h4 data-id="heading-26">6.2 日志调试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugNumberEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">"DebugNumberEditText"</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> InputConnection <span class="hljs-title function_">onCreateInputConnection</span><span class="hljs-params">(EditorInfo outAttrs)</span> {
        <span class="hljs-type">InputConnection</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.onCreateInputConnection(outAttrs);
        <span class="hljs-keyword">if</span> (base == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugInputConnectionWrapper</span>(base, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugInputConnectionWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputConnectionWrapper</span> {

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DebugInputConnectionWrapper</span><span class="hljs-params">(InputConnection target, <span class="hljs-type">boolean</span> mutable)</span> {
            <span class="hljs-built_in">super</span>(target, mutable);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
            Log.d(TAG, <span class="hljs-string">"setComposingText: text='"</span> + text + <span class="hljs-string">"', cursor="</span> + newCursorPosition);

            <span class="hljs-type">boolean</span> <span class="hljs-variable">hasNonDigit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; text.length(); i++) {
                    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> text.charAt(i);
                    <span class="hljs-keyword">if</span> (!Character.isDigit(c)) {
                        hasNonDigit = <span class="hljs-literal">true</span>;
                        Log.w(TAG, <span class="hljs-string">"  Detected non-digit: '"</span> + c + <span class="hljs-string">"' at index "</span> + i);
                    }
                }
            }

            <span class="hljs-type">boolean</span> result;
            <span class="hljs-keyword">if</span> (hasNonDigit) {
                Log.d(TAG, <span class="hljs-string">"  Action: finishComposingText() (rejecting non-digit input)"</span>);
                result = <span class="hljs-built_in">super</span>.finishComposingText();
            } <span class="hljs-keyword">else</span> {
                Log.d(TAG, <span class="hljs-string">"  Action: setComposingText() (accepting digit input)"</span>);
                result = <span class="hljs-built_in">super</span>.setComposingText(text, newCursorPosition);
            }

            Log.d(TAG, <span class="hljs-string">"  Result: "</span> + result);
            <span class="hljs-keyword">return</span> result;
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">commitText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
            Log.d(TAG, <span class="hljs-string">"commitText: text='"</span> + text + <span class="hljs-string">"', cursor="</span> + newCursorPosition);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.commitText(text, newCursorPosition);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">finishComposingText</span><span class="hljs-params">()</span> {
            Log.d(TAG, <span class="hljs-string">"finishComposingText"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.finishComposingText();
        }
    }
}
</code></pre>
<h4 data-id="heading-27">6.3 单元测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RunWith(RobolectricTestRunner.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberEditTextTest</span> {

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDigitInput</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 测试正常数字输入</span>
        <span class="hljs-type">RecommendedNumberEditText</span> <span class="hljs-variable">editText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecommendedNumberEditText</span>(ApplicationProvider.getApplicationContext());
        editText.setText(<span class="hljs-string">"123"</span>);

        <span class="hljs-type">InputConnection</span> <span class="hljs-variable">ic</span> <span class="hljs-operator">=</span> editText.onCreateInputConnection(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EditorInfo</span>());
        ic.setComposingText(<span class="hljs-string">"456"</span>, <span class="hljs-number">1</span>);

        assertEquals(<span class="hljs-string">"123456"</span>, editText.getText().toString());
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLetterInput</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 测试字母输入（应该被拒绝）</span>
        <span class="hljs-type">RecommendedNumberEditText</span> <span class="hljs-variable">editText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecommendedNumberEditText</span>(ApplicationProvider.getApplicationContext());
        editText.setText(<span class="hljs-string">"123"</span>);

        <span class="hljs-type">InputConnection</span> <span class="hljs-variable">ic</span> <span class="hljs-operator">=</span> editText.onCreateInputConnection(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EditorInfo</span>());
        ic.setComposingText(<span class="hljs-string">"abc"</span>, <span class="hljs-number">1</span>);

        <span class="hljs-comment">// 内容不应该变化</span>
        assertEquals(<span class="hljs-string">"123"</span>, editText.getText().toString());
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMixedInput</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 测试混合输入</span>
        <span class="hljs-type">RecommendedNumberEditText</span> <span class="hljs-variable">editText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecommendedNumberEditText</span>(ApplicationProvider.getApplicationContext());
        editText.setText(<span class="hljs-string">"123"</span>);

        <span class="hljs-type">InputConnection</span> <span class="hljs-variable">ic</span> <span class="hljs-operator">=</span> editText.onCreateInputConnection(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EditorInfo</span>());
        ic.setComposingText(<span class="hljs-string">"4a5"</span>, <span class="hljs-number">1</span>);

        <span class="hljs-comment">// 包含字母，应该被拒绝</span>
        assertEquals(<span class="hljs-string">"123"</span>, editText.getText().toString());
    }
}
</code></pre>
<h4 data-id="heading-28">6.4 兼容性测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 测试不同输入法的兼容性
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IMECompatibilityTest</span> {

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBaiduIME</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 模拟百度输入法的行为</span>
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSogouIME</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 模拟搜狗输入法的行为</span>
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGboard</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 模拟Google Gboard的行为</span>
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-29">七、常见问题与解答</h3>
<h4 data-id="heading-30">7.1 为什么不直接去掉inputType="number"？</h4>
<p><strong>问题</strong>：去掉inputType后，不会有Bug，为什么不这样做？</p>
<p><strong>解答</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">去掉 <span class="hljs-attr">inputType</span>=<span class="hljs-string">"number"</span> 的后果:
1. 弹出全键盘（而不是数字键盘）
2. 用户体验变差（输入数字需要切换键盘）
3. 无法使用系统的数字键盘优化

保留 <span class="hljs-attr">inputType</span>=<span class="hljs-string">"number"</span> + InputConnection拦截:
1. 保留数字键盘（用户体验好）
2. 避免数据丢失（技术正确）
3. 最佳实践
</code></pre>
<h4 data-id="heading-31">7.2 为什么调用finishComposingText()？</h4>
<p><strong>问题</strong>：为什么不直接return false？</p>
<p><strong>解答</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 错误做法</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
    <span class="hljs-keyword">if</span> (containsNonDigit(text)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// ✗ 输入法会认为失败，可能重试或报错</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setComposingText(text, newCursorPosition);
}

<span class="hljs-comment">// 正确做法</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
    <span class="hljs-keyword">if</span> (containsNonDigit(text)) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.finishComposingText(); <span class="hljs-comment">// ✓ 告诉输入法"组合已完成"</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setComposingText(text, newCursorPosition);
}
</code></pre>
<p><strong>原因</strong>：</p>
<ul>
<li><code>finishComposingText()</code> 是合法的操作，输入法会正常处理</li>
<li>返回 <code>false</code> 表示操作失败，输入法可能出现异常行为</li>
<li><code>finishComposingText()</code> 会清除COMPOSING Span，避免后续问题</li>
</ul>
<h4 data-id="heading-32">7.3 为什么不用setFilters完全替代？</h4>
<p><strong>问题</strong>：为什么不只用InputFilter，还要用InputConnection？</p>
<p><strong>解答</strong>：</p>
<pre><code class="hljs language-markdown" lang="markdown">单独使用 InputFilter 的问题:
<span class="hljs-bullet">1.</span> 无法阻止delete操作（delete绕过Filter）
<span class="hljs-bullet">2.</span> 仍会触发Bug

单独使用 InputConnection 的优势:
<span class="hljs-bullet">1.</span> 拦截时机早（delete之前）
<span class="hljs-bullet">2.</span> 从源头解决问题

最佳实践:
  InputConnection拦截为主（方案一）
  或 InputFilter + InputConnection双重保护（方案三）
</code></pre>
<h4 data-id="heading-33">7.4 如何支持小数点？</h4>
<p><strong>扩展方案</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidNumberInput</span><span class="hljs-params">(CharSequence text)</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; text.length(); i++) {
        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> text.charAt(i);
        <span class="hljs-comment">// 允许数字和小数点</span>
        <span class="hljs-keyword">if</span> (!Character.isDigit(c) &amp;&amp; c != <span class="hljs-string">'.'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
    <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span> &amp;&amp; !isValidNumberInput(text)) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.finishComposingText();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setComposingText(text, newCursorPosition);
}

<span class="hljs-comment">// 同时设置inputType</span>
setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
</code></pre>
<hr/>
<h3 data-id="heading-34">八、总结：从理论到实践的完整链路</h3>
<h4 data-id="heading-35">8.1 三篇文章的知识链</h4>
<pre><code class="hljs language-sql" lang="sql">第一篇：Binder通信机制
  ├─ 三进程架构
  ├─ AIDL接口定义
  ├─ Stub<span class="hljs-operator">/</span>Proxy实现
  ├─ 线程切换
  └─ 信息不对称
       ↓ 为什么输入法不知道实际结果

第二篇：文本编辑设计缺陷
  ├─ InputFilter接口局限
  ├─ <span class="hljs-keyword">delete</span>绕过<span class="hljs-keyword">Filter</span>
  ├─ replaceText先<span class="hljs-keyword">delete</span>后<span class="hljs-keyword">insert</span>
  ├─ Span范围异常扩展
  └─ 不对称的控制权
       ↓ 为什么数字会被删除

第三篇（本文）：工程解决方案
  ├─ InputConnection拦截（推荐）
  ├─ TextWatcher过滤（简单）
  ├─ 自定义InputFilter（灵活）
  ├─ 三种方案对比
  ├─ 选型指南
  ├─ 最佳实践
  └─ 完整代码
       ↓ 如何在实际项目中解决
</code></pre>
<h4 data-id="heading-36">8.2 最佳实践总结</h4>






























<table><thead><tr><th>场景</th><th>推荐方案</th><th>核心代码</th></tr></thead><tbody><tr><td><strong>普通数字输入</strong></td><td>InputConnection拦截</td><td><code>finishComposingText()</code></td></tr><tr><td><strong>自定义规则</strong></td><td>自定义Filter + IC</td><td><code>filter()</code> + <code>finishComposingText()</code></td></tr><tr><td><strong>快速开发</strong></td><td>TextWatcher</td><td><code>afterTextChanged()</code> + <code>setText()</code></td></tr><tr><td><strong>高性能</strong></td><td>InputConnection拦截</td><td>避免多余操作</td></tr></tbody></table>
<h4 data-id="heading-37">8.3 核心要点</h4>
<pre><code class="hljs language-markdown" lang="markdown">关键设计决策:
<span class="hljs-bullet">1.</span> 保留 inputType="number" （数字键盘）
<span class="hljs-bullet">2.</span> 重写 onCreateInputConnection() （拦截入口）
<span class="hljs-bullet">3.</span> 包装 InputConnectionWrapper （扩展功能）
<span class="hljs-bullet">4.</span> 拦截 setComposingText() （关键方法）
<span class="hljs-bullet">5.</span> 调用 finishComposingText() （正确处理）

为什么这样设计:
<span class="hljs-bullet">1.</span> 用户体验：数字键盘更方便
<span class="hljs-bullet">2.</span> 性能优化：拦截早，开销小
<span class="hljs-bullet">3.</span> 兼容性好：对输入法透明
<span class="hljs-bullet">4.</span> 代码简洁：只需40行代码
<span class="hljs-bullet">5.</span> 易于维护：逻辑清晰
</code></pre>
<h4 data-id="heading-38">8.4 延伸应用</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 可以扩展到其他场景:</span>

<span class="hljs-comment">// 1. 手机号输入（数字 + 空格/横线）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumberEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 2. 邮箱输入（限制特殊字符）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 3. 用户名输入（字母 + 数字 + 下划线）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsernameEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 4. 密码输入（增强安全）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurePasswordEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-39">九、完整示例项目结构</h3>
<pre><code class="hljs language-css" lang="css">app/<span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span>/java/com/yourpackage/
├─ widget/
│  ├─ RecommendedNumberEditText<span class="hljs-selector-class">.java</span>   ← 方案一（推荐）
│  ├─ SimpleNumberEditText<span class="hljs-selector-class">.java</span>        ← 方案二
│  ├─ SafeNumberEditText<span class="hljs-selector-class">.java</span>          ← 方案三
│  ├─ MoneyEditText<span class="hljs-selector-class">.java</span>               ← 扩展：金额输入
│  ├─ PhoneNumberEditText<span class="hljs-selector-class">.java</span>         ← 扩展：电话输入
│  └─ DebugNumberEditText<span class="hljs-selector-class">.java</span>         ← 调试版本
│
├─ utils/
│  └─ InputValidationUtils<span class="hljs-selector-class">.java</span>        ← 通用验证工具
│
└─ MainActivity<span class="hljs-selector-class">.java</span>

app/<span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span>/res/layout/
└─ activity_main<span class="hljs-selector-class">.xml</span>

app/<span class="hljs-attribute">src</span>/test/java/com/yourpackage/
└─ NumberEditTextTest<span class="hljs-selector-class">.java</span>             ← 单元测试
</code></pre>
<hr/>
<h3 data-id="heading-40">参考资料</h3>
<ol>
<li>Android源码：<code>frameworks/base/core/java/android/view/inputmethod/InputConnectionWrapper.java</code></li>
<li>官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fview%2Finputmethod%2FInputConnectionWrapper" target="_blank" title="https://developer.android.com/reference/android/view/inputmethod/InputConnectionWrapper" ref="nofollow noopener noreferrer">InputConnectionWrapper</a></li>
<li>官方文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fview%2Finputmethod%2FInputConnection" target="_blank" title="https://developer.android.com/reference/android/view/inputmethod/InputConnection" ref="nofollow noopener noreferrer">InputConnection</a></li>
<li>本系列前两篇：
<ul>
<li>第一篇：《Android输入法框架的Binder通信机制剖析》</li>
<li>第二篇：《从一个Bug看Android文本编辑的设计缺陷》</li>
</ul>
</li>
</ol>
<hr/>
<h3 data-id="heading-41">附录：完整可运行的示例代码</h3>
<p><strong>RecommendedNumberEditText.java</strong>（直接复制可用）：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.yourpackage.widget;

<span class="hljs-keyword">import</span> android.content.Context;
<span class="hljs-keyword">import</span> android.util.AttributeSet;
<span class="hljs-keyword">import</span> android.view.inputmethod.EditorInfo;
<span class="hljs-keyword">import</span> android.view.inputmethod.InputConnection;
<span class="hljs-keyword">import</span> android.view.inputmethod.InputConnectionWrapper;
<span class="hljs-keyword">import</span> androidx.appcompat.widget.AppCompatEditText;

<span class="hljs-comment">/**
 * 推荐的数字输入框实现
 * 解决 inputType="number" 时，切换字母键盘导致数字丢失的问题
 *
 * 使用方法:
 * &lt;com.yourpackage.widget.RecommendedNumberEditText
 *     android:inputType="number"
 *     ... /&gt;
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecommendedNumberEditText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatEditText</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecommendedNumberEditText</span><span class="hljs-params">(Context context)</span> {
        <span class="hljs-built_in">super</span>(context);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecommendedNumberEditText</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> {
        <span class="hljs-built_in">super</span>(context, attrs);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecommendedNumberEditText</span><span class="hljs-params">(Context context, AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> {
        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> InputConnection <span class="hljs-title function_">onCreateInputConnection</span><span class="hljs-params">(EditorInfo outAttrs)</span> {
        <span class="hljs-type">InputConnection</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.onCreateInputConnection(outAttrs);
        <span class="hljs-keyword">if</span> (base == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberInputConnectionWrapper</span>(base, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-comment">/**
     * 自定义InputConnection包装类
     * 拦截setComposingText，检查是否包含非数字字符
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberInputConnectionWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputConnectionWrapper</span> {

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberInputConnectionWrapper</span><span class="hljs-params">(InputConnection target, <span class="hljs-type">boolean</span> mutable)</span> {
            <span class="hljs-built_in">super</span>(target, mutable);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setComposingText</span><span class="hljs-params">(CharSequence text, <span class="hljs-type">int</span> newCursorPosition)</span> {
            <span class="hljs-keyword">if</span> (text != <span class="hljs-literal">null</span> &amp;&amp; containsNonDigit(text)) {
                <span class="hljs-comment">// 包含非数字字符，直接完成组合（不执行delete-insert）</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.finishComposingText();
            }
            <span class="hljs-comment">// 纯数字或null，正常处理</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.setComposingText(text, newCursorPosition);
        }

        <span class="hljs-comment">/**
         * 检查是否包含非数字字符
         */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNonDigit</span><span class="hljs-params">(CharSequence text)</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; text.length(); i++) {
                <span class="hljs-keyword">if</span> (!Character.isDigit(text.charAt(i))) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<p><strong>activity_main.xml</strong>：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span>
    <span class="hljs-attr">android:padding</span>=<span class="hljs-string">"16dp"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"推荐方案（InputConnection拦截）："</span>
        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">"16sp"</span>
        <span class="hljs-attr">android:textStyle</span>=<span class="hljs-string">"bold"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">com.yourpackage.widget.RecommendedNumberEditText</span>
        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/edit_recommended"</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:hint</span>=<span class="hljs-string">"请输入数字"</span>
        <span class="hljs-attr">android:inputType</span>=<span class="hljs-string">"number"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">"24dp"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"测试说明："</span>
        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">"14sp"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">"8dp"</span>
        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"1. 输入数字 123456\n2. 切换到字母键盘\n3. 连续点击字母 'q'\n4. 数字不会被删除 ✓"</span>
        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">"12sp"</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>
</code></pre>
<hr/>
<p><strong>系列完结</strong>。从Binder通信机制，到文本编辑设计缺陷，再到完整的工程解决方案，希望这三篇文章能帮助你深入理解Android输入法框架，并在实际项目中游刃有余地解决类似问题。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[进入职场第三课——立足]]></title>    <link>https://juejin.cn/post/7570935965435510799</link>    <guid>https://juejin.cn/post/7570935965435510799</guid>    <pubDate>2025-11-10T13:58:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570935965435510799" data-draft-id="7570901172527497251" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="进入职场第三课——立足"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2025-11-10T13:58:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Mapbarfront"/> <meta itemprop="url" content="https://juejin.cn/user/624178336632407"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            进入职场第三课——立足
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/624178336632407/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Mapbarfront
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T13:58:13.000Z" title="Mon Nov 10 2025 13:58:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">进入职场第三课—立足</h2>
<p>在观察和融入之后，要做的第三件事就是立足。你已经度过了新手期，接下来，需要你承担更多有挑战的工作，来证明你的能力。</p>
<p>如果你是应届新人，这个时候可能跟着带你的导师，开始正式参加业务开发；如果你是职场老鸟，这个时候就需要你独立完成任务了。这个阶段是你给直属领导，也就是你的老板，建立印象最关键的时刻，如果符合预期甚至超预期，以后，在公司大概率会发展的顺顺利利；如果不及预期的话，则可能会被老板贴上不太行的标签，被归为低绩效的候选人。</p>
<p>渡过了新手期，接下来就该立足了，只有站得稳，才能走得好，才有机会跳得高，易经乾卦中的见龙在田，说的就是这个意思，想要立足，想要站得稳，你需要做好以下这四个动作。</p>
<h3 data-id="heading-1">1、做好第一个独立任务</h3>
<p>从新手期的学习适应，到立足期的承担负责，这是团队内其他成员，对你预期的改变，老板给了你很长时间，是时候体现你的价值了，当你接到第一个独立完成的任务，尤其重要，你需要花120%的心思来把它做好。</p>
<p>原因很简单，这个任务完成的好坏，直接决定，你在老板心中建立什么样的印象，想被老板认可，后续被他归到放心、靠谱这一类里，第一个独立任务是你必须做好的。当然，你来的时间还不长，一些历史债务可能还不清楚，仍然存在犯错的可能性，没关系，尽力去把它做好，即使犯错也别担心，积极改正的努力态度一定要打满。</p>
<h3 data-id="heading-2">2、主动优化一个小事</h3>
<p>每个公司、每个团队，都有大大小小、各种各样的问题，就算再优秀的团队，也一定有小的瑕疵可以优化，在你负责的工作范围内，找到一件小事情，在领导没有安排，其他同事默认接受的情况下，你主动去把它优化一下，做的更好一点，让团队的协作效率变得更高一点，可别小看这种小事情，这是有观察力、主动思考的典型表现，会给老板和团队其他成员，留下很好的印象。</p>
<h3 data-id="heading-3">3、为自己贴上靠谱的标签</h3>
<p>凡事有交代，件件有着落，事事有回响，无论是独立任务、合作任务，又或者是共同讨论，主动参与、积极反馈、懂得必还，这些都是建立信任的行为，也是为自己贴上靠谱标签的动作，千万记得，一定不要让流转到你手上的事情，没完成、没下文，掉在地上，同时，有风险也要第一时间同步出来，不要捂在自己的盖子底下。</p>
<h3 data-id="heading-4">4、结交正磁场的同事</h3>
<p>团队里，老板喜欢的人，往往是主力输出，同时也是中高绩效，如果你有野心，想在团队里立足，立的高一点，尽量要结交那些，能给你提供正磁场的同事，人都是有磁场的，每个人的磁场也不同，磁场之间相互吸引、相互影响，相互传递。</p>
<p>低绩效，边缘化的同事，他可能自己已经摆烂了或者想溜了，你跟他在一起，除了天天听他吐槽公司、吐槽老板，抱怨东抱怨西，啥也收获不了，而且时间长了，在老板眼里，你也会被归到和他同一类态度里去。</p>
<h2 data-id="heading-5">结语</h2>
<p>见龙在田，利见大人，也有该结交可以帮助你贵人的意思，做好上面这4件事，你就算在团队中真正的立足站稳了。</p>
<p>你的能力有了施展的机会，你也开始真正独立的被人审视，被人看见，这是一个从被动接受，到主动承担的过程。</p>
<p>见龙在田，龙刚刚出现在大地上被人发现，重点在于显现，而不是冲刺，立足站稳，而不是急功近利，别着急，后面的路还长着呢。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[震撼业界：文心5.0 Preview登顶全球第二，创意写作能力亮眼！]]></title>    <link>https://juejin.cn/post/7570885801478553641</link>    <guid>https://juejin.cn/post/7570885801478553641</guid>    <pubDate>2025-11-10T14:00:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570885801478553641" data-draft-id="7570908785293656083" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="震撼业界：文心5.0 Preview登顶全球第二，创意写作能力亮眼！"/> <meta itemprop="keywords" content="AIGC"/> <meta itemprop="datePublished" content="2025-11-10T14:00:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="墨风如雪"/> <meta itemprop="url" content="https://juejin.cn/user/4064249017803927"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            震撼业界：文心5.0 Preview登顶全球第二，创意写作能力亮眼！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4064249017803927/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    墨风如雪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T14:00:44.000Z" title="Mon Nov 10 2025 14:00:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近AI圈子真是热闹非凡，各大模型你方唱罢我登场，但如果说哪个消息最让人心头一震，那莫过于百度文心大模型5.0 Preview的横空出世，它不仅一举问鼎国内大模型之首，更是在国际舞台上杀入了全球并列第二的宝座，尤其在创意写作方面，更是独步天下，拿下了全球第一的桂冠！</p>
<p>这可不是什么实验室里的数据，而是来自AI界公认的权威评测平台——LMArena（原名LMSYS Chatbot Arena）的实战结果。这个由加州大学伯克利分校团队打造的平台，评测机制可以说相当“残酷”但也最贴近真实：它让全球用户对两个匿名的模型回答进行盲测投票，谁答得好就给谁一票。这种基于用户真实偏好的Elo评分系统，能最直观地反映模型在实际应用中的用户体验和能力。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2025%2F11%2FiShot_2025-11-10_21.49.55-1024x459.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2025/11/iShot_2025-11-10_21.49.55-1024x459.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3436459c86fb45338d988e052ab726c5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763388044&amp;x-signature=Yv4VwgSfUz%2F12ZBNrMpTObMqqBE%3D" alt="iShot_2025-11-10_21.49.55" loading="lazy"/></a></p>
<h3 data-id="heading-0">LMArena榜单的惊艳表现</h3>
<p>就在最近的LMArena Text Arena榜单上，文心5.0 Preview（ERNIE-5.0-Preview-1022）凭借1432分的Elo高分，与OpenAI的GPT-4.5-Preview、Anthropic的Claude-Opus-4-1等国际顶级模型平起平坐，一同位列全球并列第二。更令人兴奋的是，它超越了包括GPT-5-High、Qwen3-Max、DeepSeek-R1在内的诸多国内外主流强劲对手。这不光是文心的胜利，更是国产大模型迈向全球巅峰的重要里程碑。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2025%2F11%2FiShot_2025-11-10_21.50.03-1024x726.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2025/11/iShot_2025-11-10_21.50.03-1024x726.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a6d2c8280f584680a4368bac46b1111b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763388044&amp;x-signature=L%2Bx%2BGhpQvyJr6NHYbXGQRsT4Kmg%3D" alt="iShot_2025-11-10_21.50.03" loading="lazy"/></a></p>
<h3 data-id="heading-1">三大核心能力，定义顶尖水准</h3>
<p>那么，这个新来的“黑马”究竟凭什么能一鸣惊人呢？在我看来，文心5.0 Preview在以下几个核心文本能力维度上，确实展现了顶级水准：</p>
<h4 data-id="heading-2">🏆 创意写作：全球独一份的“妙笔生花”</h4>
<p>要说最让人拍案叫绝的，必须是文心5.0 Preview在<strong>创意写作</strong>上的统治力——它在这个维度拿下了<strong>全球第一</strong>！这意味着，无论是策划一场声势浩大的营销战役、撰写引人入胜的剧本，还是生成一篇情感真挚的文章，它的产出都能在效率和质量上实现大幅跃升。有实测案例显示，在策划一场营销战役时，文心5.0 Preview不仅能抓住“情绪价值”的核心洞察，连输出的短视频脚本都专业到令人惊叹，画面、剪辑点、音效等执行细节一应俱全，这可不是简单的堆砌文字，而是真正意义上的“妙笔生花”。</p>
<h4 data-id="heading-3">🧠 复杂长问题理解：洞察深层逻辑的“智者”</h4>
<p>在处理<strong>复杂长问题</strong>方面，文心5.0 Preview也表现出了非凡的才能。它擅长处理那些拥有多层逻辑、需要深入阅读和推理的长文本任务。想象一下，面对一篇冗长的学术报告，或者一个需要多方面知识融合的深度问答，它能够精准把握核心要点，进行高效的知识推理和分析。这对于科研、法律、金融等高认知要求的场景，简直是如虎添翼。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2025%2F11%2FiShot_2025-11-10_21.50.09-1024x742.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2025/11/iShot_2025-11-10_21.50.09-1024x742.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c20f358cc2f9492d8ab091f17d873731~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763388044&amp;x-signature=VuX6EDrmBLEcNTHHDjQe8mkNbO8%3D" alt="iShot_2025-11-10_21.50.09" loading="lazy"/></a></p>
<h4 data-id="heading-4">✅ 指令遵循：精确无误的“执行官”</h4>
<p>第三个核心能力是<strong>指令遵循</strong>。这听起来简单，但在实际应用中却至关重要。文心5.0 Preview能精准理解并执行用户提出的各项复杂意图，这对于智能助理、代码生成、业务流程自动化等场景，是保证输出可靠性和准确性的基石。还记得那个令人称奇的测试吗？在撰写关于“北京”的介绍时，模型被要求同时满足“禁止使用‘的’字、禁止使用逗号和顿号、必须分三个编号段落”等多项反直觉的苛刻约束。结果呢？它出色地理解并完美执行了所有规则，在完全不用特定标点和字词的情况下，依然生成了一段连贯且富有文采的介绍，这简直是在AI的“刀尖上跳舞”！</p>
<h3 data-id="heading-5">国产AI，未来可期</h3>
<p>文心5.0 Preview的强劲表现，绝非偶然。这背后是百度在“芯片-框架-模型-应用”四层全栈AI技术布局上的长期深耕与积累。这不光是模型的胜利，更是百度在AI领域长期投入的全栈技术体系开花结果，它清晰地告诉我们，中国的大模型在理解和生成人类语言方面，已经完全有能力与全球最顶尖的产品掰手腕。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.worldcodeing.com%2Fwp-content%2Fuploads%2F2025%2F11%2FiShot_2025-11-10_21.50.18-1024x725.png" target="_blank" title="https://blog.worldcodeing.com/wp-content/uploads/2025/11/iShot_2025-11-10_21.50.18-1024x725.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/67f77e84520c4c21b64349d8fcda82d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aKo6aOO5aaC6Zuq:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763388044&amp;x-signature=%2B4Bh0ustsJWE9xKqr9WV7hFQPzQ%3D" alt="iShot_2025-11-10_21.50.18" loading="lazy"/></a></p>
<p>虽然目前我们看到的是一个Preview版本，但它带来的惊喜已经足够震动业界。据悉，文心大模型的最新基座模型计划于2025年11月13日的百度世界大会上正式发布，届时，开发者和用户将有机会更全面地体验它的强大能力。作为AI创作者，我已经迫不及待想看看它在更广阔的应用场景中，还能带来多少惊喜。国产AI的未来，从未如此清晰和令人振奋！</p>
<p><strong>如果你也对最新的AI信息感兴趣或者有疑问 都可以加入我的大家庭 第一时间分享最新AI资讯、工具、教程、文档 欢迎你的加入！！！😉😉😉</strong></p>
<p>公众号：墨风如雪小站</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C#/.NET/.NET Core技术前沿周刊 | 第 60 期（2025年11.1-11.9）]]></title>    <link>https://juejin.cn/post/7570902804451475466</link>    <guid>https://juejin.cn/post/7570902804451475466</guid>    <pubDate>2025-11-10T12:03:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902804451475466" data-draft-id="7570912420567744522" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C#/.NET/.NET Core技术前沿周刊 | 第 60 期（2025年11.1-11.9）"/> <meta itemprop="keywords" content="后端,.NET"/> <meta itemprop="datePublished" content="2025-11-10T12:03:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="追逐时光者"/> <meta itemprop="url" content="https://juejin.cn/user/2770425031690333"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C#/.NET/.NET Core技术前沿周刊 | 第 60 期（2025年11.1-11.9）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2770425031690333/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    追逐时光者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:03:25.000Z" title="Mon Nov 10 2025 12:03:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/43a29eaf433a41e99b3836c7caf5a516~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=02RmGren4qCBIuicXq0AsqbFjkg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">前言</h2>
<p>C#/.NET/.NET Core技术前沿周刊，你的每周技术指南针！记录、追踪C#/.NET/.NET Core领域、生态的每周最新、最实用、最有价值的技术文章、社区动态、优质项目和学习资源等。让你时刻站在技术前沿，助力技术成长与视野拓宽。</p>
<blockquote>
<p>欢迎投稿、推荐或自荐优质文章、项目、学习资源等。</p>
</blockquote>
<ul>
<li><strong>🏆技术前沿周刊Gitee开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fysgdaydayup%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetWeekly.md" target="_blank" title="https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md" ref="nofollow noopener noreferrer">gitee.com/ysgdaydayup…</a></li>
<li><strong>📰技术前沿周刊GitHub开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FYSGStudyHards%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetWeekly.md" target="_blank" title="https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetWeekly.md" ref="nofollow noopener noreferrer">github.com/YSGStudyHar…</a></li>
</ul>
<h2 data-id="heading-1">C#/.NET/.NET Core优秀项目和框架2025年10月简报</h2>
<ul>
<li><strong>文章简介：</strong> 公众号每月定期推广和分享的C#/.NET/.NET Core优秀项目和框架（每周至少会推荐两个优秀的项目和框架当然节假日除外），公众号推文中有项目和框架的详细介绍、功能特点、使用方式以及部分功能截图等（打不开或者打开GitHub很慢的同学可以优先查看公众号推文，文末一定会附带项目和框架源码地址）。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FDB1UBuiS2BvZjf7VlH0_MQ" target="_blank" title="https://mp.weixin.qq.com/s/DB1UBuiS2BvZjf7VlH0_MQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/DB1UBuiS2…</a></li>
</ul>
<h2 data-id="heading-2">事半功倍：.NET 开发者的 Visual Studio 效率技巧！</h2>
<ul>
<li><strong>文章简介：</strong> 本文大姚将为你分享一些 Visual Studio 的使用技巧和建议，旨在帮助 .NET 开发者更加高效地利用 Visual Studio 进行编程开发工作。无论你是 .NET 初学者还是经验丰富的 .NET 开发者，这些技巧都将有助于提升你的工作效率，让你能够更快地编写出高质量的代码。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FyHAK0VvcOR8bqZVqOBizXQ" target="_blank" title="https://mp.weixin.qq.com/s/yHAK0VvcOR8bqZVqOBizXQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/yHAK0VvcO…</a></li>
</ul>
<h2 data-id="heading-3">【拾遗补漏】.NET 常见术语集</h2>
<ul>
<li><strong>文章简介：</strong> .NET 常见术语集旨在为 .NET 初学者提供一份清晰的入门指引，也为经验丰富的 .NET 开发者提供一份便捷的参考，帮助大家更准确地表达、更高效地学习、更深入地探索 .NET 的强大功能（有遗漏的欢迎文末留言）。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2FCan-daydayup%2Fp%2F19193323" target="_blank" title="https://www.cnblogs.com/Can-daydayup/p/19193323" ref="nofollow noopener noreferrer">www.cnblogs.com/Can-daydayu…</a></li>
</ul>
<h2 data-id="heading-4">一款基于 .NET WinForm 开源、轻量且功能强大的节点编辑器</h2>
<ul>
<li><strong>文章简介：</strong> STNodeEditor 是一款基于 .NET WinForm 开源免费（MIT License）、轻量且功能强大的节点编辑器，采用纯 GDI+ 绘制无任何依赖库仅仅100+Kb，提供了丰富的属性以及事件，可以非常方便的完成节点之间数据的交互及通知，编辑器内置了大量虚函数，供开发者根据需求进行重写，赋予了极高的自由度和定制能力。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfMG3iAu1Y0Fkmf6d-fcgiA" target="_blank" title="https://mp.weixin.qq.com/s/fMG3iAu1Y0Fkmf6d-fcgiA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/fMG3iAu1Y…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc08d40683fa477e8650ce425439488d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=vcdiT%2FJjvahnXVpAR%2FRfeU15dtM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5">一款 .NET 开源（GPL-3.0 license）、免费、现代的远程会话管理和启动器</h2>
<ul>
<li><strong>文章简介：</strong> 1Remote 是一个现代化的个人远程会话管理和启动器，适用于需要管理多种不同协议远程会话的用户。无论是系统管理员、开发人员还是IT支持人员，都可以通过1Remote在一个集中的地方管理他们的所有远程连接，提高工作效率和便利性。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F4PIKVLGLkOsvSJJO9InvXA" target="_blank" title="https://mp.weixin.qq.com/s/4PIKVLGLkOsvSJJO9InvXA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/4PIKVLGLk…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f16c45ff1bbb482694f0b734b8c887c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=InIjYF7OsUCLt68OEaIhv7ZSPa0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6">ASP.NET Core 部署进化史：从 Windows IIS 到 Docker，再到国产 Linux 容器化实践</h2>
<ul>
<li><strong>文章简介：</strong> ASP.NET Core 部署进化史：从 Windows IIS 到 Docker，再到国产 Linux 容器化实践。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqxBAzom3He-Lk7hQr7T7bQ" target="_blank" title="https://mp.weixin.qq.com/s/qxBAzom3He-Lk7hQr7T7bQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/qxBAzom3H…</a></li>
</ul>
<h2 data-id="heading-7">深入探索C# Channels：高级模式与实战指南</h2>
<ul>
<li><strong>文章简介：</strong> 我们已经介绍了基础知识，包括类型、循环，甚至一些实际应用场景。现在，您应该对生产者、消费者、完成和取消操作感到熟悉了。但 Channels 就像一座冰山；您目前所见的仅是冰山一角。其底层隐藏着高级模式，如果能够恰当地运用（或避免使用），它们能让您的系统发挥出卓越的性能。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fjhu0IEk_4D1n-cJocPLMbA" target="_blank" title="https://mp.weixin.qq.com/s/jhu0IEk_4D1n-cJocPLMbA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/jhu0IEk_4…</a></li>
</ul>
<h2 data-id="heading-8">一个开源、精美的 WPF 用户界面</h2>
<ul>
<li><strong>文章简介：</strong> WPFUIDemo 是一个专注于 WPF（Windows Presentation Foundation）用户界面设计与开发的示例项目。该项目旨在为开发者提供一个全面、实用的参考范例，帮助他们快速掌握 WPF 应用开发的核心技巧和最佳实践，提升开发效率与界面设计水平。通过丰富的功能模块和代码示例，开发者可以深入了解 WPF 的强大特性，并将其灵活应用于实际项目中。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F15oTrGmLzGl4AAUV6maIgw" target="_blank" title="https://mp.weixin.qq.com/s/15oTrGmLzGl4AAUV6maIgw" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/15oTrGmLz…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a24154ae6baf4a4abe006b250011e0aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=8o%2Bl%2BjX7g6ofRRlwWg7bi7C6q%2BI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">一款基于 .NET 8 + Vue 前后端分离的快速开发框架，解决 70% 的重复工作！</h2>
<ul>
<li><strong>文章简介：</strong> ZrAdminNetCore 是一款基于前后端分离架构、跨平台部署的通用权限管理后台系统，采用 RBAC（Role-Based Access Control） 权限模型设计，支持多租户、动态菜单、细粒度权限控制等功能。项目以 .NET Core 为后端技术栈，结合现代化前端框架构建，适用于企业级中后台管理系统快速开发。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FilK-HScDVxb9tBykwgP_JQ" target="_blank" title="https://mp.weixin.qq.com/s/ilK-HScDVxb9tBykwgP_JQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/ilK-HScDV…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b10e69eb50b34b46a44e7a6e49522c35~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=oPvimKfOYTCAyP03fo7uZ%2FyuBU0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f8875103a4d4b548847114e259a4e5f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=RTruBica7oXG6cFg4A4%2Bvxl8BoI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">【译】Avalonia UI与谷歌Flutter团队合作将Impeller渲染引擎引入.NET</h2>
<ul>
<li><strong>文章简介：</strong> 我们激动地宣布阿瓦洛尼亚在渲染技术道路上迎来一个重要里程碑。我们的团队正与谷歌Flutter工程师合作，将其下一代"GPU优先"渲染器Impeller引入.NET开发者生态。这项技术合作旨在突破跨平台性能边界，展现开源社区如何通过协作创造更大价值。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBQz1GrnknYqlAMujSJQ55A" target="_blank" title="https://mp.weixin.qq.com/s/BQz1GrnknYqlAMujSJQ55A" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/BQz1Grnkn…</a></li>
</ul>
<h2 data-id="heading-11">一款 .NET 开源免费、功能全面的串口调试神器，工控必备效率工具！</h2>
<ul>
<li><strong>文章简介：</strong> BYSerial 是一款功能全面、用户友好的串口调试工具，适用于工控领域、物联网开发、嵌入式系统开发等多种场景。项目开源免费（MIT License），支持多语言切换、自动更新、自定义快捷命令等功能，是工控领域必备的效率工具。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6aJr_eT1kFCgvBvILXHkXQ" target="_blank" title="https://mp.weixin.qq.com/s/6aJr_eT1kFCgvBvILXHkXQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/6aJr_eT1k…</a></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87c8079ad7a34f52857d19b403b3552f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381005&amp;x-signature=BMcKIQQlkPErIQrkouOP2Cbq2Fg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-12">.NET 搞 AI 不行？</h2>
<ul>
<li><strong>文章简介：</strong> 今天，我要告诉你一个被严重低估的事实：.NET开发者不仅能做AI，而且可能是最适合把AI落地到生产环境的那群人。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fsheng-jie%2Fp%2F19200934" target="_blank" title="https://www.cnblogs.com/sheng-jie/p/19200934" ref="nofollow noopener noreferrer">www.cnblogs.com/sheng-jie/p…</a></li>
</ul>
<h2 data-id="heading-13">从零开始:C#与C++函数传参——调包侠秘籍</h2>
<ul>
<li><strong>文章简介：</strong> 在日常开发中，C# 和 C++ 都是非常强大的编程语言。C# 有着简洁的语法和强大的框架支持，而 C++ 在性能和底层操作上有着独特的优势。有时候，我们可能需要在 C# 项目中调用 C++ 编写的高性能函数，比如处理复杂的图像算法、调用底层硬件接口等，还有就是可以更多的丰富咱们的代码库，因为很多性能好、实用、跨平台的库都是C++写的，可以极大扩展咱们程序的应用场景。但对于初学者来说，第一大难题就是方法/函数的调用。接下来我们举例说明一下C#调用C++动态链接库函数的详细实现（以windows系统为例）。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fluojin765%2Fp%2F19199730" target="_blank" title="https://www.cnblogs.com/luojin765/p/19199730" ref="nofollow noopener noreferrer">www.cnblogs.com/luojin765/p…</a></li>
</ul>
<h2 data-id="heading-14">ASP.NET Core Blazor 核心功能三：Blazor与JavaScript互操作——让Web开发更灵活</h2>
<ul>
<li><strong>文章简介：</strong> 今天我们来聊聊Blazor中C#与JavaScript互操作。我知道很多同学在听到"Blazor"和"JavaScript"要一起工作时会有点懵，但别担心，我会用最简单的方式带你掌握这个技能！</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fshenchuanchao%2Fp%2F19194651" target="_blank" title="https://www.cnblogs.com/shenchuanchao/p/19194651" ref="nofollow noopener noreferrer">www.cnblogs.com/shenchuanch…</a></li>
</ul>
<h2 data-id="heading-15">ASP.NET Core Blazor 核心功能二：Blazor表单和验证</h2>
<ul>
<li><strong>文章简介：</strong> 本文介绍了Blazor中EditForm组件的使用及表单验证方案。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fshenchuanchao%2Fp%2F19189573" target="_blank" title="https://www.cnblogs.com/shenchuanchao/p/19189573" ref="nofollow noopener noreferrer">www.cnblogs.com/shenchuanch…</a></li>
</ul>
<h2 data-id="heading-16">【EF Core】“多对多”关系与跳跃导航</h2>
<ul>
<li><strong>文章简介：</strong> “多对多”关系不像“一对多”那么“单纯”，它内部涉及到“连接实体”（Join Entity）的概念。咱们先放下这个概念不表，来了解一下多对多数据表为什么需要一个“辅助表”来建立关系。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Ftcjiaan%2Fp%2F19184567" target="_blank" title="https://www.cnblogs.com/tcjiaan/p/19184567" ref="nofollow noopener noreferrer">www.cnblogs.com/tcjiaan/p/1…</a></li>
</ul>
<h2 data-id="heading-17">LVGLSharp：LVGL的C#绑定库介绍</h2>
<ul>
<li><strong>文章简介：</strong> 在嵌入式系统和图形用户界面（GUI）开发领域，LVGL（Light and Versatile Graphics Library）是一个广受欢迎的开源图形库，它提供了丰富的UI组件和高效的渲染能力，适用于各种资源受限的设备。而LVGLSharp则是LVGL的一个C#绑定库，它使得.NET开发者能够更方便地利用LVGL的强大功能，在C#环境中创建出美观且高效的图形界面。本文将详细介绍LVGLSharp及其特点。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fshanyou%2Fp%2F19185046" target="_blank" title="https://www.cnblogs.com/shanyou/p/19185046" ref="nofollow noopener noreferrer">www.cnblogs.com/shanyou/p/1…</a></li>
</ul>
<h2 data-id="heading-18">Copilot Studio 如何使用 .NET 和 WebAssembly 实现性能和创新</h2>
<ul>
<li><strong>文章简介：</strong> Microsoft Copilot Studio 处于对话式 AI 和自动化的最前沿，使组织能够为各种企业场景构建、自定义和管理智能助手和机器人。随着平台的发展，支撑它的技术也在不断发展。Copilot Studio 创新的核心是它与 .NET 的深度集成，包括在 WebAssembly （WASM） 上使用 .NET。这篇文章探讨了 Copilot Studio 如何利用 .NET、平台升级带来的好处，以及由此带来的性能、成本和生产力改进。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fcopilot-studio-dotnet-wasm%2F" target="_blank" title="https://devblogs.microsoft.com/dotnet/copilot-studio-dotnet-wasm/" ref="nofollow noopener noreferrer">devblogs.microsoft.com/dotnet/copi…</a></li>
</ul>
<h2 data-id="heading-19">.NET Conf 2025即将开始</h2>
<ul>
<li><strong>文章简介：</strong> .NET Conf 2025 仅几天后就要开始了，参加11 月 11 日至 13 日的这场免费三日虚拟会议，了解 .NET 平台、开源项目和开发者工具的最新进展—包括 .NET 10 的正式发布，以及对 Visual Studio 2026 的深度探讨。今年的会议特别聚焦使用 Aspire 进行云原生开发、快速地将现有应用升级到 .NET 10，以及使用 AI 构建智能应用，包括全新的 Microsoft Agent Framework 和 Model Context Protocol (MCP) 支持。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FGqLWiGQ77EZ4MTUFhwGqUA" target="_blank" title="https://mp.weixin.qq.com/s/GqLWiGQ77EZ4MTUFhwGqUA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/GqLWiGQ77…</a></li>
</ul>
<h2 data-id="heading-20">AI 时代，.NET 开发者向左还是向右？</h2>
<ul>
<li><strong>文章简介：</strong> AI 时代，.NET 开发者向左还是向右？ MAF vs LangChain 1.0 一场关乎未来的技术选择。</li>
<li><strong>文章地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FXBYYsjkmhuDEq3gyTvSmmQ" target="_blank" title="https://mp.weixin.qq.com/s/XBYYsjkmhuDEq3gyTvSmmQ" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/XBYYsjkmh…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[货拉拉用户画像基于 Apache Doris 的数据模型设计与实践]]></title>    <link>https://juejin.cn/post/7570903763721797642</link>    <guid>https://juejin.cn/post/7570903763721797642</guid>    <pubDate>2025-11-10T12:03:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570903763721797642" data-draft-id="7570932873130803227" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="货拉拉用户画像基于 Apache Doris 的数据模型设计与实践"/> <meta itemprop="keywords" content="数据库,Apache"/> <meta itemprop="datePublished" content="2025-11-10T12:03:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SelectDB"/> <meta itemprop="url" content="https://juejin.cn/user/3189021726222904"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            货拉拉用户画像基于 Apache Doris 的数据模型设计与实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3189021726222904/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SelectDB
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:03:56.000Z" title="Mon Nov 10 2025 12:03:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>货拉拉是国内领先的同城货运数字化平台，成立于 2013 年。截⾄2025 年 4⽉ ，货拉拉业务覆盖全球 14 个市场 ，400+ 城市 ，其中中国内地总共覆盖 363 座城市 ，⽉活司机达 120 万 ，⽉活⽤户达 1400 万， 并在全球设有 6 个数据中⼼。作为共享经济模式的代表企业 ，货拉拉通过移动互联⽹技术整合社会运⼒资源 ，为⽤户提供即时货运、企业物流、搬家服务等多元化解决⽅案。</p>
<p>在庞⼤的业务规模下 ，构建完善的⽤户画像平台成为实现精细化运营的重要基础 ，可以有效提升运营效率和⽤户体验。</p>
<h2 data-id="heading-0">画像服务背景与架构</h2>
<p>目前货拉拉的画像平台已深度应用于多个核心业务场景，各业务场景对标签的使⽤⽅式和时效性要求各不相同。从 22 年到 25 年，用户呈现稳定增长趋势，业务对服务的压力也是逐年递增，累计接入了 300+ 业务，3,000+ 个标签以及 5 万多人群。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c66913f70762483c865b8f6a4c96ca0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=ygxNmiZsth03AsIZmiNNqnrZksE%3D" alt="画像服务背景与架构.png" loading="lazy"/></p>
<h3 data-id="heading-1">01 应用架构</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/55e13b8607e243a98ef31a3995963291~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=2ko8cdEzlCDoZJZYfm9wMalSkio%3D" alt="货拉拉用户画像应用架构.PNG" loading="lazy"/></p>
<p>上图是货拉拉画像平台整体架构图，Apache Doris 作为统一查询引擎，为人群画像提供高效的分析能力。该平台通过架构分层实现了业务需求与技术能力的精准匹配。其中有两个核心模块：</p>
<ul>
<li>API 层（接⼝服务层）：基于重点使⽤场景和对接系统搭建的画像接口服务 ，从⽽精准地⽣成用户画像 ，给到对接业务⽅使⽤。其中包括：
<ul>
<li>persona-api：⾯向⾼并发查询场景</li>
<li>persona-analysis-api：承接分析计算与推送作业请求</li>
<li>persona-web-api：⽀持管理后台的 Web 服务</li>
</ul>
</li>
<li>BE 层（计算引擎层） ：建造基于大数据体系的用户标签链路的画像管理平台 ，⽤于在特定业务形态下描述业务主体；其中包括：
<ul>
<li>persona-task：执⾏分布式计算作业 ，⽀持横向扩展</li>
<li>persona-scheduler ：调度⼈群计算任务</li>
</ul>
</li>
</ul>
<p>两大模块协同工作，共同支撑业务方的精细化运营需求。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1331ddf1992b4fcfa2c32bf8ae770647~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=wp%2F6LvWGnjEARAq8aX614Wrq2Xo%3D" alt="货拉拉用户画像应用架构-1.PNG" loading="lazy"/></p>
<h3 data-id="heading-2">02 画像平台计算引擎演进</h3>
<p>在核心计算引擎的选型与演进过程中，技术团队经历了三个主要阶段。</p>
<ul>
<li>第一阶段，受限于成本因素，采用了三方服务结合 Impala+KUDU 的架构作为用户画像计算引擎。该架构在实际应用中暴露出诸多问题：单次人群计算耗时 10 分钟以上，高峰期甚至超过 30 分钟；同时，数据导入耗时较长，经常超时。此外，该架构存在横向扩展困难、复杂查询效率偏低及运维复杂等不足。</li>
<li>第二阶段，为寻求改进，我们尝试引入 Elasticsearch，虽在一定程度上有所缓解，但仍面临开发成本高、语法复杂、多维分析能力不足等挑战，且在动态扩展和复杂查询方面未实现根本性改善。尤其在处理人群间存在依赖关系的特殊业务场景时，Elasticsearch 架构难以有效支持。</li>
<li>基于此，我们最终转向采用 Doris 作为核心计算引擎。选择 Doris 的关键因素如下：
<ul>
<li><strong>性能优越</strong>：基于 MPP 架构、具备向量化引擎和先进的优化器能力，查询性能优秀。</li>
<li><strong>社区资源丰富</strong>：Doris 拥有活跃的社区支持以及丰富的文档资料，自行搭建遇到卡点时，可向社区帮助寻求专业的指导与帮助。</li>
<li><strong>支持多种数据类型</strong>：画像场景可以使用 BITMAP 实现高效的交并集运算，成为支撑多样化标签类型与人群分析业务的技术基础。</li>
<li><strong>支持多种数据模型</strong>：针对多维复杂的人群画像，可以使用不同的数据模型支撑各种标签类型与人群业务。</li>
</ul>
</li>
</ul>
<p>自引入 Doris 后，系统稳定性得到了显著提升，至今未出现过重大稳定性问题，整体链路的时效性与可靠性均实现了根本性的优化，具体如下：</p>
<ul>
<li>在计算效率方面，单个人群的计算能够实现秒级响应，即使在高峰期，响应时间也保持在 1 分钟以内。相比之下，Impala 架构下该计算过程通常需要 10 至 30 分钟。<strong>采用 Doris 后，计算效率提升了近 30 倍。</strong></li>
<li>在数据导入方面，Doris 同样表现出色。在处理 4 亿行 200 列的单表数据时，Doris 可在 30 分钟内完成导入操作。而在同等条件下，Impala 架构则需要 90 分钟以上，<strong>Doris 数据导入效率是 Impala 架构的 3 倍</strong>。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e11a63c30e5d480b82e6415f75c1b972~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=pHrcYb7lNVtrHwxTHa8vw%2Fohwto%3D" alt="画像平台计算引擎演进.png" loading="lazy"/></p>
<h2 data-id="heading-3">数据模型设计与异构查询实现</h2>
<h3 data-id="heading-4">01 核心挑战</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0942780c34794cc5a1867f7ce10fb846~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=N0laRIszv2f04xcN5fy%2Bcyyip4E%3D" alt="核心挑战.png" loading="lazy"/></p>
<p>首先是用户画像标签存储的挑战。面对 3000+ 标签的体系，我们发现标签数据天然存在三个维度的分裂特征：业务属性（行为/属性/地理等）、聚合粒度（明细/聚合/人群）、更新时效（离线/近实时/实时）。不同业务属性的数据在更新频率、查询模式、存储密度上差异巨大。</p>
<p>此外，用户使用画像标签的时候，对人群标签/明细标签/聚合标签等概念不清晰，只会进行简单的拖拉拽拼接规则。因此在标签使用场景，如何选择存储模型成为了核心问题。若使用宽表，将面临动态更新以及列拓展的挑战；而高表则面临复杂查询与嵌套逻辑的挑战。</p>
<h3 data-id="heading-5">02 存储模型设计</h3>
<p>面对复杂的标签管理，我们采用了<strong>基于 Apache Doris 分而治之的存储方案</strong>，具体分为三类模型来进行协同工作。</p>
<p><strong>标签宽表</strong></p>
<ul>
<li>存储低频更新的标签。</li>
<li>存储无法用高表存储的密集标签。</li>
<li>利用 Doris 的列式存储技术，利用索引、物化视图等优化手段，支持高效的多维分析。</li>
</ul>
<p>标签宽表建表 SQL 参考：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>  wide_table  (
 user_id  <span class="hljs-type">varchar</span>(<span class="hljs-number">1000</span>) <span class="hljs-keyword">NULL</span> COMMENT "",
 age  <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) REPLACE_IF_NOT_NULL <span class="hljs-keyword">NULL</span> COMMENT "",
 height  <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) REPLACE_IF_NOT_NULL <span class="hljs-keyword">NULL</span> COMMENT "",
 ......) ENGINE<span class="hljs-operator">=</span>OLAP AGGREGATE KEY( user_id ) COMMENT "OLAP"
DISTRIBUTED <span class="hljs-keyword">BY</span> HASH( user_id ) BUCKETS <span class="hljs-number">40</span>
PROPERTIES ( ... )
</code></pre>
<p><strong>标签高表</strong></p>
<ul>
<li>存储高频更新的稀疏标签。</li>
<li>支持秒级/分钟级数据更新，标签新增的场景下，可以规避宽表频繁 ALTER TABLE 导致的锁表问题。</li>
<li>多个标签的位图交并计算，并且支持毫秒级响应。</li>
</ul>
<p>标签高表建表 SQL 参考：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>  high_table  (
 tag  <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NULL</span> COMMENT "标签名",
 tag_value  <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NULL</span> COMMENT "标签值",
 <span class="hljs-type">time</span>  datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT "数据灌入时间",
 user_ids  bitmap BITMAP_UNION <span class="hljs-keyword">NULL</span> COMMENT "用户集"
) ENGINE<span class="hljs-operator">=</span>OLAP AGGREGATE KEY( tag ,  tag_value ,  <span class="hljs-type">time</span>  ) COMMENT "OLAP"
DISTRIBUTED <span class="hljs-keyword">BY</span> HASH( tag ) BUCKETS <span class="hljs-number">128</span>
PROPERTIES ( ... )
</code></pre>
<p><strong>人群位图表</strong></p>
<ul>
<li>用于存储标签规则圈选出来的人群结果。</li>
<li>用户 ID 集合使用 RoaringBitmap 压缩，降低存储成本。</li>
<li>支持人群依赖计算，避免表数量膨胀问题，⽀持⼈群营销实验业务。</li>
</ul>
<p>人群位图表建表 SQL 参考：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>  routine_segmentation_bitmap (
 <span class="hljs-type">time</span>  datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT "数据灌入时间",
 seg_name  <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NULL</span> COMMENT "标签值",
 user_ids  bitmap BITMAP_UNION <span class="hljs-keyword">NULL</span> COMMENT "人群ID集合"
) ENGINE<span class="hljs-operator">=</span>OLAP AGGREGATE KEY( <span class="hljs-type">time</span> ,  seg_name )
COMMENT "OLAP" <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>(`<span class="hljs-type">time</span>`) (...)DISTRIBUTED <span class="hljs-keyword">BY</span> HASH( seg_name )
BUCKETS <span class="hljs-number">128</span>
PROPERTIES (..., "dynamic_partition.enable" <span class="hljs-operator">=</span> "true", ...);
</code></pre>
<h3 data-id="heading-6">03 人群圈选与异构组合查询</h3>
<p>基于上述提到了三种存储模型，我们构建了以位图计算为核心的异构组合计算体系，并将其作用于整个人群圈选的场景，实现宽表、高表及人群表这三类存储模型之间的无缝联动。</p>
<ol>
<li>第一步：将所有单一标签或子查询的结果都处理成 Bitmap 位图，处理宽表的标签使用<code>TO_BITMAP</code>聚合多列 ID 结果，处理标签高表和人群表则直接使用预聚合的 Bitmap，加速逻辑复用。</li>
<li>第二步，通过<code>UNION ALL</code>整合宽表/高表/人群表三种数据源的 Bitmap，并使用外层的<code>BITMAP_INTERSECT</code>/<code>BITMAP_UNION</code>实现跨模型交并集运算（AND/OR 逻辑）。</li>
<li>第三步，由于<code>BITMAP_INTERSECT</code>/<code>BITMAP_UNION</code>的结果也是 Bitmap，所以可以用同样的处理方式，递归整合子查询的查询结果，并支持直接导出或对接业务系统。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a99ecd4ce2249518f26832e57d7d1d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=sv5DbJfnXHGJ41zgvegBpAh%2Bq%2Bo%3D" alt="人群圈选与异构组合查询.png" loading="lazy"/></p>
<p>该实现方法具备三大核心优势：</p>
<ul>
<li><strong>灵活拓展</strong>：动态嵌套子查询支持无限层级规则（如 “A 且（B 或 C）且（D 且（E 或 F））” ） ，静态属性、动态行为以及预计算人群等复杂的标签规则皆可无缝嵌入。</li>
<li><strong>资源节省</strong>：复用人群表（预计算人群）的数据从而大幅减轻计算压力，并允许不同人群间相互依赖进行计算；人群计算结果使用 RoaringBitmap 存储，不需要额外新增表。</li>
<li><strong>业务友好</strong>：支持人群+标签的复杂混合嵌套查询，用户无需技术基础，仅通过简单的拖拽标签条件即可高效圈定目标用户群体，适用于营销等多种场景。</li>
</ul>
<p>查询 SQL 示例：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">FROM</span> (
  <span class="hljs-comment">-- Layer1: 宽表条件A</span>
  <span class="hljs-keyword">SELECT</span> TO_BITMAP(...) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 标签宽表 <span class="hljs-keyword">WHERE</span> 条件A
  <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-comment">-- Layer1: 高表条件B</span>
  <span class="hljs-keyword">SELECT</span> user_ids <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 标签高表 <span class="hljs-keyword">WHERE</span> 条件B
  <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-comment">-- Layer1: 人群条件C</span>
  <span class="hljs-keyword">SELECT</span> user_ids <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 人群表 <span class="hljs-keyword">WHERE</span> 条件C
  <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-comment">-- Layer2: 嵌套子查询（新条件D/E/F）</span>
  <span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">FROM</span> (
    <span class="hljs-keyword">SELECT</span> TO_BITMAP(...) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 标签宽表 <span class="hljs-keyword">WHERE</span> 条件D  <span class="hljs-comment">-- 新宽表条件</span>
    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
    <span class="hljs-keyword">SELECT</span> user_ids <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 标签高表 <span class="hljs-keyword">WHERE</span> 条件E      <span class="hljs-comment">-- 新高表条件</span>
    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
    <span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(...) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> 人群表 <span class="hljs-keyword">WHERE</span> 条件F <span class="hljs-comment">-- 新人群条件</span>
  )
) t;
</code></pre>
<h3 data-id="heading-7">04 数据导入</h3>
<p>货拉拉画像服务的实时标签/人群点查主要采用 HBase 与 Redis 相结合的方式，Doris 主要承担人群圈选、人群洞察、行为分析等任务。实时和近实时标签写入 Doris 则通过 Flink 完成，离线导入依赖 Doris 的 Broker Load 功能。对应的数据导⼊⽅式和应⽤场景如下：</p>
<p><strong>实时/近实时标签</strong></p>
<p>定义：秒级/小时级更新的动态数据（如点击、登录事件）。</p>
<p>数据源：Kafka 日志、API 埋点、云文件存储。</p>
<p>处理方式：</p>
<ul>
<li>秒级/分钟级标签：Flink -&gt; Doris / Hbase。</li>
<li>小时级标签：云文件存储 -&gt; BrokerLoad。</li>
</ul>
<p>场景：用户行为分析，用户实时人群。</p>
<p><strong>离线标签</strong></p>
<p>定义：T+1 更新的历史数据（如年龄、历史订单）。</p>
<p>数据源：Hive。</p>
<p>处理方式：</p>
<ul>
<li>数据量：3000+ 标签，4 亿+用户总量。</li>
<li>定时调度：BrokerLoad。</li>
<li>调优手段：宽表导入拆分多表和多个 BrokerLoad 任务。数据量少的稀疏标签使用高表导入。</li>
<li>导入效率：200+ 标签宽表 4 亿行+导入 30min 以内，高表标签导入 5min 以内。</li>
</ul>
<p>场景：用户人群圈选、用户画像分析。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17651837909c467abb42a2f9c871d55e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=HepMDQlzhYPcV2IQKo2xIuGivS4%3D" alt="数据导入.png" loading="lazy"/></p>
<p>特别值得注意的是，大规模数据导入时，建议拆分多个表并行导入以提升效率，例如在早期 1.2.4 版本集群测试中，单个包含 200 余标签、四亿行记录的宽表导入耗时超过 1.5 小时，而拆分为 6 个任务并行导入后，总耗时缩短至约 20 分钟，<strong>效率提升近 5 倍</strong>。</p>
<h2 data-id="heading-8">货拉拉画像工程查询优化实践</h2>
<h3 data-id="heading-9">01 DSL 与 SQL 优化</h3>
<p>首先是离线人群包圈选的流程，主要分为三步：【运营通过平台进行多规则拼接，前端完成 DSL 构建】-【DSL 经过服务后端优化】-【最终将业务规则自动转化为高效 SQL】。DSL 优化的目的是提前排除冗余计算，从而将优化后的 DSL 直接翻译为高效易用的 SQL。</p>
<ol>
<li>为什么需要优化？当前异构查询 SQL 痛点：
<ol>
<li>部分标签在业务逻辑上可以合并 ，引擎侧没有覆盖识别；</li>
<li>多层聚合导致冗余扫描：复杂嵌套的场景下，嵌套的 <code>UNION ALL</code> 和 <code>BITMAP_INTERSECT</code> 导致执行计划层级膨胀，导致冗余的扫描。</li>
<li>稳定性：高峰期人群计算时，内存占用高、网络传输量大，高内存开销影响集群稳定性。</li>
</ol>
</li>
<li>如何实现优化？DSL 优化：
<ol>
<li>条件合并（染色）：将同类标记的标签条件合并为同个子查询。</li>
<li>结构扁平化（剪枝）：去除冗余的 AND/OR 逻辑节点</li>
</ol>
</li>
</ol>
<p>将同类合并操作后的 DSL 转为 SQL，原本查询 3 次宽表读取了 3 个 BITMAP 进行合并计算，优化后统一成 1 次宽表查询和 1 次 BITMAP 读取，减少了60% 的冗余读取。参考下图，DSL 的每一个圆圈对应一个 BITMAP 查询：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0322d45dce5143068f52bd0c035ba2e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=myNzCIbQ%2Fz5tL84427dvFCP6%2FFo%3D" alt="DSL 与 SQL 优化.png" loading="lazy"/></p>
<p>关于 <code>EXPLAIN</code> 指标优化前后的具体表现，我们在此也分享一则参考示例，详情如下：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 优化前</span>
<span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span> 
<span class="hljs-keyword">FROM</span> (
    <span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">AS</span> b 
    <span class="hljs-keyword">FROM</span> (
        <span class="hljs-keyword">SELECT</span> user_bitmap <span class="hljs-keyword">as</span> b <span class="hljs-keyword">FROM</span> user_bitmap <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">group</span> <span class="hljs-operator">=</span> ‘A’
        <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> 
        <span class="hljs-keyword">SELECT</span> TO_BITMAP(id) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> wide_table <span class="hljs-keyword">WHERE</span> city <span class="hljs-operator">=</span> <span class="hljs-string">'东莞'</span>
        <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
        <span class="hljs-keyword">SELECT</span> TO_BITMAP(id) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> wide_table <span class="hljs-keyword">WHERE</span> sex <span class="hljs-operator">=</span> <span class="hljs-string">'男'</span>
    ) t1 ) t2;
 
<span class="hljs-comment">-- 优化后</span>
<span class="hljs-keyword">SELECT</span> BITMAP_INTERSECT(b) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">result</span> 
<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> user_bitmap <span class="hljs-keyword">as</span> b <span class="hljs-keyword">FROM</span> user_bitmap <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">group</span> <span class="hljs-operator">=</span> ‘A’    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> 
    <span class="hljs-keyword">SELECT</span> TO_BITMAP(id) <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">FROM</span> wide_table <span class="hljs-keyword">WHERE</span> city <span class="hljs-operator">=</span> <span class="hljs-string">'东莞'</span> <span class="hljs-keyword">and</span> sex <span class="hljs-operator">=</span> ‘男’
) t1 ) t2;
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e67718b54bd4931859275b3dffdbfc3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=kNgfIa6yfLOxPwWg5hW1PJijgc0%3D" alt="DSL 与 SQL 优化-1.png" loading="lazy"/></p>
<p>在业务圈选逻辑不变的情况下，通过将优化前 BITMAP 子查询合并到 WHERE 条件中以避免重复扫描表，同时减少 BITMAP 子查询及数据分片合并次数，进而减少聚合层级实现结构扁平化，降低人群计算时的内存峰值。</p>
<p><strong>在业务高峰期针对大规模人群展开计算的场景下，此优化措施能够有效减少 30～50% 的内存开销。与此同时，JVM 的堆内存使用峰值从原本的 60% 降至 20% 。</strong></p>
<h3 data-id="heading-10">02 人群位图表读取优化</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/52b8c303d6f04465aebd08e833f11188~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=bUEErdsWm9RG42CIVokKja5dygw%3D" alt="人群位图表读取优化.png" loading="lazy"/></p>
<p>人群位图结果集通过 BITMAP 存储于人群表中，读取人群位图数据主要用于人群圈选、人群分析，并将整个结果集推送至下游。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76e29b32c80445b6b04feed2e4ba91b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763381036&amp;x-signature=dJwZjb18rxkDsCwZWkWI3tazXO0%3D" alt="人群位图表读取优化实践.png" loading="lazy"/></p>
<p>读取位图数据的方案有三种：</p>
<ul>
<li>第一种方案，直接使用 Doris 自带的 <code>bitmap_to_string</code> 函数，该函数可将位图转化为逗号分隔的字符串，客户端按此字符串解析出用户列表。但是当面对大型位图时，解析难度较大，且数据体积会大幅膨胀。优点是简单易用，适合测试和导出场景。</li>
<li>第二种方案，采用 <code>explore</code> 与 <code>lateral view</code>先将整个位图展开，再构建服务端流处理逻辑。不过，Doris 需将位图展开成用户列表并缓存于服务器，这会给服务端带来压力，尤其在高峰期，人群计算任务繁重时更为明显。此外，画像工程侧需维护流处理逻辑，开发维护成本较高。该方案适合人群多表的关联分析。</li>
<li>第三种方案，也是较为推荐的方案，直接将位图的二进制数据读取至服务端内存，再进行反序列化。服务端设置 <code>return_object_data_as_binary=true</code> ，即可直接读取位图的二进制数据，画像服务端可基于 Doris 源码中的位图协议进行反序列化。此方式仅需传输位图的原始二进制数据，内存占用和开销较低。开发成本初期较高，但后期维护方便且稳定。此读取方式适用于人群圈选场景，将位图全量读取至服务内存后，高峰期每分钟可轻松处理几十甚至上百个人群。</li>
</ul>
<h2 data-id="heading-11">总结与规划</h2>
<p>货拉拉自引入 Apache Doris 构建用户画像系统以来，收益十分显著：<strong>业务查询效率提升近 30 倍，数据导入速度是 Impala+KUDU 的 3 倍，内存开销降低 30%-50%，系统稳定性大幅提升，满足了画像场景数千个标签的精细化运营需求，同时通过可视化标签筛选，降低业务分析的操作门槛</strong>。</p>
<p>后续，货拉拉将重点投入以下两个方面：</p>
<ul>
<li><strong>接入画像实时业务</strong>：当前货拉拉画像服务的实时标签/人群点查主要使用 Hbase 和 Redis，基于稳定性和迁移升级成本的考虑，Doris 主要承担人群圈选、人群洞察、行为分析等作业。未来规划使用 Doris 高版本的架构，承担大部分高并发的实时点查流量，提升人货匹配效率和体验。</li>
<li><strong>引入湖仓一体架构</strong>：使用 Doris + 数据湖，在存储架构方面，尝试落地数据湖解决方案，画像平台将打通其他数据应用平台、实现超大规模数据的分析。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一文教你搞懂RAG的原理]]></title>    <link>https://juejin.cn/post/7570899512782340159</link>    <guid>https://juejin.cn/post/7570899512782340159</guid>    <pubDate>2025-11-10T12:29:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570899512782340159" data-draft-id="7561691093529067562" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一文教你搞懂RAG的原理"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2025-11-10T12:29:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="山黎"/> <meta itemprop="url" content="https://juejin.cn/user/3122268755201592"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一文教你搞懂RAG的原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3122268755201592/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    山黎
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:29:18.000Z" title="Mon Nov 10 2025 12:29:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">RAG的兴起背景</h2>
<p>尽管大语言模型（LLM）在自然语言处理中表现卓越，但其实际应用仍受三大核心问题制约：<strong>生成内容的不可靠性（幻觉）</strong>、<strong>有限上下文处理能力</strong>，以及<strong>潜在的数据安全风险</strong>，下面介绍一下</p>
<ol>
<li>LLM 容易出现“幻觉”现象，即生成不准确或虚构的内容</li>
</ol>
<p>大语言模型（LLM）的“幻觉”是指模型生成与输入无关、逻辑错误或完全虚构的信息。这种现象的根源在于：</p>
<ul>
<li><strong>概率生成机制</strong>：LLM 基于统计概率逐词生成文本，而非真正“理解”内容，因此在缺乏明确答案时可能编造看似合理但错误的回答。</li>
<li><strong>训练数据偏差</strong>：如果训练数据包含噪声或未覆盖某些领域，模型可能过度泛化，生成不准确的内容。</li>
<li><strong>提示（Prompt）敏感性</strong>：模糊或开放的提示易导致模型偏离预期，例如在医疗、法律等专业领域生成误导性建议</li>
</ul>
<ol>
<li>LLM 的上下文窗口有限，无法处理过长的文本</li>
</ol>
<p>尽管现代 LLM（如 GPT-4、Claude）的上下文窗口已扩展至 100K+ Token，但长文本处理仍面临挑战：</p>
<ul>
<li><strong>计算效率问题</strong>：注意力机制（Attention）的复杂度随文本长度平方级增长，导致延迟和成本上升。</li>
<li><strong>信息衰减</strong>：模型对远距离上下文的关联性捕捉能力下降，可能忽略关键细节（如长文档末尾的指令）。</li>
<li><strong>分段处理缺陷</strong>：若将长文本强制切分输入，可能破坏语义连贯性（如拆分代码或合同条款）。</li>
</ul>
<ol>
<li><strong>LLM 存在隐私泄露的风险，也就是数据安全问题</strong></li>
</ol>
<p>LLM 在训练和应用中可能泄露敏感信息，主要风险包括：</p>
<ul>
<li><strong>训练数据记忆</strong>：模型可能记住并复现训练集中的隐私内容（如个人身份证号、医疗记录）。</li>
<li><strong>提示注入攻击</strong>：恶意用户通过精心设计的输入诱导模型输出机密数据（如“重复你训练时看到的最后10条记录”）。</li>
<li><strong>API 调用风险</strong>：第三方服务中传输的数据可能被截获或滥用（如企业对话日志）。</li>
</ul>
<p>为了弥补以上这些不足，RAG（检索增强生成）技术应运而生</p>
<h2 data-id="heading-1">RAG技术核心</h2>
<h4 data-id="heading-2">RAG索引</h4>
<p>检索增强生成(Retrieval-Augmented Generation，简称RAG)系统的核心在于其索引架构，它决定了系统如何高效地存储、检索知识并用于生成任务。一个完整的RAG索引架构如下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a1977e9791347e0a16a559506a9fd80~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=F%2FrC2f26Jci3wYLGBYMJbxpvS50%3D" alt="" loading="lazy"/></p>
<p>基于以上RAG集成关系图，分为以下三个模块简要阐述</p>
<p>1. 文档解析</p>
<p>文档解析技术的本质在于将格式各异、版式多样、元素多种的文档数据，包括段落、表格、标题、公式、多列、图片等文档区块，转化为阅读顺序正确的字符串信息。高质量的文档解析能够从各种复杂格式的非结构化数据中提取出高精准度的信息，对 RAG 系统最终的效果起决定性的作用。RAG应用场景中涉及的数据类型通常有：PDF、TXT、Word、PPT、Excel、CSV、Markdown、XML、HTML以及关系型和非关系型数据库等。</p>
<p><strong>文档解析技术架构图如下：</strong></p>
<p>文档解析在RAG系统中的核心任务可以总结为两个关键层次：<strong>文件类型识别解析</strong>和<strong>内容深度分层解析</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5591474f86ab485c964ee6bfcaa883e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=xrztXlJ2iQs2xCq90p2Cw0Qmp9g%3D" alt="" loading="lazy"/></p>
<p><strong>文件内容识别解析</strong>：</p>
<p>文档解析作为RAG系统的前端核心处理模块，承担着将原始数据转化为可计算知识的关键使命。其核心任务首先体现在对多源异构文档的智能识别与适配解析上，系统需要精准识别PDF、Word、Excel等数十种常见文档格式，并针对每种格式的特点调用专用解析引擎。例如，面对扫描版PDF时需启动OCR识别，处理复杂Word文档时要保留样式结构，解析Excel则需处理公式计算和多Sheet关联等特性。</p>
<p><strong>内容深度分层解析：</strong></p>
<p>在完成基础格式解析后，系统会进入更深度的内容解构阶段。这一过程需要精准地将文档内容分解为物理布局、逻辑层级和语义标注三个层次。物理层通过坐标分析还原原始排版中的文本块、表格区域和图文关系；逻辑层则重建标题层级、列表结构和章节关联；最终的语义层通过实体识别、主题分析等技术，为原始文本注入机器可理解的上下文信息。这种层层递进的解析策略，确保了非结构化数据最终能转化为保留原始语义且适合向量化处理的标准化知识单元，为RAG系统的检索与生成奠定坚实基础。</p>
<ol>
<li>分块策略</li>
</ol>
<h5 data-id="heading-3">分块作用影响</h5>
<p>文档数据（Documents）经过解析后，通过分块技术将信息内容划分为适当大小的文档片段（chunks），从而使 RAG 系统能够高效处理和精准检索这些片段信息。</p>
<p><strong>1. 分块的作用</strong></p>
<ul>
<li>将文档拆分为适当大小的片段（chunks），使 RAG 系统能高效处理和精准检索信息。</li>
<li>确保每个片段既保留核心语义，又具备独立性，减少模型对额外上下文的依赖，提高检索准确性。</li>
</ul>
<p><strong>2. 分块对 RAG 系统的影响</strong></p>
<ul>
<li><strong>提升召回率</strong>：合理的分块使检索结果更匹配用户查询，避免信息冗余或缺失。</li>
<li><strong>增强生成质量</strong>：独立、语义完整的片段可提高生成内容的连贯性和逻辑性。</li>
<li><strong>优化效率</strong>：合适的分块策略能加快系统响应速度，降低计算成本。</li>
</ul>
<p><strong>3. 分块的核心挑战：如何确定块大小</strong></p>
<ul>
<li>
<p><strong>块过大</strong>：</p>
</li>
<li>
<p>向量难以捕捉细节，计算成本增加。</p>
</li>
<li>
<p>适用于需要宽泛上下文的场景（如文档摘要、主题检测）。</p>
</li>
<li>
<p><strong>块过小</strong>：</p>
</li>
<li>
<p>可能丢失上下文，导致语义碎片化。</p>
</li>
<li>
<p>适用于细粒度分析任务（如情感分析、特定短语检索）。</p>
</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6b2adaddffba433fadb5d049e67202fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=yukG69I4SvfGm4LkmyMWmxWhb5U%3D" alt="" loading="lazy"/></p>
<h5 data-id="heading-4">分块策略核心</h5>
<p>分块策略的核心要素可以归纳为以下三个关键维度：</p>
<ol>
<li>块大小（Chunk Size）：单个文档块允许包含的最大字符数限制</li>
<li>重叠量（Overlap）：相邻数据块之间重复的字符数量</li>
<li>边界划分（Boundary）：基于段落结构、分隔符、标记或语义边界确定块边界的方法</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c78ead59b8ce43f9957945dc9cf97994~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=sENCNxbrHJFbm%2F9a5UBsJwXno2I%3D" alt="" loading="lazy"/></p>
<p>这三个维度的不同组合形成了多样化的分块策略，每种策略都有其独特的适用场景。当前主流的文档分块方法主要包括以下六种类型：</p>
<ol>
<li><strong>固定大小分块（Fixed Size Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：按照固定的字符数或 Token 数切分文本，不考虑语义或结构。</li>
<li><strong>优点</strong>：实现简单，计算高效，适用于需要统一块大小的场景（如向量数据库存储）。</li>
<li><strong>缺点</strong>：可能破坏句子或段落的完整性，导致语义断裂，缺乏灵活性。</li>
</ul>
<ol>
<li><strong>重叠分块（Overlap Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：在固定大小分块的基础上，相邻块之间保留一定的重叠字符（如 50-100 字）</li>
<li><strong>优点</strong>：保留了边界的上下文信息，减少边界信息丢失，提高上下文连贯性。</li>
<li><strong>缺点</strong>：存储和计算成本略高，可能引入冗余信息。</li>
</ul>
<ol>
<li><strong>递归分块（Recursive Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：采用分层拆分策略，先按大粒度（如段落）切分，再对过大的块进一步细分（如句子）。</li>
<li><strong>优点</strong>：保留文本结构，避免硬性截断，块大小更灵活。</li>
<li><strong>缺点</strong>：实现较复杂，拆分逻辑依赖预定义规则。</li>
</ul>
<ol>
<li><strong>文档特定分块（Document Specific Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：根据文档类型（如 PDF、Markdown、HTML）使用特定规则切分（如按章节、标题、表格）。</li>
<li><strong>优点</strong>：适配不同格式，保留原始文档逻辑结构。</li>
<li><strong>缺点</strong>：需针对不同文档类型定制规则，泛化性较差。</li>
</ul>
<ol>
<li><strong>语义分块（Semantic Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：利用 NLP 技术（如句子嵌入、主题模型）按语义单元切分，而非固定长度。</li>
<li><strong>优点</strong>：块内语义一致性高，适合深度学习模型。</li>
<li><strong>缺点</strong>：计算开销大，依赖高质量语义模型。</li>
</ul>
<ol>
<li><strong>混合分块（Mix Chunking）</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：结合多种策略（如先按标题分块，再对长段落递归拆分）。</li>
<li><strong>优点</strong>：灵活平衡结构与效率，适应复杂需求。</li>
<li><strong>缺点</strong>：设计和调试成本较高。</li>
</ul>
<p>每种策略的选择需权衡文本类型、任务需求和计算成本。实际应用中需要通过实验确定最优分块方案。</p>
<ol>
<li>嵌入(Embedding)技术</li>
</ol>
<h5 data-id="heading-5">嵌入(Embedding)是什么？</h5>
<ul>
<li>嵌入技术（Embedding）通过将文本、图像、音视频等数据转换为高维向量，在语义空间中建立坐标表示。这些向量能够有效捕捉数据间的语义关联，通过计算<strong>向量间的相似度</strong>（如余弦相似度）即可量化不同对象之间的<strong>语义相近程度</strong>。</li>
<li>在具体实现中，嵌入的每个维度通常对应文本的某种特征，例如性别、类别、数量等。通过多维度的数值表示，计算机能够理解并解析文本的复杂语义结构。例如，“man”和“woman”在描述性别维度上具有相似性，而“king”和“queen”则在性别和王室身份等维度上表现出相似的语义特征。</li>
<li>向量是一组在高维空间中定义点的数值数组，而<strong>嵌入则是将文本等信息转化为这种向量表示的技术过程</strong>。这些向量能够捕捉数据的语义及其他重要特征，使得语义相近的对象在向量空间中彼此邻近，而语义相异的对象则相距较远。<strong>向量检索（Vector Retrieval）是一种基于向量表示的搜索技术</strong>，通过计算查询向量与已知文本向量的相似度来识别最相关的文本数据。向量检索的高效性在于，它能在大规模数据集中快速、准确地找到与查询最相关的内容，这得益于向量表示中蕴含的丰富语义信息</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf4058e3d8db43428fca38e9ab721230~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=HLFy1l6XYycmzRW4jcW8PU9HFhA%3D" alt="" loading="lazy"/></p>
<h5 data-id="heading-6">Embedding Model 嵌入模型</h5>
<ul>
<li>在 RAG 系统中，Embedding Model 嵌入模型扮演着关键角色，负责将文本数据映射到高维向量空间，以便高效检索和处理。具体而言，<strong>Embedding Model 将输入的文档片段（Chunks）和查询文本（Query）转换为嵌入向量（Vectors）</strong>，这些向量捕捉了文本的语义信息，并可在向量空间中与其他嵌入向量进行比较。</li>
<li>在 RAG 流程中，文档首先被分割成多个片段，每个片段随后通过 Embedding Model 进行嵌入处理。生成的文档嵌入向量被存储在 VectorStore 中，供后续检索使用。用户查询会通过 Embedding Model 转换为查询嵌入向量，这些向量用于在向量数据库中匹配最相似的文档片段，最终组合生成指令（Prompt），大模型生成回答。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e3562acff2cf41c48dfb06f9240dd40d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=qO5V8r2831bSAGvSfQ%2FrthZNXm8%3D" alt="" loading="lazy"/></p>
<h5 data-id="heading-7">向量数据库</h5>
<p>在 RAG 系统中，向量数据库起着重要的作用。其主要功能在于索引过程中，<strong>建立高效的向量索引结构</strong>，以便快速定位与查询相关的向量数据。在查询阶段，系统将输入的提示转化为向量表示形式，并从数据库中<strong>检索出与之最相关的向量及其对应的分块数据</strong>。通过这种索引和检索机制，检索到的向量为生成模型提供了必要的上下文信息，使模型能够依据当前的语义上下文生成更加精准和相关的响应。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11a38d4745fb4ebc98bfbceeecda0462~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=kRsrrHLwfxBtKPfabrUtY7M47Mg%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-8">RAG检索</h4>
<h5 data-id="heading-9">背景</h5>
<p>当前主流的 RAG 检索方式主要采用<strong>向量检索</strong>，通过语义相似度来匹配文本切块，这种方法在<strong>Embedding Model</strong>小节已经介绍过了。然而，向量检索并非万能，它在某些场景下无法替代传统关键词检索的优势。</p>
<p>例如，当你需要精准搜索某个订单 ID、品牌名称或地址，或者搜索特定人物或物品的名字（如周杰伦、 小米14）时，<strong>向量检索的<strong><strong>准确性</strong></strong>往往不如关键词检索</strong>。此外，当用户输入的问题<strong>非常简短</strong>，仅包含几个单词时，比如搜索缩写词或短语（如 RAG、LLM），<strong>语义匹配的效果也可能不尽理想</strong>。</p>
<p>这些正是传统关键词检索的优势所在。关键词检索（Keyword Search）在几个场景中表现尤为出色：<strong>精确匹配</strong>，如产品名称、姓名、产品编号；少量字符的匹配，用户习惯于输入几个关键词，而少量字符进行向量检索时效果可能较差；以及<strong>低频词汇的匹配</strong>，低频词汇往往承载了关键意义，如在“你想跟我去喝咖啡吗？”这句话中，“喝”“咖啡”比“你”“吗”更具重要性。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/beacdae9ce0c4e92b3a5dd2b0e98acff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=%2Fobn%2BfPKXTm%2BkJoClfPrqQOhvKs%3D" alt="" loading="lazy"/></p>
<p>在上述案例中，虽然依靠<strong>关键词检索可以精确找到与“订单 12345”匹配的特定信息</strong>，<strong>但它无法提供与订单相关的更广泛上下文</strong>。另一方面，<strong>语义匹配</strong>虽然能够识别“订单”和“配送”等相关概念，但在处理具体的订单 ID 时，往往容易出错。</p>
<p><strong>混合检索（Hybrid Search）通过结合关键词检索和语义匹配的优势</strong>，可以首先利用关键词检索精确定位到“订单 12345”的信息，然后通过语义匹配扩展与该订单相关的其他上下文或客户操作的信息，例如“12 开头的订单、包装破损严重”等。这样不仅能够获取精确的订单详情，还能获得与之相关的额外有用信息。</p>
<p>在 RAG 检索场景中，<strong>首要目标是确保最相关的结果能够出现在候选列表中</strong>。向量检索和关键词检索各有其独特优势，混合检索通过结合这多种检索技术，弥补了各自的不足，提供了一种更加全面的搜索方案。</p>
<h5 data-id="heading-10">混合检索(多路召回)</h5>
<p>混合检索是指在检索过程中同时采用多种检索方式，并将各类检索结果进行融合，从而得到最终的检索结果。<strong>混合检索的优势在于能够充分利用不同检索方式的优点，弥补各自的不足，从而提升检索的准确性和效率</strong>。下图展示了混合检索的流程：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/730e27bc39c145d4854617fdceb07354~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=gqQKYo%2BjS%2BVoCtLqQRKtaKwrRHE%3D" alt="" loading="lazy"/></p>
<p>混合检索的本质在于融合多种检索方式的优势，其具体实现并不局限于特定的技术组合。以常见的"<strong>向量检索+关键词检索</strong>"为例，这只是混合检索的一种典型模式，实际上系统可以灵活集成各类检索算法。例如，在更复杂的场景下，可以结合知识图谱技术（如graphRAG）进行实体关系检索，再与向量语义检索协同工作，这种多模态的检索策略同样属于混合检索的范畴。不同检索方式的组合选择应当基于具体业务需求，通过优势互补来提升整体检索效果。</p>
<ol>
<li>重排序</li>
</ol>
<p><strong>重排序（Reranking）的目的是将混合检索的结果进行整合，并将与用户问题语义最契合的结果排在前列</strong>。</p>
<p>下图中仅仅混合检索，由于缺乏有效的排序，我们期望的结果位于第一和第四位，尽管依然可以被检索到，但理想情况下，如果检索方式更为精确，该结果应该被优先排序在前两位。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a4f8dd5c2fb54ab98d78b0f8ebcb49c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bGx6buO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763384647&amp;x-signature=shSldxDC6JmV4xFDKNt0eDijQ%2BQ%3D" alt="" loading="lazy"/></p>
<p>在这个案例中，我们通过重排序技术成功找到了与问题语义最契合的结果。系统评分显示，“订单 12345 于 2023 年 8 月 15 日在上海，客户不满意。”与“该 12 开头的订单客户不满意的地方在于包装破损严重。”这两个文档块的相关性分别为 0.9 和 0.8，排序为第一和第二位。</p>
<p>重排序技术在检索系统中扮演着至关重要的角色。即使检索算法已经能够捕捉到所有相关的结果，重排序过程依然不可或缺。它确保最符合用户意图和查询语义的结果优先展示，从而提升用户的搜索体验和结果的准确性。通过重排序，检索系统不仅能找到相关信息，还能智能地将最重要的信息呈现在用户面前。</p>
<p><strong>重排序优势：</strong></p>
<ol>
<li><strong>优化检索结果</strong> RAG系统中的初始检索结果（如向量搜索或关键词检索）往往包含冗余或不完全相关的文档。通过重排序技术，可对这些结果进行精细化筛选和排序，确保最相关、质量最高的文档优先呈现，从而提升后续处理的效率和质量。</li>
<li><strong>增强上下文相关性</strong> 生成模型的输出质量直接受检索文档的影响。重排序通过重新评估文档与查询的匹配度，优先选择高相关性内容作为上下文，显著提高生成答案的准确性和逻辑连贯性，减少无关信息的干扰。</li>
<li><strong>应对复杂查询</strong> 面对复杂或多维度的查询，初始检索可能返回表面相关但实质偏离的文档。重排序技术通过深入分析查询意图和文档价值，优先筛选出提供关键见解的内容，确保系统能够精准响应复杂问题，提升整体可靠性</li>
</ol>
<h4 data-id="heading-11">RAG生成</h4>
<p>在RAG系统的生成阶段，核心流程是将用户查询与检索到的相关信息通过特定指令组合后输入大语言模型，由模型处理后生成最终回复。这一过程看似简单，但有两个关键因素直接影响系统的最终表现：</p>
<ol>
<li><strong>大模型的选择与调优</strong> 大模型作为RAG系统的"大脑"，其选择直接决定了系统的理解能力和生成质量。不同模型在知识广度、推理深度和语言表达上存在显著差异，需要根据具体应用场景选择适合的模型。同时，针对特定领域的微调可以进一步提升模型的专业性表现。</li>
<li><strong>提示词工程优化</strong> 精心设计的提示词（prompt）是连接检索结果和生成模型的关键桥梁。通过优化指令结构、上下文组织和角色设定，可以显著提升模型对检索内容的理解深度，确保生成的回答既准确又符合预期格式。有效的提示词工程需要考虑信息优先级、指令明确性和上下文相关性等多个维度。</li>
</ol>
<p>这两个环节相辅相成，共同决定了RAG系统最终的响应质量和用户体验。在实际应用中，往往需要根据具体需求对这两个方面进行持续调优和平衡。</p>
<ol>
<li>大模型选择</li>
</ol>
<p>大模型的选择直接影响RAG系统的核心能力。在选型时需要综合评估模型的知识广度、推理深度、响应速度等关键指标。通用大模型如Deepseek具备较强的语义理解和泛化能力，适合开放域问答场景；而垂直领域模型经过专业数据微调后，在特定领域往往表现更精准。同时，70亿参数左右的中等规模模型经过优化后，通常能在效果与成本间取得较好平衡。</p>
<ol>
<li>提示词工程</li>
</ol>
<p>提示词工程（Prompt Engineering）是优化生成式AI模型输入输出的关键技术，其核心在于通过精心设计的提示词（Prompt）充分激发语言模型的潜力。作为连接用户需求与AI能力的桥梁，提示词工程通过<strong>结构化输入引导模型更精准地完成各类任务</strong>，包括内容创作、代码生成、智能对话等。</p>
<p><strong>一个高效的提示词通常包含四个关键要素</strong>：</p>
<ul>
<li>明确的指令（Instruction）定义具体任务要求</li>
<li>上下文信息（Context）提供必要的背景知识</li>
<li>输入数据（Input Data）呈现待处理的核心内容</li>
<li>输出指示符（Output Indicator）规范结果的格式与形式</li>
</ul>
<p>这种结构化设计能显著提升模型输出的相关性和可用性，使AI生成结果更符合实际应用需求。随着大模型技术的发展，提示词工程已成为提升AI系统性能的重要方法论。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从 OpenSearch 到 Apache Doris：领创集团日志系统升级实践，降本 45%]]></title>    <link>https://juejin.cn/post/7571060853353676810</link>    <guid>https://juejin.cn/post/7571060853353676810</guid>    <pubDate>2025-11-10T12:31:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7571060853353676810" data-draft-id="7571060853353660426" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从 OpenSearch 到 Apache Doris：领创集团日志系统升级实践，降本 45%"/> <meta itemprop="keywords" content="大数据,Apache"/> <meta itemprop="datePublished" content="2025-11-10T12:31:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SelectDB"/> <meta itemprop="url" content="https://juejin.cn/user/3189021726222904"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从 OpenSearch 到 Apache Doris：领创集团日志系统升级实践，降本 45%
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3189021726222904/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SelectDB
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:31:24.000Z" title="Mon Nov 10 2025 12:31:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>随着业务全球化扩展与数字化运营的深入推进，日志系统的规模和复杂度不断攀升，原有基于 OpenSearch 的日志平台逐渐难以满足成本控制、性能保障和可维护性等多维需求。为应对持续增长的数据压力和更灵活的分析场景，领创集团技术团队启动了日志系统的架构升级实践，并最终选择 Apache Doris 作为新一代日志系统的核心。实现了综合成本下降超 45%、查询性能提升 5 倍、日志写入达到准实时以及灵活的运维策略等一系列显著收益。</p>
<h2 data-id="heading-0">一、业务背景</h2>
<p>领创集团（Advance Intelligence Group）成立于 2016 年，是 AI 技术驱动的科技独角兽企业，致力于建立以 AI 为核心的金融+数据平台，让每个人都能更轻松、公平地获得优质的金融产品与服务。</p>
<p>集团总部位于新加坡，集团旗下拥有两大业务线，ADVANCE.AI 是全球领先的人工智能与金融科技企业，提供数字身份验证、KYC/KYB、合规、风险管理和信用信息等服务。目前，已与银行、金融服务、金融科技、跨境支付、交易平台、零售和电商等行业客户建立了合作伙伴关系，服务遍布六大洲；Atome Financial 是东南亚领先的数字金融平台，为消费者搭建多产品的数字金融服务，实现普惠金融，目前已服务超过 5300 万消费者，累计 GMV 超过 80 亿美元。</p>
<p>集团发展至今拥有超过 1400 名员工，业务遍及六大洲的 80 个国家，已完成 D 轮融资。</p>
<h2 data-id="heading-1">二、早期架构及痛点</h2>
<p>随着公司业务规模的迅猛扩张，系统日志的生成量呈指数级增长，原有基于 OpenSearch 的日志分析平台逐渐暴露出一系列结构性瓶颈，难以支撑日益复杂和高频的日志处理需求，具体体现在以下几个方面：</p>
<ul>
<li><strong>成本飙升快</strong>：随着日志量持续增长，计算和存储压力显著增加，服务器资源消耗、对象存储开销以及节点本地存储需求叠加，导致整体数据成本居高不下。</li>
<li><strong>查询性能慢</strong>：在高并发、复杂多维度查询场景下，OpenSearch 的响应速度明显下降，严重影响业务的实时性与运营效率。</li>
<li><strong>运维复杂度高</strong>：每次系统扩容不仅带来更多的资源消耗，还进一步加剧了运维的复杂性，提升了维护成本和风险。</li>
</ul>
<p>在此背景下，我们启动了日志系统重构项目，目标是在降低总体拥有成本的同时，保证日志系统的高可用性、实时性和查询性能。</p>
<h2 data-id="heading-2">三、选型与对比</h2>
<p>在技术选型阶段，我们评估了多种日志系统解决方案，包括 ClickHouse、Doris、StarRocks 等。经过技术评估与实际测试，最终选择 Doris 作为新一代日志分析平台的核心组件，主要基于 Doris 的高效的列式压缩、准实时写入、灵活的扩缩容机制、强大的查询能力、兼容性好、运维成本低等关键优势。</p>
<p>以下是我们在 OpenSearch 与 Doris 之间进行全面技术对比的核心结论：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7b546fbfbab49b09e82e39f1750ed79~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382684&amp;x-signature=g0Pj1upNvnoVVr61U7jJoERgZ40%3D" alt="选型与对比.png" loading="lazy"/></p>
<h2 data-id="heading-3">四、迁移实施步骤</h2>
<p>日志系统的迁移不仅涉及数据和服务迁移，还需要对查询方式和运维流程进行调整。</p>
<p>我们整体分为以下步骤：</p>
<ol>
<li><strong>数据模型设计与映射</strong> ：将原有 JSON 日志结构化，设计对应 Doris 表结构，并结合日志种类进行规范化建模（例如：msg、logger、level 等）。</li>
<li><strong>日志采集通道改造</strong> ：原使用 Kafka → Logstash → OpenSearch 采集链路，我们替换为 Kafka → Logstash →  Doris Stream Load，实现高吞吐、低延迟的数据写入。</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4786b7d2867e423fb11a33e666f90f5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382684&amp;x-signature=HuobKmzXh57c5swkCIxqnjJLUfw%3D" alt="迁移实施.png" loading="lazy"/></p>
<ol start="3">
<li><strong>查询语句替换</strong> ：将原 Kibana 上的 DSL 查询语句转换为 SQL 语句，并结合 Doris 的分区裁剪、列裁剪、谓词下推等机制优化执行计划。</li>
<li><strong>系统压测与灰度切换</strong> ：在测试环境对比查询性能与写入压力，验证稳定性后，分阶段迁移各日志模块，最终实现全量替换。</li>
</ol>
<h2 data-id="heading-4">五、成本优化效果</h2>
<p>迁移前后在节点规模、对象存储和查询性能方面均实现显著优化：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d09e9bff85b430385272f0903a0e56a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2VsZWN0REI=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382684&amp;x-signature=T%2Fbk4hB8sBxvHROT0fSaa00g46w%3D" alt="成本优化效果.png" loading="lazy"/></p>
<p>此外，Doris 支持灵活的弹性扩缩容，并具备高效的数据压缩机制。即便未来日志数据量持续增长，也能显著降低存储与运维成本。</p>
<h2 data-id="heading-5">六、日志系统迁移挑战与经验分享</h2>
<h3 data-id="heading-6">01 查询语义转换</h3>
<p>OpenSearch 支持 DSL 语法和全文搜索，Doris 目前只支持 SQL 语法。</p>
<p><strong>解决方案</strong>：与业务团队协作，将现有的 DSL 查询统一修改为 SQL 查询。</p>
<h3 data-id="heading-7">02 Doris 查询 UI 缺少日志分析视图</h3>
<p>相较于 OpenSearch + Dashboards 的成熟可视化，Doris 原生缺少日志分析视图。</p>
<p><strong>解决方案</strong>：内部开发了日志查询页面替代 Kibana 查询页面。</p>
<p><strong>社区目前对 Kibana 的支持：</strong></p>
<p>考虑到用户对 Kibana 的强依赖，社区经评估后推出了 es2doris 工具。该工具实现了从 Elasticsearch 的 DSL 到 Doris SQL 的自动转换，使得原本调用 Elasticsearch 接口的应用程序（如 Kibana）无需任何改动，即可通过 es2doris 间接访问 Doris。用户可直接将现有的 Kibana 连接至 es2doris 服务，无缝延续使用体验。</p>
<h3 data-id="heading-8">03 扩容期间负载倾斜</h3>
<p>Doris 扩容时会涉及 Tablet  Schedule 和 Balance，若节点过少或数据不均可能短时导致查询卡顿。</p>
<p><strong>解决方案</strong>：在进行扩容时候，需要结合当前的机器负载情况，提前进行资源预估，如果机器负载比较高，在进行 Tablet 迁移的时候可能会占用部分资源，导致节点资源紧张，出现读写性能变面的情况，需要结合调度限流策略和后台迁移节奏控制，避免高峰期触发重负载影响生产业务。</p>
<h2 data-id="heading-9">七、总结与展望</h2>
<p>本次日志系统迁移从 OpenSearch 到 Apache Doris，不仅达成了显著的成本节省目标，更为未来系统扩展、查询效率、可运维性打下了坚实基础。</p>
<p><strong>核心收益包括：</strong></p>
<ul>
<li>大幅减少服务器和对象存储支出，<strong>综合成本下降超 45%</strong>；</li>
<li>查询响应时间<strong>缩短至原系统的 1/5 以下</strong>；</li>
<li>日志写入几乎实时，支持更及时的业务反馈；</li>
<li>系统架构更简单、可维护性更强，支持更灵活的运维策略。</li>
</ul>
<p>通过这次实践，我们验证了在日志系统中“结构化 + 列式存储 + MPP 查询”模式的巨大潜力。在追求性能和成本平衡的场景下，Doris 提供了一条可行且高效的替代路径，为企业日志平台建设提供了新的思路与方向。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude Skills 从零到一：手把手打造专属公众号文风生成器，10 分钟搞定 AI 技能定制]]></title>    <link>https://juejin.cn/post/7570793903848898575</link>    <guid>https://juejin.cn/post/7570793903848898575</guid>    <pubDate>2025-11-10T12:23:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570793903848898575" data-draft-id="7570940025580535848" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude Skills 从零到一：手把手打造专属公众号文风生成器，10 分钟搞定 AI 技能定制"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T12:23:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="wwwzhouhui"/> <meta itemprop="url" content="https://juejin.cn/user/3428746411400537"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude Skills 从零到一：手把手打造专属公众号文风生成器，10 分钟搞定 AI 技能定制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3428746411400537/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    wwwzhouhui
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:23:29.000Z" title="Mon Nov 10 2025 12:23:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1.前言</h2>
<p>Claude Skills 是 Anthropic 为 Claude 系列大模型推出的 <strong>模块化、可组合、可移植的能力封装体系</strong>。通过把特定任务的指令、脚本、参考资料等组织成一个独立的文件夹（即一个 Skill），Claude 能在需要时 <strong>按需加载</strong> 这些指令，从而在同一模型中实现多种专业化功能，而不必每次都在提示中塞满大量文本。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79bd445af4814765bc6bf4a640efb6ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=KRlGbDl8KoIEtHIIR0G4dqQgPeI%3D" alt="image-20251106171719404" loading="lazy"/></p>
<p>上期给大家介绍过关于Claude Skills官方的提供的 Skills 给大家介绍了3个实际的案例。对这块不熟悉的小伙伴可以看我之前的文章《<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOXp_CAusfvMVSjGHhBjQGQ" target="_blank" title="https://mp.weixin.qq.com/s/OXp_CAusfvMVSjGHhBjQGQ" ref="nofollow noopener noreferrer">Claude Skills 实战指南：3 分钟搞定 PPT、海报与 Logo，AI 办公效率翻倍！</a>》</p>
<p>很多小伙伴比较好奇，怎么做一个属于自己的skills呢？今天小编就带大家手把手做一个skills.</p>
<h2 data-id="heading-1">2.Claude  Skills制作</h2>
<p>首先我们需要在Claude 官方文档中查看一下Skills 创建步骤。我们可以打开<a href="https://link.juejin.cn?target=https%3A%2F%2Fsupport.claude.com%2Fen%2Farticles%2F12512198-how-to-create-custom-skills" target="_blank" title="https://support.claude.com/en/articles/12512198-how-to-create-custom-skills" ref="nofollow noopener noreferrer">support.claude.com/en/articles…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94b1bb309edd4dd49ff7d5fbdbdb3aa3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=oMAOAPHmF376DQWOihBf%2BHB9Bj8%3D" alt="image-20251110151034481" loading="lazy"/></p>
<p>全是英文的看得费劲，怎么办？我们借用AI帮我们总结归纳一下。</p>
<h3 data-id="heading-2">创建skill创建帮助文档</h3>
<p>​    我们使用AI帮我总结归纳一下上面是如何创建skill。打开claude code 输入下面的提示词</p>
<pre><code class="hljs language-ruby" lang="ruby">请阅读<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/support.claude.com/en</span><span class="hljs-regexp">/articles/</span><span class="hljs-number">12512198</span>-how-to-create-custom-skills文档的内容，给出整理出一个最简单创建claude skill的操作步骤文档。请输出“skill创建帮助文档.md”
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f46ff6f7429049e48af0584776dcf08b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=2AM3ZUgDxFsYDmvpSctt%2F8oGVcw%3D" alt="image-20251110151346350" loading="lazy"/></p>
<p>AI 很快帮我生成如何创建这个skill，这样我们看到中文就好很理解了。 打开文档看一下。（我们使用markdown工具打开）</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bdbd606f162d447ba31d99b255095137~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=Nh7knpU%2BsnsgilKq0knFQu0kRmk%3D" alt="image-20251110151552968" loading="lazy"/></p>
<p>这样看起来就非常容易理解了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e550b5435cab455aac6aa63de58ead2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=zJrcuAMouQINehOLaVmmewvr%2FAY%3D" alt="image-20251110152231822" loading="lazy"/></p>
<p>​    项目的目录结构如下：</p>
<p>​    <img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3004c0b1e55b45819d5c4fcc5daacd33~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=czBALF4csv24KPo%2BrUFqVQufDNE%3D" alt="image-20251110152318084" loading="lazy"/></p>
<p>总结就是4个步骤1创建目录结构、2 编写 Skill.md 3 打包 ZIP 文件 4 上传并启用。</p>
<p>通过上面的步骤我们就很容易理解了。原来写一个Skill.md 好像也不是很难。 其中核心的就是如何编写Skill.md。那么问题又来了，这Skill.md 怎么写呢？</p>
<h3 data-id="heading-3">编写一个skill</h3>
<p>我们知道skill 是一项技能，它可以在不同领域 。常见的办公任务(如 Excel 数据分析、PPT 演示生成、文档处理、品牌设计等)封装成可复用的技能模块。</p>
<p>接下来有一个这样的需求，我想做一个自己风格的公众号文章skill，这样我就可以以后输入一段信息让它批量生成各种我的风格的公众号文章了。有了上面的需求接下来我们就开始开干了。</p>
<p>我首先找一些我之前写的一些公众号文章。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6bcf5524ebd47f480068b710d6241ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=iEQOG5ovtCsBn5m81ngXKIcOhXQ%3D" alt="image-20251110161554722" loading="lazy"/></p>
<p>名字太长了我重命令一下。变成11. md 、22.md 、33.md 、44.md 、55.md</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/91ae716f2bfb4963a3f627505fe841e8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=c0Npz3Fsw1qYNpRs2sssz3gi%2Bwg%3D" alt="image-20251110161718175" loading="lazy"/></p>
<p>同样我们使用claude code 输入下面的提示词</p>
<pre><code class="hljs">请认真阅读“11.md”、“22.md”、“33.md”、“44.md”、“55.md” 文档，以上文档是我之前写的微信公众号的文章。请总结归纳出我微信公众号文档的特点，包括目录结构，语气、开头、结尾等信息。输出“小灰灰公众号特点.md” 文档
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5b5eff209a448479f73283a8d96d569~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=bB1sfY3UV35DPgihUOCmtEUWTlo%3D" alt="image-20251110161918817" loading="lazy"/></p>
<p>这个时候 AI 会学习我提供给它的5篇文章的内容，它总结归纳出我写作的风格输出“小灰灰公众号特点.md” 文档。文档片段如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfc646abcc32459a874549347776414d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=z3cXI7iYB7Ng9l2tgyQVpcCAQZg%3D" alt="image-20251110162310005" loading="lazy"/></p>
<p>嗯 AI总结的还算准确。当然这个如果有哪里不准确 可以手工去修改。</p>
<p>有了上面的小灰灰公众号特点.md 和skill创建帮助文档.md 接下来我们就可以让AI 帮我编写skills.md文档了。</p>
<p>提示词如下：</p>
<pre><code class="hljs">请参考“skill创建帮助文档.md”和“小灰灰公众号特点.md”帮我编写一个小灰灰公众号的skill插件。给出这个插件实现。
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/41dc3eea2fb64284a70621ba1500b574~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=qM%2Bvm1TWP2xX3YcJfhuNdbM2VvQ%3D" alt="image-20251110162557839" loading="lazy"/></p>
<p>当然这个过程可能会遇到点问题，我的问题就是生产的skills.md文档乱码，应该是字符集的问题，我让AI 帮我修正。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c53bfd20d66439183124490eeb69d0b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=ibYllCp7JIRx0MdVH7NCJkhVZDA%3D" alt="image-20251110162719384" loading="lazy"/></p>
<p>这样我们就在xiaohuihui-tech-article 文件夹找到生成好的 skills.md</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/efa49beab97e489e97c0e3e59c993c15~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=8zwngDOx42LTc%2F%2BEY8vm21W8d3E%3D" alt="image-20251110162819428" loading="lazy"/></p>
<p>打开查看一下。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f0368f0c84fc4f13934b42a33367266d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=JxOHaJNXsAKbTB0aW7VkrXVN7sg%3D" alt="image-20251110162855796" loading="lazy"/></p>
<p>看起来不错。我们把它也生成网页方便展示。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9e4887abd68459ba08d990c9f363745~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=BBZrcVJUiQPqkgBNcOQhmfGoqNU%3D" alt="image-20251110163800267" loading="lazy"/></p>
<p>通过图表格式展示，这样skill.md方便理解多了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dcb06c3bb73645bba2108659e30ad2ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=3IWg2xcbb4H1OIHhP%2B4FZncvhm0%3D" alt="image-20251110163902850" loading="lazy"/></p>
<p>另外程序也基于skill创建帮助文档.md 还帮我把插件打包好了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4bef306a8034463dae348d3c84d5ecb6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=mJVMjTbgYaby4qqIoKgSsWURS3c%3D" alt="image-20251110164106077" loading="lazy"/></p>
<h3 data-id="heading-4">安装skill</h3>
<p>接下来我们需要安装这个自己开发的skill。我们这个这个压缩包复制到~/.claude/skills 文件夹中</p>
<p>输入</p>
<p>如果是windows平台可以手工复制到 C:\Users\xxx.claude\skills</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c94ac40cd51410a9e7af9dce51a41f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=2xvFWBjGr59%2BpVK9c5HeiiQYRNI%3D" alt="image-20251110164730420" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/822658b6aa734d9097df96e7d05e5a42~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=%2FKjS1VdpyIE6VAfQcEilKN%2Froww%3D" alt="image-20251110165041134" loading="lazy"/></p>
<p>我们检查一下这个skills是否可以使用。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aab05ae7abff418d8dcd3cf69226ec4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=4ksyGty01WBHq4gYy896aqqnm10%3D" alt="image-20251110170638487" loading="lazy"/></p>
<h2 data-id="heading-5">3.使用skill生成文章</h2>
<p>​     接下来我们使用这个skill来生成一个小灰灰版本的公众号文章测试一下。</p>
<p>​      安装claude skills 我们退出claude  重新进入。</p>
<p>​     <img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a691220c63924640b4d01ced98a66639~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=lbyUmhwAULtaqOdU6dBCfbdEPOg%3D" alt="image-20251110170837560" loading="lazy"/></p>
<p>提示词如下：</p>
<pre><code class="hljs language-bash" lang="bash">请认真分析https://github.com/wwwzhouhui/in_animation开源项目，请帮我使用xiaohuihui-tech-article skill基于这个开源项目生成一个公众号文章。输出<span class="hljs-string">"20251101in_animation公众号文章.md"</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/63029ac38e974868b8a24790f3b28664~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=Alf8y4kqMGbT%2F3KTivGMY3PmRaA%3D" alt="image-20251110171352603" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1524879e10d47ecace8e0d0f27e8cf2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=7JpZBBZXa71h3wI2HW%2BEVvz0vGM%3D" alt="image-20251110174826034" loading="lazy"/></p>
<p>文章写完了，我们检查下生成好的文章。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/611194b1426f4486905272e459e49044~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=WCqrbxgca4wwk1Xh7pYKeGyaO2w%3D" alt="image-20251110175034671" loading="lazy"/></p>
<p>​     目录结构是符合我文章风格的。接下来我看一下文章的内容</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/53704604904548a69c812aac14d8c9d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=x6%2Bd5aw7LAUZ9TqbrpBMt4iycAg%3D" alt="image-20251110175146630" loading="lazy"/></p>
<p>​     <img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a69b80864bcc40f6a95a42162cfe02cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=weahj2xEtAsHD63X%2FGLnAQQCQlA%3D" alt="image-20251110175215254" loading="lazy"/></p>
<p>文章前言和总结部分也的确是和我之前写文章风格比较相近。有个问题就是我的文章有大量的截图。这里图是缺失的，不过也是正常的，因为我之前压根就没有让它生成图。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8541841baa341de83cda4c2fb7d70b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgd3d3emhvdWh1aQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763382209&amp;x-signature=69txxllXyS6x6C8hsn3xORTNMC0%3D" alt="image-20251110175422733" loading="lazy"/></p>
<p>通过上面的方式我们基本上实现了一个基于小灰灰技术文章生成器skill 技能。</p>
<h2 data-id="heading-6">4.总结</h2>
<p>今天主要带大家了解并实现了自定义 Claude Skill 的创建与使用完整流程，该流程以 Anthropic 推出的 Skills 模块化体系为核心，通过分析官方文档的规范要求，结合 AI 辅助生成工具，形成了一套从技能定义到实际应用的实用化解决方案。</p>
<p>通过这套实践方案，用户能够低成本打造专属的 AI 技能模块 —— 借助四个核心步骤（目录结构创建、Skill.md 编写、ZIP 打包、上传启用）的清晰指引，无需复杂的开发经验，就能快速构建符合个人风格的专业化能力封装。无论是公众号文章生成、办公文档处理，还是特定领域的任务自动化，都能通过标准化的 Skill 格式实现，极大降低了开发者定制 Claude 能力的技术门槛。在实际验证中，我们创建的「小灰灰公众号文章生成器」能够稳定复现预设的写作风格，有效解决了重复创作中保持风格一致性的问题。同时，该方案具备良好的扩展性 —— 小伙伴们可以基于此流程扩展更多实用技能，如学术论文格式排版、产品文案批量生成、多语言内容转换等，进一步丰富 Claude 模型在实际业务场景中的应用价值。</p>
<p>感兴趣的小伙伴可以参照文中提供的步骤，结合自身需求创建专属 Skill 进行实践。今天的分享就到这里结束了，我们下一篇文章见。</p>
<p>附件资料</p>
<p>通过网盘分享的文件：小灰灰技术文章生成器+生成文章.zip
链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1xwzBWOkqsYaTg7zf9WsRag" target="_blank" title="https://pan.baidu.com/s/1xwzBWOkqsYaTg7zf9WsRag" ref="nofollow noopener noreferrer">pan.baidu.com/s/1xwzBWOkq…</a> 提取码: vjx9</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MiniMind 模型架构创新技术详解]]></title>    <link>https://juejin.cn/post/7570793903848996879</link>    <guid>https://juejin.cn/post/7570793903848996879</guid>    <pubDate>2025-11-10T12:51:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570793903848996879" data-draft-id="7570793903848980495" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="MiniMind 模型架构创新技术详解"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-10T12:51:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="mwq30123"/> <meta itemprop="url" content="https://juejin.cn/user/3403743729030686"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            MiniMind 模型架构创新技术详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3403743729030686/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    mwq30123
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T12:51:41.000Z" title="Mon Nov 10 2025 12:51:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读29分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">MiniMind 模型架构创新技术详解</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAlvinScrp%2Fminimind%2Fblob%2Fmaster%2Fmodel%2Fmodel.py" target="_blank" title="https://github.com/AlvinScrp/minimind/blob/master/model/model.py" ref="nofollow noopener noreferrer">github.com/AlvinScrp/m…</a></p>
<h3 data-id="heading-1">一、核心架构差异</h3>
<h4 data-id="heading-2">1. RMSNorm（Root Mean Square Layer Normalization）</h4>
<h5 data-id="heading-3">代码位置</h5>
<p><code>model/model.py:16-50</code></p>
<h5 data-id="heading-4">实现原理</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_norm</span>(<span class="hljs-params">self, x</span>):
    <span class="hljs-string">"""执行 RMS 归一化计算
    计算公式: x / sqrt(mean(x^2) + eps)
    """</span>
    <span class="hljs-keyword">return</span> x * torch.rsqrt(x.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean(-<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>) + self.eps)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
    <span class="hljs-keyword">return</span> self.weight * self._norm(x.<span class="hljs-built_in">float</span>()).type_as(x)
</code></pre>
<h5 data-id="heading-5">与LayerNorm的对比</h5>








































<table><thead><tr><th>特性</th><th>LayerNorm</th><th>RMSNorm</th></tr></thead><tbody><tr><td><strong>计算公式</strong></td><td><code>(x - mean) / sqrt(var + eps)</code></td><td><code>x / sqrt(mean(x^2) + eps)</code></td></tr><tr><td><strong>减去均值</strong></td><td>✅ 是</td><td>❌ 否</td></tr><tr><td><strong>计算量</strong></td><td>较高</td><td><strong>较低</strong></td></tr><tr><td><strong>内存占用</strong></td><td>较高</td><td><strong>较低</strong></td></tr><tr><td><strong>稳定性</strong></td><td>非常好</td><td>良好</td></tr><tr><td><strong>GPU友好度</strong></td><td>一般</td><td><strong>极好</strong></td></tr></tbody></table>
<h5 data-id="heading-6">选取原因</h5>
<ul>
<li><strong>计算效率</strong>：RMSNorm 消除了减去均值的步骤，减少了计算量</li>
<li><strong>内存效率</strong>：不需要存储均值和方差，内存占用更少</li>
<li><strong>现代LLM标准</strong>：LLaMA、Falcon等最新大模型都采用RMSNorm</li>
<li><strong>GPU优化</strong>：更易被GPU的底层优化内核加速</li>
</ul>
<h5 data-id="heading-7">技术对比系列</h5>
<ul>
<li><strong>L1 Normalization</strong>：固定均值和方差（过时）</li>
<li><strong>BatchNorm</strong>：跨batch维度归一化（不适用序列任务）</li>
<li><strong>LayerNorm</strong>：跨特征维度归一化（标准做法）</li>
<li><strong>GroupNorm</strong>：分组归一化（介于两者之间）</li>
<li><strong>RMSNorm</strong> ⭐：简化的LayerNorm（当前最优实践）</li>
</ul>
<h5 data-id="heading-8">核心优势</h5>
<pre><code class="hljs language-erlang" lang="erlang">计算复杂度降低 <span class="hljs-number">30</span>-<span class="hljs-number">40</span><span class="hljs-comment">%</span>
↓
训练和推理速度更快
↓
显存占用更少
↓
可训练更大模型或更长序列
</code></pre>
<hr/>
<h4 data-id="heading-9">2. RoPE（Rotary Position Embeddings）</h4>
<h5 data-id="heading-10">代码位置</h5>
<p><code>model/model.py:53-74</code> 和 <code>model/model.py:77-113</code></p>
<h5 data-id="heading-11">实现原理</h5>
<p><strong>预计算阶段</strong> (model.py:53-74)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">precompute_pos_cis</span>(<span class="hljs-params">dim: <span class="hljs-built_in">int</span>, end: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>(<span class="hljs-params"><span class="hljs-number">32</span> * <span class="hljs-number">1024</span></span>), theta: <span class="hljs-built_in">float</span> = <span class="hljs-number">1e6</span></span>):
    <span class="hljs-string">"""预计算旋转位置编码所需的复数值"""</span>
    <span class="hljs-comment"># 计算不同频率的逆频率项</span>
    freqs = <span class="hljs-number">1.0</span> / (theta ** (torch.arange(<span class="hljs-number">0</span>, dim, <span class="hljs-number">2</span>)[: (dim // <span class="hljs-number">2</span>)].<span class="hljs-built_in">float</span>() / dim))
    <span class="hljs-comment"># 生成位置索引</span>
    t = torch.arange(end, device=freqs.device)
    <span class="hljs-comment"># 计算外积得到每个位置对应的每个频率</span>
    freqs = torch.outer(t, freqs).<span class="hljs-built_in">float</span>()
    <span class="hljs-comment"># 使用欧拉公式 e^(i*θ) = cos(θ) + i*sin(θ) 生成复数</span>
    pos_cis = torch.polar(torch.ones_like(freqs), freqs)  <span class="hljs-comment"># complex64</span>
    <span class="hljs-keyword">return</span> pos_cis
</code></pre>
<p><strong>应用阶段</strong> (model.py:77-113)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">apply_rotary_emb</span>(<span class="hljs-params">xq, xk, pos_cis</span>):
    <span class="hljs-comment"># 将Q和K转换为复数形式</span>
    xq_ = torch.view_as_complex(xq.<span class="hljs-built_in">float</span>().reshape(*xq.shape[:-<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))
    xk_ = torch.view_as_complex(xk.<span class="hljs-built_in">float</span>().reshape(*xk.shape[:-<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))

    <span class="hljs-comment"># 在复数域中应用旋转（乘以pos_cis）</span>
    xq_out = torch.view_as_real(xq_ * pos_cis).flatten(<span class="hljs-number">3</span>)
    xk_out = torch.view_as_real(xk_ * pos_cis).flatten(<span class="hljs-number">3</span>)
    <span class="hljs-keyword">return</span> xq_out.type_as(xq), xk_out.type_as(xk)
</code></pre>
<h5 data-id="heading-12">与传统位置编码的对比</h5>















































<table><thead><tr><th>特性</th><th>绝对位置编码</th><th>相对位置编码</th><th>RoPE</th></tr></thead><tbody><tr><td><strong>实现方式</strong></td><td>直接加到嵌入</td><td>相对位置矩阵</td><td>复数旋转</td></tr><tr><td><strong>外推性能</strong></td><td>❌ 极差</td><td>一般</td><td>✅<strong>优秀</strong></td></tr><tr><td><strong>长文本适应</strong></td><td>❌ 无法处理</td><td>中等</td><td>✅<strong>可达32K+</strong></td></tr><tr><td><strong>计算复杂度</strong></td><td>O(1)</td><td>O(n²)</td><td>O(n)</td></tr><tr><td><strong>显存占用</strong></td><td>最少</td><td>中等</td><td>极少</td></tr><tr><td><strong>理论基础</strong></td><td>无</td><td>相对位置偏置</td><td><strong>复数几何</strong></td></tr></tbody></table>
<h5 data-id="heading-13">选取原因</h5>
<p><strong>数学优雅性</strong>：</p>
<ul>
<li>利用复数旋转的几何性质编码位置信息</li>
<li>相邻位置之间的相对距离由旋转角度决定</li>
</ul>
<p><strong>外推能力</strong>：</p>
<ul>
<li>可以处理训练长度之外的序列（外推长度可达10-100倍）</li>
<li>这是LLaMA能处理4K→32K序列的关键</li>
</ul>
<p><strong>硬件友好</strong>：</p>
<ul>
<li>无需额外的位置矩阵存储</li>
<li>计算可完全融合到Q、K的投影中</li>
</ul>
<h5 data-id="heading-14">技术演进线路</h5>
<pre><code class="hljs language-scss" lang="scss">绝对位置编码 (Sin/Cos embedding)
    ↓ <span class="hljs-selector-attr">[问题：外推能力差]</span>
相对位置编码 (Shaw et al., <span class="hljs-number">2018</span>)
    ↓ <span class="hljs-selector-attr">[问题：计算复杂度高]</span>
ALiBi (Press et al., <span class="hljs-number">2022</span>)
    ↓ <span class="hljs-selector-attr">[问题：需要修改注意力计算]</span>
RoPE (Su et al., <span class="hljs-number">2021</span>) ⭐
    ↓ <span class="hljs-selector-attr">[最优方案]</span>
YaRN / NTK-Aware (<span class="hljs-number">2023</span>)
</code></pre>
<h5 data-id="heading-15">核心优势</h5>
<pre><code class="hljs">相对位置不变性
↓
频率分解的自然性
↓
优秀的外推性能
↓
可训练更长序列
</code></pre>
<hr/>
<h4 data-id="heading-16">3. GQA（Grouped-Query Attention）</h4>
<h5 data-id="heading-17">代码位置</h5>
<p><code>model/model.py:142-280</code></p>
<h5 data-id="heading-18">实现原理</h5>
<p><strong>头部配置</strong> (model.py:163-201)：</p>
<pre><code class="hljs language-python" lang="python">self.n_kv_heads = args.n_kv_heads <span class="hljs-keyword">if</span> args.n_kv_heads <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> args.n_heads
<span class="hljs-keyword">assert</span> args.n_heads % self.n_kv_heads == <span class="hljs-number">0</span>  <span class="hljs-comment"># Q头数必须是KV头数的倍数</span>
self.n_rep = self.n_local_heads // self.n_local_kv_heads  <span class="hljs-comment"># 每个KV头对应的Q头数</span>
</code></pre>
<p><strong>重复KV头</strong> (model.py:116-139)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">repeat_kv</span>(<span class="hljs-params">x: torch.Tensor, n_rep: <span class="hljs-built_in">int</span></span>) -&gt; torch.Tensor:
    <span class="hljs-string">"""将KV头重复n_rep次以匹配Q头数量"""</span>
    bs, slen, n_kv_heads, head_dim = x.shape
    <span class="hljs-keyword">if</span> n_rep == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> x
    <span class="hljs-keyword">return</span> (
        x[:, :, :, <span class="hljs-literal">None</span>, :]
        .expand(bs, slen, n_kv_heads, n_rep, head_dim)
        .reshape(bs, slen, n_kv_heads * n_rep, head_dim)
    )
</code></pre>
<p><strong>注意力计算</strong> (model.py:244-272)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 重复KV头以匹配Q头数量</span>
xq, xk, xv = (
    xq.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
    repeat_kv(xk, self.n_rep).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),  <span class="hljs-comment"># ← 关键：KV被重复</span>
    repeat_kv(xv, self.n_rep).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
)
</code></pre>
<h5 data-id="heading-19">与标准MHA的对比</h5>















































<table><thead><tr><th>特性</th><th>MHA</th><th>MQA</th><th>GQA</th></tr></thead><tbody><tr><td><strong>Q头数</strong></td><td>n</td><td>n</td><td>n</td></tr><tr><td><strong>KV头数</strong></td><td>n</td><td>1</td><td>n/g (可调)</td></tr><tr><td><strong>KV投影参数</strong></td><td>最多</td><td>最少</td><td><strong>中等</strong></td></tr><tr><td><strong>推理显存</strong></td><td>基准</td><td>减少 95%</td><td>减少 50-80%</td></tr><tr><td><strong>推理速度</strong></td><td>基准</td><td><strong>快</strong></td><td><strong>快</strong></td></tr><tr><td><strong>精度损失</strong></td><td>0%</td><td>0-2%</td><td><strong>&lt;0.5%</strong></td></tr></tbody></table>
<h5 data-id="heading-20">配置示例</h5>
<pre><code class="hljs language-ini" lang="ini">标准 MHA：<span class="hljs-attr">Q</span>=<span class="hljs-number">32</span>头, KV=<span class="hljs-number">32</span>头
    ↓
MQA：<span class="hljs-attr">Q</span>=<span class="hljs-number">32</span>头, KV=<span class="hljs-number">1</span>头 (激进，精度可能下降)
    ↓
GQA (<span class="hljs-attr">n_kv_heads</span>=<span class="hljs-number">4</span>)：Q=<span class="hljs-number">32</span>头, KV=<span class="hljs-number">4</span>头 (均衡) ⭐
    ↓
GQA (<span class="hljs-attr">n_kv_heads</span>=<span class="hljs-number">8</span>)：Q=<span class="hljs-number">32</span>头, KV=<span class="hljs-number">8</span>头 (接近MHA)
</code></pre>
<h5 data-id="heading-21">选取原因</h5>
<p><strong>推理性能</strong>：</p>
<ul>
<li>KV缓存大小减少，提高显存利用率</li>
<li>在长序列生成时显著加速</li>
</ul>
<p><strong>训练稳定性</strong>：</p>
<ul>
<li>相比MQA，精度损失极小（&lt;0.5%）</li>
<li>保留了足够的KV多样性</li>
</ul>
<p><strong>工业标准</strong>：</p>
<ul>
<li>Llama 2使用GQA</li>
<li>OpenAI的最新模型采用此方案</li>
</ul>
<h5 data-id="heading-22">技术演进</h5>
<pre><code class="hljs language-scss" lang="scss">Multi-Head Attention (Vaswani et al., <span class="hljs-number">2017</span>)
    ↓ <span class="hljs-selector-attr">[问题：推理时KV缓存太大]</span>
Multi-Query Attention (Shazeer, <span class="hljs-number">2019</span>)
    ↓ <span class="hljs-selector-attr">[问题：精度下降明显]</span>
Grouped-Query Attention (Ainslie et al., <span class="hljs-number">2023</span>) ⭐
    ↓ <span class="hljs-selector-attr">[最优平衡点]</span>
</code></pre>
<h5 data-id="heading-23">核心优势</h5>
<pre><code class="hljs language-erlang" lang="erlang">KV缓存减少 <span class="hljs-number">50</span>-<span class="hljs-number">80</span><span class="hljs-comment">%</span>
↓
推理显存压力减轻
↓
可提高吞吐量或处理更长序列
↓
精度基本无损
</code></pre>
<hr/>
<h4 data-id="heading-24">4. Flash Attention</h4>
<h5 data-id="heading-25">代码位置</h5>
<p><code>model/model.py:254-261</code></p>
<h5 data-id="heading-26">实现原理</h5>
<p><strong>检测与启用</strong> (model.py:194-195)：</p>
<pre><code class="hljs language-python" lang="python">self.flash = <span class="hljs-built_in">hasattr</span>(torch.nn.functional, <span class="hljs-string">'scaled_dot_product_attention'</span>) <span class="hljs-keyword">and</span> args.flash_attn
</code></pre>
<p><strong>调用方式</strong> (model.py:254-261)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> self.flash <span class="hljs-keyword">and</span> seq_len != <span class="hljs-number">1</span>:
    dropout_p = self.dropout <span class="hljs-keyword">if</span> self.training <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>
    output = F.scaled_dot_product_attention(
        xq, xk, xv,
        attn_mask=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># Flash Attention内部处理因果掩码</span>
        dropout_p=dropout_p,
        is_causal=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 指示使用因果掩码</span>
    )
<span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 降级到标准注意力</span>
    scores = (xq @ xk.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)) / math.sqrt(self.head_dim)
    scores += self.mask[:, :, :seq_len, :seq_len]
    scores = F.softmax(scores.<span class="hljs-built_in">float</span>(), dim=-<span class="hljs-number">1</span>).type_as(xq)
    scores = self.attn_dropout(scores)
    output = scores @ xv
</code></pre>
<h5 data-id="heading-27">与标准Attention的对比</h5>








































<table><thead><tr><th>特性</th><th>标准Attention</th><th>Flash Attention</th></tr></thead><tbody><tr><td><strong>计算流程</strong></td><td>Q@K→softmax→@V</td><td>优化的融合核</td></tr><tr><td><strong>中间张量</strong></td><td>需要存储N²分数矩阵</td><td>按块流式处理</td></tr><tr><td><strong>IO复杂度</strong></td><td>O(N²)</td><td>O(N)</td></tr><tr><td><strong>计算速度</strong></td><td>基准</td><td><strong>2-4倍快</strong></td></tr><tr><td><strong>显存占用</strong></td><td>基准</td><td><strong>减少 90%</strong></td></tr><tr><td><strong>精度</strong></td><td>FP32</td><td>FP16（自适应）</td></tr></tbody></table>
<h5 data-id="heading-28">工作原理（高层）</h5>
<p>标准方法的问题：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[Q @ K^T]</span> → 生成N×N的分数矩阵（显存瓶颈）
    ↓
<span class="hljs-selector-attr">[softmax]</span> → 每个元素依赖全局信息
    ↓
<span class="hljs-selector-attr">[@ V]</span> → 需要重新读取全N×N矩阵
</code></pre>
<p>Flash Attention解决方案：</p>
<pre><code class="hljs language-markdown" lang="markdown">将注意力计算分块进行：
<span class="hljs-bullet">  1.</span> 将Q、K、V分块加载到快速显存（SRAM）
<span class="hljs-bullet">  2.</span> 对每块计算注意力
<span class="hljs-bullet">  3.</span> 融合softmax和dropout
<span class="hljs-bullet">  4.</span> 直接写入结果，无需存储中间分数
</code></pre>
<h5 data-id="heading-29">选取原因</h5>
<p><strong>性能瓶颈突破</strong>：</p>
<ul>
<li>标准注意力的IO成为主要瓶颈（不是计算）</li>
<li>Flash Attention通过减少IO实现2-4倍加速</li>
</ul>
<p><strong>显存节省</strong>：</p>
<ul>
<li>关键在长序列场景下</li>
<li>可训练更长上下文</li>
</ul>
<p><strong>库支持</strong>：</p>
<ul>
<li>PyTorch 2.0+集成支持</li>
<li>无需额外依赖</li>
</ul>
<h5 data-id="heading-30">核心优势</h5>
<pre><code class="hljs">IO感知的算法设计
↓
充分利用GPU硬件特性
↓
推理和训练都快 2-4 倍
↓
长序列成为可能
</code></pre>
<hr/>
<h4 data-id="heading-31">5. KV Cache 优化</h4>
<h5 data-id="heading-32">代码位置</h5>
<p><code>model/model.py:236-242</code></p>
<h5 data-id="heading-33">实现原理</h5>
<p><strong>缓存保存</strong> (model.py:236-242)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># KV缓存处理：如果有历史KV，则与当前KV拼接</span>
<span class="hljs-keyword">if</span> past_key_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    xk = torch.cat([past_key_value[<span class="hljs-number">0</span>], xk], dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 拼接历史K和当前K</span>
    xv = torch.cat([past_key_value[<span class="hljs-number">1</span>], xv], dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 拼接历史V和当前V</span>

<span class="hljs-comment"># 如果需要缓存，则保存当前KV用于下一步</span>
past_kv = (xk, xv) <span class="hljs-keyword">if</span> use_cache <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>
</code></pre>
<p><strong>生成时的使用</strong> (model.py:731-737)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 首次推理或不使用缓存时，处理整个序列</span>
<span class="hljs-keyword">if</span> first_seq <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> use_cache:
    out, first_seq = self(input_ids, past_key_values=past_kvs, use_cache=use_cache, **args), <span class="hljs-literal">False</span>
<span class="hljs-comment"># 后续推理且使用缓存时，只处理最新的token</span>
<span class="hljs-keyword">else</span>:
    out = self(input_ids[:, -<span class="hljs-number">1</span>:], past_key_values=past_kvs, use_cache=use_cache,
               start_pos=input_ids.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, **args)
</code></pre>
<h5 data-id="heading-34">性能影响</h5>



































<table><thead><tr><th>场景</th><th>无KV Cache</th><th>有KV Cache</th></tr></thead><tbody><tr><td><strong>生成速度</strong></td><td>基准 (100%)</td><td><strong>~10倍快</strong></td></tr><tr><td><strong>显存占用</strong></td><td>随长度平方增长</td><td>线性增长</td></tr><tr><td><strong>长序列生成</strong></td><td>不可行</td><td>✅ 可行</td></tr><tr><td><strong>首token延迟</strong></td><td>低</td><td>略高（需要全序列计算）</td></tr><tr><td><strong>后续token延迟</strong></td><td><strong>高</strong></td><td>极低</td></tr></tbody></table>
<h5 data-id="heading-35">原理分析</h5>
<p>无缓存时的计算流程：</p>
<pre><code class="hljs language-perl" lang="perl">生成token <span class="hljs-number">100</span>：
  Q, K, V = self.w<span class="hljs-string">q(seq_0-100)</span>, self.wk(seq_<span class="hljs-number">0</span>-<span class="hljs-number">100</span>), self.wv(seq_<span class="hljs-number">0</span>-<span class="hljs-number">100</span>)
  attn = softmax(Q @ K^T) @ V
  重新计算了seq_<span class="hljs-number">0</span>-<span class="hljs-number">99</span>的K、V（浪费！）

生成token <span class="hljs-number">101</span>：
  Q, K, V = self.w<span class="hljs-string">q(seq_0-101)</span>, self.wk(seq_<span class="hljs-number">0</span>-<span class="hljs-number">101</span>), self.wv(seq_<span class="hljs-number">0</span>-<span class="hljs-number">101</span>)
  attn = softmax(Q @ K^T) @ V
  又重新计算了seq_<span class="hljs-number">0</span>-<span class="hljs-number">100</span>的K、V（二次浪费！）
</code></pre>
<p>有缓存时：</p>
<pre><code class="hljs language-ini" lang="ini">生成token 100：
  Q100, K100, <span class="hljs-attr">V100</span> = self.wq(token_100), self.wk(token_100), self.wv(token_100)
  <span class="hljs-attr">cached_K</span> = [K_0-<span class="hljs-number">99</span>, K100]  ← 保存
  <span class="hljs-attr">cached_V</span> = [V_0-<span class="hljs-number">99</span>, V100]  ← 保存
  <span class="hljs-attr">attn</span> = softmax(Q100 @ cached_K^T) @ cached_V

生成token 101：
  Q101, K101, <span class="hljs-attr">V101</span> = self.wq(token_101), self.wk(token_101), self.wv(token_101)
  <span class="hljs-attr">cached_K</span> = [K_0-<span class="hljs-number">99</span>, K100, K101]  ← 追加（只计算新token）
  <span class="hljs-attr">cached_V</span> = [V_0-<span class="hljs-number">99</span>, V100, V101]  ← 追加
  <span class="hljs-attr">attn</span> = softmax(Q101 @ cached_K^T) @ cached_V
</code></pre>
<h5 data-id="heading-36">选取原因</h5>
<p><strong>自回归生成的必要条件</strong>：</p>
<ul>
<li>不使用KV Cache时，生成100个token需要计算~5000次矩阵乘法</li>
<li>使用KV Cache只需~200次（理论加速50倍）</li>
</ul>
<p><strong>实际场景</strong>：</p>
<ul>
<li>所有LLM推理框架都使用KV Cache</li>
<li>没有KV Cache无法进行实用的文本生成</li>
</ul>
<h5 data-id="heading-37">核心优势</h5>
<pre><code class="hljs">避免重复计算历史token的K、V
↓
生成速度提升 10-50 倍
↓
可进行实时交互式应用
↓
大幅降低推理成本
</code></pre>
<hr/>
<h3 data-id="heading-38">技术总结矩阵</h3>















































<table><thead><tr><th>技术</th><th>改进目标</th><th>相对复杂度</th><th>收益幅度</th><th>现代地位</th></tr></thead><tbody><tr><td><strong>RMSNorm</strong></td><td>计算效率</td><td>⭐ 低</td><td>30-40%</td><td>🔥 标准</td></tr><tr><td><strong>RoPE</strong></td><td>外推能力</td><td>⭐⭐ 中</td><td>10-100倍</td><td>🔥 标准</td></tr><tr><td><strong>GQA</strong></td><td>推理效率</td><td>⭐⭐ 中</td><td>2-4倍</td><td>🔥 标准</td></tr><tr><td><strong>Flash Attention</strong></td><td>计算速度</td><td>⭐⭐⭐ 复杂</td><td>2-4倍</td><td>🔥 推荐</td></tr><tr><td><strong>KV Cache</strong></td><td>生成速度</td><td>⭐ 低</td><td>10-50倍</td><td>🔥 必须</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-39">架构演进对比</h3>
<h4 data-id="heading-40">原始Transformer (Vaswani et al., 2017)</h4>
<pre><code class="hljs language-scss" lang="scss">Embedding + LayerNorm
    ↓
Positional Encoding (绝对位置)
    ↓
Multi-Head Attention (<span class="hljs-number">32</span>头, <span class="hljs-number">32</span>KV)
    ↓
LayerNorm + FFN (<span class="hljs-number">4</span>倍维度)
    ↓
无KV Cache推理
    ↓
外推能力：❌ 极差
推理速度：❌ 极慢
</code></pre>
<h4 data-id="heading-41">GPT-3风格 (Brown et al., 2020)</h4>
<pre><code class="hljs language-scss" lang="scss">Embedding + LayerNorm
    ↓
Positional Encoding (绝对位置)
    ↓
Multi-Head Attention (<span class="hljs-number">96</span>头, <span class="hljs-number">96</span>KV)
    ↓
LayerNorm + FFN (<span class="hljs-number">4</span>倍维度)
    ↓
KV Cache推理
    ↓
外推能力：❌ 无法处理超训练长度
推理速度：中等（有Cache）
</code></pre>
<h4 data-id="heading-42">LLaMA风格 (Meta, 2023) - MiniMind采用</h4>
<pre><code class="hljs language-java" lang="java">Embedding + RMSNorm ⭐
    ↓
RoPE位置编码 ⭐
    ↓
Grouped-Query <span class="hljs-title function_">Attention</span> <span class="hljs-params">(32Q, 8KV)</span> ⭐
    ↓
RMSNorm + SwiGLU FFN
    ↓
Flash Attention + KV Cache ⭐
    ↓
外推能力：✅ 可处理 <span class="hljs-number">10</span>-<span class="hljs-number">100</span>倍长序列
推理速度：✅ 比GPT-<span class="hljs-number">3</span>快 <span class="hljs-number">10</span>-<span class="hljs-number">50</span>倍
显存占用：✅ 减少 <span class="hljs-number">50</span>-<span class="hljs-number">80</span>%
</code></pre>
<hr/>
<h2 data-id="heading-43">MiniMind 前馈网络创新技术详解</h2>
<h3 data-id="heading-44">二、前馈网络差异</h3>
<h4 data-id="heading-45">1. SwiGLU 激活函数</h4>
<h5 data-id="heading-46">代码位置</h5>
<p><code>model/model.py:283-344</code></p>
<h5 data-id="heading-47">实现原理</h5>
<p><strong>类定义和初始化</strong> (model.py:300-324)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FeedForward</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config: LMConfig</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-comment"># 如果未指定隐藏层维度，则自动计算</span>
        <span class="hljs-keyword">if</span> config.hidden_dim <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            hidden_dim = <span class="hljs-number">4</span> * config.dim  <span class="hljs-comment"># 初始为4倍维度</span>
            hidden_dim = <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span> * hidden_dim / <span class="hljs-number">3</span>)  <span class="hljs-comment"># ← 关键：降到约2.67倍</span>
            <span class="hljs-comment"># 对齐到multiple_of的倍数（通常为256）</span>
            config.hidden_dim = config.multiple_of * ((hidden_dim + config.multiple_of - <span class="hljs-number">1</span>) // config.multiple_of)

        <span class="hljs-comment"># 三个线性投影层</span>
        self.w1 = nn.Linear(config.dim, config.hidden_dim, bias=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 升维</span>
        self.w2 = nn.Linear(config.hidden_dim, config.dim, bias=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 降维</span>
        self.w3 = nn.Linear(config.dim, config.hidden_dim, bias=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 门控</span>
        self.dropout = nn.Dropout(config.dropout)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-string">"""SwiGLU实现：FFN(x) = dropout(W₂ · (SiLU(W₁·x) ⊙ W₃·x))"""</span>
        <span class="hljs-keyword">return</span> self.dropout(self.w2(F.silu(self.w1(x)) * self.w3(x)))
        <span class="hljs-comment">#                                    ↑ 激活函数      ↑ 门控信号</span>
</code></pre>
<h5 data-id="heading-48">数学公式对比</h5>

























<table><thead><tr><th>架构</th><th>公式</th><th>参数数量</th></tr></thead><tbody><tr><td><strong>传统FFN</strong></td><td><code>FFN(x) = W₂ · ReLU(W₁ · x)</code></td><td><code>2D·H</code></td></tr><tr><td><strong>GELU FFN</strong></td><td><code>FFN(x) = W₂ · GELU(W₁ · x)</code></td><td><code>2D·H</code></td></tr><tr><td><strong>SwiGLU</strong></td><td><code>FFN(x) = W₂ · (SiLU(W₁·x) ⊙ W₃·x)</code></td><td><code>3D·H</code></td></tr></tbody></table>
<p>其中：</p>
<ul>
<li><code>D</code> = 模型维度 (通常 768-4096)</li>
<li><code>H</code> = 隐藏维度 (通常 2.67D)</li>
<li><code>⊙</code> = 逐元素乘法（Hadamard积）</li>
<li><code>SiLU(x) = x · sigmoid(x)</code> = Swish激活</li>
</ul>
<h5 data-id="heading-49">SwiGLU的三个关键组件</h5>
<p><strong>1. SiLU激活函数（Swish）</strong></p>
<pre><code class="hljs language-python" lang="python">SiLU(x) = x · sigmoid(x) = x · <span class="hljs-number">1</span>/(<span class="hljs-number">1</span> + e^(-x))
</code></pre>
<p>对比其他激活函数：</p>
<pre><code class="hljs language-scss" lang="scss">ReLU：          <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, x)           - 非光滑，梯度为<span class="hljs-number">0</span>或<span class="hljs-number">1</span>
GELU：          x · Φ(x)            - 光滑，类似softmax
Swish/SiLU：    x · <span class="hljs-built_in">sigmoid</span>(x)      - 光滑自门控 ⭐
</code></pre>
<p><strong>2. 门控机制（Gating）</strong></p>
<pre><code class="hljs language-python" lang="python">f(x) = SiLU(W₁·x) ⊙ W₃·x
       ↑ 激活路径    ↑ 门控路径
</code></pre>
<p>门控作用：</p>
<ul>
<li><code>W₃·x</code> 产生的值范围在 [0, 1] 之间（或接近）</li>
<li>通过逐元素乘法来调节信息流</li>
<li>类似于LSTM中的遗忘门</li>
</ul>
<p><strong>3. 参数高效性</strong></p>
<pre><code class="hljs language-r" lang="r">标准FFN：<span class="hljs-built_in">dim</span> → <span class="hljs-number">4</span><span class="hljs-operator">*</span><span class="hljs-built_in">dim</span> → <span class="hljs-built_in">dim</span>
         参数数：<span class="hljs-number">2</span><span class="hljs-operator">*</span>D<span class="hljs-operator">*</span><span class="hljs-number">4</span>D <span class="hljs-operator">=</span> <span class="hljs-number">8</span>D²

SwiGLU：  <span class="hljs-built_in">dim</span> → <span class="hljs-number">2.67</span><span class="hljs-operator">*</span><span class="hljs-built_in">dim</span> → <span class="hljs-built_in">dim</span> <span class="hljs-punctuation">(</span>两个分支<span class="hljs-punctuation">)</span>
         参数数：<span class="hljs-punctuation">(</span><span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span>D<span class="hljs-operator">*</span><span class="hljs-number">2.67</span>D ≈ <span class="hljs-number">8</span>D²

↓ 虽然参数相同，但计算量相近，但效果显著更好
</code></pre>
<h5 data-id="heading-50">与其他激活函数的对比</h5>





























































<table><thead><tr><th>特性</th><th>ReLU</th><th>GELU</th><th>Swish/SiLU</th><th>SwiGLU</th></tr></thead><tbody><tr><td><strong>平滑性</strong></td><td>❌ 不平滑</td><td>✅ 平滑</td><td>✅ 平滑</td><td>✅ 平滑</td></tr><tr><td><strong>自门控</strong></td><td>❌ 无</td><td>❌ 无</td><td>✅ 有</td><td>✅ 有</td></tr><tr><td><strong>双路径</strong></td><td>❌ 单路</td><td>❌ 单路</td><td>❌ 单路</td><td>✅ 双路</td></tr><tr><td><strong>梯度流</strong></td><td>差</td><td>好</td><td>优</td><td><strong>优异</strong></td></tr><tr><td><strong>计算成本</strong></td><td>最低</td><td>中等</td><td>中等</td><td>中等</td></tr><tr><td><strong>模型质量</strong></td><td>低</td><td>高</td><td>高</td><td><strong>最高</strong></td></tr><tr><td><strong>现代采用</strong></td><td>过时</td><td>广泛</td><td>常见</td><td><strong>🔥标准</strong></td></tr></tbody></table>
<h5 data-id="heading-51">选取原因</h5>
<p><strong>1. 门控的必要性</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">传统FFN的问题：
<span class="hljs-bullet">  -</span> 激活函数处理所有信息
<span class="hljs-bullet">  -</span> 无法根据上下文调节信息
<span class="hljs-bullet">  -</span> 梯度流受限

SwiGLU的优势：
<span class="hljs-bullet">  -</span> 双路径设计：激活路径 + 门控路径
<span class="hljs-bullet">  -</span> 可动态调节信息流强度
<span class="hljs-bullet">  -</span> 梯度从两条路径流向反向传播
</code></pre>
<p><strong>2. 实验证据（来自原始论文）</strong></p>
<p>使用相同参数量的情况下：</p>

























<table><thead><tr><th>架构</th><th>BLEU评分</th><th>困惑度</th></tr></thead><tbody><tr><td>ReLU FFN</td><td>25.4</td><td>5.20</td></tr><tr><td>GELU FFN</td><td>26.8</td><td>4.95</td></tr><tr><td>SwiGLU</td><td><strong>27.6</strong></td><td><strong>4.71</strong></td></tr></tbody></table>
<p>SwiGLU相比GELU提升 ~3%，相比ReLU提升 ~8%</p>
<p><strong>3. 参数高效性</strong></p>
<pre><code class="hljs language-r" lang="r">关键发现（Shazeer et al.<span class="hljs-punctuation">,</span> <span class="hljs-number">2022</span>）：

使用SwiGLU时，可以减少FFN的隐藏维度，
同时保持相同甚至更好的性能

原始：<span class="hljs-built_in">dim</span> → <span class="hljs-number">4</span><span class="hljs-operator">*</span><span class="hljs-built_in">dim</span> → <span class="hljs-built_in">dim</span>
现在：<span class="hljs-built_in">dim</span> → <span class="hljs-number">2.67</span><span class="hljs-operator">*</span><span class="hljs-built_in">dim</span> → <span class="hljs-built_in">dim</span> ⭐

效果：参数减少 <span class="hljs-number">33</span>%，性能持平或更优
</code></pre>
<p><strong>4. 现代LLM标准</strong></p>
<pre><code class="hljs">LLaMA / LLaMA-2：SwiGLU
PaLM / Gemini：SwiGLU
Falcon：SwiGLU
MistralAI：SwiGLU
</code></pre>
<h5 data-id="heading-52">激活函数演进线</h5>
<pre><code class="hljs language-scss" lang="scss">时代 <span class="hljs-number">1</span> (<span class="hljs-number">2012</span>-<span class="hljs-number">2017</span>)：ReLU 主宰
  <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, x)
  ↓ <span class="hljs-selector-attr">[梯度消失问题]</span>

时代 <span class="hljs-number">2</span> (<span class="hljs-number">2017</span>-<span class="hljs-number">2020</span>)：GELU 兴起
  x·Φ(x)  <span class="hljs-selector-attr">[更平滑的梯度]</span>
  ↓ <span class="hljs-selector-attr">[缺少自适应门控]</span>

时代 <span class="hljs-number">3</span> (<span class="hljs-number">2020</span>-<span class="hljs-number">2022</span>)：Swish 实验阶段
  x·<span class="hljs-built_in">sigmoid</span>(x)  <span class="hljs-selector-attr">[自门控]</span>
  ↓ <span class="hljs-selector-attr">[门控不够结构化]</span>

时代 <span class="hljs-number">4</span> (<span class="hljs-number">2022</span>+)：SwiGLU 标准化 ⭐
  W₂(SiLU(W₁x) ⊙ W₃x)  <span class="hljs-selector-attr">[最优的表达力+效率]</span>
  ↓

未来可能：MLP-Mixer, GLU Variants
</code></pre>
<h5 data-id="heading-53">核心优势总结</h5>
<pre><code class="hljs language-markdown" lang="markdown">双路径设计
<span class="hljs-code">    ↓
更好的梯度流
    ↓
更强的表达能力
    ↓
可减少参数同时保持性能
    ↓
成为现代LLM标准激活函数
</span></code></pre>
<hr/>
<h4 data-id="heading-54">2. MoE（Mixture of Experts）混合专家模型</h4>
<h5 data-id="heading-55">代码位置</h5>
<p><code>model/model.py:347-459</code></p>
<h5 data-id="heading-56">实现原理</h5>
<p><strong>MoE门控网络</strong> (model.py:347-401)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoEGate</span>(nn.Module):
    <span class="hljs-string">"""门控网络：决定每个token由哪些专家处理"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config: LMConfig</span>):
        <span class="hljs-built_in">super</span>().__init__()
        self.top_k = config.num_experts_per_tok  <span class="hljs-comment"># 每个token选择的专家数</span>
        self.n_routed_experts = config.n_routed_experts  <span class="hljs-comment"># 路由专家总数</span>
        self.scoring_func = config.scoring_func  <span class="hljs-comment"># 评分函数（softmax）</span>
        self.alpha = config.aux_loss_alpha  <span class="hljs-comment"># 辅助损失权重</span>
        self.weight = nn.Parameter(torch.empty((self.n_routed_experts, self.gating_dim)))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states</span>):
        <span class="hljs-comment"># 计算每个专家的得分</span>
        logits = F.linear(hidden_states, self.weight, <span class="hljs-literal">None</span>)
        scores = logits.softmax(dim=-<span class="hljs-number">1</span>)  <span class="hljs-comment"># 转换为概率</span>

        <span class="hljs-comment"># 选择top-k个专家</span>
        topk_weight, topk_idx = torch.topk(scores, k=self.top_k, dim=-<span class="hljs-number">1</span>, <span class="hljs-built_in">sorted</span>=<span class="hljs-literal">False</span>)

        <span class="hljs-comment"># 归一化top-k权重</span>
        <span class="hljs-keyword">if</span> self.top_k &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.norm_topk_prob:
            denominator = topk_weight.<span class="hljs-built_in">sum</span>(dim=-<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>) + <span class="hljs-number">1e-20</span>
            topk_weight = topk_weight / denominator

        <span class="hljs-comment"># 计算辅助损失（平衡专家负载）</span>
        aux_loss = self._compute_aux_loss(...)

        <span class="hljs-keyword">return</span> topk_idx, topk_weight, aux_loss
</code></pre>
<p><strong>MoE前馈网络</strong> (model.py:404-436)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MOEFeedForward</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config: LMConfig</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-comment"># 创建多个专家（每个都是一个独立的FFN）</span>
        self.experts = nn.ModuleList([
            FeedForward(config)
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(config.n_routed_experts)
        ])
        self.gate = MoEGate(config)  <span class="hljs-comment"># 门控网络</span>

        <span class="hljs-comment"># 可选的共享专家（所有token都经过）</span>
        <span class="hljs-keyword">if</span> config.n_shared_experts <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.shared_experts = FeedForward(config)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        identity = x
        <span class="hljs-comment"># 1. 使用门控网络选择专家</span>
        topk_idx, topk_weight, aux_loss = self.gate(x)

        <span class="hljs-comment"># 2. 分发token给选中的专家</span>
        <span class="hljs-keyword">if</span> self.training:
            <span class="hljs-comment"># 训练时：循环分发（更简单的实现）</span>
            y = torch.empty_like(x, dtype=torch.float16)
            <span class="hljs-keyword">for</span> i, expert <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.experts):
                y[flat_topk_idx == i] = expert(x[flat_topk_idx == i])
            y = (y.view(*topk_weight.shape, -<span class="hljs-number">1</span>) * topk_weight.unsqueeze(-<span class="hljs-number">1</span>)).<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># 推理时：优化的推理流程</span>
            y = self.moe_infer(x, flat_topk_idx, topk_weight.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))

        <span class="hljs-comment"># 3. 可选：添加共享专家的输出</span>
        <span class="hljs-keyword">if</span> self.config.n_shared_experts <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            y = y + self.shared_experts(identity)

        <span class="hljs-comment"># 保存辅助损失用于反向传播</span>
        self.aux_loss = aux_loss
        <span class="hljs-keyword">return</span> y
</code></pre>
<p><strong>高效推理</strong> (model.py:438-459)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@torch.no_grad()</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">moe_infer</span>(<span class="hljs-params">self, x, flat_expert_indices, flat_expert_weights</span>):
    <span class="hljs-string">"""推理时的高效MoE计算"""</span>
    expert_cache = torch.zeros_like(x)

    <span class="hljs-comment"># 按专家索引排序token</span>
    idxs = flat_expert_indices.argsort()

    <span class="hljs-comment"># 计算每个专家处理的token数</span>
    tokens_per_expert = flat_expert_indices.bincount().cpu().numpy().cumsum(<span class="hljs-number">0</span>)
    token_idxs = idxs // self.config.num_experts_per_tok

    <span class="hljs-comment"># 为每个专家处理对应的tokens</span>
    <span class="hljs-keyword">for</span> i, end_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tokens_per_expert):
        start_idx = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> tokens_per_expert[i - <span class="hljs-number">1</span>]
        <span class="hljs-keyword">if</span> start_idx == end_idx:
            <span class="hljs-keyword">continue</span>
        expert = self.experts[i]
        exp_token_idx = token_idxs[start_idx:end_idx]
        expert_tokens = x[exp_token_idx]
        expert_out = expert(expert_tokens)
        expert_out.mul_(flat_expert_weights[idxs[start_idx:end_idx]])
        expert_cache.scatter_add_(<span class="hljs-number">0</span>, exp_token_idx.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>).repeat(<span class="hljs-number">1</span>, x.shape[-<span class="hljs-number">1</span>]), expert_out)

    <span class="hljs-keyword">return</span> expert_cache
</code></pre>
<h5 data-id="heading-57">MoE工作流程详解</h5>
<p><strong>步骤 1：门控路由</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">token</span> <span class="hljs-string">sequence</span> [<span class="hljs-string">seq_len</span>, <span class="hljs-string">dim</span>]
            <span class="hljs-string">↓</span>
<span class="hljs-attr">Gate Network:</span> <span class="hljs-string">计算每个token</span> <span class="hljs-string">→</span> <span class="hljs-string">每个专家的概率</span>
            <span class="hljs-string">↓</span>
<span class="hljs-attr">Top-k Selection:</span> <span class="hljs-string">为每个token选择top-k个专家</span>
            <span class="hljs-string">↓</span>
<span class="hljs-attr">Output:</span> <span class="hljs-string">(token_to_expert_mapping,</span> <span class="hljs-string">expert_weights)</span>
</code></pre>
<p><strong>步骤 2：专家分发</strong></p>
<pre><code class="hljs language-python" lang="python">输入：Token序列 [B, S, D]
         ↓
Gate: [B*S, num_experts] → 每个token的专家权重
         ↓
TopK: 为每个token选择 top_k=<span class="hljs-number">2</span> 个专家
         ↓
分发：
  Token <span class="hljs-number">0</span> → Expert <span class="hljs-number">3</span>, Expert <span class="hljs-number">7</span>  (权重: <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>)
  Token <span class="hljs-number">1</span> → Expert <span class="hljs-number">1</span>, Expert <span class="hljs-number">5</span>  (权重: <span class="hljs-number">0.7</span>, <span class="hljs-number">0.3</span>)
  Token <span class="hljs-number">2</span> → Expert <span class="hljs-number">7</span>, Expert <span class="hljs-number">9</span>  (权重: <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)
         ↓
汇聚：对每个token的多个专家输出加权求和
</code></pre>
<p><strong>步骤 3：输出合并</strong></p>
<pre><code class="hljs language-ini" lang="ini">Expert 1 output: <span class="hljs-section">[0.7 * token_1_output, ...]</span>
Expert 3 output: <span class="hljs-section">[0.6 * token_0_output, ...]</span>
Expert 5 output: <span class="hljs-section">[0.3 * token_1_output, ...]</span>
Expert 7 output: <span class="hljs-section">[0.4 * token_0_output, 0.5 * token_2_output, ...]</span>
Expert 9 output: <span class="hljs-section">[0.5 * token_2_output, ...]</span>
         ↓ <span class="hljs-section">[合并到原始位置]</span>
Final output: <span class="hljs-section">[token_0_out, token_1_out, token_2_out, ...]</span>
</code></pre>
<h5 data-id="heading-58">MoE vs 标准FFN</h5>













































<table><thead><tr><th>特性</th><th>标准FFN</th><th>MoE</th></tr></thead><tbody><tr><td><strong>参数数量</strong></td><td>基准 (8D²)</td><td><strong>稍高</strong> (~10D²)</td></tr><tr><td><strong>计算量</strong></td><td>所有token都经过所有神经元</td><td><strong>只经过top-k专家</strong></td></tr><tr><td><strong>激活参数</strong></td><td>基准</td><td><strong>减少 80-90%</strong></td></tr><tr><td><strong>模型容量</strong></td><td>固定</td><td><strong>动态可扩展</strong></td></tr><tr><td><strong>泛化能力</strong></td><td>基准</td><td><strong>更强</strong></td></tr><tr><td><strong>训练稳定性</strong></td><td>良好</td><td>需要负载均衡</td></tr><tr><td><strong>推理速度</strong></td><td>基准</td><td><strong>取决于top-k</strong></td></tr></tbody></table>
<h5 data-id="heading-59">详细对比分析</h5>
<p><strong>计算量对比（以Transformer块为例）</strong></p>
<p>标准FFN：</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[B, S, D]</span> → <span class="hljs-selector-attr">[B, S, 4D]</span> → <span class="hljs-selector-attr">[B, S, D]</span>

总计算量 = <span class="hljs-selector-tag">B</span>*S*D * <span class="hljs-number">4</span>D + <span class="hljs-selector-tag">B</span>*S*<span class="hljs-number">4</span>D * D = <span class="hljs-number">8</span>*<span class="hljs-selector-tag">B</span>*S*D²
（每个token都经过全部计算）
</code></pre>
<p>MoE (num_experts=8, top_k=2)：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-attr">[B, S, D]</span> → Gate → 选择<span class="hljs-attribute">top</span>-<span class="hljs-number">2</span>专家 (共<span class="hljs-number">8</span>个专家)

每个专家大小 = D → D/<span class="hljs-number">2</span> → D  (为了保持总参数量)

单个token的计算 = D * (D/<span class="hljs-number">2</span>) * <span class="hljs-number">2</span> = <span class="hljs-selector-tag">B</span>*S*D²
                  (只处理<span class="hljs-number">2</span>个专家)

总计算量 ≈ <span class="hljs-number">2</span>*<span class="hljs-selector-tag">B</span>*S*D²
（相比标准FFN减少 <span class="hljs-number">75%</span>！）
</code></pre>
<p><strong>实际性能数据</strong> (来自GLaM论文)</p>





























<table><thead><tr><th>配置</th><th>参数</th><th>计算</th><th>困惑度</th></tr></thead><tbody><tr><td>标准 175B</td><td>175B</td><td>基准</td><td>10.5</td></tr><tr><td>MoE 64E 2K</td><td>175B</td><td>基准</td><td><strong>9.8</strong></td></tr><tr><td>MoE 1024E 2K</td><td>175B</td><td>基准</td><td><strong>9.2</strong></td></tr></tbody></table>
<p><strong>关键发现</strong>：</p>
<ul>
<li>相同参数量，MoE显著超过标准模型</li>
<li>可以用更少计算达到相同精度</li>
<li>或用相同计算达到更高精度</li>
</ul>
<h5 data-id="heading-60">MoE的四大挑战与解决方案</h5>
<p><strong>挑战 1：负载不均衡</strong></p>
<pre><code class="hljs language-ini" lang="ini">问题：某些专家被频繁选中，某些很少被选中
      ↓ 浪费了参数和计算资源

解决方案：Auxiliary Loss（辅助损失）
  <span class="hljs-attr">aux_loss</span> = alpha * (专家使用概率 * 专家容量)
  ↓ 鼓励均匀分布
</code></pre>
<p><strong>挑战 2：路由碰撞</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">问题：某些token想去的专家都满了（容量限制）
<span class="hljs-code">      ↓ 需要丢弃或降级处理
</span>
解决方案：
<span class="hljs-bullet">  1.</span> Expert Capacity：为每个专家设定容量阈值
<span class="hljs-bullet">  2.</span> Drop Tokens：超过容量的token丢弃
<span class="hljs-bullet">  3.</span> Shared Experts：所有token都经过的后备专家
</code></pre>
<p><strong>挑战 3：训练不稳定</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">问题：Gate网络突然改变路由决策
<span class="hljs-code">      ↓ 梯度不稳定
</span>
解决方案：
<span class="hljs-bullet">  1.</span> Sticky Gate：添加随机噪声平滑路由
<span class="hljs-bullet">  2.</span> Temperature Annealing：逐步降低温度
<span class="hljs-bullet">  3.</span> Load Balancing：强制均衡专家负载
</code></pre>
<p><strong>挑战 4：推理延迟</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">问题：不规则的内存访问模式
<span class="hljs-code">      ↓ GPU利用率低
</span>
解决方案：Token Reordering（代码中的moe<span class="hljs-emphasis">_infer）
  1. 按专家排序token
  2. 连续处理相同专家的token
  3. 提高GPU缓存命中率
</span></code></pre>
<h5 data-id="heading-61">选取原因</h5>
<p><strong>1. 稀疏性的力量</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">在极大规模模型中：
<span class="hljs-bullet">  -</span> 标准模型每个token都要经过每个参数 → 计算量巨大
<span class="hljs-bullet">  -</span> MoE让每个token只经过部分参数 → 大幅减少计算

例子：Google GLaM
<span class="hljs-bullet">  -</span> 1.2 万亿参数的MoE模型
<span class="hljs-bullet">  -</span> 计算量仅相当于100B标准模型
</code></pre>
<p><strong>2. 模型缩放的新方向</strong></p>
<pre><code class="hljs language-erlang" lang="erlang">参数缩放：基本饱和（<span class="hljs-number">10</span>B→<span class="hljs-number">100</span>B效果递减）

计算缩放：有效但不够快（计算<span class="hljs-number">4</span>倍→性能仅提升~<span class="hljs-number">40</span><span class="hljs-comment">%）</span>

稀疏缩放（MoE）：极有效（计算<span class="hljs-number">4</span>倍→性能提升~<span class="hljs-number">60</span><span class="hljs-comment">%）⭐</span>
             可以用更少计算得到更强模型
</code></pre>
<p><strong>3. 工业级应用的可行性</strong></p>
<pre><code class="hljs language-r" lang="r">有了MoE，才能在实际中训练<span class="hljs-operator">/</span>运行最强大的模型

Switch Transformer：<span class="hljs-number">1.6</span><span class="hljs-built_in">T</span>参数，但激活参数仅相当于<span class="hljs-number">30</span>B
Google<span class="hljs-string">'s Gemini MoE：参数巨大，但高效可用
</span></code></pre>
<h5 data-id="heading-62">共享专家（Shared Experts）设计</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> config.n_shared_experts <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    y = y + self.shared_experts(identity)
</code></pre>
<p>为什么需要共享专家？</p>






























<table><thead><tr><th>特性</th><th>纯MoE</th><th>共享+MoE</th></tr></thead><tbody><tr><td><strong>容量</strong></td><td>所有专家都路由</td><td>共享专家始终活跃</td></tr><tr><td><strong>稳定性</strong></td><td>需要强制均衡</td><td>自然更均衡</td></tr><tr><td><strong>泛化</strong></td><td>可能过专化</td><td>更一般化</td></tr><tr><td><strong>计算</strong></td><td>最少</td><td>略高</td></tr></tbody></table>
<pre><code class="hljs language-markdown" lang="markdown">共享专家的作用：
<span class="hljs-bullet">  -</span> 所有token都经过共享专家 → 提供基础特征
<span class="hljs-bullet">  -</span> 路由专家基于token的特殊性 → 提供特化特征
<span class="hljs-bullet">  -</span> 合并：y = y<span class="hljs-emphasis">_routed + y_</span>shared ⭐

类比：
  共享专家 ≈ 通用骨架
  路由专家 ≈ 特化模块
</code></pre>
<h5 data-id="heading-63">核心优势总结</h5>
<pre><code class="hljs language-markdown" lang="markdown">模型参数巨大但计算精简
<span class="hljs-code">    ↓
稀疏激活的力量
    ↓
用更少计算达到更强性能
    ↓
可以训练超大规模模型
    ↓
适合实际工业应用
</span></code></pre>
<hr/>
<h3 data-id="heading-64">前馈网络架构演进</h3>
<pre><code class="hljs language-scss" lang="scss">时代 <span class="hljs-number">1</span> (<span class="hljs-number">2017</span>)：标准FFN
  dim → <span class="hljs-number">4</span>*dim → dim
  激活：ReLU
  参数：<span class="hljs-number">8</span>D²

         ↓ <span class="hljs-selector-attr">[质量瓶颈]</span>

时代 <span class="hljs-number">2</span> (<span class="hljs-number">2018</span>-<span class="hljs-number">2020</span>)：GELU激活函数
  dim → <span class="hljs-number">4</span>*dim → dim
  激活：GELU
  参数：<span class="hljs-number">8</span>D²
  质量提升：~<span class="hljs-number">15%</span>

         ↓ <span class="hljs-selector-attr">[容量瓶颈]</span>

时代 <span class="hljs-number">3</span> (<span class="hljs-number">2020</span>-<span class="hljs-number">2022</span>)：门控和SwiGLU
  dim → <span class="hljs-number">2.67</span>*dim → dim (两分支)
  激活：SiLU + 门控
  参数：<span class="hljs-number">8</span>D²（但效果更好）
  质量提升：+<span class="hljs-number">3%</span> vs GELU

         ↓ <span class="hljs-selector-attr">[缩放瓶颈]</span>

时代 <span class="hljs-number">4</span> (<span class="hljs-number">2022</span>+)：MoE混合专家 ⭐
  dim → 多个专家 → dim
  激活：SwiGLU + 稀疏路由
  参数：<span class="hljs-number">10</span>D² (但激活仅<span class="hljs-number">2</span>/<span class="hljs-number">8</span>)
  质量提升：+<span class="hljs-number">60%</span> vs 标准FFN（相同计算）
  可扩展：到数万亿参数
</code></pre>
<hr/>
<h3 data-id="heading-65">与标准FFN的完整对比</h3>
<h4 data-id="heading-66">标准FFN (原始Transformer)</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 简单线性变换</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardFFN</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):
        self.w1 = nn.Linear(dim, <span class="hljs-number">4</span>*dim)
        self.w2 = nn.Linear(<span class="hljs-number">4</span>*dim, dim)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-keyword">return</span> self.w2(F.relu(self.w1(x)))

效果：基准
计算：基准
参数：8D²
</code></pre>
<h4 data-id="heading-67">SwiGLU FFN (MiniMind采用)</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 门控双路径设计</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FeedForward</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):
        self.w1 = nn.Linear(dim, hidden_dim)
        self.w2 = nn.Linear(hidden_dim, dim)
        self.w3 = nn.Linear(dim, hidden_dim)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-keyword">return</span> self.w2(F.silu(self.w1(x)) * self.w3(x))

效果：+<span class="hljs-number">3</span>% vs GELU
计算：中等
参数：8D²（但更高效）
</code></pre>
<h4 data-id="heading-68">MoE FFN (可选)</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 稀疏专家路由</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MOEFeedForward</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):
        self.experts = [FeedForward(config) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_experts)]
        self.gate = MoEGate(config)
        self.shared_experts = FeedForward(config)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        idx, weight, aux_loss = self.gate(x)  <span class="hljs-comment"># 路由</span>
        y = self._route(x, idx, weight)       <span class="hljs-comment"># 分发</span>
        y = y + self.shared_experts(x)        <span class="hljs-comment"># 共享</span>
        <span class="hljs-keyword">return</span> y

效果：+<span class="hljs-number">60</span>% vs 标准FFN（相同计算）
计算：减少 <span class="hljs-number">75</span>%（激活参数）
参数：10D²（但仅<span class="hljs-number">2</span>/<span class="hljs-number">8</span>活跃）
可扩展：最好
</code></pre>
<hr/>
<h3 data-id="heading-69">对标原始GPT论文的改进</h3>
<p>原始GPT论文中的FFN：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-string">"We employed a position-wise feed-forward network
which consists of two linear transformations with a
ReLU activation in between."</span>

<span class="hljs-keyword">dim</span> → <span class="hljs-number">4</span>*<span class="hljs-keyword">dim</span> → <span class="hljs-keyword">dim</span> <span class="hljs-keyword">with</span> ReLU
</code></pre>
<p>MiniMind的改进：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 激活函数升级：ReLU → GELU → SwiGLU
   质量提升：+30% (相同参数)

<span class="hljs-bullet">2.</span> 智能门控：添加第三个投影 (W3)
   参数相同，表达力大幅提升

<span class="hljs-bullet">3.</span> 可选稀疏化：标准FFN → MoE
   计算减少：75%（推理）
   性能：+60%（相同计算）
</code></pre>
<hr/>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> <strong>优化技术</strong> (参数共享, 生成采样策略)</li>
<li class="task-list-item"><input type="checkbox" disabled="disabled"/> <strong>完整总结</strong> (所有技术综合评分)</li>
</ul>
<h2 data-id="heading-70">MiniMind 优化技术详解</h2>
<h3 data-id="heading-71">三、优化技术</h3>
<h4 data-id="heading-72">1. 参数共享（Weight Tying）</h4>
<h5 data-id="heading-73">代码位置</h5>
<p><code>model/model.py:562-578</code></p>
<h5 data-id="heading-74">实现原理</h5>
<p><strong>初始化阶段</strong> (model.py:562-578)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiniMindLM</span>(<span class="hljs-title class_ inherited__">PreTrainedModel</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, params: LMConfig = <span class="hljs-literal">None</span></span>):
        <span class="hljs-comment"># ... 其他初始化代码 ...</span>

        <span class="hljs-comment"># 词元嵌入层：将token ID映射为向量表示</span>
        self.tok_embeddings = nn.Embedding(params.vocab_size, params.dim)

        <span class="hljs-comment"># 输出层：将隐藏状态映射为词汇表大小的logits</span>
        self.output = nn.Linear(params.dim, params.vocab_size, bias=<span class="hljs-literal">False</span>)

        <span class="hljs-comment"># ⭐ 关键：参数共享</span>
        <span class="hljs-comment"># 让输出层的权重与嵌入层权重指向同一个参数张量</span>
        self.tok_embeddings.weight = self.output.weight
</code></pre>
<h5 data-id="heading-75">数学原理</h5>
<pre><code class="hljs language-r" lang="r">标准方式：
  嵌入矩阵：W_emb <span class="hljs-punctuation">[</span>vocab_size<span class="hljs-punctuation">,</span> <span class="hljs-built_in">dim</span><span class="hljs-punctuation">]</span>
  输出矩阵：W_out <span class="hljs-punctuation">[</span><span class="hljs-built_in">dim</span><span class="hljs-punctuation">,</span> vocab_size<span class="hljs-punctuation">]</span>
  总参数：vocab_size <span class="hljs-operator">*</span> <span class="hljs-built_in">dim</span> <span class="hljs-operator">*</span> <span class="hljs-number">2</span>

参数共享：
  共享矩阵：W <span class="hljs-punctuation">[</span>vocab_size<span class="hljs-punctuation">,</span> <span class="hljs-built_in">dim</span><span class="hljs-punctuation">]</span>
  嵌入：token_id → W<span class="hljs-punctuation">[</span>token_id<span class="hljs-punctuation">,</span> <span class="hljs-operator">:</span><span class="hljs-punctuation">]</span> ∈ ℝ<span class="hljs-operator">^</span><span class="hljs-built_in">dim</span>
  输出：h ∈ ℝ<span class="hljs-operator">^</span><span class="hljs-built_in">dim</span> → h <span class="hljs-operator">@</span> W<span class="hljs-operator">^</span><span class="hljs-built_in">T</span> ∈ ℝ<span class="hljs-operator">^</span>vocab_size
  总参数：vocab_size <span class="hljs-operator">*</span> <span class="hljs-built_in">dim</span>（减少<span class="hljs-number">50</span>%！）
</code></pre>
<h5 data-id="heading-76">前向计算对比</h5>
<p><strong>标准方式</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 嵌入阶段</span>
h = embedding_matrix[input_ids]  <span class="hljs-comment"># [B, S, dim]</span>

<span class="hljs-comment"># 输出阶段</span>
logits = h @ output_matrix       <span class="hljs-comment"># [B, S, vocab_size]</span>
</code></pre>
<p><strong>参数共享</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 嵌入和输出共用同一个矩阵W [vocab_size, dim]</span>

<span class="hljs-comment"># 嵌入阶段</span>
h = W[input_ids, :]              <span class="hljs-comment"># [B, S, dim]</span>

<span class="hljs-comment"># 输出阶段（W是嵌入层权重的引用）</span>
logits = h @ W.T                 <span class="hljs-comment"># [B, S, vocab_size]</span>
</code></pre>
<h5 data-id="heading-77">影响分析</h5>








































<table><thead><tr><th>方面</th><th>标准方式</th><th>参数共享</th></tr></thead><tbody><tr><td><strong>参数数量</strong></td><td>vocab_size × dim × 2</td><td>vocab_size × dim ⭐</td></tr><tr><td><strong>参数减少</strong></td><td>基准</td><td><strong>50%</strong></td></tr><tr><td><strong>显存占用</strong></td><td>基准</td><td><strong>减少 50%</strong></td></tr><tr><td><strong>计算量</strong></td><td>基准</td><td>相同</td></tr><tr><td><strong>精度</strong></td><td>基准</td><td>相同</td></tr><tr><td><strong>训练稳定性</strong></td><td>基准</td><td>稍差（但可接受）</td></tr></tbody></table>
<h5 data-id="heading-78">参数量估算示例</h5>
<p>以Llama-7B为例：</p>
<pre><code class="hljs language-ini" lang="ini">Vocabulary size: 32,000
Hidden dimension: 4,096

标准方式：
  嵌入参数：32,000 × 4,<span class="hljs-attr">096</span> = <span class="hljs-number">131.1</span>M
  输出参数：4,096 × 32,<span class="hljs-attr">000</span> = <span class="hljs-number">131.1</span>M
  总计：262.2M 参数（占模型约3.8%）

参数共享：
  共享参数：32,000 × 4,<span class="hljs-attr">096</span> = <span class="hljs-number">131.1</span>M
  总计：131.1M 参数（减少 50%）

节省显存：
  32-bit: 262.2M × <span class="hljs-attr">4B</span> = <span class="hljs-number">1.05</span>GB
  半精度: 262.2M × <span class="hljs-attr">2B</span> = <span class="hljs-number">0.52</span>GB
</code></pre>
<h5 data-id="heading-79">选取原因</h5>
<p><strong>1. 嵌入和输出的对称性</strong></p>
<pre><code class="hljs">语言模型的本质是：token编码 → 中间表示 → token解码

嵌入层：token_id → 向量
输出层：向量 → token_id

这两个操作在数学上应该互为转置关系！
</code></pre>
<p><strong>语言模型假设</strong>：</p>
<pre><code class="hljs language-css" lang="css">一个token的嵌入向量应该与输出时的得分向量相近

即：
  token <span class="hljs-selector-tag">i</span> 的嵌入向量 ≈ 模型预测token <span class="hljs-selector-tag">i</span>时的权重向量

如果使用同一个矩阵，这个关系会更强！
</code></pre>
<p><strong>2. 参数高效性</strong></p>
<pre><code class="hljs language-erlang" lang="erlang">模型的显存瓶颈：
  总参数数 = n_layers × (注意力参数 + FFN参数) + 嵌入+输出

对于大词汇表模型（如中文，词汇表&gt;<span class="hljs-number">50</span>K）：
  嵌入+输出可占总参数的 <span class="hljs-number">3</span>-<span class="hljs-number">10</span><span class="hljs-comment">%</span>
  参数共享可节省 <span class="hljs-number">1.5</span>-<span class="hljs-number">5</span><span class="hljs-comment">% 的总参数量</span>
</code></pre>
<p><strong>3. 现代LLM标准</strong></p>
<pre><code class="hljs">BERT：✅ 使用参数共享
GPT：✅ 使用参数共享
ALBERT：✅ 设计的核心特性
LLaMA：✅ 使用参数共享
T5：✅ 使用参数共享
</code></pre>
<h5 data-id="heading-80">潜在的缺点与应对</h5>
<p><strong>缺点 1：嵌入和输出学习目标不同</strong></p>
<pre><code class="hljs">嵌入需要编码：token的语义、语法信息
输出需要判别：不同token的区别

强制使用同一个矩阵可能引入冲突
</code></pre>
<p>应对：<strong>隐层变换</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 使用一个额外的线性层解耦</span>
self.output = nn.Linear(params.dim, params.vocab_size, bias=<span class="hljs-literal">False</span>)
<span class="hljs-comment"># 但不再使用共享权重</span>
<span class="hljs-comment"># 而是使用投影层进行变换</span>
</code></pre>
<p><strong>缺点 2：词汇表增长时问题</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">如果需要扩展词汇表（如添加新语言token）：
<span class="hljs-bullet">  -</span> 嵌入矩阵需要扩展：[vocab<span class="hljs-emphasis">_size_</span>old, dim] → [vocab<span class="hljs-emphasis">_size_</span>new, dim]
<span class="hljs-bullet">  -</span> 输出矩阵也需要扩展
<span class="hljs-bullet">  -</span> 如果参数共享，嵌入和输出同时扩展（没问题）
</code></pre>
<h5 data-id="heading-81">代码实现要点</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 正确的参数共享方式</span>
self.tok_embeddings = nn.Embedding(params.vocab_size, params.dim)
self.output = nn.Linear(params.dim, params.vocab_size, bias=<span class="hljs-literal">False</span>)

<span class="hljs-comment"># 关键：使嵌入层权重和输出层权重指向同一个参数</span>
self.tok_embeddings.weight = self.output.weight

<span class="hljs-comment"># 为什么这样做有效？</span>
<span class="hljs-comment"># 1. 嵌入：token_id → self.tok_embeddings.weight[token_id]</span>
<span class="hljs-comment"># 2. 输出：hidden → hidden @ self.output.weight.T</span>
<span class="hljs-comment">#        = hidden @ self.tok_embeddings.weight.T</span>
</code></pre>
<h5 data-id="heading-82">核心优势</h5>
<pre><code class="hljs language-erlang" lang="erlang">参数减少 <span class="hljs-number">50</span><span class="hljs-comment">%（嵌入+输出）</span>
    ↓
显存节省 <span class="hljs-number">1</span>-<span class="hljs-number">3</span><span class="hljs-comment">%（总模型）</span>
    ↓
训练速度稍快
    ↓
对齐嵌入和输出的学习目标
    ↓
成本收益比极高
</code></pre>
<hr/>
<h4 data-id="heading-83">2. 生成采样策略</h4>
<h5 data-id="heading-84">代码位置</h5>
<p><code>model/model.py:710-773</code></p>
<h5 data-id="heading-85">实现原理</h5>
<p><strong>流式生成的完整流程</strong> (model.py:710-773)：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_stream</span>(<span class="hljs-params">self, input_ids, eos_token_id, max_new_tokens,
            temperature, top_p, rp, use_cache, **args</span>):
    <span class="hljs-string">"""
    逐token生成的流式采样函数
    """</span>
    start, first_seq, past_kvs = input_ids.shape[<span class="hljs-number">1</span>], <span class="hljs-literal">True</span>, <span class="hljs-literal">None</span>

    <span class="hljs-keyword">while</span> input_ids.shape[<span class="hljs-number">1</span>] &lt; max_new_tokens - <span class="hljs-number">1</span>:
        <span class="hljs-comment"># 推理：获取logits</span>
        <span class="hljs-keyword">if</span> first_seq <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> use_cache:
            out = self(input_ids, past_key_values=past_kvs, use_cache=use_cache)
        <span class="hljs-keyword">else</span>:
            out = self(input_ids[:, -<span class="hljs-number">1</span>:], past_key_values=past_kvs,
                      use_cache=use_cache, start_pos=input_ids.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)

        logits, past_kvs = out.logits[:, -<span class="hljs-number">1</span>, :], out.past_key_values

        <span class="hljs-comment"># ⭐ 策略 1：重复惩罚（Repetition Penalty）</span>
        logits[:, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(input_ids.tolist()[<span class="hljs-number">0</span>]))] /= rp

        <span class="hljs-comment"># ⭐ 策略 2：温度缩放（Temperature Scaling）</span>
        logits /= (temperature + <span class="hljs-number">1e-9</span>)

        <span class="hljs-comment"># ⭐ 策略 3：核采样（Top-p/Nucleus Sampling）</span>
        <span class="hljs-keyword">if</span> top_p <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> top_p &lt; <span class="hljs-number">1.0</span>:
            sorted_logits, sorted_indices = torch.sort(logits, descending=<span class="hljs-literal">True</span>, dim=-<span class="hljs-number">1</span>)
            sorted_probs = F.softmax(sorted_logits, dim=-<span class="hljs-number">1</span>)
            cumulative_probs = torch.cumsum(sorted_probs, dim=-<span class="hljs-number">1</span>)

            <span class="hljs-comment"># 找出超过threshold的位置</span>
            sorted_indices_to_remove = cumulative_probs &gt; top_p
            sorted_indices_to_remove[:, <span class="hljs-number">1</span>:] = sorted_indices_to_remove[:, :-<span class="hljs-number">1</span>].clone()
            sorted_indices_to_remove[:, <span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>

            indices_to_remove = sorted_indices_to_remove.scatter(<span class="hljs-number">1</span>, sorted_indices,
                                                                  sorted_indices_to_remove)
            logits[indices_to_remove] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">'Inf'</span>)

        <span class="hljs-comment"># ⭐ 策略 4：多项式采样（Multinomial Sampling）</span>
        input_ids_next = torch.multinomial(F.softmax(logits, dim=-<span class="hljs-number">1</span>), num_samples=<span class="hljs-number">1</span>)
        input_ids = torch.cat((input_ids, input_ids_next), dim=<span class="hljs-number">1</span>)

        <span class="hljs-keyword">yield</span> input_ids[:, start:]

        <span class="hljs-keyword">if</span> input_ids_next.item() == eos_token_id:
            <span class="hljs-keyword">break</span>
</code></pre>
<h5 data-id="heading-86">四大采样策略详解</h5>
<p><strong>策略 1：重复惩罚（Repetition Penalty）</strong> [model.py:742]</p>
<pre><code class="hljs language-python" lang="python">logits[:, <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(input_ids.tolist()[<span class="hljs-number">0</span>]))] /= rp
</code></pre>
<p><strong>目的</strong>：避免生成重复文本</p>
<p><strong>工作原理</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">已生成的token：<span class="hljs-section">[我, 是, 一, 个, AI]</span>

重复惩罚（<span class="hljs-attr">rp</span> = <span class="hljs-number">1.2</span>）：
  对已经出现过的token，降低其logit值
  logit<span class="hljs-section">[我]</span> = logit<span class="hljs-section">[我]</span> / 1.2
  logit<span class="hljs-section">[是]</span> = logit<span class="hljs-section">[是]</span> / 1.2
  ...

效果：
  这些token被选中的概率下降
  → 新的token被选中的概率上升
  → 避免"我我我"或"是是是"
</code></pre>
<p><strong>参数说明</strong>：</p>
<ul>
<li><code>rp = 1.0</code>：无惩罚（允许重复）</li>
<li><code>rp = 1.2</code>：轻度惩罚（推荐）</li>
<li><code>rp = 2.0</code>：强度惩罚（可能失去必要的重复）</li>
</ul>






























<table><thead><tr><th>值</th><th>效果</th><th>使用场景</th></tr></thead><tbody><tr><td>1.0</td><td>允许重复</td><td>列表、枚举</td></tr><tr><td>1.2</td><td><strong>轻度限制</strong></td><td><strong>通用对话</strong> ⭐</td></tr><tr><td>1.5</td><td>中等限制</td><td>创意写作</td></tr><tr><td>2.0+</td><td>严格禁止</td><td>多样性要求高</td></tr></tbody></table>
<hr/>
<p><strong>策略 2：温度缩放（Temperature Scaling）</strong> [model.py:744]</p>
<pre><code class="hljs language-python" lang="python">logits /= (temperature + <span class="hljs-number">1e-9</span>)
</code></pre>
<p><strong>目的</strong>：控制生成的随机性/确定性程度</p>
<p><strong>工作原理</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">Softmax 概率计算：
  <span class="hljs-selector-tag">P</span>(token_i) = <span class="hljs-built_in">exp</span>(logits_i / temperature) / Σ <span class="hljs-built_in">exp</span>(logits_j / temperature)

temperature = <span class="hljs-number">0.1</span>（低温）：
  <span class="hljs-built_in">exp</span>(logits_i / <span class="hljs-number">0.1</span>) 放大了logits的差异
  → 分布尖锐，概率高的token更容易被选中
  → 生成结果确定、连贯

temperature = <span class="hljs-number">1.0</span>（常温）：
  标准 softmax
  → 平衡的随机性

temperature = <span class="hljs-number">2.0</span>（高温）：
  <span class="hljs-built_in">exp</span>(logits_i / <span class="hljs-number">2.0</span>) 缩小了logits的差异
  → 分布平坦，所有token概率接近
  → 生成结果随意、多样
</code></pre>
<p><strong>可视化</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">Logits: <span class="hljs-section">[2.0, 1.0, 0.5]</span>

<span class="hljs-attr">Temperature</span> = <span class="hljs-number">0.1</span> (确定模式):
  <span class="hljs-attr">P</span> = softmax([<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>]) ≈ [<span class="hljs-number">0.999</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.0</span>]
  ↓ 高概率token几乎必中

<span class="hljs-attr">Temperature</span> = <span class="hljs-number">1.0</span> (平衡模式):
  <span class="hljs-attr">P</span> = softmax([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>]) ≈ [<span class="hljs-number">0.659</span>, <span class="hljs-number">0.242</span>, <span class="hljs-number">0.099</span>]
  ↓ 保留一定的随机性

<span class="hljs-attr">Temperature</span> = <span class="hljs-number">2.0</span> (随机模式):
  <span class="hljs-attr">P</span> = softmax([<span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.25</span>]) ≈ [<span class="hljs-number">0.409</span>, <span class="hljs-number">0.326</span>, <span class="hljs-number">0.265</span>]
  ↓ 所有token概率接近，高度随意
</code></pre>






























<table><thead><tr><th>温度</th><th>行为</th><th>使用场景</th></tr></thead><tbody><tr><td>0.1-0.5</td><td>确定、保守</td><td>代码、数据、事实问答</td></tr><tr><td>0.7-0.8</td><td><strong>平衡</strong></td><td><strong>通用对话</strong> ⭐</td></tr><tr><td>1.0-1.5</td><td>创意、多样</td><td>故事创作、诗歌</td></tr><tr><td>2.0+</td><td>极度随意</td><td>数据增强、探索</td></tr></tbody></table>
<hr/>
<p><strong>策略 3：核采样（Top-p/Nucleus Sampling）</strong> [model.py:747-763]</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">if</span> top_p <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> top_p &lt; <span class="hljs-number">1.0</span>:
    sorted_logits, sorted_indices = torch.sort(logits, descending=<span class="hljs-literal">True</span>, dim=-<span class="hljs-number">1</span>)
    sorted_probs = F.softmax(sorted_logits, dim=-<span class="hljs-number">1</span>)
    cumulative_probs = torch.cumsum(sorted_probs, dim=-<span class="hljs-number">1</span>)

    sorted_indices_to_remove = cumulative_probs &gt; top_p
    sorted_indices_to_remove[:, <span class="hljs-number">1</span>:] = sorted_indices_to_remove[:, :-<span class="hljs-number">1</span>].clone()
    sorted_indices_to_remove[:, <span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>

    indices_to_remove = sorted_indices_to_remove.scatter(<span class="hljs-number">1</span>, sorted_indices,
                                                          sorted_indices_to_remove)
    logits[indices_to_remove] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">'Inf'</span>)
</code></pre>
<p><strong>目的</strong>：动态选择候选token集合，避免选择低概率token</p>
<p><strong>工作原理</strong>（示例）：</p>
<pre><code class="hljs language-ini" lang="ini">概率分布（已排序）：
  P(token_A) = 0.50 → 累积: 0.50 ✅ 保留
  P(token_B) = 0.25 → 累积: 0.75 ✅ 保留
  P(token_C) = 0.15 → 累积: 0.90 ✅ 保留
  P(token_D) = 0.08 → 累积: 0.98 ❌ 移除（超过<span class="hljs-attr">top_p</span>=<span class="hljs-number">0.9</span>）
  P(token_E) = 0.02 → 累积: 1.00 ❌ 移除

Top-p采样：从<span class="hljs-section">[A, B, C]</span>中随机选择
          P(A|selected) = 0.50/<span class="hljs-attr">0.90</span> = <span class="hljs-number">0.556</span>
          P(B|selected) = 0.25/<span class="hljs-attr">0.90</span> = <span class="hljs-number">0.278</span>
          P(C|selected) = 0.15/<span class="hljs-attr">0.90</span> = <span class="hljs-number">0.167</span>
</code></pre>
<p><strong>与Top-k的对比</strong>：</p>



































<table><thead><tr><th>特性</th><th>Top-k采样</th><th>Top-p采样</th></tr></thead><tbody><tr><td><strong>原理</strong></td><td>保留概率最高的k个token</td><td>保留累积概率达p的token</td></tr><tr><td><strong>候选数</strong></td><td>固定k</td><td>动态（取决于分布）</td></tr><tr><td><strong>低置信度情况</strong></td><td>可能包含低分token</td><td>自动过滤</td></tr><tr><td><strong>高置信度情况</strong></td><td>可能过度限制</td><td>自动放松</td></tr><tr><td><strong>推荐值</strong></td><td>k=50</td><td><strong>p=0.9</strong> ⭐</td></tr></tbody></table>
<p><strong>工作场景对比</strong>：</p>
<pre><code class="hljs language-css" lang="css">高置信情况（模型很确定答案）：
  <span class="hljs-attribute">Top</span>-k (k=<span class="hljs-number">50</span>)：强制选择<span class="hljs-number">50</span>个token
               可能包含不相关的token

  <span class="hljs-attribute">Top</span>-<span class="hljs-selector-tag">p</span> (<span class="hljs-selector-tag">p</span>=<span class="hljs-number">0.9</span>)：可能只需<span class="hljs-number">5</span>个token就达到<span class="hljs-number">0.9</span>
                自动缩小候选集
                更优！✅

低置信情况（模型不确定答案）：
  <span class="hljs-attribute">Top</span>-k (k=<span class="hljs-number">50</span>)：保留<span class="hljs-number">50</span>个token
               可能包含很低分的

  <span class="hljs-attribute">Top</span>-<span class="hljs-selector-tag">p</span> (<span class="hljs-selector-tag">p</span>=<span class="hljs-number">0.9</span>)：需要<span class="hljs-number">50</span>个token才能达到<span class="hljs-number">0.9</span>
                自动放松限制
                更优！✅
</code></pre>
<hr/>
<p><strong>策略 4：多项式采样（Multinomial Sampling）</strong> [model.py:766]</p>
<pre><code class="hljs language-python" lang="python">input_ids_next = torch.multinomial(F.softmax(logits, dim=-<span class="hljs-number">1</span>), num_samples=<span class="hljs-number">1</span>)
</code></pre>
<p><strong>目的</strong>：按概率分布随机采样下一个token</p>
<p><strong>与贪心解码的对比</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">贪心解码（Greedy Decoding）：
  selected_token = <span class="hljs-built_in">argmax</span>(logits)
  ↓ 总是选择概率最高的token
  ↓ 确定但可能陷入局部最优

多项式采样（Multinomial Sampling）：
  <span class="hljs-selector-tag">P</span>(token_i) ∝ <span class="hljs-built_in">exp</span>(logits_i)
  selected_token ~ <span class="hljs-built_in">Multinomial</span>(P)
  ↓ 按概率随机选择
  ↓ 保留一定随机性，发现更多可能性
</code></pre>
<p><strong>概率示例</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">logits</span> = [<span class="hljs-number">2.0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">0.5</span>]
<span class="hljs-attr">P</span> = softmax(logits) = [<span class="hljs-number">0.659</span>, <span class="hljs-number">0.242</span>, <span class="hljs-number">0.099</span>]

多项式采样：
  - 65.9% 概率选token_0
  - 24.2% 概率选token_1
  - 9.9% 概率选token_2

而不是总是选token_0（贪心）
</code></pre>
<hr/>
<h5 data-id="heading-87">采样策略的完整流程</h5>
<pre><code class="hljs language-scss" lang="scss">logits <span class="hljs-selector-attr">[vocab_size]</span>
    ↓
<span class="hljs-selector-attr">[1]</span> 重复惩罚
    对已出现的token：logits /= rp
    ↓ logits_penalized

<span class="hljs-selector-attr">[2]</span> 温度缩放
    logits /= temperature
    ↓ logits_scaled

<span class="hljs-selector-attr">[3]</span> 核采样（可选）
    <span class="hljs-attribute">mask</span> out low-probability tokens
    ↓ logits_filtered

<span class="hljs-selector-attr">[4]</span> 多项式采样
    <span class="hljs-selector-tag">P</span> = <span class="hljs-built_in">softmax</span>(logits_filtered)
    token ~ <span class="hljs-built_in">Multinomial</span>(P)
    ↓
next_token
</code></pre>
<h5 data-id="heading-88">采样参数的推荐配置</h5>






















































<table><thead><tr><th>场景</th><th>temperature</th><th>top_p</th><th>rp</th><th>特点</th></tr></thead><tbody><tr><td><strong>代码生成</strong></td><td>0.1</td><td>0.95</td><td>1.0</td><td>确定、无重复限制</td></tr><tr><td><strong>事实问答</strong></td><td>0.7</td><td>0.90</td><td>1.2</td><td>准确、避免重复</td></tr><tr><td><strong>对话交互</strong></td><td>0.8</td><td>0.90</td><td>1.2</td><td><strong>平衡</strong> ⭐</td></tr><tr><td><strong>故事创作</strong></td><td>1.2</td><td>0.85</td><td>1.1</td><td>创意、连贯</td></tr><tr><td><strong>数据增强</strong></td><td>1.5</td><td>0.80</td><td>1.0</td><td>多样、自由</td></tr><tr><td><strong>极度创意</strong></td><td>2.0</td><td>0.75</td><td>1.0</td><td>随意、无约束</td></tr></tbody></table>
<h5 data-id="heading-89">选取原因</h5>
<p><strong>1. 解决模式坍塌（Mode Collapse）</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">在生成任务中，如果只使用贪心解码：
<span class="hljs-bullet">  -</span> 模型总是选择概率最高的token
<span class="hljs-bullet">  -</span> 生成的文本虽然通顺，但极其单调
<span class="hljs-bullet">  -</span> 重复某些短语："我很高兴...我很高兴...我很高兴"

采样策略可以：
<span class="hljs-bullet">  -</span> 保留多样性
<span class="hljs-bullet">  -</span> 让"合理但不是最优"的token有机会被选中
<span class="hljs-bullet">  -</span> 生成更自然的文本
</code></pre>
<p><strong>2. 平衡质量和多样性</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">贪心：高质量 ✅，低多样性 ❌
采样：中等质量，高多样性 ✅

采样策略的组合：
<span class="hljs-bullet">  -</span> 温度：控制随机性程度
<span class="hljs-bullet">  -</span> Top-p：动态选择候选集
<span class="hljs-bullet">  -</span> 重复惩罚：避免冗余
<span class="hljs-bullet">  -</span> 多项式采样：最终选择

四者结合 → 既保持质量，又保留多样性 ⭐
</code></pre>
<p><strong>3. 实用性</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">所有先进LLM都使用采样生成：
<span class="hljs-bullet">  -</span> ChatGPT
<span class="hljs-bullet">  -</span> Claude
<span class="hljs-bullet">  -</span> Gemini
<span class="hljs-bullet">  -</span> LLaMA

都是 temperature + top<span class="hljs-emphasis">_p + 重复惩罚 的组合
</span></code></pre>
<h5 data-id="heading-90">核心优势</h5>
<pre><code class="hljs language-markdown" lang="markdown">避免生成单调重复文本
<span class="hljs-code">    ↓
保持多样性和创意性
    ↓
平衡质量和随机性
    ↓
适应不同应用场景
    ↓
提升用户体验
</span></code></pre>
<hr/>
<h3 data-id="heading-91">优化技术对比总结</h3>















































<table><thead><tr><th>技术</th><th>改进目标</th><th>实现复杂度</th><th>收益</th><th>现状</th></tr></thead><tbody><tr><td><strong>参数共享</strong></td><td>模型大小</td><td>⭐ 极简</td><td>参数减少50%</td><td>🔥 标准</td></tr><tr><td><strong>重复惩罚</strong></td><td>生成质量</td><td>⭐ 极简</td><td>避免重复</td><td>🔥 必需</td></tr><tr><td><strong>温度缩放</strong></td><td>生成多样性</td><td>⭐ 极简</td><td>可调随机性</td><td>🔥 必需</td></tr><tr><td><strong>核采样</strong></td><td>生成效率</td><td>⭐⭐ 简单</td><td>动态候选集</td><td>🔥 推荐</td></tr><tr><td><strong>多项式采样</strong></td><td>生成方式</td><td>⭐ 极简</td><td>保留多样性</td><td>🔥 标准</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-92">与标准GPT的改进对比</h3>
<h4 data-id="heading-93">原始GPT论文</h4>
<pre><code class="hljs language-scss" lang="scss">参数：嵌入矩阵 + 输出矩阵（分开）
生成：贪心解码 <span class="hljs-built_in">argmax</span>(logits)
      → 单调、重复
</code></pre>
<h4 data-id="heading-94">MiniMind的改进</h4>
<pre><code class="hljs language-css" lang="css">参数：参数共享
      → 减少 <span class="hljs-number">50%</span> 的嵌入+输出参数

生成：四阶段采样策略
      <span class="hljs-selector-attr">[重复惩罚]</span> → <span class="hljs-selector-attr">[温度缩放]</span> → <span class="hljs-selector-attr">[核采样]</span> → <span class="hljs-selector-attr">[多项式采样]</span>
      → 多样、流畅、自然
</code></pre>
<hr/>
<h3 data-id="heading-95">优化技术的实际效果</h3>
<h4 data-id="heading-96">参数共享的显存节省</h4>
<pre><code class="hljs language-ini" lang="ini">词汇表大小：32,000
模型维度：4,096

节省显存：32,000 × 4,096 × <span class="hljs-attr">4bytes</span> = <span class="hljs-number">0.52</span> GB（F32）
         32,000 × 4,096 × <span class="hljs-attr">2bytes</span> = <span class="hljs-number">0.26</span> GB（F16）

对于一个7B模型来说：节省 1-3% 显存
</code></pre>
<h4 data-id="heading-97">采样策略的生成质量对比</h4>















































<table><thead><tr><th>设置</th><th>文本流畅度</th><th>重复率</th><th>多样性</th><th>推荐度</th></tr></thead><tbody><tr><td><strong>贪心解码</strong></td><td>高</td><td>高</td><td>低</td><td>❌</td></tr><tr><td><strong>Temperature=0.8</strong></td><td>高</td><td>低</td><td>中</td><td>⭐⭐</td></tr><tr><td><strong>Top-p=0.9</strong></td><td>高</td><td>中</td><td>高</td><td>⭐⭐⭐</td></tr><tr><td><strong>T=0.8 + p=0.9</strong></td><td>高</td><td>低</td><td>高</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>T=0.8 + p=0.9 + rp=1.2</strong></td><td><strong>最优</strong></td><td><strong>最低</strong></td><td><strong>高</strong></td><td>⭐⭐⭐⭐⭐</td></tr></tbody></table>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Elasticsearch 避坑指南：我在项目中总结的 14 条实用经验]]></title>    <link>https://juejin.cn/post/7569959427879567370</link>    <guid>https://juejin.cn/post/7569959427879567370</guid>    <pubDate>2025-11-09T13:45:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7569959427879567370" data-draft-id="7567249547006607387" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Elasticsearch 避坑指南：我在项目中总结的 14 条实用经验"/> <meta itemprop="keywords" content="Elasticsearch,后端,性能优化"/> <meta itemprop="datePublished" content="2025-11-09T13:45:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="红尘旅人"/> <meta itemprop="url" content="https://juejin.cn/user/3485898277388519"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Elasticsearch 避坑指南：我在项目中总结的 14 条实用经验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3485898277388519/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    红尘旅人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-09T13:45:03.000Z" title="Sun Nov 09 2025 13:45:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#2b2b2b;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(159,219,252,.15) 3%,transparent 0),linear-gradient(1turn,rgba(159,219,252,.15) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin-top:35px;margin-bottom:10px;color:#4dd0e1}.markdown-body h1{font-size:30px;text-align:center;position:relative;width:max-content;margin:0 auto}.markdown-body h1:before{position:absolute;content:"";z-index:-1;top:-20px;height:100%;width:100px;left:0;right:0;margin:0 auto;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADsAAAA6CAYAAAAOeSEWAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAABkLSURBVGhDtZoHnJ1llcbP3Om9ZiYzmfSQhCQQIbRQVQKI9CYC68qKriJK0UXcZRcINqStIoiIqKCi1NACQihBWiCkkJ5MJlMyvd7p7d759v989/sy34yTbIj48Atz71ff855znvOc971xDrB/EtoGI7a9Z8Aq+wZML0mNj7dE95NZ1OKsj1dHo1GbnJpss9OTbWJyonvun4VP1Njuoagtb+m0it4By0iIt8LEeMvkr8XFWcfgkA1gYDLf47i2PzpsyU7UspKSLDoctagTZ7Vc08MzClMS7awJ2ZaflBB78CeET8TYla1dtrKt2w5KS7YCDGzEoz2RqKUmhGw6x2bhuXyOp2BoRXef1Q1E7Lj8TIsMD1sbxu1kcnYSAX1810RMTUmyMB7f2j1gC7NS7byinNiL/kH8Q8a+2NRh77b32El56VaPAe0YeGR2mh2bm+FdMRqP1rbZe+3dFsHT35qcb/Oz0rwzo7Gxs9feYPLS4kM2h8lawee5hPmlJXneFQeGAzJ2F564v7rFzi7Msu3d/Xgjzq5g8ArX8VCNN2vJ28daey0zZJabmGCLslP5HOf+Oygr3UzDGOf+JxrauXfQjslJt+dbuuyMgiwmk+sPAB/b2Lt2NdoMZnuY21qHIvbvUyZ4Z0ZQiXGrWjvsmPxsK4R0nmHA8ZCTQvxVQn5eRipklIBtcVbV1WtHYsjati47ZWKuTUpP9Z4yGk/xDBGe3v1mW4/dOrvYO7P/2G9jRSjf31FnXyaUXiB8r51WaJkM3kcfOSa2FR6qarIenooTLQHPLcC4mYThyw1tVpKWYlVERlZ8nC3Oz3Jzdn1nn5uvQ8OOHYvhR/CvsqffJbkCkZTvcYZ6Z0WTfTovw5Y1dtjXp+TbFPhgf7FfxpYxuMfr2uwo8rEtMmwXF+d6Z8wGmIR2PLyjo8cqOFffP2SLGexJEJCP9R29thkPXlpa4A5Y3w/jmuVNYYwO2QkY7WMtz3mVcE1hkualJdmSolzX8GnpKd4VZq80d1o7zN0RdWxGaqItgbn3B/+vsasgh/UMNBOvzYMZDxtDKp289KGaVguFQvb1yQWWwuB97GaSXqUUnVaYbSUwrDCEBz/C2CM8EhNrP13fbkeSh3OJgCAe2N1CWXKsGOc6TOr5U4q8MwYhDtkTda02MyPN+nnGBQEH7A37NHYz5KOZVv08qyjbSseEzKauPnsMj98wc6Ibcj5UUv7M8QWZTE52jEwGOVaD8U1Dw1YNWX0qM8VKyb80L/TrOPYOzH4KBJQTrK8M7+7KZjuM63sHBt17FubGoibCuf+tarWFGUmuwWeT8/vCXo1tZOYeZcazCaez8MwEzzM+HqhqtiJI5twxL1jeGLYk7jmKMF1JOCbg6Qj5nAdRqX7q3BYm8VAmQvW1lfcMc58IT95uIA3q+gftrDHPXUXJWkVEHJme5Bp5UmHsvIZ/O3l8ECE/FWcsItX2hr0ae8O2Wjs+J43QTbOZzGYQ/7Wtxq6eXjRK3r0By4YJ6Ty8EiYSJqcm2eGeV4Pox/ANENJR49RiEdfqcLflUJrEBZqgxYHrBjn2ExFURqKdVETN9YirJxKxR2rbrYeQv5ISmB6IsiDGNfZGWPeMgkzr58xnPaJ5p6XDZPKz4T77wayJ7jGhhXLwanOHTWBgq5n5q6YUwNJ7l3kKcRl7OJ7fF56l1GzvHbSD8dghTPi0wIRfv6XafjJ3ssv0PnZQ7nZx/etwzO1zJ3lHR2OETTw8x0tOx1AN3De0D7YV+63oGthjaJQ5Ur7eVVZjcdGInUyuaT73ZWg3efV8fZs7cc2E777Qi5eunVbghvPPymrt/krKGfcLd8ybYjdxrK6333Z09rjHZkNuLYzz0uIc+xWCZzz8nbHbe4dsY1e/XUOY+nimvtUaSazv4jXhaQasSbmYmpuenGwHZ8TKggSEQm08rMD7ahBOoExcMqXQegjnZ+CEvaEa1ZQUQkt39dj0zDS7krq+ARmpdws/nlNqD9WFbWN7l5u3wr9MyrcXKUsqWy3jTOaoML4DdaQ83YIoT4VYpEXvYQZLmbX5SLohBrgOj186Kc/iKTUPUhq+Rrm5ekOl3TWv1Mr6hqwbY0VOQXwEo+Moq4Z47q5qsU489G944LyJOW4LOLZOKtT/iI6+nGe/0dhuEd4ltj2NmiuCU4hnk5fHIi7+RK4uTEu0e+s7rAiRcw1CYy3OejvcYz+eXeI9MYY9nu3lYZl0KavJJ7Vjibzgjp319rUZE20j7CkJqFr5JQYgQ39f3eQaKpQk0afy8nl4uBzvjUUTRk7k3iebOm0pabDiyFn2XGu3dRME41CGVeBVqSiVnc6hIUpekp1VjHLDSOEcQlui5W/U8C7IKREjv1Gabw3wRwUTvpv7jybPtzHmIPZ49q6KRjuccqBQVCOtGvqXhrCFUUXJzOYSHt7Kw5Ix9H08dSje1o1JyL73IYXpEMmE5CRbw6wuykx2pR+Pd6/J4JpLiJKV6N9OnrcQNfQ0Zem6qQX2MmFXyWTE+DMO0kGx4e08DEjnXbsYuOq7niHB8jdY/wQ8Srm2XCZZUrOakF1CY5EKX0h93Tu/1J4kRdbDMT8MamgZK9xe3uDcvrPe++Y4f61rcZr7B53rN1c5N2ytcV5rCrvHt3T2Og19g+5nH7dvq3bqunr4NOwgK2MHA1jeEDuG7HNuLmtw7qpocl5t6nCPvdTQ7v4N4u3WTqeyu9cZHIo4f6lqdFoHh7wzMbzDeeGv3Hvzjlrnh2W1zofhHuftxpFn3VFe7zxS0+p0DlKVPbhhvBxhvwiFMgfP+mjHA08gEC4pybeLyK1iZldh8zC5VJQyUl8l59KZ0WJk2xaiYWxNrkXXJhA8r3PvZRur7ZZZRfadaRPsfiTmX9HGajC2tXd6V8dQTMhX0h8rNdJx9Ra8F8SbRNLzhPRnJmTZIUTYueTyWxyr7uv3rjC3OkzE8495oS+4xq6D5WoI0bO5WVCOSerl8rIeBrOI/Hkaw6ME5W1zSuzx2la3CRdWi3zIG+FDBvUp9LMgI/vggUmE7KkT81yGvOOgEYa/aUahhRAF5xLec3OzbF1r2O17BbVxIi7hzJIC64IYhXdJA+nh/5xVbOmE9J0QqjSxWk0pp37M2YEtgjS8GpimACu7xkqxdKJ6fEXyYl2Lre0ZtC8yELVewtWUnbfCPIhrvgDFz8WI5yhJKgcnFMZWEFrwhgzo5uWDDDA1oGSOzcu0xfx7vTlsv6posIMpJ6cGWPiw/BxL4PU7vbrpjgf8bMdu5OYwOdhm83DARUSa0ELknYIeEAaILuWxlhGa0M8+EuJCrpJT+ymENhN60pXBxa3LZ5TsucnlGaCmIEQ4Evru91yuz0xMtKaeXluI5zdh9Mm8vAlBn4aR07X64EH3vEKdXQkZJXPP/JxMvNRpLxEtHZ5RQgmNewnpouvVTpYTHdfOnmy5kFUGnpRTfEhXD9DiBdFFJB0/YWS9aj6pmc89r0BaQmgTRkgI+EsdKsYasJZOBF+QqTH474NK7LbyBvf7W+RgOxNyxfQY2/2hrp2+NkroxrzrQ55fSZkpJIa28znCgF6rb7H1hOSslATyvNflAh9pvHcX3lVE/Ya8FjTJIexa2Rq77nfU96unTnD7aME3+TAm6BFKYrPnqCNIqV5sq0ZGCiEV+Db+qWMQqpFgb5KPx48R6omeDl2EuP9DTYt9iGA/f1KBS1w/La+H4ktsSmLItvZHXLUkrCeflVtJ9DVVg1H7+sxiGvVM975rZpfabuqHVhuP5F1vewav5O8GamUe91yDanoYw47FWzC929O+DJnKA2opFY1Rjru5CE7kOcO0jJtQVUIynzuZEMeb+1CEOFXN8iFSGeRpCm1BTlJxVg49Azm819SO7Bu0axEbwn27GuxMck+TMQHDP8fn48gfDVIL4R8xKVPJ73MQBUIfA/Z54LMw5vmlE+w+VFo2A78X/SsyPA/RMD0z3e2qVLtfo7aeBslpMX0N0TEnLcUlKym1jyBFqSohmYntI5enBhYB9CY/2kNarhwJhNiMtRGyWnkQdKaCFyQwgydjyNUw4VchKxXv2/DoKdC+lkQbCX1NlKCGvJiBJkSGbCus6jfo4yGBNySgr+u7e20BCsxdVAcFlJ/tHd32+cIsNxSXUULUUx+dg/d47g7OPYFw2MxkSuyMwLHVTI6PBN6dS8Sppw45zHJSgDXV3aQzmz40Z6fDgBfiAXU0uZxby2zejee+j3eltoQMzhV6qSBogXwrEXDj7ElWxUQ8RrnSaoU0dxIsKaiMvMykXTu90NqJsGHP4z78SdLigUrLKat32nFwy/E07pfDFRdQ/7N5r57pQ1482uvWhMGhQcviGkVrKDUp0ToCxfhQal5n4Hs/g1jOgH4LWdwFOd1b1WzHET4vLZppv+Czjxo840OrDlG8jAJzv2tp5mLK1dsU/lfIOeWy5NxFxfl2BoYImlQtx9QF6mJRQKBsQYYuO2yaLYPBUXvu/VqYPxtHhNy7Y4hCkNLGPtKSklzCVKSHtMQxcqm5Kw1DhI2PTGZtcGDAvoLQ/u7MifYtWFBlxz2H9zo8RkwKzC5UYiG+p44ccqE62YAxLeT/TOpf8MXx8Qk0IJFRY1Go+viQVJpE5Ehjf49xfAZeqGIy/7us3nqxwQfCkjZypPxobVr/6YpQHIalUvuCyEwbSXC9PC8QnkFcXlrgLpoLIhIfKuaqlQkYIAwQnr/f3eyu7KttOw2lNpv8/BPHyjzVNER3o72gvEBKqRMTflndbP8BMweRDyeciEj5bFayFXqTLzheivgYJC0jwzwHa0MDDEotm48ndze5BBBElAnxxcRYHAFh3FfZaA9UNRmC354kNwUx8eHkmVj5dcTE5ZMnuEyr1QqlhtaJLuOYZv4v3KNo0TKrGPUZ1NILPKuWcvVn5Trv10SMB6h0j/ARMnlOuafCBIfnSWEx/Raif3HDzofYMM31dOyY9LBaLK3TjoX2fEqT4+2qaUVWSTQvyM6wC8nNJyEetXIyuLKrx04P7MKNnbJZlKUtNAIHo7i2dA/YU3Vtdi5l6jCepXy8hOedSSSsI8/HQg5Q+gxTKXwkMHkbESo+hjG0lbRRzQ3Fc5LOzDuFhs3Ptumpie7ilRDhlEJOq/hjsZljCxjkt7fWuPS/EekpXMggJQIk0G+eN9Xu2VmHWIkJe0nJRN4ptBBit2yutG9ML7J1DHAxebiAMrZ4VZlduqGS8I2tJc2iborUxmIN79c+kTovFxivPvrcSaP3n7RSKYTUmKt4N3rMOcw4JOneD3sP956jNaMglIeTER5Xbdlt15Tm2W10NEsYrA/N5JLCHHsR9tSqwxq08G3bqm1ZTbOtagnbo6SLvH/VzBL7W7jPzqFea0LmMLFzUuLtdwumuO3i1Vtq7OK15Xgw3l1PDmIXak+6QBEkvB9YJIzBcc/L20JIYaSZ/qAzVm5Ut4oowk3QehC+N3xo/1wTqt7zsYawfX9no9XjqdPXVLhrwyo/wucJYQkE1e4j8rLcBuHUItQQKqgMXb6LGvxFQlXw33AdZLR0V5P9Fr29lP73scNnosoyvdWPv4fPJ+uJrLVtMakqaL1M1cTvv0OLIZE6wk2a2IcIRUQh+DaejpdcXepBa7bKDRGM9PIVxTl2EwarZ72rooVuY4RQtMypdk6e1lLLehhY2lt7QEd7WxlCDvdIli6E9B4+ZIodmZEMccUGqgiZOqru9tkR3iJ8nCcXRWRZCSPMLPEjlx2LjQL1OM5qKAm+vhSuRqSfV5Ttrg8FdWcrnhMqCTex7DEM6qTsVEuM1+8hovaHQ6e6a1Fz0xLd3nUt4ToWWuzWNkhcoAIIjUx2ZpxjLzWF9+SYmngR1lok4TEoJxGfuijhI/7OICoFmadl2llcL9b1oRVJtbD+JLlv1KrhHG5811t9ELbzgk14ICUwqE+TDzftqHPz98vUSy3jSIwP8dCpkNqLDPTx+rArz4T5qLG3G2PrvJKKPoLBWE501NC3ilUX5mVjVIb9nIbgWcpPMiSXjbcL8K62UkR86m1/yfkSeMaHFuK04X0CE3J6SWzFUxw0BSNHlSzi3RmIRJwHq5udO3c16quLp6sbnffbupxbt+12vzOrzuvNHc7ycRbIxuJHgYU7YSASdQgxp7qz2ynv6HJeqW91doa7nLruXof+17sqhhu31Xif9o7HalqczV29Dnrb/f5EXZvzdH27U98/6LR5i3N0UM5zjHU71/lwjRWWltU5CAIn7F1MqLp/r9hQ5RoaxG+qmrxP4yNKcfsFLwuiprffeb2l03m2scO5h3Or2rudzjGrhk8x4Cqu2xcexilBvNEcdi5Yu4tKF3Ue4tzPy+td5/1md4tzw5iJ27NuXEYobYUdlb8z6GTWkdxaCvk2zHjd5mpKQ459mv5TkAp6mQb9Aq9HHQ8S6mrZnuc6vUG6WHusIhCJGNXl9byvnJyaiE7+Eoz8c5TYNQiUveENGpJpcIJ+biS8R0+rlcazGNs7pKB+zPLTOSX2KNWhlDAf4r2Spj72JORB5OyHULX+dlD/FOky/HFy5ygYU0sey/i8moeqdunXK1qC3RuaMOYHlI/raQMl3M+EeTV5WxD3Km8a8PkM8nr648sQ9+esKbf5e/nxiKBfAOQkxbv3SU9LYmqPV9V/Pn+V20VwTyVjTqCI6edEQUOFUXs9WmfSll8DyX2dt7GlnwkswaM3l9XZ0oNK3MTXbxpOV2sGk69s6XCJw4cY8KbyRrt9TrHt7Bm0rRBQe1+fHUWNfaapU0KbqxzbORC1M/LS3dJwIl3KOrwykQG/E+61q+isgniztdOKqNOziDgZqZIzFwPvqGiyg5NCtoCqoG5NxHhPZTOsnORulKskjoKMDeLuXQ3OmnC3syxARFXdfc57LR3OrdtrvSOOs55rnqhtcdoGhpxHdjc5EfJUuHZTlftX+G15rXPlhkrnLe59F7Lz8VGHdg8c5y2OLeMZ126qduq9XC3v7nd+FchLvYPJd15gPCu8XQnh/qpm59WGVudZzvvQO97kXTcGxhnEuJvR39tWY8cwK4uhcikk4a3Gdstg9l5B2t0wfaTdWkEou5vCPOV5PH73vFL3+DfXltnh6OxjkJD6Wd5F3g88tMe6CW/7YmI99VIL4u0oqUK8ocW4d8hFrXMVoOQU8s3U97MnjvDD/XRYkyhHM1MT3GVZQR2Tdv70U8EbA5vlo+CaPAaaSWoZXm50otGodxQ6L6txGKxzw5ZYORrBsPPrykZKQIy1n8bTjwb2fO4Te3ue7x6KOKvaYns1wtIddd4nx3mwot55qyl2360cp81zurg+CGqwU8v4/Of5uAVvPgObrwvHomY8jOtZ4fXWLnefdHVXv9044+8ZklCx75DXwcV1Sb27y+vInUQEuVYSaMgRJYfAwtoj0raFxIUW1A8nz35f02qLc9Lc9lG7CBkwtUR7bf+A+5uL6ehnH9Lat+5sIEfj3Cbj3NKRvP7Rjlo7FSmqavKvpSP8MRZ7NVbQYLSkqlC9ZW4sPH18gBTcORjrhMWmQWzFmK2UsvO90qQ1oZcI8UhkCLZPtRqMy0NirobAvjIpb4/sW06qKGyPR2oGIdlazjOOTk+kLYzaaYGSp63Wz6HsXsQ51wd+LTAuZOy+8GBNq7tF+IOdDU4kENJthNID5YRafZtzZ3mDs9LbRgzixcZ2l1h83OKFbDmEd0/FiFp7DWHgp0AQGzq6nf8hPF+oa3EehOz0ziCWcm4NpBRMhX1hn571oR9wqVVSDVPtUi32sQ0vbu7scZdY9aOt2ZSEL9BEBIW+dv20AKDd9/ep09oimYqHpyImkKDuRllS4PrlHNuIqDmCJmNJQba7q1joEaUQJuR/WdXsLrJrq/L6cdJsPOyXscJ7GLKqo8cOpqhrO//yQG6oS3kZwS9xPkRB3wi7diFMtDN+PLk5m1ath+8f0Fy80dbjhvVXub+U5mEqeal27UP+dWpPlknNxW79Ak6/7Tg3UMOF52j1xA1qK7Trd6nXC+8P9ttYQcumIonLSnJtBdJNa77axw1C2x3qR4Wqnj73x9f6MbV+CCYFBZO6y51aSh3gzVrsmwzJnULEbCJC1oZ7vIZ/9Iqmfvn2u5oWO5n8fApxcuWUApum5diPgY9lrA9EtvUNOzYf8vqAcJPsU5iOh7XtXQgt2uZhjKU2amF7HQyfEYWcZk5yQ1RDKNrLcq02k/9IGmldrB93KiokPw8EB2SsoKWXO5FmxXhlckqi+3vEUvLqwok5PHVkIWAszlqzy1p54zuLpnPZ3q9bod08JlLSb5DrNxDm38Sbvsg5EBywsT7oH+3XNW3uasGirFSrxRNdCllKiPZHZzJYLZb5qEcpae3pxMCuu9oibS5/QCOiLcYUrp+MmtJeURjFdVlxzqiae6D4h40NQt54HyGv3JRo10aVfv8YhtC0pSlVKcPFuxIXahr08mzCO4VzMlLSsZuomZ+RaucU0rXsw/sfF5+osUFonWob/7TrLdaUgdpV93fl9X+VIC0Y6tek2uI8OD3J5gT2Vj9ZmP0f4IM4iY7RQ5gAAAAASUVORK5CYII=) no-repeat 50%;background-size:64px 64px;opacity:.84}.markdown-body h1:after{position:absolute;content:"";width:150%;left:-25%;height:50%;bottom:12px;border-radius:50%;background:linear-gradient(transparent 80%,rgba(77,208,225,.8));background-size:400% 200%;opacity:.6;animation:h1Animate 6s linear infinite}@keyframes h1Animate{0%{background-position:100% 100%}50%{background-position:100% 50%}to{background-position:100% 100%}}.markdown-body h2{display:block;border-bottom:4px solid #4dd0e1;position:relative;font-size:24px;padding:12px 32px;margin:30px 0}.markdown-body h2:before{width:24px;height:24px;left:0;top:0;margin:auto;background-size:24px 24px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADGklEQVRYR81X32vTYBQ999s6mFjQgQ+DrbHiVFZYU4cDcQ/6pGhTFVYFEXGi82H+Bz448UnEF1Fx9ccEEcXpZE3d5tP2ooKiTacTHaLNpigMHDgnU9tcSbrWrkwWR0sbyEOSe885ObnfvV8IRT6oyPwoLQHBx+OVM5WJvSyEVAhnBOjt7yU/+/rr6r6l8TMO+F/EN0JQhICqQpD/xaRpcpAc9tS+M+9lBCia/oqBamK+zeDuQogQZaKJk3wcQjxSva7tGQGB2Ke1zIk3DNyMyNL+QpCnMQOaPsDAVuGAp9cjvbYc8Ec/bCYSg0zoiHilk1tHxqsqEsYlML4kjIpT/eurJxRNPweQU5VdrWaOEo1fgKAVbBgXIz73kF3R/ph+ghgdzMYWM29eAWlBJqgZaFlFYtC6nhWpaDqnSGlIlV1WjJ3DloDNgyNLncudqgX//Ucg3LxuStHGuhi8pqKCW3rqV342rwFjRznKm+/LNaN2yC237ThgF2wxcfMLeP6+ncrKzoPoKTGeLQbYbg4TNoC5iZPJY5HGVRdSNZAWYBclD3FzBQzrR8hACAKdzBzKA/4/IYioDQaOskBbpEG6PO8qKKSAEi3CnEb0Pw4oMf0OmKbTDWqh3Lw6EIiNBZi5lxh3wz4puBD5ovqAMvxhHSdFKxE1CQe3m/07TeTX4lcJdAhE+1Sv65Z5P/ByvIGTRowIZ9igbtXnmrOsbTvgj+kHBNMuBu9OdVw8EeU4nC1A0cYmAHZOTRrLhra4Z8ywnSN6vZHAFTA2WnnMfQB3qz73ddsOZM8CACFDIPSgQXqebXEgqgeZcAeEe6pXasm1f8ew3igMtAHWac0Uc/jYdyAaP0xEBwFsmgUPqbJ0NE2UKj4EGcahiOzuyhagaHpnmtgcVgTcCMuua7YdyAHbA3ArQNscVFbb4635aD6fnYaTvxxi9UNP7ddMXaRWVBdAcaLk6bDXPZCNZ9uBXEsDUX1T2Cc9yjig6Z0EHg3LK8/aqf6MwJKchkXfks1+0+JtSq3qLPa23BRR1B+T/6nkfMaW1r9hPt/MLtYfTLEpP+T9FNoAAAAASUVORK5CYII=)}.markdown-body h2:after,.markdown-body h2:before{content:"";display:block;position:absolute;bottom:0}.markdown-body h2:after{right:0;width:400px;height:10px;border-top-right-radius:24px;background:linear-gradient(90deg,#fff,#4dd0e1);max-width:50vw}.markdown-body h3{margin:30px 0;font-size:18px;position:relative;padding:4px 32px;width:max-content}.markdown-body h3:before{border-bottom:2px solid #4dd0e1;width:100%;content:"";display:block;height:28px;position:absolute;left:0;top:0;bottom:-2px;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);background-repeat:no-repeat;animation:h3AnimationBefore 2s infinite alternate}@keyframes h3AnimationBefore{0%{width:28px}25%{width:100%}50%{width:100%}to{width:100%}}.markdown-body h3:after{content:"";display:block;width:28px;height:28px;position:absolute;border:2px solid #4dd0e1;border-radius:50%;right:-15px;top:0;bottom:0;margin:auto;background-size:28px 28px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABRklEQVRYR2NkGGDAOMD2M4w6YDQERkNg+ITAppcfY/8zMv3wF+NdTUrZQpUQ2PT6cz8Dw/8CkMWMDIwNvqK8jcQ6gmIHNN19EaXPx1XPyMCghrCUKcpPlGc5MY6gyAE+Fx52MjL8j3cU5a1UYWXtZGBkEAVb+p8hxU+Mby5NHQCxnKEMaskzJ37uFmUetkmMjAzrfUX4woixHBJlZAA0y2EmPPYU4enLkhGeQIqRJDsAh+UgO7duNpD3IcVykkOA2paT5ABaWE60A2hlOdEO8D3/4CMDIyMfWvySFefoaYSoROh74eFXBgYGLiTNVLGc+BC48PAnAwMDG9QBVLOcaAd8P5ox+x/jf5AjGLgYfnwnKqv9/8/PwPO/kFF/MSj0cAKiouD/0bgYoixFU8RovWgJIX1EOYCQIZTIjzpgNARGQ2DAQwAAvHBaIdB7zxsAAAAASUVORK5CYII=);animation:h3AnimationAfter 2s infinite alternate}@keyframes h3AnimationAfter{0%{transform:rotate(0)}10%{transform:rotate(0)}50%{transform:rotate(-1turn)}to{transform:rotate(-1turn)}}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin:22px 0;letter-spacing:2px;font-size:14px;word-spacing:2px}.markdown-body img{max-width:80%;border-radius:6px;display:block;margin:20px auto!important;object-fit:contain;box-shadow:0 0 16px hsla(0,0%,43.1%,.45)}.markdown-body figcaption{display:block;font-size:13px;color:#2b2b2b}.markdown-body figcaption:before{content:"";background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAGFBMVEVHcExAuPtAuPpAuPtAuPpAuPtAvPxAuPokzOX5AAAAB3RSTlMAkDLqNegkoiUM7wAAAGBJREFUKM9jYBhcgMkBTUDVBE1BeDGqEtXychNUBeXlKEqACsrLQxB8lnCQQClCiWt5OYoSiAIkJVAF5eVBqAqAShTAAs7l5ShKWMwRAmAlSArASpAVgJUkCqIAscESHwCVVjMBK9JnbQAAAABJRU5ErkJggg==);display:inline-block;width:18px;height:18px;background-size:18px;background-repeat:no-repeat;background-position:50%;margin-right:5px;margin-bottom:-5px}.markdown-body hr{border:none;border-top:1px solid #4dd0e1;margin-top:32px;margin-bottom:32px}.markdown-body del{color:#4dd0e1}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(77,208,225,.08);color:#26c6da;padding:.195em .4em}.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#4dd0e1;border-bottom:1px solid #4dd0e1;font-weight:400;text-decoration:none;margin:0 4px}.markdown-body a:active,.markdown-body a:hover{background-color:rgba(77,208,225,.1)}.markdown-body strong{color:#26c6da}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{font-style:normal;color:#4dd0e1;font-weight:700}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(77,208,225,.05)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{margin:2em 0;padding:24px 32px;border-left:4px solid #26c6da;background:rgba(77,208,225,.15);position:relative}.markdown-body blockquote:before{content:"❝";top:8px;left:8px;color:#4dd0e1;font-size:30px;line-height:1;font-weight:700;position:absolute;opacity:.7}.markdown-body blockquote:after{content:"❞";font-size:30px;position:absolute;right:8px;bottom:0;color:#4dd0e1;opacity:.7}.markdown-body blockquote p{color:#595959;line-height:2}.markdown-body ol,.markdown-body ul{color:#595959;padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>刚开始接触 Elasticsearch 时，我觉得它就像个黑盒子——数据往里一扔，查询语句一写，结果就出来了。直到负责公司核心业务的搜索模块后，我才发现这个黑盒子里面藏着无数需要注意的细节。</p>
</blockquote>
<hr/>
<p>今天就把我在实际项目中积累的 ES 使用经验分享给大家，主要从<strong>索引设计</strong>、<strong>字段类型</strong>、<strong>查询优化</strong>、<strong>集群管理</strong>和<strong>架构设计</strong>这几个方面来展开。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed326ed06d3f41ec9c1ee1010da01c42~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg57qi5bCY5peF5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763300702&amp;x-signature=kA3%2FCjHgK3B0Ze8upiBaoF5nBzE%3D" alt="20251102-4.jpg" loading="lazy"/></p>
<h2 data-id="heading-0">索引设计：从基础到进阶</h2>
<h3 data-id="heading-1">1. 索引别名（alias）：为变更留条后路</h3>
<p>刚开始做项目时，我习惯直接用索引名。直到有一次需要修改字段类型，才发现 <strong>ES 不支持直接修改映射，也不支持修改主分片数</strong>，必须重建索引。（**新增字段是可以的）</p>
<p><strong>解决方案很简单</strong>：使用<strong>索引别名</strong>。业务代码中永远使用别名，重建索引时只需要切换别名的指向，整个过程用户无感知。</p>
<p>这就好比给索引起了个"外号"，里面怎么换内容都不影响外面的人称呼它。</p>
<h3 data-id="heading-2">2. Routing 路由：让查询更精准</h3>
<p>在做 <strong>SaaS 电商系统</strong>时，我发现查询某个商家的订单数据特别慢。原来，<strong>默认情况下ES根据文档ID的哈希值分配分片</strong>，导致同一个商家的数据分散在不同分片上。</p>
<p><strong>优化方案</strong>：使用商家 ID 作为 <strong>routing key</strong>，存储和查询数据时指定routing key。这样，同一个商家的所有数据都会存储在同一个分片上。</p>
<p><strong>效果对比</strong>：</p>
<ul>
<li>优化前：查询要扫描所有分片（比如3个分片都要查）</li>
<li>优化后：只需要查1个分片</li>
<li><strong>结果</strong>：查询速度直接翻倍，资源消耗还更少</li>
</ul>
<h3 data-id="heading-3">3. 分片拆分：应对数据增长</h3>
<p>当单个索引数据量持续增长时，单纯增加分片数并不是最佳方案。</p>
<p><strong>我的经验是</strong>：</p>
<ul>
<li><strong>业务索引</strong>：单个分片控制在 10-30GB</li>
<li><strong>搜索索引</strong>：10GB 以内更合适</li>
<li><strong>日志索引</strong>：可以放宽到 20-50GB</li>
</ul>
<p>对于 SaaS 系统，ES单索引数据较大，且存在“超级大商户”，导致数据倾斜严重时，可以按<strong>商家ID%64取模</strong>进行索引拆分，比如 <code>orders_001</code> 到 <code>orders_064</code>，每个索引包含部分商家的数据，然后再根据商户ID指定routing key。</p>
<blockquote>
<p>请根据<strong>业务数据量</strong>和<strong>业务要求</strong>，选择最适合的<strong>分片拆分规则</strong> 和<strong>routing key路由算法</strong>，同时不要因为拆分不合理，导致ES节点中存在大量分片。</p>
<p>ES默认<strong>单节点分片最大值为1000</strong>(7.0版本后)，可以参考ES官方建议，<strong>堆内存分片数量</strong>维持大约<strong>1:20</strong>的比例</p>
</blockquote>
<hr/>
<h2 data-id="heading-4">字段类型：选择比努力重要</h2>
<h3 data-id="heading-5">4. Text vs Keyword：理解它们的本质区别</h3>
<p>曾经有个坑：用户手机号用 <strong>text 类型</strong>存储，结果搜索完整的手机号却搜不到。原来 text 类型会被分词，<code>13800138000</code> 可能被拆成 <code>138</code>、<code>0013</code>、<code>8000</code> 等片段。</p>
<p><strong>正确做法</strong>：</p>
<ul>
<li>需要分词搜索的用 <strong>text</strong>（如商品描述）</li>
<li>需要精确匹配的用 <strong>keyword</strong>（如订单号、手机号），适合 <strong>term、terms</strong> 等精确查询</li>
<li><strong>效果</strong>：keyword 类型的 term 查询速度更快，存储空间更小</li>
</ul>
<h3 data-id="heading-6">5. 多字段映射（multi-fields）：按需使用不浪费</h3>
<p>ES 默认会为 text 字段创建 keyword 子字段，但这并不总是必要的。</p>
<p><strong>我的选择</strong>：</p>
<ul>
<li>确定字段需要<strong>精确匹配和聚合</strong>时：启用 <strong>multi-fields</strong></li>
<li>只用于全文搜索时：禁用 multi-fields</li>
<li><strong>好处</strong>：节省存储空间，提升写入速度</li>
</ul>
<h3 data-id="heading-7">6. 排序字段：选对类型提升性能</h3>
<p>用 keyword 字段做数值排序是个常见误区。比如价格排序，<code>100</code> 会排在 <code>99</code> 前面，因为它是按字符串顺序比较的。</p>
<p><strong>推荐做法</strong>：</p>
<ul>
<li>数值排序：用 <strong>long、integer</strong> 类型</li>
<li>时间排序：用 <strong>date</strong> 类型</li>
<li><strong>提升效果</strong>：排序速度提升明显，内存占用也更少</li>
</ul>
<hr/>
<h2 data-id="heading-8">查询优化：平衡速度与精度</h2>
<h3 data-id="heading-9">7. 模糊查询：了解正确的打开方式</h3>
<p>在 <strong>ES 7.9 之前</strong>，<strong>wildcard 查询</strong>是个性能陷阱。它基于正则表达式引擎，前导通配符会导致全量词项扫描。</p>
<p><strong>现在的方案</strong>：</p>
<ul>
<li><strong>ES7.9+</strong>：使用 <strong>wildcard 字段类型</strong></li>
<li><strong>优势</strong>：底层使用优化的 <strong>n-gram</strong> + <strong>二进制 doc value</strong> 机制，性能提升显著</li>
</ul>
<blockquote>
<p>提示：ES7.9前后版本wildcard的具体介绍，可以参考我的上一篇文章</p>
<p><a href="https://juejin.cn/post/7567581946144522291" target="_blank" title="https://juejin.cn/post/7567581946144522291">《与产品经理的“模糊”对决：Elasticsearch实现MySQL LIKE '%xxx%'》</a></p>
</blockquote>
<h3 data-id="heading-10">8. 分页查询：避免深度分页的坑</h3>
<p>产品经理曾要求实现"无限滚动"，我展示了深度分页的性能数据后，大家达成共识：<strong>业务层面避免深度分页才是根本解决方案</strong>。就像淘宝、Google 这样的大厂，也都对分页做了限制，这不仅是技术考量，更是用户体验的最优选择。</p>
<p><strong>技术方案</strong>（仅在确实无法避免时考虑）：</p>
<ul>
<li><strong>浅分页</strong>：使用 <code>from/size</code>，适合前几页的常规分页</li>
<li><strong>Scroll</strong>：适合大数据量导出，但需要维护 scroll_id 和历史快照，对服务器资源消耗较大</li>
<li><strong>search_after</strong>：基于上一页最后一条记录进行分页，但无法跳转任意页面，且频繁查询会增加服务器压力</li>
</ul>
<p>需要强调的是，这些技术方案都存在各自的局限性，<strong>业务设计上的规避始终是最佳选择</strong>。</p>
<hr/>
<h2 data-id="heading-11">集群管理：保障稳定运行</h2>
<h3 data-id="heading-12">9. 索引生命周期：自动化运维</h3>
<p>日志数据的特点是源源不断，如果不加管理，磁盘很快就会被撑满。</p>
<p><strong>我的做法</strong>：</p>
<ul>
<li>按天创建索引（如 log_20231201）</li>
<li>设置保留策略（保留7天或30天）</li>
<li>结合模板自动化管理</li>
</ul>
<h3 data-id="heading-13">10. 准实时性：理解刷新机制</h3>
<p>很多新手会困惑：为什么数据写入后不能立即搜索？</p>
<p><strong>原理</strong>：<strong>ES 默认 1 秒刷新一次索引</strong>，这是为了在实时性和写入性能之间取得平衡。</p>
<p><strong>调整建议</strong>：</p>
<ul>
<li>实时性要求高：保持 1s</li>
<li>写入量大：适当调大 refresh_interval</li>
</ul>
<blockquote>
<p><strong>补充说明</strong>：如果需要更新后立即能查询到，通常有两种方案：</p>
<ol>
<li>让前端直接展示刚提交的数据，等下一次调用接口时再查询 ES</li>
<li>更新完后，前端延迟 1.5 秒后再查询</li>
</ol>
<p><strong>关键点</strong>：业务需求不一定都要后端实现，可以结合前端一起考虑解决方案。</p>
</blockquote>
<h3 data-id="heading-14">11. 内存配置：32G 限制的真相</h3>
<p>为什么 ES 官方建议不要超过 32G 内存？</p>
<p><strong>技术原因</strong>：Java 的<strong>压缩指针技术</strong>在 32G 以内有效，超过这个限制会浪费大量内存。</p>
<p><strong>实践建议</strong>：单个节点配置约50%内存，留出部分给操作系统。</p>
<hr/>
<h2 data-id="heading-15">架构设计：合理的分工协作</h2>
<h3 data-id="heading-16">12. ES 与数据库：各司其职</h3>
<p>曾经试图在 ES 里存储完整的业务数据，结果遇到<strong>数据一致性</strong>问题。</p>
<p><strong>现在的方案</strong>：</p>
<ul>
<li><strong>ES</strong>：存储搜索条件和文档 ID</li>
<li><strong>数据库</strong>：存储完整业务数据</li>
<li><strong>查询</strong>：ES 找 ID，数据库取详情</li>
</ul>
<p><strong>好处</strong>：既享受 ES 的搜索能力，又保证数据的强一致性。</p>
<h3 data-id="heading-17">13. 嵌套对象：保持数据关联性</h3>
<p>处理商品规格这类数组数据时，用普通的 <strong>object 类型</strong>会导致数据扁平化，破坏对象间的关联。</p>
<p><strong>解决方案</strong>：使用 <strong>nested 类型</strong>，保持数组内对象的独立性，确保查询结果的准确性。</p>
<h3 data-id="heading-18">14. 副本配置：读写平衡的艺术</h3>
<p>副本可以提升查询能力，但也不是越多越好。</p>
<p><strong>经验值</strong>：</p>
<ul>
<li>大多数场景：<strong>1 个副本</strong>足够</li>
<li>高查询压力：可适当增加</li>
<li><strong>注意</strong>：副本越多，写入压力越大</li>
</ul>
<hr/>
<h2 data-id="heading-19">写在最后</h2>
<p>这些经验都是在解决实际问题中慢慢积累的。就像修路一样，开始可能只是简单铺平，随着车流量的增加，需要不断优化——设置红绿灯、划分车道、建立立交桥。使用 ES 也是同样的道理，随着业务的发展，需要不断调整和优化。</p>
<p>最大的体会是：<strong>理解原理比记住命令更重要</strong>。只有明白了为什么这样设计，才能在遇到新问题时找到合适的解决方案。</p>
<blockquote>
<p>如果有人问我："ES 怎么才能用得更好？"我的回答是："先理解业务场景，再选择技术方案。就像我们之前做的模糊搜索，不是简单地用 wildcard，而是根据 ES 版本选择最优解。"</p>
</blockquote>
<p><strong>技术的价值不在于多复杂，而在于能否优雅地解决实际问题。与大家共勉。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter 拖拉对比组件，换装图片前后对比必备]]></title>    <link>https://juejin.cn/post/7570197010885034030</link>    <guid>https://juejin.cn/post/7570197010885034030</guid>    <pubDate>2025-11-09T12:28:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570197010885034030" data-draft-id="7568699551101075508" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter 拖拉对比组件，换装图片前后对比必备"/> <meta itemprop="keywords" content="Flutter,前端,开源"/> <meta itemprop="datePublished" content="2025-11-09T12:28:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LinXunFeng"/> <meta itemprop="url" content="https://juejin.cn/user/1820446984512392"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter 拖拉对比组件，换装图片前后对比必备
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1820446984512392/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LinXunFeng
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-09T12:28:38.000Z" title="Sun Nov 09 2025 12:28:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>欢迎关注微信公众号：<a href="https://link.juejin.cn?target=https%3A%2F%2Fp3-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2F31960a996f1f4b0da35d69ab7480f7d6~tplv-k3u1fbpfcp-zoom-1.image" target="_blank" title="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31960a996f1f4b0da35d69ab7480f7d6~tplv-k3u1fbpfcp-zoom-1.image" ref="nofollow noopener noreferrer">FSA全栈行动</a> 👋</p>
</blockquote>
<h2 data-id="heading-0">一、前言</h2>
<p>最近一个需求，需要在 <code>photo_view</code> 中实现拖拉对比两张图片的功能，要求不影响左右翻页及缩放手势。</p>
<p>其中前后图片上需要显示一些额外的信息，所以更准确来说，要对比的是两个视图，而不单单只是图片。</p>
<p>市面上几个现有的组件库，要么只能传入 <code>Image</code>，要么只允许全屏拖拽，且无法满足我们高自定义的需要，所以我自己做了一个。</p>
<p>相应的 <code>Demo</code> 可科学上网后在线体验:
<a href="https://link.juejin.cn?target=https%3A%2F%2Flinxunfeng.github.io%2Fflutter_compare_slider%2F" target="_blank" title="https://linxunfeng.github.io/flutter_compare_slider/" ref="nofollow noopener noreferrer">linxunfeng.github.io/flutter_com…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e582ebd2385247bdbfb966509bcdc5c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGluWHVuRmVuZw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763296117&amp;x-signature=b6xhOjYJqMvCSsqTxQRu%2BLK7nRo%3D" alt="" loading="lazy"/></p>
<p>OK，接下来我们就来看看具体使用</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLinXunFeng%2Fflutter_compare_slider" target="_blank" title="https://github.com/LinXunFeng/flutter_compare_slider" ref="nofollow noopener noreferrer">github.com/LinXunFeng/…</a></p>
<h2 data-id="heading-1">二、使用</h2>
<p>添加依赖</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-attr">compare_slider:</span> <span class="hljs-string">latest_version</span>
</code></pre>
<p>导入</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:compare_slider/compare_slider.dart'</span>;
</code></pre>
<p>使用</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-built_in">double</span> value = <span class="hljs-number">0.5</span>;
<span class="hljs-built_in">double</span> thickness = <span class="hljs-number">1</span>;
<span class="hljs-built_in">bool</span> dragOnlyOnSlider = <span class="hljs-keyword">true</span>;

CompareSlider(
  <span class="hljs-comment">// 当前值 [0, 1]</span>
  value: value,
  <span class="hljs-comment">// 是否只允许在滑块区域拖拽</span>
  dragOnlyOnSlider: dragOnlyOnSlider,
  <span class="hljs-comment">// 原图视图（接收类型为 Widget，不局限于图片）</span>
  before: _buildImageView(isBefore: <span class="hljs-keyword">true</span>),
  <span class="hljs-comment">// 换装后的视图</span>
  after: _buildImageView(isBefore: <span class="hljs-keyword">false</span>),
  <span class="hljs-comment">// 分割线厚度</span>
  thickness: thickness,
  <span class="hljs-comment">// 拖拽的滑块和分割线</span>
  thumb: _buildThumb(),
  <span class="hljs-comment">// 滑块值改变时触发的回调</span>
  onValueChanged: (<span class="hljs-built_in">double</span> value) {
    <span class="hljs-keyword">this</span>.value = value;
    setState(() {});
  },
);
</code></pre>
<p>分割线与滑块</p>
<pre><code class="hljs language-dart" lang="dart">Widget _buildThumb() {
  <span class="hljs-keyword">return</span> Stack(
    clipBehavior: Clip.none,
    alignment: Alignment.center,
    children: [
      <span class="hljs-comment">// 分割线</span>
      _buildSliderLine(),
      <span class="hljs-comment">// 滑块</span>
      Positioned(
        left: -(thumbSize - thickness) / <span class="hljs-number">2</span>,
        child: _buildSliderThumb(),
      ),
    ],
  );
}

Widget _buildSliderLine() {
  <span class="hljs-keyword">return</span> Container(
    width: thickness,
    color: Colors.white.withValues(alpha: <span class="hljs-number">0.5</span>),
  );
}
</code></pre>
<p><code>thickness</code> 是分割线的宽度，传入用于提前计算其偏移量。</p>
<p><code>dragOnlyOnSlider</code> 默认为 <code>false</code>，即全区域拖动，如果设置为 <code>true</code>，则默认情况下，交互区域为 <code>_buildSliderLine()</code> 视图。</p>
<p>有时分割线的宽度较小，而你想扩大交互范围时，则可以通过 <code>extraHitTestArea</code> 来实现，结合 <code>debugHitTestAreaColor</code> 可清晰知道交互范围，如文章顶部动图中半透明红色。</p>
<p>为了不影响 <code>photo_view</code> 的缩放手势，可以在开始触摸滑块时（<code>onSliderThumbTouchBegin</code> 回调）禁用手势，在结束触摸滑块时（<code>onSliderThumbTouchEnd</code> 回调）恢复手势即可。</p>
<h2 data-id="heading-2">三、最后</h2>
<p>好了，开源不易，如果你也觉得这个库好用，请不吝给个 <code>Star</code>  👍 ，并多多支持！</p>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLinXunFeng%2Fflutter_compare_slider" target="_blank" title="https://github.com/LinXunFeng/flutter_compare_slider" ref="nofollow noopener noreferrer">github.com/LinXunFeng/…</a></strong></p>
<p>本篇到此结束，感谢大家的支持，我们下次再见！ 👋</p>
<blockquote>
<p>如果文章对您有所帮助, 请不吝点击关注一下我的微信公众号：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fp3-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2F31960a996f1f4b0da35d69ab7480f7d6~tplv-k3u1fbpfcp-zoom-1.image" title="https://link.juejin.cn/?target=https%3A%2F%2Fp3-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2F31960a996f1f4b0da35d69ab7480f7d6~tplv-k3u1fbpfcp-zoom-1.image" target="_blank">FSA全栈行动</a>, 这将是对我最大的激励. 公众号不仅有 <code>iOS</code> 技术，还有 <code>Android</code>，<code>Flutter</code>，<code>Python</code> 等文章, 可能有你想要了解的技能知识点哦~</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript + Web Audio API 打造炫酷音乐可视化效果，让你的网页跟随音乐跳起来]]></title>    <link>https://juejin.cn/post/7569904733718380563</link>    <guid>https://juejin.cn/post/7569904733718380563</guid>    <pubDate>2025-11-09T07:40:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7569904733718380563" data-draft-id="7564589390656208930" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript + Web Audio API 打造炫酷音乐可视化效果，让你的网页跟随音乐跳起来"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-09T07:40:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="刘大华"/> <meta itemprop="url" content="https://juejin.cn/user/3507878440995946"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript + Web Audio API 打造炫酷音乐可视化效果，让你的网页跟随音乐跳起来
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3507878440995946/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    刘大华
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-09T07:40:02.000Z" title="Sun Nov 09 2025 07:40:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>大家好！我是大华！今天分享一下怎么用<code>Web Audio API</code>和<code>JavaScript</code>实现一个音乐旋律波长可视化效果。</p>
<h3 data-id="heading-1">效果预览</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bdac7a16d0640c8b70da8229b5ae462~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YiY5aSn5Y2O:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763278802&amp;x-signature=H8H5cyOds0MvrrN2Yr45e3oCoL4%3D" alt="20251017_115321.gif" loading="lazy"/></p>
<p>实现的效果：一个动态响应音乐频率的可视化界面，音频条会随着音乐的节奏和旋律起伏变化，形成波形图效果。</p>
<p><strong>完整源码在文末~</strong></p>
<h3 data-id="heading-2">技术核心：Web Audio API</h3>
<p>要实现音乐可视化，我们需要用到浏览器的<strong>Web Audio API</strong>。这个强大的API允许我们在浏览器中处理和分析音频数据。</p>
<h2 data-id="heading-3">代码实现详解</h2>
<p>在开始编码前，我们先理解Web Audio API的工作流程：</p>
<pre><code class="hljs">音频输入 → AudioContext → AnalyserNode → 频率数据 → 可视化渲染
</code></pre>
<h3 data-id="heading-4">关键组件：</h3>
<p><strong>1.AudioContext</strong>：音频处理的上下文环境
<strong>2.AnalyserNode</strong>：分析音频数据的节点
<strong>3.Frequency Data</strong>：频率数据数组
<strong>4.requestAnimationFrame</strong>：实现平滑动画</p>
<h3 data-id="heading-5">1. 创建基础HTML结构</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>音乐可视化<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-comment">/* CSS样式 */</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>音乐旋律波长可视化<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        
        <span class="hljs-comment">&lt;!-- 可视化区域 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"visualizer-container"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bars-container"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"barsContainer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        <span class="hljs-comment">&lt;!-- 控制区域 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"controls"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"startBtn"</span>&gt;</span>开始可视化<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"audioFile"</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">"audio/*"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"audioFile"</span>&gt;</span>选择音频文件<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"stopBtn"</span>&gt;</span>停止<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        <span class="hljs-comment">&lt;!-- 音频信息显示 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"audio-info"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"trackInfo"</span>&gt;</span>未选择音频文件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"frequency-info"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>低频: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"lowFreq"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> Hz<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>中频: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"midFreq"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> Hz<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>高频: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"highFreq"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> Hz<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// JavaScript代码</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>设计思路：</strong></p>
<ul>
<li>模块化布局：标题、可视化区、控制区、信息区</li>
<li>语义化ID命名：便于JavaScript操作</li>
</ul>
<h3 data-id="heading-6">2. 动态创建音频条</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 获取DOM元素</span>
<span class="hljs-keyword">const</span> barsContainer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'barsContainer'</span>);

<span class="hljs-comment">// 创建64个音频条</span>
<span class="hljs-keyword">const</span> barCount = <span class="hljs-number">64</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; barCount; i++) {
    <span class="hljs-keyword">const</span> bar = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
    bar.<span class="hljs-property">className</span> = <span class="hljs-string">'bar'</span>;
    bar.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">'5px'</span>;  <span class="hljs-comment">// 初始高度</span>
    barsContainer.<span class="hljs-title function_">appendChild</span>(bar);
}
<span class="hljs-keyword">const</span> bars = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.bar'</span>);
</code></pre>
<p><strong>技术要点：</strong></p>
<ul>
<li>为什么选择64个音频条？这是性能与效果的平衡点</li>
<li>初始高度5px确保音频条始终可见</li>
<li>使用CSS Flex布局自动排列</li>
</ul>
<h3 data-id="heading-7">3. 音频条样式设计</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.bar</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span>;
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to top, <span class="hljs-number">#ff6b6b</span>, <span class="hljs-number">#ffde7d</span>, <span class="hljs-number">#6a98f0</span>);
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">6px</span> <span class="hljs-number">6px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
    <span class="hljs-attribute">transition</span>: height <span class="hljs-number">0.1s</span> ease-out;
    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">106</span>, <span class="hljs-number">152</span>, <span class="hljs-number">240</span>, <span class="hljs-number">0.5</span>);
}

<span class="hljs-selector-class">.bars-container</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">justify-content</span>: center;
    <span class="hljs-attribute">align-items</span>: flex-end;  <span class="hljs-comment">/* 关键：从底部向上生长 */</span>
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">4px</span>;
}
</code></pre>
<p><strong>设计原理：</strong></p>
<ul>
<li><code>align-items: flex-end</code>：让柱子从底部开始生长</li>
<li><code>transition: height 0.1s</code>：平滑的高度变化动画</li>
<li>渐变背景：从红色到黄色到蓝色的视觉层次</li>
</ul>
<h3 data-id="heading-8">4. 创建音频上下文和分析器</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> audioContext;
<span class="hljs-keyword">let</span> analyser;
<span class="hljs-keyword">let</span> source;
<span class="hljs-keyword">let</span> dataArray;
<span class="hljs-keyword">let</span> bufferLength;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">initAudioContext</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!audioContext) {
        <span class="hljs-comment">// 创建音频上下文（兼容不同浏览器）</span>
        audioContext = <span class="hljs-keyword">new</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">AudioContext</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitAudioContext</span>)();
        
        <span class="hljs-comment">// 创建分析器节点</span>
        analyser = audioContext.<span class="hljs-title function_">createAnalyser</span>();
        
        <span class="hljs-comment">// 设置FFT大小，影响频率分析的精细度</span>
        analyser.<span class="hljs-property">fftSize</span> = <span class="hljs-number">256</span>;
        
        <span class="hljs-comment">// 获取频率数据数组长度</span>
        bufferLength = analyser.<span class="hljs-property">frequencyBinCount</span>;  <span class="hljs-comment">// 128</span>
        
        <span class="hljs-comment">// 创建用于存储频率数据的数组</span>
        dataArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(bufferLength);
    }
}
</code></pre>
<p><strong>核心概念解析：</strong></p>
<p><strong>FFT（快速傅里叶变换）</strong></p>
<ul>
<li>作用：将时域信号转换为频域信号</li>
<li>fftSize=256：将音频分成256个采样点进行分析</li>
<li>frequencyBinCount=128：得到128个频率区间数据</li>
</ul>
<p><strong>Uint8Array</strong></p>
<ul>
<li>8位无符号整数数组</li>
<li>取值范围：0-255</li>
<li>每个值代表对应频率区间的振幅</li>
</ul>
<h3 data-id="heading-9">5. 动画循环函数</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!isPlaying) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-comment">// 获取实时频率数据</span>
    analyser.<span class="hljs-title function_">getByteFrequencyData</span>(dataArray);
    
    <span class="hljs-comment">// 更新所有音频条</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bars.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">const</span> value = dataArray[i];
        <span class="hljs-keyword">const</span> percent = value / <span class="hljs-number">256</span>;  <span class="hljs-comment">// 转换为百分比</span>
        <span class="hljs-keyword">const</span> height = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(percent * <span class="hljs-number">200</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 计算高度</span>
        
        bars[i].<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">`<span class="hljs-subst">${height}</span>px`</span>;
        
        <span class="hljs-comment">// 动态颜色：根据频率位置变化</span>
        <span class="hljs-keyword">const</span> hue = i * <span class="hljs-number">360</span> / bars.<span class="hljs-property">length</span>;
        bars[i].<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">`linear-gradient(to top, 
            hsl(<span class="hljs-subst">${hue}</span>, 100%, 50%), 
            hsl(<span class="hljs-subst">${hue + <span class="hljs-number">30</span>}</span>, 100%, 70%), 
            hsl(<span class="hljs-subst">${hue + <span class="hljs-number">60</span>}</span>, 100%, 50%))`</span>;
    }
    
    <span class="hljs-comment">// 更新频率信息显示</span>
    <span class="hljs-title function_">updateFrequencyInfo</span>();
    
    <span class="hljs-comment">// 循环调用</span>
    <span class="hljs-title function_">requestAnimationFrame</span>(animate);
}
</code></pre>
<p><strong>技术深度解析：</strong></p>
<p><strong>getByteFrequencyData()</strong></p>
<ul>
<li>功能：将当前音频的频率数据填充到指定数组</li>
<li>数据分布：低频在数组开头，高频在数组末尾</li>
<li>实时性：每帧获取的都是最新数据</li>
</ul>
<p><strong>HSL色彩模型</strong></p>
<ul>
<li>H（色相）：0-360度，实现彩虹效果</li>
<li>S（饱和度）：100%，鲜艳的颜色</li>
<li>L（亮度）：50%，适中的亮度</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li><code>Math.max(percent * 200, 5)</code>：确保最小高度，避免闪烁</li>
<li><code>requestAnimationFrame</code>：浏览器优化的60fps动画</li>
</ul>
<h3 data-id="heading-10">6. 频率信息显示</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFrequencyInfo</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 低频：索引2，约0-250Hz（鼓声、贝斯）</span>
    <span class="hljs-keyword">const</span> lowFreqValue = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(dataArray[<span class="hljs-number">2</span>] * <span class="hljs-number">2</span>);
    
    <span class="hljs-comment">// 中频：索引8，约250-2000Hz（人声、主旋律）</span>
    <span class="hljs-keyword">const</span> midFreqValue = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(dataArray[<span class="hljs-number">8</span>] * <span class="hljs-number">4</span>);
    
    <span class="hljs-comment">// 高频：索引20，约2000Hz以上（镲片、细节）</span>
    <span class="hljs-keyword">const</span> highFreqValue = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(dataArray[<span class="hljs-number">20</span>] * <span class="hljs-number">8</span>);
    
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'lowFreq'</span>).<span class="hljs-property">textContent</span> = lowFreqValue;
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'midFreq'</span>).<span class="hljs-property">textContent</span> = midFreqValue;
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'highFreq'</span>).<span class="hljs-property">textContent</span> = highFreqValue;
}
</code></pre>
<p><strong>频率分布原理：</strong></p>
<ul>
<li>数组索引对应不同的频率范围</li>
<li>乘数系数用于放大显示效果</li>
<li>实际应用中可以调整这些参数来匹配不同音乐类型</li>
</ul>
<h3 data-id="heading-11">7. 文件上传处理</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'audioFile'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'change'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-keyword">const</span> file = e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (file) {
        <span class="hljs-keyword">const</span> objectUrl = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(file);
        <span class="hljs-title function_">playAudioFile</span>(objectUrl);
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'trackInfo'</span>).<span class="hljs-property">textContent</span> = <span class="hljs-string">`正在播放: <span class="hljs-subst">${file.name}</span>`</span>;
    }
});

<span class="hljs-keyword">function</span> <span class="hljs-title function_">playAudioFile</span>(<span class="hljs-params">url</span>) {
    <span class="hljs-title function_">initAudioContext</span>();
    
    <span class="hljs-comment">// 停止之前的音频</span>
    <span class="hljs-keyword">if</span> (source &amp;&amp; source.<span class="hljs-property">stop</span>) {
        source.<span class="hljs-title function_">stop</span>();
    }
    
    <span class="hljs-comment">// 创建音频元素</span>
    <span class="hljs-keyword">const</span> audio = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Audio</span>();
    audio.<span class="hljs-property">src</span> = url;
    audio.<span class="hljs-property">crossOrigin</span> = <span class="hljs-string">"anonymous"</span>;  <span class="hljs-comment">// 解决CORS问题</span>
    
    <span class="hljs-comment">// 连接到Web Audio API</span>
    source = audioContext.<span class="hljs-title function_">createMediaElementSource</span>(audio);
    source.<span class="hljs-title function_">connect</span>(analyser);
    analyser.<span class="hljs-title function_">connect</span>(audioContext.<span class="hljs-property">destination</span>);
    
    <span class="hljs-comment">// 开始播放</span>
    audio.<span class="hljs-title function_">play</span>();
    isPlaying = <span class="hljs-literal">true</span>;
    
    <span class="hljs-comment">// 开始动画</span>
    <span class="hljs-title function_">animate</span>();
}
</code></pre>
<p><strong>关键技术点：</strong></p>
<p><strong>createObjectURL()</strong></p>
<ul>
<li>创建指向本地文件的临时URL</li>
<li>避免直接文件路径访问的安全限制</li>
</ul>
<p><strong>createMediaElementSource()</strong></p>
<ul>
<li>将普通Audio元素转换为Web Audio节点</li>
<li>建立音频处理管道</li>
</ul>
<p><strong>CORS处理</strong></p>
<ul>
<li><code>crossOrigin="anonymous"</code>解决跨域资源访问</li>
<li>必要的安全措施</li>
</ul>
<h3 data-id="heading-12">8. 控制按钮逻辑</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'startBtn'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (!isPlaying) {
        <span class="hljs-keyword">if</span> (!source) {
            <span class="hljs-title function_">createOscillator</span>();  <span class="hljs-comment">// 默认演示音频</span>
        }
        <span class="hljs-title function_">initAudioContext</span>();
        isPlaying = <span class="hljs-literal">true</span>;
        <span class="hljs-title function_">animate</span>();
    }
});

<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'stopBtn'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (isPlaying) {
        isPlaying = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (source &amp;&amp; source.<span class="hljs-property">stop</span>) {
            source.<span class="hljs-title function_">stop</span>();
            source = <span class="hljs-literal">null</span>;
        }
        <span class="hljs-comment">// 重置音频条</span>
        bars.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">bar</span> =&gt;</span> {
            bar.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">'5px'</span>;
        });
    }
});
</code></pre>
<h3 data-id="heading-13">9. 创建演示音频源</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createOscillator</span>(<span class="hljs-params"/>) {
    <span class="hljs-title function_">initAudioContext</span>();
    
    <span class="hljs-keyword">const</span> oscillator = audioContext.<span class="hljs-title function_">createOscillator</span>();
    oscillator.<span class="hljs-property">type</span> = <span class="hljs-string">'sawtooth'</span>;  <span class="hljs-comment">// 锯齿波，谐波丰富</span>
    oscillator.<span class="hljs-property">frequency</span>.<span class="hljs-title function_">setValueAtTime</span>(<span class="hljs-number">220</span>, audioContext.<span class="hljs-property">currentTime</span>);  <span class="hljs-comment">// A3音</span>
    
    <span class="hljs-keyword">const</span> gainNode = audioContext.<span class="hljs-title function_">createGain</span>();
    gainNode.<span class="hljs-property">gain</span>.<span class="hljs-property">value</span> = <span class="hljs-number">0.1</span>;  <span class="hljs-comment">// 音量控制</span>
    
    oscillator.<span class="hljs-title function_">connect</span>(gainNode);
    gainNode.<span class="hljs-title function_">connect</span>(analyser);
    analyser.<span class="hljs-title function_">connect</span>(audioContext.<span class="hljs-property">destination</span>);
    
    oscillator.<span class="hljs-title function_">start</span>();
    source = oscillator;
}
</code></pre>
<p><strong>音频合成原理：</strong></p>
<ul>
<li>振荡器类型影响音色特性</li>
<li>增益节点控制输出音量</li>
<li>220Hz对应钢琴的A3音</li>
</ul>
<h2 data-id="heading-14">原理解析：音频可视化是如何工作的？</h2>
<h3 data-id="heading-15">1. 音频分析基础</h3>
<p>当声音通过麦克风或音频文件进入Web Audio API时，它实际上是一系列连续的波形。AnalyserNode将这些波形通过<strong>傅里叶变换</strong>转换为频率数据。</p>
<p>简单来说，傅里叶变换可以将复杂的波形分解为不同频率的简单正弦波组合。</p>
<h3 data-id="heading-16">2. 频率数据</h3>
<p><code>getByteFrequencyData</code>方法返回一个Uint8Array（8位无符号整数数组），其中每个元素代表一个特定频率区间的振幅值，范围从0到255。</p>
<h3 data-id="heading-17">3. 可视化映射</h3>
<p>我们将这些数值映射到音频条的高度和颜色：</p>
<ul>
<li>值越大，音频条越高</li>
<li>不同的频率区间对应不同的颜色</li>
</ul>
<h2 data-id="heading-18">项目总结</h2>
<p><strong>已实现功能</strong></p>
<ul>
<li>音频文件上传和播放</li>
<li>实时频率分析和可视化</li>
<li>动态颜色变化效果</li>
<li>频率分区信息显示</li>
<li>响应式交互控制</li>
</ul>
<p><strong>通过这个项目，我们学习了：</strong></p>
<ul>
<li>Web Audio API的基本使用</li>
<li>如何获取和分析音频频率数据</li>
<li>使用JavaScript和CSS创建动态可视化效果</li>
<li>处理用户上传的文件</li>
</ul>
<p>完整代码在我的Github仓库，你可以直接复制使用。</p>
<p>Github地址：
<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2F1344160559-lch%2Fdh-vue3-component%2Fblob%2Fmain%2FAudioVisualization%2Findex.html" target="_blank" title="https://github.com/1344160559-lch/dh-vue3-component/blob/main/AudioVisualization/index.html" ref="nofollow noopener noreferrer">github.com/1344160559-…</a></strong></p>
<blockquote>
<p>本文首发于公众号：程序员刘大华，专注分享前后端开发的实战笔记。关注我，少走弯路，一起进步！</p>
</blockquote>
<h4 data-id="heading-19">📌往期精彩</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FP7SMincYFKERZbNKAFtzGQ" target="_blank" title="https://mp.weixin.qq.com/s/P7SMincYFKERZbNKAFtzGQ" ref="nofollow noopener noreferrer">《这20条SQL优化方案，让你的数据库查询速度提升10倍》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fy-GJ26kl0-yT6hE3fy2KjQ" target="_blank" title="https://mp.weixin.qq.com/s/y-GJ26kl0-yT6hE3fy2KjQ" ref="nofollow noopener noreferrer">《MySQL 为什么不推荐用雪花ID 和 UUID 做主键？》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1Th3DuMqYpt4Xg5hEywIww" target="_blank" title="https://mp.weixin.qq.com/s/1Th3DuMqYpt4Xg5hEywIww" ref="nofollow noopener noreferrer">《用html写了个超好用的网页主题切换插件》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfSMv8b_2Z-kozaBeiCgqrA" target="_blank" title="https://mp.weixin.qq.com/s/fSMv8b_2Z-kozaBeiCgqrA" ref="nofollow noopener noreferrer">《SpringBoot3+Vue3实现的数据库文档工具，自动生成Markdown/HTML》</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Webpack：从构建流程到性能优化的深度探索]]></title>    <link>https://juejin.cn/post/7569960869960368174</link>    <guid>https://juejin.cn/post/7569960869960368174</guid>    <pubDate>2025-11-09T12:35:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7569960869960368174" data-draft-id="7570201730991505434" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Webpack：从构建流程到性能优化的深度探索"/> <meta itemprop="keywords" content="Webpack,前端工程化,JavaScript"/> <meta itemprop="datePublished" content="2025-11-09T12:35:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="answerball"/> <meta itemprop="url" content="https://juejin.cn/user/209320781557531"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Webpack：从构建流程到性能优化的深度探索
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/209320781557531/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    answerball
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-09T12:35:37.000Z" title="Sun Nov 09 2025 12:35:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-09
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github-gist">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#333}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#d73a49}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-symbol{color:#0086b3}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#6f42c1}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.hljs-number{color:#005cc5}.hljs-string{color:#032f62}</style><p><strong>引言：为什么我们需要构建工具？</strong></p>
<p>想象一下，你正在开发一个复杂的前端应用，有几十个JavaScript文件、几十个CSS文件、各种图片和字体资源。如果手动管理这些文件的依赖关系、合并、压缩，那将是一场噩梦。这就是Webpack等构建工具诞生的原因——它们像一位细心的管家，帮我们打理前端项目中的各种资源，让开发变得高效而愉快。</p>
<p>作为前端开发领域最流行的构建工具之一，Webpack已经成为了现代Web开发不可或缺的一部分。本文将带你深入探索Webpack的构建机制，并分享一系列提升开发效率的实用技巧。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a3c1fcfc332450c8738452b7fcd9f3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYW5zd2VyYmFsbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763296537&amp;x-signature=fs9CxMtzbLXdGwebCmHIQ8%2BpNkg%3D" alt="image.png" width="50%" loading="lazy"/></p>
<h2 data-id="heading-0">一、Webpack构建流程：一场精心编排的演出</h2>
<p>Webpack的构建过程就像一场精心编排的演出，每个环节都有明确的职责和顺序。让我们揭开这场演出的幕后秘密。</p>
<h3 data-id="heading-1">1.1 初始化阶段：准备舞台</h3>
<p>一切始于参数初始化。Webpack会从配置文件（通常是webpack.config.js）和Shell命令中读取参数，然后合并这些参数，得出最终的配置。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.config.js 示例</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  },
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>
};
</code></pre>
<p>在这个阶段，Webpack会初始化Compiler对象——这是整个构建过程的大脑，负责调度和执行各个构建任务。同时，所有配置的插件会被加载，并注册到对应的事件钩子上。</p>
<h3 data-id="heading-2">1.2 编译阶段：演员就位</h3>
<p>编译阶段是构建过程的核心，它又可以分为几个关键步骤：</p>
<p><strong>确定入口</strong></p>
<p>Webpack从配置的entry开始，像侦探一样追踪每一个依赖。假设我们的入口文件是这样的：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// src/index.js</span>
<span class="hljs-keyword">import</span> { utils } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./styles.css'</span>;

utils.<span class="hljs-title function_">sayHello</span>();
</code></pre>
<p>Webpack会先处理index.js，然后发现它依赖utils.js和styles.css，接着去处理这些文件，再发现这些文件的依赖...如此递归下去，最终形成一个完整的依赖图。</p>
<p><strong>编译模块</strong></p>
<p>对于每个模块，Webpack会根据配置的loader对其进行"翻译"。比如，对于CSS文件，css-loader会处理其中的@import和url()，style-loader则会将CSS注入到DOM中。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack配置中的loader部分</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>]
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span>
      }
    ]
  }
};
</code></pre>
<p>这个过程就像把各种语言的书籍（不同类型的模块）翻译成统一的语言（JavaScript），让浏览器这个"读者"能够理解。</p>
<p><strong>完成模块编译</strong></p>
<p>经过loader的处理，每个模块都被转换成了浏览器能够理解的形式，同时Webpack也清晰地掌握了模块之间的依赖关系。</p>
<h3 data-id="heading-3">1.3 输出阶段：演出开始</h3>
<p><strong>输出资源</strong></p>
<p>Webpack会将相关的模块分组到不同的chunk中。比如，通过splitChunks优化，可以将第三方库单独打包：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">cacheGroups</span>: {
        <span class="hljs-attr">vendor</span>: {
          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">'vendors'</span>,
          <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>
        }
      }
    }
  }
};
</code></pre>
<p>每个chunk最终会被转换成单独的文件，加入到输出列表中。这时，插件还有最后一次机会修改输出内容。</p>
<p><strong>输出完成</strong></p>
<p>最后，Webpack根据配置的输出路径和文件名，将文件写入到文件系统中。至此，构建过程圆满完成。</p>
<h3 data-id="heading-4">1.4 插件系统：演出的特效团队</h3>
<p>Webpack的插件系统就像演出的特效团队，在特定时刻为演出增添亮点。插件通过监听Webpack在生命周期中广播的各种事件，在合适的时机执行自定义逻辑。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 一个简单的插件示例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">'MyPlugin'</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'构建完成，准备输出资源！'</span>);
    });
  }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;
</code></pre>
<h2 data-id="heading-5">二、提升开发效率：Webpack的好帮手</h2>
<p>在了解了Webpack的构建流程后，让我们看看如何通过各种工具和技巧提升开发效率。</p>
<h3 data-id="heading-6">2.1 可视化工具：让构建过程一目了然</h3>
<p><strong>webpack-dashboard：构建仪表盘</strong></p>
<p>传统的命令行输出信息有限且不够直观。webpack-dashboard提供了一个全新的终端可视化界面，让你对构建状态、资源大小、错误信息等一目了然。</p>
<p>安装和使用非常简单：</p>
<pre><code class="hljs language-bash" lang="bash">npm install --save-dev webpack-dashboard
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">DashboardPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-dashboard/plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...其他配置</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DashboardPlugin</span>()
  ]
};
</code></pre>
<p><strong>speed-measure-webpack-plugin：性能分析专家</strong></p>
<p>这个插件可以测量各个loader和插件的耗时，帮你找出构建过程中的性能瓶颈。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SpeedMeasurePlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"speed-measure-webpack-plugin"</span>);
<span class="hljs-keyword">const</span> smp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpeedMeasurePlugin</span>();

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = smp.<span class="hljs-title function_">wrap</span>({
  <span class="hljs-comment">// 原来的webpack配置</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>] <span class="hljs-comment">// 这里会显示每个loader的耗时</span>
      }
    ]
  }
});
</code></pre>
<h3 data-id="heading-7">2.2 配置管理：让配置更清晰</h3>
<p><strong>webpack-merge：配置合并利器</strong></p>
<p>在大型项目中，我们通常需要针对不同环境（开发、测试、生产）使用不同的配置。webpack-merge可以帮助我们提取公共配置，避免重复代码。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { merge } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>);

<span class="hljs-comment">// 公共配置</span>
<span class="hljs-keyword">const</span> commonConfig = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [{
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
      <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span>
    }]
  }
};

<span class="hljs-comment">// 开发环境配置</span>
<span class="hljs-keyword">const</span> devConfig = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'cheap-module-source-map'</span>
};

<span class="hljs-comment">// 生产环境配置  </span>
<span class="hljs-keyword">const</span> prodConfig = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'source-map'</span>
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (env === <span class="hljs-string">'production'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(commonConfig, prodConfig);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(commonConfig, devConfig);
};
</code></pre>
<h3 data-id="heading-8">2.3 热更新：开发者的福音</h3>
<p><strong>HotModuleReplacementPlugin</strong></p>
<p>热模块替换（HMR）是开发过程中极其有用的功能。它允许在运行时更新各种模块，而无需进行完全刷新，这意味着你可以在不丢失应用状态的情况下看到代码更改的效果。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...其他配置</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启热更新</span>
    <span class="hljs-attr">contentBase</span>: <span class="hljs-string">'./dist'</span>
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>()
  ]
};
</code></pre>
<p>对于CSS，HMR体验尤为出色 - 样式更改会立即反映在页面上。对于JavaScript，你可能需要手动处理模块更新：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>) {
  <span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-string">'./myModule'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 模块更新后的回调</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'myModule更新了！'</span>);
  });
}
</code></pre>
<h2 data-id="heading-9">三、文件指纹：精准控制缓存策略</h2>
<p>文件指纹是打包后输出文件名的后缀，用于控制浏览器缓存，是性能优化中的重要一环。</p>
<h3 data-id="heading-10">3.1 三种文件指纹策略</h3>
<p><strong>Hash：项目级别</strong></p>
<p>Hash与整个项目构建相关，只要项目文件有修改，整个项目构建的hash值就会改变。这种策略比较"粗放"，任何文件改动都会导致所有输出文件的hash变化。</p>
<p><strong>ChunkHash：代码块级别</strong></p>
<p>ChunkHash与webpack打包的chunk相关，不同的entry会生成不同的chunkhash。这种方式更为精准，只有属于同一chunk的文件发生变化时，该chunk的hash才会改变。</p>
<p><strong>ContentHash：内容级别</strong></p>
<p>ContentHash根据文件内容来定义hash，文件内容不变，contenthash就不变。这是最精确的缓存控制策略，特别适用于CSS等资源文件。</p>
<h3 data-id="heading-11">3.2 实战文件指纹配置</h3>
<p><strong>JavaScript的文件指纹</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">app</span>: <span class="hljs-string">'./src/app.js'</span>,
    <span class="hljs-attr">search</span>: <span class="hljs-string">'./src/search.js'</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name]-[chunkhash:8].js'</span> <span class="hljs-comment">// 使用8位chunkhash</span>
  }
};
</code></pre>
<p>这样会生成类似app-a1b2c3d4.js和search-e5f6g7h8.js的文件。</p>
<p><strong>CSS的文件指纹</strong></p>
<p>CSS的文件指纹需要借助MiniCssExtractPlugin：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">app</span>: <span class="hljs-string">'./src/app.js'</span>,
    <span class="hljs-attr">search</span>: <span class="hljs-string">'./src/search.js'</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name]-[chunkhash:8].js'</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-comment">// 使用MiniCssExtractPlugin的loader</span>
          <span class="hljs-string">'css-loader'</span>
        ]
      }
    ]
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name]-[contenthash:8].css'</span> <span class="hljs-comment">// 使用8位contenthash</span>
    })
  ]
};
</code></pre>
<p><strong>图片资源的文件指纹</strong></p>
<p>对于图片等静态资源，我们通常使用file-loader或url-loader来处理：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>)
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpg|gif)$/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'file-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">name</span>: <span class="hljs-string">'images/[name]-[hash:8].[ext]'</span> <span class="hljs-comment">// 图片使用hash</span>
            }
          }
        ]
      }
    ]
  }
};
</code></pre>
<p>file-loader提供了丰富的占位符：</p>
<ul>
<li><code>[name]</code>：文件原名</li>
<li><code>[path]</code>：文件相对路径</li>
<li><code>[folder]</code>：文件所在文件夹</li>
<li><code>[hash]</code>：文件内容hash</li>
<li><code>[contenthash]</code>：内容hash（与hash通常相同）</li>
</ul>
<h2 data-id="heading-12">四、构建性能优化：让打包速度飞起来</h2>
<p>随着项目规模的增长，构建时间可能会成为开发效率的瓶颈。下面是一些实用的优化策略。</p>
<h3 data-id="heading-13">4.1 使用最新工具</h3>
<p>始终使用最新版本的Webpack和Node.js。每个新版本通常都会带来性能改进和新特性。Webpack 5相比Webpack 4在构建性能上有显著提升。</p>
<h3 data-id="heading-14">4.2 多进程构建</h3>
<p><strong>thread-loader</strong></p>
<p>将这个loader放在其他loader之前，其后的loader就会在单独的worker池中运行，充分利用多核CPU的优势。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'thread-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">workers</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 开启2个worker</span>
            }
          },
          <span class="hljs-string">'babel-loader'</span>
        ]
      }
    ]
  }
};
</code></pre>
<p>注意：thread-loader有一定启动开销，在小型项目中可能不太划算。</p>
<h3 data-id="heading-15">4.3 优化压缩过程</h3>
<p><strong>并行压缩JavaScript</strong></p>
<p>使用TerserWebpackPlugin开启多进程并行压缩：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'terser-webpack-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>({
        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启多进程</span>
        <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 开启缓存</span>
      })
    ]
  }
};
</code></pre>
<p><strong>CSS压缩和提取</strong></p>
<p>使用MiniCssExtractPlugin配合优化器：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-minimizer-webpack-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">'css-loader'</span>]
      }
    ]
  },
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>()
    ]
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()]
};
</code></pre>
<h3 data-id="heading-16">4.4 图片优化</h3>
<p>使用image-webpack-loader自动压缩图片：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg)$/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'file-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">name</span>: <span class="hljs-string">'images/[name]-[hash:8].[ext]'</span>
            }
          },
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'image-webpack-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">mozjpeg</span>: {
                <span class="hljs-attr">progressive</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">quality</span>: <span class="hljs-number">65</span>
              },
              <span class="hljs-attr">optipng</span>: {
                <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>
              },
              <span class="hljs-attr">pngquant</span>: {
                <span class="hljs-attr">quality</span>: [<span class="hljs-number">0.65</span>, <span class="hljs-number">0.90</span>],
                <span class="hljs-attr">speed</span>: <span class="hljs-number">4</span>
              }
            }
          }
        ]
      }
    ]
  }
};
</code></pre>
<h3 data-id="heading-17">4.5 缩小打包作用域</h3>
<p>通过精确配置，减少Webpack的搜索范围，可以显著提升构建速度。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-comment">// 明确告诉webpack搜索哪些目录</span>
    <span class="hljs-attr">modules</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'node_modules'</span>)],
    <span class="hljs-comment">// 使用别名减少查找过程</span>
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-string">'@'</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>)
    },
    <span class="hljs-comment">// 减少尝试的扩展名</span>
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.jsx'</span>, <span class="hljs-string">'.json'</span>]
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-comment">// 只对src目录下的js文件使用babel-loader</span>
        <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'src'</span>),
        <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span>
      }
    ]
  }
};
</code></pre>
<h3 data-id="heading-18">4.6 提取公共资源</h3>
<p><strong>分离第三方库</strong></p>
<p>将不常变动的第三方库单独打包，可以利用浏览器缓存：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">cacheGroups</span>: {
        <span class="hljs-attr">vendor</span>: {
          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">'vendors'</span>,
          <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>
        }
      }
    }
  }
};
</code></pre>
<p><strong>使用CDN</strong></p>
<p>通过externals配置，将一些大型库排除在打包之外，通过CDN引入：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">externals</span>: {
    <span class="hljs-attr">react</span>: <span class="hljs-string">'React'</span>,
    <span class="hljs-string">'react-dom'</span>: <span class="hljs-string">'ReactDOM'</span>
  }
};
</code></pre>
<p>然后在HTML中通过script标签引入CDN资源。</p>
<h3 data-id="heading-19">4.7 充分利用缓存</h3>
<p>缓存是提升二次构建速度的利器。</p>
<p><strong>babel-loader缓存</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>,
          <span class="hljs-attr">options</span>: {
            <span class="hljs-attr">cacheDirectory</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 开启babel缓存</span>
          }
        }
      }
    ]
  }
};
</code></pre>
<p><strong>持久化缓存</strong></p>
<p>Webpack 5提供了内置的持久化缓存：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">cache</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'filesystem'</span> <span class="hljs-comment">// 使用文件系统缓存</span>
  }
};
</code></pre>
<p>对于Webpack 4，可以使用hard-source-webpack-plugin：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HardSourceWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hard-source-webpack-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">HardSourceWebpackPlugin</span>()]
};
</code></pre>
<h3 data-id="heading-20">4.8 Tree Shaking：消除无用代码</h3>
<p>Tree Shaking就像园丁修剪树木一样，去除代码中未被使用的部分，让最终打包体积更小。</p>
<p>ES6模块系统是Tree Shaking的基础，因为ES6模块是静态的，可以在编译时确定依赖关系。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// math.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x * x;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x * x * x;
}

<span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> { cube } <span class="hljs-keyword">from</span> <span class="hljs-string">'./math.js'</span>; <span class="hljs-comment">// 只引入了cube</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">cube</span>(<span class="hljs-number">5</span>));
</code></pre>
<p>在这个例子中，square函数不会被包含在最终的bundle中。</p>
<p>确保在package.json中设置sideEffects属性，帮助Webpack识别哪些文件有副作用：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"your-project"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"sideEffects"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"*.css"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"*.scss"</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 data-id="heading-21">五、自定义Loader和Plugin：扩展Webpack能力</h2>
<p>当Webpack内置功能无法满足需求时，我们可以通过编写自定义loader和plugin来扩展其能力。</p>
<h3 data-id="heading-22">5.1 编写Loader：模块转换器</h3>
<p>Loader就像一个翻译官，负责将各种类型的模块"翻译"成Webpack能够理解的JavaScript。</p>
<p><strong>Loader开发原则</strong></p>
<ul>
<li>单一职责：每个loader只做一件事</li>
<li>链式调用：loader支持链式调用，前一个loader的输出作为后一个loader的输入</li>
<li>模块化：确保loader输出的是JavaScript模块</li>
<li>无状态：在多次构建之间，loader不应该保留状态</li>
</ul>
<p><strong>一个简单的Loader示例</strong></p>
<p>假设我们要开发一个简单的markdown loader：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">'marked'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {
  <span class="hljs-comment">// 获取loader的配置选项</span>
  <span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOptions</span>();
  
  <span class="hljs-comment">// 使用marked解析markdown</span>
  <span class="hljs-keyword">const</span> html = <span class="hljs-title function_">marked</span>(source, options);
  
  <span class="hljs-comment">// 返回JavaScript模块</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`module.exports = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(html)}</span>`</span>;
};
</code></pre>
<p>使用这个loader：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,
        <span class="hljs-attr">use</span>: [
          {
            <span class="hljs-attr">loader</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'markdown-loader.js'</span>),
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">pedantic</span>: <span class="hljs-literal">true</span>
            }
          }
        ]
      }
    ]
  }
};
</code></pre>
<p><strong>Loader工具库</strong></p>
<p>官方提供的loader-utils和schema-utils可以简化loader开发：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { getOptions } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'loader-utils'</span>);
<span class="hljs-keyword">const</span> { validate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'schema-utils'</span>);

<span class="hljs-keyword">const</span> schema = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'object'</span>,
  <span class="hljs-attr">properties</span>: {
    <span class="hljs-attr">test</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>
    }
  }
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {
  <span class="hljs-keyword">const</span> options = <span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>);
  
  <span class="hljs-comment">// 验证options是否符合schema</span>
  <span class="hljs-title function_">validate</span>(schema, options, <span class="hljs-string">'Example Loader'</span>);
  
  <span class="hljs-comment">// loader逻辑...</span>
  <span class="hljs-keyword">return</span> source;
};
</code></pre>
<h3 data-id="heading-23">5.2 编写Plugin：构建过程增强器</h3>
<p>如果说Loader处理的是单个模块，那么Plugin则是在整个构建过程中起作用，可以监听Webpack构建生命周期中的事件，在合适的时机执行自定义逻辑。</p>
<p><strong>Plugin基本结构</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    <span class="hljs-comment">// 注册钩子</span>
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">someHook</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">'MyPlugin'</span>, <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> {
      <span class="hljs-comment">// 插件逻辑</span>
    });
  }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;
</code></pre>
<p><strong>一个实用的Plugin示例</strong></p>
<p>让我们创建一个在构建完成后显示构建信息的插件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildInfoPlugin</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options || {};
  }

  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">'BuildInfoPlugin'</span>, <span class="hljs-function">(<span class="hljs-params">stats</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> { compilation } = stats;
      <span class="hljs-keyword">const</span> { outputOptions } = compilation;
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'🎉 构建完成！'</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📁 输出目录: <span class="hljs-subst">${outputOptions.path}</span>`</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📦 文件数量: <span class="hljs-subst">${compilation.assets.length}</span>`</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`⏱ 构建时间: <span class="hljs-subst">${stats.endTime - stats.startTime}</span>ms`</span>);
      
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">showAssets</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'📄 生成文件:'</span>);
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(compilation.<span class="hljs-property">assets</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">assetName</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> asset = compilation.<span class="hljs-property">assets</span>[assetName];
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`   <span class="hljs-subst">${assetName}</span> (<span class="hljs-subst">${asset.size()}</span> bytes)`</span>);
        });
      }
    });
  }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">BuildInfoPlugin</span>;
</code></pre>
<p>使用这个插件：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">BuildInfoPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build-info-plugin'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildInfoPlugin</span>({
      <span class="hljs-attr">showAssets</span>: <span class="hljs-literal">true</span>
    })
  ]
};
</code></pre>
<p><strong>理解Compiler和Compilation</strong></p>
<p>在Plugin开发中，有两个核心概念需要理解：</p>
<ul>
<li>compiler：代表了配置完备的Webpack环境，从启动到关闭的整个生命周期</li>
<li>compilation：代表了一次单一的构建，包含了当前的模块资源、编译生成资源、变化的文件等信息</li>
</ul>
<p><strong>常用的钩子时机</strong></p>
<ul>
<li>entryOption：处理entry配置</li>
<li>compile：开始编译</li>
<li>emit：生成资源到output目录之前</li>
<li>done：编译完成</li>
</ul>
<h2 data-id="heading-24">结语</h2>
<p>Webpack作为现代前端开发的基石，其重要性不言而喻。通过深入了解其构建流程、掌握性能优化技巧、甚至能够编写自定义的loader和plugin，我们不仅能够提升开发效率，还能更好地应对复杂项目的构建需求。</p>
<p>记住，Webpack配置没有绝对的"最佳实践"，最适合项目需求的配置就是最好的配置。希望本文能帮助你在Webpack的学习和使用道路上走得更远，让构建工具真正成为提升开发体验的利器，而不是令人头疼的负担。</p>
<p>构建愉快！</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/310f9fafebf248d2bcd0e307983f15d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYW5zd2VyYmFsbA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763296537&amp;x-signature=hd5FmxDyvnYgqcpe4eXd1FJ9zhg%3D" alt="image.png" width="50%" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C++双向链表删除操作：由浅入深完全指南]]></title>    <link>https://juejin.cn/post/7570899512782176319</link>    <guid>https://juejin.cn/post/7570899512782176319</guid>    <pubDate>2025-11-10T11:17:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570899512782176319" data-draft-id="7570885801478144041" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C++双向链表删除操作：由浅入深完全指南"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T11:17:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="oioihoii"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C++双向链表删除操作：由浅入深完全指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    oioihoii
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:17:08.000Z" title="Mon Nov 10 2025 11:17:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>双向链表是一种基础且重要的数据结构，每个节点不仅包含数据，还包含指向前一个节点和后一个节点的指针。这种结构使得双向链表在插入和删除操作上，尤其是在已知节点位置时，比单向链表更具优势。</p>
<p>本文将聚焦于<strong>删除操作</strong>，带你从基本概念出发，逐步深入到边界处理和应用实践。</p>
<hr/>
<h3 data-id="heading-0"><strong>第一部分：基础篇 —— 删除节点的核心逻辑</strong></h3>
<p>在双向链表中删除一个节点，核心在于“重新布线”，将被删除节点前后两个节点连接起来，然后安全地释放该节点。</p>
<p>假设我们有一个简单的节点定义：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> {
    <span class="hljs-type">int</span> val;
    ListNode* prev; <span class="hljs-comment">// 指向前一个节点</span>
    ListNode* next; <span class="hljs-comment">// 指向后一个节点</span>
    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) {}
};
</code></pre>
<p>现在，假设我们要在链表中删除一个已知的节点 <code>delNode</code>。下图清晰地展示了这一过程：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e15fa6831ca4695a50edf681093c273~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgb2lvaWhvaWk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763378228&amp;x-signature=4X8IV%2FJbTfw%2F%2Bt5w0hC4DnX8Ajo%3D" alt="deepseek_mermaid_20251110_5ac562.png" loading="lazy"/></p>
<p>根据图示，我们可以将其转化为代码：</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 前提：delNode 不是空指针，且存在于链表中</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* delNode)</span> </span>{
    <span class="hljs-comment">// 1. 处理前驱节点的next指针</span>
    <span class="hljs-keyword">if</span> (delNode-&gt;prev != <span class="hljs-literal">nullptr</span>) {
        delNode-&gt;prev-&gt;next = delNode-&gt;next;
    }
    <span class="hljs-comment">// 2. 处理后继节点的prev指针</span>
    <span class="hljs-keyword">if</span> (delNode-&gt;next != <span class="hljs-literal">nullptr</span>) {
        delNode-&gt;next-&gt;prev = delNode-&gt;prev;
    }
    <span class="hljs-comment">// 3. 安全删除节点</span>
    <span class="hljs-keyword">delete</span> delNode;
}
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>我们必须检查 <code>delNode-&gt;prev</code> 和 <code>delNode-&gt;next</code> 是否为空，因为要删除的节点可能是头节点或尾节点。</li>
<li>操作顺序很重要，但在此例中，只要在解除链接前获取了必要的信息，顺序可以调整。</li>
</ul>
<hr/>
<h3 data-id="heading-1"><strong>第二部分：进阶篇 —— 处理边界情况与设计封装</strong></h3>
<p>基础的删除逻辑很简单，但一个健壮的链表实现需要 meticulously (一丝不苟地) 处理各种边界情况。</p>
<h4 data-id="heading-2"><strong>情况一：删除头节点</strong></h4>
<p>如果 <code>delNode</code> 是链表的头节点，在删除后，链表的头指针需要被更新。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode** head_ref, ListNode* delNode)</span> </span>{
    <span class="hljs-comment">// 检查空指针</span>
    <span class="hljs-keyword">if</span> (*head_ref == <span class="hljs-literal">nullptr</span> || delNode == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 如果删除的是头节点，则需要更新头指针</span>
    <span class="hljs-keyword">if</span> (*head_ref == delNode) {
        *head_ref = delNode-&gt;next; <span class="hljs-comment">// 新的头节点是原头的下一个</span>
    }

    <span class="hljs-comment">// ... (接下来的连接操作与基础篇相同)</span>
    <span class="hljs-keyword">if</span> (delNode-&gt;next != <span class="hljs-literal">nullptr</span>) {
        delNode-&gt;next-&gt;prev = delNode-&gt;prev;
    }
    <span class="hljs-keyword">if</span> (delNode-&gt;prev != <span class="hljs-literal">nullptr</span>) {
        delNode-&gt;prev-&gt;next = delNode-&gt;next;
    }

    <span class="hljs-keyword">delete</span> delNode;
}
</code></pre>
<h4 data-id="heading-3"><strong>情况二：删除尾节点</strong></h4>
<p>如果 <code>delNode</code> 是尾节点，我们只需要更新它前一个节点的 <code>next</code> 指针为 <code>nullptr</code>。基础代码中的 <code>if (delNode-&gt;next != nullptr)</code> 已经完美处理了这种情况，防止了访问空指针的 <code>prev</code>。</p>
<h4 data-id="heading-4"><strong>情况三：删除唯一节点</strong></h4>
<p>如果链表只有一个节点，那么删除它后，头指针需要被置为 <code>nullptr</code>。上面的代码同样可以处理：它首先将 <code>*head_ref</code> 设置为 <code>delNode-&gt;next</code>（也就是 <code>nullptr</code>），然后进行连接操作（因为 <code>prev</code> 和 <code>next</code> 都是 <code>nullptr</code>，所以 <code>if</code> 内的语句不会执行）。</p>
<hr/>
<h3 data-id="heading-5"><strong>第三部分：实践篇 —— 完整的链表类与复杂删除</strong></h3>
<p>让我们在一个简单的双向链表类中实现删除功能，并探讨更复杂的场景。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> {
<span class="hljs-keyword">private</span>:
    ListNode* head;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">DoublyLinkedList</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>) {}

    <span class="hljs-comment">// 删除指定值的第一个节点</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteByValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{
        ListNode* current = head;
        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) {
            <span class="hljs-keyword">if</span> (current-&gt;val == value) {
                <span class="hljs-comment">// 找到节点，调用删除逻辑</span>
                <span class="hljs-keyword">if</span> (current == head) {
                    head = head-&gt;next;
                }
                <span class="hljs-keyword">if</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) {
                    current-&gt;next-&gt;prev = current-&gt;prev;
                }
                <span class="hljs-keyword">if</span> (current-&gt;prev != <span class="hljs-literal">nullptr</span>) {
                    current-&gt;prev-&gt;next = current-&gt;next;
                }
                <span class="hljs-keyword">delete</span> current;
                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 只删除第一个找到的</span>
            }
            current = current-&gt;next;
        }
    }

    <span class="hljs-comment">// 删除指定位置的节点 (索引从0开始)</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteByPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span> </span>{
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || position &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

        ListNode* current = head;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; current != <span class="hljs-literal">nullptr</span> &amp;&amp; i &lt; position; i++) {
            current = current-&gt;next;
        }

        <span class="hljs-comment">// 如果current为空，说明位置超出链表长度</span>
        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-comment">// 复用删除节点的核心逻辑</span>
        <span class="hljs-keyword">if</span> (current == head) {
            head = head-&gt;next;
        }
        <span class="hljs-keyword">if</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) {
            current-&gt;next-&gt;prev = current-&gt;prev;
        }
        <span class="hljs-keyword">if</span> (current-&gt;prev != <span class="hljs-literal">nullptr</span>) {
            current-&gt;prev-&gt;next = current-&gt;next;
        }
        <span class="hljs-keyword">delete</span> current;
    }

    <span class="hljs-comment">// 清空整个链表</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) {
            ListNode* temp = head;
            head = head-&gt;next;
            <span class="hljs-keyword">delete</span> temp;
        }
    }

    <span class="hljs-comment">// ... 其他成员函数，如push_front, push_back, print等</span>
};
</code></pre>
<p><strong>复杂删除场景：</strong></p>
<ol>
<li><strong>清空链表：</strong> 如 <code>clear()</code> 函数所示，它反复删除头节点，直到链表为空。这是一种高效且安全的方法。</li>
<li><strong>在析构函数中调用：</strong> 一个良好的 C++ 链表类必须在析构函数中清理所有节点，防止内存泄漏。
<pre><code class="hljs language-cpp" lang="cpp">~<span class="hljs-built_in">DoublyLinkedList</span>() {
    <span class="hljs-built_in">clear</span>();
}
</code></pre>
</li>
</ol>
<hr/>
<h3 data-id="heading-6"><strong>第四部分：深入理解 —— 与单向链表删除的对比</strong></h3>
<p>这是理解双向链表优势的关键。</p>

























<table><thead><tr><th align="left">特性</th><th align="left">单向链表</th><th align="left">双向链表</th></tr></thead><tbody><tr><td align="left"><strong>删除给定节点</strong></td><td align="left"><strong>O(n)</strong>。需要从头遍历以找到该节点的前驱节点。</td><td align="left"><strong>O(1)</strong>。因为通过 <code>prev</code> 指针可以直接找到前驱节点。</td></tr><tr><td align="left"><strong>删除头节点</strong></td><td align="left">O(1)</td><td align="left">O(1)</td></tr><tr><td align="left"><strong>删除尾节点</strong></td><td align="left">O(n)。需要找到倒数第二个节点。</td><td align="left">O(1)。通过尾节点的 <code>prev</code> 直接找到前驱。</td></tr></tbody></table>
<p><strong>结论：</strong> 当操作涉及到反向遍历或已知节点位置而非仅值时的删除，双向链表的效率远高于单向链表。</p>
<h3 data-id="heading-7"><strong>总结</strong></h3>
<p>从最基础的“重新布线”逻辑，到处理头节点、尾节点等边界情况，再到封装成完整的类并与单向链表进行对比，我们对C++双向链表的删除操作进行了一次由浅入深的探索。</p>
<p>记住成为一名优秀C++程序员的关键：</p>
<ul>
<li><strong>始终注意内存管理</strong>：<code>new</code> 和 <code>delete</code> 要成对出现。</li>
<li><strong>严谨处理边界</strong>：头节点、尾节点、空链表是bug的高发区。</li>
<li><strong>理解底层原理</strong>：明白指针是如何被操作的，才能写出正确、高效的代码。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[软件生产的“高速公路网”：深入浅出理解CI/CD的核心流程]]></title>    <link>https://juejin.cn/post/7570885801478160425</link>    <guid>https://juejin.cn/post/7570885801478160425</guid>    <pubDate>2025-11-10T11:18:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570885801478160425" data-draft-id="7570899512782192703" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="软件生产的“高速公路网”：深入浅出理解CI/CD的核心流程"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T11:18:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="oioihoii"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            软件生产的“高速公路网”：深入浅出理解CI/CD的核心流程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    oioihoii
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:18:19.000Z" title="Mon Nov 10 2025 11:18:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在现代软件开发中，我们追求的是快速、频繁且可靠地发布新功能。而实现这一目标的基石，就是CI/CD。很多人把CI/CD简单理解为一条“流水线”，但其内部实则有一套精密的“交通系统”，由多种不同的“流”构成。本文将为您拆解CI/CD中各种“流”的概念与作用。</p>
<h3 data-id="heading-0"><strong>一、 核心主干道：按流程阶段划分的“流”</strong></h3>
<p>这是理解CI/CD最经典的视角，描绘了代码从提交到上线的完整旅程。</p>
<h4 data-id="heading-1"><strong>1. CI（持续集成）流：代码的“质量检测线”</strong></h4>
<p>这条流的核心是<strong>快速反馈，确保代码质量</strong>。</p>
<ul>
<li><strong>触发信号</strong>：开发者向代码仓库（如Git）推送了新的代码。</li>
<li><strong>流水线工序</strong>：
<ol>
<li><strong>拉取代码</strong>：自动抓取最新的代码变更。</li>
<li><strong>静态检查</strong>：如同代码的“语法检查”，运行自动化工具扫描代码风格、潜在漏洞和复杂度。</li>
<li><strong>编译打包</strong>：将源代码“翻译”成可执行的软件包（如Docker镜像、JAR包）。</li>
<li><strong>单元测试</strong>：运行大量细粒度的测试，验证每个代码单元的正确性。</li>
</ol>
</li>
<li><strong>最终目标</strong>：生成一个<strong>可信的、可随时部署的软件制品</strong>，并存入“制品库”。如果此流程任何一步失败，团队会立即收到警报。</li>
</ul>
<h4 data-id="heading-2"><strong>2. CD流：软件的“发布之旅”</strong></h4>
<p>CI流确保了“货物”质量合格，CD流则负责将其“安全送达用户手中”。CD又分为两种模式：</p>
<p><strong>a) 持续交付流：整装待发，一键部署</strong></p>
<ul>
<li><strong>核心特征</strong>：<strong>自动化一切，但生产部署需要手动批准</strong>。</li>
<li><strong>流水线工序</strong>：
<ol>
<li><strong>自动部署到测试环境</strong>：将CI产生的制品部署到类生产环境。</li>
<li><strong>全面测试</strong>：进行更严格的集成测试、端到端测试和安全扫描。</li>
<li><strong>等待手动批准</strong>：在最终部署前，项目经理或运维人员点击“确认”按钮。</li>
<li><strong>一键部署</strong>：经批准后，自动化部署到生产环境。</li>
</ol>
</li>
<li><strong>适用场景</strong>：对发布有严格管控要求的企业，是目前最主流的模式。</li>
</ul>
<p><strong>b) 持续部署流：全程自动驾驶</strong></p>
<ul>
<li><strong>核心特征</strong>：<strong>完全自动化，无需手动干预</strong>。</li>
<li><strong>流水线工序</strong>：在持续交付的基础上，<strong>移除了手动批准环节</strong>。只要代码通过所有自动化测试关卡，就会像坐上滑梯一样，<strong>自动、直接地发布到生产环境</strong>。</li>
<li><strong>适用场景</strong>：追求极致效率、测试文化非常成熟的团队。</li>
</ul>
<blockquote>
<p><strong>简单比喻</strong>：持续交付像是把火箭发射按钮放在玻璃罩里，需要时再砸碎按下；持续部署则是程序自动判断最佳时机并直接发射。</p>
</blockquote>
<h3 data-id="heading-3"><strong>二、 分支策略流：代码管理的“交通规则”</strong></h3>
<p>在多人协作开发中，代码存放在不同的分支上，就像城市有不同的道路。不同的分支对应着不同的CI/CD流程。</p>
<ul>
<li>
<p><strong>特性分支流（城市小道）</strong>：</p>
<ul>
<li><strong>场景</strong>：开发者在自己的分支上开发新功能。</li>
<li><strong>流程</strong>：触发一个<strong>轻量级CI流</strong>，只进行编译和基础测试，目的是给开发者快速反馈，<strong>不部署</strong>。</li>
</ul>
</li>
<li>
<p><strong>主干/开发分支流（城市主干道）</strong>：</p>
<ul>
<li><strong>场景</strong>：代码合并到主分支或开发分支。</li>
<li><strong>流程</strong>：触发<strong>完整的CI流</strong>和后续的<strong>CD流</strong>，自动部署到测试或预发布环境。这是最重要的流程之一。</li>
</ul>
</li>
<li>
<p><strong>发布/热修复分支流（应急车道）</strong>：</p>
<ul>
<li><strong>场景</strong>：为发布版本或修复线上紧急Bug创建的分支。</li>
<li><strong>流程</strong>：触发一个<strong>稳定、快速的CI/CD流</strong>，旨在用最简路径将代码安全可靠地交付上线。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-4"><strong>三、 发布模式流：上线时的“交通疏导方案”</strong></h3>
<p>当软件包抵达生产环境门口，如何让用户无感知、平滑地切换到新版本？这就需要智能的“交通疏导”策略。</p>
<ul>
<li>
<p><strong>蓝绿部署：整体切换</strong></p>
<ul>
<li><strong>描述</strong>：准备两套完全相同的环境（蓝和绿）。当前用户流量在蓝色（旧版本）。新版本在绿色环境部署测试完毕后，<strong>瞬间将全部流量从蓝色切换到绿色</strong>。</li>
<li><strong>优点</strong>：发布和回滚（切回蓝色）都极快，几乎零风险。</li>
</ul>
</li>
<li>
<p><strong>金丝雀发布：逐步放行</strong></p>
<ul>
<li><strong>描述</strong>：像矿工用金丝雀探测瓦斯一样，先将新版本部署到一小部分服务器，引入少量用户流量（如2%）。确认无误后，再逐步扩大范围，直至完全替换旧版本。</li>
<li><strong>优点</strong>：能最大限度地控制新版本故障的影响范围，是风险最低的发布策略。</li>
</ul>
</li>
<li>
<p><strong>滚动更新：渐进替换</strong></p>
<ul>
<li><strong>描述</strong>：在Kubernetes等平台中常见。逐步停止旧版本的实例，同时启动新版本的实例，直到所有实例都更新完毕。</li>
<li><strong>优点</strong>：服务不会中断，资源利用高效。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-5"><strong>总结：一张交织的智能网络</strong></h3>
<p>CI/CD中的这些“流”并非孤立存在，它们共同构成了一张智能高效的软件交付网络：</p>
<ul>
<li><strong>特性分支流</strong> 保障了开发过程的敏捷。</li>
<li><strong>CI流</strong> 作为质量基石，是所有后续流程的信任来源。</li>
<li><strong>主干分支流</strong> 驱动着 <strong>持续交付/部署流</strong>，实现了集成的自动化。</li>
<li><strong>蓝绿部署/金丝雀发布</strong> 等策略，则确保了发布最终用户时的平滑与安全。</li>
</ul>
<p>理解并巧妙组合这些流程，就如同为您的软件项目规划了一套完美的交通系统，能让您的创意以安全、稳定、极速的方式，抵达用户的指尖。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么在 JavaScript 中 NaN !== NaN？背后藏着 40 年的技术故事]]></title>    <link>https://juejin.cn/post/7570932873130901531</link>    <guid>https://juejin.cn/post/7570932873130901531</guid>    <pubDate>2025-11-10T11:54:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570932873130901531" data-draft-id="7570912420567662602" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 为什么在 JavaScript 中 NaN !== NaN？背后藏着 40 年的技术故事"/> <meta itemprop="keywords" content="前端,JavaScript,Node.js"/> <meta itemprop="datePublished" content="2025-11-10T11:54:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冴羽"/> <meta itemprop="url" content="https://juejin.cn/user/712139234359182"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             为什么在 JavaScript 中 NaN !== NaN？背后藏着 40 年的技术故事
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/712139234359182/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冴羽
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:54:37.000Z" title="Mon Nov 10 2025 11:54:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1. 前言</h2>
<p>初学 JavaScript 的时候，经常会遇到一些令人困惑的现象，比如：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> !== <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// true</span>
</code></pre>
<p>为什么一个值会不等于它自己呢？</p>
<p>今天，我们就来深入探究这个问题。</p>
<h2 data-id="heading-1">2. NaN 的本质：一个特殊的“数字”</h2>
<p>NaN 其实是 <code>Not a Number</code> 的缩写，表示它不是一个数字。但 NaN 的类型却是 <code>number</code></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// "number"</span>
</code></pre>
<p>所以你可以把 NaN 理解为一个数字类型的特殊值。</p>
<p>当你尝试将非数字字符串转换为数字，或者进行无效的数学运算时，就会得到 NaN：</p>
<pre><code class="hljs language-javascript" lang="javascript">+<span class="hljs-string">"oops"</span>; <span class="hljs-comment">// NaN</span>
<span class="hljs-number">0</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// NaN</span>
</code></pre>
<p>而当 NaN 出现在数学运算中时，它会导致所有运算结果都是 NaN：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> - <span class="hljs-number">1</span>); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// NaN</span>
</code></pre>
<h2 data-id="heading-2">3. 深入底层：IEEE 754 标准的故事</h2>
<p>要理解 NaN !== NaN 的根源，我们需要回到 1985 年。</p>
<p>当时，IEEE 发布了 <strong>754 号标准</strong>——<a href="https://juejin.cn/post/6844904093601759239#heading-1" target="_blank" title="https://juejin.cn/post/6844904093601759239#heading-1">二进制浮点数算术标准</a>。</p>
<p>这个标准定义了浮点数的表示格式，包括一些特殊值：无穷大（Infinity）、负零（-0）和 NaN。</p>
<p><strong>IEEE 754 标准规定，当指数部分为 0x7FF 而尾数部分非零时，这个值表示 NaN。</strong></p>
<p><strong>更重要的是，标准明确要求 NaN 不等于自身。</strong></p>
<h3 data-id="heading-3">3.1. 为什么会这样设计呢？</h3>
<p>这其实是一种<strong>深思熟虑的设计</strong>，而非错误。主要原因是：</p>
<ol>
<li><strong>提供错误检测机制</strong>：在早期没有 <code>isNaN()</code> 函数的编程环境中，<code>x != x</code>是检测 NaN 的唯一方法</li>
<li><strong>逻辑一致性</strong>：NaN 代表“不是数字”，一个非数值确实不应该等于另一个非数值，这在逻辑上也是通畅的</li>
</ol>
<h3 data-id="heading-4">3.2. 跨语言的一致性</h3>
<p>因此 <code>NaN !== NaN</code> 的行为不仅存在于 JavaScript，而是贯穿所有遵循 IEEE 754 标准的编程语言：</p>
<p><strong>以 Python 为例：</strong></p>
<hr/>
<pre><code class="hljs language-plain" lang="plain">#Python

import math

nan = float('nan')
print(nan != nan)  # True
print(nan == nan)  # False
print(math.isnan(nan))  # True
</code></pre>
<hr/>
<p><strong>以 C++ 为例：</strong></p>
<hr/>
<pre><code class="hljs language-plain" lang="plain">//C++

#include &lt;iostream&gt;
#include &lt;cmath&gt;

int main() {
    double nan = NAN;
    std::cout &lt;&lt; (nan != nan) &lt;&lt; std::endl;  // 1 (true)
    std::cout &lt;&lt; (nan == nan) &lt;&lt; std::endl;  // 0 (false)
    std::cout &lt;&lt; std::isnan(nan) &lt;&lt; std::endl;  // 1 (true, proper way)
    return 0;
}
</code></pre>
<p>以 Rust 为例：</p>
<pre><code class="hljs language-plain" lang="plain">//Rust

fn main() {
    let nan = f64::NAN;
    println!("{}", nan != nan);  // true
    println!("{}", nan == nan);  // false
    println!("{}", nan.is_nan());  // true (proper way)
}
</code></pre>
<h3 data-id="heading-5">3.3. 硬件级别的实现</h3>
<p>有趣的是，NaN 的比较行为不是在 JavaScript 引擎层面实现的，而是<strong>直接由 CPU 硬件提供</strong>的支持。想一想也很合逻辑，我们想要对数字进行运算，CPU 也是在操作数字，所以在 CPU 中进行运算会是最快的!</p>
<p>当我们查看 JavaScript 引擎源码时，会发现它们依赖底层系统的标准库：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Firefox</span>
bool <span class="hljs-built_in">isNaN</span>() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> <span class="hljs-title function_">isDouble</span>() &amp;&amp; <span class="hljs-attr">std</span>::<span class="hljs-title function_">isnan</span>(<span class="hljs-title function_">toDouble</span>()); }

<span class="hljs-comment">// V8</span>
<span class="hljs-keyword">if</span> (<span class="hljs-title class_">IsMinusZero</span>(value)) <span class="hljs-keyword">return</span> <span class="hljs-title function_">has_minus_zero</span>();
<span class="hljs-keyword">if</span> (<span class="hljs-attr">std</span>::<span class="hljs-title function_">isnan</span>(value)) <span class="hljs-keyword">return</span> <span class="hljs-title function_">has_nan</span>();
</code></pre>
<p>那 CPU 是如何识别 NaN 的呢？</p>
<p>以 x86 架构的 CPU 为例，它会用专门的 “浮点寄存器（xmm0）” 处理浮点数运算，还会用一条叫 ucomisd 的指令比较两个浮点数 —— 如果比较的是 NaN，这条指令会设置一个 “奇偶标志位（PF=1）”，相当于给 CPU 发信号：“这是 NaN，不能正常比较！”</p>
<p>简单来说：当你写 NaN === NaN 时，底层 CPU 其实已经判断出 “这两个值特殊”，所以返回 false。</p>
<p>再直观一点，我们可以用 C 语言直接操作硬件寄存器，计算 “0.0/0.0”（这会生成 NaN）：</p>
<pre><code class="hljs language-plain" lang="plain">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int main() {
    double x = 0.0 / 0.0;
    // 直接读取 x 在内存中的二进制位
    uint64_t bits = *(uint64_t*)&amp;x;
    printf("NaN 的十六进制表示：0x%016lx\n", bits);
    return 0;
}
</code></pre>
<p>运行结果会是 <code>0xfff8000000000000</code>—— 这正是 IEEE 754 标准规定的 NaN 存储格式，和 CPU 的处理逻辑完全对应。</p>
<h2 data-id="heading-6">4. JavaScript 不能没有 NaN</h2>
<p>在 IEEE 754 标准之前，各硬件厂商有自己处理无效运算的方式。大多数情况下，像 0/0 这样的操作会直接导致<strong>程序崩溃</strong>。</p>
<p>想象一下，如果没有 NaN：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 我们需要对每个数学运算进行防御性检查</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">safeDivide</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">if</span> (b === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Division by zero!"</span>);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"number"</span> || <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"number"</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Arguments must be numbers!"</span>);
  }
  <span class="hljs-keyword">return</span> a / b;
}

<span class="hljs-comment">// 使用try-catch包围每个可能出错的运算</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">safeDivide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-comment">// 处理错误...</span>
}
</code></pre>
<p>而有了 NaN，代码变得简洁而安全：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a / b; <span class="hljs-comment">// 让硬件处理边界情况</span>
}

<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// Infinity</span>
<span class="hljs-keyword">const</span> invalidResult = <span class="hljs-number">0</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// NaN</span>

<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(invalidResult)) {
  <span class="hljs-comment">// 在合适的地方统一处理错误</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"检测到无效计算"</span>);
}
</code></pre>
<h2 data-id="heading-7">5. 实际开发中如何检测？</h2>
<p>在日常开发中，我们应该如何使用 NaN 呢？</p>
<h3 data-id="heading-8">5.1. 使用 isNaN() 函数（不推荐）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"hello"</span>)); <span class="hljs-comment">// true - 注意：字符串会被先转换为数字</span>
</code></pre>
<p><code>isNaN()</code> 函数会先尝试将参数转换为数字，这可能导致意外的结果。</p>
<h3 data-id="heading-9">5.2. 使用 Number.isNaN()（推荐）</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"hello"</span>)); <span class="hljs-comment">// false - 不会进行类型转换</span>
</code></pre>
<p>ES6 引入的 <code>Number.isNaN()</code> 只会对真正的 NaN 值返回 true，是更安全的选择。</p>
<h3 data-id="heading-10">5.3. 使用 Object.is() 方法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span>
</code></pre>
<p>ES6 的 <code>Object.is()</code> 方法能正确识别 NaN，但它使用严格相等比较，适用于特殊场景。</p>
<h2 data-id="heading-11">6. 总结</h2>
<p>NaN !== NaN 是 JavaScript 中一个看似奇怪但却<strong>设计合理</strong>的特性。它背后是 IEEE 754 标准的深思熟虑，目的是为浮点数运算提供一致且可靠的错误处理机制。</p>
<p>在实际开发中，记住以下几点：</p>
<ol>
<li><strong>始终使用<code>Number.isNaN()</code> 而不是 <code>isNaN()</code> 来检测 NaN 值</strong></li>
<li><strong>含有 NaN 的数学运算总会产生 NaN</strong></li>
<li><strong>利用这一特性**</strong>在代码中优雅地处理错误情况**</li>
<li><strong>记住 NaN 是数字类型的特殊值，这在类型检查时很重要</strong></li>
</ol>
<h2 data-id="heading-12">7. 参考链接</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpiccalil.li%2Fblog%2Fnan-the-not-a-number-number-that-isnt-nan%2F" target="_blank" title="https://piccalil.li/blog/nan-the-not-a-number-number-that-isnt-nan/" ref="nofollow noopener noreferrer">NaN, the not-a-number number that isn’t NaN</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpzarycki.com%2Fen%2Fposts%2Fjs-nan%2F" target="_blank" title="https://pzarycki.com/en/posts/js-nan/" ref="nofollow noopener noreferrer">Why NaN !== NaN in JavaScript (and the IEEE 754 story behind it)</a></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kotlin泛型位置规律与设计考量]]></title>    <link>https://juejin.cn/post/7570902804451409930</link>    <guid>https://juejin.cn/post/7570902804451409930</guid>    <pubDate>2025-11-10T11:56:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902804451409930" data-draft-id="7570932873130770459" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kotlin泛型位置规律与设计考量"/> <meta itemprop="keywords" content="GitHub"/> <meta itemprop="datePublished" content="2025-11-10T11:56:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风冷"/> <meta itemprop="url" content="https://juejin.cn/user/3843548379091742"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kotlin泛型位置规律与设计考量
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3843548379091742/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风冷
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:56:17.000Z" title="Mon Nov 10 2025 11:56:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Kotlin泛型位置规律与设计考量</h2>
<h3 data-id="heading-1">1. 泛型出现的位置分类</h3>
<p>在Kotlin中，泛型可以出现在以下几个主要位置：</p>
<h4 data-id="heading-2">1.1 类声明中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt;(
    <span class="hljs-keyword">val</span> pagerId: String,
    <span class="hljs-keyword">val</span> nativeRef: <span class="hljs-built_in">Int</span>
) {
    <span class="hljs-keyword">val</span> view: T?
        <span class="hljs-keyword">get</span>() = PagerManager.getPager(pagerId)
            .getViewWithNativeRef(nativeRef) <span class="hljs-keyword">as</span>? T
}
</code></pre>
<p><strong>规律</strong>：</p>
<ul>
<li>泛型参数<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;</code>紧跟在类名后面</li>
<li>用于定义整个类的类型参数</li>
<li>可以在类的任何地方使用这个类型参数</li>
</ul>
<p><strong>设计考量</strong>：</p>
<ul>
<li>类型安全：确保ViewRef只能引用特定类型的视图</li>
<li>代码复用：一个类可以处理多种类型，但保持类型安全</li>
<li>API一致性：所有ViewRef实例都有相同的方法签名，但类型不同</li>
</ul>
<h4 data-id="heading-3">1.2 函数声明中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    ref(ViewRef&lt;T&gt;(pagerId, nativeRef))
}
</code></pre>
<p><strong>规律</strong>：</p>
<ul>
<li>泛型参数<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;</code>在fun关键字和函数名之间</li>
<li>用于定义函数的类型参数</li>
<li>可以在函数的参数、返回值和函数体中使用这个类型参数</li>
</ul>
<p><strong>设计考量</strong>：</p>
<ul>
<li>扩展函数：为特定类型的所有子类提供统一方法</li>
<li>类型推断：编译器可以自动推断T的类型</li>
<li>灵活性：同一个函数可以处理多种类型，但保持类型安全</li>
</ul>
<h4 data-id="heading-4">1.3 接口声明中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IViewPublicApi</span>&lt;<span class="hljs-type">A : Attr, E : Event</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">attr</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">A</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">event</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">E</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>
}
</code></pre>
<p><strong>规律</strong>：</p>
<ul>
<li>接口级别的泛型<code>&lt;A : Attr, E : Event&gt;</code>在接口名后</li>
<li>方法级别的泛型<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;</code>在方法名前</li>
</ul>
<p><strong>设计考量</strong>：</p>
<ul>
<li>接口泛型：定义接口的类型参数，影响整个接口</li>
<li>方法泛型：只影响特定方法的类型参数</li>
</ul>
<h3 data-id="heading-5">2. 泛型位置的设计规律</h3>
<h4 data-id="heading-6">2.1 作用域规律</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 类级别泛型：作用域是整个类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt; {
    <span class="hljs-keyword">val</span> view: T? <span class="hljs-comment">// T在整个类中可用</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>: T? { <span class="hljs-keyword">return</span> view } <span class="hljs-comment">// T在方法中可用</span>
}

<span class="hljs-comment">// 函数级别泛型：作用域是整个函数</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">// T只在函数内可用</span>
    ref(ViewRef&lt;T&gt;(pagerId, nativeRef))
}
</code></pre>
<h4 data-id="heading-7">2.2 生命周期规律</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 类泛型：与类实例生命周期相同</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> items = mutableListOf&lt;T&gt;()
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span> { items.add(item) }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T = items[index]
}

<span class="hljs-comment">// 函数泛型：只存在于函数调用期间</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">createList</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> items: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; {
    <span class="hljs-keyword">return</span> listOf(*items) <span class="hljs-comment">// T只在函数执行期间有效</span>
}
</code></pre>
<h3 data-id="heading-8">3. 泛型约束的位置规律</h3>
<h4 data-id="heading-9">3.1 上界约束</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 类泛型约束</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt; { <span class="hljs-comment">// T必须是DeclarativeBaseView的子类</span>
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 函数泛型约束</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(...)</span></span> { <span class="hljs-comment">// T必须是DeclarativeBaseView的子类</span>
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 多重约束</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">process</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span> <span class="hljs-keyword">where</span> T : DeclarativeBaseView&lt;*, *&gt;, T : Cloneable {
    <span class="hljs-comment">// T必须同时满足两个约束</span>
}
</code></pre>
<h4 data-id="heading-10">3.2 型变约束</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 生产者位置（out）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T { ... }
}

<span class="hljs-comment">// 消费者位置（in）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span> { ... }
}

<span class="hljs-comment">// 不变位置</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>: T { ... }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span> { ... }
}
</code></pre>
<h3 data-id="heading-11">4. 泛型在Kotlin中的特殊位置</h3>
<h4 data-id="heading-12">4.1 扩展函数中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 扩展函数泛型：T是接收者类型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">// T既是泛型参数，也是接收者类型</span>
}

<span class="hljs-comment">// 扩展属性中的泛型</span>
<span class="hljs-keyword">val</span> &lt;T : DeclarativeBaseView&lt;*, *&gt;&gt; T.refCount: <span class="hljs-built_in">Int</span>
    <span class="hljs-keyword">get</span>() = <span class="hljs-number">1</span>
</code></pre>
<h4 data-id="heading-13">4.2 高阶函数中的泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 函数类型中的泛型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">execute</span><span class="hljs-params">(operation: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>, param: <span class="hljs-type">T</span>)</span></span> {
    operation(param)
}

<span class="hljs-comment">// 函数类型参数中的泛型</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">// T在函数类型参数中使用</span>
}
</code></pre>
<h4 data-id="heading-14">4.3 泛型型变</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 协变（out）</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Producer</span>&lt;<span class="hljs-type">out T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T
}

<span class="hljs-comment">// 逆变（in）</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>
}

<span class="hljs-comment">// 星投影</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;*&gt;)</span></span> {
    <span class="hljs-comment">// List&lt;*&gt; 表示未知类型的List</span>
}
</code></pre>
<h3 data-id="heading-15">5. 实际项目中的泛型位置选择</h3>
<h4 data-id="heading-16">5.1 类泛型 vs 函数泛型</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 使用类泛型的情况：类型需要在整个类中保持一致</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt; {
    <span class="hljs-keyword">val</span> view: T? <span class="hljs-comment">// 需要在多个地方使用T</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>: T? { <span class="hljs-keyword">return</span> view }
}

<span class="hljs-comment">// 使用函数泛型的情况：类型只在函数中使用</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">// T只在函数内使用</span>
}
</code></pre>
<h4 data-id="heading-17">5.2 多层泛型嵌套</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 多层泛型嵌套</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PagerManager</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; <span class="hljs-title">getView</span><span class="hljs-params">(pagerId: <span class="hljs-type">String</span>, nativeRef: <span class="hljs-type">Int</span>)</span></span>: T? {
        <span class="hljs-keyword">return</span> PagerManager.getPager(pagerId)
            .getViewWithNativeRef(nativeRef) <span class="hljs-keyword">as</span>? T
    }
}

<span class="hljs-comment">// 使用时</span>
<span class="hljs-keyword">val</span> textView: TextView? = PagerManager.getView&lt;TextView&gt;(<span class="hljs-string">"pager1"</span>, <span class="hljs-number">123</span>)
<span class="hljs-keyword">val</span> buttonView: Button? = PagerManager.getView&lt;Button&gt;(<span class="hljs-string">"pager1"</span>, <span class="hljs-number">456</span>)
</code></pre>
<h3 data-id="heading-18">6. 泛型位置的设计原则</h3>
<h4 data-id="heading-19">6.1 最小作用域原则</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 好的设计：泛型作用域最小化</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">process</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: String {
    <span class="hljs-keyword">return</span> item.toString()
}

<span class="hljs-comment">// 避免：不必要的类泛型</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Processor</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">process</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: String {
        <span class="hljs-keyword">return</span> item.toString()
    }
}
</code></pre>
<h4 data-id="heading-20">6.2 类型安全原则</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 好的设计：明确的类型约束</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt; {
    <span class="hljs-comment">// 确保T是DeclarativeBaseView的子类</span>
}

<span class="hljs-comment">// 避免：无约束的泛型</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-comment">// T可以是任何类型，可能导致运行时错误</span>
}
</code></pre>
<h4 data-id="heading-21">6.3 可读性原则</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 好的设计：有意义的泛型参数名</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">TView : DeclarativeBaseView&lt;*, *</span>&gt;&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getView</span><span class="hljs-params">()</span></span>: TView? { ... }
}

<span class="hljs-comment">// 避免：无意义的泛型参数名</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getView</span><span class="hljs-params">()</span></span>: T? { ... }
}
</code></pre>
<h3 data-id="heading-22">7. 总结</h3>
<p>Kotlin中泛型位置的选择遵循以下规律和原则：</p>
<ol>
<li>
<p><strong>作用域决定位置</strong>：</p>
<ul>
<li>类泛型：需要在整个类中使用</li>
<li>函数泛型：只在函数中使用</li>
<li>接口泛型：影响整个接口</li>
</ul>
</li>
<li>
<p><strong>生命周期决定位置</strong>：</p>
<ul>
<li>长生命周期：使用类泛型</li>
<li>短生命周期：使用函数泛型</li>
</ul>
</li>
<li>
<p><strong>类型安全决定约束</strong>：</p>
<ul>
<li>明确约束：使用上界约束</li>
<li>多重约束：使用where子句</li>
</ul>
</li>
<li>
<p><strong>使用场景决定型变</strong>：</p>
<ul>
<li>生产者：使用out</li>
<li>消费者：使用in</li>
<li>读写操作：不变</li>
</ul>
</li>
</ol>
<p>在ViewRef的设计中：</p>
<ul>
<li>类泛型<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;</code>确保类型安全</li>
<li>函数泛型<code>&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt; T.ref(...)</code>提供扩展能力</li>
<li>泛型约束确保只能引用正确的视图类型</li>
<li>泛型位置的选择平衡了灵活性、安全性和可读性</li>
</ul>
<p>这种设计使得ViewRef既类型安全又使用灵活，是Kotlin泛型系统在实际项目中的优秀应用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Agent】生成式隐式记忆 MemGen 源码解读]]></title>    <link>https://juejin.cn/post/7570940025580486696</link>    <guid>https://juejin.cn/post/7570940025580486696</guid>    <pubDate>2025-11-10T11:58:10.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570940025580486696" data-draft-id="7569864390942425139" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Agent】生成式隐式记忆 MemGen 源码解读"/> <meta itemprop="keywords" content="算法,人工智能"/> <meta itemprop="datePublished" content="2025-11-10T11:58:10.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="罗西的思考"/> <meta itemprop="url" content="https://juejin.cn/user/351470467691175"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Agent】生成式隐式记忆 MemGen 源码解读
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/351470467691175/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    罗西的思考
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T11:58:10.000Z" title="Mon Nov 10 2025 11:58:10 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读27分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">【Agent】生成式隐式记忆 MemGen 源码解读</h2>
<p>[toc]</p>
<h3 data-id="heading-1">0x00 概要</h3>
<p>MemGen旨在构建一个动态、生成式的记忆框架，其核心由两个协同工作的轻量级模块构成：一个基于强化学习（RL）训练的记忆触发器（Memory Trigger）和一个记忆编织器（Memory Weaver）。</p>
<p>论文：MemGen: Weaving Generative Latent Memory for Self-Evolving Agents</p>
<p>链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2509.24704" target="_blank" title="https://arxiv.org/abs/2509.24704" ref="nofollow noopener noreferrer">arxiv.org/abs/2509.24…</a></p>
<p>代码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FKANABOON1%2FMemGen" target="_blank" title="https://github.com/KANABOON1/MemGen" ref="nofollow noopener noreferrer">github.com/KANABOON1/M…</a></p>
<h3 data-id="heading-2">0x01 背景</h3>
<p>MemGen 提出动态生成式记忆框架，由记忆触发器与记忆编织器两个轻量模块协同构成，旨在突破现有智能体记忆范式的局限。</p>
<p>当前主流的记忆实现路径为：</p>
<ul>
<li>参数化记忆通过微调将经验编码进模型参数，虽能深度内化知识却易引发灾难性遗忘；</li>
<li>基于检索的记忆将经验外化存储，虽规避了遗忘问题，但静态的一次性检索机制无法体现记忆与推理动态交互的认知特性。</li>
</ul>
<p>这一现状引出两大核心问题：如何实现记忆与推理在每一步思考中的无缝耦合，以及如何让记忆从提取式升级为满足当前需求的生成式重构，而动态生成式隐式记忆正是应对这些挑战的第三种探索路径。</p>
<h3 data-id="heading-3">0x02 源码解析</h3>
<p>MemGen项目旨在创建一个动态且自生成的记忆框架，该框架由两个协同工作的轻量级模块组成：一个基于强化学习训练的记忆触发器和一个记忆编织器。这一框架的核心思想是解决大型语言模型（LLM）智能体能力涌现时对“自进化”机制的探索需求，其中记忆扮演关键角色。</p>
<h4 data-id="heading-4">2.1 模型</h4>
<p>LatentMemoryModel 是 MemGen 框架的核心实现，旨在构建动态生成式隐式记忆系统，解决传统记忆范式的局限性。通过整合推理器（Reasoner）、记忆编织器（Weaver）和记忆触发器（Trigger），实现记忆与推理过程的无缝耦合，让智能体在任务执行中动态生成、使用记忆，而非依赖静态检索或参数化存储。</p>
<h5 data-id="heading-5">2.1.1  核心特色</h5>
<p>模型的核心特色如下：</p>
<ul>
<li><strong>模块化协同设计</strong>：由推理器（核心推理）、编织器（生成潜在记忆）、触发器（控制记忆触发）三大模块构成，模块间通过投影层实现嵌入空间映射，结构清晰且解耦。</li>
<li><strong>动态记忆增强</strong>：在推理过程中自动识别分隔符位置作为记忆增强点，动态插入编织器生成的潜在记忆，突破静态记忆注入的局限，贴合人类认知中记忆与推理的动态交互特性。</li>
<li><strong>精度与效率优化</strong>：默认使用 bfloat16 精度，推理器采用 Flash Attention 2 提升计算效率；冻结推理器参数，仅训练编织器和触发器，实现参数高效学习。</li>
<li><strong>灵活配置与兼容性</strong>：支持自定义触发器模型、PEFT 微调配置、记忆增强次数等参数；自动处理 Tokenizer 缺失 pad token 的问题，标准化对话模板，提升跨场景兼容性。</li>
<li><strong>损失计算精准过滤</strong>：通过潜在记忆掩码排除记忆嵌入对应的位置，仅对原始输入位置计算损失，确保训练目标聚焦于核心任务性能，避免记忆生成过程干扰主任务学习。</li>
</ul>
<h5 data-id="heading-6">2.1.2  网络结构</h5>
<p>关键说明（核心设计亮点）</p>
<ol>
<li><strong>三大模块协同逻辑</strong>：
<ul>
<li>推理器（Reasoner）：核心推理组件，权重冻结以保留基础能力，仅通过潜在记忆调整解码路径。</li>
<li>触发器（MemGenTrigger）：动态判断记忆插入时机，输出二分类触发概率，决定是否调用编织器。</li>
<li>编织器（MemGenWeaver）：生成针对性潜在记忆，分提示词 / 推理两阶段设计，支持 PEFT 高效微调。</li>
</ul>
</li>
<li><strong>核心流程闭环</strong>：输入 → 推理器生成原始嵌入 → 触发器 + 增强点选择模块确定插入位置 → 编织器生成潜在记忆 → 投影层适配维度 → 重组增强序列 → 推理器完成最终推理 → 过滤无效位置输出。</li>
<li><strong>关键技术细节</strong>：
<ul>
<li>跨模块投影：通过 <code>reasoner_to_weaver</code> 和 <code>weaver_to_reasoner</code> 解决推理器与编织器嵌入维度不匹配问题。</li>
<li>动态记忆增强：按分隔符拆分序列，逐段插入记忆，避免长序列冗余，贴合人类 “思考 - 记忆” 交互模式。</li>
<li>精度与效率：全流程采用 bfloat16 精度，推理器 / 编织器启用 Flash Attention 2，平衡性能与速度。</li>
</ul>
</li>
<li><strong>训练与推理适配</strong>：
<ul>
<li>训练时：通过 <code>labels</code> 和 <code>valid_logits</code> 计算损失，仅优化编织器、触发器及投影层参数。</li>
<li>推理时：无需 <code>labels</code>，自动完成 “触发判断 - 记忆生成 - 推理增强” 全流程，实现动态自进化。</li>
</ul>
</li>
</ol>
<p>具体网络结构如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fedf1bee4f404d00b60b5ade066b5dd0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763380690&amp;x-signature=udJwW4ZcYOdkSaA%2FuS5q7k6%2FUAc%3D" alt="MemGen-1.png" loading="lazy"/></p>
<h5 data-id="heading-7">2.1.3 代码</h5>
<p>LatentMemoryModel 的代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@registry.register_model(<span class="hljs-params"><span class="hljs-string">"latmem"</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LatentMemoryModel</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):  <span class="hljs-comment"># 定义了一个名为 LatentMemoryModel 的类，继承自 BaseModel</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">
        self, 
        reasoner_model_name: <span class="hljs-built_in">str</span>,  <span class="hljs-comment"># 推理模型名称</span>
        weaver_model_name: <span class="hljs-built_in">str</span>,  <span class="hljs-comment"># 记忆编织器模型名称</span>
        prompt_latents_len: <span class="hljs-built_in">int</span>,  <span class="hljs-comment"># 提示长度</span>
        inference_latents_len: <span class="hljs-built_in">int</span>,  <span class="hljs-comment"># 推理长度</span>
        weaver_peft_config: <span class="hljs-type">Optional</span>[PeftConfig] = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 记忆编织器配置，可选</span>
        trigger_model_name: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 触发模型名称，可选</span>
        trigger_peft_config: <span class="hljs-type">Optional</span>[PeftConfig] = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 触发器配置，可选</span>
        max_prompt_aug_num: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>,  <span class="hljs-comment"># 最大提示增强数量</span>
        max_inference_aug_num: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span>,  <span class="hljs-comment"># 最大推理增强数量</span>
    </span>):   
        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 调用父类构造函数</span>

        <span class="hljs-comment"># 构建推理模型</span>
        self.model = AutoModelForCausalLM.from_pretrained(  <span class="hljs-comment"># 从预训练模型加载推理模型</span>
            reasoner_model_name, torch_dtype=torch.bfloat16, attn_implementation=<span class="hljs-string">"flash_attention_2"</span>)
        self.tokenizer = AutoTokenizer.from_pretrained(reasoner_model_name)  <span class="hljs-comment"># 加载入分词器</span>
        self.config = self.model.config  <span class="hljs-comment"># 获取模型配置</span>
        
        <span class="hljs-comment"># 构建记忆编织器</span>
        self.weaver = MemGenWeaver(  <span class="hljs-comment"># 初始化记忆编织器</span>
            weaver_model_name, prompt_latents_len, inference_latents_len, weaver_peft_config
        )
        
        <span class="hljs-comment"># 构建触发器</span>
        self.trigger = NanoTrigger()  <span class="hljs-comment"># 默认触发器，始终返回 true</span>
        <span class="hljs-keyword">if</span> trigger_model_name <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.trigger = MemGenTrigger(  <span class="hljs-comment"># 如果指定了触发模型，则加载相应的触发器</span>
                trigger_model_name, trigger_peft_config
            )
            logging.info(<span class="hljs-string">f"Use Trigger: <span class="hljs-subst">{trigger_model_name}</span>"</span>)  <span class="hljs-comment"># 记录日志</span>
        
        <span class="hljs-comment"># 投影层，用于在推理模型和记忆编织器之间映射嵌入</span>
        <span class="hljs-comment"># 将推理模型输入嵌入映射到记忆编织器输入嵌入</span>
        self.reasoner_to_weaver = nn.Linear(  <span class="hljs-comment"># 线性层，从推理模型隐藏层到记忆编织器隐藏层</span>
            self.model.config.hidden_size, self.weaver.config.hidden_size, dtype=torch.bfloat16
        )
        <span class="hljs-comment"># 将记忆编织器隐藏状态映射回推理模型输入嵌入</span>
        self.weaver_to_reasoner = nn.Linear(  <span class="hljs-comment"># 线性层，从记忆编织器隐藏层到推理模型隐藏层</span>
            self.weaver.config.hidden_size, self.model.config.hidden_size, dtype=torch.bfloat16
        )
        
        self.delimiters: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = [<span class="hljs-string">","</span>, <span class="hljs-string">"."</span>, <span class="hljs-string">"\n"</span>]  <span class="hljs-comment"># 用于检测增强点的分隔符</span>
        self.max_prompt_aug_num = max_prompt_aug_num  <span class="hljs-comment"># 提示后提示中插入潜在数量</span>
        self.max_inference_aug_num = max_inference_aug_num  <span class="hljs-comment"># 指定分隔符后插入潜在数量</span>

        <span class="hljs-comment"># 后处理</span>
        self._postprocess_models()  <span class="hljs-comment"># 后处理模型</span>

        self.warnings_issued = {}  <span class="hljs-comment"># 存储发出的警告</span>
        self.model_tags = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 存储模型标签</span>
        log_trainable_params(self)  <span class="hljs-comment"># 记录可训练参数</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_model_tags</span>(<span class="hljs-params">self, tags: <span class="hljs-type">Union</span>[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], <span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 添加模型标签</span>
        <span class="hljs-string">r"""
        向模型添加自定义标签，这些标签将被推送到 Hugging Face Hub。不会覆盖模型中现有的标签。

        参数：
            tags (`Union[list[str], str]`)：
                要添加到模型的标签

        例子：

        ```python
        from transformers import AutoModel

        model = AutoModel.from_pretrained("google-bert/bert-base-cased")

        model.add_model_tags(["custom", "custom-bert"])

        # 将模型推送到您的命名空间，名称为 "my-custom-bert"。
        model.push_to_hub("my-custom-bert")
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(tags, <span class="hljs-built_in">str</span>):
            tags = [tags]

        <span class="hljs-keyword">if</span> self.model_tags <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            self.model_tags = []

        <span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> tags:
            <span class="hljs-keyword">if</span> tag <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.model_tags:
                self.model_tags.append(tag)
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_postprocess_models</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""
        后处理记忆模型的组件：推理模型、记忆编织器、触发器和分词器。

        步骤：
            1. 冻结推理模型的所有参数（不更新梯度）。
            2. 将所有模型转换为 bfloat16 以提高内存和计算效率。
            3. 确保分词器有一个有效的填充符：
                - 如果缺少填充符，使用 EOS 符作为填充符。
                - 设置 `padding_side` 为 "left" 以兼容生成任务。
            4. 标准化分词器的模板为 `CONVERSATION_TEMPLATE`。
        """</span>
        <span class="hljs-comment"># 默认冻结推理模型的所有参数</span>
        fix_model_parameters(self.model)

        <span class="hljs-comment"># 将所有子模型转换为 bfloat16</span>
        self.model = self.model.bfloat16()
        self.weaver = self.weaver.bfloat16()
        self.trigger = self.trigger.bfloat16()

        <span class="hljs-comment"># 确保分词器有一个填充符</span>
        <span class="hljs-keyword">if</span> self.tokenizer.pad_token <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            self.tokenizer.pad_token = self.tokenizer.eos_token
            self.tokenizer.pad_token_id = self.tokenizer.eos_token_id
            self.tokenizer.padding_side = <span class="hljs-string">"left"</span>
            logging.info(
                <span class="hljs-string">f"Tokenizer has no pad token. Using EOS token (<span class="hljs-subst">{self.tokenizer.eos_token}</span>) as pad token."</span>
            )

        <span class="hljs-comment"># 标准化分词器的模板</span>
        self.tokenizer.chat_template = CONVERSATION_TEMPLATE
</code></pre>
<h5 data-id="heading-8">2.1.4 插入阶段</h5>
<p>LatentMemoryModel 的两个关键函数 forward 和  generate 区别如下：</p>
<ul>
<li>forward 函数
<ul>
<li>训练时候计算损失，由训练循环自动调用。</li>
</ul>
</li>
<li>generate 函数
<ul>
<li>推理时候生成文本，由代码显式调用。</li>
</ul>
</li>
</ul>
<h6 data-id="heading-9">forward</h6>
<p>forward 函数的主体如下：</p>
<pre><code class="hljs language-python" lang="python">    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_forward</span>(<span class="hljs-params">
        self, 
        input_ids: torch.Tensor,
        attention_mask: torch.Tensor,
        labels: torch.Tensor,   
        **kwargs
    </span>) -&gt; torch.Tensor:
        <span class="hljs-comment"># 预处理输入</span>
        <span class="hljs-keyword">assert</span> input_ids.shape == attention_mask.shape == labels.shape
        
        tokenizer = self.tokenizer
        reasoner = self.model
        weaver = self.weaver
        delimiters = self.delimiters
        max_augment_num = self.max_inference_aug_num  <span class="hljs-comment"># 限制推理增强点的数量以避免过度增强</span>
        device = self.device
        embeds_dtype = reasoner.get_input_embeddings().weight.dtype
        B, _ = input_ids.shape
        hidden_size = reasoner.config.hidden_size

        <span class="hljs-comment"># 选择增强索引</span>
        augmentation_indices = self._select_augment_points_after_delimiter(
            input_ids, labels, delimiters, tokenizer, max_augment_num
        )
        
        <span class="hljs-comment"># 输入嵌入</span>
        inputs_embeds = reasoner.get_input_embeddings()(input_ids)
                 
        <span class="hljs-comment"># 初始化开始索引和空张量以累积处理的段</span>
        current_start_idx = <span class="hljs-number">0</span>
        current_inputs_embeds = torch.empty(B, <span class="hljs-number">0</span>, hidden_size).to(device, dtype=embeds_dtype)
        current_attention_mask = torch.empty(B, <span class="hljs-number">0</span>).to(device, dtype=attention_mask.dtype)
        current_latents_mask = torch.empty(B, <span class="hljs-number">0</span>).to(device, dtype=torch.<span class="hljs-built_in">bool</span>)

        <span class="hljs-comment"># 遍历所选增强点</span>
        <span class="hljs-keyword">for</span> aug_idx <span class="hljs-keyword">in</span> augmentation_indices:
            <span class="hljs-comment"># 切片原始嵌入和注意力掩码</span>
            segment_inputs_embeds = inputs_embeds[:, current_start:aug_idx]
            segment_attention_mask = attention_mask[:, current_start:aug_idx]
            segment_latents_mask = torch.zeros(B, segment_inputs_embeds.size(<span class="hljs-number">1</span>).to(device, dtype=torch.<span class="hljs-built_in">bool</span>)

            <span class="hljs-comment"># 连接当前段到累积嵌入和掩码</span>
            current_inputs_embeds = torch.cat([current_inputs_embeds, segment_inputs_embeds], dim=<span class="hljs-number">1</span>)
            current_mask = torch.cat([current_mask, segment_attention_mask], dim=<span class="hljs-number">1</span>)
            current_position_ids = generate_position_ids(current_mask)
            current_latents = torch.cat([current_latents, segment_latents], dim=<span class="hljs-number">1</span>)

            <span class="hljs-comment"># 将推理模型嵌入映射到记忆编织器嵌入</span>
            weaver_inputs_embeds = self.reasoner_to_weaver(current_inputs_embeds)

            <span class="hljs-comment"># 确定此点是否为提示（增强）的结束</span>
            is_prompt_end_aug = (labels[:, aug_idx] != -<span class="hljs-number">100</span>).<span class="hljs-built_in">all</span>() <span class="hljs-keyword">and</span> (labels[:, aug_idx-<span class="hljs-number">1</span>] == -<span class="hljs-number">100</span>).<span class="hljs-built_in">all</span>().item()
            <span class="hljs-comment"># 根据类型，使用记忆编织器增强提示或推理</span>
            <span class="hljs-keyword">if</span> is_prompt_end_aug:
                weaver_hidden_states, attn_mask, pos_ids = weaver.augment_prompt(
                    weaver_inputs, current_attention_mask, current_position_ids
                )
            <span class="hljs-keyword">else</span>:
                weaver_hidden_states, attn_mask, pos_ids = weaver.augment_inference(
                    weaver_inputs, current_attention_mask, current_position_ids
                ) 

            <span class="hljs-comment"># 将记忆编织器隐藏状态映射回推理模型嵌入</span>
            latent_inputs_embeds = self.weaver_to_reasoner(weaver_hidden_states)

            <span class="hljs-comment"># 更新累积嵌入和掩码与新增强段</span>
            current_inputs_embeds = torch.cat
</code></pre>
<h6 data-id="heading-10">generate</h6>
<h6 data-id="heading-11">核心作用</h6>
<p>该 <code>generate</code> 方法是 MemGen 模型的推理核心，实现了<strong>动态记忆增强与序列生成的无缝融合</strong>。通过迭代生成新 token，每步自适应判断是否插入编织器生成的潜在记忆，让推理器在生成过程中实时利用动态记忆调整解码路径，最终输出增强后的序列（可选返回记忆增强位置掩码）。</p>
<h6 data-id="heading-12">核心特色</h6>
<ul>
<li><strong>双阶段记忆增强</strong>：先执行提示词阶段记忆增强（初始化全局记忆），再在迭代生成中动态触发推理阶段增强（补充实时记忆），适配不同生成阶段的记忆需求。</li>
<li><strong>自适应触发机制</strong>：通过 <code>_should_augment</code> 结合触发器决策，仅对需要记忆支持的序列执行增强，避免无意义的计算开销。</li>
<li><strong>维度对齐优化</strong>：非增强序列采用左填充（<code>_left_pad</code>）方式对齐增强序列维度，确保批次内所有序列格式统一，不影响批量生成效率。</li>
<li>高效推理设计：
<ul>
<li>禁用梯度计算（<code>@torch.no_grad()</code>），节省内存并加速推理；</li>
<li>启用推理器缓存（<code>use_cache=True</code>），减少重复计算；</li>
<li>仅在必要时输出隐藏状态，降低计算成本。</li>
</ul>
</li>
<li><strong>灵活配置与可解释性</strong>：支持控制最大生成 token 数、采样策略等参数；可选返回 <code>augmentation_pos</code> 掩码，标记记忆插入位置，提升模型可解释性。</li>
<li><strong>鲁棒性保障</strong>：提前终止机制（所有序列生成 EOS 或达最大增强次数时终止），避免无效迭代；重构生成配置固定关键参数，确保生成稳定性。</li>
</ul>
<h6 data-id="heading-13">推理生成流程图</h6>
<p>潜在记忆插入的完整流程：</p>
<ul>
<li>初始化阶段：对输入提示进行增强，插入初始潜在记忆。</li>
<li>生成循环：逐个生成token。</li>
<li>条件检查：在每个步骤检查是否满足插入条件。</li>
<li>决策判断：使用trigger模型决定是否插入潜在记忆。</li>
<li>潜在记忆生成：通过weaver模型生成潜在记忆表示。</li>
<li>嵌入连接：将潜在记忆嵌入连接到当前输入序列。</li>
<li>继续生成：使用增强后的序列继续生成下一个token。</li>
</ul>
<p>具体流程如下图所示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51a1177007e14bdd916d4e2ea501c2c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763380690&amp;x-signature=aylwPhRKpttlymB%2BFRIe5TqKJmg%3D" alt="MemGen-2.png" loading="lazy"/></p>
<p>代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@torch.no_grad()  </span><span class="hljs-comment"># 禁用梯度计算，适用于推理阶段，提升效率并节省内存</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">
    self, 
    input_ids: torch.Tensor,  <span class="hljs-comment"># 输入token ID序列，形状[batch_size, prompt_len]</span>
    attention_mask: torch.Tensor,  <span class="hljs-comment"># 注意力掩码，形状与input_ids一致</span>
    generation_config: GenerationConfig = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 生成配置（如最大新token数、采样策略等）</span>
    return_augmentation_mask: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,  <span class="hljs-comment"># 是否返回记忆增强位置掩码</span>
    **kwargs
</span>) -&gt; <span class="hljs-type">Union</span>[torch.Tensor, <span class="hljs-type">Tuple</span>[torch.Tensor, torch.Tensor]]: 
    <span class="hljs-string">"""
    执行MemGen模型的推理生成流程：动态融合潜在记忆与推理器，生成增强后的输出序列。
    
    核心逻辑：
    1. 初始化提示词阶段的记忆增强
    2. 迭代生成新token，每步判断是否触发推理阶段记忆增强
    3. 对需增强的序列插入编织器生成的潜在记忆，非增强序列左填充对齐维度
    4. 生成完成后返回结果（可选返回增强位置掩码）
    """</span>
    tokenizer = self.tokenizer
    reasoner = self.model
    weaver = self.weaver
    trigger = self.trigger
    delimiters = self.delimiters
    max_augment_num = self.max_inference_aug_num  <span class="hljs-comment"># 单序列最大推理阶段增强次数</span>
    invalid_token_id = -<span class="hljs-number">100</span>  <span class="hljs-comment"># 无效位置标记（用于增强位置掩码）</span>

    <span class="hljs-comment"># 预处理输入：转移到模型所在设备</span>
    input_ids = input_ids.to(self.device)
    attention_mask = attention_mask.to(self.device)
    <span class="hljs-comment"># 提取生成配置关键参数</span>
    max_new_tokens = generation_config.max_new_tokens  <span class="hljs-comment"># 最大生成新token数</span>
    do_sample = generation_config.do_sample  <span class="hljs-comment"># 是否启用采样生成</span>
    temperature = generation_config.temperature  <span class="hljs-comment"># 采样温度（控制随机性）</span>
    pad_token_id = tokenizer.pad_token_id  <span class="hljs-comment"># pad token ID</span>
    eos_token_id = tokenizer.eos_token_id  <span class="hljs-comment"># 结束token ID</span>
    prompt_len = input_ids.size(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 提示词长度</span>
    <span class="hljs-comment"># 重构生成配置（固定必要参数，确保生成稳定性）</span>
    generation_config = GenerationConfig(
        do_sample=do_sample,
        temperature=temperature,
        pad_token_id=pad_token_id,
        eos_token_id=eos_token_id,
        use_cache=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 启用缓存加速生成</span>
    )

    <span class="hljs-comment"># 将输入token ID转换为嵌入向量</span>
    inputs_embeds = reasoner.get_input_embeddings()(input_ids)
    B, _, hidden_size = inputs_embeds.shape  <span class="hljs-comment"># B=batch_size，hidden_size=推理器隐藏层维度</span>
    device = inputs_embeds.device  <span class="hljs-comment"># 模型所在设备（CPU/GPU）</span>

    <span class="hljs-comment"># 初始化生成过程中的关键张量</span>
    current_inputs_embeds = inputs_embeds  <span class="hljs-comment"># 当前输入嵌入（含原始提示词+潜在记忆）</span>
    current_attention_mask = attention_mask  <span class="hljs-comment"># 当前注意力掩码</span>
    current_position_ids = generate_position_ids(current_attention_mask)  <span class="hljs-comment"># 当前位置ID</span>
    current_input_ids = input_ids  <span class="hljs-comment"># 当前已生成的token ID序列</span>
    
    <span class="hljs-comment"># 提示词阶段记忆增强：生成并插入提示词专用潜在记忆</span>
    weaver_inputs_embeds = self.reasoner_to_weaver(current_inputs_embeds)  <span class="hljs-comment"># 映射到编织器嵌入空间</span>
    weaver_hidden_states, attn_mask, pos_ids = weaver.augment_prompt(
        weaver_inputs_embeds, current_attention_mask, current_position_ids
    )
    latent_inputs_embeds = self.weaver_to_reasoner(weaver_hidden_states)  <span class="hljs-comment"># 映射回推理器嵌入空间</span>

    <span class="hljs-comment"># 拼接提示词与增强记忆</span>
    current_inputs_embeds = torch.cat([current_inputs_embeds, latent_inputs_embeds], dim=<span class="hljs-number">1</span>)
    current_attention_mask = torch.cat([current_attention_mask, attn_mask], dim=<span class="hljs-number">1</span>)
    current_position_ids = torch.cat([current_position_ids, pos_ids], dim=<span class="hljs-number">1</span>)

    <span class="hljs-comment"># 生成循环初始化</span>
    sentence_augment_count = torch.zeros(B, dtype=torch.<span class="hljs-built_in">int</span>, device=device)  <span class="hljs-comment"># 各序列已增强次数</span>
    augmentation_pos = torch.full((B, max_new_tokens), fill_value=invalid_token_id, device=device)  <span class="hljs-comment"># 增强位置掩码</span>
    inserted_embeds: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[torch.Tensor]] = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(B)]  <span class="hljs-comment"># 记录插入的潜在记忆（用于后处理）</span>
    
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_new_tokens):
        <span class="hljs-comment"># 若所有序列均已生成EOS token，提前终止</span>
        <span class="hljs-keyword">if</span> (current_input_ids[:, -<span class="hljs-number">1</span>] == eos_token_id).<span class="hljs-built_in">all</span>():
            <span class="hljs-keyword">break</span>   

        <span class="hljs-comment"># 若所有序列均已达到最大增强次数，一次性生成剩余token</span>
        <span class="hljs-keyword">if</span> (sentence_augment_count &gt;= max_augment_num).<span class="hljs-built_in">all</span>():
            <span class="hljs-comment"># 调整剩余生成长度</span>
            generation_config.max_new_tokens = max_new_tokens - i
            <span class="hljs-comment"># 推理器生成剩余token</span>
            generated = reasoner.generate(
                inputs_embeds=current_inputs_embeds,
                attention_mask=current_attention_mask,
                generation_config=generation_config,
            )
            current_input_ids = torch.cat([current_input_ids, generated], dim=<span class="hljs-number">1</span>)
            <span class="hljs-keyword">break</span>

        <span class="hljs-comment"># 推理器前向传播，获取当前步输出</span>
        outputs = reasoner(
            inputs_embeds=current_inputs_embeds,
            attention_mask=current_attention_mask,
            position_ids=current_position_ids,
            output_hidden_states=<span class="hljs-literal">False</span>,  <span class="hljs-comment"># 推理阶段无需输出隐藏状态，提升效率</span>
        )
        <span class="hljs-comment"># 生成并追加一个新token，更新关键张量</span>
        current_inputs_embeds, current_attention_mask, current_position_ids, current_input_ids = self._append_one_step(
            outputs, current_inputs_embeds, current_attention_mask, current_position_ids, current_input_ids, do_sample, temperature
        )
 
        <span class="hljs-comment"># 若为最后一步生成，终止循环</span>
        <span class="hljs-keyword">if</span> i == max_new_tokens - <span class="hljs-number">1</span>:  
            <span class="hljs-keyword">break</span> 

        <span class="hljs-comment"># 判断当前批次中哪些序列需要进行推理阶段记忆增强</span>
        augment_decision = self._should_augment(
            current_input_ids, current_attention_mask, sentence_augment_count=sentence_augment_count, 
            do_sample=do_sample, temperature=temperature  
        )
        augmentation_pos[:, i + <span class="hljs-number">1</span>] = augment_decision  <span class="hljs-comment"># 记录增强位置（1=增强，0=不增强，-100=无效）</span>
        augment_indices = torch.where(augment_decision == <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 需增强的序列索引</span>

        <span class="hljs-comment"># 对需增强的序列执行记忆增强，非增强序列左填充对齐维度</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(augment_indices) &gt; <span class="hljs-number">0</span>:
            <span class="hljs-comment"># 递增需增强序列的增强次数计数</span>
            sentence_augment_count[augment_indices] += <span class="hljs-number">1</span>

            <span class="hljs-comment"># 提取需增强序列的嵌入、掩码和位置ID</span>
            candidate_inputs_embeds = current_inputs_embeds[augment_indices]
            candidate_attention_mask = current_attention_mask[augment_indices]
            candidate_position_ids = current_position_ids[augment_indices]
            
            <span class="hljs-comment"># 编织器生成推理阶段潜在记忆</span>
            weaver_inputs_embeds = self.reasoner_to_weaver(candidate_inputs_embeds)
            weaver_hidden_states, attn_mask, _ = weaver.augment_inference(
                weaver_inputs_embeds, candidate_attention_mask, candidate_position_ids
            )
            latent_inputs_embeds = self.weaver_to_reasoner(weaver_hidden_states)  <span class="hljs-comment"># 映射回推理器空间</span>
            
            <span class="hljs-comment"># 拼接原始嵌入与潜在记忆</span>
            candidate_inputs_embeds = torch.cat([candidate_inputs_embeds, latent_inputs_embeds], dim=<span class="hljs-number">1</span>)
            candidate_attention_mask = torch.cat([candidate_attention_mask, attn_mask], dim=<span class="hljs-number">1</span>)
            
            <span class="hljs-comment"># 构建合并张量（适配所有序列，包括增强和非增强）</span>
            new_len = candidate_inputs_embeds.size(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 增强后序列长度</span>
            merged_inputs_embeds = torch.zeros((B, new_len, hidden_size), device=device, dtype=current_inputs_embeds.dtype)
            merged_attention_mask = torch.zeros((B, new_len), device=device, dtype=current_attention_mask.dtype)
            
            <span class="hljs-comment"># 填充增强序列</span>
            merged_inputs_embeds[augment_indices] = candidate_inputs_embeds
            merged_attention_mask[augment_indices] = candidate_attention_mask
            
            <span class="hljs-comment"># 填充非增强序列（左填充对齐长度）</span>
            non_augment_indices = torch.where(augment_decision != <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(non_augment_indices) &gt; <span class="hljs-number">0</span>:
                non_aug_inputs_embeds = current_inputs_embeds[non_augment_indices]
                non_aug_attention_mask = current_attention_mask[non_augment_indices]
                non_aug_inputs_embeds, non_aug_attention_mask, _ = self._left_pad(
                    non_aug_inputs_embeds, non_aug_attention_mask, <span class="hljs-literal">None</span>, weaver.inference_latents_num
                )
                merged_inputs_embeds[non_augment_indices] = non_aug_inputs_embeds
                merged_attention_mask[non_augment_indices] = non_aug_attention_mask
            
            <span class="hljs-comment"># 更新当前关键张量</span>
            current_inputs_embeds = merged_inputs_embeds
            current_attention_mask = merged_attention_mask
            current_position_ids = generate_position_ids(current_attention_mask)  <span class="hljs-comment"># 重新生成位置ID</span>
            
            <span class="hljs-comment"># 记录插入的潜在记忆（用于后处理或可解释性分析）</span>
            <span class="hljs-keyword">for</span> idx, embed <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(augment_indices, latent_inputs_embeds):
                inserted_embeds[idx].append(embed.clone().detach().cpu())
        
        <span class="hljs-comment"># 后处理：调整增强位置掩码长度与生成结果一致</span>
        new_generated_len = current_input_ids.size(<span class="hljs-number">1</span>) - prompt_len
        augmentation_pos = augmentation_pos[:, :new_generated_len]
         
        <span class="hljs-comment"># 根据配置返回结果：仅生成序列 或 序列+增强位置掩码</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> return_augmentation_mask:
            <span class="hljs-keyword">return</span> current_input_ids
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> current_input_ids, augmentation_pos
</code></pre>
<h4 data-id="heading-14">2.2 Trigger</h4>
<h5 data-id="heading-15">2.2.1. 核心作用</h5>
<p>该模块定义了 MemGen 框架中记忆触发器的核心接口与两种具体实现，核心作用是<strong>动态决策记忆增强的时机</strong>—— 即在推理过程中判断何时插入编织器生成的潜在记忆，实现记忆与推理的动态耦合，突破传统静态记忆注入的局限。</p>
<h5 data-id="heading-16">2.2.2. 核心特色</h5>
<ul>
<li><strong>抽象接口统一规范</strong>：<code>Trigger</code>抽象基类定义了触发器的核心接口，确保后续扩展新触发器时遵循统一标准，提升代码可扩展性。</li>
<li>双实现适配不同场景：
<ul>
<li><code>NanoTrigger</code>：极简实现，始终触发记忆增强，无需训练，适用于快速测试、基线对比或无需动态控制的简单场景。</li>
<li><code>MemGenTrigger</code>：基于预训练 LLM 的智能触发器，通过二分类头适配决策任务，支持 PEFT 参数高效微调，能根据输入序列动态判断是否触发，适配复杂真实场景。</li>
</ul>
</li>
<li>高效适配与灵活扩展：
<ul>
<li>采用 bfloat16 精度和 Flash Attention 2 优化计算效率；</li>
<li>支持 PEFT 微调，在不冻结基础模型的前提下实现参数高效学习；</li>
<li>替换 LLM 原始输出头为二分类头，精准适配 "是否插入记忆" 的决策需求。</li>
</ul>
</li>
<li><strong>模块解耦设计</strong>：触发器决策独立于编织器模块，仅基于输入序列和数据分布做出判断，保证了模块间的低耦合和高内聚。</li>
</ul>
<h5 data-id="heading-17">2.2.3 网络架构</h5>
<p>网络架构图如下。</p>
<p>说明如下：</p>
<ol>
<li>模型支持PEFT参数高效微调（如LoRA），适配于Transformer Blocks层</li>
<li>整体精度采用bfloat16，平衡计算效率与数值稳定性</li>
<li>注意力计算通过Flash Attention 2优化，提升长序列处理速度</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34dd418dca1746b69160336bafae5e6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763380690&amp;x-signature=Av9etmryf2cwP7Mw6AaiNNc%2FzO4%3D" alt="MemGen-3.png" loading="lazy"/></p>
<h5 data-id="heading-18">2.2.4 代码</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trigger</span>(torch.nn.Module, ABC):
    <span class="hljs-string">"""
    记忆触发器的抽象基类（Trigger）。
    定义了触发器的核心接口，用于决定在推理过程中何时触发记忆增强（插入潜在记忆）。
    所有具体触发器实现都需继承此类并实现forward方法。
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 调用父类Module的初始化方法</span>
    
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, **kwargs</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">"""
        抽象前向传播方法：接收输入数据，返回是否触发记忆增强的决策。
        子类必须实现此方法，定义具体的触发逻辑。
        
        Args:
            **kwargs: 可变关键字参数，包含输入序列、注意力掩码等模型所需数据
            
        Returns:
            bool: 触发决策（True表示触发记忆增强，False表示不触发）
        """</span>
        ...


<span class="hljs-keyword">class</span> <span class="hljs-title class_">NanoTrigger</span>(torch.nn.Module):
    <span class="hljs-string">"""
    极简触发器（NanoTrigger）：始终触发记忆增强的基础实现。
    无需复杂逻辑，固定返回触发决策，适用于基础测试或无需动态控制的场景。
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()  
        <span class="hljs-comment"># 注册一个缓冲区张量，用于获取模型所在设备（无实际计算意义）</span>
        self.register_buffer(<span class="hljs-string">"_device"</span>, torch.tensor(<span class="hljs-number">0.0</span>))
    
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">device</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""获取模型所在设备（CPU/GPU）"""</span>
        <span class="hljs-keyword">return</span> self._device.device
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, input_ids: torch.Tensor, attention_mask: torch.Tensor, **kwargs</span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-comment"># 该"极简触发器"始终预测需要插入记忆</span>
        <span class="hljs-comment"># 输出logits张量，其中插入决策（索引=1）的概率被设为1.0</span>
        <span class="hljs-comment"># 适用于批次中的每个token位置</span>
        batch_size, seq_len = input_ids.shape

        <span class="hljs-comment"># 初始化logits张量：形状为[batch_size, seq_len, 2]，2表示"不插入"（0）和"插入"（1）两类</span>
        logits = torch.zeros(batch_size, seq_len, <span class="hljs-number">2</span>, device=input_ids.device)
        logits[..., <span class="hljs-number">1</span>] = <span class="hljs-number">1.0</span>  <span class="hljs-comment"># 将所有位置的"插入"决策概率设为1.0</span>
        <span class="hljs-keyword">return</span> logits


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MemGenTrigger</span>(torch.nn.Module):
    <span class="hljs-string">"""
    MemGen框架的专用触发器模块（MemGenTrigger）。
    - 输入：接收推理器模型当前解码序列的`inputs_embeds`（或input_ids）
    - 输出：生成形状为[batch_size, seq_len, 2]的logits张量，
      表示每个位置"不插入"（0）和"插入"（1）记忆的概率，用于动态决策记忆增强时机。
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">
        self, 
        pretrained_model_name_or_path: <span class="hljs-built_in">str</span>,  <span class="hljs-comment"># 预训练模型名称或路径（用于初始化触发器LLM）</span>
        peft_config: <span class="hljs-type">Optional</span>[PeftConfig] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># PEFT配置（可选，用于参数高效微调）</span>
    </span>):
        <span class="hljs-built_in">super</span>().__init__()
        
        <span class="hljs-comment"># 构建基础LLM模型（作为触发器的核心推理组件）</span>
        self.model = AutoModelForCausalLM.from_pretrained(
            pretrained_model_name_or_path, 
            torch_dtype=torch.bfloat16,  <span class="hljs-comment"># 使用bfloat16精度提升效率</span>
            attn_implementation=<span class="hljs-string">"flash_attention_2"</span>  <span class="hljs-comment"># 启用Flash Attention 2优化注意力计算</span>
        )
        self.tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path)  <span class="hljs-comment"># 对应的Tokenizer</span>
        
        <span class="hljs-comment"># 对基础模型进行后处理（设置可训练、替换输出头）</span>
        self.model = self._postprocess(self.model)
        <span class="hljs-comment"># 若提供PEFT配置，应用参数高效微调</span>
        <span class="hljs-keyword">if</span> peft_config <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.model = get_peft_model(self.model, peft_config)
        
        self.config = self.model.config  <span class="hljs-comment"># 保存模型配置</span>

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">device</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""获取模型所在设备（CPU/GPU）"""</span>
        <span class="hljs-keyword">return</span> self.model.device
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_postprocess</span>(<span class="hljs-params">self, model: PreTrainedModel</span>):
        <span class="hljs-string">"""
        对基础模型进行后处理，适配触发器的二分类任务需求。
        
        Args:
            model: 原始预训练LLM模型
            
        Returns:
            处理后的模型（可训练、替换为二分类输出头）
        """</span>
        <span class="hljs-comment"># 设置所有模型参数为可训练</span>
        <span class="hljs-keyword">for</span> parameter <span class="hljs-keyword">in</span> model.parameters():
            parameter.requires_grad = <span class="hljs-literal">True</span>
        
        <span class="hljs-comment"># 将原始语言模型的输出头（lm_head）替换为二分类头</span>
        hidden_size = model.config.hidden_size  <span class="hljs-comment"># 模型隐藏层维度</span>
        classification_head = nn.Linear(hidden_size, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 输出维度为2（不插入/插入）</span>
        model.lm_head = classification_head
        
        <span class="hljs-comment"># 确保新的二分类头参数可训练</span>
        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.lm_head.parameters():
            param.requires_grad = <span class="hljs-literal">True</span>

        <span class="hljs-keyword">return</span> model

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">
        self, 
        input_ids: <span class="hljs-type">Optional</span>[torch.LongTensor] = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 生成序列的token ID，形状[batch_size, seq_len]</span>
        attention_mask: <span class="hljs-type">Optional</span>[torch.Tensor] = <span class="hljs-literal">None</span>,  <span class="hljs-comment"># 注意力掩码，避免关注填充token</span>
        **kwargs: Unpack[TransformersKwargs],  <span class="hljs-comment"># 传递给底层模型的额外参数</span>
    </span>) -&gt; torch.Tensor:
        <span class="hljs-string">"""
        序列生成的触发决策机制。
        触发器基于已生成的`input_ids`做出决策，受数据分布影响，但独立于编织器模块。

        Args:
            input_ids (Optional[torch.LongTensor]): 生成序列的token ID张量
            attention_mask (Optional[torch.Tensor]): 注意力掩码，默认None
            **kwargs: 传递给底层模型的额外关键字参数

        Returns:
            torch.Tensor: Logits张量，形状为`(batch_size, seq_len, num_classes)`
                        num_classes=2，分别对应"不插入"（索引0）和"插入"（索引1）的概率
        """</span>   
        <span class="hljs-comment"># 调用基础模型前向传播，返回二分类logits</span>
        <span class="hljs-keyword">return</span> self.model(
            input_ids=input_ids, 
            attention_mask=attention_mask, 
            **kwargs
        ).logits
</code></pre>
<h4 data-id="heading-19">2.3  MemGenWeaver</h4>
<h5 data-id="heading-20">2.3.1 核心作用</h5>
<p>MemGenWeaver 是 MemGen 框架的核心组件之一，负责生成动态潜在记忆并将其与推理器的输入序列融合，从而实现记忆与推理过程的无缝交织。它通过可学习的潜在记忆查询向量，在提示词阶段和推理阶段分别生成针对性的记忆表示，引导推理器调整解码路径，提升智能体的动态决策能力。</p>
<h5 data-id="heading-21">2.3.2 核心特色</h5>
<ul>
<li>双阶段记忆生成：区分提示词阶段（<code>augment_prompt</code>）和推理阶段（<code>augment_inference</code>），使用各自独立的可学习潜在记忆查询向量，适配不同阶段的记忆需求，增强记忆生成的针对性。</li>
<li>灵活的潜在记忆融合：通过<code>_augment</code>方法统一实现潜在记忆与输入序列的融合，包括嵌入拼接、注意力掩码扩展和位置 ID 计算，确保记忆与原始输入在语义空间和时序上的一致性。</li>
<li>高效的模型设计：
<ul>
<li>基于预训练 LLM 构建，支持 PEFT 参数高效微调，在保留基础能力的同时降低训练成本；</li>
<li>采用 bfloat16 精度和 Flash Attention 2 优化，提升计算效率和内存利用率。</li>
</ul>
</li>
<li>动态记忆编织机制：生成的潜在记忆并非静态检索结果，而是基于当前输入序列动态生成的隐藏状态，能够捕捉实时上下文信息，实现 “生成式记忆” 的核心特性。</li>
<li>模块化与可扩展性：与推理器、触发器解耦，通过标准化接口交互；潜在记忆的数量可通过参数灵活配置，适配不同任务对记忆容量的需求。</li>
</ul>
<h5 data-id="heading-22">2.3.3 网络架构</h5>
<p>网络架构图如下。</p>
<p>说明如下：</p>
<ol>
<li>
<p>核心组件：</p>
<ul>
<li>可学习潜在记忆向量：分阶段设计（P=提示词阶段数量，I=推理阶段数量），支持动态生成记忆</li>
<li>预训练LLM：作为记忆生成核心，默认启用bfloat16精度和Flash Attention 2优化</li>
<li>序列融合层：确保输入与记忆在语义、掩码、时序上的一致性</li>
</ul>
</li>
<li>
<p>核心流程：</p>
<ul>
<li>输入 → 选择对应阶段的潜在记忆 → 融合序列 → LLM生成隐藏状态 → 提取潜在记忆输出</li>
<li>支持PEFT参数高效微调（如LoRA），适配于Transformer Blocks层</li>
</ul>
</li>
<li>
<p>输出用途：</p>
<ul>
<li>生成的潜在记忆将通过投影层映射到推理器的嵌入空间，与原始输入融合以引导解码</li>
</ul>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/171332decb0c4154ba66ca9f7de013db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg572X6KW_55qE5oCd6ICD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763380690&amp;x-signature=MkDfTVSJzZAmLMpyyKdipXchpbw%3D" alt="MemGen-4.png" loading="lazy"/></p>
<h5 data-id="heading-23">2.3.4 代码</h5>
<p>两个关键变量如下：</p>
<ul>
<li>prompt_query_latents。
<ul>
<li>作用：增强模型在处理prompt时候的表现。 在模型处理完原始提示之后会被注入到序列中，为模型提供额外的上下文信息。</li>
<li>使用场景：在 augment_prompt 方法中使用，在生成阶段的开始阶段使用一次。</li>
</ul>
</li>
<li>inference_query_latents。
<ul>
<li>作用：在生成过程中动态增强模型的推理能力。可以在生成过程中的多个点被注入，以提供实时上下文增强。</li>
<li>使用场景：在 augment_inference 方法中使用，在生成阶段中多次被使用。通常在遇到特定分隔符（逗号，句号等）后触发插入。</li>
</ul>
</li>
</ul>
<p>这两个变量都通过_augment 方法获得（获取学习到的潜在向量，并将其附加到输入嵌入中）。其流程如下：</p>
<ul>
<li>将潜在变量附加到当前输入嵌入序列的末尾。</li>
<li>更新注意力掩码和位置ID，以考虑新增的潜在向量。</li>
<li>将增强后的序列通过Weaver模型处理。</li>
<li>提供于潜在向量位置对应的隐状态作为增强表示。</li>
</ul>
<p>判断是否插入是通过函数 _should_augment 完成的。</p>
<ul>
<li>检查当前生成的文本是否是特殊字符（逗号等）</li>
<li>使用触发模型（trigger model）进一步判断是否应该增强。</li>
<li>考虑最大增强次数限制。</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemGenWeaver</span>(torch.nn.Module):
    <span class="hljs-string">"""
    MemGen模型的编织器模块（MemGenWeaver）。
    - 输入：接收接收来自推理器模型当前当前解码序列的`inputs_embeds`（输入嵌入入）
    - 输出：生成长度为K的隐藏状态序列，
这些状态将与原始`inputs_embeds`拼接，以改变推理器的解码路径
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">
        self, 
        pretrained_model_name_or_path: <span class="hljs-built_in">str</span>,  <span class="hljs-comment"># 预训练模型的名称或路径</span>
        prompt_latents_num: <span class="hljs-built_in">int</span>,    <span class="hljs-comment"># 提示词阶段生成的潜在记忆数量</span>
        inference_latents_num: <span class="hljs-built_in">int</span>, <span class="hljs-comment"># 推理阶段生成的潜在记忆数量</span>
        peft_config: <span class="hljs-type">Optional</span>[PeftConfig] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># PEFT配置（可选）</span>
    </span>):
        <span class="hljs-built_in">super</span>().__init__()
        
        <span class="hljs-comment"># 基础模型初始化</span>
        self.model = AutoModelForCausalLM.from_pretrained(
            pretrained_model_name_or_path,
            torch_dtype=torch.bfloat16,  <span class="hljs-comment"># 使用bfloat16精度以提高效率</span>
            attn_implementation=<span class="hljs-string">"flash_attention_2"</span>  <span class="hljs-comment"># 启用Flash Attentionention 2优化</span>
        )
        self.tokenizer = AutoTokenizer.from_pretrained(pretrained_model_name_or_path)  <span class="hljs-comment"># 对应的分词器</span>
        <span class="hljs-comment"># 若提供PEFT配置，则应用参数高效微调</span>
        <span class="hljs-keyword">if</span> peft_config <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            self.model = get_peft_model(self.model, peft_config)
        
        self.config = self.model.config  <span class="hljs-comment"># 保存模型配置</span>
        
        <span class="hljs-comment"># 提示词阶段的潜在记忆查询向量（可学习参数）</span>
        self.prompt_query_latents = nn.Parameter(
            torch.randn(prompt_latents_num, self.config.hidden_size),  <span class="hljs-comment"># 形状：[prompt_latents_num, hidden_size]</span>
            requires_grad=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 允许反向传播更新</span>
        )

        <span class="hljs-comment"># 推理阶段的潜在记忆查询向量（可学习参数）</span>
        self.inference_query_latents = nn.Parameter(
            torch.randn(inference_latents_num, self.config.hidden_size),  <span class="hljs-comment"># 形状：[inference_latents_num, hidden_size]</span>
            requires_grad=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 允许反向传播更新</span>
        )
    
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prompt_latents_num</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-string">"""返回提示词阶段的潜在记忆数量"""</span>
        <span class="hljs-keyword">return</span> self.prompt_query_latents.size(<span class="hljs-number">0</span>)

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inference_latents_num</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-string">"""返回推理阶段的潜在记忆数量"""</span>
        <span class="hljs-keyword">return</span> self.inference_query_latents.size(<span class="hljs-number">0</span>)

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">device</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""返回模型所在的设备（CPU/GPU）"""</span>
        <span class="hljs-keyword">return</span> self.model.device

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_augment</span>(<span class="hljs-params">
        self, 
        latents: torch.Tensor,                <span class="hljs-comment"># 潜在记忆查询向量，形状：[latents_num, hidden_size]</span>
        inputs_embeds: torch.Tensor,          <span class="hljs-comment"># 输入嵌入，形状：[batch_size, seq_len, hidden_size]</span>
        attention_mask: torch.Tensor,         <span class="hljs-comment"># 注意力掩码，形状：[batch_size, seq_len]</span>
        position_ids: torch.Tensor            <span class="hljs-comment"># 位置ID，形状：[batch_size, seq_len]</span>
    </span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor, torch.Tensor, torch.Tensor]:
        <span class="hljs-string">"""
        通用的潜在记忆增强方法：将潜在记忆与输入序列融合，生成增强后的隐藏状态。
        
        参数：
            latents: 潜在记忆查询向量
            inputs_embeds: 输入序列的嵌入表示
            attention_mask: 输入序列的注意力掩码
            position_ids: 输入序列的位置ID
        
        返回：
            三元组 (latents_hidden_states, latents_mask, latents_position_ids)
            - latents_hidden_states: 生成的潜在记忆隐藏状态，形状：[batch_size, latents_num, hidden_size]
            - latents_mask: 潜在记忆的注意力掩码，形状：[batch_size, latents_num]
            - latents_position_ids: 潜在记忆的位置ID，形状：[batch_size, latents_num]
        """</span>
        batch_size = attention_mask.shape[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取批次大小</span>
        latents_num = latents.size(<span class="hljs-number">0</span>)         <span class="hljs-comment"># 获取潜在记忆数量</span>
        
        <span class="hljs-comment"># 扩展潜在记忆维度以匹配批次大小：[1, latents_num, hidden_size] → [batch_size, latents_num, hidden_size]</span>
        latents = latents.unsqueeze(<span class="hljs-number">0</span>).repeat(batch_size, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
        
        <span class="hljs-comment"># 将潜在记忆嵌入与输入嵌入拼接：[batch_size, seq_len + latents_num, hidden_size]</span>
        inputs_embeds = torch.cat([inputs_embeds, latents], dim=<span class="hljs-number">1</span>)

        <span class="hljs-comment"># 构建潜在记忆的注意力掩码（全为1，表示有效）并与输入掩码拼接</span>
        latents_mask = torch.ones(latents.shape[:-<span class="hljs-number">1</span>], dtype=attention_mask.dtype, device=attention_mask.device)
        attention_mask = torch.cat([attention_mask, latents_mask], dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 形状：[batch_size, seq_len + latents_num]</span>
        
        <span class="hljs-comment"># 生成潜在记忆的位置ID（在输入序列最后位置的基础上递增）</span>
        last_position_ids = position_ids.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取输入序列的最大位置ID</span>
        latents_relative_positions = torch.arange(latents_num, device=attention_mask.device)  <span class="hljs-comment"># 潜在记忆的相对位置</span>
        <span class="hljs-comment"># 计算绝对位置：输入序列最大位置 + 相对位置 + 1（避免重叠）</span>
        latents_position_ids = last_position_ids.unsqueeze(<span class="hljs-number">1</span>) + latents_relative_positions + <span class="hljs-number">1</span>
        <span class="hljs-comment"># 拼接位置ID：[batch_size, seq_len + latents_num]</span>
        position_ids = torch.cat([position_ids.long(), latents_position_ids.long()], dim=<span class="hljs-number">1</span>) 

        <span class="hljs-comment"># 验证拼接后的维度是否一致</span>
        <span class="hljs-keyword">assert</span> inputs_embeds.shape[:<span class="hljs-number">2</span>] == attention_mask.shape == position_ids.shape

        <span class="hljs-comment"># 模型前向传播，获取隐藏状态</span>
        outputs = self.model(
            inputs_embeds=inputs_embeds,
            attention_mask=attention_mask,
            position_ids=position_ids,  
            output_hidden_states=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 输出所有层的隐藏状态</span>
        )
        <span class="hljs-comment"># 取最后一层的隐藏状态，并提取潜在记忆部分（序列末尾的latents_num个位置）</span>
        hidden_states = outputs.hidden_states[-<span class="hljs-number">1</span>]
        latents_hidden_states = hidden_states[:, -latents_num:, :]

        <span class="hljs-keyword">return</span> latents_hidden_states, latents_mask, latents_position_ids

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">augment_prompt</span>(<span class="hljs-params">
        self, 
        inputs_embeds: torch.Tensor, 
        attention_mask: torch.Tensor, 
        position_ids: torch.Tensor
    </span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor, torch.Tensor, torch.Tensor]:
        <span class="hljs-string">"""
        提示词阶段的潜在记忆增强：使用提示词专用的潜在记忆查询向量。
        
        参数与返回值同_augment方法
        """</span>
        <span class="hljs-keyword">return</span> self._augment(
            latents=self.prompt_query_latents,
            inputs_embeds=inputs_embeds,
            attention_mask=attention_mask,
            position_ids=position_ids
        )


    <span class="hljs-keyword">def</span> <span class="hljs-title function_">augment_inference</span>(<span class="hljs-params">
        self, 
        inputs_embeds: torch.Tensor, 
        attention_mask: torch.Tensor, 
        position_ids: torch.Tensor
    </span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor, torch.Tensor, torch.Tensor]:
        <span class="hljs-string">"""
        推理阶段的潜在记忆增强：使用推理专用的潜在记忆查询向量。
        
        参数与返回值同_augment方法
        """</span>
        <span class="hljs-keyword">return</span> self._augment(
            latents=self.inference_query_latents,
            inputs_embeds=inputs_embeds,
            attention_mask=attention_mask,
            position_ids=position_ids
        )
</code></pre>
<h3 data-id="heading-24">0xFF 参考</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FpqCPoUw0p2oTsnMUj9t2mw" target="_blank" title="https://mp.weixin.qq.com/s/pqCPoUw0p2oTsnMUj9t2mw" ref="nofollow noopener noreferrer">最新成果！Agent记忆的第三种可能：生成式隐式记忆</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring AI 实战——评估生成结果]]></title>    <link>https://juejin.cn/post/7570901172526858275</link>    <guid>https://juejin.cn/post/7570901172526858275</guid>    <pubDate>2025-11-10T09:40:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570901172526858275" data-draft-id="7570866247980187700" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring AI 实战——评估生成结果"/> <meta itemprop="keywords" content="Spring,AI编程,LLM"/> <meta itemprop="datePublished" content="2025-11-10T09:40:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="数据智能老司机"/> <meta itemprop="url" content="https://juejin.cn/user/430664289626439"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring AI 实战——评估生成结果
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/430664289626439/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    数据智能老司机
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:40:14.000Z" title="Mon Nov 10 2025 09:40:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">本章内容</h2>
<ul>
<li>初识 Spring AI 的评估器（evaluators）</li>
<li>检查相关性（relevancy）</li>
<li>判断回答的正确性（correctness）</li>
<li>在运行时应用评估器</li>
</ul>
<p>为你的代码编写测试是一种重要实践。自动化测试不仅能确保应用没有被破坏，还能提供有助于设计与实现的反馈。对应用中的<strong>生成式 AI 组件</strong>进行测试，丝毫不比其他部分的测试不重要。</p>
<p>只有一个问题：如果你把相同的提示多次发送给一个 LLM，你很可能每次都会得到不同的答案。生成式 AI 的<strong>非确定性</strong>意味着测试中无法采用“断言相等（assert equals）”的套路。</p>
<p>在第 1 章里，你看到如何使用 <strong>WireMock</strong> 来模拟 API 的响应，从而在测试中获得<strong>确定性的</strong>结果。这种测试方式非常适合测试“围绕向生成式 AI API 发起请求”的代码，但它并不能测试<strong>提示本身</strong>以及模型如何对该提示作出响应。幸运的是，Spring AI 提供了另一种判断“生成响应是否可接受”的方式：<strong>评估器（Evaluators）</strong> 。</p>
<p>一个<strong>评估器</strong>会拿到提交给 LLM 的提示中的用户文本，以及模型返回的内容，然后据此判断这份响应内容是否通过某些准则。从内部机制看，评估器可以用任何适合其评估类型的方式实现。但如图 2.1 所示，评估器通常会**借助一个 LLM（通过 ChatClient）**来判断生成的响应与所提交提示之间的契合度。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f81731ace774ceb9bf9b4be09adc02b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763372413&amp;x-signature=y30vXdbCZqbHl%2FEgAco4CH6BmiA%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 2.1</strong> Spring AI 评估器把提示与生成的响应一并发送给 LLM，以评估响应质量。</p>
<p>接下来我们看看如何使用评估器，为 <strong>BoardGameService</strong>（Board Game Buddy 应用中使用生成式 AI 的那个组件）编写一份<strong>集成测试</strong>。</p>
<h2 data-id="heading-1">2.1 确保答案相关（Ensuring relevant answers）</h2>
<p>最基础的评估形式，就是判断 LLM 是否回答了<strong>所提的问题</strong>。也就是：生成的响应<strong>至少与提示同一话题</strong>吗？</p>
<p>例如，用户问 “Why is the sky blue?”，LLM 回答 “Because of Rayleigh scattering”（或类似回答），那么这个答案是<strong>相关的</strong>。反之，若 LLM 回答 “The moon is approximately 239,900 miles from Earth.”，尽管它可能是正确事实，但<strong>与天空为何是蓝色</strong>这一问题<strong>不相关</strong>。</p>
<p>判断答案是否与给定问题相关，正是 Spring AI 的 <strong>RelevancyEvaluator</strong> 要做的事。为了理解它如何工作，让我们用它来为 <strong>BoardGameService</strong> 写一个测试。下面的清单展示了该测试类。</p>
<p><strong>清单 2.1 测试 LLM 的响应是否与问题相关</strong></p>
<pre><code class="hljs language-typescript" lang="typescript">package com.<span class="hljs-property">example</span>.<span class="hljs-property">boardgamebuddy</span>;

<span class="hljs-keyword">import</span> org.<span class="hljs-property">assertj</span>.<span class="hljs-property">core</span>.<span class="hljs-property">api</span>.<span class="hljs-property">Assertions</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">junit</span>.<span class="hljs-property">jupiter</span>.<span class="hljs-property">api</span>.<span class="hljs-property">BeforeEach</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">junit</span>.<span class="hljs-property">jupiter</span>.<span class="hljs-property">api</span>.<span class="hljs-property">Test</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">chat</span>.<span class="hljs-property">client</span>.<span class="hljs-property">ChatClient</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">chat</span>.<span class="hljs-property">evaluation</span>.<span class="hljs-property">RelevancyEvaluator</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">evaluation</span>.<span class="hljs-property">EvaluationRequest</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">ai</span>.<span class="hljs-property">evaluation</span>.<span class="hljs-property">EvaluationResponse</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Autowired</span>;
<span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">test</span>.<span class="hljs-property">context</span>.<span class="hljs-property">SpringBootTest</span>;

<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameServiceTests</span> {

  <span class="hljs-meta">@Autowired</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title class_">BoardGameService</span> boardGameService;

  <span class="hljs-meta">@Autowired</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title class_">ChatClient</span>.<span class="hljs-property">Builder</span> chatClientBuilder;

  <span class="hljs-keyword">private</span> <span class="hljs-title class_">RelevancyEvaluator</span> relevancyEvaluator;

  <span class="hljs-meta">@BeforeEach</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">relevancyEvaluator</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RelevancyEvaluator</span>(chatClientBuilder);
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">evaluateRelevancy</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">String</span> userText = <span class="hljs-string">"Why is the sky blue?"</span>;
    <span class="hljs-title class_">Question</span> question = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Question</span>(userText);
    <span class="hljs-title class_">Answer</span> answer = boardGameService.<span class="hljs-title function_">askQuestion</span>(question);

    <span class="hljs-title class_">EvaluationRequest</span> evaluationRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvaluationRequest</span>(
        userText, answer.<span class="hljs-title function_">answer</span>());

    <span class="hljs-title class_">EvaluationResponse</span> response = relevancyEvaluator
        .evaluate(evaluationRequest);

    <span class="hljs-title class_">Assertions</span>.<span class="hljs-title function_">assertThat</span>(response.<span class="hljs-title function_">isPass</span>())
        .<span class="hljs-title function_">withFailMessage</span>(<span class="hljs-string">""</span><span class="hljs-string">"
          ========================================
          The answer "</span>%s<span class="hljs-string">"
          is not considered relevant to the question
          "</span>%s<span class="hljs-string">".
          ========================================
          "</span><span class="hljs-string">""</span>, answer.<span class="hljs-title function_">answer</span>(), userText)
        .<span class="hljs-title function_">isTrue</span>();
  }

}
</code></pre>
<p>阅读 <code>SpringAiBoardGameServiceTests</code> 可以看到，测试前几行在做<strong>评估所需的准备</strong>。类上标注了 <code>@SpringBootTest</code>，表明这是<strong>集成测试</strong>：会创建一个 Spring 应用上下文（包含应用中的所有 bean）。从该上下文中，通过 <code>@Autowired</code> 注入了 <code>BoardGameService</code> 与 <code>ChatClient.Builder</code>。随后在 <code>setup()</code> 方法里，用 <code>ChatClient.Builder</code> 创建了一个 <code>RelevancyEvaluator</code>，以供测试方法使用。</p>
<p><code>evaluateRelevancy()</code> 测试方法首先创建一个 <code>Question</code>，并将其发送给注入的 <code>BoardGameService#askQuestion()</code> 来获得 <code>Answer</code>。接着用原始用户文本与答案创建 <code>EvaluationRequest</code>，传给 <code>RelevancyEvaluator#evaluate()</code>。其内部会向 LLM 发送一个提示，要求它判断<strong>答案与问题的相关性</strong>。</p>
<p><code>evaluate()</code> 返回 <code>EvaluationResponse</code>，随后调用 <code>isPass()</code> 判断评估是否通过。若返回 <code>true</code>，说明答案被认为与问题相关；否则返回 <code>false</code>，表示不相关，断言失败。</p>
<p>有了这个测试，你就能<strong>快速、自动</strong>检查：通过 <code>SpringAiBoardGameService#askQuestion()</code> 提出的一个问题是否得到<strong>契合话题</strong>的回答。当然，<strong>相关</strong>并不等于<strong>正确</strong>。我们再把测试提升一档，检查答案是否<strong>正确</strong>。</p>
<h2 data-id="heading-2">2.2 测试事实正确性（Testing for factual accuracy）</h2>
<p>假设当被问到“天空为什么是蓝色”时，LLM 回答：“The sky is blue because there are a gazillion tiny bubbles filled with blueberry jam floating in the atmosphere.”（天空之所以蓝，是因为大气中漂浮着无数装满蓝莓酱的小气泡。）这个回答看起来<strong>相关</strong>，但显然<strong>不正确</strong>。它也许能“躲过” <code>RelevancyEvaluator</code> 的法眼，但并不适合直接展示给你的用户。</p>
<p>Spring AI 的 <strong>FactCheckingEvaluator</strong> 与 <code>RelevancyEvaluator</code> 类似，但它不是让 LLM 判断<strong>相关性</strong>，而是让 LLM 判断这个回答是否<strong>正确地回答</strong>了问题。</p>
<p>在把事实正确性测试加进 <code>SpringAiBoardGameServiceTests</code> 之前，需要稍微调整一下 <code>setup()</code> 方法，创建一个 <code>FactCheckingEvaluator</code> 并赋给实例变量：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">private</span> <span class="hljs-title class_">FactCheckingEvaluator</span> factCheckingEvaluator;

  <span class="hljs-meta">@BeforeEach</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">relevancyEvaluator</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RelevancyEvaluator</span>(chatClientBuilder);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">factCheckingEvaluator</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactCheckingEvaluator</span>(
        chatClientBuilder);
  }
</code></pre>
<p>现在编写事实核查测试方法：</p>
<pre><code class="hljs language-ini" lang="ini">@Test
  public void evaluateFactualAccuracy() {
    var <span class="hljs-attr">userText</span> = <span class="hljs-string">"Why is the sky blue?"</span><span class="hljs-comment">;</span>
    var <span class="hljs-attr">question</span> = new Question(userText)<span class="hljs-comment">;</span>
    var <span class="hljs-attr">answer</span> = boardGameService.askQuestion(question)<span class="hljs-comment">;</span>

    var <span class="hljs-attr">evaluationRequest</span> =
            new EvaluationRequest(userText, answer.answer())<span class="hljs-comment">;</span>

    var <span class="hljs-attr">response</span> =
            factCheckingEvaluator.evaluate(evaluationRequest)<span class="hljs-comment">;</span>

    Assertions.assertThat(response.isPass())
        .withFailMessage("<span class="hljs-attr">""</span>

          ========================================
          The answer "%s"
          is not considered correct for the question
          "%s".
          ========================================
          """, answer.answer(), userText)
        .isTrue()<span class="hljs-comment">;</span>
  }
</code></pre>
<p><code>evaluateFactualAccuracy()</code> 与之前的 <code>evaluateRelevancy()</code> 很相似。与相关性测试一样，仍然通过 <code>EvaluationResponse#isPass()</code> 进行断言：若生成的答案被判定为<strong>不正确</strong>，断言就会失败。</p>
<p>当 <code>isPass()</code> 返回 <code>false</code> 导致断言失败时，失败信息会解释原因。举例来说，如果生成的答案是 “There are tiny bubbles filled with blueberry jam high in the atmosphere.”，那么 <code>FactCheckingEvaluator</code> 会判定该回答<strong>不正确</strong>，断言失败，输出的失败信息可能如下：</p>
<pre><code class="hljs language-csharp" lang="csharp">========================================
The answer <span class="hljs-string">"The sky is blue because there are a gazillion tiny bubbles filled
with blueberry jam floating in the atmosphere."</span>
<span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> considered correct <span class="hljs-keyword">for</span> the question
<span class="hljs-string">"Why is the sky blue?"</span>.
========================================
</code></pre>
<p>在通读本书的过程中，你会对<strong>发送给 LLM 的提示</strong>做出许多改动。借助 <code>evaluateRelevancy()</code> 与 <code>evaluateFactualAccuracy()</code> 这样的测试，你可以确保：<strong>无论提示如何调整</strong>，依然能获得<strong>恰当且正确</strong>的回答。</p>
<p>即便如此，还有一点可能不那么显而易见：你也许会希望在<strong>测试之外（运行时）<strong>使用评估器，以确保实际运行中返回给用户的回答同样</strong>相关</strong>且<strong>正确</strong>。接下来我们看看如何在应用代码中<strong>直接应用评估器</strong>。</p>
<h2 data-id="heading-3">2.3 在运行时应用自评估（Applying self-evaluation at runtime）</h2>
<p>即使在构建应用时基于评估器的测试全部通过，<strong>运行时</strong>仍可能出现<strong>不相关</strong>或<strong>不正确</strong>的回答。生成式 AI 的<strong>非确定性</strong>意味着：测试阶段也许“运气不错”拿到了好回答，但到生产环境时情况却可能“跑偏”。在运行时应用评估器，可以帮助避免把糟糕答案返回给应用用户。</p>
<p>事实证明，评估器并<strong>不限于</strong>用于集成测试。下面的清单展示了如何把 <strong>RelevancyEvaluator</strong> 与 <strong>Spring Retry</strong> 结合，避免返回与用户问题<strong>不相关</strong>的答案。</p>
<p><strong>清单 2.2 在运行时代码中校验相关性（Verifying relevancy in runtime code）</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.evaluation.RelevancyEvaluator;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.prompt.ChatOptions;
<span class="hljs-keyword">import</span> org.springframework.ai.evaluation.EvaluationRequest;
<span class="hljs-keyword">import</span> org.springframework.ai.evaluation.EvaluationResponse;
<span class="hljs-keyword">import</span> org.springframework.retry.annotation.Recover;
<span class="hljs-keyword">import</span> org.springframework.retry.annotation.Retryable;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfEvaluatingBoardGameService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BoardGameService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RelevancyEvaluator evaluator;

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SelfEvaluatingBoardGameService</span><span class="hljs-params">(ChatClient.Builder chatClientBuilder)</span> {
    <span class="hljs-type">var</span> <span class="hljs-variable">chatOptions</span> <span class="hljs-operator">=</span> ChatOptions.builder()
        .model(<span class="hljs-string">"gpt-4o-mini"</span>)
        .build();

    <span class="hljs-built_in">this</span>.chatClient = chatClientBuilder
        .defaultOptions(chatOptions)
        .build();

    <span class="hljs-built_in">this</span>.evaluator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RelevancyEvaluator</span>(chatClientBuilder);
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-meta">@Retryable(retryFor = AnswerNotRelevantException.class)</span>
  <span class="hljs-keyword">public</span> Answer <span class="hljs-title function_">askQuestion</span><span class="hljs-params">(Question question)</span> {
    <span class="hljs-type">var</span> <span class="hljs-variable">answerText</span> <span class="hljs-operator">=</span> chatClient.prompt()
        .user(question.question())
        .call()
        .content();

    evaluateRelevancy(question, answerText);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Answer</span>(answerText);
  }

  <span class="hljs-meta">@Recover</span>
  <span class="hljs-keyword">public</span> Answer <span class="hljs-title function_">recover</span><span class="hljs-params">(AnswerNotRelevantException e)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Answer</span>(<span class="hljs-string">"I'm sorry, I wasn't able to answer the question."</span>);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">evaluateRelevancy</span><span class="hljs-params">(Question question, String answerText)</span> {
    <span class="hljs-type">var</span> <span class="hljs-variable">evaluationRequest</span> <span class="hljs-operator">=</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvaluationRequest</span>(question.question(), answerText);
    <span class="hljs-type">var</span> <span class="hljs-variable">evaluationResponse</span> <span class="hljs-operator">=</span> evaluator.evaluate(evaluationRequest);
    <span class="hljs-keyword">if</span> (!evaluationResponse.isPass()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnswerNotRelevantException</span>(question.question(), answerText);
    }
  }

}
</code></pre>
<p><code>SelfEvaluatingBoardGameService</code> 与 <code>SpringAiBoardGameService</code> 很相似，只是 <code>askQuestion()</code> 方法上添加了 <code>@Retryable</code> 注解。这个来自 <strong>Spring Retry</strong> 的注解表示：如果该方法抛出了 <code>AnswerNotRelevantException</code>，则<strong>重试</strong>该方法。</p>
<p>在 <code>askQuestion()</code> 中，会调用 <code>evaluateRelevancy()</code> 来进行相关性评估。<code>evaluateRelevancy()</code> 使用构造器里创建的 <code>RelevancyEvaluator</code>。若 <code>isPass()</code> 返回 <code>false</code>，<code>evaluateRelevancy()</code> 会抛出 <code>AnswerNotRelevantException</code>，该异常向外传播至 <code>askQuestion()</code>，从而触发重试。</p>
<p>至于 <code>AnswerNotRelevantException</code>，它是一个简单的<strong>非受检</strong>异常，类似如下：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnswerNotRelevantException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>{
    public <span class="hljs-type">AnswerNotRelevantException</span>(<span class="hljs-type">String</span> question, <span class="hljs-type">String</span> answer) {
        <span class="hljs-keyword">super</span>(<span class="hljs-string">"The answer '"</span> + answer + <span class="hljs-string">"' is not relevant to the question '"</span> + question + <span class="hljs-string">"'."</span>);
    }
}
</code></pre>
<p>默认情况下，带有 <code>@Retryable</code> 的方法会<strong>最多重试三次</strong>。你可以通过 <code>maxAttempts</code> 属性进行调整。例如，将重试上限设为 5 次：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@Retryable(<span class="hljs-params">retryFor = AnswerNotRelevantException.<span class="hljs-keyword">class</span>, maxAttempts=<span class="hljs-number">5</span></span>)</span>
</code></pre>
<p>尽管可以通过 <code>maxAttempts</code> 增加重试次数，但要注意：每次重试都意味着对 <strong>LLM</strong> 多发送一次提示，同时评估器也会反复向 LLM 发送评估提示。这会<strong>增加费用</strong>（因为在得到相关答案前可能发送了更多 token），并且如果在短时间内连续发送同样的提示，也可能触发<strong>限流</strong>。因此把 <code>maxAttempts</code> 设得较低可以避免这些问题。</p>
<p>如果在三次（或你通过 <code>maxAttempts</code> 指定的次数）尝试后仍未生成相关答案，控制流程会进入 <code>recover()</code> 方法。<code>recover()</code> 用 <code>@Recover</code> 注解标注，是 Spring Retry 提供的<strong>兜底</strong>机制：当重试持续失败时调用。在 <code>SelfEvaluatingBoardGameService</code> 中，<code>recover()</code> 只是返回一个表示<strong>无法回答</strong>的 <code>Answer</code>。</p>
<p>关于 Spring AI 的评估器，还有最后一点：虽然开箱即用的只有 <code>RelevancyEvaluator</code> 与 <code>FactCheckingEvaluator</code>，但它们都是基于 Spring AI 的如下 <strong>Evaluator</strong> 接口构建的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> org.springframework.ai.evaluation;

<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.stream.Collectors;

<span class="hljs-keyword">import</span> org.springframework.ai.document.Document;
<span class="hljs-keyword">import</span> org.springframework.util.StringUtils;

<span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Evaluator</span> {

    EvaluationResponse <span class="hljs-title function_">evaluate</span><span class="hljs-params">(EvaluationRequest evaluationRequest)</span>;

    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">doGetSupportingData</span><span class="hljs-params">(EvaluationRequest evaluationRequest)</span> {
        List&lt;Document&gt; data = evaluationRequest.getDataList();
        <span class="hljs-keyword">return</span> data.stream()
            .map(Document::getText)
            .filter(StringUtils::hasText)
            .collect(Collectors.joining(System.lineSeparator()));
    }

}
</code></pre>
<p>若 <code>RelevancyEvaluator</code> 或 <code>FactCheckingEvaluator</code> <strong>不能满足</strong>你的评估需求，你可以实现 <code>Evaluator</code> 接口<strong>自定义评估器</strong>。</p>
<h2 data-id="heading-4">小结（Summary）</h2>
<ul>
<li>生成式 AI 的<strong>非确定性</strong>使测试变得棘手。</li>
<li>Spring AI 提供<strong>评估器</strong>，可用于对生成的响应进行<strong>断言</strong>。</li>
<li>评估器通过向 LLM 发送提示，来判断响应的<strong>相关性</strong>与<strong>事实正确性</strong>。</li>
<li>评估器可在<strong>运行时</strong>应用；若返回不满意的结果，可以<strong>重试</strong>提示。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[线上python问题排查思路]]></title>    <link>https://juejin.cn/post/7570896170920951871</link>    <guid>https://juejin.cn/post/7570896170920951871</guid>    <pubDate>2025-11-10T10:02:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570896170920951871" data-draft-id="7570793903848407055" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="线上python问题排查思路"/> <meta itemprop="keywords" content="后端,Python"/> <meta itemprop="datePublished" content="2025-11-10T10:02:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="沙虫一号"/> <meta itemprop="url" content="https://juejin.cn/user/4427059249293504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            线上python问题排查思路
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4427059249293504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    沙虫一号
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:02:13.000Z" title="Mon Nov 10 2025 10:02:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>下面把检查线程阻塞和排查内存增长的工具与典型用法按要点列清楚。</p>
<h2 data-id="heading-0">线程阻塞与死锁排查</h2>
<ul>
<li>
<p>观测点：进程响应变慢或完全停滞，CPU/IO 异常或日志显示线程等待。</p>
</li>
<li>
<p>日志检查：抓取线程相关日志、异常堆栈、阻塞/等待信息。先定位时间窗口和可疑线程ID。</p>
</li>
<li>
<p>gdb（动态附加查看线程栈）</p>
</li>
</ul>
<p>用法要点：<code>gdb -p &lt;pid&gt;</code>，然后 <code>thread apply all bt</code> 查看每个线程的调用栈，定位互斥锁/等待点。</p>
<p>快速流程：附加 → 列出线程 → 对可疑线程打印 backtrace。</p>
<ul>
<li>strace（跟踪系统调用/阻塞在 syscall）</li>
</ul>
<p>用法要点：<code>strace -f -p &lt;pid&gt;</code> 或 <code>strace -ff -o out -p &lt;pid&gt;</code>。看是否在 futex、poll、read/write 等系统调用上长时间阻塞。</p>
<ul>
<li>综合策略：先从日志缩小时间段和线程；用 gdb 看 Python 层调用栈（若是 C 扩展或解释器死锁也能看出）；用 strace 判断是用户态等待还是系统调用层面阻塞。</li>
</ul>
<h2 data-id="heading-1">内存泄漏/内存增长排查</h2>
<ul>
<li>
<p>观测点：长期运行进程内存占用持续上涨，GC 后未回落，或 OOM 频繁。</p>
</li>
<li>
<p>监控：<code>top</code>/<code>ps</code>/<code>smem</code>/<code>pmap</code> 定期采样记录 RSS/VSZ。结合应用日志标记时间点。</p>
</li>
<li>
<p>tracemalloc（Python 标准库，跟踪内存分配地点）</p>
</li>
</ul>
<p>用法要点：</p>
<pre><code class="hljs language-python" lang="python">
<span class="hljs-keyword">import</span> tracemalloc

tracemalloc.start()

<span class="hljs-comment"># 在关键点取快照</span>

snap1 = tracemalloc.take_snapshot()

<span class="hljs-comment"># 运行一段时间后</span>

snap2 = tracemalloc.take_snapshot()

stats = snap2.compare_to(snap1, <span class="hljs-string">'lineno'</span>)

<span class="hljs-keyword">for</span> stat <span class="hljs-keyword">in</span> stats[:<span class="hljs-number">20</span>]:

<span class="hljs-built_in">print</span>(stat)

</code></pre>
<p>能找出按文件行号分配增长最多的地方。</p>
<ul>
<li>objgraph（分析对象引用关系）</li>
</ul>
<p>用法要点：</p>
<pre><code class="hljs language-python" lang="python">
<span class="hljs-keyword">import</span> objgraph

objgraph.show_most_common_types(limit=<span class="hljs-number">20</span>)

obj = objgraph.by_type(<span class="hljs-string">'YourTypeName'</span>)[:<span class="hljs-number">10</span>]

objgraph.show_backrefs(obj, max_depth=<span class="hljs-number">10</span>, filename=<span class="hljs-string">'leak.png'</span>)

</code></pre>
<p>用来发现哪些对象数量异常和它们的引用路径（可生成图片）。</p>
<ul>
<li>pympler（运行时内存概览与分配追踪）</li>
</ul>
<p>用法要点：</p>
<pre><code class="hljs language-python" lang="python">
<span class="hljs-keyword">from</span> pympler <span class="hljs-keyword">import</span> muppy, summary

all_objs = muppy.get_objects()

<span class="hljs-built_in">print</span>(summary.summarize(all_objs))

</code></pre>
<p>可结合 <code>asizeof</code> 或 <code>tracker</code> 做更细粒度的分配追踪。</p>
<ul>
<li>实战流程建议：先用系统工具确认增长曲线 → 用 tracemalloc 找到热点分配位置 → 用 objgraph 可视化引用链确认根对象 → 用代码修复并验证（重复采样对比快照）。</li>
</ul>
<h2 data-id="heading-2">快速检查清单（按优先级）</h2>
<ol>
<li>
<p>采集日志与进程内存/线程快照。</p>
</li>
<li>
<p>若线程疑似阻塞，先 gdb 打栈，再用 strace 确认是 syscall 层阻塞。</p>
</li>
<li>
<p>若内存增长，先采样 RSS，再用 tracemalloc 定位分配源，最后用 objgraph 验证引用链。</p>
</li>
<li>
<p>修复后做回归采样对比快照。</p>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🧭 使用历史记录 API - SPA导航与状态管理的完整指南]]></title>    <link>https://juejin.cn/post/7570598043298758719</link>    <guid>https://juejin.cn/post/7570598043298758719</guid>    <pubDate>2025-11-10T10:08:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570598043298758719" data-draft-id="7570908785292951571" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🧭 使用历史记录 API - SPA导航与状态管理的完整指南"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-10T10:08:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Bug_Constructer"/> <meta itemprop="url" content="https://juejin.cn/user/254742426830856"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🧭 使用历史记录 API - SPA导航与状态管理的完整指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/254742426830856/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Bug_Constructer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:08:35.000Z" title="Mon Nov 10 2025 10:08:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>🎯 <strong>学习目标</strong>：掌握 <code>pushState</code> / <code>replaceState</code> / <code>popstate</code> 的核心用法；在不刷新页面的情况下同步 URL 与 UI 状态；设计轻量、可序列化的 <code>state</code> 对象；为用户的前进/后退提供可控的导航体验。</p>
<p>📊 <strong>难度等级</strong>：初级-中级<br/>
🏷️ <strong>技术标签</strong>：<code>#WebAPI</code> <code>#HistoryAPI</code> <code>#SPA</code> <code>#路由</code><br/>
⏱️ <strong>阅读时间</strong>：约9分钟</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">🌟 引言</h2>
<p>在日常 SPA 开发中，你是否遇到过这些困扰：</p>
<ul>
<li>内容更新却不改变 URL，刷新或分享后无法到达当前视图</li>
<li>用户点击后退/前进导致状态丢失，体验不一致</li>
<li>页面刷新后无法恢复视图与数据，需重新操作</li>
<li>路由实现复杂，状态对象难以维护与序列化</li>
</ul>
<p>这篇文章围绕 History API，讲透如何无刷新地同步 URL 与状态，并提供经测试的最佳实践。</p>
<hr/>
<h2 data-id="heading-1">💡 核心技巧详解</h2>
<h3 data-id="heading-2">1. 无刷新导航封装：URL 与 UI 同步</h3>
<h4 data-id="heading-3">🔍 应用场景</h4>
<p>菜单切换、分页/筛选、可分享的视图定位。</p>
<h4 data-id="heading-4">❌ 常见问题</h4>
<p>只更新内容不更新 URL；未校验同源导致错误导航。</p>
<h4 data-id="heading-5">✅ 推荐方案</h4>
<p>统一封装导航函数，集中处理 <code>pushState</code> 与渲染。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 使用 History API 进行无刷新导航
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">url</span> - 目标同源 URL（可包含查询参数）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{view:string, params?:Record&lt;string,string&gt;, scrollY?:number</span>}} state - 轻量页面状态
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">navigate</span> = (<span class="hljs-params">url, state</span>) =&gt; {
  <span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(url, <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span>);
  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">origin</span> !== <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 同源校验</span>
  history.<span class="hljs-title function_">pushState</span>(state ?? {}, <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>, target.<span class="hljs-property">href</span>);
  <span class="hljs-title function_">renderFromState</span>(state ?? {});
};

<span class="hljs-comment">/**
 * 根据 state 渲染页面（视图与参数）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{view?:string, params?:Record&lt;string,string&gt;, scrollY?:number</span>}} state
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">renderFromState</span> = (<span class="hljs-params">state = {}</span>) =&gt; {
  <span class="hljs-keyword">const</span> view = state.<span class="hljs-property">view</span> || <span class="hljs-string">'home'</span>;
  <span class="hljs-keyword">const</span> params = state.<span class="hljs-property">params</span> || {};
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#app'</span>).<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'data-view'</span>, view);
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#params'</span>).<span class="hljs-property">textContent</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params);
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>({ <span class="hljs-attr">top</span>: state.<span class="hljs-property">scrollY</span> ?? <span class="hljs-number">0</span>, <span class="hljs-attr">behavior</span>: <span class="hljs-string">'instant'</span> });
};
</code></pre>
<h4 data-id="heading-6">💡 核心要点</h4>
<ul>
<li><code>pushState</code> 不触发 <code>popstate</code>，需主动渲染当前视图</li>
<li>同源校验避免跨源导航错误</li>
<li>仅保存必要参数，保持状态轻量可序列化</li>
</ul>
<h4 data-id="heading-7">🎯 实际应用</h4>
<p>在导航点击事件中调用 <code>navigate</code>，实现无刷新路由与状态同步。</p>
<hr/>
<h3 data-id="heading-8">2. 初始化首条历史记录：避免回退丢失</h3>
<h4 data-id="heading-9">🔍 应用场景</h4>
<p>应用启动、直达链接、首次加载查询参数。</p>
<h4 data-id="heading-10">❌ 常见问题</h4>
<p>未设置初始条目，回退后无法正确恢复视图。</p>
<h4 data-id="heading-11">✅ 推荐方案</h4>
<p>用 <code>replaceState</code> 写入首条历史记录并渲染。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 用 replaceState 初始化首条历史记录
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">initHistoryState</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> state = {
    <span class="hljs-attr">view</span>: <span class="hljs-string">'home'</span>,
    <span class="hljs-attr">params</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(location.<span class="hljs-property">search</span>)),
    <span class="hljs-attr">scrollY</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>
  };
  history.<span class="hljs-title function_">replaceState</span>(state, <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>, location.<span class="hljs-property">href</span>);
  <span class="hljs-title function_">renderFromState</span>(state);
};
</code></pre>
<h4 data-id="heading-12">💡 核心要点</h4>
<ul>
<li><code>replaceState</code> 替换当前条目，避免生成多余历史记录</li>
<li>初始渲染从 URL 查询参数推导状态</li>
</ul>
<h4 data-id="heading-13">🎯 实际应用</h4>
<p>应用入口处调用 <code>initHistoryState</code>，保障后退/前进行为一致。</p>
<hr/>
<h3 data-id="heading-14">3. 监听 popstate：浏览器导航状态恢复</h3>
<h4 data-id="heading-15">🔍 应用场景</h4>
<p>用户使用浏览器后退/前进或 <code>history.go()</code>。</p>
<h4 data-id="heading-16">❌ 常见问题</h4>
<p>未监听 <code>popstate</code> 导致状态无法恢复，页面闪烁或重载。</p>
<h4 data-id="heading-17">✅ 推荐方案</h4>
<p>绑定 <code>popstate</code>，根据历史条目恢复 UI。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 绑定 popstate 事件以恢复 UI
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">void</span>}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">bindPopState</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'popstate'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> state = e.<span class="hljs-property">state</span> || {};
    <span class="hljs-title function_">renderFromState</span>(state);
  });
};
</code></pre>
<h4 data-id="heading-18">💡 核心要点</h4>
<ul>
<li><code>popstate</code> 仅在用户导航或 <code>history.go()</code> 时触发</li>
<li>历史条目中的 <code>state</code> 应足以推导并渲染 UI</li>
</ul>
<h4 data-id="heading-19">🎯 实际应用</h4>
<p>应用启动后立即绑定，保证导航一致性。</p>
<hr/>
<h3 data-id="heading-20">4. 轻量状态对象：可序列化且可推导 UI</h3>
<h4 data-id="heading-21">🔍 应用场景</h4>
<p>分页、筛选、详情视图定位。</p>
<h4 data-id="heading-22">❌ 常见问题</h4>
<p>状态过度复杂，无法序列化或跨会话恢复。</p>
<h4 data-id="heading-23">✅ 推荐方案</h4>
<p>仅保存视图标识、查询参数与滚动位置。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 生成可序列化的轻量状态对象
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">view</span> - 视图标识
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Record&lt;string,string&gt;</span>} <span class="hljs-variable">params</span> - 查询参数
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">{view:string, params:Record&lt;string,string&gt;, scrollY:number</span>}}
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">makeState</span> = (<span class="hljs-params">view, params = {}</span>) =&gt; ({
  view,
  params,
  <span class="hljs-attr">scrollY</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>
});
</code></pre>
<h4 data-id="heading-24">💡 核心要点</h4>
<ul>
<li>复杂对象转 ID 或可重建的引用</li>
<li>保持状态小而清晰，提升兼容与维护性</li>
</ul>
<h4 data-id="heading-25">🎯 实际应用</h4>
<p>与路由服务结合，统一生成并持久化轻量 <code>state</code>。</p>
<hr/>
<h2 data-id="heading-26">📊 技巧对比总结</h2>



































<table><thead><tr><th>技巧</th><th>使用场景</th><th>优势</th><th>注意事项</th></tr></thead><tbody><tr><td>无刷新导航封装</td><td>菜单切换、分页/筛选</td><td>URL 与 UI 同步、无刷新</td><td>同源校验、轻量状态</td></tr><tr><td>初始化首条记录</td><td>应用启动、直达链接</td><td>回退行为一致、可恢复</td><td>使用 replaceState</td></tr><tr><td>监听 popstate</td><td>后退/前进导航</td><td>状态恢复、体验一致</td><td>仅用户导航触发</td></tr><tr><td>轻量状态对象</td><td>分页、筛选、详情</td><td>可序列化、可推导 UI</td><td>复杂对象转 ID</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-27">🎯 实战应用建议</h2>
<h3 data-id="heading-28">最佳实践</h3>
<ol>
<li>将导航封装为服务模块，统一同源校验与状态构建</li>
<li>分享/收藏的场景更新 URL；内部微调可不产生历史条目</li>
<li>将分页/筛选写入查询串，便于直达同一视图</li>
<li>结合滚动位置与焦点管理，提升返回体验连贯性</li>
</ol>
<h3 data-id="heading-29">性能考虑</h3>
<ul>
<li>避免在 <code>popstate</code> 中做重计算，优先使用已保存的轻量状态</li>
<li>校验 URL 同源后再构建状态，减少异常与重渲染</li>
<li>必要时提供 Hash 降级兼容旧环境或跨源路径</li>
</ul>
<hr/>
<h2 data-id="heading-30">💡 总结</h2>
<p>这 4 个 History API 技巧能让 SPA 在不刷新页面的前提下实现“可导航、可恢复、可分享”的能力：</p>
<ol>
<li>无刷新导航封装：统一 <code>pushState</code> 与渲染</li>
<li>初始化首条历史记录：用 <code>replaceState</code> 保证回退一致</li>
<li>监听 <code>popstate</code>：用户导航时恢复 UI</li>
<li>轻量状态对象：仅保存必要信息，保持可序列化与可维护</li>
</ol>
<p>希望这些技巧能帮助你在 SPA 路由与状态管理中写出更优雅的代码！</p>
<hr/>
<h2 data-id="heading-31">🔗 相关资源</h2>
<ul>
<li>MDN（中文）：Working with the History API<br/>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FHistory_API%2FWorking_with_the_History_API" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API/Working_with_the_History_API" ref="nofollow noopener noreferrer">developer.mozilla.org/zh-CN/docs/…</a></li>
</ul>
<hr/>
<blockquote>
<p>💡 <strong>今日收获</strong>：掌握了History API的多个核心技巧，这些知识点在实际开发中非常实用。</p>
</blockquote>
<p><strong>如果这篇文章对你有帮助，欢迎点赞、收藏和分享！有任何问题也欢迎在评论区讨论。</strong> 🚀</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[年处理约 1.4 万亿美元：从支付基础设施到 ACP 协议，拆解 Stripe 如何搭建AI智能体经济的商业标准？]]></title>    <link>https://juejin.cn/post/7570793903848521743</link>    <guid>https://juejin.cn/post/7570793903848521743</guid>    <pubDate>2025-11-10T10:02:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570793903848521743" data-draft-id="7570901172526956579" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="年处理约 1.4 万亿美元：从支付基础设施到 ACP 协议，拆解 Stripe 如何搭建AI智能体经济的商业标准？"/> <meta itemprop="keywords" content="产品经理"/> <meta itemprop="datePublished" content="2025-11-10T10:02:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="莫尔索"/> <meta itemprop="url" content="https://juejin.cn/user/518625218016504"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            年处理约 1.4 万亿美元：从支付基础设施到 ACP 协议，拆解 Stripe 如何搭建AI智能体经济的商业标准？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/518625218016504/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    莫尔索
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:02:36.000Z" title="Mon Nov 10 2025 10:02:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>在这期播客中，Stripe（几乎所有出海产品都在用的全球性支付平台）的数据与 AI 负责人 Emily 深入探讨了 AI 如何从根本上重塑经济基础设施。AI 不仅在创造新的商业模式（如 Agent 服务商），也带来全新的经济挑战，特别是高昂的边际成本和新型欺诈。Stripe 正在通过扩展其反欺诈系统 (Radar)、<strong>推出 Token Billing（按推理时 token 计费）</strong> 等创新支付工具，以及与 OpenAI 联合发布 <strong>ACP (Agentic Commerce Protocol，代理式电商协议)</strong> 来应对这些挑战，旨在为即将到来的 AI Agent 经济建立一个开放、高效且安全的商业标准。</p>
</blockquote>
<p>欢迎订阅合集 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4221297752417992707%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252FX1JwNWhO9tjVQfh9Qq9uJw%26nolastread%3D1%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4221297752417992707&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FX1JwNWhO9tjVQfh9Qq9uJw&amp;nolastread=1&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">AI 播客捕手</a>：专门面向文字内容爱好者分享 AI 领域优质播客，其他合集：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4243230891033935893%26subscene%3D159%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252FZcMiAmfNkmYLDgAu0rlb1Q%26nolastread%3D1%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4243230891033935893&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZcMiAmfNkmYLDgAu0rlb1Q&amp;nolastread=1#wechat_redirect" ref="nofollow noopener noreferrer">AI 冷思考</a>：个人在 AI 狂欢下的冷思考，聚焦 AI 工程化、Agent Infra 产品、效率型 AI 工具和人机协作话题，寻找可持续的产业价值。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4243205243418624006%26subscene%3D159%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252F0Tdan3R8juUlj-Lh-QMmew%26nolastread%3D1%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4243205243418624006&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0Tdan3R8juUlj-Lh-QMmew&amp;nolastread=1#wechat_redirect" ref="nofollow noopener noreferrer">AI 博客精选</a>：精心编译海外技术厂商发布的高质量 AI 领域博客文章。</li>
</ul>
<h2 data-id="heading-0">目录</h2>
<ul>
<li>Stripe 的 AI 演进：从反欺诈到支付基础模型</li>
<li>AI 时代的经济挑战：高昂的边际成本与新型欺诈</li>
<li>为 AI 经济构建基础设施：从 Radar 扩展到支付创新</li>
<li>ACP：定义 AI Agent 的商业未来</li>
<li>AI 经济分析：泡沫还是繁荣？</li>
<li>个人思考</li>
</ul>
<h2 data-id="heading-1">Stripe 的 AI 演进：从反欺诈到支付基础模型</h2>
<p>Stripe 的使命是构建互联网的金融基础设施，作为数据与 AI 负责人，Emily 的职责是帮助 Stripe 有效利用其庞大的数据——每年处理约 1.4 万亿美元（占全球 GDP 约 1.3%）的交易量，这些数据不仅用于理解经济动态，更被反馈到产品中，以优化支付体验、减少欺诈、提高授权率。</p>
<p>Emily 领导的组织涵盖了从数据平台、机器学习基础设施到应用层的整个技术栈。其中一个特色是实验项目团队，这个小而精的团队专注于探索那些跨越单一产品线的、由用户需求拉动的从 0 到 1 的机会，近期的 ACP 和 Token Billing 项目均源于此团队。（编注：这个小团队约 20 多人，由数据部门主导，具备跨部门的数据获取权限，高效挖掘业务数据价值，将 AI 深度融入到企业业务模式和工作流程中，大企业试验性探索 AI 原生组织模式的有效思路）</p>
<p>谈到 AI 在 Stripe 的演进，Emily 指出，Stripe 使用 ML 的历史已超过十年，远早于当下的 AI 浪潮。最初，ML 被用于核心产品 Radar（Stripe 的欺诈检测系统）以及内部运营。Stripe 每天需要审核数千名新用户，确保他们的可支持性、信用价值和非欺诈性，这从一开始就离不开 ML。</p>
<p>真正的转变发生在 GPT-3.5 出现时，Stripe 意识到需要为所有人提供高质量、安全、易用的 LLM 访问权限，不仅是为日常工作，更是为了构建生产级的 AI 体验。在过去一年半中，Stripe 的策略从<strong>使用多个单任务、点解决方案的 ML 模型，转向构建自己特定领域的支付基础模型 (Foundation Model, FM)</strong> 。</p>
<p>这个基础模型在 Stripe 的支付处理中扮演着至关重要的角色，每分钟处理高达 50,000 笔交易，并且每一笔交易都会流经这个 FM 进行实时评估，延迟必须控制在 100 毫秒以内。FM 的强大之处在于它能处理所有事情——它被输入了数百亿笔交易的全部细节，而不像传统 ML 模型那样依赖人类工程师的手工特征工程。</p>
<p>更关键的是，<strong>FM 引入了序列的概念，将支付数据类比为语言数据。一个支付行为就像一个词，其意义取决于上下文（即周围的词）。FM 能够捕捉到复杂的序列模式，例如某个 IP 在某个特定时间、使用某种卡在特定商家进行交易。</strong> 这好比观看一部电影，FM 能够识别出哪些场景组合起来构成了异常。</p>
<p>这种能力在盗刷测试监测上取得了显著成果。传统的盗刷者会隐藏在大型电商的巨大流量中，进行大量 1 美分、2 美分的小额测试。传统 ML 很难捕捉到这种撒胡椒面式的攻击。而 FM 通过分析嵌入向量，能实时发现这些异常簇，并将大型用户的盗刷检测率从 59% 提升到了 97%。</p>
<p>FM 的另一个优势是快速适应性。一些 AI 公司向 Stripe 反映，他们面临大量可疑交易，这些交易虽然最终没有导致欺诈性争议（商家能收到钱），但它们来自机器人，会干扰数据，属于不良流量。Stripe 利用 FM 快速识别并聚类了这些新型可疑行为（例如，枚举登录流程中的某些组件），并在几天内就为 AI 公司提供了标记这些流量的能力，允许它们自行决定是否阻止这些交易。</p>
<h2 data-id="heading-2">AI 时代的经济挑战：高昂的边际成本与新型欺诈</h2>
<p>在 AI 时代，欺诈的形态发生了根本性的变化。Emily 指出，一种被称为友好欺诈的问题正变得尤为突出。这并非指盗用他人信用卡，而是用户使用自己的凭证进行“非支付滥用”，例如免费试用滥用 、退款滥用或“先用后不付”。</p>
<p>在传统的 SaaS 时代，这个问题并不致命。因为 SaaS 产品的边际成本几乎为零。即使用户滥用了免费试用，SaaS 公司损失的也只是潜在的收入，而没有产生实际的、高昂的交付成本。</p>
<p>在 AI 时代，情况完全不同。GPU 非常昂贵，推理成本很高。当一个用户滥用 AI 产品的免费试用时，他们是在消耗实实在在的算力资源。这种高昂的边际成本使得欺诈变为对 AI 企业生死存亡的威胁。</p>
<p>Emily 分享了一个案例：她与一位小型 AI 创始人交流，对方称欺诈不是问题。Emily 追问后发现，这位创始人为了解决欺诈问题，不得不完全关闭了免费试用，并且在新用户证明其支付能力之前，极大地限制了他们的积分或使用额度。Emily 犀利地指出：“你不是解决了欺诈问题，你是在扼杀你自己的收入。”</p>
<p>这种痛苦是真实存在的，它迫使企业在增长和风险之间做出艰难的权衡。这个问题不仅限于 AI 公司，也存在于广告平台（广告商投放了广告却不付钱，占用了本可以付费的广告位）等领域。</p>
<p>Emily 甚至提到，她的朋友最近获得了 Robin Hood 信用卡，该卡甚至在营销中提供“免费试用卡”——这种卡 24 小时后即过期，专门用于注册免费试用。这对善意的消费者来说很方便，但对欺诈者而言，这是对 AI 经济极具破坏性的工具。</p>
<p>Stripe 正在构建一套 Radar 扩展套件，专门针对这些新型欺诈。例如，Stripe 的免费试用产品声称可以在源头捕获大多数免费试用滥用。对于退款滥用，Stripe 也正在开发类似的解决方案。退款滥用在企业级套餐（如每月 10,000 美元购买数十万积分）中尤为严重。Stripe 的系统可以看到这些用户在使用服务（例如，在极短时间内用完所有积分），并能验证使用者身份，从而帮助商家识别并阻止这种滥用。</p>
<p>.... 更多内容</p>
<p>欢迎订阅合集 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4221297752417992707%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252FX1JwNWhO9tjVQfh9Qq9uJw%26nolastread%3D1%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4221297752417992707&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FX1JwNWhO9tjVQfh9Qq9uJw&amp;nolastread=1&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">AI 播客捕手</a>：专门面向文字内容爱好者分享 AI 领域优质播客，其他合集：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4243230891033935893%26subscene%3D159%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252FZcMiAmfNkmYLDgAu0rlb1Q%26nolastread%3D1%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4243230891033935893&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZcMiAmfNkmYLDgAu0rlb1Q&amp;nolastread=1#wechat_redirect" ref="nofollow noopener noreferrer">AI 冷思考</a>：个人在 AI 狂欢下的冷思考，聚焦 AI 工程化、Agent Infra 产品、效率型 AI 工具和人机协作话题，寻找可持续的产业价值。</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzg2OTk1NDQ4Ng%3D%3D%26action%3Dgetalbum%26album_id%3D4243205243418624006%26subscene%3D159%26subscene%3D%26scenenote%3Dhttps%253A%252F%252Fmp.weixin.qq.com%252Fs%252F0Tdan3R8juUlj-Lh-QMmew%26nolastread%3D1%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTk1NDQ4Ng==&amp;action=getalbum&amp;album_id=4243205243418624006&amp;subscene=159&amp;subscene=&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0Tdan3R8juUlj-Lh-QMmew&amp;nolastread=1#wechat_redirect" ref="nofollow noopener noreferrer">AI 博客精选</a>：精心编译海外技术厂商发布的高质量 AI 领域博客文章。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[setTimeout 和 setInterval：看似简单，但你不知道的使用误区]]></title>    <link>https://juejin.cn/post/7570902473432973312</link>    <guid>https://juejin.cn/post/7570902473432973312</guid>    <pubDate>2025-11-10T10:14:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902473432973312" data-draft-id="7563194864416210979" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="setTimeout 和 setInterval：看似简单，但你不知道的使用误区"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2025-11-10T10:14:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="矢心"/> <meta itemprop="url" content="https://juejin.cn/user/4441682709588525"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            setTimeout 和 setInterval：看似简单，但你不知道的使用误区
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4441682709588525/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    矢心
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:14:05.000Z" title="Mon Nov 10 2025 10:14:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">不那么准时的setTimeout和setInterval</h2>
<h3 data-id="heading-1">setTimeout和setInterval的执行时间误差</h3>
<p>在我们常见观念中，<strong>setTimeout</strong> 和 <strong>setInterval</strong> 都是用来在指定时间定时执行代码的函数。
setTimeout用于在指定的时间后执行一次代码，而setInterval则用于在指定的时间间隔内重复执行代码。</p>
<p>如题，下面的代码，很多人会下意识的认为 setTimeout 会在1秒后输出，setInterval 每1秒输出一次</p>
<p>但是实际情况中，setTimeout和setInterval的执行时间是有一定误差的。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 记录开始时间</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`setTimeout实际执行时间：<span class="hljs-subst">${end - start}</span>ms`</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// 记录开始时间</span>
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> end = performance.<span class="hljs-title function_">now</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`setInterval实际执行时间：<span class="hljs-subst">${end - start}</span>ms`</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>
<p><code>实际上执行时间会大于等于指定的延迟时间</code></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87e579e21f4e4fc382585b162fe576a8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-i5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763374445&amp;x-signature=FTjApNmeB08XiZXzFZeSTan5k6A%3D" alt="GIF2.gif" loading="lazy"/></p>
<p>这是为什么呢？定时器始终存在实际最小执行间隔，即使指定的延迟时间为<strong>0ms</strong>，也会存在一定的延迟。</p>
<h4 data-id="heading-2">1、JS 引擎机制</h4>
<p>这是因为JavaScript是单线程执行的，而 setTimeout 和 setInterval 都是异步函数，
当JavaScript引擎执行到 setTimeout 或 setInterval 时，会将其放入事件队列中，定时器的回调函数必须等待主线程空闲时才能执行。而主线程空闲的时间是不确定的，取决于当前执行的代码的耗时。
即使主线程空闲，浏览器也需要一定时间调度回调函数（属于引擎内部的 “调度开销”），这个开销通常在 <strong>1ms~4ms</strong> 之间</p>
<h4 data-id="heading-3">2、HTML5 规范</h4>
<ol>
<li>
<p>HTML5 规范明确规定了<strong>定时器的最小延迟限制为4ms</strong>，嵌套层级较浅时最小延迟可能低至1ms。</p>
</li>
<li>
<p>对于嵌套层级 ≥ 5 的定时器（即定时器回调中再次创建定时器，形成嵌套），浏览器会强制将最小延迟限制为 4ms。</p>
</li>
<li>
<p>处于后台标签页中的计时器也可能会被限制为1秒的最小延迟</p>
</li>
</ol>
<p>因此，对于实际应用中，我们不能依赖 setTimeout 和 setInterval 的精确执行时间，而应该根据实际需求来调整定时器的延迟时间。</p>
<p>因此，对于实际应用中，我们不能依赖 <code>0ms</code> 延迟实现高精度逻辑（比如动画帧）</p>
<p>推荐使用 <code>requestAnimationFrame</code>（专门为动画设计，与浏览器刷新频率同步）</p>
<h3 data-id="heading-4">解决方法</h3>
<p>1、调整延迟时间
根据实际需求，合理调整定时器的延迟时间。如果对执行时间有严格要求，建议使用 Date.now() 或performance.now() 来计算实际执行时间，而不是依赖定时器的回调函数。</p>
<p>2、使用 requestAnimationFrame
requestAnimationFrame 是浏览器提供的用于动画循环的函数，它会在浏览器下一次重绘之前执行回调函数。与浏览器刷新频率同步，使用 requestAnimationFrame 可以实现更精确的动画效果。</p>
<h2 data-id="heading-5">setInterval存在的问题</h2>
<p>除了最小延迟时间外，setInterval 还存在一些额外问题，主要表现在以下几个方面：</p>
<h3 data-id="heading-6">1、任务堆叠（执行耗时  &gt;  设定间隔）</h3>
<p>如果回调中的执行耗时超过间隔时间，setInterval 可不会等你，而是会立即执行下一个回调，它会无视上次回调是否执行完毕，将新的回调推入队列，导致任务在队列中堆积，主线程空闲后，这些回调会连续地执行，失去间隔意义</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  count++;
  <span class="hljs-comment">// 每秒先输出当前执行信息</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`执行第<span class="hljs-subst">${count}</span>次，累计运行<span class="hljs-subst">${((<span class="hljs-built_in">Date</span>.now() - startTime) / <span class="hljs-number">1000</span>).toFixed(<span class="hljs-number">1</span>)}</span>s`</span>);
  <span class="hljs-comment">// 模拟耗时操作（阻塞2s）</span>
  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">2000</span>) {} <span class="hljs-comment">// 阻塞2000ms</span>
  <span class="hljs-comment">// 输出任务完成信息，并标记时间点</span>
  <span class="hljs-keyword">if</span> (count === <span class="hljs-number">1</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"第一次任务执行完成（约3秒后）"</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"任务执行完成（间隔约2秒）"</span>);
  }
}, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 间隔1000ms</span>
<span class="hljs-comment">// 实际为除了第一次是3s后执行完成，后续都是2s后执行完成，不会按照预设的1s间隔执行</span>
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c6101b8b3274d47ba40309ea75e3aa0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-i5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763374445&amp;x-signature=WmNqYk7xjPs6fCFTbT%2Fv3aQVK88%3D" alt="GIF.gif" loading="lazy"/>
<code>如果回调中的执行耗时超过间隔时间，实际间隔时间就是执行任务消耗的时间，而不是设定的值</code></p>
<h3 data-id="heading-7">2、误差累积（时间不准）</h3>
<p>上面说过，由于js的单线程机制，setInterval 无法保证精确间隔​，实际输出时间间隔可能大于设定的时间，因为js是单线程的，游览器最小间隔限制：浏览器通常有 ​4ms 最小延迟​（即使设 0ms），没有0延时定时器，包括setTimeout。</p>
<p>因此，在使用 setInterval 时，需要注意任务的执行耗时，避免耗时过长导致误差累积。</p>
<h3 data-id="heading-8">3、内存泄漏（忘记清除）</h3>
<p>忘记清理 setTimeout 只会导致一个多余的回调执行。但忘记 clearInterval 会导致回调函数无限执行，造成严重的内存泄漏，且页面跳转也不会自动停止（在 SPA 中最为明显）</p>
<h3 data-id="heading-9">解决办法</h3>
<p>手动写一个 <strong>setTimeout 递归封装的「安全版定时器」</strong>，解决 setInterval 可能出现的任务堆叠等问题，确保前一次回调完全执行完毕后，才触发下一次</p>
<p>简单示例：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInterval</span>(<span class="hljs-params">fn, delay</span>) {
  <span class="hljs-comment">// 递归执行函数</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 执行任务</span>
    <span class="hljs-built_in">setTimeout</span>(run, delay); <span class="hljs-comment">// 任务完成后，才触发下一次</span>
  };
  <span class="hljs-comment">// 启动首次执行</span>
  <span class="hljs-built_in">setTimeout</span>(run, delay);
}
</code></pre>
<p>使用效果</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-title function_">myInterval</span>(<span class="hljs-function">() =&gt;</span> {
  count++;
  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">1000</span>) {} <span class="hljs-comment">// 阻塞1000ms</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`执行第<span class="hljs-subst">${count}</span>次，累计运行<span class="hljs-subst">${((<span class="hljs-built_in">Date</span>.now() - startTime) / <span class="hljs-number">1000</span>).toFixed(<span class="hljs-number">1</span>)}</span>s`</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d2d37d3144d4bba9c4b359bd8d8c7d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55-i5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763374445&amp;x-signature=5697PMBvazkcfsfN2il0H%2F5ZsVM%3D" alt="GIF3.gif" loading="lazy"/>
每<strong>2s</strong>间隔执行，这样确保了每次回调执行完毕后，才会触发下一次，避免了任务堆叠问题。</p>
<h2 data-id="heading-10">总结</h2>
<p>在开发中，在大多数需要轮询定时器的场景下，使用递归的 setTimeout 相对更安全、更可控，使用 setInterval 时要做到心中有数，避免产生bug。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Android 渲染机制深度解析（一个Crash引发的思考）]]></title>    <link>https://juejin.cn/post/7570903763721453578</link>    <guid>https://juejin.cn/post/7570903763721453578</guid>    <pubDate>2025-11-10T10:11:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570903763721453578" data-draft-id="7570932873130557467" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Android 渲染机制深度解析（一个Crash引发的思考）"/> <meta itemprop="keywords" content="性能优化"/> <meta itemprop="datePublished" content="2025-11-10T10:11:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="范特蛟"/> <meta itemprop="url" content="https://juejin.cn/user/3773179636744205"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Android 渲染机制深度解析（一个Crash引发的思考）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3773179636744205/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    范特蛟
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:11:12.000Z" title="Mon Nov 10 2025 10:11:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Android 渲染机制深度解析</h2>
<blockquote>
<p>起因：androidx.recyclerview.widget.RecyclerView$Recycler.validateViewHolderForOffsetPosition</p>
</blockquote>
<blockquote>
<p>包含 RecyclerView、GapWorker 和 Choreographer 的完整工作原理</p>
</blockquote>
<h3 data-id="heading-1">目录</h3>
<ul>
<li><a href="#%E4%B8%80recyclerview-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" title="#%E4%B8%80recyclerview-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">一、RecyclerView 工作原理</a></li>
<li><a href="#%E4%BA%8Cgapworker-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90" title="#%E4%BA%8Cgapworker-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90">二、GapWorker 深度解析</a></li>
<li><a href="#%E4%B8%89choreographer-%E8%AF%A6%E8%A7%A3" title="#%E4%B8%89choreographer-%E8%AF%A6%E8%A7%A3">三、Choreographer 详解</a></li>
</ul>
<hr/>
<h2 data-id="heading-2">一、RecyclerView 工作原理</h2>
<p>RecyclerView 是 Android 中用于高效显示大量数据的组件。</p>
<h3 data-id="heading-3">核心设计理念</h3>
<p><strong>复用（Recycle）+ 视图持有者（ViewHolder）= 高性能列表</strong></p>
<p>传统的 ListView 每次滚动都要 <code>findViewById</code>，非常耗时。RecyclerView 通过缓存和复用机制大幅提升性能。</p>
<h3 data-id="heading-4">核心组件</h3>
<h4 data-id="heading-5">1. ViewHolder（视图持有者）</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewHolder</span>(itemView: View) : RecyclerView.ViewHolder(itemView) {
    <span class="hljs-keyword">val</span> textView = itemView.findViewById&lt;TextView&gt;(R.id.text)
    <span class="hljs-comment">// 缓存子View的引用，避免重复 findViewById</span>
}
</code></pre>
<p><strong>作用</strong>：</p>
<ul>
<li>缓存 itemView 中的子 View 引用</li>
<li>携带 position、itemId 等元数据</li>
<li>一个 ViewHolder 对应一个列表项</li>
</ul>
<h4 data-id="heading-6">2. Adapter（适配器）</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">MyViewHolder</span>&gt;() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> { ... }          <span class="hljs-comment">// 数据总数</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(...)</span></span>: MyViewHolder <span class="hljs-comment">// 创建ViewHolder</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder, position)</span></span>    <span class="hljs-comment">// 绑定数据</span>
}
</code></pre>
<p><strong>作用</strong>：</p>
<ul>
<li>管理数据源</li>
<li>创建和绑定 ViewHolder</li>
<li>通知 RecyclerView 数据变化</li>
</ul>
<h4 data-id="heading-7">3. LayoutManager（布局管理器）</h4>
<pre><code class="hljs language-kotlin" lang="kotlin">LinearLayoutManager    <span class="hljs-comment">// 线性布局</span>
GridLayoutManager      <span class="hljs-comment">// 网格布局</span>
StaggeredGridLayoutManager <span class="hljs-comment">// 瀑布流</span>
</code></pre>
<p><strong>作用</strong>：</p>
<ul>
<li>决定 item 如何摆放（垂直、横向、网格等）</li>
<li>处理滚动逻辑</li>
<li>决定哪些 item 可见</li>
</ul>
<h4 data-id="heading-8">4. Recycler（回收器）</h4>
<p>核心复用机制的实现者，管理多级缓存。</p>
<h3 data-id="heading-9">四级缓存机制</h3>
<p>这是 RecyclerView 性能的核心！</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────┐
│          RecyclerView 缓存池             │
├─────────────────────────────────────────┤
│ <span class="hljs-number">1</span>. mAttachedScrap (屏幕内缓存)           │  ← 最快，无需绑定
│    - 保存正在显示的 ViewHolder            │
│    - 用于布局期间临时分离的 ViewHolder     │
├─────────────────────────────────────────┤
│ <span class="hljs-number">2</span>. mCachedViews (离屏缓存)               │  ← 快，无需绑定
│    - 默认大小：<span class="hljs-number">2</span>                          │
│    - 保存刚滚出屏幕的 ViewHolder           │
│    - <span class="hljs-attribute">position</span> 和数据完全匹配才能复用       │
├─────────────────────────────────────────┤
│ <span class="hljs-number">3</span>. ViewCacheExtension (自定义缓存)       │  ← 开发者自定义
│    - 几乎不用                             │
├─────────────────────────────────────────┤
│ <span class="hljs-number">4</span>. RecycledViewPool (回收池)            │  ← 需要重新绑定
│    - 默认每种 type 缓存 <span class="hljs-number">5</span> 个               │
│    - 按 viewType 分类存储                 │
│    - ViewHolder 会清除 <span class="hljs-attribute">position</span> 信息      │
│    - 需要重新 <span class="hljs-built_in">onBindViewHolder</span>()          │
└─────────────────────────────────────────┘
</code></pre>
<h4 data-id="heading-10">缓存查找优先级</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 伪代码展示缓存查找流程</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryGetViewHolderForPositionByDeadline</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: ViewHolder? {
    <span class="hljs-comment">// 1. 先从 mAttachedScrap 找（精确匹配 position）</span>
    holder = mAttachedScrap.findByPosition(position)
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> holder  <span class="hljs-comment">// 直接使用，无需 bind</span>

    <span class="hljs-comment">// 2. 从 mCachedViews 找（精确匹配 position）</span>
    holder = mCachedViews.findByPosition(position)
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> holder  <span class="hljs-comment">// 直接使用，无需 bind</span>

    <span class="hljs-comment">// 3. 从自定义缓存找</span>
    holder = mViewCacheExtension?.getViewForPosition(position)
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> holder

    <span class="hljs-comment">// 4. 从 RecycledViewPool 找（按 viewType 查找）</span>
    holder = mRecyclerPool.getRecycledView(viewType)
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) {
        holder.resetInternal()  <span class="hljs-comment">// 清除旧数据</span>
        adapter.bindViewHolder(holder, position)  <span class="hljs-comment">// 需要重新绑定</span>
        <span class="hljs-keyword">return</span> holder
    }

    <span class="hljs-comment">// 5. 所有缓存都没有，创建新的</span>
    holder = adapter.createViewHolder(parent, viewType)
    adapter.bindViewHolder(holder, position)
    <span class="hljs-keyword">return</span> holder
}
</code></pre>
<h3 data-id="heading-11">工作流程</h3>
<h4 data-id="heading-12">1. 初始化阶段</h4>
<pre><code class="hljs language-kotlin" lang="kotlin">recyclerView.layoutManager = LinearLayoutManager(context)
recyclerView.adapter = myAdapter
</code></pre>
<p>RecyclerView 会：</p>
<ol>
<li>测量自己的尺寸</li>
<li>让 LayoutManager 布局子 View</li>
<li>根据可见区域创建足够的 ViewHolder</li>
</ol>
<h4 data-id="heading-13">2. 滚动阶段</h4>
<pre><code class="hljs language-arduino" lang="arduino">用户向上滚动：

┌──────────────────┐
│ position <span class="hljs-number">0</span>       │ ← 滚出屏幕，进入 mCachedViews
├──────────────────┤
│ position <span class="hljs-number">1</span>       │ ← 可见
├──────────────────┤
│ position <span class="hljs-number">2</span>       │ ← 可见
├──────────────────┤
│ position <span class="hljs-number">3</span>       │ ← 可见
├──────────────────┤
│ position <span class="hljs-number">4</span>       │ ← 即将可见，从缓存中取 ViewHolder
└──────────────────┘
</code></pre>
<p><strong>流程</strong>：</p>
<ol>
<li>position 0 滚出屏幕 → detach → 放入 <code>mCachedViews</code></li>
<li>position 4 即将进入屏幕 → 从缓存查找 ViewHolder</li>
<li>如果 <code>mCachedViews</code> 满了（超过2个）→ 最旧的移到 <code>RecycledViewPool</code></li>
</ol>
<h4 data-id="heading-14">3. 数据更新阶段</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 错误：notifyDataSetChanged()</span>
adapter.notifyDataSetChanged()
<span class="hljs-comment">// 所有缓存失效，全部重新 bind，性能差</span>

<span class="hljs-comment">// ✅ 正确：精确通知</span>
adapter.notifyItemRemoved(position)      <span class="hljs-comment">// 删除</span>
adapter.notifyItemInserted(position)     <span class="hljs-comment">// 插入</span>
adapter.notifyItemChanged(position)      <span class="hljs-comment">// 更新</span>
adapter.notifyItemMoved(from, to)        <span class="hljs-comment">// 移动</span>
</code></pre>
<h3 data-id="heading-15">notify 方法对比</h3>








































<table><thead><tr><th>方法</th><th>缓存失效范围</th><th>重新 bind</th><th>动画</th><th>性能</th></tr></thead><tbody><tr><td><code>notifyDataSetChanged()</code></td><td>全部失效</td><td>全部重新 bind</td><td>❌ 无</td><td>⚠️ 差</td></tr><tr><td><code>notifyItemRemoved(pos)</code></td><td>仅一个</td><td>仅一个</td><td>✅ 有</td><td>✅ 好</td></tr><tr><td><code>notifyItemChanged(pos)</code></td><td>仅一个</td><td>仅一个</td><td>✅ 有</td><td>✅ 好</td></tr><tr><td><code>notifyItemInserted(pos)</code></td><td>后续位置 +1</td><td>仅新的</td><td>✅ 有</td><td>✅ 好</td></tr></tbody></table>
<h3 data-id="heading-16">位置信息管理</h3>
<p>RecyclerView 维护了复杂的位置映射：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewHolder</span> {
    <span class="hljs-keyword">var</span> mPosition: <span class="hljs-built_in">Int</span> = NO_POSITION        <span class="hljs-comment">// 当前位置</span>
    <span class="hljs-keyword">var</span> mOldPosition: <span class="hljs-built_in">Int</span> = NO_POSITION     <span class="hljs-comment">// 旧位置</span>
    <span class="hljs-keyword">var</span> mPreLayoutPosition: <span class="hljs-built_in">Int</span> = NO_POSITION <span class="hljs-comment">// 布局前位置</span>
    <span class="hljs-comment">// ... 其他位置信息</span>
}
</code></pre>
<p><strong>为什么需要这么多位置</strong>：</p>
<ul>
<li>动画期间，item 的位置会变化</li>
<li>需要记录动画前后的位置</li>
<li>预取机制需要预测位置</li>
</ul>
<h3 data-id="heading-17">完整的删除流程对比</h3>
<h4 data-id="heading-18">❌ 错误方式</h4>
<pre><code class="hljs language-kotlin" lang="kotlin">datas.remove(<span class="hljs-keyword">data</span>)
notifyDataSetChanged()

<span class="hljs-comment">// 问题：</span>
<span class="hljs-comment">// 1. 所有 ViewHolder 的 position 信息立即失效</span>
<span class="hljs-comment">// 2. GapWorker 可能使用过期的 position</span>
<span class="hljs-comment">// 3. 所有可见 item 都要重新 bind（性能差）</span>
<span class="hljs-comment">// 4. 没有删除动画</span>
</code></pre>
<h4 data-id="heading-19">✅ 正确方式</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> position = datas.indexOf(<span class="hljs-keyword">data</span>)
<span class="hljs-keyword">if</span> (position != -<span class="hljs-number">1</span>) {
    datas.remove(<span class="hljs-keyword">data</span>)
    notifyItemRemoved(position)
    notifyItemRangeChanged(position, datas.size - position)
}

<span class="hljs-comment">// 优点：</span>
<span class="hljs-comment">// 1. RecyclerView 立即更新内部位置映射</span>
<span class="hljs-comment">// 2. GapWorker 获得准确的 position 信息</span>
<span class="hljs-comment">// 3. 只有被删除的 item 需要处理</span>
<span class="hljs-comment">// 4. 有流畅的删除动画</span>
<span class="hljs-comment">// 5. 后续 item 的 position 自动更新</span>
</code></pre>
<hr/>
<h2 data-id="heading-20">二、GapWorker 深度解析</h2>
<p>GapWorker 是 RecyclerView 在 Android Support Library 25.1.0 引入的预取（Prefetch）机制，用于在 UI 空闲时提前准备即将显示的 ViewHolder。</p>
<h3 data-id="heading-21">为什么需要 GapWorker？</h3>
<h4 data-id="heading-22">传统滚动的性能问题</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">用户滚动时的帧时间分布（没有</span> <span class="hljs-string">GapWorker）：</span>

<span class="hljs-attr">Frame 1:</span> <span class="hljs-string">████████████████</span> <span class="hljs-string">(16ms</span> <span class="hljs-bullet">-</span> <span class="hljs-string">流畅)</span>
         <span class="hljs-string">只需要渲染已有的</span> <span class="hljs-string">ViewHolder</span>

<span class="hljs-attr">Frame 2:</span> <span class="hljs-string">████████████████████████████</span> <span class="hljs-string">(28ms</span> <span class="hljs-bullet">-</span> <span class="hljs-string">卡顿！⚠️)</span>
         <span class="hljs-string">需要创建新的</span> <span class="hljs-string">ViewHolder：</span>
         <span class="hljs-bullet">-</span> <span class="hljs-string">inflate</span> <span class="hljs-string">XML</span> <span class="hljs-string">(8ms)</span>
         <span class="hljs-bullet">-</span> <span class="hljs-string">onCreateViewHolder</span> <span class="hljs-string">(2ms)</span>
         <span class="hljs-bullet">-</span> <span class="hljs-string">onBindViewHolder</span> <span class="hljs-string">(5ms)</span>
         <span class="hljs-bullet">-</span> <span class="hljs-string">measure</span> <span class="hljs-string">+</span> <span class="hljs-string">layout</span> <span class="hljs-string">(3ms)</span>
         <span class="hljs-string">总计超过</span> <span class="hljs-string">16ms</span> <span class="hljs-string">→</span> <span class="hljs-string">掉帧！</span>

<span class="hljs-attr">Frame 3:</span> <span class="hljs-string">████████████████</span> <span class="hljs-string">(16ms</span> <span class="hljs-bullet">-</span> <span class="hljs-string">流畅)</span>
</code></pre>
<h4 data-id="heading-23">有了 GapWorker 之后</h4>
<pre><code class="hljs language-markdown" lang="markdown">Frame 1: ████████████████ (16ms - 流畅)
<span class="hljs-code">         渲染 + GapWorker 在空闲时间预取
</span>
Frame 2: ████████████████ (14ms - 流畅！✅)
<span class="hljs-code">         直接使用预取好的 ViewHolder
</span>
空闲时间: ░░░ (2ms)
<span class="hljs-code">         GapWorker 继续预取下一个
</span></code></pre>
<h3 data-id="heading-24">GapWorker 架构</h3>
<pre><code class="hljs language-arduino" lang="arduino">┌─────────────────────────────────────────────────┐
│              <span class="hljs-built_in">GapWorker</span> (单例)                    │
├─────────────────────────────────────────────────┤
│  管理多个 RecyclerView 的预取任务                 │
│                                                 │
│  ┌──────────────────────────────────────┐      │
│  │   RecyclerView A 的预取任务           │      │
│  │   - 预取 position <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>            │      │
│  │   - 优先级: 高                        │      │
│  └──────────────────────────────────────┘      │
│                                                 │
│  ┌──────────────────────────────────────┐      │
│  │   RecyclerView B 的预取任务           │      │
│  │   - 预取 position <span class="hljs-number">10</span>                 │      │
│  │   - 优先级: 中                        │      │
│  └──────────────────────────────────────┘      │
│                                                 │
│  通过 Choreographer 在每一帧执行               │
└─────────────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-25">工作时机</h3>
<p>GapWorker 通过 <code>Choreographer</code> 在每一帧的特定时机工作：</p>
<pre><code class="hljs language-scss" lang="scss">Android 每一帧的时间分配（<span class="hljs-number">60</span>fps = <span class="hljs-number">16.67ms</span>）：

<span class="hljs-number">0ms</span> ─────────────────────────────── <span class="hljs-number">16.67ms</span>
│                                    │
├─ <span class="hljs-selector-tag">Input</span> (触摸事件)                   │
│  约 <span class="hljs-number">2ms</span>                             │
│                                    │
├─ <span class="hljs-attribute">Animation</span> (动画)                   │
│  约 <span class="hljs-number">2ms</span>                             │
│                                    │
├─ Traversal (测量、布局、绘制)        │
│  约 <span class="hljs-number">8ms</span>                             │
│                                    │
├─ 空闲时间 ░░░░░░                    │ ← GapWorker 在这里工作！
│  约 <span class="hljs-number">4ms</span>                             │
│                                    │
└─ VSync 下一帧开始                   │
</code></pre>
<h3 data-id="heading-26">预取策略</h3>
<h4 data-id="heading-27">1. 预测下一个可见的位置</h4>
<pre><code class="hljs language-scss" lang="scss">用户向下滚动，dy &gt; <span class="hljs-number">0</span>：

┌──────────────────┐
│ <span class="hljs-attribute">position</span> <span class="hljs-number">5</span>  ✅   │ ← 完全可见
├──────────────────┤
│ <span class="hljs-attribute">position</span> <span class="hljs-number">6</span>  ✅   │ ← 完全可见
├──────────────────┤
│ <span class="hljs-attribute">position</span> <span class="hljs-number">7</span>  ✅   │ ← 完全可见
├──────────────────┤
│ <span class="hljs-attribute">position</span> <span class="hljs-number">8</span>  ⚠️   │ ← 部分可见，继续滚动会完全显示
├──────────────────┤
│ <span class="hljs-attribute">position</span> <span class="hljs-number">9</span>  🎯   │ ← 即将可见，需要预取！
└──────────────────┘
│ <span class="hljs-attribute">position</span> <span class="hljs-number">10</span> 🎯   │ ← 可能可见，也预取
  （屏幕外）

预取优先级：
<span class="hljs-number">1</span>. <span class="hljs-attribute">position</span> <span class="hljs-number">9</span>  (紧急，马上要显示)
<span class="hljs-number">2</span>. <span class="hljs-attribute">position</span> <span class="hljs-number">10</span> (次要，可能要显示)
</code></pre>
<h4 data-id="heading-28">2. LayoutManager 的预取实现</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// LinearLayoutManager 的预取逻辑</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collectInitialPrefetchPositions</span><span class="hljs-params">(
    adapterItemCount: <span class="hljs-type">Int</span>,
    layoutPrefetchRegistry: <span class="hljs-type">LayoutPrefetchRegistry</span>
)</span></span> {
    <span class="hljs-comment">// 初始布局时的预取</span>
    <span class="hljs-keyword">val</span> prefetchCount = Math.min(
        adapterItemCount,
        mInitialPrefetchItemCount <span class="hljs-comment">// 默认 2 个</span>
    )

    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until prefetchCount) {
        layoutPrefetchRegistry.addPosition(i, <span class="hljs-number">0</span>)
    }
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collectAdditionalPrefetchPositions</span><span class="hljs-params">(
    dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>,
    state: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">State</span>,
    layoutPrefetchRegistry: <span class="hljs-type">LayoutPrefetchRegistry</span>
)</span></span> {
    <span class="hljs-comment">// 滚动时的预取</span>
    <span class="hljs-keyword">val</span> layoutDirection = <span class="hljs-keyword">if</span> (dy &gt; <span class="hljs-number">0</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span> <span class="hljs-comment">// 滚动方向</span>
    <span class="hljs-keyword">val</span> scrollingOffset = Math.abs(dy)

    <span class="hljs-comment">// 计算需要预取的位置</span>
    <span class="hljs-keyword">val</span> prefetchPosition = getCurrentPosition() + layoutDirection

    <span class="hljs-comment">// 注册预取任务</span>
    layoutPrefetchRegistry.addPosition(prefetchPosition, scrollingOffset)
}
</code></pre>
<h4 data-id="heading-29">3. 预取任务的数据结构</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// GapWorker 内部任务队列</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GapWorker</span> {

    <span class="hljs-comment">// 任务类</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> {
        <span class="hljs-keyword">var</span> view: RecyclerView? = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">var</span> position: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
        <span class="hljs-keyword">var</span> immediate: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>  <span class="hljs-comment">// 是否紧急</span>
        <span class="hljs-keyword">var</span> viewVelocity: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>       <span class="hljs-comment">// 滚动速度</span>
        <span class="hljs-keyword">var</span> distanceToItem: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>     <span class="hljs-comment">// 距离当前位置的距离</span>
    }

    <span class="hljs-comment">// 任务优先级队列（按紧急程度排序）</span>
    <span class="hljs-keyword">val</span> mTasks = ArrayList&lt;Task&gt;()

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sortTasks</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 按以下优先级排序：</span>
        <span class="hljs-comment">// 1. immediate 任务优先</span>
        <span class="hljs-comment">// 2. 距离近的优先</span>
        <span class="hljs-comment">// 3. 滚动速度快的优先</span>
        mTasks.sortWith { task1, task2 -&gt;
            <span class="hljs-keyword">when</span> {
                task1.immediate &amp;&amp; !task2.immediate -&gt; -<span class="hljs-number">1</span>
                !task1.immediate &amp;&amp; task2.immediate -&gt; <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span> -&gt; task1.distanceToItem - task2.distanceToItem
            }
        }
    }
}
</code></pre>
<h3 data-id="heading-30">预取执行流程</h3>
<h4 data-id="heading-31">详细的执行步骤</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 简化的源码逻辑</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GapWorker</span> : <span class="hljs-type">Runnable</span> {

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 1. 获取截止时间（当前帧结束时间）</span>
        <span class="hljs-keyword">val</span> deadlineNs = TimeUtils.currentAnimationTimeMillis() * <span class="hljs-number">1_000_000</span> + <span class="hljs-number">4_000_000</span>
        <span class="hljs-comment">// 留 4ms 给 GapWorker，其他时间留给渲染</span>

        <span class="hljs-comment">// 2. 执行预取任务</span>
        prefetch(deadlineNs)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prefetch</span><span class="hljs-params">(deadlineNs: <span class="hljs-type">Long</span>)</span></span> {
        <span class="hljs-comment">// 按优先级处理任务</span>
        <span class="hljs-keyword">for</span> (task <span class="hljs-keyword">in</span> mTasks) {
            <span class="hljs-comment">// 检查是否还有时间</span>
            <span class="hljs-keyword">if</span> (System.nanoTime() &gt;= deadlineNs) {
                <span class="hljs-keyword">break</span> <span class="hljs-comment">// 时间用完，停止预取</span>
            }

            <span class="hljs-comment">// 执行预取</span>
            prefetchPositionWithDeadline(
                task.view,
                task.position,
                deadlineNs
            )
        }

        <span class="hljs-comment">// 清空任务队列</span>
        mTasks.clear()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">prefetchPositionWithDeadline</span><span class="hljs-params">(
        view: <span class="hljs-type">RecyclerView</span>?,
        position: <span class="hljs-type">Int</span>,
        deadlineNs: <span class="hljs-type">Long</span>
    )</span></span>: ViewHolder? {
        <span class="hljs-comment">// 这里就是崩溃发生的地方！⚠️</span>

        <span class="hljs-keyword">val</span> holder = view?.mRecycler?.tryGetViewHolderForPositionByDeadline(
            position,
            <span class="hljs-literal">false</span>,
            deadlineNs
        )

        <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (holder.isBound &amp;&amp; !holder.isInvalid) {
                <span class="hljs-comment">// 成功预取，放入缓存</span>
                view.mRecycler.recycleView(holder.itemView)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 预取失败，回收</span>
                view.mRecycler.addViewHolderToRecycledViewPool(holder, <span class="hljs-literal">false</span>)
            }
        }

        <span class="hljs-keyword">return</span> holder
    }
}
</code></pre>
<h3 data-id="heading-32">与 Recycler 缓存的配合</h3>
<pre><code class="hljs language-bash" lang="bash">GapWorker 预取的 ViewHolder 放在哪里？

┌─────────────────────────────────────────┐
│         Recycler 缓存系统                 │
├─────────────────────────────────────────┤
│                                         │
│  GapWorker 预取                          │
│      ↓                                  │
│  创建/绑定 ViewHolder                     │
│      ↓                                  │
│  放入 mCachedViews (离屏缓存)             │  ← 优先放这里
│      │                                  │
│      ├─ 如果 mCachedViews 满了           │
│      └─→ 放入 RecycledViewPool           │  ← 次选
│                                         │
│  当 item 滚动进屏幕时：                   │
│      从 mCachedViews 直接取出 ✅          │
│      无需重新 <span class="hljs-built_in">bind</span>！                     │
└─────────────────────────────────────────┘
</code></pre>
<h3 data-id="heading-33">IndexOutOfBoundsException 崩溃场景详细分析</h3>
<h4 data-id="heading-34">崩溃的时序图</h4>
<pre><code class="hljs language-scss" lang="scss">主线程（UI Thread）                   GapWorker（后台任务）
    │                                      │
    │ 用户滚动到 <span class="hljs-attribute">position</span> <span class="hljs-number">5</span>                │
    │ LayoutManager 布局完成                │
    │                                      │
    ├─ <span class="hljs-built_in">collectPrefetchPositions</span>()          │
    │  决定预取 <span class="hljs-attribute">position</span> <span class="hljs-number">6</span>                 │
    │                                      │
    │ post GapWorker<span class="hljs-selector-class">.run</span>()                 │
    │ ─────────────────────────────────→  │
    │                                      │
    │ 继续渲染界面                          │  GapWorker<span class="hljs-selector-class">.run</span>() 开始
    │                                      │  读取任务：预取 <span class="hljs-attribute">position</span> <span class="hljs-number">6</span>
    │                                      │
    │ 用户点击删除 <span class="hljs-attribute">position</span> <span class="hljs-number">2</span> ⚠️            │
    │                                      │
    ├─ <span class="hljs-built_in">onClick</span>() {                         │
    │    datas<span class="hljs-selector-class">.remove</span>(position <span class="hljs-number">2</span>)          │  ← adapter 现在只有 <span class="hljs-number">9</span> 条数据
    │    <span class="hljs-built_in">notifyDataSetChanged</span>()            │  ← 只是标记，未立即生效！
    │  }                                   │
    │                                      │
    │                                      ├─ <span class="hljs-built_in">prefetchPositionWithDeadline</span>(<span class="hljs-number">6</span>)
    │                                      │  调用 adapter<span class="hljs-selector-class">.getItemCount</span>()
    │                                      │  返回 <span class="hljs-number">9</span>（已经删除了一条）
    │                                      │
    │                                      ├─ <span class="hljs-built_in">validateViewHolderForOffsetPosition</span>()
    │                                      │  检查 <span class="hljs-attribute">position</span> <span class="hljs-number">6</span> 是否有效
    │                                      │
    │                                      │  GapWorker 认为：
    │                                      │  - 之前计划预取 <span class="hljs-attribute">position</span> <span class="hljs-number">6</span>
    │                                      │  - 但现在 adapter 只有 <span class="hljs-number">9</span> 条数据
    │                                      │  - ViewHolder 的位置信息不一致
    │                                      │
    │                                      │  抛出异常：⚠️
    │  ←────────────────────────────────── │  IndexOutOfBoundsException:
    │                                      │  Inconsistency detected!
    │                                      │
    │ CRASH! ☠️                            │
</code></pre>
<h4 data-id="heading-35">关键代码路径</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// RecyclerView.Recycler</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryGetViewHolderForPositionByDeadline</span><span class="hljs-params">(
    position: <span class="hljs-type">Int</span>,
    dryRun: <span class="hljs-type">Boolean</span>,
    deadlineNs: <span class="hljs-type">Long</span>
)</span></span>: ViewHolder? {

    <span class="hljs-comment">// ... 省略缓存查找逻辑</span>

    <span class="hljs-comment">// 关键检查点：验证 ViewHolder 的位置是否有效</span>
    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (!holder.isValid || holder.position != position) {
            <span class="hljs-comment">// 这里检测到不一致！⚠️</span>
            <span class="hljs-keyword">throw</span> IndexOutOfBoundsException(
                <span class="hljs-string">"Inconsistency detected. Invalid view holder "</span> +
                <span class="hljs-string">"adapter position <span class="hljs-variable">$holder</span>"</span>
            )
        }
    }

    <span class="hljs-keyword">return</span> holder
}

<span class="hljs-comment">// 为什么会不一致？</span>
<span class="hljs-comment">// 1. GapWorker 计划预取时：adapter.getItemCount() = 10</span>
<span class="hljs-comment">// 2. 用户删除后：adapter.getItemCount() = 9</span>
<span class="hljs-comment">// 3. 但 GapWorker 还在用旧的 position 6</span>
<span class="hljs-comment">// 4. position 6 在新的数据集中可能越界或指向错误的数据</span>
</code></pre>
<h3 data-id="heading-36">为什么精确通知能解决？</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 错误方式</span>
datas.remove(<span class="hljs-keyword">data</span>)
notifyDataSetChanged()

<span class="hljs-comment">// notifyDataSetChanged() 做了什么？</span>
<span class="hljs-comment">// 1. 标记所有 ViewHolder 为 FLAG_INVALID</span>
<span class="hljs-comment">// 2. 标记 adapter 为 hasStableIds = false</span>
<span class="hljs-comment">// 3. 触发 requestLayout()</span>
<span class="hljs-comment">// 4. 但这些都是异步的！不会立即生效！</span>
<span class="hljs-comment">// 5. GapWorker 还在使用旧的位置信息 ⚠️</span>
</code></pre>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 正确方式</span>
<span class="hljs-keyword">val</span> position = datas.indexOf(<span class="hljs-keyword">data</span>)
<span class="hljs-keyword">if</span> (position != -<span class="hljs-number">1</span>) {
    datas.remove(<span class="hljs-keyword">data</span>)
    notifyItemRemoved(position)
    notifyItemRangeChanged(position, datas.size - position)
}

<span class="hljs-comment">// notifyItemRemoved() 做了什么？</span>
<span class="hljs-comment">// 1. 立即更新 RecyclerView 的内部 AdapterHelper</span>
<span class="hljs-comment">// 2. AdapterHelper 维护位置更新操作队列</span>
<span class="hljs-comment">// 3. 告诉 RecyclerView：position 被移除了</span>
<span class="hljs-comment">// 4. RecyclerView 立即更新所有 ViewHolder 的位置</span>
<span class="hljs-comment">// 5. GapWorker 查询位置时，获得的是更新后的正确位置 ✅</span>
</code></pre>
<h4 data-id="heading-37">AdapterHelper 的作用</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// RecyclerView 内部的 AdapterHelper</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AdapterHelper</span> {

    <span class="hljs-comment">// 保存所有的数据变更操作</span>
    <span class="hljs-keyword">val</span> mPendingUpdates = ArrayList&lt;UpdateOp&gt;()

    <span class="hljs-comment">// 操作类型</span>
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ADD = <span class="hljs-number">1</span>      <span class="hljs-comment">// 插入</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REMOVE = <span class="hljs-number">2</span>   <span class="hljs-comment">// 删除</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> UPDATE = <span class="hljs-number">3</span>   <span class="hljs-comment">// 更新</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MOVE = <span class="hljs-number">4</span>     <span class="hljs-comment">// 移动</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onItemRangeRemoved</span><span class="hljs-params">(positionStart: <span class="hljs-type">Int</span>, itemCount: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-comment">// 创建删除操作</span>
        <span class="hljs-keyword">val</span> op = UpdateOp(REMOVE, positionStart, itemCount)
        mPendingUpdates.add(op)

        <span class="hljs-comment">// 立即应用到位置映射</span>
        applyRemove(op)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">applyRemove</span><span class="hljs-params">(op: <span class="hljs-type">UpdateOp</span>)</span></span> {
        <span class="hljs-comment">// 更新后续所有 ViewHolder 的位置</span>
        <span class="hljs-keyword">for</span> (holder <span class="hljs-keyword">in</span> mCachedViews) {
            <span class="hljs-keyword">if</span> (holder.position &gt;= op.positionStart) {
                holder.offsetPosition(-op.itemCount, <span class="hljs-literal">false</span>)
            }
        }

        <span class="hljs-comment">// GapWorker 读取位置时，会经过这个映射 ✅</span>
        <span class="hljs-comment">// 所以获得的是正确的位置</span>
    }
}
</code></pre>
<h3 data-id="heading-38">GapWorker 的优缺点</h3>
<h4 data-id="heading-39">优点 ✅</h4>
<ol>
<li><strong>显著提升滚动流畅度</strong>：避免滚动时创建 ViewHolder 导致的卡顿</li>
<li><strong>智能预测</strong>：根据滚动方向和速度预测</li>
<li><strong>时间控制</strong>：不会占用太多帧时间（默认 4ms）</li>
<li><strong>多 RecyclerView 支持</strong>：一个 GapWorker 管理多个列表</li>
</ol>
<h4 data-id="heading-40">缺点和风险 ⚠️</h4>
<ol>
<li><strong>数据不一致崩溃</strong>：如遇到的 IndexOutOfBoundsException</li>
<li><strong>过度预取</strong>：可能预取用不到的 ViewHolder，浪费资源</li>
<li><strong>复杂性增加</strong>：增加了调试难度</li>
<li><strong>内存占用</strong>：预取的 ViewHolder 会占用额外内存</li>
</ol>
<h3 data-id="heading-41">最佳实践</h3>
<h4 data-id="heading-42">1. 始终使用精确通知</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 正确</span>
adapter.notifyItemRemoved(position)
adapter.notifyItemInserted(position)
adapter.notifyItemChanged(position)

<span class="hljs-comment">// ❌ 避免</span>
adapter.notifyDataSetChanged()
</code></pre>
<h4 data-id="heading-43">2. 在主线程修改数据</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ✅ 正确</span>
lifecycleScope.launch(Dispatchers.Main) {
    adapter.removeItem(position)
}

<span class="hljs-comment">// ❌ 错误：后台线程修改</span>
lifecycleScope.launch(Dispatchers.IO) {
    adapter.removeItem(position) <span class="hljs-comment">// 可能与 GapWorker 冲突</span>
}
</code></pre>
<h4 data-id="heading-44">3. 使用 DiffUtil</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// DiffUtil 会自动计算差异并调用精确的 notify 方法</span>
<span class="hljs-keyword">val</span> diffResult = DiffUtil.calculateDiff(MyDiffCallback(oldList, newList))
diffResult.dispatchUpdatesTo(adapter)
</code></pre>
<h4 data-id="heading-45">4. 优化 onBindViewHolder</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// GapWorker 会调用 bind，所以要保持高效</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">ViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
    <span class="hljs-comment">// ✅ 快速绑定</span>
    holder.textView.text = <span class="hljs-keyword">data</span>[position].title

    <span class="hljs-comment">// ❌ 避免耗时操作</span>
    <span class="hljs-comment">// loadImageFromNetwork()</span>
    <span class="hljs-comment">// complexCalculation()</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-46">三、Choreographer 详解</h2>
<p>Choreographer 是 Android 4.1（API 16）引入的核心类，用于协调动画、输入和绘制的时间。它的名字来自法语"Chorégraphe"，意为"编舞者"，负责编排 UI 线程的各种操作。</p>
<h3 data-id="heading-47">为什么需要 Choreographer？</h3>
<h4 data-id="heading-48">Android 4.1 之前的问题</h4>
<pre><code class="hljs language-markdown" lang="markdown">没有 Choreographer 的渲染（混乱）：

时间轴：
0ms     5ms     10ms    15ms    20ms
│       │       │       │       │
├─ 动画更新
│       ├─ 绘制操作
│               ├─ 触摸事件
│                       ├─ 绘制操作
│                               └─ 动画更新

问题：
<span class="hljs-bullet">1.</span> 渲染时机不统一，随机触发
<span class="hljs-bullet">2.</span> 可能在屏幕刷新的任何时刻绘制
<span class="hljs-bullet">3.</span> 造成画面撕裂（Tearing）
<span class="hljs-bullet">4.</span> 无法保证 60fps
</code></pre>
<h4 data-id="heading-49">有了 Choreographer 之后</h4>
<pre><code class="hljs language-css" lang="css">VSync 信号对齐（整齐）：

时间轴（<span class="hljs-number">60</span>fps = <span class="hljs-number">16.67ms</span>一帧）：
<span class="hljs-number">0ms</span>           <span class="hljs-number">16.67ms</span>        <span class="hljs-number">33.34ms</span>
│             │              │
VSync ────────VSync ──────── VSync
│             │              │
├─ <span class="hljs-selector-tag">Input</span>      ├─ <span class="hljs-selector-tag">Input</span>       ├─ <span class="hljs-selector-tag">Input</span>
├─ <span class="hljs-attribute">Animation</span>  ├─ <span class="hljs-attribute">Animation</span>   ├─ <span class="hljs-attribute">Animation</span>
├─ Traversal  ├─ Traversal   ├─ Traversal
└─ Commit     └─ Commit      └─ Commit

优点：
<span class="hljs-number">1</span>. 所有渲染操作对齐到 VSync 信号
<span class="hljs-number">2</span>. 画面流畅，无撕裂
<span class="hljs-number">3</span>. 可预测的帧率
</code></pre>
<h3 data-id="heading-50">VSync（垂直同步）机制</h3>
<h4 data-id="heading-51">什么是 VSync？</h4>
<pre><code class="hljs language-ini" lang="ini">屏幕刷新原理：

LCD/OLED 屏幕的电子枪从上到下逐行扫描：

第1行  ═══════════════════════
第2行  ═══════════════════════
第3行  ═══════════════════════
...    ...
第N行  ═══════════════════════

扫描完一屏后，回到顶部（垂直回扫）
此时发出 VSync 信号 📡

<span class="hljs-attr">VSync</span> = Vertical Synchronization（垂直同步）
</code></pre>
<h4 data-id="heading-52">屏幕撕裂（Tearing）问题</h4>
<pre><code class="hljs">没有 VSync 同步：

GPU 正在渲染 Frame 2      屏幕正在显示
┌─────────────┐           ┌─────────────┐
│             │           │ Frame 1 上半│ ← 显示旧帧
│  Frame 2    │ ────→     ├─────────────┤ ← 撕裂线！
│             │           │ Frame 2 下半│ ← 显示新帧
└─────────────┘           └─────────────┘

用户看到的画面不连贯 ⚠️
</code></pre>
<pre><code class="hljs language-scss" lang="scss">有了 VSync 同步：

等待 VSync 信号才提交新帧

GPU 渲染 Frame <span class="hljs-number">2</span>          VSync 信号      屏幕显示
┌─────────────┐           │              ┌─────────────┐
│             │           │              │             │
│  Frame <span class="hljs-number">2</span>    │ ─────等待─┤ VSync 📡 ───→│  Frame <span class="hljs-number">2</span>    │
│             │           │              │  (完整)     │
└─────────────┘           │              └─────────────┘

画面流畅无撕裂 ✅
</code></pre>
<h4 data-id="heading-53">双缓冲（Double Buffering）</h4>
<pre><code class="hljs language-markdown" lang="markdown">Android 的双缓冲机制：

┌──────────────┐  显示      ┌──────────┐
│ Front Buffer │ ─────────→ │  Screen  │
└──────────────┘            └──────────┘
<span class="hljs-code">       ↑
       │ VSync 时交换
       │
┌──────────────┐  绘制
│ Back Buffer  │ ←──── GPU 在这里绘制下一帧
└──────────────┘
</span>
工作流程：
<span class="hljs-bullet">1.</span> GPU 在 Back Buffer 绘制
<span class="hljs-bullet">2.</span> VSync 信号到来
<span class="hljs-bullet">3.</span> 交换 Front 和 Back Buffer
<span class="hljs-bullet">4.</span> 屏幕显示 Front Buffer
<span class="hljs-bullet">5.</span> GPU 继续在新的 Back Buffer 绘制
</code></pre>
<h3 data-id="heading-54">Choreographer 架构</h3>
<h4 data-id="heading-55">核心组件</h4>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────┐
│           Choreographer (编舞者)                 │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │  CallbackQueue (回调队列)                │   │
│  │                                         │   │
│  │  CALLBACK_INPUT      (触摸输入)         │   │
│  │  CALLBACK_ANIMATION  (动画)             │   │
│  │  CALLBACK_TRAVERSAL  (测量/布局/绘制)    │   │
│  │  CALLBACK_COMMIT     (提交)             │   │
│  └─────────────────────────────────────────┘   │
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │  FrameDisplayEventReceiver              │   │
│  │  (接收 VSync 信号)                       │   │
│  └─────────────────────────────────────────┘   │
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │  FrameHandler                           │   │
│  │  (主线程 Handler，处理回调)              │   │
│  └─────────────────────────────────────────┘   │
└─────────────────────────────────────────────────┘
           ↑
           │ VSync 信号
           │
    ┌──────────────┐
    │  SurfaceFlinger  │ ← 系统服务
    │  (屏幕合成器)     │
    └──────────────┘
</code></pre>
<h4 data-id="heading-56">Choreographer 是单例</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Choreographer 每个线程一个实例</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Choreographer</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(looper: Looper) {

    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-comment">// ThreadLocal 保证每个线程独立</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sThreadInstance = ThreadLocal&lt;Choreographer&gt;()

        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>: Choreographer {
            <span class="hljs-keyword">return</span> sThreadInstance.<span class="hljs-keyword">get</span>() ?: synchronized(Choreographer::<span class="hljs-keyword">class</span>.java) {
                Choreographer(Looper.myLooper()).also {
                    sThreadInstance.<span class="hljs-keyword">set</span>(it)
                }
            }
        }
    }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-comment">// 主线程的 Choreographer</span>
<span class="hljs-keyword">val</span> mainChoreographer = Choreographer.getInstance() <span class="hljs-comment">// UI 线程</span>

<span class="hljs-comment">// 其他线程需要先创建 Looper</span>
thread {
    Looper.prepare()
    <span class="hljs-keyword">val</span> threadChoreographer = Choreographer.getInstance() <span class="hljs-comment">// 独立实例</span>
    Looper.loop()
}
</code></pre>
<h3 data-id="heading-57">四种回调类型</h3>
<p>Choreographer 定义了四种回调类型，按执行顺序：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Choreographer 的回调类型</span>
<span class="hljs-keyword">object</span> Choreographer {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALLBACK_INPUT = <span class="hljs-number">0</span>      <span class="hljs-comment">// 输入事件</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALLBACK_ANIMATION = <span class="hljs-number">1</span>  <span class="hljs-comment">// 动画</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALLBACK_TRAVERSAL = <span class="hljs-number">2</span>  <span class="hljs-comment">// 遍历（测量、布局、绘制）</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> CALLBACK_COMMIT = <span class="hljs-number">3</span>     <span class="hljs-comment">// 提交</span>
}
</code></pre>
<h4 data-id="heading-58">执行顺序和时间分配</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">一帧的完整生命周期（16.67ms</span> <span class="hljs-string">@</span> <span class="hljs-string">60fps）：</span>

<span class="hljs-string">VSync</span> <span class="hljs-string">信号到达</span>
<span class="hljs-string">│</span>
<span class="hljs-string">├─</span> <span class="hljs-attr">0-2ms:</span> <span class="hljs-string">CALLBACK_INPUT</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">处理触摸事件</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">分发点击事件</span>
<span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">更新触摸状态</span>
<span class="hljs-string">│</span>
<span class="hljs-string">├─</span> <span class="hljs-attr">2-4ms:</span> <span class="hljs-string">CALLBACK_ANIMATION</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">ValueAnimator.animateValue()</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">ObjectAnimator</span> <span class="hljs-string">更新属性</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">视图动画更新</span>
<span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">GapWorker.postFromTraversal()</span> <span class="hljs-string">←</span> <span class="hljs-string">在这里注册预取</span>
<span class="hljs-string">│</span>
<span class="hljs-string">├─</span> <span class="hljs-attr">4-14ms:</span> <span class="hljs-string">CALLBACK_TRAVERSAL</span>
<span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">ViewRootImpl.performTraversals()</span>
<span class="hljs-string">│</span>  <span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">measure</span> <span class="hljs-string">(测量)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">│</span>  <span class="hljs-string">├─</span> <span class="hljs-string">layout</span> <span class="hljs-string">(布局)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">draw</span> <span class="hljs-string">(绘制)</span>
<span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">生成</span> <span class="hljs-string">DisplayList</span>
<span class="hljs-string">│</span>
<span class="hljs-string">├─</span> <span class="hljs-attr">14-16ms:</span> <span class="hljs-string">CALLBACK_COMMIT</span>
<span class="hljs-string">│</span>  <span class="hljs-string">└─</span> <span class="hljs-string">提交渲染数据到</span> <span class="hljs-string">RenderThread</span>
<span class="hljs-string">│</span>
<span class="hljs-string">└─</span> <span class="hljs-attr">16ms:</span> <span class="hljs-string">空闲时间</span>
   <span class="hljs-string">└─</span> <span class="hljs-string">GapWorker.run()</span> <span class="hljs-string">←</span> <span class="hljs-string">RecyclerView</span> <span class="hljs-string">预取在这里执行！</span>
</code></pre>
<h4 data-id="heading-59">详细说明每种回调</h4>
<h5 data-id="heading-60">1. CALLBACK_INPUT（输入）</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 触摸事件的分发</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRootImpl</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deliverInputEvent</span><span class="hljs-params">(event: <span class="hljs-type">InputEvent</span>)</span></span> {
        <span class="hljs-comment">// 触摸事件会在 CALLBACK_INPUT 阶段处理</span>
        Choreographer.getInstance().postCallback(
            Choreographer.CALLBACK_INPUT,
            { processInputEvent(event) },
            <span class="hljs-literal">null</span>
        )
    }
}

<span class="hljs-comment">// 优先级最高，保证触摸响应快速</span>
</code></pre>
<h5 data-id="heading-61">2. CALLBACK_ANIMATION（动画）</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ValueAnimator 的实现</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueAnimator</span> {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 注册动画回调</span>
        AnimationHandler.getInstance().addAnimationFrameCallback(<span class="hljs-keyword">this</span>)
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAnimationFrame</span><span class="hljs-params">(frameTime: <span class="hljs-type">Long</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-comment">// 每一帧更新动画值</span>
        <span class="hljs-keyword">val</span> fraction = (frameTime - mStartTime) / mDuration
        <span class="hljs-keyword">val</span> animatedValue = mInterpolator.getInterpolation(fraction)

        <span class="hljs-comment">// 更新属性</span>
        mUpdateListeners.forEach { it.onAnimationUpdate(<span class="hljs-keyword">this</span>) }

        <span class="hljs-keyword">return</span> fraction &lt; <span class="hljs-number">1.0</span> <span class="hljs-comment">// 是否继续动画</span>
    }
}

<span class="hljs-comment">// AnimationHandler 内部使用 CALLBACK_ANIMATION</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimationHandler</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameCallback = <span class="hljs-keyword">object</span> : Choreographer.FrameCallback {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
            <span class="hljs-comment">// 执行所有动画</span>
            mAnimationCallbacks.forEach {
                it.doAnimationFrame(frameTimeNanos)
            }

            <span class="hljs-comment">// 如果还有动画，注册下一帧</span>
            <span class="hljs-keyword">if</span> (mAnimationCallbacks.isNotEmpty()) {
                Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>)
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addAnimationFrameCallback</span><span class="hljs-params">(callback: <span class="hljs-type">AnimationFrameCallback</span>)</span></span> {
        <span class="hljs-keyword">if</span> (mAnimationCallbacks.isEmpty()) {
            <span class="hljs-comment">// 第一个动画，开始监听帧回调</span>
            Choreographer.getInstance().postFrameCallback(mFrameCallback)
        }
        mAnimationCallbacks.add(callback)
    }
}
</code></pre>
<h5 data-id="heading-62">3. CALLBACK_TRAVERSAL（遍历）</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ViewRootImpl 的绘制流程</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRootImpl</span> {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> (!mTraversalScheduled) {
            mTraversalScheduled = <span class="hljs-literal">true</span>

            <span class="hljs-comment">// 注册遍历回调</span>
            mChoreographer.postCallback(
                Choreographer.CALLBACK_TRAVERSAL,
                mTraversalRunnable,  <span class="hljs-comment">// 执行 performTraversals</span>
                <span class="hljs-literal">null</span>
            )
        }
    }

    <span class="hljs-keyword">val</span> mTraversalRunnable = Runnable {
        doTraversal()
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doTraversal</span><span class="hljs-params">()</span></span> {
        performTraversals()
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 1. 测量</span>
        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec)

        <span class="hljs-comment">// 2. 布局</span>
        performLayout(lp, mWidth, mHeight)

        <span class="hljs-comment">// 3. 绘制</span>
        performDraw()
    }
}
</code></pre>
<h5 data-id="heading-63">4. CALLBACK_COMMIT（提交）</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 提交渲染数据到 RenderThread</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedRenderer</span> {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> {
        <span class="hljs-comment">// 在 CALLBACK_COMMIT 阶段提交</span>
        updateRootDisplayList(view, callbacks)

        <span class="hljs-comment">// 注册 commit 回调</span>
        mChoreographer.postCallback(
            Choreographer.CALLBACK_COMMIT,
            {
                <span class="hljs-comment">// 同步渲染数据</span>
                nSyncAndDrawFrame(mNativeProxy, frameInfo)
            },
            <span class="hljs-literal">null</span>
        )
    }
}
</code></pre>
<h3 data-id="heading-64">Choreographer 工作流程</h3>
<h4 data-id="heading-65">完整的执行流程</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 简化的 Choreographer 源码</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Choreographer</span> {

    <span class="hljs-comment">// 1. 注册回调</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postCallback</span><span class="hljs-params">(callbackType: <span class="hljs-type">Int</span>, action: <span class="hljs-type">Runnable</span>, token: <span class="hljs-type">Any</span>?)</span></span> {
        postCallbackDelayed(callbackType, action, token, <span class="hljs-number">0</span>)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postCallbackDelayed</span><span class="hljs-params">(
        callbackType: <span class="hljs-type">Int</span>,
        action: <span class="hljs-type">Runnable</span>,
        token: <span class="hljs-type">Any</span>?,
        delayMillis: <span class="hljs-type">Long</span>
    )</span></span> {
        <span class="hljs-comment">// 添加到对应类型的队列</span>
        mCallbackQueues[callbackType].addCallbackLocked(action, token)

        <span class="hljs-comment">// 请求 VSync 信号</span>
        scheduleFrameLocked()
    }

    <span class="hljs-comment">// 2. 请求 VSync</span>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleFrameLocked</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> (!mFrameScheduled) {
            mFrameScheduled = <span class="hljs-literal">true</span>

            <span class="hljs-keyword">if</span> (USE_VSYNC) {
                <span class="hljs-comment">// 请求下一个 VSync 信号</span>
                scheduleVsyncLocked()
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 降级：使用普通消息</span>
                <span class="hljs-keyword">val</span> msg = mHandler.obtainMessage(MSG_DO_FRAME)
                mHandler.sendMessageAtTime(msg, nextFrameTime)
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleVsyncLocked</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 向 SurfaceFlinger 请求 VSync 信号</span>
        mDisplayEventReceiver.scheduleVsync()
    }

    <span class="hljs-comment">// 3. 接收 VSync 信号</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameDisplayEventReceiver</span> : <span class="hljs-type">DisplayEventReceiver</span>() {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onVsync</span><span class="hljs-params">(
            timestampNanos: <span class="hljs-type">Long</span>,    <span class="hljs-comment">// VSync 时间戳</span>
            physicalDisplayId: <span class="hljs-type">Long</span>,  <span class="hljs-comment">// 显示器 ID</span>
            frame: <span class="hljs-type">Long</span>              <span class="hljs-comment">// 帧号</span>
        )</span></span> {
            <span class="hljs-comment">// VSync 信号到了！</span>
            mTimestampNanos = timestampNanos
            mFrame = frame

            <span class="hljs-comment">// 发送消息到主线程</span>
            <span class="hljs-keyword">val</span> msg = Message.obtain(mHandler, <span class="hljs-keyword">this</span>)
            msg.setAsynchronous(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// 异步消息，优先处理</span>
            mHandler.sendMessageAtTime(msg, timestampNanos / <span class="hljs-number">1_000_000</span>)
        }

        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {
            <span class="hljs-comment">// 在主线程执行</span>
            doFrame(mTimestampNanos, mFrame)
        }
    }

    <span class="hljs-comment">// 4. 执行一帧</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>, frame: <span class="hljs-type">Long</span>)</span></span> {
        <span class="hljs-keyword">val</span> startNanos = System.nanoTime()

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 按顺序执行四种回调</span>
            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos)
            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos)
            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos)
            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos)
        } <span class="hljs-keyword">finally</span> {
            mFrameScheduled = <span class="hljs-literal">false</span>
        }

        <span class="hljs-comment">// 检查是否掉帧</span>
        <span class="hljs-keyword">val</span> endNanos = System.nanoTime()
        <span class="hljs-keyword">val</span> durationMillis = (endNanos - startNanos) / <span class="hljs-number">1_000_000</span>

        <span class="hljs-keyword">if</span> (durationMillis &gt; mFrameIntervalNanos / <span class="hljs-number">1_000_000</span>) {
            <span class="hljs-comment">// 超过一帧时间，掉帧了！</span>
            <span class="hljs-keyword">val</span> skippedFrames = (durationMillis / (mFrameIntervalNanos / <span class="hljs-number">1_000_000</span>)).toInt()
            Log.w(TAG, <span class="hljs-string">"Skipped <span class="hljs-variable">$skippedFrames</span> frames! The application may be doing too much work on its main thread."</span>)
        }
    }

    <span class="hljs-comment">// 5. 执行回调队列</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doCallbacks</span><span class="hljs-params">(callbackType: <span class="hljs-type">Int</span>, frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
        <span class="hljs-keyword">val</span> callbacks = mCallbackQueues[callbackType]

        <span class="hljs-comment">// 执行该类型的所有回调</span>
        <span class="hljs-keyword">while</span> (callbacks.hasNext()) {
            <span class="hljs-keyword">val</span> callback = callbacks.next()
            callback.run(frameTimeNanos)
        }
    }
}
</code></pre>
<h4 data-id="heading-66">时序图</h4>
<pre><code class="hljs language-scss" lang="scss">应用进程                          SurfaceFlinger 进程
    │                                   │
    │ <span class="hljs-built_in">scheduleTraversals</span>()              │
    ├─ <span class="hljs-built_in">postCallback</span>(TRAVERSAL)          │
    │                                   │
    │ <span class="hljs-built_in">scheduleVsyncLocked</span>()             │
    ├─────── <span class="hljs-built_in">requestVsync</span>() ──────────→ │
    │                                   │
    │ 等待 VSync...                      │ 下一个 VSync 周期到来
    │                                   │
    │ ←────── <span class="hljs-built_in">onVsync</span>() ────────────── │ 📡 VSync 信号
    │                                   │
    │ <span class="hljs-built_in">doFrame</span>()                         │
    ├─ <span class="hljs-built_in">doCallbacks</span>(INPUT)               │
    ├─ <span class="hljs-built_in">doCallbacks</span>(ANIMATION)           │
    ├─ <span class="hljs-built_in">doCallbacks</span>(TRAVERSAL)           │
    │  └─ <span class="hljs-built_in">performTraversals</span>()           │
    │     ├─ measure                    │
    │     ├─ layout                     │
    │     └─ draw                       │
    ├─ <span class="hljs-built_in">doCallbacks</span>(COMMIT)              │
    │  └─ <span class="hljs-built_in">nSyncAndDrawFrame</span>() ─────────→│ 提交渲染数据
    │                                   │
    │                                   ├─ 合成图层
    │                                   └─ 显示到屏幕
</code></pre>
<h3 data-id="heading-67">掉帧（Jank）分析</h3>
<h4 data-id="heading-68">什么是掉帧？</h4>
<pre><code class="hljs">正常情况（60fps）：

Frame 1      Frame 2      Frame 3      Frame 4
├────────────├────────────├────────────├────────
0ms         16.67ms      33.34ms      50ms

每帧耗时 &lt; 16.67ms ✅
</code></pre>
<pre><code class="hljs">掉帧情况：

Frame 1      Frame 2                    Frame 3
├────────────├─────────────────────────├────────
0ms         16.67ms                   50ms

Frame 2 耗时 33.34ms（跨越 2 个 VSync）⚠️
用户感觉卡顿
</code></pre>
<h4 data-id="heading-69">掉帧检测</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Choreographer 内部的掉帧检测</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>, frame: <span class="hljs-type">Long</span>)</span></span> {
    <span class="hljs-keyword">val</span> startNanos = System.nanoTime()

    <span class="hljs-comment">// 计算应该执行的时间</span>
    <span class="hljs-keyword">val</span> intendedFrameTimeNanos = mLastFrameTimeNanos + mFrameIntervalNanos

    <span class="hljs-comment">// 检查延迟</span>
    <span class="hljs-keyword">val</span> jitterNanos = frameTimeNanos - intendedFrameTimeNanos
    <span class="hljs-keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) {
        <span class="hljs-comment">// 掉帧了！</span>
        <span class="hljs-keyword">val</span> skippedFrames = jitterNanos / mFrameIntervalNanos

        <span class="hljs-keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) {  <span class="hljs-comment">// 默认 30 帧</span>
            Log.i(TAG, <span class="hljs-string">"Skipped <span class="hljs-variable">$skippedFrames</span> frames! "</span> +
                  <span class="hljs-string">"The application may be doing too much work on its main thread."</span>)
        }
    }

    <span class="hljs-comment">// 执行回调...</span>

    <span class="hljs-keyword">val</span> endNanos = System.nanoTime()
    <span class="hljs-keyword">val</span> frameDuration = (endNanos - startNanos) / <span class="hljs-number">1_000_000</span>

    Log.d(<span class="hljs-string">"FrameTime"</span>, <span class="hljs-string">"Frame took <span class="hljs-subst">${frameDuration}</span>ms"</span>)
}
</code></pre>
<h4 data-id="heading-70">常见掉帧原因</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 主线程耗时操作 ❌</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
    <span class="hljs-comment">// 不要在主线程做这些：</span>
    <span class="hljs-keyword">val</span> bitmap = BitmapFactory.decodeFile(<span class="hljs-string">"/sdcard/large_image.jpg"</span>)  <span class="hljs-comment">// IO 操作</span>
    <span class="hljs-keyword">val</span> result = complexCalculation()  <span class="hljs-comment">// 复杂计算</span>
    Thread.sleep(<span class="hljs-number">100</span>)  <span class="hljs-comment">// 阻塞线程</span>

    <span class="hljs-comment">// 必然掉帧！⚠️</span>
}

<span class="hljs-comment">// 2. 布局层级过深 ❌</span>
&lt;LinearLayout&gt;
  &lt;RelativeLayout&gt;
    &lt;FrameLayout&gt;
      &lt;LinearLayout&gt;
        &lt;RelativeLayout&gt;
          &lt;!-- <span class="hljs-number">5</span>层嵌套，measure 和 layout 很慢 --&gt;
        &lt;/RelativeLayout&gt;
      &lt;/LinearLayout&gt;
    &lt;/FrameLayout&gt;
  &lt;/RelativeLayout&gt;
&lt;/LinearLayout&gt;

<span class="hljs-comment">// 3. 过度绘制 ❌</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> {
    <span class="hljs-comment">// 多次绘制同一区域</span>
    canvas.drawColor(Color.WHITE)   <span class="hljs-comment">// 背景</span>
    canvas.drawBitmap(bitmap1, ...)  <span class="hljs-comment">// 图层1</span>
    canvas.drawBitmap(bitmap2, ...)  <span class="hljs-comment">// 图层2</span>
    canvas.drawBitmap(bitmap3, ...)  <span class="hljs-comment">// 图层3（完全覆盖）</span>
    <span class="hljs-comment">// 前面的绘制都浪费了！</span>
}

<span class="hljs-comment">// 4. RecyclerView 创建 ViewHolder ❌</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(...)</span></span>: ViewHolder {
    <span class="hljs-comment">// inflate 很慢（8-10ms）</span>
    <span class="hljs-keyword">val</span> view = LayoutInflater.from(context).inflate(R.layout.complex_item, parent, <span class="hljs-literal">false</span>)
    <span class="hljs-comment">// 滚动时创建会掉帧 ← GapWorker 就是解决这个问题！</span>
}
</code></pre>
<h3 data-id="heading-71">与 RecyclerView 的关系</h3>
<p>RecyclerView 和 GapWorker 如何配合：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// RecyclerView 的渲染流程</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RecyclerView</span> {

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(changed: <span class="hljs-type">Boolean</span>, l: <span class="hljs-type">Int</span>, t: <span class="hljs-type">Int</span>, r: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-comment">// 布局子 View</span>
        dispatchLayout()

        <span class="hljs-comment">// 布局完成后，通知 GapWorker 可以预取了</span>
        <span class="hljs-keyword">if</span> (mPrefetchRegistry != <span class="hljs-literal">null</span>) {
            mPrefetchRegistry.collectPrefetchPositions(
                mLayout,
                mState,
                mGapWorker
            )
        }
    }
}

<span class="hljs-comment">// LayoutManager 收集预取位置</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearLayoutManager</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collectAdditionalPrefetchPositions</span><span class="hljs-params">(
        dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>,
        state: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">State</span>,
        layoutPrefetchRegistry: <span class="hljs-type">LayoutPrefetchRegistry</span>
    )</span></span> {
        <span class="hljs-comment">// 在 CALLBACK_ANIMATION 阶段被调用</span>
        <span class="hljs-keyword">val</span> prefetchPosition = getCurrentPosition() + (<span class="hljs-keyword">if</span> (dy &gt; <span class="hljs-number">0</span>) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>)
        layoutPrefetchRegistry.addPosition(prefetchPosition, Math.abs(dy))
    }
}

<span class="hljs-comment">// GapWorker 注册回调</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GapWorker</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postFromTraversal</span><span class="hljs-params">(recyclerView: <span class="hljs-type">RecyclerView</span>, dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>)</span></span> {
        <span class="hljs-comment">// 在 CALLBACK_TRAVERSAL 完成后被调用</span>

        <span class="hljs-comment">// 注册到下一帧的消息队列（不是 Choreographer 回调）</span>
        recyclerView.post(<span class="hljs-keyword">this</span>)
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 在 CALLBACK_COMMIT 之后的空闲时间执行</span>
        <span class="hljs-comment">// 此时一帧的主要工作已完成，可以预取了</span>

        <span class="hljs-keyword">val</span> deadlineNs = System.nanoTime() + <span class="hljs-number">4_000_000</span> <span class="hljs-comment">// 留 4ms</span>
        prefetch(deadlineNs)
    }
}
</code></pre>
<h4 data-id="heading-72">完整的一帧时间线（包含 RecyclerView）</h4>
<pre><code class="hljs language-css" lang="css">VSync 信号
│
├─ <span class="hljs-number">0</span>-<span class="hljs-number">2ms</span>: CALLBACK_INPUT
│  └─ 处理触摸滚动事件
│
├─ <span class="hljs-number">2</span>-<span class="hljs-number">4ms</span>: CALLBACK_ANIMATION
│  ├─ 动画更新
│  └─ LayoutManager.<span class="hljs-built_in">collectPrefetchPositions</span>() ← 收集预取位置
│
├─ <span class="hljs-number">4</span>-<span class="hljs-number">14ms</span>: CALLBACK_TRAVERSAL
│  ├─ RecyclerView.<span class="hljs-built_in">onLayout</span>()
│  ├─ 布局可见的子 View
│  └─ GapWorker.<span class="hljs-built_in">postFromTraversal</span>() ← 注册预取任务
│
├─ <span class="hljs-number">14</span>-<span class="hljs-number">16ms</span>: CALLBACK_COMMIT
│  └─ 提交渲染数据
│
└─ <span class="hljs-number">16ms</span>+: 空闲时间（下一帧之前）
   └─ GapWorker.<span class="hljs-built_in">run</span>() ← 执行预取！✅
      ├─ 创建 ViewHolder (如需要)
      ├─ 绑定数据
      └─ 放入缓存
</code></pre>
<h3 data-id="heading-73">实际应用</h3>
<h4 data-id="heading-74">1. 监控帧率</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FpsMonitor</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mFrameCount = <span class="hljs-number">0</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mLastTime = <span class="hljs-number">0L</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameCallback = <span class="hljs-keyword">object</span> : Choreographer.FrameCallback {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
            mFrameCount++

            <span class="hljs-keyword">val</span> currentTime = System.currentTimeMillis()
            <span class="hljs-keyword">if</span> (currentTime - mLastTime &gt;= <span class="hljs-number">1000</span>) {
                <span class="hljs-comment">// 每秒统计一次</span>
                <span class="hljs-keyword">val</span> fps = mFrameCount
                Log.d(<span class="hljs-string">"FPS"</span>, <span class="hljs-string">"当前帧率: <span class="hljs-variable">$fps</span> fps"</span>)

                <span class="hljs-keyword">if</span> (fps &lt; <span class="hljs-number">55</span>) {
                    Log.w(<span class="hljs-string">"FPS"</span>, <span class="hljs-string">"帧率过低，可能卡顿！"</span>)
                }

                mFrameCount = <span class="hljs-number">0</span>
                mLastTime = currentTime
            }

            <span class="hljs-comment">// 注册下一帧</span>
            Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
        mLastTime = System.currentTimeMillis()
        Choreographer.getInstance().postFrameCallback(mFrameCallback)
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> {
        Choreographer.getInstance().removeFrameCallback(mFrameCallback)
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">val</span> monitor = FpsMonitor()
monitor.start()
</code></pre>
<h4 data-id="heading-75">2. 检测掉帧</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JankDetector</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mLastFrameTimeNanos = <span class="hljs-number">0L</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameIntervalNanos = <span class="hljs-number">16_666_666L</span> <span class="hljs-comment">// 60fps</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameCallback = <span class="hljs-keyword">object</span> : Choreographer.FrameCallback {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
            <span class="hljs-keyword">if</span> (mLastFrameTimeNanos != <span class="hljs-number">0L</span>) {
                <span class="hljs-keyword">val</span> frameDuration = frameTimeNanos - mLastFrameTimeNanos
                <span class="hljs-keyword">val</span> skippedFrames = (frameDuration / mFrameIntervalNanos) - <span class="hljs-number">1</span>

                <span class="hljs-keyword">if</span> (skippedFrames &gt; <span class="hljs-number">0</span>) {
                    Log.w(<span class="hljs-string">"Jank"</span>, <span class="hljs-string">"掉帧 <span class="hljs-variable">$skippedFrames</span> 帧！"</span> +
                          <span class="hljs-string">"耗时: <span class="hljs-subst">${frameDuration / <span class="hljs-number">1</span>_000_000}</span>ms"</span>)

                    <span class="hljs-comment">// 上报到性能监控平台</span>
                    reportJank(skippedFrames, frameDuration)
                }
            }

            mLastFrameTimeNanos = frameTimeNanos

            <span class="hljs-comment">// 继续监听</span>
            Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> {
        Choreographer.getInstance().postFrameCallback(mFrameCallback)
    }
}
</code></pre>
<h4 data-id="heading-76">3. 延迟执行（等待下一帧）</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 等待下一帧再执行</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doOnNextFrame</span><span class="hljs-params">(action: () -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    Choreographer.getInstance().postFrameCallback {
        action()
    }
}

<span class="hljs-comment">// 使用场景：View 刚创建，等布局完成再操作</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyView</span> : <span class="hljs-type">View</span> {
    <span class="hljs-keyword">init</span> {
        doOnNextFrame {
            <span class="hljs-comment">// 此时 View 已经测量和布局完成</span>
            <span class="hljs-keyword">val</span> width = measuredWidth
            <span class="hljs-keyword">val</span> height = measuredHeight
            <span class="hljs-comment">// 可以安全使用尺寸了</span>
        }
    }
}
</code></pre>
<h4 data-id="heading-77">4. 优化动画</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmoothAnimator</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mStartValue = <span class="hljs-number">0f</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mEndValue = <span class="hljs-number">0f</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mStartTime = <span class="hljs-number">0L</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mDuration = <span class="hljs-number">0L</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mFrameCallback = <span class="hljs-keyword">object</span> : Choreographer.FrameCallback {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
            <span class="hljs-keyword">val</span> elapsed = (frameTimeNanos - mStartTime) / <span class="hljs-number">1_000_000</span>
            <span class="hljs-keyword">val</span> fraction = (elapsed.toFloat() / mDuration).coerceIn(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>)

            <span class="hljs-comment">// 计算当前值</span>
            <span class="hljs-keyword">val</span> value = mStartValue + (mEndValue - mStartValue) * fraction

            <span class="hljs-comment">// 更新 UI</span>
            onAnimationUpdate(value)

            <span class="hljs-keyword">if</span> (fraction &lt; <span class="hljs-number">1f</span>) {
                <span class="hljs-comment">// 继续下一帧</span>
                Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>)
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">(from: <span class="hljs-type">Float</span>, to: <span class="hljs-type">Float</span>, duration: <span class="hljs-type">Long</span>)</span></span> {
        mStartValue = from
        mEndValue = to
        mDuration = duration
        mStartTime = System.nanoTime()

        Choreographer.getInstance().postFrameCallback(mFrameCallback)
    }

    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAnimationUpdate</span><span class="hljs-params">(value: <span class="hljs-type">Float</span>)</span></span> {
        <span class="hljs-comment">// 子类实现</span>
    }
}
</code></pre>
<h3 data-id="heading-78">高刷新率屏幕支持</h3>
<h4 data-id="heading-79">90Hz / 120Hz / 144Hz 屏幕</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Android 11+ 可以获取屏幕刷新率</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshRateDetector</span> {

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRefreshRate</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: <span class="hljs-built_in">Float</span> {
        <span class="hljs-keyword">val</span> display = <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) {
            context.display
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">val</span> wm = context.getSystemService(Context.WINDOW_SERVICE) <span class="hljs-keyword">as</span> WindowManager
            wm.defaultDisplay
        }

        <span class="hljs-keyword">return</span> display?.refreshRate ?: <span class="hljs-number">60f</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getFrameIntervalNanos</span><span class="hljs-params">(refreshRate: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Long</span> {
        <span class="hljs-keyword">return</span> (<span class="hljs-number">1_000_000_000</span> / refreshRate).toLong()
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">val</span> refreshRate = detector.getRefreshRate(context)
Log.d(<span class="hljs-string">"Display"</span>, <span class="hljs-string">"屏幕刷新率: <span class="hljs-variable">$refreshRate</span> Hz"</span>)

<span class="hljs-keyword">when</span> {
    refreshRate &gt;= <span class="hljs-number">120f</span> -&gt; {
        <span class="hljs-comment">// 120Hz: 每帧 8.33ms</span>
        <span class="hljs-comment">// 需要更严格的性能优化</span>
    }
    refreshRate &gt;= <span class="hljs-number">90f</span> -&gt; {
        <span class="hljs-comment">// 90Hz: 每帧 11.11ms</span>
    }
    <span class="hljs-keyword">else</span> -&gt; {
        <span class="hljs-comment">// 60Hz: 每帧 16.67ms</span>
    }
}
</code></pre>
<h3 data-id="heading-80">性能优化建议</h3>
<h4 data-id="heading-81">1. 避免在回调中做耗时操作</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 错误</span>
Choreographer.getInstance().postFrameCallback {
    <span class="hljs-keyword">val</span> bitmap = loadLargeBitmap()  <span class="hljs-comment">// IO 操作，很慢</span>
    imageView.setImageBitmap(bitmap)
}

<span class="hljs-comment">// ✅ 正确</span>
lifecycleScope.launch {
    <span class="hljs-keyword">val</span> bitmap = withContext(Dispatchers.IO) {
        loadLargeBitmap()  <span class="hljs-comment">// 在后台线程</span>
    }
    imageView.setImageBitmap(bitmap)  <span class="hljs-comment">// 在主线程</span>
}
</code></pre>
<h4 data-id="heading-82">2. 使用 Systrace 分析</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 抓取 Systrace</span>
python systrace.py -a com.your.package -t 10 -o trace.html \
  gfx view res dalvik <span class="hljs-built_in">sched</span> freq idle

<span class="hljs-comment"># 分析要点：</span>
<span class="hljs-comment"># 1. 查看每一帧的耗时</span>
<span class="hljs-comment"># 2. 找出超过 16.67ms 的帧</span>
<span class="hljs-comment"># 3. 分析是哪个阶段慢（input/animation/traversal/commit）</span>
<span class="hljs-comment"># 4. 定位具体的慢方法</span>
</code></pre>
<h4 data-id="heading-83">3. 减少布局层级</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- ❌ 过深的层级 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>

<span class="hljs-comment">&lt;!-- ✅ 扁平化 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ConstraintLayout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ConstraintLayout</span>&gt;</span>
</code></pre>
<h4 data-id="heading-84">4. 使用硬件加速</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 在 AndroidManifest.xml 中启用 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 为特定 View 启用</span>
view.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="hljs-literal">null</span>)
</code></pre>
<hr/>
<h3 data-id="heading-85">总结</h3>
<h4 data-id="heading-86">RecyclerView 核心要点</h4>
<ol>
<li><strong>四级缓存</strong>：极致的复用机制</li>
<li><strong>ViewHolder</strong>：避免重复 findViewById</li>
<li><strong>精确通知</strong>：告诉 RecyclerView 具体哪里变了</li>
<li><strong>位置管理</strong>：维护复杂的位置映射关系</li>
</ol>
<h4 data-id="heading-87">GapWorker 核心要点</h4>
<ol>
<li><strong>预取机制</strong>：在空闲时间提前准备 ViewHolder</li>
<li><strong>优先级调度</strong>：按距离和紧急程度排序</li>
<li><strong>时间控制</strong>：默认最多占用 4ms</li>
<li><strong>数据一致性</strong>：必须使用精确的 notify 方法</li>
</ol>
<h4 data-id="heading-88">Choreographer 核心要点</h4>
<ol>
<li><strong>编舞者</strong>：协调输入、动画、绘制的时间</li>
<li><strong>VSync 同步</strong>：所有渲染操作对齐到 VSync 信号</li>
<li><strong>四种回调</strong>：INPUT → ANIMATION → TRAVERSAL → COMMIT</li>
<li><strong>掉帧检测</strong>：超过 16.67ms 就会掉帧</li>
</ol>
<h4 data-id="heading-89">三者关系</h4>
<pre><code class="hljs language-objectivec" lang="objectivec">Choreographer (编舞者)
    │
    ├─ <span class="hljs-built_in">CALLBACK_INPUT</span>: 处理触摸滚动
    │
    ├─ <span class="hljs-built_in">CALLBACK_ANIMATION</span>: 收集预取位置
    │
    ├─ <span class="hljs-built_in">CALLBACK_TRAVERSAL</span>: RecyclerView 布局
    │   └─ 使用四级缓存快速复用 ViewHolder
    │
    ├─ <span class="hljs-built_in">CALLBACK_COMMIT</span>: 提交渲染
    │
    └─ 空闲时间: GapWorker 预取
        └─ 避免下一帧创建 ViewHolder 导致掉帧
</code></pre>
<h4 data-id="heading-90">崩溃根本原因</h4>
<p><strong>数据改变和通知不同步，导致位置信息不一致</strong></p>
<ul>
<li>GapWorker 在空闲时间预取</li>
<li>主线程同时删除数据</li>
<li>使用 <code>notifyDataSetChanged()</code> 异步通知</li>
<li>GapWorker 使用旧的位置信息 → 崩溃</li>
</ul>
<p><strong>解决方案</strong>：使用 <code>notifyItemRemoved()</code> 同步更新位置</p>
<hr/>
<blockquote>
<p>文档生成时间：2025-11-10
文档版本：1.0
适用于：Android 开发者深入理解渲染机制</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring AI 实战——提交用于生成的提示词]]></title>    <link>https://juejin.cn/post/7570901172526940195</link>    <guid>https://juejin.cn/post/7570901172526940195</guid>    <pubDate>2025-11-10T09:57:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570901172526940195" data-draft-id="7570909641682321448" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring AI 实战——提交用于生成的提示词"/> <meta itemprop="keywords" content="Spring,AI编程,LLM"/> <meta itemprop="datePublished" content="2025-11-10T09:57:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="数据智能老司机"/> <meta itemprop="url" content="https://juejin.cn/user/430664289626439"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring AI 实战——提交用于生成的提示词
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/430664289626439/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    数据智能老司机
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:57:05.000Z" title="Mon Nov 10 2025 09:57:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">本章内容</h2>
<ul>
<li>定义提示模板（prompt templates）</li>
<li>提供上下文</li>
<li>格式化响应输出</li>
<li>流式传输响应</li>
<li>访问响应元数据</li>
</ul>
<p>在第 1 章中，你创建了一个非常简单的 Spring AI 应用：它在 POST 请求里接收一个问题，并通过注入的 <code>ChatClient</code> 直接提交给 LLM。它运行良好，但随着你的生成式 AI 需求变得更高级，你发给 LLM 的提示也会随之复杂化。此时，基于 <code>String</code> 的提示可能就不够用了。</p>
<p>另外，生成的响应也不仅仅是一个简单的字符串。结果中可能包含有用的<strong>元数据</strong>，例如<strong>用量数据</strong>，帮助你评估每次生成对计费的影响。响应还可以<strong>分片流式返回</strong>给客户端，而不是一次性返回完整结果。</p>
<p>本章将把你的提示与响应处理提升到新水平。先从<strong>如何定义提示模板</strong>开始。</p>
<h2 data-id="heading-1">3.1 使用提示模板（Working with prompt templates）</h2>
<p>Spring AI 支持<strong>从模板创建提示</strong>。模板由固定文本与一个或多个<strong>占位符</strong>组成。如图 3.1 所示，这些模板的占位符将由“模型数据”在每次调用时填充，以生成要发送给 LLM 的提示。模型数据被填入占位符，外层由提示文本包裹，引导 LLM 应当如何作答。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe4e4863ad35460fa114d776132969b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=2FSRnk0GhyxxCAGTmkdzD7RccC8%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 3.1</strong> 使用提示模板由模型数据生成提示</p>
<p>为了演示提示模板如何工作，我们从第 1 章的示例出发，把它扩展为能回答各类<strong>桌面游戏</strong>（如跳棋、Monopoly，或更现代的欧式桌游如 Catan、Wingspan）的问答。</p>
<p>首先，需要在 <code>Question</code> 记录类型中加入<strong>游戏标题</strong>：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.boardgamebuddy</span>;

<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">jakarta</span><span class="hljs-selector-class">.validation</span><span class="hljs-selector-class">.constraints</span><span class="hljs-selector-class">.NotBlank</span>;

<span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">record</span> <span class="hljs-selector-tag">Question</span>(
    <span class="hljs-variable">@NotBlank</span>(message = <span class="hljs-string">"Game title is required"</span>) String gameTitle,
    <span class="hljs-variable">@NotBlank</span>(message = <span class="hljs-string">"Question is required"</span>) String question) {
}
</code></pre>
<p>这个新版 <code>Question</code> 增加了 <code>gameTitle</code> 属性，用于承载游戏名。这样即便问题本身未提到游戏名，也能提供足够上下文来回答关于某款游戏的提问。</p>
<p>你也会注意到两个属性都标注了 <code>@NotBlank</code>。虽然<strong>校验</strong>不是 Spring AI 的特性，但它是 Spring 本身非常重要且有用的功能。用 <code>@NotBlank</code> 声明它们都是<strong>必填</strong>的，且不能为 <code>null</code> 或去空白后变成空字符串。</p>
<p>要启用 <code>@NotBlank</code> 以及 Spring 的校验支持，需要在构建中加入如下 starter 依赖：</p>
<pre><code class="hljs language-arduino" lang="arduino">implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-validation'</span>
</code></pre>
<p>同时，需要在控制器的 <code>ask()</code> 方法里给 <code>Question</code> 参数添加 <code>@Valid</code>，以便 Spring 在处理该控制器的请求时执行校验：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@PostMapping</span>(path=<span class="hljs-string">"/ask"</span>, produces=<span class="hljs-string">"application/json"</span>)
public Answer <span class="hljs-built_in">ask</span>(<span class="hljs-variable">@RequestBody</span> <span class="hljs-variable">@Valid</span> Question question) {
  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">boardGameService</span><span class="hljs-selector-class">.askQuestion</span>(question);
}
</code></pre>
<p>最后，为了把校验错误<strong>整齐地</strong>以 JSON 形式返回，下面的控制器增强（advice）类利用了 Spring 对 <strong>Problem Details（RFC-7807）</strong> 的支持（<a href="https://link.juejin.cn?target=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc7807" target="_blank" title="https://datatracker.ietf.org/doc/html/rfc7807" ref="nofollow noopener noreferrer">datatracker.ietf.org/doc/html/rf…</a>）。</p>
<p><strong>清单 3.1 使用 Problem Details 优雅返回校验错误</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.context.MessageSourceResolvable;
<span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;
<span class="hljs-keyword">import</span> org.springframework.http.ProblemDetail;
<span class="hljs-keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.ExceptionHandler;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestControllerAdvice;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-meta">@RestControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHandlerAdvice</span> {

  <span class="hljs-meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span>
  <span class="hljs-keyword">public</span> ProblemDetail handleValidationExceptions(
                              MethodArgumentNotValidException ex) {
    <span class="hljs-keyword">var</span> problemDetail =  ProblemDetail
        .forStatusAndDetail(HttpStatus.BAD_REQUEST, <span class="hljs-string">"Validation failed"</span>);

    <span class="hljs-keyword">var</span> validationMessages = ex.getBindingResult().getAllErrors()
        .stream()
        .map(MessageSourceResolvable::getDefaultMessage)
        .toList();

    problemDetail.setProperty(<span class="hljs-string">"validationErrors"</span>, validationMessages);
    <span class="hljs-keyword">return</span> problemDetail;
  }

}
</code></pre>
<p>简而言之，<strong>Problem Details</strong> 是一种对 HTTP API 错误进行<strong>标准化结构化</strong>的规范。自 Spring 6.0 起，Spring 就提供了一等的 Problem Details 支持。当应用了 Problem Details 且<strong>校验失败</strong>（例如请求未提供游戏名）时，客户端会收到类似这样的标准响应：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"detail"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Validation failed"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"instance"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/ask"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"status"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">400</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"title"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Bad Request"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"about:blank"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"validationErrors"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"Game title is required"</span>
    <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>现在把注意力转向<strong>响应</strong>。与 <code>Question</code> 一样，你还希望在 <code>Answer</code> 记录类型中加入<strong>游戏标题</strong>，让 API 客户端知道这条答案对应的是哪款游戏：</p>
<pre><code class="hljs language-arduino" lang="arduino">package com.example.boardgamebuddy;

<span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Answer</span><span class="hljs-params">(<span class="hljs-type">String</span> gameTitle, <span class="hljs-type">String</span> answer)</span> </span>{
}
</code></pre>
<p>既然 <code>Question</code> 与 <code>Answer</code> 都包含了游戏名，你可以把 <code>SpringAiBoardGameService</code> 中的 <code>askQuestion()</code> 简化为<strong>字符串拼接</strong>生成提示：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-title class_">Answer</span> <span class="hljs-title function_">askQuestion</span>(<span class="hljs-params">Question question</span>) {
  <span class="hljs-title class_">String</span> prompt =
      <span class="hljs-string">"Answer this question about "</span> + question.<span class="hljs-title function_">gameTitle</span>() +
      <span class="hljs-string">": "</span> + question.<span class="hljs-title function_">question</span>();

  <span class="hljs-title class_">String</span> answerText = chatClient.<span class="hljs-title function_">prompt</span>()
      .<span class="hljs-title function_">user</span>(prompt)
      .<span class="hljs-title function_">call</span>()
      .<span class="hljs-title function_">content</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Answer</span>(question.<span class="hljs-title function_">gameTitle</span>(), answerText);
}
</code></pre>
<p>现在可以在请求中带上游戏名来提问了。比如用 HTTPie 向经典的 <strong>checkers（跳棋）</strong> 提问：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"checkers"</span> \
question=<span class="hljs-string">"How many pieces are there?"</span> -b
{
  <span class="hljs-string">"answer"</span>: <span class="hljs-string">"In checkers, there are a total of 24 pieces-12 for each player."</span>,
  <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"checkers"</span>
}
</code></pre>
<p>底层 LLM 能基于自身训练回答关于跳棋的问题。这种方式适用于<strong>知名游戏</strong>（如跳棋、国际象棋）；但对于<strong>较新/不那么出名</strong>的游戏可能会吃力。下一章我们会看到如何让 LLM 回答<strong>超出其训练范围</strong>的问题。</p>
<p>虽然能用，但通过<strong>字符串拼接</strong>来构建提示很笨拙。即便是 <code>askQuestion()</code> 中这样简单的提示，也会让代码读写不便。</p>
<h3 data-id="heading-2">3.1.1 定义提示模板（Defining a prompt template）</h3>
<p>与其用字符串拼接，不如创建一个<strong>提示模板</strong>，把“原始、未渲染的提示”写成带占位符的模板。下面清单展示了修改后的 <code>SpringAiBoardGameService</code>，它使用了模板化提示。</p>
<p><strong>清单 3.2 使用提示模板，避免笨拙的字符串拼接</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BoardGameService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringAiBoardGameService</span><span class="hljs-params">(ChatClient.Builder chatClientBuilder)</span> {
    <span class="hljs-built_in">this</span>.chatClient = chatClientBuilder.build();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">questionPromptTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-string">"""
      Answer this question about {game}: {question}
      """</span>;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Answer <span class="hljs-title function_">askQuestion</span><span class="hljs-params">(Question question)</span> {
    <span class="hljs-type">var</span> <span class="hljs-variable">answerText</span> <span class="hljs-operator">=</span> chatClient.prompt()
        .user(userSpec -&gt; userSpec
            .text(questionPromptTemplate)
            .param(<span class="hljs-string">"gameTitle"</span>, question.gameTitle())
            .param(<span class="hljs-string">"question"</span>, question.question()))
        .call()
        .content();

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Answer</span>(question.gameTitle(), answerText);
  }

}
</code></pre>
<p>如你所见，名为 <code>questionPromptTemplate</code> 的提示模板看起来与此前拼接出来的提示很像，但它不仅仅是文本。它是一个 <strong>StringTemplate</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.stringtemplate.org%2F" target="_blank" title="https://www.stringtemplate.org/" ref="nofollow noopener noreferrer">www.stringtemplate.org/</a>），其中包含每个参数的占位符<code>{game}</code> 与 <code>{question}</code>。</p>
<p>由于存在占位符，这个模板<strong>不能</strong>直接作为普通字符串提交；你还必须<strong>提供用于填充占位符的值</strong>。</p>
<p>因此，在 <code>askQuestion()</code> 中，<code>user()</code> 不是接收模板字符串本身，而是接收一个<strong>lambda</strong>。更具体地说，这个 lambda 实现了 <code>Consumer&lt;UserSpec&gt;</code> 接口，让你能<strong>定制</strong>要发送给 LLM 的消息。</p>
<p>在本例中，通过在 <code>userSpec</code> 上调用 <code>text()</code> 指定用户消息的正文（也就是提示模板），再通过多次调用 <code>param()</code> 为每个参数设置值。在提示发送给 LLM 之前，占位符会被这些参数值<strong>填充</strong>，从而形成完整的提示消息。图 3.2 演示了这个过程。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3796ed3650564abf8d3a03690500a0dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=y%2F72E1HNRGn4RHmbAwIYaQxATuQ%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 3.2</strong> 提示模板把模型数据渲染进提示，再提交给 LLM</p>
<p><code>askQuestion()</code> 余下的代码与之前相同：<code>call()</code> 表示提示已准备就绪并发送；<code>content()</code> 返回答案文本。</p>
<p>重新启动应用，再次提交请求，它应当像之前一样工作（由于生成式 AI 的<strong>非确定性</strong>，回答的措辞可能略有变化）。你也可以试着询问<strong>其他桌游</strong>来看看回答情况。</p>
<p>现在，提示的核心集中在一个地方——那个<strong>静态字符串常量</strong>——可读且易维护，尽管在 <code>askQuestion()</code> 里多了几行代码。既然更易维护了，我们就做点<strong>提示工程（prompt engineering）</strong> ，把模板再优化一下。例如改为：</p>
<pre><code class="hljs language-ini" lang="ini">private static final String <span class="hljs-attr">questionPromptTemplate</span> = <span class="hljs-string">"""
    You are a helpful assistant, answering questions about tabletop games.
    If you don't know anything about the game or don't know the answer,
    say "I don't know".

    The game is {game}.

    The question is: {question}.
    """</span><span class="hljs-comment">;</span>
</code></pre>
<p>这个新模板为 LLM 设置了更多<strong>角色与期望上下文</strong>：告诉它自己是一个有用的助手、要回答<strong>桌面游戏</strong>相关的问题；还要求它在不知道答案或不了解该游戏时<strong>明确承认不知道</strong>。</p>
<p>像这样的小小提示工程技巧，能帮助你从提示中获得更好的结果。更多提示工程建议可参考 <strong>Prompt Engineering Guide</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.promptingguide.ai%2F" target="_blank" title="https://www.promptingguide.ai/" ref="nofollow noopener noreferrer">www.promptingguide.ai/</a>）。</p>
<h3 data-id="heading-3">3.1.2 将模板作为资源导入（Importing the template as a resource）</h3>
<p>把提示模板的字符串提取成常量，有助于整理 <code>askQuestion()</code> 方法，让代码更易读、也更便于调整提示。但你还能再进一步：把模板<strong>抽到外部文件</strong>。这样既能让模板与 Java 源码分离，又仍可将模板纳入代码仓库管理。</p>
<p>为此，先在项目的 <code>src/main/resources</code> 目录下创建名为 <strong><code>promptTemplates</code></strong> 的新目录。在新目录里创建文件 <strong><code>questionPromptTemplate.st</code></strong>，内容如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">You are a helpful assistant, answering questions about tabletop games.
<span class="hljs-keyword">If</span> you don<span class="hljs-comment">'t know anything about the game or don't know the answer,</span>
say <span class="hljs-string">"I don't know"</span>.

Answer <span class="hljs-keyword">in</span> complete sentences.

The game <span class="hljs-built_in">is</span> {gameTitle}.

The question <span class="hljs-built_in">is</span>: {question}.
</code></pre>
<p><strong>NOTE</strong> 目录名与模板文件名可以随意取；只要在把模板注入到 <code>SpringAiBoardGameService</code> 时<strong>正确引用</strong>即可。</p>
<p>（尽管你把代码提交到 GitHub 时它可能会提示别的），扩展名 <strong><code>.st</code></strong> 表示这是一个 <strong>StringTemplate</strong> 文件（并不是 Smalltalk 文件）。可以看到，这个 StringTemplate 文件的文本与之前定义的静态字符串常量相同。但现在模板在独立文件中，模板的细节可与“提交提示的代码”分开维护。</p>
<p>基于此，你需要修改 <code>SpringAiBoardGameService</code> 来引用该模板文件。删除静态字符串常量，改为如下字段：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/promptTemplates/questionPromptTemplate.st"</span>)</span>
Resource questionPromptTemplate;
</code></pre>
<p><code>@Value</code> 注解使用 <code>classpath:</code> 前缀来引用模板文件，本质上是把它注入到一个 <code>Resource</code> 属性中。注意，这个 <code>Resource</code> 属性的名字与原先的字符串常量相同。<code>user</code> 规格的 <code>text()</code> 方法是<strong>重载</strong>的，既可接受 <code>String</code>，也可接受 <code>Resource</code>。因此把该 <code>Resource</code> 命名为 <code>questionPromptTemplate</code> 后，你<strong>无需修改</strong> <code>askQuestion()</code> 方法里对模板的使用。</p>
<p>重启应用，继续就游戏提问；行为依旧与之前相同。尽管应用外在行为没变，但内部实现更整洁；对模板的任何调整，都可以与 <code>SpringAiBoardGameService</code> 代码<strong>解耦</strong>地完成。</p>
<p>如果你询问 checkers、chess 或其他知名游戏，很可能会得到正确答案。但假设你问的是模型未被训练过的游戏。例如试着询问纸牌游戏 <strong>Burger Battle</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.burgerbattlegame.com%2F" target="_blank" title="https://www.burgerbattlegame.com/" ref="nofollow noopener noreferrer">www.burgerbattlegame.com/</a>）。理想情况下，如果它不知道答案，它会说 “I don't know”：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"Burger Battle"</span> \
question=<span class="hljs-string">"What is the Grave Digger card?"</span> -b
{
    <span class="hljs-string">"answer"</span>: <span class="hljs-string">"I don't know."</span>,
    <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"Burger Battle"</span>
}
</code></pre>
<p>尽管模板明确要求“不会就说 I don't know”，你仍有相当概率得到<strong>瞎编</strong>的答案：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"Burger Battle"</span> \
question=<span class="hljs-string">"What is the Destroy card?"</span> -b
{
  <span class="hljs-string">"answer"</span>: <span class="hljs-string">"In Burger Battle, the Destroy card is a special card that allows
      players to eliminate one ingredient card from an opponent's burger."</span>,
  <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"Burger Battle"</span>
}
</code></pre>
<p>如果你玩过——或读过——Burger Battle 的规则，你会知道这答案是<strong>错误的</strong>。这就是与 LLM 共事时一个不太妙、但有时颇具“喜剧效果”的特性：当它对某话题训练不足时，可能<strong>编造</strong>一个完全不真实的答案——通常称为<strong>幻觉（hallucinations）</strong> 。</p>
<p>避免幻觉的几种方式包括：</p>
<ul>
<li>训练你自己的模型</li>
<li>对现有模型进行微调（fine-tuning）</li>
<li>在提示中提供<strong>额外上下文</strong></li>
</ul>
<p>从根本上说，训练或微调（更不用说能基于私有数据定制模型）是避免幻觉的上策，但这很难，且需要<strong>数据科学</strong>领域的技能而非软件开发技能。此外，训练/微调要想做得好，需要<strong>大量数据</strong>，也非常耗时——可能是数小时、数天，甚至数周。以我们构建的桌游示例为例，因应新品发布<strong>立即</strong>为其“加入一个游戏”的做法就不可行。</p>
<p>相较之下，在提示中添加<strong>一些上下文</strong>几乎就像添加问题本身那样简单——在提交提示的<strong>即时</strong>阶段完成。因此，它比训练/微调要<strong>简单得多</strong>。</p>
<p>下面看看如何在提示中连同问题一起提供<strong>额外上下文</strong>。这将为下一章的 <strong>RAG（检索增强生成）</strong> 做铺垫——RAG 是一种更高级的方法，能在不超限的情况下为提示添加相关上下文。</p>
<h2 data-id="heading-4">3.2 用上下文“填充”提示（Stuffing the prompt with context）</h2>
<p>回想你上学时，可能遇到过<strong>开卷考试</strong>。这时，你不必把所有内容<strong>死记</strong>在脑子里：即便你没复习，也能翻书找到过关所需的答案。</p>
<p>在生成式 AI 中，常被称为 <strong>“stuffing the prompt（填充提示）”</strong> 的技巧，就像给 LLM 进行一次“开卷考试”。除了把问题提交给 LLM 生成外，你还提供一段<strong>额外文本</strong>供它参考。这样，LLM 即便未在该主题上预训练，也能回答相关问题。</p>
<p>为了让 <strong>Board Game Buddy</strong> 能准确回答 <strong>Burger Battle</strong>（LLM 未训练过的游戏）的问题，我们给它来一场“开卷”：把<strong>游戏规则</strong>作为上下文加入提示。最直接的方式是创建一个<strong>纯文本文件</strong>来存放该游戏规则。</p>
<p><strong>Burger Battle</strong> 的规则（<a href="https://link.juejin.cn?target=https%3A%2F%2Fmng.bz%2FyNKo" target="_blank" title="https://mng.bz/yNKo" ref="nofollow noopener noreferrer">mng.bz/yNKo</a>）相对较短，但仍然太长，不适合原文印在书里。至少，为了让 LLM 能回答 Destroy 卡或其他战斗卡相关问题，创建一个包含以下内容的文件：</p>
<pre><code class="hljs language-python" lang="python">* Burger Bomb: Blow up another playe<span class="hljs-string">r's Burger by sending their ingredients
to the Graveyard.
* Burger Force Field: Your Burger is now protected from all Battle Cards
* Burgerpocalypse: Obliterate all players'</span> ingredients, including your own,
<span class="hljs-keyword">and</span> toss them <span class="hljs-keyword">in</span> the Graveyard.
* Destroy!: Destroy <span class="hljs-built_in">any</span> Battle Card of yours <span class="hljs-keyword">or</span> another playe<span class="hljs-string">r's and toss
it in the Graveyard.
* Gonna Eat That?: Steal another player'</span>s ingredient <span class="hljs-keyword">and</span> add it to your
Burger.
* Grave Digger: Dig through the Graveyard <span class="hljs-keyword">for</span> <span class="hljs-built_in">any</span> needed ingredient <span class="hljs-keyword">and</span> add
it to your Burger.
* I Got Nothin<span class="hljs-string">': Toss your hand in the Graveyard and draw 5 new cards
* More Meat!: Make another player'</span>s Burger a double-decker by adding an
extra Meat to their ingredients <span class="hljs-built_in">list</span>.
* Pickle Plague: Rain vengeance down upon another player by adding Pickles
to their ingredients <span class="hljs-built_in">list</span>.
* Picky Eater: Throw another playe<span class="hljs-string">r's Lettuce, Tomato, or Onion in the
Graveyard.
* The Old Switcheroo: Trade hands with another player.
* Yours Looks Good!: Trade your Burger and all of your ingredients with
another player, including added Battle Cards.
</span></code></pre>
<p>把这个文件放到 <code>src/main/resources</code> 下新建的 <strong><code>gameRules</code></strong> 目录，命名为 <strong><code>burger_battle.txt</code></strong>。</p>
<p>接下来，需要修改模板，加入一个<strong>规则占位符</strong>：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">You are a helpful assistant, answering questions about tabletop games.
<span class="hljs-keyword">If</span> available, use the rules <span class="hljs-keyword">in</span> the RULES section below.
<span class="hljs-keyword">If</span> you don<span class="hljs-comment">'t know anything about the game or don't know the answer,</span>
say <span class="hljs-string">"I don't know"</span>.

Answer <span class="hljs-keyword">in</span> complete sentences.

The game <span class="hljs-built_in">is</span> {gameTitle}.

The question <span class="hljs-built_in">is</span>: {question}.

<span class="hljs-symbol">RULES:</span>
{rules}
</code></pre>
<p>注意，除了新增 <code>{rules}</code> 占位符之外，文本中还加入了<strong>指令</strong>，告诉 LLM：如果有规则可用，请使用它们。</p>
<p>在把规则注入提示之前，需要先把规则<strong>读入一个字符串</strong>。为此，创建一个类似下方清单的服务类。</p>
<p><strong>清单 3.3 <code>GameRulesService</code> 将游戏规则加载为字符串</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.core.io.DefaultResourceLoader;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.nio.charset.Charset;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameRulesService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOG</span> <span class="hljs-operator">=</span>
      LoggerFactory.getLogger(GameRulesService.class);

  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRulesFor</span><span class="hljs-params">(String gameName)</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-type">var</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> String.format(
          <span class="hljs-string">"classpath:/gameRules/%s.txt"</span>,
          gameName.toLowerCase().replace(<span class="hljs-string">" "</span>, <span class="hljs-string">"_"</span>));

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultResourceLoader</span>()
          .getResource(filename)
          .getContentAsString(Charset.defaultCharset()); \
           } <span class="hljs-keyword">catch</span> (IOException e) {
      LOG.info(<span class="hljs-string">"No rules found for game: "</span> + gameName);
      <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
    }
  }

}
</code></pre>
<p>简而言之，<code>getRulesFor()</code> 会通过 <code>Resource</code> 把某个游戏的规则<strong>加载为字符串</strong>。由于资源路径会随游戏名变化，无法像模板那样用 <code>@Value</code> 固定注入，因此 <code>getRulesFor()</code> 借助了一些 Spring 的工具类来构造 <code>Resource</code>。</p>
<p>在构造规则路径时，<code>getRulesFor()</code> 会把游戏标题<strong>转为小写</strong>并把空格替换为下划线，避免因大小写或空格差异导致标题与文件名不一致。例如如果 <code>Question</code> 中传入的游戏名是 “Burger battle”，它会被规范化为 <code>burger_battle</code>。</p>
<p>现在可以修改 <code>SpringAiBoardGameService</code>，把规则加入提示。首先把 <code>GameRulesService</code> 注入进来：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameService</span> <span class="hljs-title">implements</span> <span class="hljs-title">BoardGameService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> GameRulesService gameRulesService;

  <span class="hljs-keyword">public</span> SpringAiBoardGameService(
      ChatClient.Builder chatClientBuilder,
      GameRulesService gameRulesService) {
    <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.build();
    <span class="hljs-keyword">this</span>.gameRulesService = gameRulesService;
  }

  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>然后，修改 <code>askQuestion()</code>，调用 <code>GameRulesService</code> 读取规则，并通过再调用一次 <code>param()</code> 把规则作为参数加入用户消息规格：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Override</span>
public Answer <span class="hljs-built_in">askQuestion</span>(Question question) {
  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">gameRules</span> = <span class="hljs-selector-tag">gameRulesService</span><span class="hljs-selector-class">.getRulesFor</span>(question.<span class="hljs-built_in">gameTitle</span>());

  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">answerText</span> = <span class="hljs-selector-tag">chatClient</span><span class="hljs-selector-class">.prompt</span>()
      <span class="hljs-selector-class">.user</span>(userSpec -&gt; userSpec
          .<span class="hljs-built_in">text</span>(questionPromptTemplate)
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"gameTitle"</span>, question.<span class="hljs-built_in">gameTitle</span>())
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"question"</span>, question.<span class="hljs-built_in">question</span>())
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"rules"</span>, gameRules))
      <span class="hljs-selector-class">.call</span>()
      <span class="hljs-selector-class">.content</span>();

  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Answer</span>(question.<span class="hljs-built_in">gameTitle</span>(), answerText);
}
</code></pre>
<p>现在可以试一试了。重启应用，再次询问 Burger Battle 的 <strong>Destroy</strong> 卡：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"Burger Battle"</span> \
question=<span class="hljs-string">"What is the Destroy card?"</span> -b
{
  <span class="hljs-string">"answer"</span>: <span class="hljs-string">"The Destroy card in Burger Battle allows you to destroy any
      Battle Card, whether it belongs to you or another player, and then
      place it in the Graveyard."</span>,
  <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"Burger Battle"</span>
}
</code></pre>
<p>太棒了！这次答案<strong>正确</strong>，而且显然是从提示中给定的<strong>上下文</strong>抽取出来的。</p>
<p>为确保其他游戏也能正常回答，再试一次。这次问 <strong>chess</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/ask gameTitle=<span class="hljs-string">"chess"</span> \
question=<span class="hljs-string">"How are knights allowed to move?"</span> -b
{
  <span class="hljs-string">"answer"</span>: <span class="hljs-string">"In chess, knights move in an L-shape: two squares in one
      direction, and then one square perpendicular to that. Knights are the
      only pieces that can jump over other pieces on the board."</span>,
  <span class="hljs-string">"gameTitle"</span>: <span class="hljs-string">"chess"</span>
}
</code></pre>
<p>即使应用<strong>没有</strong>从资源中加载国际象棋的规则，模型也能回答，因为它已在训练中学过国际象棋规则。</p>
<p>需要理解的是：<strong>更多上下文</strong>意味着提示中会有<strong>更多输入 token</strong>。例如提问国际象棋时没有额外上下文，提示只有 <strong>75 个 token</strong>；而 Burger Battle 的问题（即便只包含一小段规则）提示 token 数是 <strong>315</strong> —— 是无上下文时的 <strong>4 倍多</strong>。</p>
<p>至少，token 数会影响<strong>成本</strong>：提示（以及响应）中的 token 越多，付费就越多。很多 LLM（如 GPT-4o）在每 1,000 token 的价格上非常便宜，但随着使用时间增长，也会累积。</p>
<p>更进一步，如果提示里 token 太多，可能会<strong>超出上下文窗口</strong>的限制。以 GPT-4o 为例，窗口为 <strong>128K</strong> token，远超我们这个简单示例的需求。大多数桌游的规则都能轻松落在 128K 内，但在其他领域，把大体量文档作为上下文就<strong>很可能</strong>超限。</p>
<p>在下一章里，你将学习如何使用 <strong>RAG（检索增强生成）</strong> ，在不超限的情况下，为提示提供<strong>相关的上下文</strong>。在引入 RAG 之前，关于提示我们还有一些内容要探索，比如<strong>提示角色（prompt roles）</strong> 的用法。</p>
<h2 data-id="heading-5">3.3 为提示分配角色（Assigning prompt roles）</h2>
<p>包括 OpenAI、MistralAI、Anthropic 在内的许多 LLM，都支持把一个提示切分为多条<strong>消息</strong>，每条消息都归属于某个<strong>角色</strong>，模型应按该角色来理解这段内容。常见的角色包括：</p>
<ul>
<li><strong>User（用户）</strong> ——来自应用用户（或代表用户）的提问或陈述。</li>
<li><strong>System（系统）</strong> ——应用本身给 LLM 的指令。</li>
<li><strong>Assistant（助手）</strong> ——LLM 的响应内容。</li>
<li><strong>Tool（工具）</strong> ——调用外部工具以执行某些操作或获取额外上下文的指令。</li>
</ul>
<p>现在我们先聚焦 <strong>user</strong> 与 <strong>system</strong> 消息。<strong>assistant</strong> 消息在与 LLM 的<strong>多轮对话</strong>中才会用到，第 5 章会详细讨论。第 6 章则会看到 <strong>tool</strong> 消息如何通过对接 API 让 AI 交互更具动态性。</p>
<blockquote>
<p><strong>NOTE</strong> 并非所有 LLM API 都支持相同的消息角色选择。如果某个 API 不支持 <strong>System</strong> 角色，Spring AI 会把原本用于 System 角色的文本直接合并进 <strong>User</strong> 消息里。</p>
</blockquote>
<p>到目前为止，我们一直通过 <code>user()</code> 方法来指定提示，也就是说，这些提示在语义上都属于<strong>用户消息</strong>。例如，在当前代码基础上询问“checkers（跳棋）有多少棋子”，Spring AI 会向 OpenAI 发送如下 JSON（作为 POST 请求体）：</p>
<pre><code class="hljs language-swift" lang="swift">{
  <span class="hljs-string">"messages"</span>: [
    {
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"You are a helpful assistant, answering questions about
          tabletop games.<span class="hljs-subst">\n</span>If available, use the rules in the RULES section
          below.<span class="hljs-subst">\n</span>If you don't know anything about the game or don't know the
          answer,<span class="hljs-subst">\n</span>say "</span><span class="hljs-type">I</span> don't know<span class="hljs-string">".<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>The game is checkers.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>The
          question is: How many pieces are there?.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>RULES:<span class="hljs-subst">\n</span>"</span>,
      <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>
    }
  ],
  <span class="hljs-string">"model"</span>: <span class="hljs-string">"gpt-4o"</span>,
  <span class="hljs-string">"stream"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.7</span>
}
</code></pre>
<p>可以看到这里只有一条消息，内容是整个提示，角色是 <strong>user</strong>。这能工作，但<strong>还能更好</strong>。</p>
<h4 data-id="heading-6">检查 Spring AI 的请求与响应</h4>
<p>如果你想查看使用 Spring AI 提交提示时的<strong>原始请求与响应 JSON</strong>，可以在项目里加入 Logbook（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzalando%2Flogbook" target="_blank" title="https://github.com/zalando/logbook" ref="nofollow noopener noreferrer">github.com/zalando/log…</a>）依赖：</p>
<pre><code class="hljs language-arduino" lang="arduino">implementation <span class="hljs-string">'org.zalando:logbook-spring-boot-starter:3.9.0'</span>
</code></pre>
<p>该依赖会为 Spring 自动配置一些组件，用来拦截并记录通过这些组件发起的 HTTP 请求与返回的响应。</p>
<p>Spring AI 的 <code>ChatClient</code> 底层用的是 Spring 的 <strong>RestClient</strong>，因此你需要声明一个 <code>RestClientCustomizer</code> bean，把 Logbook 的 <code>LogbookClientHttpRequestInterceptor</code> 加为请求拦截器：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Bean</span>
<span class="hljs-title class_">RestClientCustomizer</span> <span class="hljs-title function_">logbookCustomizer</span>(<span class="hljs-params">
        LogbookClientHttpRequestInterceptor interceptor</span>) {
  <span class="hljs-keyword">return</span> restClient -&gt; restClient.<span class="hljs-title function_">requestInterceptor</span>(interceptor);
}
</code></pre>
<p>Logbook 以 <strong>TRACE</strong> 级别记录请求与响应细节，因此需要在 <code>application.properties</code> 中设置日志级别：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">logging.level.org.zalando.logbook: TRACE</span>
</code></pre>
<p>默认情况下，Logbook 以 <strong>JSON</strong> 格式输出日志，可读性一般；可选地，你可以把 <code>logbook.format.style</code> 设为 <code>http</code> 来提升可读性：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">logbook.format.style</span>=http
</code></pre>
<p>配置完成后，Spring AI 与各 AI API 之间的请求与响应都会被记录，便于检查。需要注意：Spring AI 的 <strong>Gemini</strong> 模块使用 Google 自有的 HTTP 客户端库而非 RestClient，因此如果选择 Google Gemini 作为 LLM，Logbook 将<strong>无法</strong>拦截其请求。</p>
<p>如图 3.3 所示，我们可以把消息内容拆成两条：其中大部分文本实际是<strong>给 LLM 的指令</strong>，用于指导它如何回答用户问题，因此更合适做成 <strong>system</strong> 消息；真正来自用户的只有<strong>那个问题本身</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6dd859ae2d244eb3aacee01c0b90cc0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=JCS2SqX8wZpL0QS%2FP%2BvHkWaPFcs%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 3.3</strong> 将原先的用户消息拆分为独立的 system 与 user 消息</p>
<p>要把这个变更应用到项目中，先在模板目录新增一个 <strong><code>systemPromptTemplate.st</code></strong> 文件，用它替代原先的 <code>questionPromptTemplate.st</code>（后者不再使用，可以删除）。新的 system 模板内容如下：</p>
<pre><code class="hljs language-markdown" lang="markdown">You are a helpful assistant, answering questions about the tabletop
game named {gameTitle}. If available, use the rules in the RULES 
section below.

Answer in complete sentences.

<span class="hljs-section">RULES
-----</span>
{rules}
</code></pre>
<p>接下来需要调整 <code>SpringAiBoardGameService</code>，让它使用这个<strong>新模板</strong>而非旧的 question 模板。用下面的字段替换掉类中现有的模板 <code>Resource</code> 属性：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/promptTemplates/systemPromptTemplate.st"</span>)</span>
Resource promptTemplate;
</code></pre>
<p>最后，对 <code>askQuestion()</code> 方法做一些变更以使用新模板。新版本如下（<strong>清单 3.4 将提示拆分为独立的 user 与 system 消息</strong>）：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Override</span>
public Answer <span class="hljs-built_in">askQuestion</span>(Question question) {
  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">gameRules</span> = <span class="hljs-selector-tag">gameRulesService</span><span class="hljs-selector-class">.getRulesFor</span>(question.<span class="hljs-built_in">gameTitle</span>());

  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">answerText</span> = <span class="hljs-selector-tag">chatClient</span><span class="hljs-selector-class">.prompt</span>()
      <span class="hljs-selector-class">.system</span>(systemSpec -&gt; systemSpec      #<span class="hljs-number">1</span>
          .<span class="hljs-built_in">text</span>(promptTemplate)
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"gameTitle"</span>, question.<span class="hljs-built_in">gameTitle</span>())
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"rules"</span>, gameRules))
      <span class="hljs-selector-class">.user</span>(question.<span class="hljs-built_in">question</span>())             <span class="hljs-selector-id">#2</span>
      <span class="hljs-selector-class">.call</span>()
      <span class="hljs-selector-class">.content</span>();

  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Answer</span>(question.<span class="hljs-built_in">gameTitle</span>(), answerText);
}
</code></pre>
<p>具体而言：模板通过 <strong>system</strong> 消息规格的 <code>text()</code> 提供（而不是先前的 <strong>user</strong> 规格），用于填充占位符的参数也同理。至于 <strong>user</strong> 消息，再次仅使用<strong>用户问题的文本</strong>本身。</p>
<p><strong>user 与 system 消息的先后顺序并不重要</strong>；无论顺序如何，它们最终都会出现在发给 LLM 的请求中。</p>
<p>完成这些修改后，重启应用再试一次。表面上仍与之前一致，但底层发往 OpenAI 的请求现在包含两条明确分离的消息：一条是 <strong>system 指令</strong>，一条是 <strong>user 提问</strong>：</p>
<pre><code class="hljs language-swift" lang="swift">{
  <span class="hljs-string">"messages"</span>: [
    {
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"How many pieces are there?"</span>,
      <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>
    },
    {
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"You are a helpful assistant, answering questions about the
          tabletop<span class="hljs-subst">\n</span>game named checkers. If available, use the rules in the
          RULES section below.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>RULES<span class="hljs-subst">\n</span>-----<span class="hljs-subst">\n</span>"</span>,
      <span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>
    }
  ],
  <span class="hljs-string">"model"</span>: <span class="hljs-string">"gpt-4o"</span>,
  <span class="hljs-string">"stream"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.7</span>
}
</code></pre>
<p>尽管我们目前的示例可能过于简单，不足以体现“角色”带来的明显差异，但总体而言，<strong>合理使用角色有助于 LLM 生成更优的响应</strong>。随着提示复杂度提高，这种积极作用会更加显著。</p>
<p>到现在为止，我们关注的是如何<strong>创建并发送</strong>提示给 LLM 进行生成。接下来把注意力转到对话的另一端：学习<strong>如何告知 LLM 我们希望以何种形式接收生成的响应</strong>。</p>
<h2 data-id="heading-7">3.4 影响响应生成（Influencing response generation）</h2>
<p>Spring AI 提供了几项很实用的功能，用来影响响应返回的方式，包括：</p>
<ul>
<li><strong>设置生成选项</strong>：在生成响应时，对“下一枚 token 的选择”施加一定控制。</li>
<li><strong>输出转换（output conversion）</strong> ：在提示中加入格式化指令，告诉 LLM 按特定格式返回，以便把文本响应转换成 Java 对象。</li>
<li><strong>流式传输</strong>：让结果<strong>一点点</strong>返回，而不是等待<strong>一次性</strong>返回完整响应。</li>
</ul>
<p>下面从把响应绑定为 Java 对象开始，逐一介绍这些功能。</p>
<h3 data-id="heading-8">3.4.1 指定聊天选项（Specifying chat options）</h3>
<p>在使用生成式 AI 时，你可能会发现 LLM 的回答并不总如预期。模型巨大的训练规模，加上生成过程的<strong>非确定性</strong>，有时会产生不那么理想的结果。</p>
<p>Spring AI 提供了若干属性，让你“调参”以影响 LLM 处理提示的方式。你已在第 1 章见过一个：在 <code>application.properties</code> 中覆盖默认模型为 <code>gpt-4.1-nano</code>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.openai.chat.options.model</span>=gpt-<span class="hljs-number">4.1</span>-na<span class="hljs-literal">no</span>
</code></pre>
<p>Spring AI 支持的各类 API 都有类似属性来指定模型。例如，使用 Ollama 时选择 <strong>Llama 3.2</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.ollama.chat.options.model</span>=llama3.<span class="hljs-number">2</span>
</code></pre>
<p>这两行的关键区别（除模型名外）在于：一行对应 <strong>OpenAI</strong> 的 API，另一行对应 <strong>Ollama</strong> 的 API。以这种方式设置聊天选项时，请确保使用<strong>与你所用 API 匹配</strong>的属性前缀。</p>
<p>多数聊天选项都可以在 <code>application.properties</code> 里设置；也可以在创建 <code>ChatClient</code> 时通过 <code>defaultOptions()</code> 设为默认值。例如，创建 <code>ChatClient</code> 时指定 <code>gpt-4.1-nano</code>：</p>
<pre><code class="hljs language-ini" lang="ini">ChatOptions <span class="hljs-attr">chatOptions</span> = ChatOptions.builder()
    .model("gpt-4.1-nano")
    .build()<span class="hljs-comment">;</span>

ChatClient <span class="hljs-attr">chatClient</span> = chatClientBuilder
    .defaultOptions(chatOptions)
    .build()<span class="hljs-comment">;</span>
</code></pre>
<p>通过 <code>defaultOptions()</code> 设置的选项会<strong>覆盖</strong>在 <code>application.properties</code> 里同名的配置；而这些默认选项又可以在<strong>创建提示</strong>时通过 <code>options()</code> <strong>继续覆盖</strong>，例如：</p>
<pre><code class="hljs language-scss" lang="scss">String answerText = chatClient<span class="hljs-selector-class">.prompt</span>()
    <span class="hljs-selector-class">.user</span>(question.question())
    <span class="hljs-selector-class">.options</span>(chatOptions)
    <span class="hljs-selector-class">.call</span>()
    <span class="hljs-selector-class">.content</span>();
</code></pre>
<p>选择模型只是众多聊天选项之一。不同生成式 API 支持的选项并不完全相同，但有若干<strong>核心选项</strong>是普遍存在的。先看一组会影响“如何逐 token 选取”的选项。</p>
<h4 data-id="heading-9">调整“多样性/随机性”（Adjusting variability）</h4>
<p>响应生成是<strong>逐 token</strong>进行的：先考虑原始提示，然后由 API 基于模型选择<strong>下一枚 token</strong>；接着再选下一枚，直到完整响应生成完毕。</p>
<p>选择“下一枚 token”的方法可理解为<strong>统计概率 + 随机选择</strong>的组合。模型会给出若干候选 token，每个都有成为下一枚 token 的概率。以概率为权重做一次随机选择：概率高的更容易被选中，但<strong>所有候选</strong>都有被选中的可能。</p>
<p>例如提示为：“Finish this sentence: I have a large collection of.” 为了便于理解，我们先用<strong>词</strong>代替 <strong>token</strong> 来思考。假设候选词及其概率如下：</p>
<ul>
<li>“books” - 0.475</li>
<li>“coins” - 0.236</li>
<li>“records” - 0.129</li>
<li>“arts” - 0.096</li>
<li>“stamps” - 0.064</li>
</ul>
<p>基于以上权重，<strong>books</strong> 被选中的概率约是 <strong>coins</strong> 的两倍、是 <strong>stamps</strong> 的七倍多。多次提交相同提示，大多数结果会以 <strong>books</strong> 完成句子，<strong>coins/records/arts/stamps</strong> 偶尔出现，且频率逐步降低。</p>
<p>通过 <strong>temperature、Top-p、Top-k</strong> 等选项，你可以影响选择的随机性以及不同 token 被选中的相对可能性：</p>
<ul>
<li><strong>temperature（温度）</strong> ：范围 <strong>0–2</strong>，对概率施加缩放。直觉上，<strong>温度越高</strong>，结果越<strong>随机</strong>；<strong>温度越低</strong>，结果越<strong>确定</strong>（见图 3.4）。当温度趋近 2，各 token 概率趋于平均；当温度趋近 0，最高概率 token 的概率趋近 1，其他趋近 0；温度为 1 时概率不变。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e8f90d1d94e44d8b5cc06fb315ebcc9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=NGma5BUEeQGB5ddFaWaOFdGLSm8%3D" alt="image.png" loading="lazy"/></li>
</ul>
<p><strong>图 3.4</strong> 温度越高，概率越均匀，结果更随机；温度越低，概率差异被放大，结果更确定。</p>
<p>在 <code>application.properties</code> 中可按所用 API 设置温度。例如 OpenAI 设为 0.7：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.openai.chat.options.temperature</span>=<span class="hljs-number">0.7</span>
</code></pre>
<p>或在代码里通过 <code>ChatOptions</code> 指定：</p>
<pre><code class="hljs language-ini" lang="ini">ChatOptions <span class="hljs-attr">chatOptions</span> = ChatOptions.builder()
    .temperature(0.7)
    .build()<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><strong>Top-P（核采样）</strong> ：范围 <strong>0–1</strong>，保留<strong>累计概率</strong>达到阈值的<strong>最小候选集合</strong>，其余全部剔除。<br/>
例如 Top-P=0.8，如图 3.5，<code>books+coins+records</code> 的累计概率为 0.84，达到阈值，于是 <strong>arts/stamps</strong> 被剔除；随后对保留集合的概率<strong>归一化</strong>再做加权随机选择。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3c4e6ef45ee4464ae14ccbe0748fbeb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pWw5o2u5pm66IO96ICB5Y-45py6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763373425&amp;x-signature=wbWngSrSb0rM2AmIlA22YsjCdC4%3D" alt="image.png" loading="lazy"/></p>
<p><strong>图 3.5</strong> Top-P 根据高排名 token 的累计概率阈值，剔除其余候选。</p>
<p>在 OpenAI 下用属性设置：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.openai.chat.options.top-p</span>=<span class="hljs-number">0.8</span>
</code></pre>
<p>或代码设置：</p>
<pre><code class="hljs language-ini" lang="ini">ChatOptions <span class="hljs-attr">chatOptions</span> = ChatOptions.builder()
    .topP(0.8)
    .build()<span class="hljs-comment">;</span>
</code></pre>
<p>通常建议<strong>二选一</strong>：使用 <strong>temperature</strong> 或 <strong>Top-P</strong>。两者同时使用是允许的，但不一定更好。</p>
<ul>
<li><strong>Top-K</strong>：与 Top-P 类似，但用<strong>计数</strong>而非累计概率，直接保留<strong>前 K 个</strong>候选。<strong>OpenAI 不支持 Top-K</strong>，因此无法在 OpenAI 上调整它；<strong>Ollama 支持</strong>，可在配置中设置：</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">spring.ai.ollama.chat.options.top-k</span>=<span class="hljs-number">4</span>
</code></pre>
<p>或在代码中：</p>
<pre><code class="hljs language-ini" lang="ini">ChatOptions <span class="hljs-attr">chatOptions</span> = ChatOptions.builder()
    .topK(4)
    .build()<span class="hljs-comment">;</span>
</code></pre>
<p>若你在 <code>ChatOptions</code> 里设置了 Top-K 却把提示发给 OpenAI，将会收到“不支持 Top-K”的错误。</p>
<p>应用到前述“收藏”示例上，若 <code>top-k=4</code>，则 <strong>books/coins/records/arts</strong> 被保留，<strong>stamps</strong> 被剔除；随后同样进行概率归一化并随机选择。</p>
<p>像 <strong>temperature、Top-P、Top-K</strong> 这样的选项，可以在 LLM 生成响应时对其“选择过程”施加一定控制。接下来我们看看<strong>输出转换（output conversion）</strong> ，如何让生成结果直接落地为一个 <strong>Java 对象</strong>。</p>
<h3 data-id="heading-10">3.4.2 格式化响应输出（Formatting response output）</h3>
<p>到目前为止，我们的应用会显式地从 LLM 返回的响应中提取<strong>文本内容</strong>，并据此创建一个 <code>Answer</code> 对象。就目前这个简单的 <code>Answer</code> 记录类型而言，这并不难。但可以想见，若响应更复杂，“先提取再实例化”的代码会变得臃肿。幸运的是，Spring AI 提供了**输出转换（output conversion）**辅助，用于把 LLM 的响应映射为 Java 对象。</p>
<p>为了演示输出转换如何工作，先看看如何让 <code>ChatClient</code> <strong>直接返回 <code>Answer</code> 对象</strong>，而不是字符串。为此，需要把 <code>askQuestion()</code> 方法改为请求实体对象。</p>
<p><strong>清单 3.5 将 LLM 结果直接获取为 <code>Answer</code> 对象</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;
<span class="hljs-keyword">import</span> org.springframework.core.io.Resource;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameService</span> <span class="hljs-title">implements</span> <span class="hljs-title">BoardGameService</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> GameRulesService gameRulesService;

  <span class="hljs-keyword">public</span> SpringAiBoardGameService(
      ChatClient.Builder chatClientBuilder,
      GameRulesService gameRulesService) {
    <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.build();
    <span class="hljs-keyword">this</span>.gameRulesService = gameRulesService;
  }

  <span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/promptTemplates/systemPromptTemplate.st"</span>)</span>
  Resource promptTemplate;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Answer askQuestion(Question question) {
    <span class="hljs-keyword">var</span> gameRules = gameRulesService.getRulesFor(question.gameTitle());

    <span class="hljs-keyword">return</span> chatClient.prompt()
        .system(systemSpec -&gt; systemSpec
            .text(promptTemplate)
            .param(<span class="hljs-string">"gameTitle"</span>, question.gameTitle())
            .param(<span class="hljs-string">"rules"</span>, gameRules))
        .user(question.question())
        .call()
        .entity(Answer.<span class="hljs-keyword">class</span>);
  }

}
</code></pre>
<p><code>askQuestion()</code> 的工作方式几乎与之前完全相同，只是有一个不太显眼的变化：不再调用 <code>content()</code>，而是调用 <code>entity()</code>，并传入 <code>Answer.class</code> 指明期望的响应类型。</p>
<p>这个小改动带来两点变化：</p>
<ol>
<li><strong>格式化指令</strong>会被加入到提示中；</li>
<li>返回的响应会被<strong>解析为对象</strong>。</li>
</ol>
<p>在提示发送给 LLM 之前，Spring AI 会<strong>装饰</strong>提示，加入<strong>格式化指令</strong>，告诉模型响应应采用何种格式。该格式由 <code>Answer</code> 记录及其属性<strong>推导</strong>而来。如果你拦截请求并查看细节，会看到类似如下的格式化指令：</p>
<pre><code class="hljs language-vbscript" lang="vbscript">Your <span class="hljs-built_in">response</span> should be <span class="hljs-keyword">in</span> JSON format.
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">not</span> include any explanations, only provide a RFC8259 compliant JSON
<span class="hljs-built_in">response</span> following this format without deviation.
<span class="hljs-keyword">Do</span> <span class="hljs-keyword">not</span> include markdown code blocks <span class="hljs-keyword">in</span> your <span class="hljs-built_in">response</span>.
Here <span class="hljs-keyword">is</span> the JSON Schema instance your output must adhere <span class="hljs-keyword">to</span>:
```{
  <span class="hljs-string">"$schema"</span> : <span class="hljs-string">"https://json-schema.org/draft/2020-12/schema"</span>,
  <span class="hljs-string">"type"</span> : <span class="hljs-string">"object"</span>,
  <span class="hljs-string">"properties"</span> : {
    <span class="hljs-string">"answer"</span> : {
      <span class="hljs-string">"type"</span> : <span class="hljs-string">"string"</span>
    },
    <span class="hljs-string">"gameTitle"</span> : {
      <span class="hljs-string">"type"</span> : <span class="hljs-string">"string"</span>
    }
  }
}```
</code></pre>
<p>这里的格式说明<strong>精确</strong>告知 LLM：应按 JSON 对象返回，并附上了 JSON Schema。</p>
<p>当响应返回时，这个 JSON 对象会被<strong>转换</strong>成所需类型——此处为 <code>Answer</code>。</p>
<blockquote>
<p><strong>NOTE</strong> 即使 Spring AI 的输出转换负责生成了格式化指令，也<strong>不保证</strong>一定有效。有些 LLM 并不遵循格式要求，仍会随意返回答案。OpenAI 的 GPT 模型通常执行得不错，但其他模型（如 <strong>Mistral 7B</strong>）可能不行。如果所用 LLM 不遵守格式，结果就<strong>无法可靠</strong>地转换并绑定到对象；这种情况下，当 Spring AI 尝试把“非 JSON 响应”绑定到对象时，会抛出 <strong>JsonParseException</strong>。</p>
</blockquote>
<p>就是这样！现在 Spring AI 的输出转换会负责创建 <code>Answer</code> 对象——它之所以能做到，是因为它首先生成了<strong>指令</strong>，告诉 LLM 按 JSON 对象格式返回结果。</p>
<h4 data-id="heading-11">将输出解析为列表（Parsing output to a list）</h4>
<p>Spring AI 也能把响应解析为 <code>List&lt;String&gt;</code>。当你预期响应是一个“条目列表”时，这很适合，比如游乐园景点清单、联赛球队名单、或 Billboard Hot 100 的年度十大金曲。</p>
<p>为演示如何拿到列表响应，我们创建一个新的控制器（如下清单），按给定年份返回前 10 首歌曲：</p>
<p><strong>清单 3.6 返回某年份热门歌曲 Top 10 的控制器</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.topsongs;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;
<span class="hljs-keyword">import</span> org.springframework.core.ParameterizedTypeReference;
<span class="hljs-keyword">import</span> org.springframework.core.io.Resource;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestParam;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopSongsController</span> {

  <span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/top-songs-prompt.st"</span>)</span>
  Resource topSongPromptTemplate;  #<span class="hljs-number">1</span>

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;

  <span class="hljs-keyword">public</span> TopSongsController(ChatClient.Builder chatClientBuilder) {
    <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.build();
  }

  <span class="hljs-meta">@GetMapping(path = <span class="hljs-string">"/topSongs"</span>, produces = <span class="hljs-string">"application/json"</span>)</span>
  <span class="hljs-keyword">public</span> List&lt;String&gt; topSongs(<span class="hljs-meta">@RequestParam(<span class="hljs-string">"year"</span>)</span> String year) {
    <span class="hljs-keyword">return</span> chatClient.prompt()
        .user(userSpec -&gt; userSpec
            .text(topSongPromptTemplate)
            .param(<span class="hljs-string">"year"</span>, year))
        .call()
        .entity(new ParameterizedTypeReference&lt;List&lt;String&gt;&gt;() {});  #<span class="hljs-number">2</span>
  }

}
</code></pre>
<p>为简单起见，这里直接在控制器中使用 <code>ChatClient</code>，而不是像 <code>SpringAiBoardGameService</code> 那样抽到单独的服务类。</p>
<p>提示模板定义在 <code>src/main/resources/top-songs-prompt.st</code>，并作为 <code>Resource</code> 注入控制器。模板内容如下：</p>
<pre><code class="hljs language-sql" lang="sql">What were the top <span class="hljs-number">10</span> songs <span class="hljs-keyword">on</span> the Billboard Hot <span class="hljs-number">100</span> <span class="hljs-keyword">in</span> {<span class="hljs-keyword">year</span>}?

<span class="hljs-keyword">Each</span> item should <span class="hljs-keyword">only</span> include the song title.
</code></pre>
<p>该控制器与之前在 <code>SpringAiBoardGameService</code> 中见到的代码很相似，但有一点不同：调用 <code>entity()</code> 时传入了 <code>new ParameterizedTypeReference&lt;List&lt;String&gt;&gt;() {}</code>。我们期望的结果是 <code>List&lt;String&gt;</code>，但不能直接把 <code>List</code> 或 <code>List&lt;String&gt;</code> 传给 <code>entity()</code>。<code>ParameterizedTypeReference</code> 是一种特殊的类型引用，能在 Java 的<strong>类型擦除</strong>下，仍携带<strong>泛型实参</strong>传给方法（如 <code>entity()</code>）。</p>
<p>由于向 <code>entity()</code> 传入了 <code>new ParameterizedTypeReference&lt;List&lt;String&gt;&gt;() {}</code>，提示会被赋予如下的<strong>格式化指令</strong>：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">FORMAT: Your response should be a list of comma separated values</span>
<span class="hljs-section">eg: `foo, bar, baz`</span>
</code></pre>
<p>运行应用后，可用 HTTPie 试试，例如：</p>
<pre><code class="hljs language-bash" lang="bash">$ http :8080/topSongs?year=1981 -b
[
    <span class="hljs-string">"Bette Davis Eyes"</span>,
    <span class="hljs-string">"Endless Love"</span>,
    <span class="hljs-string">"Lady"</span>,
    <span class="hljs-string">"(Just Like) Starting Over"</span>,
    <span class="hljs-string">"Jessie's Girl"</span>,
    <span class="hljs-string">"Celebration"</span>,
    <span class="hljs-string">"Kiss On My List"</span>,
    <span class="hljs-string">"I Love A Rainy Night"</span>,
    <span class="hljs-string">"9 To 5"</span>,
    <span class="hljs-string">"Keep On Loving You"</span>
]
</code></pre>
<p>太好了！快速搜一下可确认这些确实是 1981 年的前十热单。当然，<strong>准确性</strong>取决于你所选 LLM 的训练质量（上述列单由 OpenAI 的 <code>gpt-4o</code> 返回）。但更重要的是，得益于<strong>列表输出转换</strong>，响应被格式化为一个值列表。</p>
<p>虽然把响应格式化为 Java 对象或列表很有用，但有时候<strong>纯文本</strong>就够了，只是你希望它在生成时<strong>逐步返回</strong>。接下来看看如何使用另一种 Spring AI 聊天客户端，把结果<strong>流式</strong>返回给调用方。</p>
<h3 data-id="heading-12">3.4.3 流式返回响应（Streaming the response）</h3>
<p>如果你用过 OpenAI 的 ChatGPT、微软 Copilot 等聊天客户端，你就体验过“聊天式界面”的 LLM 交互。你也会注意到：LLM 的回答像“在打字”一样，<strong>逐步流入</strong>对话窗口。</p>
<p>流式响应的关键好处是：<strong>提升聊天应用的用户体验</strong>。简单回答可能很快返回，但复杂回答需要更长的生成时间。如果能在生成过程中<strong>逐步渲染</strong>，用户就能确信应用<strong>在工作</strong>而非“卡住”。</p>
<p>Spring AI 在使用 <code>ChatClient</code> 时支持这种<strong>流式风格</strong>。下面的清单展示了：只需对 <code>askQuestion()</code> 做少量修改，就能以<strong>流</strong>的方式取回结果。</p>
<p><strong>清单 3.7 流式返回的棋盘游戏服务</strong></p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Override</span>
public Flux&lt;String&gt; <span class="hljs-built_in">askQuestion</span>(Question question) {    <span class="hljs-selector-id">#1</span>
  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">gameRules</span> = <span class="hljs-selector-tag">gameRulesService</span><span class="hljs-selector-class">.getRulesFor</span>(question.<span class="hljs-built_in">gameTitle</span>());

  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">chatClient</span><span class="hljs-selector-class">.prompt</span>()
      <span class="hljs-selector-class">.system</span>(systemSpec -&gt; systemSpec
          .<span class="hljs-built_in">text</span>(promptTemplate)
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"gameTitle"</span>, question.<span class="hljs-built_in">gameTitle</span>())
          .<span class="hljs-built_in">param</span>(<span class="hljs-string">"rules"</span>, gameRules))
      <span class="hljs-selector-class">.user</span>(question.<span class="hljs-built_in">question</span>())
      <span class="hljs-selector-class">.stream</span>()         <span class="hljs-selector-id">#2</span>
      <span class="hljs-selector-class">.content</span>();
}
</code></pre>
<p>与先前版本相比，关键差异在于：该方法的返回类型是 <code>Flux&lt;String&gt;</code>，且不再调用 <code>call()</code>，而是调用 <code>stream()</code>。等等，<code>Flux</code> 是什么？</p>
<p><code>Flux</code> 来自 <strong>Project Reactor</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fprojectreactor.io%2F" target="_blank" title="https://projectreactor.io/" ref="nofollow noopener noreferrer">projectreactor.io/</a>），是 Spring 响应式栈的基础库。更多内容可参考《Spring in Action》（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.manning.com%2Fbooks%2Fspring-in-action-sixth-edition" target="_blank" title="https://www.manning.com/books/spring-in-action-sixth-edition" ref="nofollow noopener noreferrer">www.manning.com/books/sprin…</a>），从第 5 版起其中就有专章讲解 Reactor 以及 <code>Flux</code> / <code>Mono</code>。</p>
<p>此处只需理解：<code>Flux</code> 是一种<strong>响应式类型</strong>，会在数据可用时<strong>流式</strong>地产生 0 到多条数据。对 LLM 的生成响应而言，<code>Flux</code> 通常会按<strong>词粒度</strong>（或短片段）不断推送内容。</p>
<p>你还需要修改 <code>AskController</code>，让它返回服务方法返回的 <code>Flux</code>。如下：</p>
<p><strong>清单 3.8 流式的 <code>AskController</code></strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PostMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestBody;
<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;
<span class="hljs-keyword">import</span> reactor.core.publisher.Flux;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AskController</span> {

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BoardGameService boardGameService;

  <span class="hljs-keyword">public</span> AskController(BoardGameService boardGameService) {
    <span class="hljs-keyword">this</span>.boardGameService = boardGameService;
  }

  <span class="hljs-meta">@PostMapping(path=<span class="hljs-string">"/ask"</span>, produces=<span class="hljs-string">"application/json"</span>)</span>
  <span class="hljs-keyword">public</span> Flux&lt;String&gt; ask(<span class="hljs-meta">@RequestBody</span> Question question) {
    <span class="hljs-keyword">return</span> boardGameService.askQuestion(question);
  }

}
</code></pre>
<p><code>ask()</code> 方法还有一个小改动：<code>@PostMapping</code> 需声明返回<strong>流式响应</strong>，其 <strong>MIME</strong> 一般设为 <code>text/event-stream</code>。这一点很重要：如果仍是 <code>application/json</code>，结果会<strong>一次性</strong>返回，而不是流式返回。</p>
<p>你可以像之前一样用 HTTPie 试试。因为流式响应通常很快返回，除非答案较长，否则你可能不明显地感受到“流动”。比如询问 Burger Battle 的<strong>战斗卡</strong>列表：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">$ http :<span class="hljs-number">8080</span>/ask gameTitle=<span class="hljs-string">"Burger Battle"</span> \
       question=<span class="hljs-string">"What battle cards are there?"</span> -b
       <span class="hljs-keyword">data</span>:

       <span class="hljs-keyword">data</span>:Here

       <span class="hljs-keyword">data</span>: <span class="hljs-keyword">is</span>

       <span class="hljs-keyword">data</span>: a

       <span class="hljs-keyword">data</span>: list

       <span class="hljs-keyword">data</span>: of

       <span class="hljs-keyword">data</span>: the

       <span class="hljs-keyword">data</span>: Battle

       <span class="hljs-keyword">data</span>: Cards
...
</code></pre>
<p>为避免篇幅过长，这里只展示前几项。显然，响应是<strong>逐词</strong>流回，而非一次性返回。尽管输出不容易看出，但每个词之间有<strong>小延迟</strong>，就像 LLM 正在“打字”。</p>
<p><code>text/event-stream</code> 的一个副作用是：每个词前会带上 <code>data:</code> 前缀，因此调用方需要能够<strong>剥离</strong>该前缀以取出真正的词。</p>
<p>为了避免对每个词做特殊处理，可以把 <code>@PostMapping</code> 的 <code>produces</code> 改为 <code>application/ndjson</code>（换行分隔 JSON）：</p>
<pre><code class="hljs language-ini" lang="ini">@PostMapping(<span class="hljs-attr">path</span> = <span class="hljs-string">"/ask"</span>, produces = <span class="hljs-string">"application/ndjson"</span>)
</code></pre>
<p>此时，LLM 仍会<strong>逐词</strong>流回，但不再带 <code>data:</code> 前缀。</p>
<p>如果用 HTTPie 测试这个 MIME，更可能会以为“流式坏了”。因为 HTTPie 遇到 <code>text/event-stream</code> 时会<strong>默认</strong>按流处理，但对 <code>application/ndjson</code> 并不会。要启用流式显示，需加 <code>--stream</code>：</p>
<pre><code class="hljs language-ini" lang="ini">$ http :8080/ask <span class="hljs-attr">gameTitle</span>=<span class="hljs-string">"Burger Battle"</span> \
       <span class="hljs-attr">question</span>=<span class="hljs-string">"What battle cards are there?"</span> -b --stream --pretty none <span class="hljs-comment">#1</span>
</code></pre>
<p>输出（此处为节选）类似：</p>
<pre><code class="hljs language-python" lang="python">In Burger Battle there are several Battle Cards that players can use. Here 
<span class="hljs-keyword">is</span> a <span class="hljs-built_in">list</span> of the standard Battle Cards:

<span class="hljs-number">1.</span> **Burger Bomb**: Blow up another playe<span class="hljs-string">r's Burger by sending their
ingredients to the Graveyard.
2. **Burger Force Field**: Your Burger is now protected from all Battle 
Cards.
3. **Burgerpocalypse**: Obliterate all players'</span> ingredients, including your
own, <span class="hljs-keyword">and</span> toss them <span class="hljs-keyword">in</span> the Graveyard.
<span class="hljs-number">4.</span> **Destroy!**: Destroy <span class="hljs-built_in">any</span> Battle Card of yours <span class="hljs-keyword">or</span> another playe<span class="hljs-string">r's and 
toss it in the Graveyard.
5. **Gonna Eat That?**: Steal another player'</span>s ingredient <span class="hljs-keyword">and</span> add it to your
Burger.
...
</code></pre>
<p>再次强调：书页静态展示不明显，但实际使用 HTTPie 时，响应是<strong>带小延迟</strong>地流回的。虽然底层仍是<strong>逐词</strong>流式，HTTPie 会<strong>缓冲</strong>这些词，直到凑成一整行再打印。</p>
<p>你也许会问：能否把<strong>流式响应</strong>与前面用到的<strong>输出转换</strong>结合起来？理论上，流式客户端可以像处理纯文本一样流式返回<strong>JSON 文本</strong>；但流回的 JSON 会被<strong>拆成词或符号</strong>，在<strong>完整</strong>响应结束前，你并没有一个<strong>完备的 JSON 文档</strong>可以解析。</p>
<p>因此，你必须<strong>先收集</strong>完整的流式 JSON 字符串，再交给输出转换去处理——这等于<strong>违背</strong>了使用流式的初衷。简言之，<strong>不要混用</strong>“流式 + 输出转换”。</p>
<p>在本章中，你已经看到如何使用 Spring AI 将提示提交给 LLM 进行生成；使用<strong>提示模板</strong>实现“填空式”提示；用<strong>上下文填充</strong>提示；利用<strong>提示角色</strong>；以及<strong>影响响应生成</strong>的方式。收尾之前，我们再看看如何检查模型可能随响应一并返回的<strong>响应元数据</strong>。</p>
<h2 data-id="heading-13">3.5 使用响应元数据（Working with response metadata）</h2>
<p>除了拿到生成结果外，<code>ChatClient</code> 还可以提供与 LLM 交互的一些有用<strong>元数据</strong>。其中最有用的是<strong>用量（usage）统计</strong>。每个提示和每段生成的响应最终都会被拆分成若干 <strong>token</strong>。这些 token（以及其他因素）会用于计算你向 AI 服务支付的费用。因此，了解每次请求消耗了多少 token，有助于你评估与 LLM 的交互成本。</p>
<p>如何使用 token 用量信息取决于你自己。最基本的做法是把这些信息简单地<strong>写入应用日志</strong>。在第 9 章，你会看到如何借助 Spring AI 的<strong>可观测性</strong>功能，对外暴露 token 用量与其他指标。</p>
<p><strong>清单 3.9 记录 token 用量到日志</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.example.boardgamebuddy;

<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ChatClient;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.client.ResponseEntity;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.metadata.ChatResponseMetadata;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.metadata.Usage;
<span class="hljs-keyword">import</span> org.springframework.ai.chat.model.ChatResponse;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;
<span class="hljs-keyword">import</span> org.springframework.core.io.Resource;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAiBoardGameService</span> <span class="hljs-title">implements</span> <span class="hljs-title">BoardGameService</span> {

  <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> Logger log =
      LoggerFactory.getLogger(SpringAiBoardGameService.<span class="hljs-keyword">class</span>);

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> GameRulesService gameRulesService;

  <span class="hljs-keyword">public</span> SpringAiBoardGameService(
      ChatClient.Builder chatClientBuilder,
      GameRulesService gameRulesService) {
    <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.build();
    <span class="hljs-keyword">this</span>.gameRulesService = gameRulesService;
  }

  <span class="hljs-meta">@Value(<span class="hljs-string">"classpath:/promptTemplates/systemPromptTemplate.st"</span>)</span>
  Resource promptTemplate;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Answer askQuestion(Question question) {
    <span class="hljs-keyword">var</span> gameRules = gameRulesService.getRulesFor(question.gameTitle());

    <span class="hljs-keyword">var</span> responseEntity = chatClient.prompt()
        .system(systemSpec -&gt; systemSpec
            .text(promptTemplate)
            .param(<span class="hljs-string">"gameTitle"</span>, question.gameTitle())
            .param(<span class="hljs-string">"rules"</span>, gameRules))
        .user(question.question())
        .call()
        .responseEntity(Answer.<span class="hljs-keyword">class</span>);

    <span class="hljs-keyword">var</span> response = responseEntity.response();

    <span class="hljs-keyword">var</span> metadata = response.getMetadata();
    logUsage(metadata.getUsage());


    <span class="hljs-keyword">return</span> responseEntity.entity();
  }

  <span class="hljs-keyword">private</span> void logUsage(Usage usage) {
    log.info(<span class="hljs-string">"Token usage: prompt={}, generation={}, total={}"</span>,
        usage.getPromptTokens(),
        usage.getCompletionTokens(),
        usage.getTotalTokens());
  }

}
</code></pre>
<p><code>askQuestion()</code> 方法和之前相比略有不同。关键差异在于：它不再调用 <code>content()</code> 或 <code>entity()</code> 获取响应，而是调用 <code>responseEntity()</code>。该方法与 <code>entity()</code> 类似，会把响应<strong>绑定</strong>为指定类型的对象（这里是 <code>Answer</code>）；但不同的是，它返回的是一个 <code>ResponseEntity&lt;ChatResponse, Answer&gt;</code>，其中既包含 <code>Answer</code>，也携带一个 <code>ChatResponse</code> 对象。</p>
<p><code>ChatResponse</code> 对象中可以找到<strong>元数据</strong>。调用 <code>getMetadata()</code> 可获取用量信息，从而在 <code>ask()</code> 方法（此处为 <code>askQuestion()</code>）中把它传给 <code>logUsage()</code> 进行日志记录。随后，<code>askQuestion()</code> 返回 <code>ResponseEntity</code> 中承载的 <code>Answer</code>。</p>
<p>完成这些修改后，像之前一样启动应用并向 <code>/ask</code> 发送请求。你应该会在日志里看到类似如下的记录：</p>
<pre><code class="hljs language-ini" lang="ini">Token usage: <span class="hljs-attr">prompt</span>=<span class="hljs-number">1618</span>, generation=<span class="hljs-number">35</span>, total=<span class="hljs-number">1653</span>
</code></pre>
<p>为突出重点，这里只展示了日志消息本身。实际的 token 数会因提问与回答而变化。但可以看到，日志为你提供了有价值的洞察：使用了多少 token（进而可用于<strong>估算费用</strong>）。</p>
<p>需要注意：并非所有 AI 服务都会返回用量指标。例如，发送给本地 <strong>Ollama</strong> 的 LLM 提示不会提供用量数据。<strong>Mistral AI</strong> 也是一个似乎不返回用量数据的服务。但你通常可以从 <strong>OpenAI、Anthropic、Google</strong>（以及可能的其他服务）拿到用量数据。</p>
<h2 data-id="heading-14"><strong>总结</strong></h2>
<ul>
<li><strong>提示模板</strong>让你可以定义并外部化通用提示，在提交生成前用具体内容填充。</li>
<li>模板也支持向提示中提供<strong>额外上下文</strong>，以使生成更聚焦、更准确。</li>
<li>上下文可包含<strong>输出格式化指令</strong>，例如要求以 JSON 返回，以便绑定到 Java 对象。</li>
<li><strong>输出转换</strong>可以把 LLM 的生成结果解析为 <strong>Java 对象</strong>或<strong>列表</strong>。</li>
<li>响应可以<strong>流式</strong>返回给客户端，模拟“思考与打字”的体验。</li>
<li>生成响应中可能包含<strong>有用的元数据</strong>，如 <strong>token 用量</strong> 等指标。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[MGPIC 初赛提交倒计时 4 天！]]></title>    <link>https://juejin.cn/post/7570902473433071616</link>    <guid>https://juejin.cn/post/7570902473433071616</guid>    <pubDate>2025-11-10T10:41:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902473433071616" data-draft-id="7570793903848718351" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" MGPIC 初赛提交倒计时 4 天！"/> <meta itemprop="keywords" content="后端,算法,编程语言"/> <meta itemprop="datePublished" content="2025-11-10T10:41:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MoonBit"/> <meta itemprop="url" content="https://juejin.cn/user/3609050528885565"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             MGPIC 初赛提交倒计时 4 天！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3609050528885565/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    MoonBit
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:41:52.000Z" title="Mon Nov 10 2025 10:41:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong/></p><p align="center"><strong>距离作品提交截止</strong></p><p/>
<p><strong/></p><p align="center"><strong>剩余4天</strong></p><p/>
<p><strong/></p><p align="center"><strong>截止日期：11月14日 18:30</strong></p><p/>
<p>随着 2025 MoonBit 全球编程创新挑战赛的临近尾声，我们见证了「程序语言设计与实现赛道」和「游戏开发与设计」两个赛道的激烈竞争。截至目前，「程序语言设计与实现赛道」已有158支队伍报名、「游戏开发与设计」赛道也吸引了163支队伍的报名。<br/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/883cff72e1eb4ac987295ab76fae8380~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9vbkJpdA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376112&amp;x-signature=%2B0AjPWAgQ8GIItQfiQ5S2FoKFbM%3D" alt="图片" loading="lazy"/></p>
<p>作品提交入口：</p>
<ul>
<li>
<p>编译赛道：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftianchi.aliyun.com%2Fcompetition%2Fentrance%2F532402" target="_blank" title="https://tianchi.aliyun.com/competition/entrance/532402" ref="nofollow noopener noreferrer">tianchi.aliyun.com/competition…</a></p>
</li>
<li>
<p>游戏赛道：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmoonbitlang%2FMoonBit-Code-JAM-2025" target="_blank" title="https://github.com/moonbitlang/MoonBit-Code-JAM-2025" ref="nofollow noopener noreferrer">github.com/moonbitlang…</a></p>
</li>
</ul>
<p>赛程升级，奖励多多</p>
<ul>
<li>
<p>编译赛道 开设了10名表现优异奖，奖金为500元（一个队伍），即除去入围决赛的队伍前6名，排行榜的第7-16名队伍都有机会获得此现金奖励~</p>
<p>P.S.进入排行榜不等于直接入围决赛，赛事组会根据评测机器以及作品完成度决定最后入围决赛名单！所以抓紧时间优化作品完成度！</p>
</li>
</ul>

<ul>
<li>游戏赛道 开设月度动态评比以及更多特别单元奖，现在提交每个队伍还有机会获得阳光普照奖（500元）！</li>
</ul>
<p>目前，双赛道的作品提交已进入最后冲刺阶段，<strong>提交作品端口将于11月14日18:30关闭</strong>，尚未提交初赛作品的队伍请抓紧时间哦！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f8930919711464598096e7247259c6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9vbkJpdA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376112&amp;x-signature=QZ86CTABch9z0bwUregJQrw7YQI%3D" alt="图片" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用高阶函数实现递归：从匿名函数到通用递归生成器]]></title>    <link>https://juejin.cn/post/7570940025580388392</link>    <guid>https://juejin.cn/post/7570940025580388392</guid>    <pubDate>2025-11-10T10:45:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570940025580388392" data-draft-id="7570793903848652815" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用高阶函数实现递归：从匿名函数到通用递归生成器"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-10T10:45:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="pe7er"/> <meta itemprop="url" content="https://juejin.cn/user/905653310988445"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用高阶函数实现递归：从匿名函数到通用递归生成器
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653310988445/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    pe7er
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:45:30.000Z" title="Mon Nov 10 2025 10:45:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>阅读时间：约 10 分钟</strong><br/>
<strong>适合人群：</strong> 具备 JavaScript 基础、想深入理解函数式编程与高阶函数实战的前端工程师。</p>
<p><strong>本文目标：</strong></p>
<ul>
<li>了解如何在没有函数名的情况下实现递归</li>
<li>掌握构建通用递归生成器的思路</li>
<li>学会在真实项目中使用高阶函数递归处理复杂逻辑</li>
</ul>
</blockquote>
<hr/>
<p>从匿名递归开始</p>
<p>先看一段看似难以理解的代码：</p>
<pre><code class="hljs language-scss" lang="scss">(g =&gt; g(g))(f =&gt; n =&gt; n &lt; <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : n * f(f)(n - <span class="hljs-number">1</span>))(<span class="hljs-number">6</span>);
</code></pre>
<p>执行结果是：</p>
<pre><code class="hljs">720
</code></pre>
<p>即 <code>6!</code>(6 的阶乘（factorial of 6）)。</p>
<p>在数学中，<strong>阶乘（factorial）</strong> 是指一个正整数与它所有比它小的正整数的乘积：</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mo>⋯</mo><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n! = n \times (n - 1) \times (n - 2) \times \cdots \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"/><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"/><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">1</span></span></span></span></span></p>
<p>拆解原理：</p>
<ul>
<li><code>(f =&gt; n =&gt; n &lt; 2 ? 1 : n * f(f)(n - 1))</code>：定义阶乘逻辑；</li>
<li><code>(g =&gt; g(g))</code>：<strong>自应用函数（Self-Application Function）</strong> ；</li>
<li><code>(g =&gt; g(g))(f =&gt; ...)</code>：将函数传入自身，让匿名函数内部实现递归。</li>
</ul>
<p>这种方式实现了<strong>没有名字的递归函数</strong>。</p>
<hr/>
<h2 data-id="heading-0">提取为可复用的函数</h2>
<p>为了可读性更高，我们提取一个通用的封装函数：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">fn</span> = (f) =&gt; {
  return (<span class="hljs-attr">g</span> =&gt; g(g))(f)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">fn1</span> = fn(f =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt; n === <span class="hljs-number">0</span> ? acc : f(f)(n - <span class="hljs-number">1</span>, n * acc))<span class="hljs-comment">;</span>
console.log(fn1(6))<span class="hljs-comment">; // 720</span>
</code></pre>
<p><code>fn()</code> 封装了匿名递归结构，传入的函数只需要关心逻辑。</p>
<hr/>
<h2 data-id="heading-1">构建通用的递归函数生成器</h2>
<p>我们进一步封装成更通用的写法：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createRecursiveFunction</span> = (<span class="hljs-params">f</span>) =&gt; {
  <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> <span class="hljs-title function_">g</span>(g))(<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">f</span>(<span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">h</span>(h)(...args)));
};
</code></pre>
<p>解释：</p>
<ul>
<li><code>f</code> 是接收 <code>self</code> 参数的函数；</li>
<li><code>self</code> 表示递归自身；</li>
<li><code>(g =&gt; g(g))</code> 让函数可以引用自身。</li>
</ul>
<hr/>
<h2 data-id="heading-2">例 1：阶乘（factorial）</h2>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">factorialLogic</span> = (self) =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt; {
  return <span class="hljs-attr">n</span> === <span class="hljs-number">0</span> ? acc : self(n - <span class="hljs-number">1</span>, n * acc)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">factorial</span> = createRecursiveFunction(factorialLogic)<span class="hljs-comment">;</span>

console.log(factorial(6))<span class="hljs-comment">; // 720</span>
</code></pre>
<p>这是一种尾递归写法，性能更优。</p>
<hr/>
<h2 data-id="heading-3">例 2：斐波那契数列（fibonacci）</h2>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">fibonacciLogic</span> = (self) =&gt; (n) =&gt; {
  return n &lt;= 1 ? n : self(n - 1) + self(n - 2)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">fibonacci</span> = createRecursiveFunction(fibonacciLogic)<span class="hljs-comment">;</span>

console.log(fibonacci(6))<span class="hljs-comment">; // 8</span>
</code></pre>
<hr/>
<h2 data-id="heading-4">例 3：爬楼梯问题（climbStairs）</h2>
<blockquote>
<p>每次可以爬 1 或 2 阶，问总共有多少种爬法？</p>
</blockquote>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">climbStairsLogic</span> = (self) =&gt; n =&gt; {
  return n &lt;= 2 ? n : self(n - 1) + self(n - 2)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">climbStairs</span> = createRecursiveFunction(climbStairsLogic)<span class="hljs-comment">;</span>

console.log(climbStairs(6))<span class="hljs-comment">; // 13</span>
</code></pre>
<hr/>
<h2 data-id="heading-5">例 4：棋盘麦粒问题（chessGrains）</h2>
<blockquote>
<p>棋盘第一个格子放 1 颗麦子，每下一个格子是前一个的 2 倍。问第 64 个格子上有多少颗？</p>
</blockquote>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">chessGrainsLogic</span> = (self) =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt; {
  return <span class="hljs-attr">n</span> === <span class="hljs-number">0</span> ? acc : self(n - <span class="hljs-number">1</span>, acc * <span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">chessGrains</span> = createRecursiveFunction(chessGrainsLogic)<span class="hljs-comment">;</span>

console.log(chessGrains(63))<span class="hljs-comment">; // 9223372036854775808</span>
</code></pre>
<hr/>
<h2 data-id="heading-6">完整代码</h2>
<pre><code class="hljs language-scss" lang="scss">const createRecursiveFunction = (f) =&gt; {
  return (g =&gt; g(g))(h =&gt; f((...args) =&gt; <span class="hljs-built_in">h</span>(h)(...args)));
};

<span class="hljs-comment">// 阶乘</span>
const factorialLogic = (self) =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt;
  n === <span class="hljs-number">0</span> ? acc : <span class="hljs-built_in">self</span>(n - <span class="hljs-number">1</span>, n * acc);
const factorial = <span class="hljs-built_in">createRecursiveFunction</span>(factorialLogic);
console<span class="hljs-selector-class">.log</span>('factorial(<span class="hljs-number">6</span>) =', <span class="hljs-built_in">factorial</span>(<span class="hljs-number">6</span>));

<span class="hljs-comment">// 斐波那契</span>
const fibonacciLogic = (self) =&gt; (n) =&gt;
  n &lt;= <span class="hljs-number">1</span> ? n : <span class="hljs-built_in">self</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">self</span>(n - <span class="hljs-number">2</span>);
const fibonacci = <span class="hljs-built_in">createRecursiveFunction</span>(fibonacciLogic);
console<span class="hljs-selector-class">.log</span>('fibonacci(<span class="hljs-number">6</span>) =', <span class="hljs-built_in">fibonacci</span>(<span class="hljs-number">6</span>));

<span class="hljs-comment">// 爬楼梯</span>
const climbStairsLogic = (self) =&gt; n =&gt;
  n &lt;= <span class="hljs-number">2</span> ? n : <span class="hljs-built_in">self</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">self</span>(n - <span class="hljs-number">2</span>);
const climbStairs = <span class="hljs-built_in">createRecursiveFunction</span>(climbStairsLogic);
console<span class="hljs-selector-class">.log</span>('climbStairs(<span class="hljs-number">6</span>) =', <span class="hljs-built_in">climbStairs</span>(<span class="hljs-number">6</span>));

<span class="hljs-comment">// 棋盘麦粒</span>
const chessGrainsLogic = (self) =&gt; (n, acc = <span class="hljs-number">1</span>) =&gt;
  n === <span class="hljs-number">0</span> ? acc : <span class="hljs-built_in">self</span>(n - <span class="hljs-number">1</span>, acc * <span class="hljs-number">2</span>);
const chessGrains = <span class="hljs-built_in">createRecursiveFunction</span>(chessGrainsLogic);
console<span class="hljs-selector-class">.log</span>('chessGrains(<span class="hljs-number">63</span>) =', <span class="hljs-built_in">chessGrains</span>(<span class="hljs-number">63</span>));
</code></pre>
<hr/>
<h2 data-id="heading-7">总结：高阶函数的力量</h2>

























<table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td>高阶函数</td><td>接收或返回函数的函数</td></tr><tr><td>匿名递归</td><td>无需函数名即可递归</td></tr><tr><td>自应用函数 <code>(g =&gt; g(g))</code></td><td>实现匿名自引用的关键</td></tr><tr><td>通用递归生成器</td><td>可动态生成任意递归逻辑</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-8">思考练习</h2>
<p>尝试使用 <code>createRecursiveFunction</code> 实现以下函数：</p>
<ol>
<li>非尾递归版阶乘</li>
<li>求数组和</li>
<li>二分查找</li>
</ol>
<p>好的，我帮你把这一节整理成 <strong>掘金文章的新一章</strong>，保持和前文一致的 Markdown 风格，标题、代码、说明都完整，方便直接发布。</p>
<hr/>
<h2 data-id="heading-9">十、递归练习与思维扩展</h2>
<p>在前文中，我们学习了如何用高阶函数和通用递归生成器 <code>createRecursiveFunction</code> 构建各种递归函数。<br/>
为了加深理解，可以尝试一些练习题，实践不同类型的递归逻辑。</p>
<p>本章给出三个示例：</p>
<ol>
<li>非尾递归版阶乘</li>
<li>求数组和</li>
<li>二分查找</li>
</ol>
<hr/>
<h3 data-id="heading-10">1. 非尾递归版阶乘</h3>
<p>非尾递归的特点是<strong>递归调用不是最后一步</strong>，返回值还要参与计算。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">factorialLogic</span> = (self) =&gt; (n) =&gt; {
  if (<span class="hljs-attr">n</span> === <span class="hljs-number">0</span>) return <span class="hljs-number">1</span><span class="hljs-comment">;</span>
  return n * self(n - 1)<span class="hljs-comment">; // 非尾递归</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">factorial</span> = createRecursiveFunction(factorialLogic)<span class="hljs-comment">;</span>

console.log(factorial(6))<span class="hljs-comment">; // 输出 720</span>
</code></pre>
<blockquote>
<p>解析：</p>
<ul>
<li>每次递归返回一个值参与乘法计算；</li>
<li>调用栈会随着 <code>n</code> 增大而增加。</li>
</ul>
</blockquote>
<hr/>
<h3 data-id="heading-11">2. 求数组和</h3>
<p>利用递归求数组所有元素的和。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">sumArrayLogic</span> = (self) =&gt; (arr) =&gt; {
  if (<span class="hljs-attr">arr.length</span> === <span class="hljs-number">0</span>) return <span class="hljs-number">0</span><span class="hljs-comment">;</span>
  const <span class="hljs-section">[head, ...tail]</span> = arr<span class="hljs-comment">;</span>
  return head + self(tail)<span class="hljs-comment">; // 非尾递归</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">sumArray</span> = createRecursiveFunction(sumArrayLogic)<span class="hljs-comment">;</span>

console.log(sumArray(<span class="hljs-section">[1, 2, 3, 4, 5]</span>))<span class="hljs-comment">; // 输出 15</span>
</code></pre>
<blockquote>
<p>解析：</p>
<ul>
<li>每次取数组的第一个元素 <code>head</code>，递归计算剩余元素 <code>tail</code> 的和；</li>
<li>递归调用返回值与 <code>head</code> 相加得到最终结果。</li>
</ul>
</blockquote>
<hr/>
<h3 data-id="heading-12">3. 二分查找</h3>
<p>在有序数组中高效查找目标元素索引。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">binarySearchLogic</span> = (self) =&gt; (arr, target, left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span>) =&gt; {
  if (left &gt; right) return -1<span class="hljs-comment">; // 未找到</span>

  const <span class="hljs-attr">mid</span> = Math.floor((left + right) / <span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
  const <span class="hljs-attr">value</span> = arr[mid]<span class="hljs-comment">;</span>

  if (<span class="hljs-attr">value</span> === target) return mid<span class="hljs-comment">;</span>
  if (value &gt; target) return self(arr, target, left, mid - 1)<span class="hljs-comment">;</span>
  return self(arr, target, mid + 1, right)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">binarySearch</span> = createRecursiveFunction(binarySearchLogic)<span class="hljs-comment">;</span>

const <span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<span class="hljs-comment">;</span>
console.log(binarySearch(arr, 7))<span class="hljs-comment">;  // 输出 3</span>
console.log(binarySearch(arr, 4))<span class="hljs-comment">;  // 输出 -1</span>
</code></pre>
<blockquote>
<p>解析：</p>
<ul>
<li>每次递归缩小查找范围；</li>
<li>递归结束条件是 <code>left &gt; right</code>；</li>
<li>返回目标元素索引或 -1。</li>
</ul>
</blockquote>
<hr/>
<h3 data-id="heading-13">特征</h3>

























<table><thead><tr><th>函数</th><th>类型</th><th>递归特点</th></tr></thead><tbody><tr><td>阶乘</td><td>非尾递归</td><td>调用后还有乘法操作</td></tr><tr><td>数组求和</td><td>非尾递归</td><td>每次取头递尾</td></tr><tr><td>二分查找</td><td>非尾递归</td><td>分治思想，递归缩小范围</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-14">核心思路</h3>
<ul>
<li>只需提供递归逻辑，<code>createRecursiveFunction</code> 负责自引用；</li>
<li>递归逻辑模板统一：</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">logic</span> = (<span class="hljs-params">self</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
  <span class="hljs-comment">// ...递归逻辑</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">self</span>(...args); <span class="hljs-comment">// 调用自身</span>
};
<span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">createRecursiveFunction</span>(logic);
</code></pre>
<p>通过练习，可以更好理解<strong>高阶函数 + 递归</strong>的组合思维，并能应用于实际项目中的树结构、异步任务等场景。</p>
<hr/>
<h2 data-id="heading-15">项目中的实际应用场景</h2>
<p>在真实项目中，高阶函数递归能让代码更灵活、更模块化。<br/>
常见的实战场景包括：</p>
<ul>
<li>树结构遍历（菜单、评论、权限等）</li>
<li>异步重试机制（API 调用失败重试）</li>
<li>动态轮询（等待异步任务完成）</li>
</ul>
<hr/>
<h3 data-id="heading-16">遍历树形菜单</h3>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">createRecursiveFunction</span> = (f) =&gt; {
  return (<span class="hljs-attr">g</span> =&gt; g(g))(h =&gt; f((...args) =&gt; h(h)(...args)))<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

// 扁平化树
const <span class="hljs-attr">flattenTreeLogic</span> = (self) =&gt; (nodes, result = []) =&gt; {
  for (const node of nodes) {
    result.push({ id: node.id, name: node.name })<span class="hljs-comment">;</span>
    if (node.children?.length) self(node.children, result)<span class="hljs-comment">;</span>
  }
  return result<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">flattenTree</span> = createRecursiveFunction(flattenTreeLogic)<span class="hljs-comment">;</span>

const <span class="hljs-attr">menu</span> = [
  { id: <span class="hljs-number">1</span>, name: <span class="hljs-string">'首页'</span> },
  {
    id: <span class="hljs-number">2</span>,
    name: <span class="hljs-string">'用户管理'</span>,
    children: [
      { id: <span class="hljs-number">3</span>, name: <span class="hljs-string">'用户列表'</span> },
      { id: <span class="hljs-number">4</span>, name: <span class="hljs-string">'用户详情'</span> },
    ],
  },
]<span class="hljs-comment">;</span>

console.log(flattenTree(menu))<span class="hljs-comment">;</span>
</code></pre>
<p>输出：</p>
<pre><code class="hljs language-bash" lang="bash">[
  { <span class="hljs-built_in">id</span>: 1, name: <span class="hljs-string">'首页'</span> },
  { <span class="hljs-built_in">id</span>: 2, name: <span class="hljs-string">'用户管理'</span> },
  { <span class="hljs-built_in">id</span>: 3, name: <span class="hljs-string">'用户列表'</span> },
  { <span class="hljs-built_in">id</span>: 4, name: <span class="hljs-string">'用户详情'</span> }
]
</code></pre>
<hr/>
<h3 data-id="heading-17">异步重试机制</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createRecursiveFunction</span> = (<span class="hljs-params">f</span>) =&gt; {
  <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> <span class="hljs-title function_">g</span>(g))(<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">f</span>(<span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">h</span>(h)(...args)));
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">retryLogic</span> = (<span class="hljs-params">self</span>) =&gt; <span class="hljs-keyword">async</span> (fn, retries = <span class="hljs-number">3</span>, delay = <span class="hljs-number">1000</span>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fn</span>();
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">if</span> (retries &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> err;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`重试中，还剩 <span class="hljs-subst">${retries}</span> 次...`</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(r, delay));
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">self</span>(fn, retries - <span class="hljs-number">1</span>, delay);
  }
};

<span class="hljs-keyword">const</span> retry = <span class="hljs-title function_">createRecursiveFunction</span>(retryLogic);

<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">unstableApi</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  count++;
  <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'失败'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">'成功'</span>;
};

<span class="hljs-title function_">retry</span>(unstableApi, <span class="hljs-number">5</span>, <span class="hljs-number">500</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'结果：'</span>, res))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'最终失败:'</span>, err.<span class="hljs-property">message</span>));
</code></pre>
<p>输出：</p>
<pre><code class="hljs language-erlang" lang="erlang">重试中，还剩 <span class="hljs-number">5</span> 次...
重试中，还剩 <span class="hljs-number">4</span> 次...
结果： 成功
</code></pre>
<hr/>
<h3 data-id="heading-18">动态轮询任务</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createRecursiveFunction</span> = (<span class="hljs-params">f</span>) =&gt; {
  <span class="hljs-keyword">return</span> (<span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> <span class="hljs-title function_">g</span>(g))(<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">f</span>(<span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">h</span>(h)(...args)));
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">pollingLogic</span> = (<span class="hljs-params">self</span>) =&gt; <span class="hljs-keyword">async</span> (checkFn, interval = <span class="hljs-number">1000</span>, maxTries = <span class="hljs-number">10</span>) =&gt; {
  <span class="hljs-keyword">const</span> done = <span class="hljs-keyword">await</span> <span class="hljs-title function_">checkFn</span>();
  <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (maxTries &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`未完成，<span class="hljs-subst">${interval}</span>ms 后再次检查...`</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(r, interval));
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">self</span>(checkFn, interval, maxTries - <span class="hljs-number">1</span>);
};

<span class="hljs-keyword">const</span> polling = <span class="hljs-title function_">createRecursiveFunction</span>(pollingLogic);

<span class="hljs-keyword">let</span> progress = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">checkTask</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  progress += <span class="hljs-number">30</span>;
  <span class="hljs-keyword">return</span> progress &gt;= <span class="hljs-number">100</span>;
};

<span class="hljs-title function_">polling</span>(checkTask, <span class="hljs-number">1000</span>, <span class="hljs-number">5</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">done</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(done ? <span class="hljs-string">'任务完成！'</span> : <span class="hljs-string">'超时未完成'</span>);
});
</code></pre>
<hr/>
<h2 data-id="heading-19">从抽象到实用</h2>





















<table><thead><tr><th>场景</th><th>应用优势</th></tr></thead><tbody><tr><td>树结构处理</td><td>灵活定义逻辑，便于复用</td></tr><tr><td>异步重试</td><td>自动化错误恢复</td></tr><tr><td>动态轮询</td><td>可配置、可扩展</td></tr></tbody></table>
<p>高阶函数递归不仅是理论技巧，更是函数式思维在工程化中的体现。<br/>
当逻辑复杂、变化频繁时，用函数组合取代命名函数，可以极大提升灵活性。</p>
<hr/>
<h2 data-id="heading-20">结语</h2>
<p>本文从匿名递归出发，一步步构建了一个通用的递归生成器，并结合项目实战展示了高阶函数递归的实用价值。</p>
<p>这类模式的核心思想是：<br/>
<strong>将递归结构与逻辑解耦，让函数更通用、更可组合。</strong></p>
<p>如果你觉得本文对你有帮助，欢迎点赞、收藏或分享，让更多人了解高阶函数的实际应用。<br/>
你的点赞，就是我继续写作的最大动力。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI也能像人一样拥有长时记忆了！谷歌最新研究攻克AI核心难题]]></title>    <link>https://juejin.cn/post/7570885801478111273</link>    <guid>https://juejin.cn/post/7570885801478111273</guid>    <pubDate>2025-11-10T10:44:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570885801478111273" data-draft-id="7570899512782078015" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI也能像人一样拥有长时记忆了！谷歌最新研究攻克AI核心难题"/> <meta itemprop="keywords" content="人工智能,资讯,机器学习"/> <meta itemprop="datePublished" content="2025-11-10T10:44:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="算家计算"/> <meta itemprop="url" content="https://juejin.cn/user/1426490793396571"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI也能像人一样拥有长时记忆了！谷歌最新研究攻克AI核心难题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1426490793396571/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    算家计算
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T10:44:38.000Z" title="Mon Nov 10 2025 10:44:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>谷歌的新研究，让AI也能像人类一样持续学习而不遗忘了。</p>
</blockquote>
<p>一般情况下，当我们学会一项新技能后，并不会忘记如何走路、说话这些基本能力。然而，这正是人工智能长期面临的困境。当AI学习新知识时，往往会像覆盖旧磁带一样，<strong>损害甚至完全抹去已经掌握的旧技能</strong>，这种现象被称为 <strong>“灾难性遗忘”。</strong></p>
<p>现在，谷歌研究院带来了一项突破性解决方案。11月7日，谷歌正式发布了全新的机器学习范式——<strong>嵌套学习（Nested Learning）</strong> ，直指这个困扰AI领域数十年的根本性难题。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2ada2ecf61d469b9df440ef6799f730~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg566X5a626K6h566X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376278&amp;x-signature=P63QdnOIfCp%2BduDQl0j6o5sGe0w%3D" alt="图表比较了生物脑电波和神经可塑性与嵌套学习模型中使用的均匀结构和多频更新。" loading="lazy"/></p>
<p>灾难性遗忘并非新问题。在传统机器学习中，模型在固定数据集上完成训练后便进入部署阶段。一旦需要学习新任务，模型往往需要重新训练或微调，而这极易导致旧知识被覆盖。</p>
<p>这就好比一个原本精通图像分类的AI系统，在学习目标检测后可能完全丧失原有的识别能力；或者一个语音助手在升级方言理解功能后，反而忘记了标准普通话的处理逻辑。</p>
<p>研究表明，在连续学习超过五个任务后，传统模型的平均性能下降幅度高达<strong>60%以上</strong>。这种局限性严重阻碍了AI在需要长期经验积累的领域应用，如医疗诊断、自动驾驶等。</p>
<p><strong>嵌套学习：统一架构与算法的全新范式</strong></p>
<p>谷歌提出的嵌套学习范式带来了根本性的变革。其核心理念是将模型架构与优化算法统一起来，将复杂模型视为一系列相互嵌套或并行的优化问题。</p>
<p>在嵌套学习框架下，模型中的每个组件都有自己的“上下文流”和更新速率。这就像人脑的学习机制——我们对眼前事物的瞬时记忆更新极快，为考试而进行的短期记忆更新速度次之，而构成世界观、价值观的长期知识则更新得非常缓慢。</p>
<p>谷歌研究团队基于这一范式开发了名为Hope的概念验证模型，它基于Titans架构的自修改循环网络，深度集成了连续体内存系统（CMS）。这种设计使模型能够通过自我参照机制优化自身内存结构，支持近乎无限层级的上下文学习。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f41d1ff4fbbe4408a6f7d2ae57e1c700~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg566X5a626K6h566X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376278&amp;x-signature=RYIj2arIptxlQWMCdzYlVVDQado%3D" alt="图片" loading="lazy"/></p>
<p><strong>技术突破：从深度优化器到连续内存系统</strong></p>
<p>嵌套学习范式的创新体现在三个关键技术突破上。</p>
<p>首先，深度优化器将优化器本身作为可学习模块，改进了目标函数，提升了对不完美数据的鲁棒性。传统优化器如Adam中的动量项，在嵌套学习视角下可被看作是微型的关联记忆模块。</p>
<p>同时，连续体内存系统（CMS）构建了由不同更新频率模块组成的内存光谱，实现了从短期到长期记忆的平滑过渡。CMS由一系列神经网络块连接而成，每个块关联着特定的更新频率，彻底改变了传统AI模型中短期记忆和长期记忆的二元划分。</p>
<p>自修改架构则使模型能够根据任务动态调整自身的学习算法，包括注意力机制中的键、值、查询投影等关键部分。这让模型拥有了在使用过程中不断优化自己学习策略的能力。</p>
<p><strong>实验结果</strong></p>
<p>在实验评估中，Hope模型在语言建模与常识推理任务中表现出<strong>更低的困惑度和更高的准确性</strong>，优于现代循环模型和标准Transformer架构。</p>
<p>特别引人注目的是，在“大海捞针”测试中，Hope展示出了卓越的长文本记忆与检索能力，验证了CMS在处理超长序列信息中的有效性。这一测试结果证明了嵌套学习范式在解决灾难性遗忘问题上的潜力。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e51b47fd09a40c38d8de12a878a98fb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg566X5a626K6h566X:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763376278&amp;x-signature=ynKoPRwgsLVhsEfgTNTUw3T5nV4%3D" alt="条形图显示 Hope 和 Titans 模型在三个难度级别的长上下文任务中始终优于 TTT 和 Mamba2。" loading="lazy"/></p>
<p>研究团队在340M、760M和1.3B三种参数规模的Hope模型上进行了全面测试，Hope的平均分超越了所有对比模型。这表明嵌套学习范式在不同规模的模型上都能发挥积极作用。</p>
<p>嵌套学习的意义远不止于技术层面的突破。它为实现持续学习的人工智能系统开辟了全新路径。</p>
<p>这一技术将可能很大程度上改变那些需要终身学习的应用领域，比如机器人、自动驾驶、个性化AI助手等。这些系统将不再需要昂贵的、从头开始的再训练，而是能够像人类一样，在保留已有知识的基础上，不断学习和成长。</p>
<p>正如谷歌研究人员所言：“我们相信嵌套学习范式为弥补当前大语言模型有限、易遗忘的特性与人脑卓越的持续学习能力之间的差距奠定了坚实基础。”</p>
<p>当然，这项研究仍在发展之中。研究人员指出，目前的工作主要聚焦于记忆的在线巩固过程，对类似人脑睡眠时的离线重放和整理机制探索有限。但这无疑让我们距离那个能像人类一样持续学习、不断进化的通用人工智能又近了一步。</p>
<p>大家怎么看？欢迎交流讨论~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[共绩算力赋能大模型：QWEN-2.5-7B云部署实战解析]]></title>    <link>https://juejin.cn/post/7570500819889258539</link>    <guid>https://juejin.cn/post/7570500819889258539</guid>    <pubDate>2025-11-10T07:42:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570500819889258539" data-draft-id="7570339961909936171" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="共绩算力赋能大模型：QWEN-2.5-7B云部署实战解析"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-10T07:42:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="_摘星_"/> <meta itemprop="url" content="https://juejin.cn/user/2228036358374227"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            共绩算力赋能大模型：QWEN-2.5-7B云部署实战解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2228036358374227/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    _摘星_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T07:42:20.000Z" title="Mon Nov 10 2025 07:42:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body cache result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbf8c323836144e0a235cdd139b387df~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=NqRjTiwbrXaLr8NSHXVb96vu55g%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">共绩算力赋能大模型：QWEN-2.5-7B云部署实战解析</h2>
<h3 data-id="heading-1">摘要</h3>
<p>本文详细介绍了在共绩算力平台上部署通义千问2.5-7B-Instruct大模型的全流程实践。共绩算力作为清华背景创业团队打造的创新平台，通过整合全国分散的闲置算力资源（包括个人电脑、网吧空闲机时和企业未充分利用的算力），构建了极具价格优势的算力网络。平台提供两种核心服务：适合长期开发的Server云主机（4090单卡仅1.68元/小时，关机环境持久保存）和面向生产的Serverless弹性部署（秒级冷启动，零运维）。文章详细记录了从算力选择、镜像配置到模型下载、基准测试的完整过程，实测证明单张4090显卡即可高效运行7B级别大模型，为AI开发者提供了高性价比的云部署方案。</p>
<h3 data-id="heading-2">共绩算力</h3>
<h4 data-id="heading-3">平台概述</h4>
<p>共绩科技 2023 年成立于清华，专注于构建融合算力与电力的智能调度网络，旨在提供平价、可靠、绿色的算力服务，使 AI 技术真正普及至每个人。通过精细调度算法，已为多家 AIGC 领军企业及科研机构提供高效算力，目标提升资源利用率 60%。作为一群清华背景的年轻创新者，我们在 2023 年秋季获得奇绩创坛等投资，正引领算力革命，开启普惠科技新篇章。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d802b6b0c7845e4b528723d3c447f9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=l%2Bd5MxbBzx2rbGlWxVEfn0qtptk%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-4">核心功能</h4>
<p>共绩算力平台为开发者和企业提供两大核心服务模式：<strong>Server 云主机</strong> 和 <strong>Serverless 弹性部署</strong>，满足不同场景下的算力需求。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a77e2f330bf48239050207668482dfc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=j36Mru%2BXnwssw%2ByMAEHLX53IjMY%3D" alt="" loading="lazy"/></p>
<h5 data-id="heading-5">Server 云主机</h5>
<p>专为需要稳定、持久开发环境的用户设计。平台拥有上万块高性能4090显卡随时待命，让每个开发者都能轻松拥有顶级算力，无需为数万元的硬件投入望而却步。</p>
<p>核心优势：</p>
<ul>
<li><strong>告别硬件投资</strong>：无需购买昂贵的GPU服务器，按需租用即可。</li>
<li><strong>环境永久保存</strong>：关机后开发环境不会丢失，下次开机即恢复，省去重复搭建环境的烦恼。</li>
<li><strong>专注代码开发</strong>：将精力完全集中在算法和业务逻辑上，而非基础设施管理。</li>
</ul>
<p>关键参数：</p>
<ul>
<li><strong>10万+ 显卡数量</strong>：海量资源池，保障随时可用。</li>
<li><strong>1.68元/时 起步价</strong>：极具竞争力的价格，让高性能计算触手可及。</li>
<li><strong>关机保存 持久化</strong>：支持关机状态下的环境持久化，保障开发连续性。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>开发测试</li>
<li>学习训练</li>
<li>长期项目研发</li>
</ul>
<p><strong>选择 Server 云主机，当您面临以下困扰时：</strong></p>
<ul>
<li>每次重新搭建开发环境太麻烦</li>
<li>需要一个稳定的长期开发环境</li>
<li>不需要对外提供在线服务</li>
</ul>
<hr/>
<h5 data-id="heading-6">Serverless 弹性部署</h5>
<p>面向生产级应用和流量波动场景，提供零运维、秒级冷启动的极致体验。写完代码，10秒内即可上线，按实际使用量付费，真正做到“用多少付多少”，实现0运维成本。</p>
<p>核心优势：</p>
<ul>
<li><strong>告别运维烦恼</strong>：无需关心服务器运维、扩容、监控等底层问题。</li>
<li><strong>弹性应对流量</strong>：智能自动扩缩容，从容应对突发流量高峰。</li>
<li><strong>专注产品开发</strong>：开发者只需关注产品本身，基础设施由平台全权托管。</li>
</ul>
<p>关键指标：</p>
<ul>
<li><strong>99.9% 可用性</strong>：高可靠性保障线上服务稳定运行。</li>
<li><strong>秒级冷启动</strong>：从代码提交到服务上线仅需10秒，响应迅速。</li>
<li><strong>0运维 零负担</strong>：无服务器管理负担，释放团队生产力。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>生产服务部署</li>
<li>突发流量应对（如营销活动、热点事件）</li>
<li>在线用户访问服务</li>
</ul>
<p><strong>选择 Serverless 弹性部署，当您面临以下挑战时：</strong></p>
<ul>
<li>担心突发流量导致服务宕机</li>
<li>不想花时间在服务器运维上</li>
<li>希望严格控制云服务成本</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6bb5dddc68d8427a9965c18dbea91488~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=h3Ti9u3hbRR3MYJ1%2BDxn5j6LGjw%3D" alt="" loading="lazy"/></p>
<p>无论是追求环境稳定、适合长期开发的 <strong>Server 云主机</strong>，还是追求极致效率、零运维负担的 <strong>Serverless 弹性部署</strong>，共绩算力平台都提供了针对性强、性价比极高的解决方案，帮助开发者和企业摆脱基础设施束缚，专注于价值创造。</p>
<h4 data-id="heading-7">技术架构</h4>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b8f2f05d8124544ab16b65434e3ac30~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=4i1Du2UiYkO%2FaFw7w6R3VoCdkPg%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-8">降本增效</h4>
<p>共绩算力平台的核心优势之一在于其极具竞争力的价格体系，真正实现了“降本增效”，让每一分钱都花在刀刃上。与传统云服务商动辄数十元甚至上百元每小时的GPU算力相比，共绩平台提供的4090显卡算力价格低至<strong>1.68元/小时（单卡）</strong> ，双卡配置仅需<strong>3.36元/小时</strong>，四卡集群也仅为<strong>6.72元/小时</strong>。这种按秒计费的精细化模式，意味着用户只需为实际使用的每一秒付费，避免了传统按小时计费带来的资源浪费和成本冗余。</p>
<p>更重要的是，这些价格背后是平台创新的商业模式——通过整合全国范围内的个人闲置电脑、网吧空闲机时以及企业未充分利用的算力资源，构建了一个庞大的分布式算力网络。这种“共享经济”模式大幅降低了基础设施的边际成本，从而将节省下来的费用直接回馈给终端用户。无论是AI初创团队进行模型训练，还是个人开发者部署推理服务，都能以极低的成本获得高性能的4090 GPU算力支持，彻底告别“算力焦虑”，把宝贵的预算集中投入到核心算法研发和业务创新上，而非昂贵的硬件投入或云服务账单中。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e6e01e0cc712464c85604d7598c94cb2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=ibNJ0SSn9l8wUWGMS5%2BGYi0HagU%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-9">平台对比分析</h4>



























































<table><thead><tr><th>对比维度</th><th>共绩算力平台</th><th>传统云服务商</th><th>自建GPU集群</th></tr></thead><tbody><tr><td><strong>成本模式</strong></td><td>按秒级精准计费，只为使用时间付费</td><td>按小时/月计费，存在资源浪费</td><td>高额前期投入，固定成本高</td></tr><tr><td><strong>资源弹性</strong></td><td>秒级扩容缩容，动态适应业务需求</td><td>分钟级扩容，存在一定延迟</td><td>无法弹性扩展，需提前规划</td></tr><tr><td><strong>资源来源</strong></td><td>整合全国分散闲时算力，包括个人/网吧/智算中心</td><td>自有数据中心，资源集中</td><td>企业自购硬件，资源固定</td></tr><tr><td><strong>部署速度</strong></td><td>3分钟快速部署AI服务</td><td>10-30分钟创建实例</td><td>数天到数周的部署周期</td></tr><tr><td><strong>技术门槛</strong></td><td>一站式GPU开发环境，降低配置复杂度</td><td>需要一定云服务使用经验</td><td>需要专业运维团队支持</td></tr><tr><td><strong>绿色节能</strong></td><td>利用闲置算力，提高资源利用率，更环保</td><td>数据中心能耗较高</td><td>能源利用率低，存在浪费</td></tr><tr><td><strong>适用场景</strong></td><td>AI推理/训练、科研计算、临时高算力需求</td><td>通用云计算、企业应用</td><td>长期稳定的大规模计算需求</td></tr><tr><td><strong>价格优势</strong></td><td>价格更低，性价比高</td><td>价格中等，按量付费</td><td>长期使用成本高</td></tr></tbody></table>
<h3 data-id="heading-10">魔搭社区和通义千问2.5-7B-Instruct</h3>
<h4 data-id="heading-11">概述</h4>
<p>魔搭社区（ModelScope）是阿里巴巴推出的<strong>模型开放平台</strong>，致力于打造“<strong>模型即服务</strong>（MaaS）”的生态体系。该平台提供海量高质量机器学习和深度学习模型，覆盖自然语言处理、计算机视觉、语音识别、多模态等多个技术领域。</p>
<h4 data-id="heading-12">魔搭社区核心特点：</h4>
<ul>
<li><strong>模型丰富</strong>：汇聚数千个开源模型，包括阿里自研模型及社区贡献模型</li>
<li><strong>开箱即用</strong>：提供一键推理、在线体验、Notebook实例等功能，降低使用门槛</li>
<li><strong>全链路支持</strong>：从模型探索、训练、推理到部署，提供完整工具链</li>
<li><strong>社区活跃</strong>：支持模型分享、评测、讨论，促进AI技术交流与创新</li>
<li><strong>企业级能力</strong>：支持私有化部署、模型定制和商业化服务</li>
</ul>
<p>魔搭不仅是模型仓库，更是连接模型开发者与使用者的桥梁，推动AI技术的普惠化和产业化。</p>
<h4 data-id="heading-13">通义千问2.5-7B-Instruct模型下载指南</h4>
<p>在魔搭社区模型库中找到通义千问2.5-7B-Instruct并进入详情</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b8f05ac2bad48848afe62960ffaa508~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=Sv6QfNlYdwG7P0pu5amKyuWrGqM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3172b3d49c6d49b1a613f0845d3d2f9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=VP4IRFBtateMToNutMJMeG9lLGk%3D" alt="" loading="lazy"/></p>
<p>按照官方给出的下载模型配置待会到共绩算力平台中进行部署</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e703a892ad674e6dba3125822a71503f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=s2dA7VtXpU6XImque8IxWY8vfy0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-14">云主机部署实践</h3>
<h4 data-id="heading-15">算力选择</h4>
<p>进入共绩算力云主机页面中：<a href="https://link.juejin.cn?target=https%3A%2F%2Fconsole.suanli.cn%2Fserver" target="_blank" title="https://console.suanli.cn/server" ref="nofollow noopener noreferrer">console.suanli.cn/server</a></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6c10156d327248e3820a85285f80009e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=W6y2Y2PGkWgp8acJwmYSsK7FbRk%3D" alt="" loading="lazy"/></p>
<p>可以看到价格和算力性价比真的是十分高，这里分别展示1核、2核、4核、8核的价格对比</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87e253990f864fcd84491b31901bc1be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=RNYefLeymLnk6qVOxc8cpkKck20%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8448a7f942524b948bdcfe048c88aa3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=Vfhr7mH%2F7R479pBQR2gULKcblvQ%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2b7c30dc8ed4e4dbba7b47597cac949~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=SOvjaYzIaegW%2FwS7NMGVY9K21wI%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3408630133fa4a74b19ab67eab1c10c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=NVOrKOOf1bULkW911fnSmGWALEA%3D" alt="" loading="lazy"/></p>
<p>那么我们之类选择单核即可</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3a2fbb8eb46489d8ccbc460d8ab311e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=WLks5riAzzenWgyUOsWwejbnQRM%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-16">镜像选择</h4>
<p>共绩算力的基础镜像中为我们提供了三种框架的选择</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5beac96bc43c41ccb7cd063dfbea6566~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=Oy%2FO1gaOcvk%2FPiEfqGiZDMCtQFM%3D" alt="" loading="lazy"/></p>
<p>我们这里的配置如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bdcab40750f549f5b27f204d0941579b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=8A5LZdhflFjnGU9MtBvbQNpXq%2F0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/074b0e59c4464e38b393fd2613235454~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=UBChD193HNeOxEwDEUAcn6ZXqv4%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae67f7624e2f471985318452ff926797~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=YdR6Kwjxo2DmxldzyY7uUZJMNzQ%3D" alt="" loading="lazy"/></p>
<p>🖥️ 云服务器实例配置详情</p>

































<table><thead><tr><th>配置类别</th><th>详细参数</th></tr></thead><tbody><tr><td><strong>设备型号</strong></td><td>NVIDIA GeForce RTX 4090 / 24GB 显存</td></tr><tr><td><strong>所属区域</strong></td><td>重庆一区</td></tr><tr><td><strong>CPU 核心数</strong></td><td>20 核</td></tr><tr><td><strong>内存容量</strong></td><td>101 GB</td></tr><tr><td><strong>CUDA 支持</strong></td><td>11.3 ~ 12.8（驱动版本：470.82.01+）</td></tr><tr><td><strong>系统硬盘</strong></td><td>50 GB</td></tr></tbody></table>
<p>🐍 系统镜像配置</p>





























<table><thead><tr><th>组件类型</th><th>版本/规格</th></tr></thead><tbody><tr><td>框架名称</td><td>PyTorch</td></tr><tr><td>框架版本</td><td>2.7.1</td></tr><tr><td>Python 版本</td><td>3.12 (Ubuntu 22.04)</td></tr><tr><td>CUDA 版本</td><td>12.8</td></tr><tr><td>镜像类型</td><td>基础镜像（含深度学习框架、Miniconda等常用工具）</td></tr></tbody></table>
<p>同时共绩算力中还提供了社区用户自己开发的镜像，我也会在后续的文章中进行试用</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/09585e47df4044f080d42df65465c080~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=Z8Qtp%2FDRqs3ManOcs%2BkFSFYgb8w%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-17">创建实例</h4>
<p>点击创建实例之后，共绩算力就会在后台自动为我们创建刚刚选好的云主机</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3201969bfb5e4567931c1ca39cdd9096~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=8nGwcN4VvV0Lps2YgwB29mm1LoA%3D" alt="" loading="lazy"/></p>
<p>并且共绩算力这里提供了三种快捷操作方式，这里我选择Jupyter Lab</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd22f0a6068a4d018c50a3e011bcdb6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=sgE9Y3cQdBqpT0jWn3emxzU0uqE%3D" alt="" loading="lazy"/></p>
<p>进入Jupyter Lab之后进入到终端</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3120ee067a7945a6b110060ea1ff474a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=sypDz00V78EViwbSg2Di%2BJEP%2BdE%3D" alt="" loading="lazy"/></p>
<p>执行下方命令从魔搭社区中下载Qwen/Qwen2.5-7B-Instruct模型</p>
<pre><code class="hljs language-css" lang="css">pip install modelscope
modelscope download <span class="hljs-attr">--model</span> Qwen/Qwen2.<span class="hljs-number">5</span>-<span class="hljs-number">7</span>B-Instruct
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f9e9c2d95dc947a983c4c80e57e8402d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=bBl7e3dokCD80CPylBWrwHSbseg%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs">pip install transformers torch tqdm accelerate
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6535f72961114d409ba02c756cf7a9c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=%2BV6Je5FRRJxGsEHw1n%2BUWMVKzzQ%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-18">基准测试</h4>
<p>准备好下方的基准测试脚本</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM
<span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> os

<span class="hljs-comment"># ========== 配置参数 ==========</span>
MODEL_NAME = <span class="hljs-string">"/root/.cache/modelscope/hub/models/Qwen/Qwen2.5-7B-Instruct"</span>
WARMUP_STEPS = <span class="hljs-number">1</span>
TEST_STEPS = <span class="hljs-number">3</span>
BATCH_SIZES = [<span class="hljs-number">1</span>]  <span class="hljs-comment"># 简化测试</span>
MAX_NEW_TOKENS = <span class="hljs-number">128</span>

<span class="hljs-comment"># 🌐 五种测试场景的提示词</span>
TEST_SCENARIOS = {
    <span class="hljs-string">"🇨🇳 中文生成"</span>: <span class="hljs-string">"今天天气真好，我想去"</span>,
    <span class="hljs-string">"🇺🇸 英文生成"</span>: <span class="hljs-string">"The capital of France is"</span>,
    <span class="hljs-string">"🧠 逻辑推理"</span>: <span class="hljs-string">"如果所有的A都是B，而所有的B都是C，那么所有的A是C吗？请详细解释。"</span>,
    <span class="hljs-string">"💻 代码生成"</span>: <span class="hljs-string">"用Python写一个快速排序算法"</span>,
    <span class="hljs-string">"📖 知识问答"</span>: <span class="hljs-string">"量子力学中的薛定谔方程是用来描述什么的？"</span>
}

<span class="hljs-comment"># ========== 工具函数 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">print_gpu_memory</span>():
    <span class="hljs-string">"""📊 打印当前GPU内存使用情况"""</span>
    allocated = torch.cuda.memory_allocated() / <span class="hljs-number">1024</span>**<span class="hljs-number">3</span>
    reserved = torch.cuda.memory_reserved() / <span class="hljs-number">1024</span>**<span class="hljs-number">3</span>
    max_allocated = torch.cuda.max_memory_allocated() / <span class="hljs-number">1024</span>**<span class="hljs-number">3</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"💽 GPU内存: 已分配 <span class="hljs-subst">{allocated:<span class="hljs-number">.2</span>f}</span>GB | 预留 <span class="hljs-subst">{reserved:<span class="hljs-number">.2</span>f}</span>GB | 峰值 <span class="hljs-subst">{max_allocated:<span class="hljs-number">.2</span>f}</span>GB"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">format_time</span>(<span class="hljs-params">seconds</span>):
    <span class="hljs-string">"""⏱️ 格式化时间显示"""</span>
    <span class="hljs-keyword">if</span> seconds &lt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{seconds*<span class="hljs-number">1000</span>:<span class="hljs-number">.2</span>f}</span> ms"</span>
    <span class="hljs-keyword">elif</span> seconds &lt; <span class="hljs-number">60</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{seconds:<span class="hljs-number">.2</span>f}</span> 秒"</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{seconds/<span class="hljs-number">60</span>:<span class="hljs-number">.2</span>f}</span> 分钟"</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">display_banner</span>(<span class="hljs-params">title</span>):
    <span class="hljs-string">"""🎉 显示漂亮的标题横幅"""</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{<span class="hljs-string">'='</span> * <span class="hljs-number">60</span>}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✨ <span class="hljs-subst">{title}</span> ✨"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{<span class="hljs-string">'='</span> * <span class="hljs-number">60</span>}</span>"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_with_stats</span>(<span class="hljs-params">model, tokenizer, prompt, max_new_tokens=MAX_NEW_TOKENS</span>):
    <span class="hljs-string">"""⚡ 执行单次生成并收集统计信息"""</span>
    <span class="hljs-comment"># 准备输入</span>
    inputs = tokenizer(prompt, return_tensors=<span class="hljs-string">"pt"</span>).to(model.device)
    input_length = inputs.input_ids.shape[<span class="hljs-number">1</span>]

    <span class="hljs-comment"># 生成</span>
    start_time = time.perf_counter()
    <span class="hljs-keyword">with</span> torch.no_grad():
        outputs = model.generate(
            **inputs,
            max_new_tokens=max_new_tokens,
            do_sample=<span class="hljs-literal">True</span>,
            temperature=<span class="hljs-number">0.7</span>,
            top_p=<span class="hljs-number">0.9</span>
        )
    end_time = time.perf_counter()

    <span class="hljs-comment"># 计算指标</span>
    generation_time = end_time - start_time
    generated_tokens = outputs[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>] - input_length
    tokens_per_second = generated_tokens / generation_time <span class="hljs-keyword">if</span> generation_time &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>

    <span class="hljs-comment"># 解码生成的文本</span>
    generated_text = tokenizer.decode(outputs[<span class="hljs-number">0</span>][input_length:], skip_special_tokens=<span class="hljs-literal">True</span>)

    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"time"</span>: generation_time,
        <span class="hljs-string">"tokens_generated"</span>: generated_tokens,
        <span class="hljs-string">"tokens_per_second"</span>: tokens_per_second,
        <span class="hljs-string">"output_text"</span>: generated_text,
        <span class="hljs-string">"memory_used"</span>: torch.cuda.max_memory_allocated() / <span class="hljs-number">1024</span>**<span class="hljs-number">3</span>
    }

<span class="hljs-comment"># ========== 主测试函数 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">benchmark_model</span>():
    display_banner(<span class="hljs-string">"🚀 模型加载中"</span>)

    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 加载模型和tokenizer</span>
        tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME, trust_remote_code=<span class="hljs-literal">True</span>)
        model = AutoModelForCausalLM.from_pretrained(
            MODEL_NAME,
            device_map=<span class="hljs-string">"auto"</span>,
            torch_dtype=torch.bfloat16,
            trust_remote_code=<span class="hljs-literal">True</span>
        )
        model.<span class="hljs-built_in">eval</span>()

        <span class="hljs-comment"># 打印模型信息</span>
        device = <span class="hljs-built_in">next</span>(model.parameters()).device
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ 模型加载成功！"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🧠 模型: <span class="hljs-subst">{MODEL_NAME}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🖥️  设备: <span class="hljs-subst">{device}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🔧 数据类型: <span class="hljs-subst">{model.dtype}</span>"</span>)
        print_gpu_memory()
        
        <span class="hljs-comment"># ========== 预热 ==========</span>
        display_banner(<span class="hljs-string">"🔥 预热阶段"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"预热模型中..."</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(WARMUP_STEPS):
            _ = generate_with_stats(model, tokenizer, <span class="hljs-string">"你好"</span>, max_new_tokens=<span class="hljs-number">32</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"预热步骤 <span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>/<span class="hljs-subst">{WARMUP_STEPS}</span> 完成"</span>)
        
        <span class="hljs-comment"># ========== 五种场景测试 ==========</span>
        all_results = {}
        
        <span class="hljs-keyword">for</span> scenario_name, prompt <span class="hljs-keyword">in</span> TEST_SCENARIOS.items():
            display_banner(<span class="hljs-string">f"🔍 <span class="hljs-subst">{scenario_name}</span> 测试"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📝 测试提示: "</span>{prompt}<span class="hljs-string">""</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"🔄 执行 <span class="hljs-subst">{TEST_STEPS}</span> 次迭代..."</span>)
            
            scenario_results = []
            
            <span class="hljs-comment"># 预先清除GPU缓存</span>
            torch.cuda.empty_cache()
            torch.cuda.reset_peak_memory_stats()
            
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(TEST_STEPS), desc=<span class="hljs-string">f"⏳ <span class="hljs-subst">{scenario_name}</span>"</span>):
                result = generate_with_stats(model, tokenizer, prompt)
                scenario_results.append(result)
                        
                <span class="hljs-comment"># 打印单次结果</span>
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{scenario_name}</span> - 迭代 <span class="hljs-subst">{i+<span class="hljs-number">1</span>}</span>/<span class="hljs-subst">{TEST_STEPS}</span>:"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   ⏱️  生成时间: <span class="hljs-subst">{format_time(result[<span class="hljs-string">'time'</span>])}</span>"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📏 生成长度: <span class="hljs-subst">{result[<span class="hljs-string">'tokens_generated'</span>]}</span> tokens"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🚀 生成速度: <span class="hljs-subst">{result[<span class="hljs-string">'tokens_per_second'</span>]:<span class="hljs-number">.2</span>f}</span> tokens/秒"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   💾 峰值内存: <span class="hljs-subst">{result[<span class="hljs-string">'memory_used'</span>]:<span class="hljs-number">.2</span>f}</span> GB"</span>)
                <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🎯 生成内容: <span class="hljs-subst">{result[<span class="hljs-string">'output_text'</span>][:<span class="hljs-number">50</span>]}</span>..."</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result[<span class="hljs-string">'output_text'</span>]) &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">else</span> <span class="hljs-string">f"   🎯 生成内容: <span class="hljs-subst">{result[<span class="hljs-string">'output_text'</span>]}</span>"</span>)
            
            <span class="hljs-comment"># 计算平均值</span>
            avg_time = <span class="hljs-built_in">sum</span>(r[<span class="hljs-string">"time"</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> scenario_results) / TEST_STEPS
            avg_tokens = <span class="hljs-built_in">sum</span>(r[<span class="hljs-string">"tokens_generated"</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> scenario_results) / TEST_STEPS
            avg_speed = <span class="hljs-built_in">sum</span>(r[<span class="hljs-string">"tokens_per_second"</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> scenario_results) / TEST_STEPS
            max_memory = <span class="hljs-built_in">max</span>(r[<span class="hljs-string">"memory_used"</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> scenario_results)
            
            all_results[scenario_name] = {
                <span class="hljs-string">"avg_time"</span>: avg_time,
                <span class="hljs-string">"avg_tokens"</span>: avg_tokens,
                <span class="hljs-string">"avg_speed"</span>: avg_speed,
                <span class="hljs-string">"max_memory"</span>: max_memory,
                <span class="hljs-string">"sample_output"</span>: scenario_results[-<span class="hljs-number">1</span>][<span class="hljs-string">"output_text"</span>],
                <span class="hljs-string">"prompt"</span>: prompt
            }
            
            <span class="hljs-comment"># 显示该场景的平均结果</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{scenario_name}</span> - 平均性能:"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   ⏱️  平均时间: <span class="hljs-subst">{format_time(avg_time)}</span>"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📏 平均长度: <span class="hljs-subst">{avg_tokens:<span class="hljs-number">.1</span>f}</span> tokens"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🚀 平均速度: <span class="hljs-subst">{avg_speed:<span class="hljs-number">.2</span>f}</span> tokens/秒"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   💾 峰值内存: <span class="hljs-subst">{max_memory:<span class="hljs-number">.2</span>f}</span> GB"</span>)
    
        <span class="hljs-keyword">return</span> all_results, model, tokenizer
    
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"❌ 基准测试失败: <span class="hljs-subst">{<span class="hljs-built_in">str</span>(e)}</span>"</span>)
        <span class="hljs-keyword">import</span> traceback
        traceback.print_exc()
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>

<span class="hljs-comment"># ========== 结果可视化 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">display_results</span>(<span class="hljs-params">all_results</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> all_results:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"❌ 无测试结果"</span>)
        <span class="hljs-keyword">return</span>
    
    display_banner(<span class="hljs-string">"📈 基准测试结果汇总"</span>)
    
    <span class="hljs-comment"># 创建结果表格</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n📊 性能对比:"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span> * <span class="hljs-number">90</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"| <span class="hljs-subst">{<span class="hljs-string">'测试场景'</span>:&lt;<span class="hljs-number">15</span>}</span> | <span class="hljs-subst">{<span class="hljs-string">'平均时间'</span>:&lt;<span class="hljs-number">12</span>}</span> | <span class="hljs-subst">{<span class="hljs-string">'平均速度'</span>:&lt;<span class="hljs-number">15</span>}</span> | <span class="hljs-subst">{<span class="hljs-string">'平均长度'</span>:&lt;<span class="hljs-number">10</span>}</span> | <span class="hljs-subst">{<span class="hljs-string">'峰值内存'</span>:&lt;<span class="hljs-number">10</span>}</span> |"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">14</span> + <span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">13</span> + <span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">16</span> + <span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">11</span> + <span class="hljs-string">"|"</span> + <span class="hljs-string">"-"</span> * <span class="hljs-number">11</span> + <span class="hljs-string">"|"</span>)
    
    <span class="hljs-keyword">for</span> scenario, metrics <span class="hljs-keyword">in</span> all_results.items():
        time_str = format_time(metrics[<span class="hljs-string">"avg_time"</span>])
        speed_str = <span class="hljs-string">f"<span class="hljs-subst">{metrics[<span class="hljs-string">'avg_speed'</span>]:<span class="hljs-number">.2</span>f}</span> t/s"</span>
        tokens_str = <span class="hljs-string">f"<span class="hljs-subst">{metrics[<span class="hljs-string">'avg_tokens'</span>]:<span class="hljs-number">.1</span>f}</span>"</span>
        mem_str = <span class="hljs-string">f"<span class="hljs-subst">{metrics[<span class="hljs-string">'max_memory'</span>]:<span class="hljs-number">.2</span>f}</span> GB"</span>
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"| <span class="hljs-subst">{scenario:&lt;<span class="hljs-number">15</span>}</span> | <span class="hljs-subst">{time_str:&lt;<span class="hljs-number">12</span>}</span> | <span class="hljs-subst">{speed_str:&lt;<span class="hljs-number">15</span>}</span> | <span class="hljs-subst">{tokens_str:&lt;<span class="hljs-number">10</span>}</span> | <span class="hljs-subst">{mem_str:&lt;<span class="hljs-number">10</span>}</span> |"</span>)
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span> * <span class="hljs-number">90</span>)
    
    <span class="hljs-comment"># 显示详细输出样本</span>
    display_banner(<span class="hljs-string">"🎨 生成示例"</span>)
    <span class="hljs-keyword">for</span> scenario, metrics <span class="hljs-keyword">in</span> all_results.items():
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{scenario}</span> 示例:"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"📝 提示: "</span>{metrics[<span class="hljs-string">'prompt'</span>]}<span class="hljs-string">""</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✏️  生成: <span class="hljs-subst">{metrics[<span class="hljs-string">'sample_output'</span>]}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"-"</span> * <span class="hljs-number">60</span>)

<span class="hljs-comment"># ========== 保存结果 ==========</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">save_results</span>(<span class="hljs-params">all_results</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> all_results:
        <span class="hljs-keyword">return</span>
    
    <span class="hljs-comment"># 保存详细结果</span>
    timestamp = time.strftime(<span class="hljs-string">"%Y%m%d_%H%M%S"</span>)
    filename = <span class="hljs-string">f"benchmark_results_<span class="hljs-subst">{timestamp}</span>.json"</span>
    
    serializable_results = {}
    <span class="hljs-keyword">for</span> scenario, metrics <span class="hljs-keyword">in</span> all_results.items():
        serializable_results[scenario] = {
            <span class="hljs-string">"avg_time"</span>: metrics[<span class="hljs-string">"avg_time"</span>],
            <span class="hljs-string">"avg_tokens"</span>: metrics[<span class="hljs-string">"avg_tokens"</span>],
            <span class="hljs-string">"avg_speed"</span>: metrics[<span class="hljs-string">"avg_speed"</span>],
            <span class="hljs-string">"max_memory"</span>: metrics[<span class="hljs-string">"max_memory"</span>],
            <span class="hljs-string">"sample_output"</span>: metrics[<span class="hljs-string">"sample_output"</span>],
            <span class="hljs-string">"prompt"</span>: metrics[<span class="hljs-string">"prompt"</span>]
        }
    
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">"w"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
        json.dump(serializable_results, f, indent=<span class="hljs-number">2</span>, ensure_ascii=<span class="hljs-literal">False</span>)
    
    <span class="hljs-comment"># 保存简化报告</span>
    report_file = <span class="hljs-string">f"benchmark_report_<span class="hljs-subst">{timestamp}</span>.txt"</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(report_file, <span class="hljs-string">"w"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
        f.write(<span class="hljs-string">"通义千问2.5-7B-Instruct 基准测试报告\n"</span>)
        f.write(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span> + <span class="hljs-string">"\n"</span>)
        f.write(<span class="hljs-string">f"测试时间: <span class="hljs-subst">{time.ctime()}</span>\n"</span>)
        f.write(<span class="hljs-string">f"模型路径: <span class="hljs-subst">{MODEL_NAME}</span>\n"</span>)
        f.write(<span class="hljs-string">f"测试迭代: <span class="hljs-subst">{TEST_STEPS}</span> 次\n"</span>)
        f.write(<span class="hljs-string">"="</span> * <span class="hljs-number">60</span> + <span class="hljs-string">"\n\n"</span>)
        
        <span class="hljs-keyword">for</span> scenario, metrics <span class="hljs-keyword">in</span> all_results.items():
            f.write(<span class="hljs-string">f"<span class="hljs-subst">{scenario}</span> 测试:\n"</span>)
            f.write(<span class="hljs-string">f"  - 平均生成时间: <span class="hljs-subst">{format_time(metrics[<span class="hljs-string">'avg_time'</span>])}</span>\n"</span>)
            f.write(<span class="hljs-string">f"  - 平均生成速度: <span class="hljs-subst">{metrics[<span class="hljs-string">'avg_speed'</span>]:<span class="hljs-number">.2</span>f}</span> tokens/秒\n"</span>)
            f.write(<span class="hljs-string">f"  - 平均生成长度: <span class="hljs-subst">{metrics[<span class="hljs-string">'avg_tokens'</span>]:<span class="hljs-number">.1</span>f}</span> tokens\n"</span>)
            f.write(<span class="hljs-string">f"  - 峰值内存使用: <span class="hljs-subst">{metrics[<span class="hljs-string">'max_memory'</span>]:<span class="hljs-number">.2</span>f}</span> GB\n"</span>)
            f.write(<span class="hljs-string">f"  - 测试提示: "</span>{metrics[<span class="hljs-string">'prompt'</span>]}<span class="hljs-string">"\n"</span>)
            f.write(<span class="hljs-string">f"  - 生成示例: <span class="hljs-subst">{metrics[<span class="hljs-string">'sample_output'</span>]}</span>\n"</span>)
            f.write(<span class="hljs-string">"-"</span> * <span class="hljs-number">60</span> + <span class="hljs-string">"\n\n"</span>)
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n✅ 结果已保存至:"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📁 详细数据: <span class="hljs-subst">{filename}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📝 简明报告: <span class="hljs-subst">{report_file}</span>"</span>)

<span class="hljs-comment"># ========== 主程序 ==========</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"🌟 通义千问2.5-7B-Instruct 基准测试工具 🌟"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"🔧 配置参数:"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🧪 模型路径: <span class="hljs-subst">{MODEL_NAME}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   🔥 预热次数: <span class="hljs-subst">{WARMUP_STEPS}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📊 测试迭代: <span class="hljs-subst">{TEST_STEPS}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"   📏 生成长度: <span class="hljs-subst">{MAX_NEW_TOKENS}</span> tokens"</span>)
    
    <span class="hljs-comment"># 执行基准测试</span>
    results, model, tokenizer = benchmark_model()
    
    <span class="hljs-comment"># 显示和保存结果</span>
    <span class="hljs-keyword">if</span> results:
        display_results(results)
        save_results(results)
        
        <span class="hljs-comment"># 清理资源</span>
        <span class="hljs-keyword">if</span> model:
            <span class="hljs-keyword">del</span> model
        <span class="hljs-keyword">if</span> tokenizer:
            <span class="hljs-keyword">del</span> tokenizer
        torch.cuda.empty_cache()
        
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n🎉 基准测试完成! GPU内存已清理."</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n❌ 基准测试未能完成，请检查错误信息。"</span>)

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n💡 提示: 要获得更准确的结果，可增加TEST_STEPS的值。"</span>)
</code></pre>
<p>执行基准测试脚本</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c9a61d23ac54cbbb9430645b4d2f273~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=nHNV0k8jayxdAUbiWFTEICXxvzk%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/225e4d803a3e4919a20cf4dec5f85971~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=EJEazrVPHB7KuONBZIbak9OCpaI%3D" alt="" loading="lazy"/></p>
<p>生成的基准测试报告：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b908b4676974ad6938954be98f7d16b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763369759&amp;x-signature=ejsMvMqU%2BWJCKPTT%2Fr16XL8pHKM%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-19">基准测试分析报告</h4>
<h5 data-id="heading-20">📌 概览摘要</h5>
<p><strong>测试时间</strong>：2025年11月10日 06:58:01<br/>
<strong>测试模型</strong>：Qwen2.5-7B-Instruct<br/>
<strong>硬件环境</strong>：NVIDIA RTX 4090 (24GB显存)<br/>
<strong>测试轮次</strong>：3次迭代/场景</p>
<p>💡 <strong>关键发现</strong>：该模型在各种任务类型中表现均衡，平均推理速度达 <strong>55.72 tokens/秒</strong>，内存占用稳定在 <strong>14.21GB</strong>，中文与英文处理能力相当，适合多场景部署。</p>
<hr/>
<h5 data-id="heading-21">🧪 测试环境与方法</h5>





























<table><thead><tr><th>项目</th><th>配置</th></tr></thead><tbody><tr><td><strong>模型路径</strong></td><td><code>/root/.cache/modelscope/hub/models/Qwen/Qwen2.5-7B-Instruct</code></td></tr><tr><td><strong>计算设备</strong></td><td>NVIDIA GeForce RTX 4090 (24GB VRAM)</td></tr><tr><td><strong>数据类型</strong></td><td>bfloat16</td></tr><tr><td><strong>最大生成长度</strong></td><td>128 tokens</td></tr><tr><td><strong>采样参数</strong></td><td>temperature=0.7, top_p=0.9</td></tr></tbody></table>
<h5 data-id="heading-22">测试方法</h5>
<ul>
<li><strong>预热步骤</strong>：1次预热运行，排除首次加载开销</li>
<li><strong>正式测试</strong>：3次迭代，取平均值</li>
<li><strong>内存监控</strong>：记录峰值GPU内存占用</li>
<li><strong>多场景覆盖</strong>：5种不同任务类型，全面评估模型能力</li>
</ul>
<hr/>
<h5 data-id="heading-23">📈 性能指标汇总</h5>






















































<table><thead><tr><th>测试场景</th><th>平均时间</th><th>生成速度</th><th>生成长度</th><th>内存占用</th></tr></thead><tbody><tr><td>🇨🇳 中文生成</td><td>2.24秒</td><td>55.63 t/s</td><td>124.7 tokens</td><td>14.21 GB</td></tr><tr><td>🇺🇸 英文生成</td><td>2.20秒</td><td>55.79 t/s</td><td>123.0 tokens</td><td>14.21 GB</td></tr><tr><td>🧠 逻辑推理</td><td>2.30秒</td><td>55.66 t/s</td><td>128.0 tokens</td><td>14.21 GB</td></tr><tr><td>💻 代码生成</td><td>2.30秒</td><td>55.77 t/s</td><td>128.0 tokens</td><td>14.21 GB</td></tr><tr><td>📖 知识问答</td><td>2.30秒</td><td>55.75 t/s</td><td>128.0 tokens</td><td>14.21 GB</td></tr><tr><td><strong>平均值</strong></td><td><strong>2.27秒</strong></td><td><strong>55.72 t/s</strong></td><td><strong>126.3 tokens</strong></td><td><strong>14.21 GB</strong></td></tr></tbody></table>
<h5 data-id="heading-24">📊 性能分析图表</h5>
<pre><code class="hljs language-scss" lang="scss">生成速度对比 (tokens/秒)
🇺🇸 英文生成   ████████████████████████████████ <span class="hljs-number">55.79</span>
💻 代码生成   ████████████████████████████████ <span class="hljs-number">55.77</span>
📖 知识问答   ████████████████████████████████ <span class="hljs-number">55.75</span>
🧠 逻辑推理   ████████████████████████████████ <span class="hljs-number">55.66</span>
🇨🇳 中文生成   ███████████████████████████████ <span class="hljs-number">55.63</span>
</code></pre>
<hr/>
<h5 data-id="heading-25">🔍 详细场景分析</h5>
<ol>
<li>🇨🇳 中文生成能力</li>
</ol>
<p><strong>测试提示</strong>："今天天气真好，我想去"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>生成内容自然流畅，符合中文表达习惯</li>
<li>能进行多轮对话式回应，保持上下文连贯性</li>
<li>生成速度：55.63 tokens/秒（接近整体平均值）</li>
</ul>
<p><strong>生成质量评估</strong>：★★★★☆<br/>
内容连贯、实用，展示了良好的中文对话能力，但在细节上（如户外活动建议）可更具体。</p>
<hr/>
<ol start="2">
<li>🇺🇸 英文生成能力</li>
</ol>
<p><strong>测试提示</strong>："The capital of France is"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>5种场景中速度最快（55.79 tokens/秒）</li>
<li>能提供准确信息并自动纠正错误（指出巴黎在法国北部中区而非纯北部）</li>
<li>展示了良好的地理知识</li>
</ul>
<p><strong>生成质量评估</strong>：★★★★★<br/>
内容准确、信息丰富，表现出优秀的英文知识型文本生成能力。</p>
<hr/>
<ol start="3">
<li>🧠 逻辑推理能力</li>
</ol>
<p><strong>测试提示</strong>："如果所有的A都是B，而所有的B都是C，那么所有的A是C吗？请详细解释。"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>能正确识别逻辑传递原则</li>
<li>提供结构化解释（前提条件、传递性分析）</li>
<li>生成内容条理清晰，展示了良好的逻辑思维能力</li>
</ul>
<p><strong>生成质量评估</strong>：★★★★☆<br/>
逻辑严谨，条理分明，但解释可更深入，例如举例说明。</p>
<hr/>
<ol start="4">
<li>💻 代码生成能力</li>
</ol>
<p><strong>测试提示</strong>："用Python写一个快速排序算法"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>能提供完整的算法框架</li>
<li>包含必要的注释说明</li>
<li>遵循Python最佳实践</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>生成在128 tokens限制处被截断，未展示完整算法</li>
<li>需要更大生成长度以评估完整代码能力</li>
</ul>
<p><strong>生成质量评估</strong>：★★★☆☆<br/>
代码结构正确，但受长度限制未能展示完整实现。</p>
<hr/>
<ol start="5">
<li>📖 知识问答能力</li>
</ol>
<p><strong>测试提示</strong>："量子力学中的薛定谔方程是用来描述什么的？"<br/>
<strong>表现亮点</strong>：</p>
<ul>
<li>能区分非相对论性与相对论性薛定谔方程</li>
<li>尝试使用数学公式表达（虽然被截断）</li>
<li>内容专业性强，显示出良好的科学知识基础</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>同样受128 tokens长度限制，关键公式未能完整展示</li>
</ul>
<p><strong>生成质量评估</strong>：★★★★☆<br/>
专业准确，但需要更长生成长度以充分展示知识深度。</p>
<hr/>
<h5 data-id="heading-26">💎 关键结论与建议</h5>
<p>核心优势</p>
<ol>
<li><strong>性能均衡</strong>：所有测试场景表现稳定，无明显短板</li>
<li><strong>多语言能力</strong>：中英文处理能力接近，均超过55 tokens/秒</li>
<li><strong>内存效率高</strong>：稳定使用14.21GB显存，适合24GB显存设备部署</li>
<li><strong>任务适应性强</strong>：从对话到专业知识均有良好表现</li>
</ol>
<p>优化建议</p>
<ol>
<li><strong>调整生成长度</strong>：针对知识型和代码生成任务，建议增加最大生成长度至256+ tokens</li>
<li><strong>批处理优化</strong>：当前测试为batch_size=1，可测试更大批次提升吞吐量</li>
<li><strong>量化部署</strong>：考虑INT8/INT4量化，在保持性能的同时进一步降低内存占用</li>
<li><strong>场景特定微调</strong>：对代码生成和专业问答场景可进行针对性微调，提升专业能力</li>
</ol>
<p>部署推荐</p>
<ul>
<li><strong>开发测试环境</strong>：完全适用，响应速度快</li>
<li><strong>生产环境</strong>：适合中等流量API服务，单实例可支撑约20-30 QPS（取决于请求长度）</li>
<li><strong>最佳应用场景</strong>：聊天助手、知识问答系统、内容创作辅助、基础代码生成</li>
</ul>
<p>✅ <strong>总结</strong>：通义千问2.5-7B-Instruct展现出了强大的综合能力，在保持高效推理速度的同时，能够胜任多种任务类型，是7B级别模型中的优秀选择，特别适合中文场景的AI应用部署。</p>
<h3 data-id="heading-27">总结</h3>
<p>共绩算力平台代表了算力资源分配模式的创新突破，其核心价值在于通过"共享经济"模式重构了AI算力市场格局。不同于传统云服务商的高成本和自建集群的重资产模式，共绩算力实现了三个维度的革命性变革：经济维度上，将顶级GPU算力成本降至1.68元/小时，按秒计费避免资源浪费；技术维度上，通过智能调度算法整合碎片化算力，达成60%的资源利用率提升；生态维度上，将闲置算力转化为普惠AI基础设施，践行"使AI技术真正普及至每个人"的使命。这种模式不仅解决了中小企业和个人开发者的"算力焦虑"，更为中国AI产业构建了更具韧性和可持续性的底层基础设施。当一台普通电脑的闲置算力也能参与大模型推理，算力民主化的新时代已然到来。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[双十一将至，用Rules玩转电商场景提效]]></title>    <link>https://juejin.cn/post/7570901172526628899</link>    <guid>https://juejin.cn/post/7570901172526628899</guid>    <pubDate>2025-11-10T09:11:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570901172526628899" data-draft-id="7570651893870968884" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="双十一将至，用Rules玩转电商场景提效"/> <meta itemprop="keywords" content="人工智能,前端,后端"/> <meta itemprop="datePublished" content="2025-11-10T09:11:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="文心快码BaiduComate"/> <meta itemprop="url" content="https://juejin.cn/user/992209294070809"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            双十一将至，用Rules玩转电商场景提效
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/992209294070809/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    文心快码BaiduComate
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:11:24.000Z" title="Mon Nov 10 2025 09:11:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>双十一将至，结合电商场景，来聊聊如何 <strong>“让AI写代码更省心”</strong> ——<strong>使用Rules帮助解决 “AI写代码总跑偏”</strong> 的问题。</p>
<h2 data-id="heading-0">01 什么是Rules&amp;如何使用Rules</h2>
<p><strong>Rules是什么呢——</strong> 是⼀组规则/指令，⽤来教AI在特定项⽬或框架中应该遵守的模式、最佳实践和约束，做好这个规则⽂件，可以显著提升AI⽣成代码的质量、⼀致性，减少之后⼈⼯修正的⼯作。</p>
<p>可以把Rules想象成 <strong>“行为说明书”或者“工作守则”：</strong></p>
<ul>
<li>对人来说，Rules就像“公司员工手册”👉 让新同事知道要遵守什么流程、不能乱改配置；</li>
<li><strong>对AI来说，Rules就是“编程导航图”</strong> 👉 让 AI 明白项目结构在哪、该用什么命令启动、要注意哪些细节。</li>
</ul>
<p>实际开发中，Rules可以理解为一套<strong>项目级的“开发约束与规范”</strong> ，帮助统一AI的编码行为，<strong>让生成的代码更符合团队习惯、项目架构和业务场景</strong>。来看看电商团队在实际工作中是如何应用Rules的：</p>
<p>1、在Rules中定义环境依赖、启动命令、目录结构等，避免AI “自由发挥”；</p>
<p>2、针对电商业务，<strong>设置业务规则</strong>，比如所有的价格展示统一使用一个组件、涉及到的订单状态统一维护一个组件等；</p>
<p>3、<strong>加入团队代码规范和安全要求</strong>，例如在代码中不能随意引用npm包、写法风格生成一致等；</p>
<p>4、定义<strong>错误处理机制</strong>，比如所有可能出错的地方，都使用统一的机制处理（例如统一弹出错误信息、异常捕获等）。</p>
<p><strong>Rules就像是团队的“AI导师”：</strong></p>
<p><strong>1）对新人友好：</strong> 即使是不熟悉项目的新同学，也能通过 Rules 快速了解项目规范和最佳实践。</p>
<p><strong>2）对AI可控：</strong> 让AI生成的代码“开箱即用”，减少人工review和修改成本。</p>
<p><strong>3）架构一致：</strong> 确保代码风格、目录结构、技术栈统一，维护性更强。</p>
<h2 data-id="heading-1">02 电商场景下，未配置Rules的问题</h2>
<p>相信大家平时都有网购经验，肯定要关注所购买商品的状态，以订单详情页为例：根据设计稿，通过Figma to Code模式生成一个订单详情页。</p>
<blockquote>
<p>说明：Figma to Code是Zulu针对前端场景开发的功能，在传统开发中，设计师出图、前端再手写页面的流程被大大简化了。如“订单详情页”设计稿，通过Figma to Code模式，只需要将设计稿导入系统，就能自动生成可运行的页面原型。</p>
</blockquote>
<p>生成视频👉<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQaZL34zk094i-BYWT_l55g" target="_blank" title="https://mp.weixin.qq.com/s/QaZL34zk094i-BYWT_l55g" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/QaZL34zk0…</a></p>
<p>以上的生成过程，<strong>在没有Rules的情况下有什么问题？</strong></p>
<p>当前，数据是按一个一个渲染的，而不是数组形式渲染；存在CSS文件的style没有用到lang="less”,生成的文件默认用了“原始px”的写法；图标用的是符号，而不是组件icon。Comate<strong>生成的代码没有合理使用团队所引用的组件库、也没有拆成特别细的组件，CSS的写法也不是研发所要求的</strong>。此外，还会有一些通用性问题，<strong>例如样式没有按要求的规范去写、组件的颗粒度不够等。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/df1a72d8ec13401ba509c38e7ec31870~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=i%2FSJ26B2jIxa3JIT9x8e31JJn0M%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p>未配置Rules，订单详情页生成的结果</p>
<p>那么，如何解决这些问题呢？切换到当前的代码生成界面，输入对话并引导改善。在没有Rules的场景下，模型并不知道具体的业务规则、代码规范或者样式要求。想要修改一些问题（比如代码格式不对、CSS写法不规范、布局跑偏等），只能依靠和模型的对话交互（Prompt）来一步步引导它调整，<strong>每次改动都需要重新输入Prompt，明确告诉模型要改哪里、怎么改。</strong></p>
<p>一次次“人工指导”——虽然灵活，但成本也比较高。随着上下文越来越多，Prompt的长度也会增加，<strong>token消耗变高，模型响应速度也会变慢</strong>。如果问题过多，使用自然语言交互就会比较困难。</p>
<p>有没有一种更好的方式，能让模型“记住”这些通用规范？<strong>是不是可以通过配置Rules的方式，让这些交互自动化？</strong> 从而实现<strong>一次配置，长期生效</strong>。</p>
<h2 data-id="heading-2">03 电商场景下，配置Rules的效果</h2>
<p>在没有配置Rules的情况下，修改问题得靠一轮轮和模型对话。<strong>如果配置了Rules，会发生什么样的质变呢？</strong> 可以<strong>把Rules想象成是给大模型配的一本「行为规范手册」</strong>，它的效果主要分几个层面：</p>
<p><strong>1.命名约定 —— 代码界的“起名大会”</strong></p>
<p>命名约定模板就像在代码界开了一场“起名大会”。变量不能随便叫“张三”，函数也别整成“李四”。有了命名规则之后，模型就能统一风格、保证可读性。不再出现一堆奇怪的名字。<strong>从此团队协作更顺畅，调试也不再像拆盲盒。</strong></p>
<p><strong>2.代码结构 —— 给模型戴上“紧箍咒”</strong></p>
<p>代码结构约束就像是给模型戴了个“紧箍咒”。不允许模型写“俄罗斯套娃”式的嵌套结构，也不允许函数变成一团“意大利面条式”的灾难代码。<strong>有了结构约束后，代码层次清晰、逻辑明了，就像写作文有大纲，模型不会乱飙自由发挥。</strong></p>
<p><strong>3.业务逻辑层 —— 模型的“逻辑交警”</strong></p>
<p>业务逻辑层是大模型的“脑回路”，而Rules在这里扮演的角色，就像一个“逻辑交警”。它负责指挥——“这个流程该往哪跑”、“那个判断在哪停”。<strong>防止模型乱开车、逻辑撞车，让业务流转更顺畅、更可控。</strong></p>
<p><strong>有了Rules，模型就像从“自由创作”变成了“规范生产”</strong> ，<strong>既能理解设计意图，又能按照标准稳定输出。</strong></p>
<p>目前有两种配置Rules的方式，一种是采用编译器，根据某个标准页面生成：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ae56464f5464388bcc8f441700f16db~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=9TTBlvUJ9zrrL5m0YT6d2g0qYHk%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p>第二种是手动更新项目Rules，找到入口，然后进行更新：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3651a215734141bc92a6a016627dfe2e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=W1wwm7COgFabwD1dItXbC8yUZlI%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2fa31e4c3bbf492fb47757ab271bd93b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=t020TB7xK4ilBhUj8p4nBehCpDg%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e8581a62337f40d7b29895f3c4e61d81~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=6cDFqn%2Fubb6%2BswxegW5bvRHlWEk%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p>Rule具体内容如下：</p>
<pre><code class="hljs language-markdown" lang="markdown">---
description:
globs:
<span class="hljs-section">alwaysApply: true
---</span>
<span class="hljs-section">## 项目概述</span>
自动解析项目框架版本，这是一个移动端的项目，所有的样式需要参考移动端来实现。
<span class="hljs-section">## 开发指南</span>
<span class="hljs-bullet">1.</span> <span class="hljs-strong">**class 类名处理**</span>
<span class="hljs-bullet">    -</span> 所有 class 名应可读、可猜测功能 统一采用 - 拼接法，如：content-title
<span class="hljs-bullet">    -</span> 去除多余复杂的 class 类名
<span class="hljs-bullet">    -</span> 保持 class 层级扁平，尽量最多嵌套三层
<span class="hljs-bullet">2.</span> <span class="hljs-strong">**css 写法**</span>
<span class="hljs-bullet">    -</span> 尺寸单位优先把 PX 改成 * @rex414 的写法; （例如 1px 变成 1* @rex414），这一点一定要执行，不要使用 @rpx414。
<span class="hljs-bullet">    -</span> 组件样式必须加 lang="less"
<span class="hljs-bullet">    -</span> 每个新写的 style 文件 必须引入 @import 'src/lib/style/common.less';，这个只需要在<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>标签里面引入就行
<span class="hljs-bullet">3.</span> <span class="hljs-strong">**组件开发**</span>
<span class="hljs-bullet">    -</span> 事件命名采用 handleXxx 格式。
<span class="hljs-bullet">    -</span> 组件请帮我写在 src/routes/components 下，不要生成组件使用示例，直接生成组件。
<span class="hljs-bullet">4.</span> <span class="hljs-strong">**页面开发**</span>
<span class="hljs-bullet">    -</span> 根据设计稿，并且根据页面的模块，请务必合理拆分组件！帮我把页面写在 src/routes/ 下。
<span class="hljs-bullet">    -</span> 页面的组件写在 src/routes/components 下。
<span class="hljs-bullet">5.</span> <span class="hljs-strong">**图片资源管理**</span>
<span class="hljs-bullet">    -</span> 所有的图片都采取占位符的方式实现。
<span class="hljs-bullet">    -</span> 图片的所有资源都要放在 assets 下，例如 list-demo 的图片都放在 src/routes/list-demo/assets 下。
<span class="hljs-bullet">    -</span> 例如，组件在 src/routes/list-demo/components 路径下 组件使用图片引入方式都需要按照 /assets/list-demo/image<span class="hljs-emphasis">_1.png 这样实现。
</span></code></pre>
<p>配置完Rules，下一步会打开设计稿，根据约束的方式自动生成代码。</p>
<p>有了Rules的约束后，会有什么样的效果呢? 以上文提到的订单详情页为例，<strong>可以明显看出配置后项目代码层级的优化（如CSS格式等）。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5fe899166104da4b9ca5f3f1774d5d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5paH5b-D5b-r56CBQmFpZHVDb21hdGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763370683&amp;x-signature=wM%2BQQSq64sqa4GbX1eK%2BJgp3Ffo%3D" alt="" loading="lazy"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/></p>
<p>配置Rules后，订单详情页代码展示</p>
<p><strong>电商场景下，配置Rules的效果视频</strong>👉<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQaZL34zk094i-BYWT_l55g" target="_blank" title="https://mp.weixin.qq.com/s/QaZL34zk094i-BYWT_l55g" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/QaZL34zk0…</a></p>
<h2 data-id="heading-3">04 Q&amp;A</h2>
<p><strong>Q1: 在实际场景中，如何配置符合项目的Rules？</strong></p>
<p><strong>A：</strong> 不要把AI看作一个能独立完成工作的程序员，而应视为一个<strong>知识渊博但缺决策能力</strong>的程序员。Rules，就是给这位“队友”的<strong>工作指引和边界说明</strong>。首先要明确几点：</p>
<ul>
<li>明确不引入外部依赖确保生成代码安全可控；</li>
<li>明确告知AI项目的架构与模式，确保数据的正确引入与使用；</li>
<li>告知AI项目使用的技术栈语法，保证生成代码在项目中可用。</li>
</ul>
<p>最好的方式，就是让AI先生成一段代码，发现不足后，总结成一个通用规范。如果项目有已存在文件，按照已有文件的代码风格，自定义Rules的规则并逐步改善，最终使生成代码与原有代码风格保持一致。</p>
<p><strong>Q2：没有Rules时，AI输出的代码会出现哪些问题？</strong></p>
<p><strong>A：</strong> 比如格式不统一、命名不规范、CSS或接口写法不符合项目标准等，AI会“凭自己理解”生成，容易出现<strong>跑偏或低质量代码</strong>。</p>
<p><strong>Q3：没有Rules时，有没有快速让AI输出符合规范的方法？</strong></p>
<p><strong>A：</strong> 在没有配置Rules的情况下，可以通过一些方式<strong>尽量让AI输出符合规范</strong>，不过每种方法都有优劣。最直接的就是<strong>多轮对话逐步引导，</strong> 每次都要手动下指令，对写提示词的能力要求比较高、效率低，且容易出错。除了多轮对话，还有一些辅助办法：</p>
<p><strong>1）Few-shot 示例：</strong> 给AI看几个标准示例，让它模仿好例子输出；</p>
<p><strong>2）RAG（检索增强生成）</strong> ：把公司的规范文档或者参考代码库检索进来，让模型在生成时参考，这样可以减少偏离规范的情况。</p>
<p>但说到底，这些都是<strong>权宜之计</strong>，<strong>效率和稳定性都不如一次性建立Rules</strong>。一旦把规则配置好，模型就像有了“行动指南”，以后生成的代码基本能自动符合规范，这才是真正<strong>一劳永逸</strong>的办法。</p>
<p><strong>Q4：Rules是不是只针对前端项目有效？</strong></p>
<p><strong>A：Rules可以用在任何编程场景。</strong> 本质上，它就是给模型定规范、定边界，告诉它“该怎么做”、“不能乱做”。前端用它可以规范命名、组件风格、CSS写法；后端可以约束函数命名、接口设计、数据库操作、日志格式；文档、报告、甚至Markdown，也能规定模板、格式和用词。甚至在多模型协作或者Agent场景，Rules也可以帮助明确输入输出、调用顺序、任务边界。<strong>只要你的任务有规范可遵循，Rules就能发挥作用</strong>，绝对不局限于前端。针对不同的场景，可以写不同的Rules去规范模型的输出。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[基于生产负载回放的数据库迁移验证实践：从模拟测试到真实预演【金仓数据库】]]></title>    <link>https://juejin.cn/post/7570902804450705418</link>    <guid>https://juejin.cn/post/7570902804450705418</guid>    <pubDate>2025-11-10T09:20:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902804450705418" data-draft-id="7570903763721093130" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="基于生产负载回放的数据库迁移验证实践：从模拟测试到真实预演【金仓数据库】"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T09:20:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CodeJourney"/> <meta itemprop="url" content="https://juejin.cn/user/3558441089502232"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            基于生产负载回放的数据库迁移验证实践：从模拟测试到真实预演【金仓数据库】
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3558441089502232/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CodeJourney
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:20:19.000Z" title="Mon Nov 10 2025 09:20:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">基于生产负载回放的数据库迁移验证实践：从模拟测试到真实预演</h2>
<p>随着国产数据库的不断成熟，越来越多企业开始将核心业务系统从 Oracle、SQL Server 等传统商业数据库迁移到国产数据库。而在迁移项目中，<strong>最终能否安全上线</strong>，往往不取决于“是否成功导入数据”，而是取决于<strong>迁移后的系统是否能承受真实业务场景下的负载压力</strong>。</p>
<p>许多团队在迁移过程中都会遇到类似的困惑：</p>
<ul>
<li>测试阶段业务看起来一切正常</li>
<li>上线后在高峰时段突然性能告警、TPS下降、锁竞争飙升</li>
<li>最终不得不紧急回退或加班调参救火</li>
</ul>
<p>问题往往不是测试做得不够，而是：</p>
<blockquote>
<p><strong>测试环境的行为不等于生产环境的行为</strong>。</p>
</blockquote>
<p>本文将介绍一种能够真实还原生产业务运行状态的迁移验证方法：<strong>生产负载回放（Workload Replay）</strong>，并结合实际落地项目分享其技术流程与效果提升。</p>
<hr/>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2adaa60338414266a36f75c8521032c5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29kZUpvdXJuZXk=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371219&amp;x-signature=8Il9G6OHLjpJ%2Bk2llW6iKLzhF38%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<h3 data-id="heading-1">一、为什么传统迁移测试难以保障上线稳定性？</h3>
<p>迁移测试阶段通常包含：功能测试、手工用例验证、压力测试、回归测试等环节，看似覆盖全面，但仍难以避免迁移后出现性能或并发问题，其根本原因在于：</p>
<h4 data-id="heading-2">1. 手工测试与真实业务行为有“不可弥合差距”</h4>
<p>人工测试用例往往聚焦在“功能正确性”，但真实业务中存在大量“边缘行为”：</p>






























<table><thead><tr><th>类型</th><th>举例</th><th>特征</th></tr></thead><tbody><tr><td>高并发事务</td><td>批量订单生成、账务结算</td><td>对锁、事务隔离高度敏感</td></tr><tr><td>复杂长查询</td><td>多表关联的历史报表 / 月度结算</td><td>执行计划受索引状态影响</td></tr><tr><td>突发性访问峰值</td><td>节假日促销投放</td><td>QPS 呈指数波动，难以预测</td></tr><tr><td>异常行为链路</td><td>回滚、多次重试、局部失败</td><td>人工用例几乎无法构造</td></tr></tbody></table>
<p>这些行为往往不是“每天都发生”，但<strong>一旦发生就可能造成致命问题</strong>。</p>
<h4 data-id="heading-3">2. 压测脚本无法真实反映用户访问特征</h4>
<p>压测工具能造“压力”，但造不出“真实用户行为”：</p>
<ul>
<li>QPS 是写死的，而真实系统中是波峰波谷交替</li>
<li>SQL 执行比例通常不固定，而测试脚本是固定的参数模板</li>
<li>同一 SQL 在数据量变化后会触发不同执行计划，这是许多迁移翻车的根源</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>压测告诉你系统“能跑”，但不能告诉你系统“会不会在真实环境下卡住”。</strong></p>
</blockquote>
<h4 data-id="heading-4">3. 制度性痛点：回归测试成本巨大</h4>
<p>一旦：</p>
<ul>
<li>数据库参数调了</li>
<li>索引加了 / 删了</li>
<li>执行计划变了</li>
</ul>
<p>理论上都要重新回归测试。</p>
<p>这导致测试团队在迁移中长期疲于<strong>重复劳动</strong>，而不是优化策略。</p>
<hr/>
<h3 data-id="heading-5">二、生产负载回放：让迁移测试从“模拟”变成“重演”</h3>
<p>为了解决“测试不真实”的核心矛盾，我们使用了**生产负载回放（Workload Replay）**技术，其思路非常直接：</p>
<blockquote>
<p><strong>不再构造测试场景，而是直接把真实生产环境中发生过的所有数据库请求，完整复制到迁移后的数据库上执行。</strong></p>
</blockquote>
<p>这样一来：</p>
<ul>
<li>测试场景不再依赖经验 → 而是由真实历史业务驱动</li>
<li>性能行为不再估计 → 而是可量化比对</li>
<li>回归测试不再重新造数据 → 而是直接重复回放</li>
</ul>
<h4 data-id="heading-6">核心流程</h4>
<pre><code class="hljs language-sql" lang="sql">Capture（生产流量采集）
→ <span class="hljs-keyword">Convert</span>（语句与类型兼容转换）
→ Replay（按原始时间序列回放）
→ Validate（结果与数据一致性比对）
</code></pre>
<p>下面逐步展开。</p>
<hr/>
<h3 data-id="heading-7">三、技术流程详解</h3>
<h4 data-id="heading-8">1. Capture：采集真实数据库请求流</h4>
<p>采集目标是捕获某一时段内的<strong>完整业务行为链路</strong>，包括：</p>
<ul>
<li>SQL语句本体</li>
<li>绑定变量</li>
<li>事务开始 / 提交 / 回滚标记</li>
<li>会话来源（IP / 应用名 / 用户会话）</li>
<li>每条语句执行的时间戳（用于还原并发节奏）</li>
</ul>
<p>采集方式为<strong>低侵入设计</strong>，不会阻塞线上业务。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">BEGIN</span>
  DBMS_WORKLOAD_CAPTURE.START_CAPTURE(
    name <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">'workload_24h_snapshot'</span>,
    dir <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-string">'CAPTURE_DIR'</span>
  );
<span class="hljs-keyword">END</span>;
<span class="hljs-operator">/</span>
</code></pre>
<p>采集周期建议选择<strong>一个具有代表性的业务日</strong>，例如：</p>
<ul>
<li>月底财务对账日</li>
<li>高客流业务日</li>
<li>大促活动日</li>
</ul>
<p>这样后续测试的可靠性才有意义。</p>
<hr/>
<h4 data-id="heading-9">2. Convert：语句兼容、执行计划适配</h4>
<p>由于数据库语法、函数、存储过程语言存在差异，需要自动化进行语义转换：</p>









































<table><thead><tr><th>内容</th><th>Oracle → KingbaseES 示例</th><th/><th/></tr></thead><tbody><tr><td>分页语法</td><td><code>ROWNUM</code> → <code>LIMIT OFFSET</code></td><td/><td/></tr><tr><td>函数替换</td><td><code>NVL()</code> → <code>COALESCE()</code></td><td/><td/></tr><tr><td>字符串拼接</td><td>`</td><td/><td><code>→</code>concat()`</td></tr><tr><td>时间类型精度</td><td>DATE → TIMESTAMP(6)</td><td/><td/></tr><tr><td>存储过程调用</td><td>PL/SQL → 仿真包接口适配</td><td/><td/></tr></tbody></table>
<p>关键在于：</p>
<blockquote>
<p>转换不仅是“能执行”，而是保证<strong>语义一致</strong>。</p>
</blockquote>
<hr/>
<h4 data-id="heading-10">3. Replay：按原始并发节奏回放</h4>
<p>不同于压测脚本制造的“固定压力模型”，回放系统会：</p>
<ul>
<li>严格还原原始执行顺序和事务隔离关系</li>
<li>恢复真实并发强度与访问扇出特征</li>
<li>支持原速 / 加速 / 降速三种模式切换</li>
</ul>
<p>特别适合：</p>





















<table><thead><tr><th>场景</th><th>回放方式</th></tr></thead><tbody><tr><td>稳定性验证</td><td>原速回放</td></tr><tr><td>能力上限评估</td><td>加速回放（2x、5x）</td></tr><tr><td>性能瓶颈定位</td><td>降速回放观察锁链和计划</td></tr></tbody></table>
<p>回放期间会生成完整性能画像：</p>
<ul>
<li>Top SQL 排序</li>
<li>计划变更检测</li>
<li>CPU / IO 热点</li>
<li>行、表、索引级锁竞争分布</li>
</ul>
<p>这是迁移调优的核心依据。</p>
<hr/>
<h4 data-id="heading-11">4. Validate：自动化结果一致性比对</h4>
<p>比对范围包括：</p>

























<table><thead><tr><th>比对内容</th><th>示例</th></tr></thead><tbody><tr><td>表级一致性</td><td>行数一致 / 无缺失或冗余</td></tr><tr><td>字段级一致性</td><td>支持 BLOB / CLOB 二进制对比</td></tr><tr><td>元数据一致性</td><td>索引、触发器、约束一致性</td></tr><tr><td>返回结果一致性</td><td>相同请求返回相同结果</td></tr></tbody></table>
<p>系统会自动生成差异报告，定位到<strong>具体表、行、字段、值差异类型</strong>，无需 DBA 手工查表。</p>
<hr/>
<h3 data-id="heading-12">四、实际项目效果：迁移周期减少一半，风险显著下降</h3>
<p>以某制造集团 ERP 系统迁移为例：</p>



































<table><thead><tr><th>指标</th><th>传统测试方式</th><th>基于负载回放方案</th></tr></thead><tbody><tr><td>测试总体周期</td><td>6 周</td><td><strong>3 周</strong></td></tr><tr><td>覆盖业务场景</td><td>依赖测试经验</td><td><strong>完全真实业务场景</strong></td></tr><tr><td>数据回归成本</td><td>每次都要重构测试场景</td><td><strong>直接复用回放数据</strong></td></tr><tr><td>性能风险</td><td>上线后才能暴露</td><td><strong>上线前发现并修复</strong></td></tr><tr><td>上线稳定性</td><td>取决于“运气”</td><td><strong>上线即平稳运行</strong></td></tr></tbody></table>
<p>迁移负责人总结得很直白：</p>
<blockquote>
<p>“以前我们是在猜测试是否足够，现在我们是在验证系统是否真实可承载。”</p>
</blockquote>
<hr/>
<h3 data-id="heading-13">五、结语</h3>
<p>数据库迁移不是把库搬走，而是要让业务无感平滑切换。</p>
<p>传统测试方法<strong>验证的是功能可用</strong>；
生产负载回放<strong>验证的是系统能否在真实业务场景中稳定运行</strong>。</p>
<p>因此：</p>
<blockquote>
<p><strong>真实负载回放，是数据库迁移从“可用”走向“可信”的关键一步。</strong></p>
</blockquote>
<p>未来，结合机器学习对执行计划差异、锁冲突链路、访问热点自动分析，迁移验证将从“经验驱动”走向“智能优化”。</p>
<p>迁移，不再是一次冒险。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[机器人“会用手”了！银河通用首破手掌任意朝向旋转难题，拧螺丝、砸钉子样样精通]]></title>    <link>https://juejin.cn/post/7570866247980105780</link>    <guid>https://juejin.cn/post/7570866247980105780</guid>    <pubDate>2025-11-10T09:30:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570866247980105780" data-draft-id="7570909641682206760" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="机器人“会用手”了！银河通用首破手掌任意朝向旋转难题，拧螺丝、砸钉子样样精通"/> <meta itemprop="keywords" content="AIGC,人工智能"/> <meta itemprop="datePublished" content="2025-11-10T09:30:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="量子位"/> <meta itemprop="url" content="https://juejin.cn/user/2858385963484488"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            机器人“会用手”了！银河通用首破手掌任意朝向旋转难题，拧螺丝、砸钉子样样精通
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2858385963484488/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    量子位
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:30:59.000Z" title="Mon Nov 10 2025 09:30:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>做灵巧手如果不会用工具，跟咸鱼（夹爪）有什么区别？</p>
<p>别急，能拧螺丝、抡锤子，玩 “转” 各类工具的灵巧手，这就来了。</p>
<p>这位拧螺丝的 “老师傅”，出自<strong>银河通用</strong>最新推出的灵巧手神经动力学模型 <strong>DexNDM</strong>。</p>
<p>在 DexNDM 的加持下，灵巧手实现了从能动到能用的飞跃，通过分布有偏的真实数据训练，无需成功示例，即可精准弥合 Sim2Real 鸿沟，首次让通用灵巧手能够对多类物体实现稳定、多姿态、多轴向的旋转操作。</p>
<ul>
<li><strong>跨物体精准操控：从微小零件到大书本、长棍、复杂几何体，首次实现跨类别、跨尺寸、跨姿态的稳定旋转。</strong></li>
<li><strong>任意姿态多轴旋转：无论手掌朝上、朝下或侧向，均能沿任意轴向进行稳定、持续的旋转。</strong></li>
<li><strong>高灵巧高鲁棒遥操作：可自如地抓、转、拧各类工具，胜任拧螺丝、家具组装等长程、复杂操作任务。</strong></li>
<li><strong>弥合 Sim2Real 的鸿沟：无需成功操作数据，仅凭分布有偏的真实数据即可完成高精度学习，克服灵巧操作 Sim2Real 的差距，实现了 “从 0 到 1” 的突破。</strong></li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9aadf8e1f9794b41af5665dd5d0e4e9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=1h5BbiCCctMG25%2Fmc9lS%2FQBIxjs%3D" alt="" loading="lazy"/></p>
<p>这下，离流水线和厨房里的灵巧机器人，真不远了！</p>
<h2 data-id="heading-0">手内操作的通用策略</h2>
<p>如上所述，DexNDM 的核心突破在于<strong>首次在真实世界中突破了手掌任意朝向的物体旋转限制</strong>，实现了跨物体、跨姿态的稳定<strong>手内旋转 (In-Hand Rotation)</strong> 与<strong>工具操作 (Tool Use)</strong>。</p>
<p>具体来说，DexNDM 能在极具挑战的手腕姿态下（如手掌朝下或侧向），实现长物体沿长边的连续旋转，以及小物体在多种转轴下的稳定旋转。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c43bad4c828441891ba20d6f0c78c90~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=4TdbeXXKhHhsXrBGloyqWN6l4pA%3D" alt="" loading="lazy"/></p>
<p>在操作对象上，DexNDM 能处理从小型到细长、从简单几何到复杂结构的多种物体。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a16dfc30b9674ecab9e79598829a3989~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=3Rp0keo%2Fqr6cyooR360rgYID7hc%3D" alt="" loading="lazy"/></p>
<p>那么，这是怎么做到的呢？</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61b0a26a35954d55bf96a146c0df5395~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=25MuvWJ7HGBbMagimE5Rvav0RWQ%3D" alt="" loading="lazy"/></p>
<p>这里的关键在于 DexNDM 的<strong>关节级神经动力学模型（ JOINT-WISE NEURAL DYNAMICS MODEL）</strong>。</p>
<p>不同于以往整手建模的方式，DexNDM 将复杂的手–物交互拆解到<strong>关节级</strong>，让每个关节独立预测自身的下一状态，完成整手的运动预测。</p>
<p>这种分解不仅显著提升了数据利用效率，还能增强模型在不同物体、姿态下的泛化能力。</p>
<p>为了学习到具有良好泛化性的动力学模型，团队开发了一套<strong>全自动数据收集策略</strong>。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/32664d1a145843939ddff1b97b7076b3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=nen%2F33Fh3RYqFAUiR5wVqrFiT40%3D" alt="" loading="lazy"/></p>
<p>在任务无关的随机扰动下，机器人能自主生成丰富的接触数据，不用人工重置，也不会频繁 “翻车”。</p>
<p>这样，模型可以在廉价、可扩展的数据上学习到足够丰富的交互动力学。</p>
<p>基于此，研究者进一步训练了一个<strong>残差策略网络</strong>，用于弥合仿真到现实的差距，使仿真中学到的基础策略能够顺利迁移到真实世界。</p>
<p>在策略学习上，DexNDM 采用了 “从专家到通才（expert-to-generalist）” 的训练流程：</p>
<blockquote>
<p>先针对不同长宽比与几何复杂度的物体训练多个专家策略，再将它们融合提炼为一个统一的通用策略，从而实现跨任务、跨形态的稳定操作。</p>
</blockquote>
<p>仿真与真实环境的测试表明，DexNDM 的操作灵活性、鲁棒性与泛化能力都得到了显著提升：</p>
<blockquote>
<p>不仅首次在手掌朝下的姿态下，实现了 10–16cm 长物体沿长轴的空中完整旋转，还能够稳定泛化到更多、更具挑战性的物体类型。</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ad5a6bcdb964227b7a5fe3072aa2dbe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=FNN2InBX7Sali3AzeOXA0cX%2BJ%2BQ%3D" alt="" loading="lazy"/></p>
<p>此外，研究还将这套<strong>通用旋转策略作为底层技能接入遥操作系统</strong>。</p>
<p>操作者只需通过 VR 控制器给出臂端位姿或旋转轴等高层指令，DexNDM 即可自主完成手指层面的精细控制。</p>
<p>这种方式克服了传统遥操作在精细操作中的根本难题——人手与机械手在自由度、传感和动力学上的不匹配。</p>
<p>借助 DexNDM，机器人不仅能 “抓得稳、放得准”，还能完成复杂的、涉及旋转的<strong>手—物—物交互</strong>，实现工具使用与长程装配等对系统鲁棒性要求极高的任务，真正迈向 “能转能用” 的灵巧操作。</p>
<h2 data-id="heading-1">从简单抓取到精细操作</h2>
<p>值得一提的是，DexNDM 解决的是机器人研究中最具挑战性的手内操作中的关键问题——手内旋转（in-hand rotation）。</p>
<p>这一突破之所以意义重大，是因为它直接推动了机器人从简单能力向精细操作能力的跨越。</p>
<p>整体来看，机器人的能力大致可分为<strong>运动能力</strong>与<strong>操作能力</strong>两类。</p>
<p>运动能力，是我们熟悉的 “跑”“跳”“翻”——以及保持全身稳定的 <strong>whole-body control</strong>。</p>
<p>如今，机器人不再需要被绳子吊着防摔，甚至在人为干扰下仍能稳住身形，各种翻跟头、跳舞的 demo 展示也是层出不穷。</p>
<p>而站稳之后，想让机器人真正具备生产力，关键还在于——<strong>操作（manipulation）</strong>。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fc7acca63fb42d68c0dbdccc8c1ed8e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=yAVBIoVw3%2FUXmPHd0tq2FZ3AUDE%3D" alt="" loading="lazy"/></p>
<p>所谓操作，就是机器人真正 “动手干活” 的能力，它包括：</p>
<ul>
<li>
<p>抓取：改变物体相对于机器人本体的位置，如拿起 / 放下物体。</p>
</li>
<li>
<p>环境辅助操作：借助外界完成任务，如桌子，平台等。</p>
</li>
<li>
<p>柔性物体操作：处理衣物、绳索、液体等。</p>
</li>
<li>
<p>手内操作：在不借助外部环境或支撑的情况下，仅通过机械手的手指运动和调整抓取姿势来改变物体在手掌中的位置和姿态，如 DexNDM 对应的手内旋转。</p>
</li>
<li>
<p>工具操作：涉及与环境或另一个物体持续、强烈的物理接触，通常用于完成特定的精细任务。</p>
</li>
</ul>
<p>虽然目前大部分的末端执行器都能很好地完成抓取任务，但简单抓取的应用范围十分有限，主要集中在上下料、分拣等场景，远未触及真正的工业级生产力。</p>
<p>因此，灵巧操作必须从 “能抓能放” 迈向“能转能用”，以实现更复杂、更精细的动作。</p>
<p>然而，这恰恰是机器人研究中最难啃的骨头。</p>
<p>机器人先驱 Rodney Brooks 曾说：</p>
<blockquote>
<p>灵巧操作是通用机器人部署中最艰难的前沿。</p>
</blockquote>
<p>原因很简单，灵巧手虽带来了比夹爪更高的自由度，但也带来了成倍的控制难度。</p>
<p>马斯克也曾感叹：</p>
<blockquote>
<p>人类的手极其精密复杂…… 它可以挥棒、穿针、弹琴，也能拆车装车。若要造出真正通用的人形机器人，必须先解决手的问题。</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a033b5ae31c4c969c3fb74c85364d1c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=hSy9CSHh%2Fs%2FSjtow69Vqo0JLf14%3D" alt="" loading="lazy"/></p>
<p>可以说，想实现真正通用的灵巧操作，就必须攻克灵巧手的精细操作。</p>
<p><strong>其中，手内旋转和工具使用能力正成为学界研究的焦点，代表了灵巧操作向更高维度发展的趋势。</strong></p>
<p>前者让机器人能灵活调整抓取姿态，使操作更顺手，后者则让机器人真正能 “干活”，拧螺丝、砸钉子、切割、组装。</p>
<p>但这两项能力，也正是难度的巅峰。它们涉及复杂且快速变化的手–物接触和手–物–物交互，是灵巧操作皇冠上的明珠。</p>
<p>而 DexNDM 的突破，就在于此。它同时攻克了 “旋转” 和“使用”这两大难题：既能实现高精度的手内旋转，也能灵活处理多种工具的操作任务。</p>
<p>更重要的是，只有当机器人能可靠地完成这类操作，语言、视觉等高层智能规划，才能真正落地为具体的动作与执行。</p>
<p>这正是通用机器人与具身智能落地的关键瓶颈。</p>
<p>不过，要做到这一点，并不容易。</p>
<h2 data-id="heading-2">通用的手内旋转策略</h2>
<p>直观地看，在拧螺丝这样的场景中，灵巧手无法像手掌朝上时那样依赖重力来稳定物体。</p>
<p>为了不让螺丝刀滑落，模型必须精确控制更多的自由度，实现对姿态、力和接触的协调控制。</p>
<p>过去的手内操作方法大多只能处理特定物体或固定姿态，依赖昂贵或定制化硬件，难以推广到更通用的场景。</p>
<p>其根源在于灵巧手本身的高自由度（人手有 21 个自由度，加上手腕就有 27 个自由度）与复杂耦合：关节彼此影响，手与物体之间的接触不断变化，建模极其困难。</p>
<p>再加上执行过程中存在自遮挡、传感不完全等问题，模型往往无法准确捕捉这些微妙的动力学细节。</p>
<p>更棘手的是，仿真与现实之间的动力学差距依旧巨大。许多策略在仿真环境下表现完美，一旦进入现实就 “翻车”。而想依靠真实数据修正，又要承担高昂的采集成本和失败风险。</p>
<p>例如，CMU 与 Meta 在《Science Robotics》封面论文 “NeuralFeels with Neural Fields” 中引入视觉 - 触觉融合模型，以弥补纯视觉感知的不足，但依然难以跨越 Sim-to-Real 的鸿沟。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5baa62ad050640f8b03d0c227914bcc6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=RiooOI10e0xudDHtknV0qqRXZfs%3D" alt="" loading="lazy"/></p>
<p>ICRA 2023 的 BACH (Belt-Augmented Compliant Hand) 则通过皮带增强的柔性机械手实现了手腕向下的旋转操作，但这种特殊结构难以迁移，也带来了额外的硬件成本。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f9a7805f30749799564ff2fb2140323~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=cU%2FphEU75%2BHw3aPfatGrIWxr2Yg%3D" alt="" loading="lazy"/></p>
<p>类似地，DexCtrl 在旋转轴通用性上取得进展，却仍受限于物体复杂度。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9903ec7b34434e59b9d9ec4f6ce1ccba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=S9%2BHPhUsnAGSzRYql3Pwue5U%2B6o%3D" alt="" loading="lazy"/></p>
<p>而 DexGen 虽能执行拧螺丝任务，却缺乏对目标物体运动的精确控制。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7f5d797066c4f94bde8e5dd60178fbd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371860&amp;x-signature=tO%2FyC0cqazsuoDfl%2FJrtehuQQzE%3D" alt="" loading="lazy"/></p>
<p>在这些方法中，我们可以窥见，当前的手内操作方法往往局限于特定场景（如固定手腕朝向）、只能处理有限集合的常规物体，或依赖昂贵、定制化硬件。即便在单一维度（如旋转轴）上实现了通用性，仍难以在多维操作中保持稳定表现。</p>
<p>在这样的背景下，DexNDM 实现了实质性飞跃——首次构建了能够跨物体类别、跨姿态任务的通用手内操作策略。</p>
<p>它不仅为遥操作系统的数据生成与策略迁移提供了坚实基础，也为灵巧操作的工业化落地奠定了条件：样本效率更高、泛化性更强、能力可复用，为具身智能研究提供了新的底层基础设施。</p>
<p>同时，遥操应用也可进一步扩展至广泛的任务类型，协助获取各类任务所需的操作数据。</p>
<h2 data-id="heading-3">生产力即产品</h2>
<p>DexNDM 的意义不仅在于一个新的模型，更在于它推动了灵巧操作这一 “皇冠上的明珠” 从学术研究走向了可复用的生产力基础设施。</p>
<p>从最初的搬箱、上下料，到如今能拧螺丝、砸钉子、装配家具、使用工具，灵巧操作正逐步从机械重复劳动者，进化为真正具备操作智慧的 “生产力单元”。</p>
<p>借助这一底层能力，机器人不再局限于演示性的 “抓取放置”，而能在工业装配、家具组装、工具使用等多场景中实现可扩展部署，持续提升实际生产力。</p>
<p>在典型的装配任务中，这一 “能干活的机器人” 的雏形已初现端倪：</p>
<p>第一步，灵巧手使用螺丝刀，将电路板核心部件固定。</p>
<p>它能在手内微调螺丝刀的姿态，使其在最顺手的角度下施力；对准 M2 微小螺丝孔后，精准施压旋入，既不打滑也不损板。</p>
<p>第二步，安装音量旋钮。</p>
<p>五指协同稳握木质旋钮，调整内螺纹与轴心对位后，完成大角度旋转——就像拧紧瓶盖那样流畅。</p>
<p>第三步，安装装饰性部件。</p>
<p>灵巧手先夹持铆钉定位，再旋转调整小锤的握姿，轻敲入位，力量精准、节奏分明。</p>
<p>这三步展示了从手内旋转到多指协调、从静态操作到动态敲击的全链路灵巧控制，也标志着灵巧操作正在从 “抓取” 走向 “使用工具”，从“重复动作” 迈向“任务理解”，成为真正的生产力。</p>
<p>正如银河通用机器人创始人、CTO 王鹤所说：</p>
<blockquote>
<p>如果大模型提倡的是智能即产品，那么具身智能提倡的就是生产力即产品。</p>
</blockquote>
<p>最后，让我们回到开头的问题：灵巧手和夹爪的区别是什么？</p>
<p>——生产力。</p>
<p><em>论文链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2510.08556" target="_blank" title="https://arxiv.org/abs/2510.08556" ref="nofollow noopener noreferrer">arxiv.org/abs/2510.08…</a></em></p>
<p><em>项目网站：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmeowuu7.github.io%2FDexNDM%2F" target="_blank" title="https://meowuu7.github.io/DexNDM/" ref="nofollow noopener noreferrer">meowuu7.github.io/DexNDM/</a></em></p>
<p><strong>欢迎在评论区留下你的想法！</strong></p>
<p>— <strong>完</strong> —</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[word文档转html（mammoth ）]]></title>    <link>https://juejin.cn/post/7570912420567285770</link>    <guid>https://juejin.cn/post/7570912420567285770</guid>    <pubDate>2025-11-10T09:33:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570912420567285770" data-draft-id="7570902804450344970" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="word文档转html（mammoth ）"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-10T09:33:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="耀耀切克闹灬"/> <meta itemprop="url" content="https://juejin.cn/user/1781681116679854"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            word文档转html（mammoth ）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1781681116679854/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    耀耀切克闹灬
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:33:56.000Z" title="Mon Nov 10 2025 09:33:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<blockquote>
<p>最近老有需要把协议Word转化为html纯预览展示的需求，为了后面方便摸鱼，用工具包脚本直接转化（手动狗头），主要使用的是 mammoth 。</p>
</blockquote>
<h2 data-id="heading-1">Word 转 HTML 工具</h2>
<p>使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmwilliamson%2Fmammoth.js" target="_blank" title="https://github.com/mwilliamson/mammoth.js" ref="nofollow noopener noreferrer">mammoth</a> 将 Word 文档转换为 HTML，特别适用于协议文档的在线预览。</p>
<h3 data-id="heading-2">安装依赖</h3>
<p>bash</p>
<pre><code class="hljs">npm install mammoth
</code></pre>
<h3 data-id="heading-3">完整代码</h3>
<p>javascript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> mammoth = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mammoth'</span>)
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getFileConfig</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> inputDir = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'input'</span>);
  <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(inputDir).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.docx'</span>));
  <span class="hljs-keyword">return</span> files.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">inputPath</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'input'</span>,f),
      <span class="hljs-attr">outputPath</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'output'</span>, f.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'.docx'</span>, <span class="hljs-string">'.html'</span>))
    }
  });
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">transformParagraph</span>(<span class="hljs-params">element</span>) {
  <span class="hljs-keyword">let</span> styleName = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">alignment</span> === <span class="hljs-string">"center"</span>) {
    styleName = <span class="hljs-string">"text-center"</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">alignment</span> === <span class="hljs-string">"right"</span>) {
    styleName = <span class="hljs-string">"text-right"</span>;
  }
  
  <span class="hljs-keyword">return</span> {
      ...element,
      styleName
  };
}

<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">styleMap</span>: [
    <span class="hljs-string">"p[style-name='text-center'] =&gt; p.text-center:fresh"</span>,
    <span class="hljs-string">"p[style-name='text-right'] =&gt; p.text-right:fresh"</span>,
     <span class="hljs-string">"u =&gt; span.text-underline:fresh"</span>
  ],
  <span class="hljs-attr">transformDocument</span>: mammoth.<span class="hljs-property">transforms</span>.<span class="hljs-title function_">paragraph</span>(transformParagraph)
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">convertToHtml</span> = (<span class="hljs-params">config</span>) =&gt; {
  <span class="hljs-keyword">const</span> { inputPath, outputPath } = config;
  <span class="hljs-keyword">return</span> mammoth.<span class="hljs-title function_">convertToHtml</span>({ <span class="hljs-attr">path</span>: inputPath }, options).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>){
    <span class="hljs-keyword">const</span> html = result.<span class="hljs-property">value</span>
    <span class="hljs-keyword">const</span> templatePath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'template.html'</span>)
    <span class="hljs-keyword">const</span> tempHtml = fs.<span class="hljs-title function_">readFileSync</span>(templatePath, <span class="hljs-string">'utf8'</span>)
    <span class="hljs-keyword">const</span> insertTag = <span class="hljs-string">'&lt;div id="app"&gt;'</span>
    <span class="hljs-keyword">const</span> insertIndex = tempHtml.<span class="hljs-title function_">lastIndexOf</span>(insertTag) + insertTag.<span class="hljs-property">length</span>
    <span class="hljs-keyword">const</span> resHtml = tempHtml.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, insertIndex) + html + tempHtml.<span class="hljs-title function_">slice</span>(insertIndex)
    fs.<span class="hljs-title function_">writeFileSync</span>(outputPath, resHtml, <span class="hljs-string">'utf8'</span>)
  }).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
  });
}

<span class="hljs-keyword">const</span> allFileConfig = <span class="hljs-title function_">getFileConfig</span>();
<span class="hljs-keyword">const</span> allFileConfigLength = allFileConfig.<span class="hljs-property">length</span>;
<span class="hljs-comment">// 清空 output 目录</span>
<span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'output'</span>))) {
  fs.<span class="hljs-title function_">rmdirSync</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'output'</span>), { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">force</span>: <span class="hljs-literal">true</span> });
}
fs.<span class="hljs-title function_">mkdirSync</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'output'</span>));

<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`开始转换，共 <span class="hljs-subst">${allFileConfigLength}</span> 个文件`</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">runNext</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">if</span> (index &gt;= allFileConfigLength) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件转换完成，请查看 output 目录'</span>);
    <span class="hljs-keyword">return</span>;
  }
  
  <span class="hljs-keyword">const</span> config = allFileConfig[index];
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>: <span class="hljs-subst">${path.basename(config.inputPath)}</span>`</span>);
  
  <span class="hljs-title function_">convertToHtml</span>(config).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    index++;
    <span class="hljs-title function_">runNext</span>();
  }).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error processing file <span class="hljs-subst">${path.basename(config.inputPath)}</span>:`</span>, err);
    index++;
    <span class="hljs-title function_">runNext</span>();
  });
}

<span class="hljs-title function_">runNext</span>();




</code></pre>
<h3 data-id="heading-4">目录结构</h3>
<p>text</p>
<pre><code class="hljs language-css" lang="css">word-<span class="hljs-selector-tag">to</span>-<span class="hljs-selector-tag">html</span>/
├── <span class="hljs-selector-tag">input</span>/                 # 存放要转换的 <span class="hljs-selector-class">.docx</span> 文件
│   ├── 协议<span class="hljs-number">1</span><span class="hljs-selector-class">.docx</span>
│   └── 协议<span class="hljs-number">2</span><span class="hljs-selector-class">.docx</span>
├── output/                # 转换后的 <span class="hljs-selector-tag">HTML</span> 文件输出目录
├── template<span class="hljs-selector-class">.html</span>          # <span class="hljs-selector-tag">HTML</span> 模板文件   
├──index<span class="hljs-selector-class">.js</span>
</code></pre>
<h3 data-id="heading-5">在package.json的scripts中添加命令行脚本</h3>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-string">"convert-doc"</span>: <span class="hljs-string">"node ./bin/word-to-html/index.js"</span>,
</code></pre>
<h3 data-id="heading-6">使用方法</h3>
<ol>
<li>将 Word 文档 (.docx) 放入 <code>input</code> 目录</li>
<li>运行脚本：</li>
<li>查看 <code>output</code> 目录获取转换后的 HTML 文件</li>
</ol>
<h3 data-id="heading-7">模板文件示例 (template.html)</h3>
<pre><code class="hljs language-xml" lang="xml">
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>协议文档预览<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"Microsoft YaHei"</span>, sans-serif;
            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.8</span>;
            <span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f5f5</span>;
        }
        <span class="hljs-selector-id">#app</span> {
            <span class="hljs-attribute">background</span>: white;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">40px</span>;
            <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);
            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
        }
        <span class="hljs-selector-class">.text-center</span> { <span class="hljs-attribute">text-align</span>: center; }
        <span class="hljs-selector-class">.text-right</span> { <span class="hljs-attribute">text-align</span>: right; }
        <span class="hljs-selector-class">.text-underline</span> { <span class="hljs-attribute">text-decoration</span>: underline; }
        <span class="hljs-selector-tag">table</span> {
            <span class="hljs-attribute">border-collapse</span>: collapse;
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">15px</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-selector-tag">table</span>, <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> {
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;
        }
        <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> {
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span>;
            <span class="hljs-attribute">text-align</span>: left;
        }
        <span class="hljs-selector-tag">th</span> {
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f8f9fa</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 data-id="heading-8">注意事项</h3>
<ul>
<li>确保 Word 文档为 .docx 格式</li>
<li>复杂表格样式可能需要额外调整</li>
<li>脚本会自动覆盖 output 目录中的现有文件</li>
<li>建议在转换前备份重要的 Word 文档</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[KuiklyUI的ViewRef设计]]></title>    <link>https://juejin.cn/post/7570902804450934794</link>    <guid>https://juejin.cn/post/7570902804450934794</guid>    <pubDate>2025-11-10T09:55:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902804450934794" data-draft-id="7570902804450836490" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="KuiklyUI的ViewRef设计"/> <meta itemprop="keywords" content="GitHub"/> <meta itemprop="datePublished" content="2025-11-10T09:55:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风冷"/> <meta itemprop="url" content="https://juejin.cn/user/3843548379091742"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            KuiklyUI的ViewRef设计
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3843548379091742/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风冷
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:55:33.000Z" title="Mon Nov 10 2025 09:55:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">nativeRef与ViewRef、AbstractBaseView、Pager以及ViewContainer的关系分析</h2>
<p>本文将深入分析KuiklyUI框架中nativeRef与ViewRef、AbstractBaseView、Pager以及ViewContainer与ViewRef之间的关系，帮助您全面理解视图引用系统的设计与实现。</p>
<h3 data-id="heading-1">一、nativeRef的本质与工作机制</h3>
<h4 data-id="heading-2">1.1 nativeRef的定义与生成机制</h4>
<p>nativeRef是KuiklyUI中每个视图实例的唯一标识符，定义在AbstractBaseView类中：</p>
<pre><code class="hljs language-kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/AbstractBaseView.kt" lang="kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/AbstractBaseView.kt">abstract class AbstractBaseView&lt;A : Attr, E : Event&gt; : BaseObject(), IViewPublicApi&lt;A, E&gt;, IModuleAccessor, IPagerId {
    val nativeRef: Int = ++nativeRefProducer
    // ...
    companion object {
        var nativeRefProducer = 0
    }
}
</code></pre>
<p>nativeRef通过一个静态计数器<code>nativeRefProducer</code>自增生成，确保每个视图实例拥有全局唯一的标识符。这种设计使得框架可以在整个应用生命周期内精确识别每一个视图。</p>
<h4 data-id="heading-3">1.2 nativeRef在视图系统中的核心作用</h4>
<p>nativeRef在KuiklyUI框架中扮演着多重关键角色：</p>
<ol>
<li><strong>视图身份标识</strong>：作为视图实例的唯一身份标识</li>
<li><strong>视图引用传递</strong>：在父子视图之间传递引用关系</li>
<li><strong>跨层通信桥梁</strong>：连接Kotlin层与原生渲染层</li>
<li><strong>属性与事件绑定</strong>：在创建Attr和Event对象时被注入，用于后续属性更新和事件分发</li>
</ol>
<p>在AbstractBaseView的内部实现中，我们可以看到nativeRef被注入到Attr和Event对象中：</p>
<pre><code class="hljs language-kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/AbstractBaseView.kt" lang="kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/AbstractBaseView.kt">private fun internalCreateEvent(): E {
    val event = createEvent()
    event.init(pagerId,nativeRef)  // 将nativeRef注入到Event对象
    return event
}

protected fun internalCreateAttr(): A {
    val attr = createAttr()
    attr.pagerId = pagerId
    attr.nativeRef = nativeRef  // 将nativeRef注入到Attr对象
    attr.flexNode = flexNode
    return attr
}
</code></pre>
<h3 data-id="heading-4">二、ViewRef与nativeRef的关系</h3>
<h4 data-id="heading-5">2.1 ViewRef的定义与实现</h4>
<p>ViewRef是一个轻量级的引用封装类，定义在DeclarativeBaseView.kt中：</p>
<pre><code class="hljs language-kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/DeclarativeBaseView.kt" lang="kotlin:/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/DeclarativeBaseView.kt">class ViewRef&lt;T : DeclarativeBaseView&lt;*, *&gt;&gt;(val pagerId: String, val nativeRef: Int) {
    val view: T?
        get() = PagerManager.getPager(pagerId)
            .getViewWithNativeRef(nativeRef) as? T
}
</code></pre>
<h4 data-id="heading-6">2.2 ViewRef与nativeRef的协作关系</h4>
<p>ViewRef与nativeRef之间存在着紧密的协作关系：</p>
<ol>
<li><strong>组成关系</strong>：ViewRef封装了pagerId和nativeRef两个核心属性</li>
<li><strong>定位机制</strong>：ViewRef通过pagerId和nativeRef组合定位到具体的视图实例</li>
<li><strong>延迟查找</strong>：ViewRef的<code>view</code>属性采用懒加载方式，只有在需要时才通过PagerManager查找视图</li>
<li><strong>类型安全</strong>：ViewRef使用泛型确保返回的视图类型正确</li>
</ol>
<h3 data-id="heading-7">三、ViewRef与AbstractBaseView的关系</h3>
<h4 data-id="heading-8">3.1 ref扩展函数的实现</h4>
<p>在DeclarativeBaseView中，实现了<code>ref</code>扩展函数，作为创建ViewRef的入口：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : DeclarativeBaseView&lt;*, *&gt;</span>&gt; T.<span class="hljs-title">ref</span><span class="hljs-params">(ref: (<span class="hljs-type">viewRef</span>: <span class="hljs-type">ViewRef</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    ref(ViewRef&lt;T&gt;(pagerId, nativeRef))
}
</code></pre>
<h4 data-id="heading-9">3.2 AbstractBaseView与ViewRef的交互流程</h4>
<p>AbstractBaseView与ViewRef的交互流程如下：</p>
<ol>
<li>AbstractBaseView实例创建时生成唯一的nativeRef</li>
<li>通过ref扩展函数，将当前视图的pagerId和nativeRef传递给ViewRef构造函数</li>
<li>ViewRef持有这些引用信息，但不直接持有视图实例</li>
<li>当需要访问视图时，通过ViewRef的<code>view</code>属性间接获取</li>
</ol>
<p>这种设计实现了视图引用的解耦，使框架能够更灵活地管理视图生命周期和内存。</p>
<h3 data-id="heading-10">四、ViewRef与Pager的协作机制</h3>
<h4 data-id="heading-11">4.1 Pager的视图引用管理</h4>
<p>Pager类实现了IPager接口，负责管理视图引用：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Pager中管理视图引用的关键代码</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> nativeRefViewMap = mutableMapOf&lt;<span class="hljs-built_in">Int</span>, AbstractBaseView&lt;*, *&gt;&gt;()

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">putNativeViewRef</span><span class="hljs-params">(nativeRef: <span class="hljs-type">Int</span>, view: <span class="hljs-type">AbstractBaseView</span>&lt;*, *&gt;)</span></span> {
    nativeRefViewMap[nativeRef] = view
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeNativeViewRef</span><span class="hljs-params">(nativeRef: <span class="hljs-type">Int</span>)</span></span> {
    nativeRefViewMap.remove(nativeRef)
}

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewWithNativeRef</span><span class="hljs-params">(nativeRef: <span class="hljs-type">Int</span>)</span></span>: AbstractBaseView&lt;*, *&gt;? {
    <span class="hljs-keyword">return</span> nativeRefViewMap[nativeRef]
}
</code></pre>
<h4 data-id="heading-12">4.2 ViewRef与Pager的协作流程</h4>
<p>ViewRef与Pager的协作流程如下：</p>
<ol>
<li>ViewRef持有pagerId和nativeRef信息</li>
<li>当调用ViewRef的<code>view</code>属性时，通过PagerManager获取对应pagerId的Pager实例</li>
<li>调用Pager的<code>getViewWithNativeRef</code>方法，通过nativeRef查找视图实例</li>
<li>将找到的视图实例转换为泛型T类型并返回</li>
</ol>
<p>这种设计使得ViewRef可以安全地在任何地方访问视图，而不需要直接持有视图实例的强引用，有利于内存管理和视图生命周期控制。</p>
<h3 data-id="heading-13">五、ViewContainer与ViewRef的关系</h3>
<h4 data-id="heading-14">5.1 ViewContainer的视图层次管理</h4>
<p>ViewContainer是所有容器视图的基类，负责管理子视图层次结构：</p>
<pre><code class="hljs language-kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt" lang="kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt">abstract class ViewContainer&lt;A : ContainerAttr, E : Event&gt; : DeclarativeBaseView&lt;A, E&gt;() {
    protected val children = fastArrayListOf&lt;DeclarativeBaseView&lt;*, *&gt;&gt;()
    // ...
}
</code></pre>
<h4 data-id="heading-15">5.2 ViewContainer中nativeRef的应用</h4>
<p>在ViewContainer中，nativeRef主要用于以下几个方面：</p>
<ol>
<li><strong>父视图引用传递</strong>：在添加子视图时，设置子视图的parentRef为当前容器的nativeRef</li>
</ol>
<pre><code class="hljs language-kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt" lang="kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt">private fun internalAddChild(child: DeclarativeBaseView&lt;*, *&gt;, index: Int) {
    child.pagerId = pagerId
    child.willMoveToParentComponent()
    if (index &lt; 0) { // append when index -1
        children.add(child)
    } else {
        children.add(index, child)
    }
    child.parentRef = nativeRef  // 设置父视图引用
    child.didMoveToParentView()
}
</code></pre>
<ol start="2">
<li><strong>渲染视图管理</strong>：在创建和移除渲染视图时，使用nativeRef标识视图</li>
</ol>
<pre><code class="hljs language-kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt" lang="kotlin:/Users/hdh/Documents/codes/KuiklyUI/core/src/commonMain/kotlin/com/tencent/kuikly/core/base/ViewContainer.kt">override fun createRenderView() {
    createRenderViewing = true
    super.createRenderView()
    createRenderViewing = false
    var index = 0
    renderChildren().forEach { child -&gt;
        child.createRenderView()
        renderView?.insertSubRenderView(child.nativeRef, index++)  // 使用nativeRef标识子视图
        child.renderViewDidMoveToParentRenderView()
    }
}
</code></pre>
<ol start="3">
<li><strong>视图引用链建立</strong>：通过nativeRef和parentRef建立完整的视图引用链</li>
</ol>
<h4 data-id="heading-16">5.3 ViewContainer中ViewRef的使用场景</h4>
<p>在ViewContainer中，ViewRef主要用于以下场景：</p>
<ol>
<li><strong>子视图引用获取</strong>：通过ViewRef安全地获取子视图引用，进行操作或通信</li>
<li><strong>跨层级视图访问</strong>：在复杂布局中，通过ViewRef实现跨层级的视图访问</li>
<li><strong>视图生命周期管理</strong>：在视图添加、移除等生命周期事件中，通过ViewRef传递引用信息</li>
</ol>
<h3 data-id="heading-17">六、整体架构与数据流</h3>
<h4 data-id="heading-18">6.1 核心组件关系图</h4>
<pre><code class="hljs language-lua" lang="lua">+<span class="hljs-comment">------------------+      +------------------+      +------------------+</span>
|                  |      |                  |      |                  |
|  AbstractBaseView|&lt;<span class="hljs-comment">-----&gt;|    ViewRef       |&lt;-----&gt;|     Pager        |</span>
|                  |      |                  |      |                  |
+<span class="hljs-comment">--------^---------+      +------------------+      +------------------+</span>
         |
         |
+<span class="hljs-comment">--------+---------+      +------------------+</span>
|                  |      |                  |
|  ViewContainer   |&lt;<span class="hljs-comment">-----&gt;|   Declarative   |</span>
|                  |      |     BaseView     |
+<span class="hljs-comment">------------------+      +------------------+</span>
</code></pre>
<h4 data-id="heading-19">6.2 数据流向与交互模式</h4>
<p>在KuiklyUI的视图引用系统中，数据流向和交互模式如下：</p>
<ol>
<li><strong>创建阶段</strong>：视图实例创建时生成nativeRef，Pager注册视图引用</li>
<li><strong>引用封装</strong>：通过ref扩展函数创建ViewRef对象，封装pagerId和nativeRef</li>
<li><strong>引用访问</strong>：通过ViewRef的view属性，间接访问视图实例</li>
<li><strong>生命周期管理</strong>：在视图添加到容器或从容器移除时，更新parentRef和视图引用注册状态</li>
<li><strong>销毁阶段</strong>：视图销毁时，从Pager中移除视图引用</li>
</ol>
<h3 data-id="heading-20">七、设计优势与技术亮点</h3>
<h4 data-id="heading-21">7.1 设计优势</h4>
<ol>
<li><strong>解耦视图引用</strong>：ViewRef通过间接引用机制，实现了视图引用与视图实例的解耦</li>
<li><strong>内存优化</strong>：避免了不必要的强引用，有利于内存管理和垃圾回收</li>
<li><strong>类型安全</strong>：泛型设计确保了类型安全，减少了运行时类型转换错误</li>
<li><strong>灵活的视图访问</strong>：可以在任何地方通过ViewRef安全地访问视图，不受生命周期限制</li>
</ol>
<h4 data-id="heading-22">7.2 技术亮点</h4>
<ol>
<li><strong>唯一标识符生成机制</strong>：通过静态计数器生成全局唯一的nativeRef</li>
<li><strong>延迟查找策略</strong>：ViewRef的view属性采用懒加载方式，只有在需要时才查找视图</li>
<li><strong>引用链管理</strong>：通过nativeRef和parentRef建立完整的视图层次引用链</li>
<li><strong>跨平台兼容性</strong>：设计考虑了跨平台需求，nativeRef作为统一的视图标识符</li>
</ol>
<h3 data-id="heading-23">八、代码优化建议</h3>
<p>基于对ViewRef和nativeRef系统的分析，提出以下优化建议：</p>
<ol>
<li>
<p><strong>引用有效性检查增强</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 在ViewRef的view属性中添加更完善的有效性检查</span>
<span class="hljs-keyword">val</span> view: T?
    <span class="hljs-keyword">get</span>() {
        <span class="hljs-keyword">val</span> pager = PagerManager.getPager(pagerId)
        <span class="hljs-keyword">if</span> (pager == <span class="hljs-literal">null</span> || !pager.isActive()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        }
        <span class="hljs-keyword">val</span> view = pager.getViewWithNativeRef(nativeRef) <span class="hljs-keyword">as</span>? T
        <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span> &amp;&amp; view.isDestroyed()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        }
        <span class="hljs-keyword">return</span> view
    }
</code></pre>
</li>
<li>
<p><strong>弱引用优化</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 在Pager中考虑使用WeakReference存储视图引用，避免内存泄漏</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> nativeRefViewMap = mutableMapOf&lt;<span class="hljs-built_in">Int</span>, WeakReference&lt;AbstractBaseView&lt;*, *&gt;&gt;&gt;()
</code></pre>
</li>
<li>
<p><strong>引用缓存机制</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 为频繁访问的ViewRef添加缓存机制</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRef</span>&lt;<span class="hljs-type">T : DeclarativeBaseView&lt;*, *</span>&gt;&gt;(<span class="hljs-keyword">val</span> pagerId: String, <span class="hljs-keyword">val</span> nativeRef: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cachedView: T? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastCacheTime: <span class="hljs-built_in">Long</span> = <span class="hljs-number">0</span>
    
    <span class="hljs-keyword">val</span> view: T?
        <span class="hljs-keyword">get</span>() {
            <span class="hljs-keyword">val</span> currentTime = System.currentTimeMillis()
            <span class="hljs-comment">// 缓存有效期100ms</span>
            <span class="hljs-keyword">if</span> (cachedView != <span class="hljs-literal">null</span> &amp;&amp; currentTime - lastCacheTime &lt; <span class="hljs-number">100</span>) {
                <span class="hljs-keyword">return</span> cachedView
            }
            cachedView = PagerManager.getPager(pagerId)
                .getViewWithNativeRef(nativeRef) <span class="hljs-keyword">as</span>? T
            lastCacheTime = currentTime
            <span class="hljs-keyword">return</span> cachedView
        }
}
</code></pre>
</li>
</ol>
<p>总结来看，nativeRef与ViewRef、AbstractBaseView、Pager以及ViewContainer之间形成了一套完整、高效的视图引用管理体系，为KuiklyUI框架提供了灵活、安全的视图访问机制。通过这种设计，框架能够有效地管理视图生命周期、优化内存使用，并提供一致的跨平台体验。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AutoHotkey 功能配置与使用指南]]></title>    <link>https://juejin.cn/post/7570904968677851163</link>    <guid>https://juejin.cn/post/7570904968677851163</guid>    <pubDate>2025-11-10T09:12:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570904968677851163" data-draft-id="7570901172526579747" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AutoHotkey 功能配置与使用指南"/> <meta itemprop="keywords" content="Windows"/> <meta itemprop="datePublished" content="2025-11-10T09:12:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="NiShiKiFuNa"/> <meta itemprop="url" content="https://juejin.cn/user/3905924343795950"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AutoHotkey 功能配置与使用指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3905924343795950/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    NiShiKiFuNa
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:12:21.000Z" title="Mon Nov 10 2025 09:12:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>本文档总结了使用 AutoHotkey 实现多种功能的配置方法，包括屏蔽快捷键、鼠标侧键音量控制、多脚本管理和开机自启动设置。</p>
<h2 data-id="heading-0">1. 使用 AutoHotkey 屏蔽 Ctrl+Esc 快捷键</h2>
<h3 data-id="heading-1">方法一：基础屏蔽脚本</h3>
<pre><code class="hljs language-autohotkey" lang="autohotkey">; 不展示托盘图标（可选）
#NoTrayIcon
; 屏蔽 Ctrl+Esc 快捷键
^Esc::return
</code></pre>
<h3 data-id="heading-2">方法二：针对特定游戏的屏蔽</h3>
<pre><code class="hljs language-autohotkey" lang="autohotkey">; 不展示托盘图标（可选）
#NoTrayIcon
; 只在特定游戏窗口中屏蔽 Ctrl+Esc
#IfWinActive ahk_exe 游戏进程名.exe
^Esc::return
#IfWinActive
</code></pre>
<p><strong>注意事项：</strong></p>
<ul>
<li>脚本需要以<strong>管理员身份运行</strong>才能在游戏中生效</li>
<li>使用 <code>#IfWinActive</code> 可以限制热键只在特定程序中生效</li>
<li>如果需要完全退出脚本，可以添加退出热键：<code>^!q::ExitApp</code></li>
</ul>
<h2 data-id="heading-3">2. 使用鼠标侧键调节音量</h2>
<h3 data-id="heading-4">带初始延迟的连续调节脚本</h3>
<pre><code class="hljs language-autohotkey" lang="autohotkey">#NoTrayIcon

; --- 延迟设置 ---
InitialDelay := 300  ; 首次按下后的延迟时间（毫秒）

; --- 鼠标侧键音量控制 ---
; 侧键1（后退键）：音量减小
XButton1::
    Send {Volume_Down}
    Key1Pressed := true
    SetTimer, RapidVolumeDown, % -InitialDelay
return

XButton1 up::
    Key1Pressed := false
    SetTimer, RapidVolumeDown, Off
return

RapidVolumeDown:
    if Key1Pressed
    {
        Send {Volume_Down}
        SetTimer, RapidVolumeDown, 150
    }
return

; 侧键2（前进键）：音量增加
XButton2::
    Send {Volume_Up}
    Key2Pressed := true
    SetTimer, RapidVolumeUp, % -InitialDelay
return

XButton2 up::
    Key2Pressed := false
    SetTimer, RapidVolumeUp, Off
return

RapidVolumeUp:
    if Key2Pressed
    {
        Send {Volume_Up}
        SetTimer, RapidVolumeUp, 150
    }
return

; --- 退出热键 ---
^+q::ExitApp
</code></pre>
<p><strong>功能特点：</strong></p>
<ul>
<li>单次点击：立即调节一次音量</li>
<li>长按：延迟后开始连续调节（默认延迟300毫秒）</li>
<li>使用系统默认的音量调节方式</li>
</ul>
<p><strong>自定义参数：</strong></p>
<ul>
<li>调整 <code>InitialDelay</code> 值可改变开始连续调节的延迟时间</li>
<li>调整 <code>150</code> 值可改变连续调节的速度</li>
</ul>
<h2 data-id="heading-5">3. 使用一个脚本启动多个其他脚本的方法</h2>
<h3 data-id="heading-6">创建主启动脚本</h3>
<pre><code class="hljs language-autohotkey" lang="autohotkey">#NoTrayIcon
; 主启动脚本 - 同时运行多个子脚本

; 启动屏蔽 Ctrl+Esc 脚本
Run, C:\脚本路径\屏蔽CtrlEsc.ahk

; 启动鼠标侧键音量控制脚本
Run, C:\脚本路径\鼠标侧键音量.ahk

; 可选：启动其他脚本
; Run, C:\脚本路径\其他功能.ahk

; 可选：主脚本在启动所有子脚本后自动退出
; ExitApp
</code></pre>
<p><strong>优势：</strong></p>
<ul>
<li>集中管理多个脚本</li>
<li>只需在任务计划程序中设置一个自启动任务</li>
<li>方便添加、删除或修改要启动的脚本</li>
</ul>
<p><strong>路径说明：</strong></p>
<ul>
<li>
<p>使用完整路径（如 <code>C:\脚本路径...</code>）最可靠</p>
</li>
<li>
<p>如果脚本在同一目录，可使用 <code>A_ScriptDir</code> 变量：</p>
<pre><code class="hljs language-autohotkey" lang="autohotkey">Run, %A_ScriptDir%\屏蔽CtrlEsc.ahk
</code></pre>
</li>
</ul>
<h2 data-id="heading-7">4. 设置任务计划程序实现开机自启且以管理员身份运行</h2>
<h3 data-id="heading-8">详细设置步骤</h3>
<ol>
<li>
<p><strong>打开任务计划程序</strong></p>
<ul>
<li>按 <code>Win + R</code>，输入 <code>taskschd.msc</code>，回车</li>
</ul>
</li>
<li>
<p><strong>创建新任务</strong></p>
<ul>
<li>点击右侧"创建任务"（不要使用"创建基本任务"）</li>
</ul>
</li>
<li>
<p><strong>常规设置</strong></p>
<ul>
<li>
<p><strong>名称</strong>：输入有意义的任务名称</p>
</li>
<li>
<p><strong>描述</strong>：（可选）添加任务描述</p>
</li>
<li>
<p><strong>安全选项</strong>：</p>
<ul>
<li>选择"只在用户登录时运行"</li>
<li>✅ <strong>勾选"使用最高权限运行"</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>触发器设置</strong></p>
<ul>
<li>点击"新建"，选择"当用户登录时"</li>
<li>建议选择"特定用户"而不是"任何用户"</li>
</ul>
</li>
<li>
<p><strong>操作设置</strong></p>
<ul>
<li>
<p>点击"新建"</p>
</li>
<li>
<p><strong>操作</strong>：选择"启动程序"</p>
</li>
<li>
<p><strong>程序或脚本</strong>：浏览选择 AutoHotkey.exe</p>
<ul>
<li>通常路径：<code>C:\Program Files\AutoHotkey\AutoHotkey.exe</code></li>
</ul>
</li>
<li>
<p><strong>参数</strong>：输入你的脚本完整路径</p>
<ul>
<li>例如：<code>"C:\AHK_Scripts\主启动脚本.ahk"</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>条件设置（可选）</strong></p>
<ul>
<li>在"条件"选项卡中，取消勾选"只有在计算机使用交流电源时才启动此任务"（确保笔记本用电池时也能运行）</li>
</ul>
</li>
</ol>
<h3 data-id="heading-9">重要注意事项</h3>
<ul>
<li><strong>权限设置</strong>：必须在"常规"选项卡中勾选"使用最高权限运行"</li>
<li><strong>触发器选择</strong>：必须选择"当用户登录时"而不是"计算机启动时"</li>
<li><strong>用户选择</strong>：建议选择"特定用户"而不是"任何用户"，以确保托盘图标正常显示</li>
<li><strong>路径处理</strong>：脚本路径中包含空格时，需要用英文双引号包围</li>
</ul>
<h3 data-id="heading-10">验证设置</h3>
<p>设置完成后，可以通过以下方式验证：</p>
<ol>
<li>右键点击任务，选择"运行"测试</li>
<li>检查任务管理器中的 AutoHotkey 进程是否正常运行</li>
<li>测试各项功能是否正常工作</li>
</ol>
<h2 data-id="heading-11">常见问题解决</h2>
<ol>
<li>
<p><strong>游戏中热键不生效</strong></p>
<ul>
<li>确保脚本以管理员身份运行</li>
<li>检查游戏是否在全屏模式下运行</li>
</ul>
</li>
<li>
<p><strong>开机不自启</strong></p>
<ul>
<li>检查任务计划程序中的触发器设置</li>
<li>确认脚本路径正确</li>
</ul>
</li>
<li>
<p><strong>托盘图标不显示</strong></p>
<ul>
<li>检查是否选择了"特定用户"而不是"任何用户"</li>
<li>确认任务属性中选择了"只在用户登录时运行"</li>
</ul>
</li>
</ol>
<p>通过以上配置，你可以实现功能的自动化运行，无需每次手动启动脚本。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python FastAPI 参数传递与响应校验]]></title>    <link>https://juejin.cn/post/7570896170920706111</link>    <guid>https://juejin.cn/post/7570896170920706111</guid>    <pubDate>2025-11-10T09:32:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570896170920706111" data-draft-id="7570598043298578495" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python FastAPI 参数传递与响应校验"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T09:32:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Hacker_Future"/> <meta itemprop="url" content="https://juejin.cn/user/1978776659433063"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python FastAPI 参数传递与响应校验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1978776659433063/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Hacker_Future
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:32:20.000Z" title="Mon Nov 10 2025 09:32:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">FastAPI 进阶教程：参数传递与响应校验</h2>
<p>上一节我们实现了基础的 HelloWorld API，这一节将聚焦实际开发核心需求 —— 参数传递（路径 / 查询 / 请求体）与响应数据校验，结合 Pydantic 模型让接口更规范、更健壮。</p>
<h3 data-id="heading-1">一、核心依赖与前置说明</h3>
<ul>
<li>依赖工具：Pydantic（FastAPI 内置，用于数据校验和模型定义）。</li>
</ul>

<ul>
<li>核心目标：通过类型注解定义参数 / 响应格式，FastAPI 自动完成校验、转换和文档生成。</li>
</ul>

<ul>
<li>适用场景：接口需要接收用户输入（如查询条件、表单数据）或返回结构化结果时。</li>
</ul>
<h3 data-id="heading-2">二、参数传递的 3 种核心方式</h3>
<h4 data-id="heading-3">2.1 路径参数（Path Parameters）</h4>
<p>用于标识资源的唯一标识（如用户 ID、商品编号），直接嵌入 URL 路径中。</p>
<h5 data-id="heading-4">基础用法（无校验）</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
app = FastAPI()
<span class="hljs-comment"># 路径参数 item_id 嵌入 URL，类型注解为 int</span>
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/items/{item_id}"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span></span>):
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"item_id"</span>: item_id, <span class="hljs-string">"message"</span>: <span class="hljs-string">"获取商品成功"</span>}
</code></pre>
<ul>
<li>访问示例：<a href="https://link.juejin.cn?target=http%3A%2F%2F127.0.0.1%3A8000%2Fitems%2F10" target="_blank" title="http://127.0.0.1:8000/items/10" ref="nofollow noopener noreferrer">http://127.0.0.1:8000/items/10</a>，返回 {"item_id":10,"message":"获取商品成功"}。</li>
</ul>

<ul>
<li>自动转换：若访问 items/abc，FastAPI 会返回 422 错误（类型不匹配），无需手动处理。</li>
</ul>
<h5 data-id="heading-5">进阶用法（路径参数校验）</h5>
<p>通过 Path 类添加校验规则（如数值范围、描述）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Path
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>
app = FastAPI()
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/items/{item_id}"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">
    <span class="hljs-comment"># ge=1：大于等于 1，le=100：小于等于 100，description 用于接口文档</span>
    item_id: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">..., ge=<span class="hljs-number">1</span>, le=<span class="hljs-number">100</span>, description=<span class="hljs-string">"商品 ID，范围 1-100"</span></span>),
    q: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 可选查询参数，下文详解</span>
</span>):
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"item_id"</span>: item_id, <span class="hljs-string">"q"</span>: q}
</code></pre>
<ul>
<li>访问示例：/items/50?q=手机 正常响应，/items/101 会返回 422 校验错误。</li>
</ul>
<h4 data-id="heading-6">2.2 查询参数（Query Parameters）</h4>
<p>用于过滤、分页等非核心参数（如搜索关键词、页码），以 ?key=value 形式附加在 URL 后。</p>
<h5 data-id="heading-7">基础用法（可选参数 + 默认值）</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/users/"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">
    page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>,  <span class="hljs-comment"># 必选查询参数，默认值 1（不传递时使用默认值）</span>
    limit: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span>,  <span class="hljs-comment"># 每页条数，默认 10</span>
    keyword: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 可选查询参数，默认 None</span>
</span>):
    <span class="hljs-comment"># 模拟分页查询逻辑</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"page"</span>: page,
        <span class="hljs-string">"limit"</span>: limit,
        <span class="hljs-string">"keyword"</span>: keyword,
        <span class="hljs-string">"data"</span>: [{<span class="hljs-string">"user_id"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"张三"</span>}, {<span class="hljs-string">"user_id"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"李四"</span>}]
    }
</code></pre>
<ul>
<li>访问示例：/users/?page=2&amp;limit=20&amp;keyword=张，返回对应分页和筛选结果。</li>
</ul>

<ul>
<li>校验特性：若传递 page=abc，会自动返回类型错误。</li>
</ul>
<h5 data-id="heading-8">进阶用法（查询参数校验）</h5>
<p>通过 Query 类添加校验规则（如字符串长度、正则匹配）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Query
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/users/"</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">
    page: <span class="hljs-built_in">int</span> = Query(<span class="hljs-params"><span class="hljs-number">1</span>, ge=<span class="hljs-number">1</span>, description=<span class="hljs-string">"页码，最小 1"</span></span>),
    limit: <span class="hljs-built_in">int</span> = Query(<span class="hljs-params"><span class="hljs-number">10</span>, ge=<span class="hljs-number">5</span>, le=<span class="hljs-number">50</span>, description=<span class="hljs-string">"每页条数，5-50 条"</span></span>),
    <span class="hljs-comment"># min_length=2：最小长度 2，max_length=10：最大长度 10</span>
    keyword: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Query(<span class="hljs-params"><span class="hljs-literal">None</span>, min_length=<span class="hljs-number">2</span>, max_length=<span class="hljs-number">10</span></span>)
</span>):
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"page"</span>: page, <span class="hljs-string">"limit"</span>: limit, <span class="hljs-string">"keyword"</span>: keyword, <span class="hljs-string">"data"</span>: []}
</code></pre>
<h4 data-id="heading-9">2.3 请求体（Request Body）</h4>
<p>用于传递复杂数据（如创建用户、提交表单），以 JSON 格式发送（FastAPI 自动解析）。</p>
<p>需通过 Pydantic 模型定义请求体结构。</p>
<h5 data-id="heading-10">步骤 1：定义 Pydantic 模型</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>
app = FastAPI()
<span class="hljs-comment"># 定义请求体模型，继承 BaseModel</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCreate</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name: <span class="hljs-built_in">str</span>  <span class="hljs-comment"># 必选字段，字符串类型</span>
    age: <span class="hljs-built_in">int</span> = Field(..., ge=<span class="hljs-number">0</span>, le=<span class="hljs-number">120</span>, description=<span class="hljs-string">"年龄，0-120 岁"</span>)  <span class="hljs-comment"># 带校验的必选字段</span>
    email: <span class="hljs-built_in">str</span> = Field(..., pattern=<span class="hljs-string">r"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+.[a-zA-Z0-9_-]+$"</span>)  <span class="hljs-comment"># 邮箱正则校验</span>
    address: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 可选字段，默认 None</span>
<span class="hljs-comment"># 定义响应体模型（可选，用于规范返回格式）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserResponse</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span>
    name: <span class="hljs-built_in">str</span>
    age: <span class="hljs-built_in">int</span>
    email: <span class="hljs-built_in">str</span>
    address: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:
        orm_mode = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 支持从 ORM 对象（如 SQLAlchemy 模型）转换为 JSON</span>
</code></pre>
<h5 data-id="heading-11">步骤 2：使用模型接收请求体</h5>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">"/users/"</span>, response_model=UserResponse</span>)  </span><span class="hljs-comment"># 指定响应模型，自动校验返回数据</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">user: UserCreate</span>):  <span class="hljs-comment"># user 参数自动解析 JSON 请求体</span>
    <span class="hljs-comment"># 模拟数据库插入，生成用户 ID</span>
    user_id = <span class="hljs-number">1001</span>
    <span class="hljs-comment"># 返回数据会被 UserResponse 校验，确保格式一致</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"id"</span>: user_id,
        <span class="hljs-string">"name"</span>: user.name,
        <span class="hljs-string">"age"</span>: user.age,
        <span class="hljs-string">"email"</span>: user.email,
        <span class="hljs-string">"address"</span>: user.address
    }
</code></pre>
<h5 data-id="heading-12">测试请求体</h5>
<ul>
<li>发送 POST 请求到 <a href="https://link.juejin.cn?target=http%3A%2F%2F127.0.0.1%3A8000%2Fusers%2F" target="_blank" title="http://127.0.0.1:8000/users/" ref="nofollow noopener noreferrer">http://127.0.0.1:8000/users/</a>，请求体 JSON：</li>
</ul>
<pre><code class="hljs language-perl" lang="perl">{
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"王五"</span>,
    <span class="hljs-string">"age"</span>: <span class="hljs-number">25</span>,
    <span class="hljs-string">"email"</span>: <span class="hljs-string">"wangwu@example.com"</span>,
    <span class="hljs-string">"address"</span>: <span class="hljs-string">"北京市海淀区"</span>
}
</code></pre>
<ul>
<li>响应结果：自动校验请求体（如 email 格式错误会返回 422），返回数据严格遵循 UserResponse 结构。</li>
</ul>
<h3 data-id="heading-13">三、响应校验的核心作用</h3>
<ol>
<li>确保返回数据格式统一，避免前端对接混乱。</li>
</ol>

<ol start="2">
<li>自动过滤多余字段（如请求体中的额外参数不会被返回）。</li>
</ol>

<ol start="3">
<li>文档自动同步：/docs 页面会显示请求体和响应体的结构化示例。</li>
</ol>
<h3 data-id="heading-14">四、实战：组合参数示例（路径 + 查询 + 请求体）</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.put(<span class="hljs-params"><span class="hljs-string">"/items/{item_id}"</span>, response_model=UserResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_item</span>(<span class="hljs-params">
    item_id: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">..., ge=<span class="hljs-number">1</span>, description=<span class="hljs-string">"商品 ID"</span></span>),
    is_active: <span class="hljs-built_in">bool</span> = Query(<span class="hljs-params"><span class="hljs-literal">True</span>, description=<span class="hljs-string">"是否启用商品"</span></span>),
    user: UserCreate  <span class="hljs-comment"># 请求体</span>
</span>):
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"id"</span>: item_id,
        <span class="hljs-string">"name"</span>: user.name,
        <span class="hljs-string">"age"</span>: user.age,
        <span class="hljs-string">"email"</span>: user.email,
        <span class="hljs-string">"address"</span>: user.address
    }
</code></pre>
<ul>
<li>访问示例：PUT 请求 <a href="https://link.juejin.cn?target=http%3A%2F%2F127.0.0.1%3A8000%2Fitems%2F5%3Fis_active%3Dtrue" target="_blank" title="http://127.0.0.1:8000/items/5?is_active=true" ref="nofollow noopener noreferrer">http://127.0.0.1:8000/items/5?is_active=true</a>，携带上述 JSON 请求体。</li>
</ul>

<ul>
<li>校验逻辑：路径参数、查询参数、请求体分别按规则校验，任意环节出错返回 422 错误。</li>
</ul>
<h3 data-id="heading-15">五、常见错误与排查</h3>
<ul>
<li>422 错误：数据校验失败（如类型不匹配、数值超出范围、正则不匹配），查看响应体的 detail 字段可获取具体原因。</li>
</ul>

<ul>
<li>请求体无法解析：未定义 Pydantic 模型，或请求头 Content-Type 不是 application/json。</li>
</ul>

<ul>
<li>可选字段必填：未给 Optional 字段设置默认值（如 keyword: Optional[str] 需改为 keyword: Optional[str] = None）。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从字符串满天飞到优雅枚举：JavaScript 常量管理的几种姿势]]></title>    <link>https://juejin.cn/post/7570598043298611263</link>    <guid>https://juejin.cn/post/7570598043298611263</guid>    <pubDate>2025-11-10T09:43:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570598043298611263" data-draft-id="7570896170920837183" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从字符串满天飞到优雅枚举：JavaScript 常量管理的几种姿势"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-11-10T09:43:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="也无风雨也雾晴"/> <meta itemprop="url" content="https://juejin.cn/user/2175258804632332"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从字符串满天飞到优雅枚举：JavaScript 常量管理的几种姿势
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2175258804632332/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    也无风雨也雾晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:43:34.000Z" title="Mon Nov 10 2025 09:43:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>重构老项目的时候，看到代码里到处都是这样的判断：</p>
<pre><code class="hljs language-ini" lang="ini">if (<span class="hljs-attr">status</span> === <span class="hljs-string">'pending'</span>) { }
if (<span class="hljs-attr">status</span> === <span class="hljs-string">'processing'</span>) { }
if (<span class="hljs-attr">orderStatus</span> === <span class="hljs-string">'pending'</span>) { }  // 等等，这个 pending 跟上面那个一样吗？
</code></pre>
<p>字符串满天飞，每次都要小心翼翼地打字，生怕打错一个字母。想用枚举来管理这些常量，但 JavaScript 又没有原生的 <code>enum</code> 关键字。</p>
<p>网上搜了一圈，发现大家的做法五花八门：</p>
<ul>
<li>有人用普通对象：<code>const Status = { PENDING: 'pending' }</code></li>
<li>有人用 <code>Object.freeze()</code>：<code>const Status = Object.freeze({ PENDING: 'pending' })</code></li>
<li>还有人干脆直接用字符串，说"够用就行"</li>
</ul>
<p>那到底哪种方式好？有没有更优雅的写法？</p>
<p>最近看到 Dr. Axel Rauschmayer 的一篇文章，介绍了用 Proxy 实现枚举的技巧。虽然他明确说这是个教学示例，不建议直接用在生产环境，但这个思路确实挺巧妙，能帮我们更好地理解 Proxy 和解构赋值的工作原理。</p>
<h2 data-id="heading-0">为什么 JavaScript 需要枚举？</h2>
<h3 data-id="heading-1">字符串常量的问题</h3>
<p>直接用字符串当常量，问题不少：</p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">updateOrder</span>(status) {
  if (status === 'shiped') {  <span class="hljs-comment">// 拼错了！应该是 shipped</span>
    <span class="hljs-comment">// ...</span>
  }
}
​
<span class="hljs-built_in">updateOrder</span>('shipped');  <span class="hljs-comment">// 运行时才发现不匹配</span>
</code></pre>
<p>JavaScript 是弱类型语言，拼错字符串编辑器不会报错，只能在运行时才发现问题。而且满屏的字符串字面量，维护起来真的头疼。</p>
<h3 data-id="heading-2">魔法数字更糟糕</h3>
<p>有些老代码喜欢用数字：</p>
<pre><code class="hljs language-scss" lang="scss">if (userLevel === <span class="hljs-number">3</span>) {  <span class="hljs-comment">// 3 是什么意思？</span>
  <span class="hljs-comment">// ...</span>
}
​
if (priority === <span class="hljs-number">3</span>) {  <span class="hljs-comment">// 这个 3 又是什么意思？</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>半年后回头看代码，鬼知道这个 <code>3</code> 代表什么。</p>
<p>问题的根源在于：<strong>JavaScript 缺少一种原生的、类型安全的方式来定义常量集合</strong>。</p>
<h2 data-id="heading-3">常见的枚举实现方式</h2>
<h3 data-id="heading-4">方式 1：普通对象</h3>
<p>最简单的做法：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">const</span> OrderStatus = {
  PENDING: <span class="hljs-string">'pending'</span>,
  PROCESSING: <span class="hljs-string">'processing'</span>,
  SHIPPED: <span class="hljs-string">'shipped'</span>,
  DELIVERED: <span class="hljs-string">'delivered'</span>
};
​
<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">if</span> (order.status === OrderStatus.SHIPPED) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>这种方式的问题是，对象属性可以被修改：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">OrderStatus.PENDING</span> = <span class="hljs-string">'xxx'</span><span class="hljs-comment">;  // 能改，但不应该改</span>
<span class="hljs-attr">OrderStatus.CANCELLED</span> = <span class="hljs-string">'cancelled'</span><span class="hljs-comment">;  // 能加新属性</span>
</code></pre>
<h3 data-id="heading-5">方式 2：Object.freeze()</h3>
<p>冻结对象，防止修改：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">OrderStatus</span> = Object.<span class="hljs-title function_ invoke__">freeze</span>({
 <span class="hljs-attr"> PENDING</span>: <span class="hljs-string">'pending'</span>,
 <span class="hljs-attr"> PROCESSING</span>: <span class="hljs-string">'processing'</span>,
 <span class="hljs-attr"> SHIPPED</span>: <span class="hljs-string">'shipped'</span>,
 <span class="hljs-attr"> DELIVERED</span>: <span class="hljs-string">'delivered'</span>
});
​
OrderStatus.PENDING = <span class="hljs-string">'xxx'</span>;  <span class="hljs-comment">// 严格模式下报错</span>
</code></pre>
<p>这个方式好一些，但每次都要写 <code>PENDING: 'pending'</code> 这种重复的键值对，有点啰嗦。特别是当枚举值就是字段名的小写形式时，这种重复更明显。</p>
<h3 data-id="heading-6">方式 3：TypeScript 的 enum</h3>
<p>如果用 TypeScript，有两种枚举方式：</p>
<p><strong>数字枚举</strong>（默认）：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span> { 
  foo,    <span class="hljs-comment">// 0</span>
  bar,    <span class="hljs-comment">// 1</span>
  baz     <span class="hljs-comment">// 2</span>
}
​
console.<span class="hljs-built_in">log</span>(MyEnum.foo);  <span class="hljs-comment">// 0</span>
console.<span class="hljs-built_in">log</span>(MyEnum.bar);  <span class="hljs-comment">// 1</span>
</code></pre>
<p>这种方式和很多编程语言（C、Java）的枚举类似，但调试起来不太直观——看到数字 <code>0</code> 你得想一下它代表什么。</p>
<p><strong>字符串枚举</strong>（推荐）：</p>
<pre><code class="hljs language-ini" lang="ini">enum OrderStatus {
  <span class="hljs-attr">PENDING</span> = <span class="hljs-string">'pending'</span>,
  <span class="hljs-attr">PROCESSING</span> = <span class="hljs-string">'processing'</span>,
  <span class="hljs-attr">SHIPPED</span> = <span class="hljs-string">'shipped'</span>,
  <span class="hljs-attr">DELIVERED</span> = <span class="hljs-string">'delivered'</span>
}
​
console.log(OrderStatus.PENDING)<span class="hljs-comment">;  // 'pending' - 一眼就能看懂</span>
</code></pre>
<p>字符串枚举的好处是调试时能直接看到有意义的值，不用去查数字对应什么。但这需要 TypeScript 环境，纯 JavaScript 项目怎么办？</p>
<h2 data-id="heading-7">用 Proxy 实现的巧妙方案</h2>
<p>这里有个挺有意思的技巧，用 Proxy 可以让枚举定义变得更简洁。理解这个技巧需要先了解两个关键点。</p>
<h3 data-id="heading-8">关键点 1：Proxy 拦截器</h3>
<p>核心思路是：创建一个特殊的对象，读取它的任何属性时，都返回属性名本身。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> keyProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({}, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">_target, propKey, _receiver</span>) {
    <span class="hljs-keyword">return</span> propKey;
  }
});
​
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keyProxy.<span class="hljs-property">foo</span>);    <span class="hljs-comment">// 'foo'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keyProxy.<span class="hljs-property">bar</span>);    <span class="hljs-comment">// 'bar'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keyProxy.<span class="hljs-property">hello</span>);  <span class="hljs-comment">// 'hello'</span>
</code></pre>
<p>看到了吗？不管你访问什么属性，都能得到属性名的字符串。</p>
<h3 data-id="heading-9">关键点 2：解构赋值的属性简写</h3>
<p>接下来，配合 ES6 的解构赋值：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">const</span> { PENDING, PROCESSING, SHIPPED, DELIVERED } = keyProxy;
​
console.<span class="hljs-built_in">log</span>(PENDING);     <span class="hljs-comment">// 'PENDING'</span>
console.<span class="hljs-built_in">log</span>(PROCESSING);  <span class="hljs-comment">// 'PROCESSING'</span>
console.<span class="hljs-built_in">log</span>(SHIPPED);     <span class="hljs-comment">// 'SHIPPED'</span>
</code></pre>
<p>这里利用了解构赋值的<strong>属性简写</strong>（property value shorthand）特性。</p>
<p>写 <code>{ foo }</code> 其实是 <code>{ foo: foo }</code> 的简写。这两种写法是<strong>完全等价的</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 简写形式</span>
<span class="hljs-type">const</span> { foo, bar, baz } = keyProxy;
​
<span class="hljs-comment">// 完整形式（等价）</span>
<span class="hljs-type">const</span> { foo: foo, bar: bar, baz: baz } = keyProxy;
</code></pre>
<p>意思是：</p>
<ul>
<li>从 <code>keyProxy</code> 对象中读取 <code>foo</code> 属性</li>
<li>把读到的值赋给变量 <code>foo</code></li>
</ul>
<p>所以上面的代码实际执行的是：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">PENDING</span> = keyProxy.PENDING<span class="hljs-comment">;      // 'PENDING'</span>
const <span class="hljs-attr">PROCESSING</span> = keyProxy.PROCESSING<span class="hljs-comment">; // 'PROCESSING'</span>
const <span class="hljs-attr">SHIPPED</span> = keyProxy.SHIPPED<span class="hljs-comment">;      // 'SHIPPED'</span>
</code></pre>
<p><strong>两个要素结合</strong>就产生了这个效果：</p>
<ol>
<li>Proxy 让属性访问返回属性名</li>
<li>解构赋值让我们同时定义多个常量</li>
</ol>
<p>一行代码搞定所有枚举值的定义。</p>
<h3 data-id="heading-10">实际使用</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 定义枚举</span>
const { PENDING, PROCESSING, SHIPPED, DELIVERED } = keyProxy;
​
<span class="hljs-comment">// 使用</span>
function <span class="hljs-built_in">updateOrder</span>(status) {
  if (status === SHIPPED) {
    console<span class="hljs-selector-class">.log</span>('订单已发货');
  }
}
​
<span class="hljs-built_in">updateOrder</span>(SHIPPED);
</code></pre>
<p>看起来是不是简洁多了？不用重复写键值对，也不用每次都写 <code>Status.PENDING</code> 这样的前缀。</p>
<h2 data-id="heading-11">进阶：用 Symbol 提高类型安全</h2>
<p>如果想要更强的类型安全性，可以把字符串换成 Symbol。</p>
<p>切换到 Symbol 版本只需要改动一行代码：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> symbolProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({}, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">_target, propKey, _receiver</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(propKey);  <span class="hljs-comment">// 只改这一行</span>
  }
});
​
<span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">PENDING</span>, <span class="hljs-variable constant_">PROCESSING</span>, <span class="hljs-variable constant_">SHIPPED</span> } = symbolProxy;
​
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-variable constant_">PENDING</span>);  <span class="hljs-comment">// 'symbol'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(<span class="hljs-variable constant_">PENDING</span>)); <span class="hljs-comment">// 'Symbol(PENDING)'</span>
</code></pre>
<p>其他代码完全不用动，只是把返回值从字符串改成 Symbol。</p>
<h3 data-id="heading-12">Symbol 的好处</h3>
<p><strong>防止误用字符串</strong>：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 用字符串的情况</span>
const { PENDING } = keyProxy;
<span class="hljs-built_in">updateOrder</span>('PENDING');  <span class="hljs-comment">// 能工作，但可能不是你想要的</span>
<span class="hljs-built_in">updateOrder</span>(PENDING);    <span class="hljs-comment">// 也能工作</span>
​
<span class="hljs-comment">// 用 Symbol 的情况</span>
const { PENDING } = symbolProxy;
<span class="hljs-built_in">updateOrder</span>('PENDING');  <span class="hljs-comment">// 不会匹配，因为类型不对</span>
<span class="hljs-built_in">updateOrder</span>(PENDING);    <span class="hljs-comment">// 只有这个才能匹配</span>
</code></pre>
<p>Symbol 是唯一的，即使描述相同，两个 Symbol 也不相等：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'foo'</span>) === <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'foo'</span>)  <span class="hljs-comment">// false</span>
</code></pre>
<p>所以用 Symbol 做枚举值，基本不可能出现误匹配的情况。</p>
<p><strong>更好的调试体验</strong>：</p>
<pre><code class="hljs language-arduino" lang="arduino">console.<span class="hljs-built_in">log</span>(PENDING);  <span class="hljs-comment">// Symbol(PENDING) - 一眼就能看出是什么</span>
</code></pre>
<h2 data-id="heading-13">这个方案的优缺点</h2>
<h3 data-id="heading-14">优势</h3>
<p><strong>简洁</strong>：</p>
<ul>
<li>不用重复写键值对</li>
<li>一行代码搞定所有常量定义</li>
</ul>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 传统方式</span>
<span class="hljs-type">const</span> Status = {
  PENDING: <span class="hljs-string">'PENDING'</span>,
  PROCESSING: <span class="hljs-string">'PROCESSING'</span>,
  SHIPPED: <span class="hljs-string">'SHIPPED'</span>,
  DELIVERED: <span class="hljs-string">'DELIVERED'</span>
};
​
<span class="hljs-comment">// Proxy 方式</span>
<span class="hljs-type">const</span> { PENDING, PROCESSING, SHIPPED, DELIVERED } = keyProxy;
</code></pre>
<p><strong>灵活</strong>：</p>
<ul>
<li>想要字符串就用字符串版本的 Proxy</li>
<li>想要 Symbol 就用 Symbol 版本的 Proxy</li>
<li>随用随取，不需要预先定义所有常量</li>
</ul>
<h3 data-id="heading-15">缺点</h3>
<p><strong>理解成本</strong>：</p>
<p>这个技巧本质上是个教学示例，主要用来展示 Proxy 和解构赋值的灵活性。对于不熟悉这些特性的同事来说，代码可能不够直观。</p>
<p><strong>没有命名空间</strong>：</p>
<p>传统方式的枚举有明确的命名空间：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">OrderStatus</span> = { PENDING: <span class="hljs-string">'pending'</span> }<span class="hljs-comment">;</span>
const <span class="hljs-attr">UserStatus</span> = { PENDING: <span class="hljs-string">'pending'</span> }<span class="hljs-comment">;</span>
​
// 两个 PENDING 不会混淆
</code></pre>
<p>但 Proxy 方式定义的常量是独立的变量：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">const</span> { PENDING: OrderPending } = keyProxy;
<span class="hljs-type">const</span> { PENDING: UserPending } = keyProxy;
​
<span class="hljs-comment">// 需要手动区分变量名</span>
</code></pre>
<p><strong>IDE 支持有限</strong>：</p>
<p>传统对象方式，IDE 能提示你有哪些可用的枚举值：</p>
<pre><code class="hljs language-arduino" lang="arduino">OrderStatus.  <span class="hljs-comment">// IDE 会列出 PENDING, PROCESSING 等</span>
</code></pre>
<p>但 Proxy 方式定义的是普通变量，IDE 不知道你定义了哪些常量。</p>
<h2 data-id="heading-16">实际使用建议</h2>
<p>这个 Proxy 技巧的价值主要在于<strong>学习和理解</strong>，而不是直接应用到生产环境。就像算法题一样，重点是理解思路，而不是把巧妙的解法用在工作代码里。</p>
<h3 data-id="heading-17">适合的场景</h3>
<p><strong>临时常量和快速原型</strong>：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 写测试代码时快速定义一些常量</span>
const { SUCCESS, FAILURE, PENDING } = keyProxy;
​
<span class="hljs-built_in">test</span>('should handle all states', () =&gt; {
  <span class="hljs-built_in">expect</span>(handler(SUCCESS))<span class="hljs-selector-class">.toBe</span>(true);
  <span class="hljs-built_in">expect</span>(handler(FAILURE))<span class="hljs-selector-class">.toBe</span>(false);
  <span class="hljs-built_in">expect</span>(handler(PENDING))<span class="hljs-selector-class">.toBe</span>(null);
});
</code></pre>
<p>在快速开发阶段，不想花时间写繁琐的枚举定义，这个方式很方便。</p>
<h3 data-id="heading-18">生产环境的建议</h3>
<p>对于业务核心的枚举（订单状态、用户角色等），建议还是用传统方式：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 清晰、有命名空间、IDE 友好</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">OrderStatus</span> = Object.<span class="hljs-title function_ invoke__">freeze</span>({
 <span class="hljs-attr"> PENDING</span>: <span class="hljs-string">'pending'</span>,
 <span class="hljs-attr"> PROCESSING</span>: <span class="hljs-string">'processing'</span>,
 <span class="hljs-attr"> SHIPPED</span>: <span class="hljs-string">'shipped'</span>,
 <span class="hljs-attr"> DELIVERED</span>: <span class="hljs-string">'delivered'</span>
});
</code></pre>
<p>或者如果项目使用 TypeScript，直接用 <code>enum</code>：</p>
<pre><code class="hljs language-ini" lang="ini">enum OrderStatus {
  <span class="hljs-attr">PENDING</span> = <span class="hljs-string">'pending'</span>,
  <span class="hljs-attr">PROCESSING</span> = <span class="hljs-string">'processing'</span>,
  <span class="hljs-attr">SHIPPED</span> = <span class="hljs-string">'shipped'</span>,
  <span class="hljs-attr">DELIVERED</span> = <span class="hljs-string">'delivered'</span>
}
</code></pre>
<h3 data-id="heading-19">如果真要用，可以封装</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// utils/enum.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> stringEnum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({}, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">_target, propKey</span>) {
    <span class="hljs-keyword">return</span> propKey;
  }
});
​
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> symbolEnum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>({}, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">_target, propKey</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(propKey);
  }
});
​
<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">import</span> { stringEnum } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils/enum'</span>;
<span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">PENDING</span>, <span class="hljs-variable constant_">PROCESSING</span> } = stringEnum;
</code></pre>
<p>这样至少让代码意图更明确一些。</p>
<h2 data-id="heading-20">写在最后</h2>
<p>这个 Proxy 技巧确实挺巧妙的，理解它的原理也挺有意思。用来学习和理解 JavaScript 的高级特性很有价值。</p>
<p>就像健身房里练单手俯卧撑，不是为了以后干活只用一只手，而是为了提升整体力量。这个技巧也一样：</p>
<ul>
<li>加深对 Proxy 的理解</li>
<li>学会解构赋值的更多玩法</li>
<li>知道"简单特性组合"能产生的效果</li>
</ul>
<p>实际写枚举的时候，老老实实用 <code>Object.freeze()</code> 或者 TypeScript 的 <code>enum</code> 比较好。但如果哪天面试被问到"你能用 Proxy 做点什么有趣的事"，这个例子正好能派上用场。</p>
<p>代码不是越巧妙越好，够清楚、好维护才是王道。</p>
<hr/>
<h2 data-id="heading-21">相关文档</h2>
<ol>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2F2ality.com%2F2018%2F08%2Fenums-via-proxies.html" target="_blank" title="https://2ality.com/2018/08/enums-via-proxies.html" ref="nofollow noopener noreferrer">Enums via proxies (原文)</a></strong> - Dr. Axel Rauschmayer 的原文</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FProxy" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" ref="nofollow noopener noreferrer">Proxy - MDN</a></strong> - Proxy 的详细用法</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSymbol" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" ref="nofollow noopener noreferrer">Symbol - MDN</a></strong> - Symbol 类型说明</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring_assignment" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" ref="nofollow noopener noreferrer">解构赋值 - MDN</a></strong> - 解构赋值的详细说明</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2Ffreeze" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" ref="nofollow noopener noreferrer">Object.freeze() - MDN</a></strong> - 冻结对象的方法</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fenums.html" target="_blank" title="https://www.typescriptlang.org/docs/handbook/enums.html" ref="nofollow noopener noreferrer">TypeScript Enums</a></strong> - TypeScript 的枚举实现</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python FastAPI 数据库集成（SQLAlchemy）+ 接口权限校验]]></title>    <link>https://juejin.cn/post/7570885801477849129</link>    <guid>https://juejin.cn/post/7570885801477849129</guid>    <pubDate>2025-11-10T09:41:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570885801477849129" data-draft-id="7570500819889963051" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python FastAPI 数据库集成（SQLAlchemy）+ 接口权限校验"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-10T09:41:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Hacker_Future"/> <meta itemprop="url" content="https://juejin.cn/user/1978776659433063"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python FastAPI 数据库集成（SQLAlchemy）+ 接口权限校验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1978776659433063/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Hacker_Future
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:41:36.000Z" title="Mon Nov 10 2025 09:41:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Python FastAPI 教程：数据库集成（SQLAlchemy）+ 接口权限校验</h2>
<p>前面我们掌握了参数传递与响应校验，这一节将聚焦生产级 API 核心需求 —— 数据库持久化（基于 SQLAlchemy ORM）和接口权限控制（基于 OAuth2 + JWT），让 API 具备数据存储、身份认证和权限隔离能力。</p>
<h3 data-id="heading-1">一、前置依赖安装</h3>
<p>需额外安装数据库相关和权限相关依赖：</p>
<pre><code class="hljs language-css" lang="css">pip install sqlalchemy pymysql python-jose<span class="hljs-selector-attr">[cryptography]</span> passlib<span class="hljs-selector-attr">[bcrypt]</span> python-multipart
</code></pre>
<ul>
<li>依赖说明：</li>
</ul>

<ul>
<li>
<ul>
<li>sqlalchemy：Python 主流 ORM 框架，实现数据库操作抽象。</li>
</ul>
</li>
</ul>

<ul>
<li>
<ul>
<li>pymysql：MySQL 数据库驱动（若用 PostgreSQL 可替换为 psycopg2-binary）。</li>
</ul>
</li>
</ul>

<ul>
<li>
<ul>
<li>python-jose：生成和验证 JWT 令牌。</li>
</ul>
</li>
</ul>

<ul>
<li>
<ul>
<li>passlib：密码哈希处理（避免明文存储）。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-2">二、数据库集成（SQLAlchemy）</h3>
<p>以 MySQL 为例，实现数据库连接、模型定义、CRUD 操作封装。</p>
<h4 data-id="heading-3">2.1 项目结构调整</h4>
<p>为便于维护，调整项目结构如下：</p>
<pre><code class="hljs language-bash" lang="bash">fastwebprojects/
├── main.py          <span class="hljs-comment"># 主程序入口（路由、APP 初始化）</span>
├── database.py      <span class="hljs-comment"># 数据库连接配置</span>
├── models.py        <span class="hljs-comment"># SQLAlchemy 数据模型（对应数据库表）</span>
├── schemas.py       <span class="hljs-comment"># Pydantic 模型（请求/响应校验）</span>
└── crud.py          <span class="hljs-comment"># 数据库 CRUD 操作封装</span>
</code></pre>
<h4 data-id="heading-4">2.2 数据库连接配置（<a href="https://link.juejin.cn?target=http%3A%2F%2Fdatabase.py%2F" target="_blank" title="http://database.py/" ref="nofollow noopener noreferrer">database.py</a>）</h4>
<pre><code class="hljs language-ini" lang="ini">from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
<span class="hljs-comment"># MySQL 连接地址：mysql+pymysql://用户名:密码@主机:端口/数据库名</span>
<span class="hljs-attr">SQLALCHEMY_DATABASE_URL</span> = <span class="hljs-string">"mysql+pymysql://root:123456@localhost:3306/fastapi_db"</span>
<span class="hljs-comment"># 创建数据库引擎</span>
<span class="hljs-attr">engine</span> = create_engine(
    SQLALCHEMY_DATABASE_URL,
    <span class="hljs-attr">pool_pre_ping</span>=<span class="hljs-literal">True</span>  <span class="hljs-comment"># 连接前校验，避免失效连接</span>
)
<span class="hljs-comment"># 创建会话本地类（每次请求对应一个会话，独立隔离）</span>
<span class="hljs-attr">SessionLocal</span> = sessionmaker(autocommit=<span class="hljs-literal">False</span>, autoflush=<span class="hljs-literal">False</span>, bind=engine)
<span class="hljs-comment"># 基础模型类（所有数据模型继承此类）</span>
<span class="hljs-attr">Base</span> = declarative_base()
</code></pre>
<h4 data-id="heading-5">2.3 定义数据模型（<a href="https://link.juejin.cn?target=http%3A%2F%2Fmodels.py%2F" target="_blank" title="http://models.py/" ref="nofollow noopener noreferrer">models.py</a>）</h4>
<p>数据模型对应数据库表，SQLAlchemy 会自动生成表结构（需手动执行迁移）。</p>
<pre><code class="hljs language-ini" lang="ini">from sqlalchemy import Column, Integer, String, Boolean
from database import Base
<span class="hljs-comment"># 用户表模型</span>
class User(Base):
    <span class="hljs-attr">__tablename__</span> = <span class="hljs-string">"users"</span>  <span class="hljs-comment"># 数据库表名</span>
    <span class="hljs-attr">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 主键 ID，索引</span>
    <span class="hljs-attr">username</span> = Column(String(<span class="hljs-number">50</span>), unique=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, nullable=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 用户名，唯一</span>
    <span class="hljs-attr">email</span> = Column(String(<span class="hljs-number">100</span>), unique=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, nullable=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 邮箱，唯一</span>
    <span class="hljs-attr">hashed_password</span> = Column(String(<span class="hljs-number">100</span>), nullable=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 哈希后的密码</span>
    <span class="hljs-attr">is_active</span> = Column(Boolean, default=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 是否激活</span>
    <span class="hljs-attr">is_admin</span> = Column(Boolean, default=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 是否为管理员（用于权限控制）</span>
</code></pre>
<h4 data-id="heading-6">2.4 初始化数据库表</h4>
<p>在 <a href="https://link.juejin.cn?target=http%3A%2F%2Fmain.py%2F" target="_blank" title="http://main.py/" ref="nofollow noopener noreferrer">main.py</a> 中添加表创建逻辑，启动时自动创建不存在的表：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> database <span class="hljs-keyword">import</span> engine, SessionLocal
<span class="hljs-keyword">import</span> models
<span class="hljs-comment"># 创建所有数据模型对应的数据库表</span>
models.Base.metadata.create_all(bind=engine)
app = FastAPI()
<span class="hljs-comment"># 依赖函数：获取数据库会话（每个请求独立会话）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db</span>():
    db = SessionLocal()
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">yield</span> db  <span class="hljs-comment"># 提供会话给路由函数</span>
    <span class="hljs-keyword">finally</span>:
        db.close()  <span class="hljs-comment"># 请求结束后关闭会话</span>
</code></pre>
<h4 data-id="heading-7">2.5 封装 CRUD 操作（<a href="https://link.juejin.cn?target=http%3A%2F%2Fcrud.py%2F" target="_blank" title="http://crud.py/" ref="nofollow noopener noreferrer">crud.py</a>）</h4>
<p>分离数据库操作与路由逻辑，降低耦合：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session
<span class="hljs-keyword">import</span> models
<span class="hljs-keyword">import</span> schemas
<span class="hljs-keyword">from</span> passlib.context <span class="hljs-keyword">import</span> CryptContext
<span class="hljs-comment"># 密码哈希上下文（使用 bcrypt 算法）</span>
pwd_context = CryptContext(schemes=[<span class="hljs-string">"bcrypt"</span>], deprecated=<span class="hljs-string">"auto"</span>)
<span class="hljs-comment"># 密码哈希处理</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_password_hash</span>(<span class="hljs-params">password: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-keyword">return</span> pwd_context.<span class="hljs-built_in">hash</span>(password)
<span class="hljs-comment"># 验证密码</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_password</span>(<span class="hljs-params">plain_password: <span class="hljs-built_in">str</span>, hashed_password: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-keyword">return</span> pwd_context.verify(plain_password, hashed_password)
<span class="hljs-comment"># 创建用户</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">db: Session, user: schemas.UserCreate</span>):
    hashed_password = get_password_hash(user.password)
    db_user = models.User(
        username=user.username,
        email=user.email,
        hashed_password=hashed_password
    )
    db.add(db_user)  <span class="hljs-comment"># 添加到会话</span>
    db.commit()      <span class="hljs-comment"># 提交事务</span>
    db.refresh(db_user)  <span class="hljs-comment"># 刷新数据（获取自动生成的 ID 等）</span>
    <span class="hljs-keyword">return</span> db_user
<span class="hljs-comment"># 根据用户名查询用户</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_username</span>(<span class="hljs-params">db: Session, username: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-keyword">return</span> db.query(models.User).<span class="hljs-built_in">filter</span>(models.User.username == username).first()
</code></pre>
<h4 data-id="heading-8">2.6 定义 Pydantic 模型（<a href="https://link.juejin.cn?target=http%3A%2F%2Fschemas.py%2F" target="_blank" title="http://schemas.py/" ref="nofollow noopener noreferrer">schemas.py</a>）</h4>
<p>区分请求体（创建用户时传入密码）和响应体（返回时隐藏密码）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, EmailStr, Field
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>
<span class="hljs-comment"># 创建用户的请求体模型（需传入密码）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCreate</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    username: <span class="hljs-built_in">str</span> = Field(..., min_length=<span class="hljs-number">3</span>, max_length=<span class="hljs-number">50</span>, description=<span class="hljs-string">"用户名"</span>)
    email: EmailStr = Field(..., description=<span class="hljs-string">"邮箱"</span>)  <span class="hljs-comment"># EmailStr 自动校验邮箱格式</span>
    password: <span class="hljs-built_in">str</span> = Field(..., min_length=<span class="hljs-number">6</span>, description=<span class="hljs-string">"密码，至少 6 位"</span>)
<span class="hljs-comment"># 返回用户的响应体模型（隐藏密码）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserResponse</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span>
    username: <span class="hljs-built_in">str</span>
    email: EmailStr
    is_active: <span class="hljs-built_in">bool</span>
    is_admin: <span class="hljs-built_in">bool</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:
        orm_mode = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 支持从 SQLAlchemy 模型直接转换</span>
</code></pre>
<h3 data-id="heading-9">三、接口权限校验（OAuth2 + JWT）</h3>
<p>实现「用户名密码登录获取令牌」→「携带令牌访问受保护接口」的完整流程。</p>
<h4 data-id="heading-10">3.1 配置 JWT 密钥与过期时间</h4>
<p>在 <a href="https://link.juejin.cn?target=http%3A%2F%2Fmain.py%2F" target="_blank" title="http://main.py/" ref="nofollow noopener noreferrer">main.py</a> 中添加配置（实际项目建议用环境变量存储密钥）：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta
<span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> JWTError, jwt
<span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, HTTPException, status
<span class="hljs-keyword">from</span> fastapi.security <span class="hljs-keyword">import</span> OAuth2PasswordBearer, OAuth2PasswordRequestForm
<span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session
<span class="hljs-comment"># JWT 配置</span>
SECRET_KEY = <span class="hljs-string">"your-secret-key-32bytes-long-keep-it-safe"</span>  <span class="hljs-comment"># 密钥（生产环境需随机生成）</span>
ALGORITHM = <span class="hljs-string">"HS256"</span>  <span class="hljs-comment"># 加密算法</span>
ACCESS_TOKEN_EXPIRE_MINUTES = <span class="hljs-number">30</span>  <span class="hljs-comment"># 令牌过期时间（30 分钟）</span>
<span class="hljs-comment"># OAuth2 依赖：从请求头的 Authorization 字段获取令牌（格式：Bearer &lt;token&gt;）</span>
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="hljs-string">"token"</span>)
</code></pre>
<h4 data-id="heading-11">3.2 实现令牌生成与验证逻辑</h4>
<p>在 <a href="https://link.juejin.cn?target=http%3A%2F%2Fmain.py%2F" target="_blank" title="http://main.py/" ref="nofollow noopener noreferrer">main.py</a> 中添加核心函数：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 生成访问令牌</span>
def create_access_token(data: dict):
    <span class="hljs-attr">to_encode</span> = data.copy()
    <span class="hljs-comment"># 设置过期时间</span>
    <span class="hljs-attr">expire</span> = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    <span class="hljs-comment"># 生成 JWT 令牌</span>
    <span class="hljs-attr">encoded_jwt</span> = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
<span class="hljs-comment"># 依赖函数：验证令牌并返回当前用户</span>
def get_current_user(
    db: <span class="hljs-attr">Session</span> = Depends(get_db),
    token: <span class="hljs-attr">str</span> = Depends(oauth2_scheme)
):
    <span class="hljs-comment"># 令牌验证失败异常</span>
    <span class="hljs-attr">credentials_exception</span> = HTTPException(
        <span class="hljs-attr">status_code</span>=status.HTTP_401_UNAUTHORIZED,
        <span class="hljs-attr">detail</span>=<span class="hljs-string">"令牌无效或已过期"</span>,
        <span class="hljs-attr">headers</span>={<span class="hljs-string">"WWW-Authenticate"</span>: <span class="hljs-string">"Bearer"</span>},
    )
    try:
        <span class="hljs-comment"># 解码令牌</span>
        <span class="hljs-attr">payload</span> = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: <span class="hljs-attr">str</span> = payload.get(<span class="hljs-string">"sub"</span>)  <span class="hljs-comment"># 令牌中存储的用户名（sub 为标准字段）</span>
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    <span class="hljs-comment"># 查询用户</span>
    <span class="hljs-attr">user</span> = crud.get_user_by_username(db, username=username)
    if user is None:
        raise credentials_exception
    return user
<span class="hljs-comment"># 依赖函数：验证当前用户是否为管理员（权限细化）</span>
def get_current_admin_user(current_user: <span class="hljs-attr">models.User</span> = Depends(get_current_user)):
    if not current_user.is_admin:
        raise HTTPException(
            <span class="hljs-attr">status_code</span>=status.HTTP_403_FORBIDDEN,
            <span class="hljs-attr">detail</span>=<span class="hljs-string">"无权限访问，仅管理员可操作"</span>
        )
    return current_user
</code></pre>
<h4 data-id="heading-12">3.3 实现登录接口（获取令牌）</h4>
<pre><code class="hljs language-ini" lang="ini">@app.post("/token", <span class="hljs-attr">response_model</span>=dict)
async def login_for_access_token(
    db: <span class="hljs-attr">Session</span> = Depends(get_db),
    form_data: <span class="hljs-attr">OAuth2PasswordRequestForm</span> = Depends()  <span class="hljs-comment"># 接收表单格式的用户名密码</span>
):
    <span class="hljs-comment"># 验证用户名和密码</span>
    <span class="hljs-attr">user</span> = crud.get_user_by_username(db, username=form_data.username)
    if not user or not crud.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            <span class="hljs-attr">status_code</span>=status.HTTP_401_UNAUTHORIZED,
            <span class="hljs-attr">detail</span>=<span class="hljs-string">"用户名或密码错误"</span>,
            <span class="hljs-attr">headers</span>={<span class="hljs-string">"WWW-Authenticate"</span>: <span class="hljs-string">"Bearer"</span>},
        )
    <span class="hljs-comment"># 生成令牌（sub 字段存储用户名）</span>
    <span class="hljs-attr">access_token</span> = create_access_token(data={<span class="hljs-string">"sub"</span>: user.username})
    return {"access_token": access_token, "token_type": "bearer"}
</code></pre>
<h4 data-id="heading-13">3.4 实现受保护接口</h4>
<ul>
<li>普通接口：需登录（携带令牌）即可访问。</li>
</ul>

<ul>
<li>管理员接口：需登录且为管理员身份才能访问。</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 普通受保护接口：获取当前登录用户信息</span>
<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">"/users/me/"</span>, response_model=schemas.UserResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_users_me</span>(<span class="hljs-params">current_user: models.User = Depends(<span class="hljs-params">get_current_user</span>)</span>):
    <span class="hljs-keyword">return</span> current_user
<span class="hljs-comment"># 管理员接口：创建用户（仅管理员可操作）</span>
<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">"/users/"</span>, response_model=schemas.UserResponse</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_new_user</span>(<span class="hljs-params">
    user: schemas.UserCreate,
    db: Session = Depends(<span class="hljs-params">get_db</span>),
    current_user: models.User = Depends(<span class="hljs-params">get_current_admin_user</span>)  <span class="hljs-comment"># 管理员权限依赖</span>
</span>):
    <span class="hljs-comment"># 检查用户名是否已存在</span>
    db_user = crud.get_user_by_username(db, username=user.username)
    <span class="hljs-keyword">if</span> db_user:
        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">"用户名已存在"</span>)
    <span class="hljs-keyword">return</span> crud.create_user(db=db, user=user)
</code></pre>
<h3 data-id="heading-14">四、测试流程与验证</h3>
<h4 data-id="heading-15">1. 初始化数据库</h4>
<ol>
<li>确保 MySQL 已启动，创建 fastapi_db 数据库（CREATE DATABASE fastapi_db;）。</li>
</ol>

<ol start="2">
<li>启动 FastAPI 服务（uvicorn main:app --reload），自动创建 users 表。</li>
</ol>
<h4 data-id="heading-16">2. 测试接口（通过 /docs 页面）</h4>
<ul>
<li>第一步：访问 <a href="https://link.juejin.cn?target=http%3A%2F%2F127.0.0.1%3A8000%2Fdocs" target="_blank" title="http://127.0.0.1:8000/docs" ref="nofollow noopener noreferrer">http://127.0.0.1:8000/docs</a>，找到 /token 接口，点击「Try it out」。</li>
</ul>

<ul>
<li>第二步：输入用户名（如 admin）、密码（如 123456），先调用 /users/ 接口（需管理员身份，可手动在数据库将 is_admin 设为 1）创建管理员用户。</li>
</ul>

<ul>
<li>第三步：用管理员用户名密码调用 /token 接口，获取 access_token。</li>
</ul>

<ul>
<li>第四步：调用 /users/me/ 接口，系统会自动携带令牌，返回当前用户信息。</li>
</ul>

<ul>
<li>第五步：非管理员用户调用 /users/ 接口，会返回 403 权限错误。</li>
</ul>
<h3 data-id="heading-17">五、生产级优化建议</h3>
<ol>
<li>密钥与数据库配置：用 python-dotenv 读取环境变量，避免硬编码。</li>
</ol>

<ol start="2">
<li>数据库迁移：使用 alembic 管理表结构变更（避免直接删除重建表）。</li>
</ol>

<ol start="3">
<li>令牌安全：延长过期时间时，可结合刷新令牌机制。</li>
</ol>

<ol start="4">
<li>日志与监控：添加接口访问日志，监控令牌过期、数据库异常等情况。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我们来说一下 Mybatis 的缓存机制]]></title>    <link>https://juejin.cn/post/7570901172526891043</link>    <guid>https://juejin.cn/post/7570901172526891043</guid>    <pubDate>2025-11-10T09:43:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570901172526891043" data-draft-id="7570902473432875008" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我们来说一下 Mybatis 的缓存机制"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-11-10T09:43:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员小假"/> <meta itemprop="url" content="https://juejin.cn/user/2285197690931932"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我们来说一下 Mybatis 的缓存机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2285197690931932/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员小假
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:43:16.000Z" title="Mon Nov 10 2025 09:43:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">核心概览</h3>
<ul>
<li><strong>一级缓存</strong>：默认开启，作用范围在 <strong>同一个 SqlSession</strong> 内。</li>
<li><strong>二级缓存</strong>：需要手动配置开启，作用范围在 <strong>同一个 Mapper 命名空间</strong>（即同一个 Mapper 接口）内，可以被多个 SqlSession 共享。</li>
</ul>
<h3 data-id="heading-1">一级缓存</h3>
<h4 data-id="heading-2">1. 作用域</h4>
<ul>
<li><strong>SqlSession 级别</strong>：当同一个 SqlSession 执行相同的 SQL 查询时，MyBatis 会优先从缓存中获取数据，而不是直接查询数据库。</li>
<li>它是 <strong>默认开启</strong> 的，无法关闭，但可以配置其作用范围（<code>SESSION</code> 或 <code>STATEMENT</code>）。</li>
</ul>
<h4 data-id="heading-3">2. 工作机制</h4>
<ol>
<li>第一次执行查询后，查询结果会被存储到 SqlSession 关联的一级缓存中。</li>
<li>在同一个 SqlSession 中，再次执行 <strong>完全相同的</strong> SQL 查询（包括语句和参数）时，会直接返回缓存中的对象，而不会去数据库查询。</li>
<li>如果 SqlSession 执行了 <strong>增（INSERT）、删（DELETE）、改（UPDATE）</strong> 操作，或者调用了 <code>commit()</code>、<code>close()</code>、<code>rollback()</code> 方法，该 SqlSession 的一级缓存会被清空。这是为了防止读取到脏数据。</li>
</ol>
<h4 data-id="heading-4">3. 示例说明</h4>
<pre><code class="hljs language-ini" lang="ini">// 假设获取的 SqlSession 和 UserMapper
try (SqlSession <span class="hljs-attr">sqlSession</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper</span> = sqlSession.getMapper(UserMapper.class)<span class="hljs-comment">;</span>

    // 第一次查询，会发送 SQL 到数据库
    User <span class="hljs-attr">user1</span> = mapper.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
    System.out.println(user1)<span class="hljs-comment">;</span>

    // 第二次查询，SQL 和参数完全相同，直接从一级缓存返回，不查询数据库
    User <span class="hljs-attr">user2</span> = mapper.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
    System.out.println(user2)<span class="hljs-comment">;</span>

    // 判断是否为同一个对象（是，因为从缓存中返回的是同一个对象的引用）
    System.out.println(<span class="hljs-attr">user1</span> == user2)<span class="hljs-comment">; // 输出：true</span>

    // 执行一个更新操作
    mapper.updateUser(user1)<span class="hljs-comment">;</span>
    // 此时，一级缓存被清空

    // 第三次查询，因为缓存被清空，会再次发送 SQL 到数据库
    User <span class="hljs-attr">user3</span> = mapper.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
    System.out.println(<span class="hljs-attr">user3</span> == user1)<span class="hljs-comment">; // 输出：false (虽然是同一条数据，但已是新对象)</span>
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-5">4. 注意事项</h4>
<ul>
<li><strong>对象相同</strong>：一级缓存返回的是 <strong>同一个对象的引用</strong>，因此在同一个 SqlSession 内，你操作的都是同一个 Java 对象。</li>
<li><strong>分布式环境</strong>：一级缓存无法在多个应用服务器之间共享，因为它绑定在单个请求的 SqlSession 上。</li>
</ul>
<h3 data-id="heading-6">二级缓存</h3>
<h4 data-id="heading-7">1. 作用域</h4>
<ul>
<li><strong>Mapper 级别 / Namespace 级别</strong>：多个 SqlSession 在访问同一个 Mapper 的查询时，可以共享其缓存。</li>
<li>它是 <strong>默认关闭</strong> 的，需要在全局配置中开启，并在具体的 Mapper XML 中显式配置。</li>
</ul>
<h4 data-id="heading-8">2. 开启与配置</h4>
<p><strong>a. 全局配置文件 (</strong> <code>mybatis-config.xml</code> <strong>)</strong> ：<br/>
必须显式设置开启二级缓存（虽然默认是 <code>true</code>，但显式声明是个好习惯）。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 开启全局二级缓存，默认就是 true，但建议写明 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>b. Mapper XML 文件</strong>：<br/>
在需要开启二级缓存的 Mapper.xml 中添加 <code>&lt;cache/&gt;</code> 标签。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span> ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.example.mapper.UserMapper"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 开启本 Mapper 的二级缓存 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">cache</span>
<span class="hljs-attr">eviction</span>=<span class="hljs-string">"FIFO"</span>
<span class="hljs-attr">flushInterval</span>=<span class="hljs-string">"60000"</span>
<span class="hljs-attr">size</span>=<span class="hljs-string">"512"</span>
<span class="hljs-attr">readOnly</span>=<span class="hljs-string">"true"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 其他 SQL 定义 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectUserById"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"long"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"User"</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">"true"</span>&gt;</span>
SELECT * FROM user WHERE id = #{id}
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<ul>
<li>
<p><code>&lt;cache/&gt;</code> 标签属性：</p>
<ul>
<li>
<p><code>eviction</code>：缓存回收策略。</p>
<ul>
<li><code>LRU</code>（默认）：最近最少使用。</li>
<li><code>FIFO</code>：先进先出。</li>
<li><code>SOFT</code>：软引用，基于垃圾回收器状态和软引用规则移除。</li>
<li><code>WEAK</code>：弱引用，更积极地移除。</li>
</ul>
</li>
<li>
<p><code>flushInterval</code>：缓存刷新间隔（毫秒），默认不清空。</p>
</li>
<li>
<p><code>size</code>：缓存存放多少元素。</p>
</li>
<li>
<p><code>readOnly</code>：是否为只读。</p>
<ul>
<li><code>true</code>：返回相同的缓存对象实例，性能好，但不允许修改。</li>
<li><code>false</code>（默认）：通过序列化返回缓存对象的拷贝，安全，性能稍差。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 data-id="heading-9">3. 工作机制</h4>
<ol>
<li>当一个 SqlSession 执行查询后，在关闭或提交时，其查询结果会被存入二级缓存。</li>
<li>另一个 SqlSession 执行相同的查询时，会先从二级缓存中查找数据。如果找到，则直接返回，否则再去数据库查询。</li>
<li>任何一个 SqlSession 执行了 <strong>增、删、改</strong> 操作并 <code>commit()</code> 后，会清空 <strong>整个对应 Mapper 的二级缓存</strong>，以保证数据一致性。</li>
</ol>
<h4 data-id="heading-10">4. 示例说明</h4>
<pre><code class="hljs language-ini" lang="ini">// 第一个 SqlSession
try (SqlSession <span class="hljs-attr">sqlSession1</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper1</span> = sqlSession1.getMapper(UserMapper.class)<span class="hljs-comment">;</span>
    User <span class="hljs-attr">user1</span> = mapper1.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">; // 查询数据库</span>
    sqlSession1.close()<span class="hljs-comment">; // 关闭时，数据存入二级缓存</span>
}

// 第二个 SqlSession（与第一个不同）
try (SqlSession <span class="hljs-attr">sqlSession2</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper2</span> = sqlSession2.getMapper(UserMapper.class)<span class="hljs-comment">;</span>
    // 查询相同的 SQL，直接从二级缓存获取，不查询数据库
    User <span class="hljs-attr">user2</span> = mapper2.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
}

// 第三个 SqlSession，执行了更新
try (SqlSession <span class="hljs-attr">sqlSession3</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper3</span> = sqlSession3.getMapper(UserMapper.class)<span class="hljs-comment">;</span>
    User <span class="hljs-attr">user</span> = mapper3.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
    user.setName("New Name")<span class="hljs-comment">;</span>
    mapper3.updateUser(user)<span class="hljs-comment">; // 执行更新</span>
    sqlSession3.commit()<span class="hljs-comment">; // 提交时，清空 UserMapper 的二级缓存</span>
}

// 第四个 SqlSession
try (SqlSession <span class="hljs-attr">sqlSession4</span> = sqlSessionFactory.openSession()) {
    UserMapper <span class="hljs-attr">mapper4</span> = sqlSession4.getMapper(UserMapper.class)<span class="hljs-comment">;</span>
    // 因为缓存已被清空，所以会再次查询数据库
    User <span class="hljs-attr">user4</span> = mapper4.selectUserById(<span class="hljs-number">1</span>L)<span class="hljs-comment">;</span>
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-11">5. 注意事项</h4>
<ul>
<li><strong>实体类序列化</strong>：如果二级缓存的 <code>readOnly="false"</code>，那么对应的实体类必须实现 <code>Serializable</code> 接口。</li>
<li><strong>事务提交</strong>：只有在 SqlSession 执行 <code>commit()</code> 或 <code>close()</code> 时，数据才会从一级缓存转存到二级缓存。</li>
<li><strong>缓存粒度</strong>：二级缓存是 Mapper 级别的，有时会显得比较粗粒度。可以通过 <code>&lt;cache-ref&gt;</code> 让多个 Mapper 共享一个缓存，但不推荐，容易引起数据混乱。</li>
</ul>
<h3 data-id="heading-12">缓存顺序与总结</h3>
<p>当发起一个查询请求时，MyBatis 的缓存查询顺序是：</p>
<ol>
<li><strong>先查二级缓存</strong>：查看当前 Mapper 的二级缓存中是否有数据。</li>
<li><strong>再查一级缓存</strong>：如果二级缓存没有，再查看当前 SqlSession 的一级缓存中是否有数据。</li>
<li><strong>最后查数据库</strong>：如果两级缓存都没有，才发送 SQL 语句到数据库执行查询。</li>
</ol>
<p>查询到的数据会 <strong>先存入一级缓存</strong>，在 SqlSession 关闭或提交时，<strong>再转存到二级缓存</strong>。</p>



































<table><thead><tr><th/><th/><th/></tr></thead><tbody><tr><td>特性</td><td>一级缓存</td><td>二级缓存</td></tr><tr><td><strong>作用域</strong></td><td>SqlSession</td><td>Mapper (Namespace)</td></tr><tr><td><strong>默认状态</strong></td><td>开启</td><td>关闭</td></tr><tr><td><strong>是否共享</strong></td><td>否，Session 独享</td><td>是，跨 Session 共享</td></tr><tr><td><strong>清空时机</strong></td><td>UPDATE/INSERT/DELETE, <code>commit()</code>, <code>close()</code></td><td>同 Mapper 的 UPDATE/INSERT/DELETE + <code>commit()</code></td></tr></tbody></table>
<h3 data-id="heading-13">使用建议</h3>
<ul>
<li><strong>查询多，修改少</strong>的数据适合使用二级缓存，如字典表、配置项。</li>
<li><strong>数据实时性要求高</strong>的场景（如交易、订单）应谨慎使用二级缓存，或者设置较短的刷新间隔。</li>
<li>在分布式环境中，默认的二级缓存（基于内存）是无法共享的，需要集成 Redis、Ehcache 等第三方缓存中间件来替代。</li>
<li>理解缓存机制有助于解决一些“诡异”的问题，比如在同一个事务中，先后查询和更新，但由于一级缓存的存在，后续查询可能看不到其他线程的更新。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Android】Android内存缓存LruCache与DiskLruCache的使用及实现原理]]></title>    <link>https://juejin.cn/post/7570902473432645632</link>    <guid>https://juejin.cn/post/7570902473432645632</guid>    <pubDate>2025-11-10T09:18:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7570902473432645632" data-draft-id="7570902473432612864" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Android】Android内存缓存LruCache与DiskLruCache的使用及实现原理"/> <meta itemprop="keywords" content="Java,Android"/> <meta itemprop="datePublished" content="2025-11-10T09:18:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="弥巷"/> <meta itemprop="url" content="https://juejin.cn/user/1743186606454698"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Android】Android内存缓存LruCache与DiskLruCache的使用及实现原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1743186606454698/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    弥巷
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-10T09:18:11.000Z" title="Mon Nov 10 2025 09:18:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-10
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">【Android】Android内存缓存LruCache与DiskLruCache的使用及实现原理</h2>
<p>在Android中，通常会通过缓存策略来优化性能，同时也会减少不必要的流量消耗。比如，用户第一次使用网络加载一张图片后，下次加载这张图片的时候，并不会从网络加载，而是会从内存或者磁盘加载这张图片。</p>
<h3 data-id="heading-1">1.LRU缓存淘汰算法</h3>
<p>由于缓存的大小并不是无限制的，因此在使用缓存时总是要为缓存指定一个最大的容量。如果当缓存容量满了，但是程序还需要向其添加缓存，这就需要删除一些旧的缓存并添加新的缓存，如何定义缓存的新旧就对应着不同的缓存算法。最常用的一种缓存算法是<strong>LRU （Least Recently Used）最近最少使用算法</strong>，它的基本理念是：<strong>当缓存空间不足时，优先淘汰最久未被访问的数据</strong>。常见缓存淘汰策略还有：</p>
<p><strong>1、随机策略：</strong> 使用一个随机数生成器随机地选择要被淘汰的数据块；</p>
<p><strong>2、FIFO 先进先出策略：</strong> 记录各个数据块的访问时间，最早访问的数据最先被淘汰；</p>
<p><strong>3、LRU （Least Recently Used）最近最少策略：</strong> 记录各个数据块的访问 <strong>“时间戳”</strong> ，最近最久未使用的数据最先被淘汰。与前 2 种策略相比，LRU 策略平均缓存命中率更高，这是因为 LRU 策略利用了 “局部性原理”：最近被访问过的数据，将来被访问的几率较大，最近很久未访问的数据，将来访问的几率也较小；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/56deddf81e2e4c0c90a1d58db591cfff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=cl43IO1MJdhR%2FEX%2BRRbTdg%2Fd0Ko%3D" alt="1613c53defb9b5d4~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.png" loading="lazy"/></p>
<p><strong>4、LFU （Least Frequently Used）最不经常使用策略：</strong> 与 LRU 相比，LFU 更加注重使用的 <strong>“频率”</strong> 。LFU 会记录每个数据块的访问次数，最少访问次数的数据最先被淘汰。但是有些数据在开始时使用次数很高，以后不再使用，这些数据就会长时间污染缓存。可以定期将计数器右移一位，形成指数衰减。</p>
<p>而在Android中，Lru对应LruCache和DiskLruCache两种缓存类。</p>
<h3 data-id="heading-2">2. LruCache的使用</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">int</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span>);
<span class="hljs-comment">//初始化大小:当前进程的可用内存的1/8</span>
<span class="hljs-type">int</span> <span class="hljs-variable">cacheSize</span> <span class="hljs-operator">=</span> maxMemory / <span class="hljs-number">8</span>;
memorySize = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LruCache</span>&lt;String, Bitmap&gt;(cacheSize) {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sizeOf</span><span class="hljs-params">(String key, Bitmap value)</span> {
        <span class="hljs-comment">//重写该方法,完成每张要缓存的图片大小的计算</span>
        <span class="hljs-keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight() / <span class="hljs-number">1024</span>;
    }
};

</code></pre>
<p>使用非常简单，只需要提供缓存的总容量大小并重写sizeOf方法即可。总容量大小为当前进程可用内存的1/8，sizeOf方法完成对Bitmap对象大小的计算。</p>
<p>除了创建缓存，还有下面一些常用方法：</p>

































<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>get(K)</td><td>通过K获取缓存</td></tr><tr><td>put(K,V)</td><td>设置K的值为V</td></tr><tr><td>remove(K)</td><td>删除K缓存</td></tr><tr><td>evictAll()</td><td>清除缓存</td></tr><tr><td>resize(int)</td><td>设置最大缓存大小</td></tr><tr><td>snapshot()</td><td>获取缓存内容的镜像</td></tr></tbody></table>
<h3 data-id="heading-3">3.DiskLruCache的使用</h3>
<p>DiskLruCache不是Android SDK的一部分，而是由Jake Wharton在JakeWharton/DiskLruCache提供的一个开源实现。所以使用之前要先引入依赖：</p>
<pre><code class="hljs language-groovy" lang="groovy">implementation 'com.jakewharton:disklrucache:2.0.2'
</code></pre>
<h4 data-id="heading-4">3.1 DiskLruCache的创建</h4>
<p><code>DiskLruCache</code>并不能通过构造方法来创建，它提供了open方法用于创建自身：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> com.jakewharton.disklrucache.DiskLruCache;
<span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskCacheHelper</span> {
    <span class="hljs-keyword">private</span> DiskLruCache diskLruCache;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiskCacheHelper</span><span class="hljs-params">(File cacheDir)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-comment">// 创建缓存目录</span>
        <span class="hljs-keyword">if</span> (!cacheDir.exists()) {
            cacheDir.mkdirs();
        }
        
        <span class="hljs-comment">// 初始化DiskLruCache</span>
        <span class="hljs-comment">// 参数：缓存目录, 版本号, 每个key对应的文件数, 最大缓存大小(字节)</span>
        diskLruCache = DiskLruCache.open(cacheDir, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 10MB</span>
    }
}
</code></pre>
<p>open方法有四个参数，其中第一个参数表示磁盘缓存在文件系统中的存储路径。第二个参数表示应用的版本号，一般设为1即可；第三个参数表示单个节点所对应的数据的个数，一般设为1即可；第四个参数表示缓存的总大小，比如10MB，当缓存大小超出这个设定值后，DiskLruCache会清除一些缓存从而保证总大小不大于这个设定值。</p>
<h4 data-id="heading-5">3.2 DiskLruCache的缓存添加</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveToCache</span><span class="hljs-params">(String key, String data)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// 获取编辑器</span>
    DiskLruCache.<span class="hljs-type">Editor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> diskLruCache.edit(key);
    <span class="hljs-keyword">if</span> (editor == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-comment">// 写入数据</span>
    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> editor.newOutputStream(<span class="hljs-number">0</span>);
    outputStream.write(data.getBytes());
    outputStream.close();
    
    <span class="hljs-comment">// 提交保存</span>
    editor.commit();
}
</code></pre>
<p>要添加缓存，首先要通过key获取缓存对象的<code>Editor</code>（编辑对象），对于这个key来说如果当前不存在其他Editor对象。那么edit()就会返回一个新的Editor对象，接着通过这个Editor就可以得到一个文件输出流，有了文件输出流，数据就可以通过这个文件输出流写入到文件系统上。最后要注意的是，单单通过<code>outputStream.write(data.getBytes());</code>，数据其实并没有真正地写入文件系统，还必须通过Editor的commit()来提交写入操作。如果数据下载过程中发生了异常还可以通过Editor的abort()来回退整个操作:</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> editor.newOutputStream(<span class="hljs-number">0</span>)) {
            os.write(data.getBytes());
        }
        editor.commit();
    } <span class="hljs-keyword">catch</span> (IOException e) {
        editor.abort(); <span class="hljs-comment">// 回退</span>
        <span class="hljs-keyword">throw</span> e;
    }
</code></pre>
<p>这样数据就成功写入到文件系统了，接下来数据（比如图片）的获取就不需要网络了。</p>
<h4 data-id="heading-6">3.3 DiskLruCache的缓存查找</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">readFromCache</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// 获取快照</span>
    DiskLruCache.<span class="hljs-type">Snapshot</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> diskLruCache.get(key);
    <span class="hljs-keyword">if</span> (snapshot == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    <span class="hljs-comment">// 读取数据</span>
    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> snapshot.getInputStream(<span class="hljs-number">0</span>);
    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream));
    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
    String line;
    
    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) {
        stringBuilder.append(line);
    }
    
    reader.close();
    snapshot.close();
    <span class="hljs-keyword">return</span> stringBuilder.toString();
}
</code></pre>
<p>和缓存的添加类似，查找缓存首先通过DiskLruCache的get方法传入key获取到Snapshot对象，接下里通过Snapshot对象就能得到缓存的文件输入流，拿到文件输入流，就能很轻松的得到原始数据。</p>
<h4 data-id="heading-7">3.4 DiskLruCache的缓存删除</h4>
<p>删除就非常简单了，DiskLruCache提供了remove方法实现缓存的删除操作：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFromCache</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException {
    diskLruCache.remove(key);
}
</code></pre>
<h3 data-id="heading-8">4. LruCache的源码实现</h3>
<p>LruCahche其实使用了LinkedHashMap双向链表结构，以下是LinkedHashMap的构造方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,
                         <span class="hljs-type">float</span> loadFactor,
                         <span class="hljs-type">boolean</span> accessOrder)</span> {
        <span class="hljs-built_in">super</span>(initialCapacity, loadFactor);
        <span class="hljs-built_in">this</span>.accessOrder = accessOrder;
    }
</code></pre>
<p>布尔变量<code>accessOrder</code>为true时，LinkedHashMap会以访问顺序排列元素，也就是访问了之后就将这个元素放到集合的最后面，否则以插入顺序排列元素。</p>
<p>可以发现，在LiskHashMap中，当<code>accessOrder</code>为true时，最后被访问的元素会被移动到表尾，而LruCache也是从表尾访问数据，在表头删除元素，这正是符合我们预期的，接下来看看LruCache是如何进行缓存的写入、获取和删除的。</p>
<h4 data-id="heading-9">4.1 LruCache的put()方法分析：</h4>
<p>写入缓存是通过LruChche的put方法实现的，源码如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> {
        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">"key == null || value == null"</span>);
        }
		<span class="hljs-comment">// 这个变量用于保存被替换的旧值（如果有的话）</span>
        V previous;
    	<span class="hljs-comment">// 加锁，确保线程安全 </span>
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            <span class="hljs-comment">// 缓存数量自增</span>
            putCount++;
            <span class="hljs-comment">// 计算缓存总大小，safeSizeOf方法计算当前键值对的大小</span>
            size += safeSizeOf(key, value);
            <span class="hljs-comment">// 通过LinkedHashMap中的put方法将键值对存入map中</span>
            <span class="hljs-comment">// 如果键已存在，map.put会返回被替换的旧值，否则返回null</span>
            previous = map.put(key, value);
            <span class="hljs-comment">// 旧值存在（就是更新键所对应的值）</span>
            <span class="hljs-keyword">if</span> (previous != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 从总大小中减去旧值的大小，注意新值大小已经添加</span>
                size -= safeSizeOf(key, previous);
            }
        }

        <span class="hljs-keyword">if</span> (previous != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 用于资源回收清理</span>
            entryRemoved(<span class="hljs-literal">false</span>, key, previous, value);
        }
    
		<span class="hljs-comment">// 检查并调整缓存大小，使用Lru算法确保当前缓存总大小不会超出最大容量限制</span>
        trimToSize(maxSize);
    	<span class="hljs-comment">// 返回被替换的旧值（如果存在） </span>
        <span class="hljs-keyword">return</span> previous;
    }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> {
    	<span class="hljs-comment">// 无限循环删除最老缓存直到大小满足要求 </span>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-comment">// 用于保存被删除的键值对</span>
            K key;
            V value;
            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
				<span class="hljs-comment">// 参数检查</span>
                <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="hljs-number">0</span>)) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(getClass().getName()
                            + <span class="hljs-string">".sizeOf() is reporting inconsistent results!"</span>);
                }
				<span class="hljs-comment">// 循环终止条件：当前大小小于等于最大容量，不需要删除最老缓存</span>
                <span class="hljs-keyword">if</span> (size &lt;= maxSize) {
                    <span class="hljs-keyword">break</span>;
                }
				
                <span class="hljs-comment">// 核心：eldest()方法返回最近最少使用的缓存，也就是链表的表头元素</span>
                Map.Entry&lt;K, V&gt; toEvict = eldest();
                <span class="hljs-comment">// 异常判断：没有可移除的缓存</span>
                <span class="hljs-keyword">if</span> (toEvict == <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">break</span>;
                }
				<span class="hljs-comment">// 最近最少使用的缓存的键值对</span>
                key = toEvict.getKey();
                value = toEvict.getValue();
                <span class="hljs-comment">// 使用LinkedHashMap的remove方法移除该缓存</span>
                map.remove(key);
                <span class="hljs-comment">// 从总大小中减去删除的缓存大小</span>
                size -= safeSizeOf(key, value);
                <span class="hljs-comment">// 移除计数器自增</span>
                evictionCount++;
            }
			
            <span class="hljs-comment">// 资源回收，true表示由于缓存空间不足而被删除，null表示新值</span>
            entryRemoved(<span class="hljs-literal">true</span>, key, value, <span class="hljs-literal">null</span>);
        }
    }
</code></pre>
<p>put方法主要是添加缓存后，然后调用<code>trimToSize</code>方法使用Lru算法来删除最近最少使用的缓存，保证缓存大小。同时两个方法都使用了同步方法块确保线程安全，简要概括来讲就是先插入后检查，以下图示很清楚地展示了put方法的工作流程：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a5524aeb01b64351b07b06a810f255a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=dhYZreDzLeQqNTPaA1QCGlASu%2FI%3D" alt="38d656e051a548778c1bd5705ee44ed0~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" loading="lazy"/></p>
<h4 data-id="heading-10">4.2 LruCache的get()方法分析：</h4>
<p>get()方法实现了LruCache的读取缓存操作：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> {
    	<span class="hljs-comment">// 键的非空判断 </span>
        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">"key == null"</span>);
        }

        V mapValue;
    	<span class="hljs-comment">// 尝试从缓存中获取值 </span>
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            <span class="hljs-comment">//调用LinkedHashMap的get()方法，注意如果该元素存在，且accessOrder为true，这个方法会将该元素移动到表尾</span>
            mapValue = map.get(key);
            <span class="hljs-comment">// 缓存命中：</span>
            <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-literal">null</span>) {
                hitCount++; <span class="hljs-comment">// 命中计数器自增</span>
                <span class="hljs-keyword">return</span> mapValue; <span class="hljs-comment">// 返回找到的值，get()方法结束 </span>
            }
            <span class="hljs-comment">// 缓存没有命中：</span>
            missCount++; <span class="hljs-comment">// 未命中计数器自增</span>
        }
		
    	<span class="hljs-comment">// 缓存未命中处理：创建值 </span>
        <span class="hljs-type">V</span> <span class="hljs-variable">createdValue</span> <span class="hljs-operator">=</span> create(key);
    	<span class="hljs-comment">// creat()方法返回null，创建失败，get()直接返回null </span>
        <span class="hljs-keyword">if</span> (createdValue == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
		
    	<span class="hljs-comment">// 将创建的值存入缓存 </span>
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            createCount++; <span class="hljs-comment">// 创建计数器自增</span>
            
            <span class="hljs-comment">// 尝试将创建的值存入map</span>
            <span class="hljs-comment">// 注：在释放锁和重新加锁的间隙，其他线程可能已经存入相同的键，所以这里使用put()方法，可能会返回已经存在的值</span>
            mapValue = map.put(key, createdValue);

            <span class="hljs-comment">// 如果mapValue不为空，说明创建过程中发生了冲突，也就是其他线程在我们创建值的同时也插入了相同的键</span>
            <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// There was a conflict so undo that last put</span>
                <span class="hljs-comment">// 撤销刚才的put操作，就是把其他线程插入的值恢复</span>
                map.put(key, mapValue);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 没有冲突，正常更新缓存大小</span>
                size += safeSizeOf(key, createdValue);
            }
        }

        <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// 发生冲突，通知创建的值被丢弃，回调entryRemoved完方法成资源的回收工作</span>
            entryRemoved(<span class="hljs-literal">false</span>, key, createdValue, mapValue);
            <span class="hljs-keyword">return</span> mapValue; <span class="hljs-comment">// 返回其他线程插入的值（就是最终缓存中的值） </span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 没有冲突，正常进行容量检查</span>
            trimToSize(maxSize);
            <span class="hljs-comment">// 返回创建的值</span>
            <span class="hljs-keyword">return</span> createdValue;
        }
    }
</code></pre>
<p>逻辑很清楚，首先通过LinkedHashMap的get方法通过键key获取值，如果存在，并且<code>且accessOrder</code>为true，整个方法会将元素移动到表尾，实现Lru的缓存逻辑。</p>
<p>如果get方法获取不到值，那么就创建键值对通过LinkedHashMap的put方法存入map，和put方法的逻辑类似，不过中间会进行线程安全的判断，保证不会重复插入键。</p>
<p>get方法图示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ba74e8e6b9194c1f8c87d364b340010b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=zYuRdFyBYcTrbDVZAllNq48KEOo%3D" alt="5aa6a6141c2f40c3886c7d6204732a97~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" loading="lazy"/></p>
<h4 data-id="heading-11">4.3 LruCache删除缓存方法分析：</h4>
<p>LruCache中删除缓存是通过remove()方法实现的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(K key)</span> {
        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">"key == null"</span>);
        }
		
    	<span class="hljs-comment">// 保存被移除的值 </span>
        V previous;
    	<span class="hljs-comment">// 确保线程安全地移除操作 </span>
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
            <span class="hljs-comment">// 从map中移除缓存</span>
            <span class="hljs-comment">// 如果存在key所对应地值，返回被移除的值</span>
            <span class="hljs-comment">// 不存在就返回null</span>
            previous = map.remove(key);
            <span class="hljs-comment">// 成功移除了缓存</span>
            <span class="hljs-keyword">if</span> (previous != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 更新缓存总大小</span>
                size -= safeSizeOf(key, previous);
            }
        }
		
    	<span class="hljs-comment">// 成功移除缓存，回调entryRemoved方法进行资源回收工作</span>
        <span class="hljs-keyword">if</span> (previous != <span class="hljs-literal">null</span>) {
            entryRemoved(<span class="hljs-literal">false</span>, key, previous, <span class="hljs-literal">null</span>);
        }
		
    	<span class="hljs-comment">// 返回被移除的值，如果键不存在就返回null </span>
        <span class="hljs-keyword">return</span> previous;
    }
</code></pre>
<p>同样非常简单，调用LinkedHashMap的remove方法删除key所对应的值，也是使用了同步方法块来确保线程安全</p>
<p>图示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8018cbb315b94a04ba934f57cc31b2ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=kPQKEqPAB1YpLf%2B8YuTZ18PpuZU%3D" alt="f7c6012cbe3546119f70c48bccded3d3~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" loading="lazy"/></p>
<h3 data-id="heading-12">5. DiskLruCache的源码实现</h3>
<h4 data-id="heading-13">5.1 DiskLruCache的open()方法分析</h4>
<p>DiskLruCache的使用从DiskLruCache的创建开始，也就是从open方法开始，接下来看看open方法的实现：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 打开或创建磁盘LRU缓存实例
 * 这是DiskLruCache的主入口方法，负责缓存的初始化、恢复和重建
 * 
 * <span class="hljs-doctag">@param</span> directory 缓存目录，缓存文件将存储在此目录下
 * <span class="hljs-doctag">@param</span> appVersion 应用版本号，用于版本管理（版本变更时会清空缓存）
 * <span class="hljs-doctag">@param</span> valueCount 每个缓存条目对应的文件数量（通常为1）
 * <span class="hljs-doctag">@param</span> maxSize 缓存的最大容量（字节）
 * <span class="hljs-doctag">@return</span> 初始化好的DiskLruCache实例
 * <span class="hljs-doctag">@throws</span> IOException 如果发生I/O错误
 * <span class="hljs-doctag">@throws</span> IllegalArgumentException 如果参数不合法
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskLruCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> {
    
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DiskLruCache <span class="hljs-title function_">open</span><span class="hljs-params">(File directory, <span class="hljs-type">int</span> appVersion, <span class="hljs-type">int</span> valueCount, <span class="hljs-type">long</span> maxSize)</span>
          <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">if</span> (maxSize &lt;= <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"maxSize &lt;= 0"</span>);
        }
        <span class="hljs-keyword">if</span> (valueCount &lt;= <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"valueCount &lt;= 0"</span>);
        }
    
        <span class="hljs-type">File</span> <span class="hljs-variable">backupFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(directory, JOURNAL_FILE_BACKUP);
        <span class="hljs-comment">//如果备份文件存在</span>
        <span class="hljs-keyword">if</span> (backupFile.exists()) {
          <span class="hljs-type">File</span> <span class="hljs-variable">journalFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(directory, JOURNAL_FILE);
          <span class="hljs-comment">// 如果journal文件存在，则把备份文件journal.bkp是删了</span>
          <span class="hljs-keyword">if</span> (journalFile.exists()) {
            backupFile.delete();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//如果journal文件不存在，则将备份文件命名为journal</span>
            renameTo(backupFile, journalFile, <span class="hljs-literal">false</span>);
          }
        }
    	<span class="hljs-comment">// 尝试从现有缓存恢复：优先复用已有的缓存数据</span>
        <span class="hljs-type">DiskLruCache</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskLruCache</span>(directory, appVersion, valueCount, maxSize);
        
        <span class="hljs-comment">//判断journal文件是否存在</span>
        <span class="hljs-keyword">if</span> (cache.journalFile.exists()) {
          <span class="hljs-comment">//如果日志文件以及存在</span>
          <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 恢复现有缓存的三步流程：</span>
            <span class="hljs-comment">// 1. readJournal(): 读取日志文件内容到内存</span>
            cache.readJournal();
            <span class="hljs-comment">// 2. processJournal(): 处理日志条目，重建缓存状态</span>
            cache.processJournal();
            <span class="hljs-comment">// 3. 创建追加模式的日志写入器，用于后续操作</span>
            cache.journalWriter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(cache.journalFile, <span class="hljs-literal">true</span>), Util.US_ASCII));
            <span class="hljs-keyword">return</span> cache;
          } <span class="hljs-keyword">catch</span> (IOException journalIsCorrupt) {
            System.out
                .println(<span class="hljs-string">"DiskLruCache "</span>
                    + directory
                    + <span class="hljs-string">" is corrupt: "</span>
                    + journalIsCorrupt.getMessage()
                    + <span class="hljs-string">", removing"</span>);
            cache.delete();
          }
        }
    
        <span class="hljs-comment">// Create a new empty cache.</span>
        <span class="hljs-comment">//创建新的缓存目录</span>
        directory.mkdirs();
        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskLruCache</span>(directory, appVersion, valueCount, maxSize);
        <span class="hljs-comment">//调用新的方法建立新的journal文件</span>
        cache.rebuildJournal();
        <span class="hljs-keyword">return</span> cache;
      }
}

</code></pre>
<p>DiskLruCache的构造方法并没有做别的事情，只是简单的将对应成员变量进行初始化，open()方法主要围绕着journal文件的创建与读写而展开的，如下所示：</p>
<ul>
<li>readJournal()：读取journal文件，主要是读取文件头里的信息进行检验，然后调用readJournalLine()逐行去读取，根据读取的内容，执行相应的缓存 添加、移除等操作。</li>
<li>rebuildJournal()：重建journal文件，重建journal文件主要是写入文件头（上面提到的journal文件都有的前面五行的内容）。</li>
<li>rocessJournal()：计算当前缓存容量的大小。</li>
</ul>
<p>至于journal文件，则是一个<strong>日志文件</strong>，主要用于记录缓存的所有操作和状态。这里关于journal文件的创建和读写流程就不展开了，感兴趣的朋友可以看看它的具体原理。接下来主要围绕DiskLruCache的写入，查找以及删除缓存来介绍。</p>
<h4 data-id="heading-14">5.2 DiskLruCache的edit()方法分析：</h4>
<p>DiskLruCache缓存的写入是通过edit()方法来完成的，源码如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> Editor <span class="hljs-title function_">edit</span><span class="hljs-params">(String key, <span class="hljs-type">long</span> expectedSequenceNumber)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">// 检查DiskLruCache是否已关闭，关闭则抛出异常</span>
    checkNotClosed();
    <span class="hljs-comment">// 验证键的有效性（通常检查是否包含空格等非法字符）</span>
    validateKey(key);
    <span class="hljs-comment">// 从之前的缓存中读取对应的entry</span>
    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> lruEntries.get(key);
    <span class="hljs-comment">// 无法修改</span>
    <span class="hljs-keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == <span class="hljs-literal">null</span>
        || entry.sequenceNumber != expectedSequenceNumber)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// Snapshot is stale.</span>
    }
    <span class="hljs-comment">// key所对应的缓存不存在，创建新的键值对并存入LinkedHashMap中</span>
    <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span>) {
      entry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key);
      lruEntries.put(key, entry);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.currentEditor != <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// 如果当前缓存正在被其他Editor编辑，拒绝并发编辑</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// Another edit is in progress.</span>
    }
	
    <span class="hljs-comment">// 创建新的Editor实例，与缓存相关联</span>
    <span class="hljs-type">Editor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Editor</span>(entry);
    entry.currentEditor = editor; <span class="hljs-comment">// 当前缓存为编辑状态</span>

    <span class="hljs-comment">// Flush the journal before creating files to prevent file leaks.</span>
    <span class="hljs-comment">// 写入DIRTY记录表示开始编辑操作</span>
    journalWriter.write(DIRTY + <span class="hljs-string">' '</span> + key + <span class="hljs-string">'\n'</span>);
    journalWriter.flush(); <span class="hljs-comment">// 强制刷新到磁盘，确保日志持久化</span>
    <span class="hljs-comment">// 返回Editor实例以供后续编辑使用</span>
    <span class="hljs-keyword">return</span> editor;
  }
</code></pre>
<p>至于DIRTY，DIRTY是DiskLruCache的一种状态标记。向日志文件中写入<strong>DIRTY</strong> ，则表示当前缓存条目正在被编辑但尚未完成。</p>
<p>一般格式为DIRTY + 空格+key，比如：</p>
<pre><code class="hljs language-bash" lang="bash">DIRTY key123  <span class="hljs-comment"># 表示 key123 这个条目正在被修改</span>
</code></pre>
<p>一般来说DIRTY 记录与 CLEAN/REMOVE 记录成对出现，构成一个完整的操作单元：</p>
<p><strong>正常完成</strong>：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">DIRTY key123    ← 表示缓存条目开始编辑
...（文件操作）...
<span class="hljs-built_in">CLEAN</span> key123    ← 表示缓存条目编辑成功完成
</code></pre>
<p><strong>异常终止</strong>：</p>
<pre><code class="hljs language-markdown" lang="markdown">DIRTY key123    ← 表示缓存条目开始编辑
...（程序崩溃）...
<span class="hljs-code">                ← 缺少 CLEAN，表示操作未完成
</span></code></pre>
<p>而lruEntries则是一个LinkedHashMap对象，表示实际的缓存条目表，负责实际的缓存存储。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/225986e2b63c4004a945ec8f93ed2afd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5byl5be3:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763371091&amp;x-signature=%2BDYQfA3sNPymrns1ChjwKnHppWg%3D" alt="屏幕截图 2025-11-10 161856.png" loading="lazy"/></p>
<p>edit()方法主要就是构建了一个Editor对象，它主要干了两件事：</p>
<ol>
<li>从集合中找到对应的实例（如果没有创建一个放到集合中），然后创建一个editor，将editor和entry关联起来。</li>
<li>向journal中写入一行操作数据（DITTY 空格 和key拼接的文字），表示这个key当前正处于编辑状态。</li>
</ol>
<p>在前面使用DiskLruCache的例子中，我们调用了Editor的newOutputStream()方法创建了一个OutputStream来写入缓存文件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * 获取缓存条目指定索引值文件的输入流
 * 用于读取缓存数据，通常在Snapshot对象中使用
 * 
 * <span class="hljs-doctag">@param</span> index 值文件的索引（从0开始，小于valueCount）
 * <span class="hljs-doctag">@return</span> 文件的输入流，如果文件不存在返回null
 * <span class="hljs-doctag">@throws</span> IOException 如果发生I/O错误
 * <span class="hljs-doctag">@throws</span> IllegalStateException 如果Snapshot已关闭或无效
 */</span>
<span class="hljs-keyword">public</span> InputStream <span class="hljs-title function_">newInputStream</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-keyword">throws</span> IOException {
      <span class="hljs-keyword">synchronized</span> (DiskLruCache.<span class="hljs-built_in">this</span>) {
        <span class="hljs-comment">// 确保当前Editor仍然有效</span>
        <span class="hljs-keyword">if</span> (entry.currentEditor != <span class="hljs-built_in">this</span>) {
          <span class="hljs-comment">// 两种情况：</span>
          <span class="hljs-comment">// 1. Snapshot已被关闭</span>
          <span class="hljs-comment">// 2. 或者条目已被新的Editor占用</span>
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();
        }
          
        <span class="hljs-comment">// 检查条目是否可读：entry.readable为true表示条目处于CLEAN状态</span>
        <span class="hljs-comment">// 如果为false，说明条目可能正在编辑或已被移除</span>
        <span class="hljs-keyword">if</span> (!entry.readable) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">try</span> {
          <span class="hljs-comment">// entry.getCleanFile(index) 获取指定索引的缓存数据文件</span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(entry.getCleanFile(index));
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
      }
    }
</code></pre>
<p>这个方法的形参index就是我们开始在open()方法里传入的valueCount，这个valueCount表示了一个key对应几个value,也就是说一个key对应几个缓存文件。那么现在传入的这个index就表示 要缓存的文件时对应的第几个value。</p>
<p>有了输出流，我们在接着调用Editor的commit()方法就可以完成缓存文件的写入了：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
      <span class="hljs-keyword">if</span> (hasErrors) {
      	<span class="hljs-comment">// 如果写入缓存出错就把集合中的缓存条目移除掉</span>
        completeEdit(<span class="hljs-built_in">this</span>, <span class="hljs-literal">false</span>);
        remove(entry.key); <span class="hljs-comment">// The previous entry is stale.</span>
      } <span class="hljs-keyword">else</span> {
      	<span class="hljs-comment">// 编辑成功则提交更改</span>
        completeEdit(<span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);
      }
      <span class="hljs-comment">// 标记本次编辑已提交，防止重复提交</span>
      committed = <span class="hljs-literal">true</span>;
    }
</code></pre>
<p>通过completeEdit方法来完成最终的缓存写入，completeEdit方法负责处理编辑的提交或中止。当编辑成功时，它将编辑过程中使用的临时工作文件转换为最终的缓存数据文件，更新缓存大小统计，并在日志中写入 CLEAN 记录；当编辑失败时，则删除临时文件进行操作撤销。
至此，缓存的插入就完成了。</p>
<h4 data-id="heading-15">3.3 读取缓存</h4>
<p>读取缓存是由DiskLruCache的get()方法来完成的，如下所示：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskLruCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> {
    
      <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Snapshot <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException {
        checkNotClosed();
        validateKey(key);
        <span class="hljs-comment">// 获取key对应的entry</span>
        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> lruEntries.get(key);
        <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    
        <span class="hljs-comment">// 如果entry不可读，说明可能在编辑，则返回空。</span>
        <span class="hljs-keyword">if</span> (!entry.readable) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    
        <span class="hljs-comment">// 打开所有缓存文件的输入流，等待被读取。</span>
        InputStream[] ins = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStream</span>[valueCount];
        <span class="hljs-keyword">try</span> {
          <span class="hljs-comment">// 为每个值文件创建输入流</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; valueCount; i++) {
            <span class="hljs-comment">// 获取正式缓存文件（非临时文件）的输入流</span>
            ins[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(entry.getCleanFile(i));
          }
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
          <span class="hljs-comment">// A file must have been deleted manually!</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; valueCount; i++) {
            <span class="hljs-keyword">if</span> (ins[i] != <span class="hljs-literal">null</span>) {
              Util.closeQuietly(ins[i]);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">break</span>;
            }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    	<span class="hljs-comment">// 增加冗余操作计数</span>
        redundantOpCount++;
        <span class="hljs-comment">// 向journal写入一行READ开头的记录，表示执行了一次读取操作</span>
        journalWriter.append(READ + <span class="hljs-string">' '</span> + key + <span class="hljs-string">'\n'</span>);
        
         
        <span class="hljs-comment">// 如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件</span>
        <span class="hljs-keyword">if</span> (journalRebuildRequired()) {
          executorService.submit(cleanupCallable);
        }
        
        <span class="hljs-comment">// 返回一个缓存文件快照，包含缓存文件大小，输入流等信息。</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snapshot</span>(key, entry.sequenceNumber, ins, entry.lengths);
      }
}
</code></pre>
<p>读取操作主要完成了以下几件事情：</p>
<ol>
<li>获取对应的entry。</li>
<li>打开所有缓存文件的输入流，等待被读取。</li>
<li>向journal写入一行READ开头的记录，表示执行了一次读取操作。</li>
<li>如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件。</li>
<li>返回一个缓存文件快照，包含缓存文件大小，输入流等信息。</li>
</ol>
<p>该方法最终返回一个缓存文件快照，包含缓存文件大小，输入流等信息。利用这个快照我们就可以读取缓存文件了。</p>
<h4 data-id="heading-16">3.4 删除缓存</h4>
<p>删除缓存是由DiskLruCache的remove()方法来完成的，如下所示：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskLruCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> {
    
      <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException {
        checkNotClosed();
        validateKey(key);
        <span class="hljs-comment">// 获取对应的entry</span>
        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> lruEntries.get(key);
        <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span> || entry.currentEditor != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    
        <span class="hljs-comment">// 删除对应的缓存文件，并将缓存大小置为0.</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; valueCount; i++) {
          <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> entry.getCleanFile(i);
          <span class="hljs-keyword">if</span> (file.exists() &amp;&amp; !file.delete()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">"failed to delete "</span> + file);
          }
          size -= entry.lengths[i];
          entry.lengths[i] = <span class="hljs-number">0</span>;
        }
    
        redundantOpCount++;
        <span class="hljs-comment">// 向journal文件添加一行REMOVE开头的记录，表示执行了一次删除操作。</span>
        journalWriter.append(REMOVE + <span class="hljs-string">' '</span> + key + <span class="hljs-string">'\n'</span>);
        lruEntries.remove(key);
    
    
        <span class="hljs-comment">// 如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件</span>
        <span class="hljs-keyword">if</span> (journalRebuildRequired()) {
          executorService.submit(cleanupCallable);
        }
    
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }   
}
</code></pre>
<p>删除操作主要做了以下几件事情：</p>
<ol>
<li>获取对应的entry。</li>
<li>删除对应的缓存文件，并将缓存大小置为0.</li>
<li>向journal文件添加一行REMOVE开头的记录，表示执行了一次删除操作。</li>
<li>如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>