<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[这两个开源项目在世界互联网大会乌镇峰会获奖]]></title>    <link>https://juejin.cn/post/7573225720698683444</link>    <guid>https://juejin.cn/post/7573225720698683444</guid>    <pubDate>2025-11-17T09:31:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720698683444" data-draft-id="7573225720698601524" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="这两个开源项目在世界互联网大会乌镇峰会获奖"/> <meta itemprop="keywords" content="开源"/> <meta itemprop="datePublished" content="2025-11-17T09:31:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            这两个开源项目在世界互联网大会乌镇峰会获奖
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:31:25.000Z" title="Mon Nov 17 2025 09:31:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>2025 <strong>“直通乌镇”全球互联网大赛</strong>是世界互联网大会乌镇峰会重要活动之一，自 2019 年以来已连续举办 7 届。本届大赛以“发现未来新势力 共筑数字新生态”为主题，设置人工智能、智联出行、数智医疗、智能制造、智能终端、开源项目（分为开源模型应用赛和开源竞技挑战赛）六大赛道。</p>
<p>自 6 月启动报名以来，共吸引来自全球 29 个国家的 1082 个项目报名参赛，其中国内项目 864 个、海外项目 218 个。经过激烈角逐，共有 71 个项目入围决赛，包含海外项目 11 个。在最终的决赛中：</p>
<p><strong>Spring AI Alibaba</strong> 和 <strong>Higress</strong> 分别获得了开源先锋社区、开源优秀社区的称号，两位社区贡献者<strong>张圣航</strong>（GitHubID: shenghang）、<strong>刑国富</strong>（GitHubID: erasernoob）获得最具价值贡献者奖。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a0d99cdda84403b940981542a4684e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976685&amp;x-signature=k42zGPMQOzF%2Bo9%2Fd655anmQZiHw%3D" alt="4ba2f7045ec7bcd4b27a2f459fce62dc.jpg" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ae65ec06d44c4bed9d094c5456040924~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976685&amp;x-signature=9NSelnuYW9Pt8BRpr4sf2DWmdB8%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/56ace434492c469d9173fe99b3ec060a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976685&amp;x-signature=9SqNB%2BTDmTqggZl3AuPTT3OkimU%3D" alt="图片" loading="lazy"/></p>
<p>感谢所有社区贡献者和开发者用户们的信任。</p>
<h3 data-id="heading-0">关于 Spring AI Alibaba</h3>
<p>Spring AI Alibaba 开源项目基于 Spring AI 构建，是阿里云通义系列模型及服务在 Java AI 应用开发领域的最佳实践，提供高层次的 AI API 抽象与云原生基础设施集成方案，帮助开发者快速构建 AI 应用。目前，Spring AI Alibaba 底层正升级到 AgentScope，未来作为 AgentScope 生态的一环，定位是做好 Spring 和 AgentScope 的连接。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3605fb5990214f5eb48c38b4d72e3ac4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976685&amp;x-signature=nNGIkNZcrDVpcbghbRRuCXlWL6I%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-1">关于 Higress</h3>
<p>Higress 是一款开源的 API 网关，内核基于 Istio 和 Envoy，可以用 Go/Rust/JS 等编写 Wasm 插件，提供对 K8s 集群的 Ingress 入口网关, 并且兼容了大量 K8s Nginx Ingress 的注解，可以从 K8s Nginx Ingress 快速平滑迁移到 Higress。此外，作为一款 AI 网关，提供 LLM API 和 MCP API 的统一管理。已服务于通义千问、阿里云百炼、携程、蚂蚁数科、钉钉、优酷、快手、Paypal、汤臣倍健、UU跑腿、Sealos、国泰产险等互联网、金融、IT 服务等多行业的企业客户。</p>
<p>率先在国内开源 AI 网关的通用能力，包括</p>
<ul>
<li>面向大模型：统一代理各主流大模型和自建大模型服务，提供 OpenAI 兼容的访问方式，并提供二次 API KEY 签发、限流、安全防护、观测等治理能力 。</li>
<li>面向 Agent：用户可便捷、安全地将各类智能体能力无缝集成至业务系统，实现智能对话、流程自动化等创新功能，助力企业高效构建智能化应用生态。</li>
<li>面向 MCP：支持 API-to-MCP 快速转化，并提供 MCP Server 代理、安全认证，以及统一观测、限流等治理能力。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端支持的主要数据类型及其使用方式]]></title>    <link>https://juejin.cn/post/7573519273029648430</link>    <guid>https://juejin.cn/post/7573519273029648430</guid>    <pubDate>2025-11-17T09:39:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573519273029648430" data-draft-id="7573310642960269350" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端支持的主要数据类型及其使用方式"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-17T09:39:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户013608756688"/> <meta itemprop="url" content="https://juejin.cn/user/1704711328379395"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端支持的主要数据类型及其使用方式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1704711328379395/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户013608756688
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:39:11.000Z" title="Mon Nov 17 2025 09:39:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前端发送HTTP请求可以发送多种数据，不限于二进制。下面是支持的主要类型</h3>
<h6 data-id="heading-1">1.文本类</h6>
<ul>
<li>application/json
API交互、提交结构化数据</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/user'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> })
});
</code></pre>
<ul>
<li>text/plain
纯文本内容（如日志、简单消息）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/log'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span> },
  <span class="hljs-attr">body</span>: <span class="hljs-string">'User clicked button at 10:00'</span>
});
</code></pre>
<ul>
<li>application/x-www-form-urlencoded
传统表单提交（类似form默认行为）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>();
params.<span class="hljs-title function_">append</span>(<span class="hljs-string">'name'</span>, <span class="hljs-string">'Alice'</span>);
params.<span class="hljs-title function_">append</span>(<span class="hljs-string">'age'</span>, <span class="hljs-string">'25'</span>);

<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/submit'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded'</span> },
  <span class="hljs-attr">body</span>: params
});
</code></pre>
<h6 data-id="heading-2">2.表单与文件混合Multipart</h6>
<p>multipart/form-data</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();
formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'username'</span>, <span class="hljs-string">'Alice'</span>);
formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'avatar'</span>, fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 二进制文件</span>

<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/upload'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: formData }); <span class="hljs-comment">// 不要手动设 Content-Type！</span>
</code></pre>
<h6 data-id="heading-3">3.二进制类Binary</h6>
<ul>
<li>原始二进制流（application/octet-stream）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">72</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>]); <span class="hljs-comment">// "Hello"</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/raw-binary'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/octet-stream'</span> },
  <span class="hljs-attr">body</span>: buffer
});
</code></pre>
<ul>
<li>动态生成的二进制数据（如 Canvas 导出图片）</li>
</ul>
<pre><code class="hljs language-js" lang="js">canvas.<span class="hljs-title function_">toBlob</span>(<span class="hljs-function"><span class="hljs-params">blob</span> =&gt;</span> {
  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/upload-image'</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
    <span class="hljs-attr">body</span>: blob <span class="hljs-comment">// 自动识别为二进制</span>
  });
}, <span class="hljs-string">'image/png'</span>);
</code></pre>
<h6 data-id="heading-4">4. 其他特殊类型</h6>
<p>application/xml 或 text/xml</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">xml</span> = `&lt;user&gt;&lt;name&gt;Alice&lt;/name&gt;&lt;/user&gt;`;
<span class="hljs-title function_ invoke__">fetch</span>(<span class="hljs-string">'/legacy-api'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/xml'</span> },
  <span class="hljs-attr">body</span>: xml
});
</code></pre>
<h6 data-id="heading-5">将二进制数据（如 Blob 或 File）转换为一个临时的、可访问的 URL</h6>
<p>核心API：URL.createObjectURL()
接收一个Blob或File对象
返回一个形如blob:<a href="https://link.juejin.cn?target=https%3A%2F%2Fxxx.com%2Fuuid" target="_blank" title="https://xxx.com/uuid" ref="nofollow noopener noreferrer">xxx.com/uuid</a> 的临时URL
该 URL 在当前文档（页面）生命周期内有效
替代方式：</p>























<table><thead><tr><th>方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>URL.createObjectURL()</td><td>高效、支持任意二进制、可重复使用</td><td>需手动释放内存</td><td>图片/视频预览、大文件下载</td></tr><tr><td>FileReader.readAsDataURL()</td><td>返回 base64 字符串，无需释放</td><td>内存占用高（base64 比原数据大 33%）、不适合大文件</td><td>小图标、简单文本预览</td></tr></tbody></table>
<p><strong>务必在适当时机调用 <code>URL.revokeObjectURL()</code> <strong>如果不释放，可能导致</strong>内存泄漏</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用Bootstrap一天搞定响应式网站：前端小白的救命稻草]]></title>    <link>https://juejin.cn/post/7573486671296970794</link>    <guid>https://juejin.cn/post/7573486671296970794</guid>    <pubDate>2025-11-17T09:40:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573486671296970794" data-draft-id="7573300346263240758" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用Bootstrap一天搞定响应式网站：前端小白的救命稻草"/> <meta itemprop="keywords" content="前端,HTML"/> <meta itemprop="datePublished" content="2025-11-17T09:40:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="BBB努力学习程序设计"/> <meta itemprop="url" content="https://juejin.cn/user/3097787706900985"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用Bootstrap一天搞定响应式网站：前端小白的救命稻草
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3097787706900985/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    BBB努力学习程序设计
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:40:02.000Z" title="Mon Nov 17 2025 09:40:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;color:#282d36}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px;color:#2f845e}.markdown-body h2{font-size:22px;display:inline-block;font-weight:700;background:#2f845e;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(47,132,194,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 32px);border-bottom:3px solid #2f845e}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%;box-shadow:6px 6px 6px #888}.markdown-body hr{border:none;border-top:1px solid rgba(66,185,131,.15);margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#f6ffed;color:#52c41a;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:16px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#262626;border:1px solid #2f845e;border-top:8px solid #2f845e;background:linear-gradient(180deg,rgba(66,185,131,.1),transparent)!important}.markdown-body pre&gt;code.hljs[lang]:before{top:8px!important;color:#2f845e!important}.markdown-body pre&gt;code.language-awesome_error{border:1px solid #ff4d4f!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#ff4d4f!important;background:#fff2f0!important}.markdown-body pre&gt;code.language-awesome_error:before{content:"!"!important;position:absolute!important;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#ff4d4f!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body pre&gt;code.language-awesome_warn{border:1px solid #ffc46f!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#ffc46f!important;background:#fffbe6!important}.markdown-body pre&gt;code.language-awesome_warn:before{content:"☂"!important;position:absolute;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#ffc46f!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body pre&gt;code.language-awesome_success{border:1px solid #52c41a!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#52c41a!important;background:#f6ffed!important}.markdown-body pre&gt;code.language-awesome_success:before{content:"✓"!important;position:absolute!important;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#52c41a!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body pre&gt;code.language-awesome_info{border:1px solid #1890ff!important;border-left-width:8px;font-size:14px;font-weight:700;padding:15px 12px 15px 16px;margin:0;word-break:normal;white-space:break-spaces;display:block;overflow-x:auto;color:#1890ff!important;background:#e6f7ff!important}.markdown-body pre&gt;code.language-awesome_info:before{content:"i"!important;position:absolute!important;top:50%!important;left:-9px!important;transform:translateY(-14px)!important;background:#1890ff!important;color:#fff!important;border:2px solid #fff!important;display:flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:100%;font-weight:700;font-family:Dosis,Source Sans Pro,Helvetica Neue,Arial,sans-serif;font-size:16px}.markdown-body strong{background-color:inherit;color:#2f845e}.markdown-body em{background-color:inherit;color:#949415}.markdown-body a{text-decoration:none;color:#2f8e54;border-bottom:1px solid #3f9e64}.markdown-body a:active,.markdown-body a:hover{color:#3f9e64}.markdown-body a[class^=footnote]{margin-left:4px}.markdown-body a:before{content:"➤ "}.markdown-body table{font-size:12px;width:100%;max-width:100%;overflow:auto;border:2px solid #2f8e54}.markdown-body thead{background:#2f8e54;color:#fff;text-align:left;font-weight:700}.markdown-body tr:nth-child(2n){background-color:rgba(153,255,188,.1)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:22px}.markdown-body td{min-width:120px}.markdown-body blockquote{padding:1px 22px;margin:22px 0;border-left:6px solid #2f845e;background-color:rgba(66,185,131,.1);border-radius:2px}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#2f845e}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px;color:#282d36}.markdown-body del{color:#2f845e}.markdown-body input[type=checkbox]:checked:before{content:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA/klEQVQ4T72TMU7DQBBF318XdFR06egQEnAXRINEGlqgowoIR8AF4AZOZ4JEGq5AC5EixBU4A55BNrEVHAcSBTHlaubt37/zxZKlcn7n6mDPXJvz8IJ89HzWu8t7C8D2dfsY52ae4apHnLx0ktsCsHXZjiUuFgG40x2eJ/H/AhztB+zDUTpLwWj8jGkzxSHiHaMPrDQC8sMoilKzLAUqiKQjmb+ZuAdW80tmelCHODoNgSfP7AFprTTaRTzsJN1GEyuIZ7uW6TEEHwCtyV/6EVBKJHhfzgC0Xv/iXwEFBF4FG0378bd7sPQq5xK/hSnk6sdlX3mZrKkwLZKBeu8n9XuWEUE7X+YAAAAASUVORK5CYII=);position:relative;top:-1px;left:-1px}.markdown-body .math .katex{font-family:Menlo,Monaco,Consolas,Courier New,monospace;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#f6ffed;color:#52c41a;font-size:.87em;padding:.065em .4em}@media (max-width:720px){.markdown-body h1{font-size:22px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>你是否挣扎在CSS的兼容性地狱？面对不同屏幕尺寸是否感到绝望？别担心，Bootstrap就是为你而来的救星！
还记得第一次做响应式网站的痛苦吗？媒体查询写得头晕眼花，在不同设备上测试到崩溃，布局总是不听话。更可怕的是，还要处理各种浏览器的怪异行为。现在，让我带你走进Bootstrap的世界，看看它如何让你在一天内做出漂亮的响应式网站</p>
<h2 data-id="heading-0">Bootstrap框架</h2>
<p>简单来说，Bootstrap是一个强大的、<strong>移动优先</strong>的CSS/JavaScript框架。它由Twitter的设计师和开发者创建，提供了一系列预定义的CSS样式类和JavaScript插件。
你可以把它理解为一个<strong>巨大的“UI零件库”</strong> ：</p>
<ul>
<li><strong>CSS零件</strong>：提供了现成的按钮、表格、表单、导航栏等组件的样式。</li>
<li><strong>布局零件</strong>：提供了一套成熟的网格系统，让你能轻松创建响应式布局。</li>
<li><strong>JS零件</strong>：提供了一些常见的交互组件，如模态框、轮播图、下拉菜单等。
使用Bootstrap，你无需从零开始写CSS，只需要在HTML元素上添加对应的类名，就能快速应用一套成熟、美观的样式</li>
</ul>
<h2 data-id="heading-1">核心概念与语法详解</h2>
<h3 data-id="heading-2">1. 引入Bootstrap</h3>
<p>使用Bootstrap的第一步是将其CSS和JS文件引入到你的HTML项目中。最简单的方式是使用CDN（内容分发网络）</p>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的第一个Bootstrap页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 引入 Bootstrap CSS --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, Bootstrap!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 引入 Bootstrap JS (包含 Popper) --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 data-id="heading-3">2. 布局的灵魂：网格系统</h3>
<p>Bootstrap的网格系统是其最核心的功能。它使用容器、行和列来布局和对齐内容，并且是<strong>响应式</strong>的，能自动适应不同大小的屏幕</p>
<h4 data-id="heading-4">核心概念：</h4>
<ul>
<li><code>.container</code>： 固定宽度的容器，用于包裹整个页面内容。<code>.container-fluid</code> 是100%宽度的容器。</li>
<li><code>.row</code>： 行，用于包裹一组列</li>
<li><code>.col-*</code>： 列，是内容的直接容器
Bootstrap的网格将一行分为12等份。通过指定 <code>.col-</code> 的后缀来决定一列占多少份</li>
</ul>
<h4 data-id="heading-5">代码示例：一个三栏布局</h4>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container my-5"</span>&gt;</span> <span class="hljs-comment">&lt;!-- my-5 是上下边距的工具类 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 在中等屏幕及以上，每列占4份（12/4=3，即三栏） --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"p-3 border bg-light"</span>&gt;</span> <span class="hljs-comment">&lt;!-- 内边距、边框和背景色工具类 --&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>左侧栏<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>一些内容...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"p-3 border bg-light"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>主内容区<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>更多内容...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"p-3 border bg-light"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>右侧栏<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>其他内容...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h3 data-id="heading-6">3. 丰富的组件：按钮</h3>
<p>Bootstrap提供了多种样式和状态的按钮，只需一个类名即可搞定</p>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-comment">&lt;!-- 基础按钮 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span>&gt;</span>主要按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-secondary"</span>&gt;</span>次要按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-success"</span>&gt;</span>成功按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-danger"</span>&gt;</span>危险按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-warning"</span>&gt;</span>警告按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-info"</span>&gt;</span>信息按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-light"</span>&gt;</span>浅色按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-dark"</span>&gt;</span>深色按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 描边按钮 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-outline-primary"</span>&gt;</span>描边主要按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 不同大小的按钮 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary btn-lg"</span>&gt;</span>大按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary btn-sm"</span>&gt;</span>小按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
<h3 data-id="heading-7">4. 常用组件：导航栏</h3>
<p>导航栏是每个网站几乎必备的组件，Bootstrap让它变得非常简单</p>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar navbar-expand-lg navbar-dark bg-dark"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container-fluid"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-brand"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>我的网站<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-toggler"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">data-bs-toggle</span>=<span class="hljs-string">"collapse"</span> <span class="hljs-attr">data-bs-target</span>=<span class="hljs-string">"#navbarNav"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-toggler-icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"collapse navbar-collapse"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"navbarNav"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-nav"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-item"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-link active"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-item"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-link"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-item"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-link"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>联系方式<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>
</code></pre>
<h3 data-id="heading-8">5. 交互组件：模态框</h3>
<p>模态框（Modal）是一个弹窗组件，无需写JavaScript即可激活</p>
<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-comment">&lt;!-- 触发按钮 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span> <span class="hljs-attr">data-bs-toggle</span>=<span class="hljs-string">"modal"</span> <span class="hljs-attr">data-bs-target</span>=<span class="hljs-string">"#exampleModal"</span>&gt;</span>
  启动演示模态框
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 模态框结构 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal fade"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exampleModal"</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">"-1"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal-dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal-content"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal-header"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal-title"</span>&gt;</span>模态框标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn-close"</span> <span class="hljs-attr">data-bs-dismiss</span>=<span class="hljs-string">"modal"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal-body"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>模态框正文内容在这里。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal-footer"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-secondary"</span> <span class="hljs-attr">data-bs-dismiss</span>=<span class="hljs-string">"modal"</span>&gt;</span>关闭<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span>&gt;</span>保存更改<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h2 data-id="heading-9">总结</h2>
<ul>
<li>✅  <strong>移动优先原则</strong>：从小屏幕开始设计，再用断点类适配大屏</li>
<li>✅ <strong>JavaScript依赖</strong>：交互功能必须引入Bootstrap的JS文件</li>
<li>✅  <strong>避免样式冲突</strong>：不要同时使用多个UI框架，会冲突</li>
<li>✅  <strong>自定义样式</strong>：自定义CSS要在Bootstrap之后引入</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SCALE | 2025 年 10 月《大模型 SQL 能力排行榜》发布]]></title>    <link>https://juejin.cn/post/7573241978902937615</link>    <guid>https://juejin.cn/post/7573241978902937615</guid>    <pubDate>2025-11-17T09:19:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573241978902937615" data-draft-id="7573241978902904847" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SCALE | 2025 年 10 月《大模型 SQL 能力排行榜》发布"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-17T09:19:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="爱可生开源社区"/> <meta itemprop="url" content="https://juejin.cn/user/1480387593251847"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SCALE | 2025 年 10 月《大模型 SQL 能力排行榜》发布
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1480387593251847/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    爱可生开源社区
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:19:30.000Z" title="Mon Nov 17 2025 09:19:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a8814d8c2444d74873065584740ab7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=yMaRzGXrN4wkF0sglROulPfbOEM%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">一、本月导览与核心看点</h2>
<p>2025 年 10 月，<a href="https://link.juejin.cn?target=https%3A%2F%2Fsql-llm-leaderboard.com%2Franking%2F2025-10" title="https://sql-llm-leaderboard.com/ranking/2025-10" target="_blank" ref="nofollow noopener noreferrer">SCALE</a> 评测基准持续追踪 AI 在专业 SQL 领域的最新进展。本月，榜单迎来了蚂蚁百灵大模型团队发布的两大 万亿级 参数的模型：<a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2FinclusionAI%2FLing-1T" target="_blank" title="https://huggingface.co/inclusionAI/Ling-1T" ref="nofollow noopener noreferrer">Ling-1T</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2FinclusionAI%2FRing-1T" target="_blank" title="https://huggingface.co/inclusionAI/Ring-1T" ref="nofollow noopener noreferrer">Ring-1T</a>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/66d3a7c5c08548e0a40b8987c1c2ced0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=ZTna70McYAWcGLWKD3JA%2BuI6%2FIo%3D" alt="" loading="lazy"/></p>
<ul>
<li><strong>Ling-1T</strong> ：蚂蚁百灵大模型 <strong>Ling 2.0</strong> 系列的第一款旗舰模型。</li>
<li><strong>Ring-1T</strong> ：一款基于 <strong>Ling 2.0</strong> 架构的思考模型，也是全球首个开源万亿参数思考模型。</li>
</ul>
<p>本期核心看点：</p>
<ul>
<li><strong>新增模型评测</strong> ：首次引入蚂蚁 <em>Ling-1T</em> 与 <em>Ring-1T</em> 模型。评测数据显示，两款模型呈现出清晰的能力分化：
<ul>
<li>Ling-1T 在「<strong>国产数据库</strong>」转换场景中表现突出，获得满分！</li>
<li>Ring-1T 在「<strong>SQL 优化</strong> 」和「<strong>SQL 理解</strong> 」维度展现了 <strong>更为均衡和稳健的综合能力</strong>，总分均进入榜单上游。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-1">二、评测基准说明</h2>
<p>为保证评测结果的长期可比性和权威性，本月我们的核心评测基准与算法保持不变，继续沿用 <strong>SCALE</strong> 自创立之初便确立的三维评测体系，确保所有模型与工具在统一、标准的测试环境下进行评估，以提供公正、可复现的评测结果。</p>
<ul>
<li><strong>SQL 优化</strong>：考察模型提升查询效率与性能的意识和能力。</li>
<li><strong>方言转换</strong>：考察模型在主流数据库之间进行语法迁移的准确性。</li>
<li><strong>SQL 理解</strong>：考察模型是否能精准解析复杂的查询逻辑与用户意图的能力。</li>
</ul>
<p>本月所有新增模型均在此标准体系下进行评估。</p>
<h2 data-id="heading-2">三、焦点分析</h2>
<h3 data-id="heading-3">专题一：Ling-1T 首次评测</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3efaa8ebe0084138926236e0402bc536~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=qKIgmjllhYe1ufvflmGg9htPP3k%3D" alt="发布日期：2025-10-09" loading="lazy"/></p>
<p><em>Ling-1T</em> 作为 <strong>Ling 2.0</strong> 系列的首款旗舰非思考模型，在本月首次参评。其各维度总分分别为：</p>
<ul>
<li><strong>SQL 优化</strong>：62.5</li>
<li><strong>方言转换</strong>：59.2</li>
<li><strong>SQL 理解</strong>：59.4</li>
</ul>
<p>评测结果显示，该模型能力特点鲜明，在特定场景表现优异，但在复杂任务处理上仍存在明显短板。</p>
<h4 data-id="heading-4">SQL 优化能力：62.5</h4>
<p><em>Ling-1T</em> 在 <strong>SQL 优化</strong> 维度获得 62.5 分。根据细分指标数据显示，该模型在「<strong>逻辑等价</strong>」方面表现出色，以 84.2 分位列该项第 5 名。</p>
<p>然而，其在「<strong>优化深度</strong> 」上表现不足，得分仅为 51.1 分（排名第 17），同时「<strong>语法错误检测</strong> 」得分也偏低（84.2分）（排名第 18），分析测评报告可见，模型将符合 MySQL 宽松模式的 <code>GROUP BY</code> 查询误判为有语法错误；对 <code>UNION</code> 查询中 <code>ORDER BY/LIMIT</code> 的语法规则理解不准确。</p>
<p><strong>核心缺陷</strong> ：模型缺乏对数据库特定模式（如 MySQL 的 <code>ONLY_FULL_GROUP_BY</code>）和 <strong>SQL 标准/方言差异</strong> 的上下文感知能力，过度依赖教条式语法规则，无法根据数据库配置灵活判断语法正确性，导致在边界情况下的误判。这一系列分数表明，模型具备保障逻辑一致性的能力，但在应用深度优化策略和保障语法规范性方面仍有较大提升空间。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb683584662e4c9599ae35e84d96795e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=xThp7ZWwdEgjhgEZ7aKYlTJJSTc%3D" alt="Ling-1T：SQL 优化维度评分" loading="lazy"/></p>
<h4 data-id="heading-5">方言转换能力：59.2</h4>
<p>此维度得分呈现出显著的能力分化（总分 59.2，排名第 17）。<strong>其最大亮点在于对国内数据库生态的适配性</strong> ，其「<strong>国产数据库</strong> 」转换子项获得 100 分满分（与 <a href="https://link.juejin.cn?target=https%3A%2F%2Fsqlshift.cn%2F" target="_blank" title="https://sqlshift.cn/" ref="nofollow noopener noreferrer">SQLShift</a> 并列），展现了其在该特定场景下的卓越能力。</p>
<p>然而，模型在处理复杂迁移任务时表现挣扎。「<strong>大 SQL 转换</strong> 」得分仅为 12.9分（排名第 20）。测评报告显示，在复杂 SQL 方言转换中，模型误用不兼容语法（如保留 <code>SET NOCOUNT ON</code>、混用 <code>DBMS_OUTPUT</code> 等），且对控制流、游标、异常处理等结构的语义理解不足，导致转换后语法不兼容或逻辑不等价，这体现出模型对复杂结构化代码的全局理解能力，以及对多方言语义差异的精确把握能力还有待提升。同时，其「<strong>逻辑等价</strong> 」（61.3分）和「<strong>语法错误检测</strong>」（69.0分）得分中等，表明其在处理非国产数据库的复杂转换时，难以保证代码的规范性。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/963aca4110dc46abb4fb6e2e19838c17~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=RatasSNS4bnOqOT9CjOTPLSXP3o%3D" alt="Ling-1T：方言转换维度评分" loading="lazy"/></p>
<h4 data-id="heading-6">SQL 理解能力：59.4</h4>
<p>该分数表明 <em>Ling-1T</em> 具备基础的 SQL 解析能力。数据细分显示，其在「<strong>语法错误检测</strong> 」上表现突出，以 87.1 分的成绩与 <em>Claude 3.5 Sonnet</em> 并列该指标测评的第 1 名。</p>
<p>然而，其在「<strong>执行准确性</strong> 」方面表现不佳，得分仅为 52.9 分（排名第 19），分析测评报告可见，模型在日期条件测评中易出错，如 <code>due_date &lt; '2025-06-07'</code> 的查询中返回了 <code>due_date='2025-06-10'</code> 的记录，明显违反了条件。这类错误反映了模型在执行 SQL 查询时，对日期比较的语义理解与严谨性不足。这是其主要短板之一。</p>
<p>此外，其「<strong>执行计划检测</strong> 」得分为 57.1 分，模型在执行计划预测时，对 DDL 中未定义索引的字段错误预测了 <code>key</code> 和 <code>possible_keys</code>。例如查询 <code>WHERE fruit_name = 'Banana'</code> 时，模型预测 <code>key: "fruit_name"</code> 和 <code>possible_keys: "fruit_name"</code>，但 DDL 中 <code>fruit_name</code> 字段没有索引，反映出模型过于基于查询模式推测出现误判，在约束验证能力和结构化解析与推理上仍有较大提升空间。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6efcfdb4fd7a44639614c794efb48388~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=9yy1njgeK90rk8y2lu7z3UgRDMI%3D" alt="Ling-1T：SQL 理解维度评分" loading="lazy"/></p>
<h3 data-id="heading-7">专题二：Ring-1T 首次评测</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9567423aeb2946d3bd837a1bbd29d291~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=RigLZFFnj%2Bkg%2FsgJHGStu%2BjaL0g%3D" alt="发布日期：2025-10-14" loading="lazy"/></p>
<p><em>Ring-1T</em> 作为基于 <strong>Ling 2.0</strong> 架构的万亿级参数思考模型，展现了比 <em>Ling-1T</em> 更强的综合实力。其各维度总分分别为：</p>
<ul>
<li><strong>SQL 优化</strong>：70.5</li>
<li><strong>方言转换</strong>：69.5</li>
<li><strong>SQL 理解</strong>：78.1</li>
</ul>
<p>能力表现更为均衡。</p>
<h4 data-id="heading-8">SQL 优化能力：70.5</h4>
<p>该分数体现了模型在 SQL 优化方面的均衡能力。其「<strong>语法错误检测</strong> 」获得 100 分满分（与 <a href="https://link.juejin.cn?target=https%3A%2F%2Fsqlflash.ai%2F" target="_blank" title="https://sqlflash.ai/" ref="nofollow noopener noreferrer">SQLFlash</a> 并列），保证了优化后代码的规范性与可用性。「<strong>逻辑等价</strong> 」得分为 84.2 分（排名第 6），表现优异。「<strong>优化深度</strong>」得分为 60.0 分（排名第 4），表明模型能够应用常规的优化策略，但在处理复杂的查询、进行深度重构以追求极致性能方面，仍有进步空间。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/697cb86af8714dea8b8e4dddbfc19731~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=fCLLq%2BMSup9HjisnUkBNvs7aKIc%3D" alt="Ring-1T：SQL 优化维度评分" loading="lazy"/></p>
<h4 data-id="heading-9">方言转换能力：69.5</h4>
<p><em>Ring-1T</em> 在方言转换维度获得 69.5 分（排名第 11）。细分数据显示，其在「<strong>国产数据库</strong> 」转换（94.7分）、「<strong>语法错误检测</strong> 」（73.8 分，排名第 9）和「<strong>逻辑等价</strong>」（71.0 分）上均表现稳健。</p>
<p>其短板在于「<strong>大 SQL 转换</strong> 」，得分仅为 41.9 分（排名第 12），模型在处理跨数据库访问（如 SQL Server 的 <code>[server].database.schema.table</code>）、控制流（如 GOTO 标签跳转）、错误处理机制（如 <code>@@ERROR</code> 检查、<code>BEGIN TRY/CATCH</code>）、动态 SQL 执行（如 <code>sp_executesql</code> 参数绑定）等复杂结构时，存在语法混用、语义不等价、结构转换不完整等问题。</p>
<p><strong>核心缺陷</strong> ：缺乏对复杂结构化代码的全局理解能力，以及对多方言语义差异的精确映射能力，导致转换后的 SQL 在语法正确性或逻辑等价性上存在缺陷。相较于 <em>Ling-1T</em> 的 12.9 分，该分数有了显著提升，表明其在处理「<strong>大 SQL 转换</strong>」和保证代码规范性方面具备更强的能力，使其成为一个更可靠的数据库迁移工具。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5c402c3760943629df960904e7d0d33~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=2SQRQBIj%2BChs5qfrtFZwfigT6tA%3D" alt="Ring-1T：方言转换维度评分" loading="lazy"/></p>
<h4 data-id="heading-10">SQL 理解能力：78.1</h4>
<p>得分 78.1 分，这是一个稳健的分数。其在「<strong>执行准确性</strong> 」上表现稳定（84.3分）。但其「<strong>执行计划检测</strong> 」（60.7分）和「<strong>语法错误检测</strong>」（67.1分）得分偏低。</p>
<p>模型混淆了标准 SQL 语法与数据库特定规则，将正确的标准语法误判为错误（如 GROUP BY 中使用别名 <code>category_prefix</code>、<code>INSERT</code> 子查询 <code>INSERT INTO table (SELECT ...)</code>、<code>CREATE VIEW</code> 中使用 <code>HAVING</code> 等），同时对复杂结构理解不准确，导致误判和漏判并存，反映了模型对标准 SQL 规范的准确理解不足，以及对语法规则判断的机械性。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7623046815e84be39b3335e5fc3d3dcc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=Czgs3stKIqtlfrNJhmE092z%2Fs5w%3D" alt="Ring-1T：SQL 理解维度评分" loading="lazy"/></p>
<h2 data-id="heading-11">四、专家点评</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/29c38e0708ba4d06bdedda92933baf75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54ix5Y-v55Sf5byA5rqQ56S-5Yy6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976184&amp;x-signature=v0GMfBY8tjG9FwoA40aV43ERWBw%3D" alt="" loading="lazy"/></p>
<blockquote>
<p><strong>林春</strong>，中国太平洋保险数智研究院首席数据库专家，OceanBase 客户专家委员会（OBCE）专家委员，获得 OBCE 认证。获得 Oracle OCM、PostgreSQL PCM、MySQL OCP 认证。墨天轮 MVP，中国数据库技术大会（DTCC）演讲嘉宾。</p>
</blockquote>
<p>SCALE 2025 年 10 月《大模型 SQL 能力排行榜》的发布，堪称 AI 与数据库协同领域的关键行业参照。其依托"<strong>SQL优化+方言兼容+SQL理解</strong> "的三维测评框架，将大模型在数据库场景的落地能力进行了体系化量化，尤其在 Ling-1T、Ring-1T 等模型的分项表现中，清晰呈现了自然语言与数据库操作的适配差异，<strong>为企业级 AI+ 数据库的技术选型提供了精准的能力标尺</strong>。</p>
<p>这个榜单通过月度迭代的动态测评范式，既强化了对大模型数据库能力演进的追踪性，又以"细分场景得分+综合能力排名"的形式，缓解了企业对大模型"泛能力强、垂直场景弱"的选型焦虑，这与当前数据库向智能化、场景化演进的趋势高度契合。<strong>它不仅为中小企业提供了低成本评估 AI 数据库工具的参照标准，更倒逼大模型行业加速垂直能力优化 ------ 在 SQL 复杂查询适配、多数据库方言兼容等领域形成技术迭代</strong>。</p>
<p>SCALE 榜单的价值在于以标准化测评姿态打通了大模型能力与数据库需求的匹配链路，推动"<strong>模型能力评估-场景技术选型-落地效果验证</strong>"全流程的理性化重构，为下一代智能数据系统的技术适配提供了极具实践意义的行业范本。</p>
<p>我们可以看到，Ring-1T 模型在数据库场景中的核心优势场景包括：</p>
<ul>
<li>
<p><strong>复杂 SQL 查询生成</strong>：在多表关联、嵌套子查询等复杂 SQL 构建任务中表现突出（SQL 优化能力得分 70.5），可高效将自然语言需求转化为高性能 SQL 语句。</p>
</li>
<li>
<p><strong>多数据库方言兼容</strong>：适配 MySQL、Oracle 等主流数据库的语法差异（方言兼容能力得分 69.5），能自动生成符合不同数据库语法规范的操作语句。</p>
</li>
<li>
<p><strong>SQL 语义理解与纠错</strong>：对模糊需求、表述不规范的查询指令，具备较强的语义解析与纠错能力（SQL 理解能力得分 78.1），降低自然语言交互的精准度门槛。</p>
</li>
<li>
<p><strong>批量数据操作适配</strong>：在批量插入、更新等数据操作场景中，可生成高效且符合数据库性能要求的 SQL 脚本，适配企业级数据批量处理需求。</p>
</li>
</ul>
<h2 data-id="heading-12">五、总结与展望</h2>
<p>随着蚂蚁百灵 <em>Ling-1T</em> 和 <em>Ring-1T</em> 两款新模型的加入，<strong>SCALE</strong> 评测榜单已累计收录超过 20 款业界主流 AI 模型及专业工具。本月评测清晰地展示了 <strong>Ling 2.0</strong> 系列两款模型的特点：</p>
<ul>
<li><strong>Ling-1T</strong> 在国产数据库适配上表现出众，但在复杂任务处理上存在短板</li>
<li><strong>Ring-1T</strong> 则展现了更均衡、更强大的综合 SQL 处理能力，特别是在 SQL 理解和优化方面表现稳健</li>
</ul>
<p>展望未来，SCALE 将继续秉持客观、严谨的原则：</p>
<ul>
<li>持续追踪：我们将继续追踪并迅速引入业界前沿的大模型和 SQL 工具。</li>
<li>深化场景：我们计划引入更多维度的企业级真实应用场景，使评测结果更贴近实际生产环境。</li>
</ul>
<blockquote>
<p>一个开放、透明的评测生态需要社区的共同建设。我们诚挚地邀请国内外更多的模型开发者、数据库工具提供商提交您的产品参与 SCALE 评测。通过在同一基准下与全球顶尖模型竞技，不仅可以精准定位产品优势与不足，更能提升品牌在开发者社区中的影响力。</p>
<p>即刻访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fsql-llm-leaderboard.com%2Franking%2F2025-09" target="_blank" title="https://sql-llm-leaderboard.com/ranking/2025-09" ref="nofollow noopener noreferrer">sql-llm-leaderboard.com/ranking/202…</a></p>
<p>查看完整榜单并联系我们提交您的产品。</p>
</blockquote>
<p><strong>SCALE ------ 为专业 SQL 任务，选专业 AI 模型。</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 一个小型游戏对象模型渐进式设计（一）——继承机制解读：从基础类到防止重写]]></title>    <link>https://juejin.cn/post/7573468493569622052</link>    <guid>https://juejin.cn/post/7573468493569622052</guid>    <pubDate>2025-11-17T09:41:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573468493569622052" data-draft-id="7553864179158614042" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 一个小型游戏对象模型渐进式设计（一）——继承机制解读：从基础类到防止重写"/> <meta itemprop="keywords" content="Swift"/> <meta itemprop="datePublished" content="2025-11-17T09:41:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unravel2025"/> <meta itemprop="url" content="https://juejin.cn/user/1116759541421880"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 一个小型游戏对象模型渐进式设计（一）——继承机制解读：从基础类到防止重写
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759541421880/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unravel2025
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:41:43.000Z" title="Mon Nov 17 2025 09:41:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">为什么必须有“继承”</h2>
<p>在真实世界里，我们习惯把事物归类：车 → 自行车 → 双人自行车。</p>
<p>Swift 的 class 类型允许我们用同样的层级方式建模，把公共的代码放在“上层”，把差异化的代码放在“下层”，这就是继承（Inheritance）。</p>
<p>它带来的三大价值：</p>
<ol>
<li>代码复用：公共逻辑写一次。</li>
<li>统一接口：上层可用“父类指针”操作一切子类。</li>
<li>多态：运行时才决定到底执行哪段代码。</li>
</ol>
<h2 data-id="heading-1">基础概念速览</h2>
<ol>
<li>基类（Base Class）：不继承任何类的类。</li>
<li>子类（Subclass）：写在冒号后面的类，它自动拥有父类所有成员。</li>
<li>重写（Override）：子类对继承来的成员重新实现，需加关键字 override。</li>
<li>super：在子类内部访问“父类实现”的前缀。</li>
<li>final：阻止后面的人再继续重写或继承。</li>
</ol>
<h2 data-id="heading-2">基类长什么样</h2>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">/// 基类：最普通的“车”</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> {
    <span class="hljs-keyword">var</span> currentSpeed <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>          <span class="hljs-comment">// 存储属性，默认 0</span>
    
    <span class="hljs-comment">/// 计算属性：只读，返回人类可读的描述</span>
    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"traveling at <span class="hljs-subst">\(currentSpeed)</span> mph"</span>
    }
    
    <span class="hljs-comment">/// 实例方法：基类里什么都不做，留给子类去“填坑”</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeNoise</span>() {
        <span class="hljs-comment">// 空实现</span>
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">let</span> someVehicle <span class="hljs-operator">=</span> <span class="hljs-type">Vehicle</span>()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Vehicle: <span class="hljs-subst">\(someVehicle.description)</span>"</span>)
<span class="hljs-comment">// 打印：Vehicle: traveling at 0.0 mph</span>
</code></pre>
<h2 data-id="heading-3">子类化（Subclassing）</h2>
<p>语法：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> 子类: 父类 { <span class="hljs-comment">/* 新增或覆盖 */</span> }
</code></pre>
<p>示例 1：自行车</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bicycle</span>: <span class="hljs-title class_">Vehicle</span> {
    <span class="hljs-keyword">var</span> hasBasket <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">// 新增属性</span>
}

<span class="hljs-keyword">let</span> bike <span class="hljs-operator">=</span> <span class="hljs-type">Bicycle</span>()
bike.hasBasket <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>
bike.currentSpeed <span class="hljs-operator">=</span> <span class="hljs-number">15</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Bicycle: <span class="hljs-subst">\(bike.description)</span>"</span>)
<span class="hljs-comment">// 打印：Bicycle: traveling at 15.0 mph</span>
</code></pre>
<p>示例 2：双人自行车（子类还能再被继承）</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tandem</span>: <span class="hljs-title class_">Bicycle</span> {
    <span class="hljs-keyword">var</span> currentNumberOfPassengers <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
}

<span class="hljs-keyword">let</span> tandem <span class="hljs-operator">=</span> <span class="hljs-type">Tandem</span>()
tandem.hasBasket <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>
tandem.currentNumberOfPassengers <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
tandem.currentSpeed <span class="hljs-operator">=</span> <span class="hljs-number">22</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Tandem: <span class="hljs-subst">\(tandem.description)</span>"</span>)
<span class="hljs-comment">// 打印：Tandem: traveling at 22.0 mph</span>
</code></pre>
<h2 data-id="heading-4">重写（Override）全规则</h2>
<ol>
<li>方法重写：必须写 override；否则编译器报错。</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span>: <span class="hljs-title class_">Vehicle</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeNoise</span>() {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Choo Choo"</span>)
    }
}
<span class="hljs-type">Train</span>().makeNoise()   <span class="hljs-comment">// Choo Choo</span>
</code></pre>
<ol start="2">
<li>
<p>属性重写</p>
<p>子类“看不到”父类属性到底是存储型还是计算型，只能按“名字 + 类型”去匹配。</p>
<p>a) 只读变读写：可以补充 setter。</p>
<p>b) 读写变只读：❌ 不允许。</p>
</li>
</ol>
<p>示例：给车加“档位”描述</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>: <span class="hljs-title class_">Vehicle</span> {
    <span class="hljs-keyword">var</span> gear <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> {
        <span class="hljs-comment">// 先拿父类描述，再拼接自己的</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.description <span class="hljs-operator">+</span> <span class="hljs-string">" in gear <span class="hljs-subst">\(gear)</span>"</span>
    }
}

<span class="hljs-keyword">let</span> car <span class="hljs-operator">=</span> <span class="hljs-type">Car</span>()
car.currentSpeed <span class="hljs-operator">=</span> <span class="hljs-number">25</span>
car.gear <span class="hljs-operator">=</span> <span class="hljs-number">3</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Car: <span class="hljs-subst">\(car.description)</span>"</span>)
<span class="hljs-comment">// 打印：Car: traveling at 25.0 mph in gear 3</span>
</code></pre>
<ol start="3">
<li>
<p>属性观察器重写</p>
<p>可以为任何继承来的属性（无论存储/计算）添加 willSet/didSet。</p>
<p>典型场景：自动档根据速度换挡。</p>
</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutomaticCar</span>: <span class="hljs-title class_">Car</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> currentSpeed: <span class="hljs-type">Double</span> {
        <span class="hljs-keyword">didSet</span> {
            gear <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(currentSpeed <span class="hljs-operator">/</span> <span class="hljs-number">10</span>) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>   <span class="hljs-comment">// 自己算档位</span>
        }
    }
}

<span class="hljs-keyword">let</span> auto <span class="hljs-operator">=</span> <span class="hljs-type">AutomaticCar</span>()
auto.currentSpeed <span class="hljs-operator">=</span> <span class="hljs-number">35</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"AutomaticCar: <span class="hljs-subst">\(auto.description)</span>"</span>)
<span class="hljs-comment">// 打印：AutomaticCar: traveling at 35.0 mph in gear 4</span>
</code></pre>
<h2 data-id="heading-5">防止继承与重写——final</h2>
<ol>
<li>防重写</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> {
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>          <span class="hljs-comment">// 子类不能 override</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">foo</span>() {}       <span class="hljs-comment">// 子类不能 override</span>
}
</code></pre>
<ol start="2">
<li>防继承</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tool</span> {}         <span class="hljs-comment">// 任何人写 class MyTool: Tool {} 都会编译失败</span>
</code></pre>
<h2 data-id="heading-6">super 的使用场景小结</h2>
<ol>
<li>在 override 方法里：<code>super.someMethod()</code></li>
<li>在 override 属性 getter/setter 里：<code>super.someProperty</code></li>
<li>在 override 下标里：<code>super[index]</code></li>
</ol>
<h2 data-id="heading-7">容易踩的坑</h2>
<ol>
<li>忘记写 override → 编译期报错。</li>
<li>重写时把只读属性改成只写 setter， Swift 不允许。</li>
<li>在 init 里访问 super 属性前，必须保证本类存储属性已初始化（初始化器规则）。</li>
<li>把 struct 拿去继承 → Swift 只有 class 支持继承，struct/enum 不行。</li>
</ol>
<h2 data-id="heading-8">继承的边界与替代方案</h2>
<p>继承是“白盒复用”，子类会依赖父类实现细节，容易造成“脆弱基类”问题。Swift 提供了更轻量的组合手段：</p>
<ol>
<li>协议（protocol）+ 默认实现 → 无需继承即可获得多态。</li>
<li>值类型（struct）+ 组合 → 把“能力”做成属性，而非父类。</li>
<li>面向协议编程（POP）→ 把“is-a”转成“can-do”，降低耦合。</li>
</ol>
<h2 data-id="heading-9">实战扩展：一个小型游戏对象模型</h2>
<p>需求：</p>
<ul>
<li>所有游戏实体都有血量 hp 与坐标 (x,y)。</li>
<li>玩家可以攻击，造成随机伤害。</li>
<li>BOSS 血量低于 20% 时进入狂暴模式，攻击力翻倍。</li>
</ul>
<p>代码：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">// 1. 基类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span> {
    <span class="hljs-keyword">var</span> hp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Double</span>, y: <span class="hljs-type">Double</span>
    
    <span class="hljs-keyword">init</span>(<span class="hljs-params">hp</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>) {
        <span class="hljs-keyword">self</span>.hp <span class="hljs-operator">=</span> hp; <span class="hljs-keyword">self</span>.x <span class="hljs-operator">=</span> x; <span class="hljs-keyword">self</span>.y <span class="hljs-operator">=</span> y
    }
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">10.0</span>   <span class="hljs-comment">// 默认伤害</span>
    }
}

<span class="hljs-comment">// 2. 普通小怪</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span>: <span class="hljs-title class_">Entity</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span> {
        <span class="hljs-keyword">let</span> damage <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>.random(in: <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">6</span>) <span class="hljs-operator">+</span> <span class="hljs-number">5</span>
        <span class="hljs-keyword">return</span> damage
    }
}

<span class="hljs-comment">// 3. BOSS</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Boss</span>: <span class="hljs-title class_">Entity</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span> {
        <span class="hljs-keyword">let</span> base <span class="hljs-operator">=</span> <span class="hljs-keyword">super</span>.attack()
        <span class="hljs-comment">// 狂暴判断</span>
        <span class="hljs-keyword">let</span> rage <span class="hljs-operator">=</span> hp <span class="hljs-operator">&lt;</span> <span class="hljs-number">20</span>   <span class="hljs-comment">// 假设 maxHp = 100</span>
        <span class="hljs-keyword">return</span> rage <span class="hljs-operator">?</span> base <span class="hljs-operator">*</span> <span class="hljs-number">2</span> : base
    }
}

<span class="hljs-comment">// 4. 使用</span>
<span class="hljs-keyword">let</span> boss <span class="hljs-operator">=</span> <span class="hljs-type">Boss</span>(hp: <span class="hljs-number">15</span>, x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"BOSS 伤害：<span class="hljs-subst">\(boss.attack())</span>"</span>)  <span class="hljs-comment">// 血量&lt;20，伤害翻倍</span>
</code></pre>
<h2 data-id="heading-10">总结与思考</h2>
<ol>
<li>继承是 Swift 面向对象体系的基石，但“能用”不等于“该用”。</li>
<li>优先把“共性”做成协议或工具函数，再考虑是否抽象出基类。</li>
<li>重写时始终加 override，既安全又自文档化。</li>
<li>用 final 明确“设计边界”，让后来者少踩坑。</li>
<li>与值类型、协议、组合搭配，才能发挥 Swift 真正的威力。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[跟着AI速度cli源码三-交互问答系统]]></title>    <link>https://juejin.cn/post/7573519273029697582</link>    <guid>https://juejin.cn/post/7573519273029697582</guid>    <pubDate>2025-11-17T09:43:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573519273029697582" data-draft-id="7573519273029681198" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="跟着AI速度cli源码三-交互问答系统"/> <meta itemprop="keywords" content="前端,Node.js"/> <meta itemprop="datePublished" content="2025-11-17T09:43:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="嘴平伊之豬"/> <meta itemprop="url" content="https://juejin.cn/user/2885545320261870"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            跟着AI速度cli源码三-交互问答系统
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2885545320261870/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    嘴平伊之豬
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:43:11.000Z" title="Mon Nov 17 2025 09:43:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto;border:3px solid rgba(62,175,124,.2)}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-weight:700;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:6px;border:2px solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c}.markdown-body a:active,.markdown-body a:hover{border-bottom:1.5px solid #3eaf7c}.markdown-body a:before{content:"⇲"}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(62,175,124,.2)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:.5rem solid;border-color:#42b983;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none}.markdown-body ul li:before{content:"•";margin-right:4px;color:#3eaf7c}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">阶段 3: 交互式问答系统</h2>
<h3 data-id="heading-1">📌 核心知识点</h3>
<h4 data-id="heading-2">1. prompts 库简介</h4>
<p><strong>prompts</strong> 是一个轻量级、美观的命令行交互式问答库。</p>
<h5 data-id="heading-3">安装:</h5>
<pre><code class="hljs language-bash" lang="bash">pnpm add prompts
</code></pre>
<h5 data-id="heading-4">基本用法:</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> prompts <span class="hljs-keyword">from</span> <span class="hljs-string">'prompts'</span>

<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'text'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'username'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入用户名:'</span>
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">username</span>)  <span class="hljs-comment">// 用户输入的值</span>
</code></pre>
<hr/>
<h4 data-id="heading-5">2. 问题对象 (PromptObject) 详解</h4>
<p>每个问题是一个对象，包含以下字段：</p>
<h5 data-id="heading-6">核心字段:</h5>



































<table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>string | function</code></td><td>✅</td><td>问题类型或动态判断函数</td></tr><tr><td><code>name</code></td><td><code>string</code></td><td>✅</td><td>答案的字段名</td></tr><tr><td><code>message</code></td><td><code>string | function</code></td><td>✅</td><td>问题文本或动态生成函数</td></tr><tr><td><code>initial</code></td><td><code>any</code></td><td>❌</td><td>默认值</td></tr></tbody></table>
<h5 data-id="heading-7">常用字段:</h5>









































<table><thead><tr><th>字段</th><th>类型</th><th>说明</th><th>适用类型</th></tr></thead><tbody><tr><td><code>choices</code></td><td><code>Array</code></td><td>选项列表</td><td><code>select</code>, <code>multiselect</code></td></tr><tr><td><code>active</code></td><td><code>string</code></td><td>"是"选项文本</td><td><code>toggle</code></td></tr><tr><td><code>inactive</code></td><td><code>string</code></td><td>"否"选项文本</td><td><code>toggle</code></td></tr><tr><td><code>hint</code></td><td><code>string</code></td><td>提示信息</td><td>所有类型</td></tr><tr><td><code>validate</code></td><td><code>function</code></td><td>验证函数</td><td>所有类型</td></tr></tbody></table>
<hr/>
<h4 data-id="heading-8">3. 问题类型 (type) 详解</h4>
<h5 data-id="heading-9">3.1 text - 文本输入</h5>
<p><strong>用途:</strong> 获取用户输入的字符串</p>
<p><strong>示例:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'text'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'projectName'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入项目名称:'</span>,
  <span class="hljs-attr">initial</span>: <span class="hljs-string">'my-app'</span>
}
</code></pre>
<p><strong>效果:</strong></p>
<pre><code class="hljs language-perl" lang="perl">? 请输入项目名称: › <span class="hljs-keyword">my</span>-app
</code></pre>
<p><strong>使用场景:</strong> 项目名、用户名、邮箱等</p>
<hr/>
<h5 data-id="heading-10">3.2 number - 数字输入</h5>
<p><strong>用途:</strong> 获取数字</p>
<p><strong>示例:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'number'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'port'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入端口号:'</span>,
  <span class="hljs-attr">initial</span>: <span class="hljs-number">3000</span>
}
</code></pre>
<p><strong>效果:</strong></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">?</span> <span class="hljs-string">请输入端口号:</span> <span class="hljs-string">›</span> <span class="hljs-number">3000</span>
</code></pre>
<hr/>
<h5 data-id="heading-11">3.3 toggle - 开关/确认</h5>
<p><strong>用途:</strong> 是/否选择</p>
<p><strong>示例:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'toggle'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'shouldOverwrite'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'目标文件非空，是否覆盖？'</span>,
  <span class="hljs-attr">initial</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">active</span>: <span class="hljs-string">'是'</span>,
  <span class="hljs-attr">inactive</span>: <span class="hljs-string">'否'</span>
}
</code></pre>
<p><strong>效果:</strong></p>
<pre><code class="hljs">? 目标文件非空，是否覆盖？ › 否 / 是
</code></pre>
<p><strong>使用场景:</strong> 确认操作、开关设置</p>
<hr/>
<h5 data-id="heading-12">3.4 select - 单选列表</h5>
<p><strong>用途:</strong> 从列表中选择一项</p>
<p><strong>示例:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'select'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'templateType'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择模板:'</span>,
  <span class="hljs-attr">choices</span>: [
    { <span class="hljs-attr">title</span>: <span class="hljs-string">'base(推荐)'</span>, <span class="hljs-attr">value</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'base'</span> } },
    { <span class="hljs-attr">title</span>: <span class="hljs-string">'demo(演示)'</span>, <span class="hljs-attr">value</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'demo'</span> } }
  ],
  <span class="hljs-attr">initial</span>: <span class="hljs-number">0</span>
}
</code></pre>
<p><strong>效果:</strong></p>
<pre><code class="hljs language-css" lang="css">? 请选择模板: › - Use arrow-keys. Return to submit.
❯ <span class="hljs-built_in">base</span>(推荐)
  <span class="hljs-built_in">demo</span>(演示)
</code></pre>
<p><strong>使用场景:</strong> 模板选择、框架选择</p>
<hr/>
<h5 data-id="heading-13">3.5 multiselect - 多选列表</h5>
<p><strong>用途:</strong> 从列表中选择多项</p>
<p><strong>示例:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'multiselect'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'features'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'选择需要的功能:'</span>,
  <span class="hljs-attr">choices</span>: [
    { <span class="hljs-attr">title</span>: <span class="hljs-string">'TypeScript'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'ts'</span> },
    { <span class="hljs-attr">title</span>: <span class="hljs-string">'ESLint'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'eslint'</span> },
    { <span class="hljs-attr">title</span>: <span class="hljs-string">'Prettier'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'prettier'</span> }
  ]
}
</code></pre>
<p><strong>效果:</strong></p>
<pre><code class="hljs">? 选择需要的功能: (空格选择，回车确认)
❯ ◉ TypeScript
  ◯ ESLint
  ◉ Prettier
</code></pre>
<hr/>
<h4 data-id="heading-14">4. 动态问题 - type 和 message 可以是函数</h4>
<p>这是 prompts 最强大的特性之一！</p>
<h5 data-id="heading-15">4.1 动态 type - 条件显示问题</h5>
<p><strong>用途:</strong> 根据前一个答案决定是否显示当前问题</p>
<p><strong>语法:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-attr">type</span>: <span class="hljs-function">(<span class="hljs-params">prevValue</span>) =&gt;</span> {
  <span class="hljs-comment">// prevValue 是上一个问题的答案</span>
  <span class="hljs-keyword">return</span> 条件 ? <span class="hljs-string">'问题类型'</span> : <span class="hljs-literal">null</span>  <span class="hljs-comment">// null 表示跳过</span>
}
</code></pre>
<p><strong>create-unibest 实际案例:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 文件覆盖问题 - 只在目录非空时显示</span>
{
  <span class="hljs-attr">name</span>: <span class="hljs-string">'shouldOverwrite'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-function">(<span class="hljs-params">prevValue</span>) =&gt;</span> {
    <span class="hljs-comment">// prevValue 是上一个问题的答案 (projectName)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">canSkipEmptying</span>(prevValue) ? <span class="hljs-literal">null</span> : <span class="hljs-string">'toggle'</span>
  },
  <span class="hljs-attr">message</span>: <span class="hljs-string">'目标文件非空，是否覆盖？'</span>,
  <span class="hljs-attr">initial</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">active</span>: <span class="hljs-string">'是'</span>,
  <span class="hljs-attr">inactive</span>: <span class="hljs-string">'否'</span>
}
</code></pre>
<p><strong>执行流程:</strong></p>
<pre><code class="hljs language-bash" lang="bash">用户输入项目名: <span class="hljs-string">"my-app"</span>
       ↓
<span class="hljs-built_in">type</span> 函数被调用: <span class="hljs-built_in">type</span>(<span class="hljs-string">"my-app"</span>)
       ↓
检查: canSkipEmptying(<span class="hljs-string">"my-app"</span>)
       ├─ <span class="hljs-literal">true</span>  → 返回 null → 跳过这个问题
       └─ <span class="hljs-literal">false</span> → 返回 <span class="hljs-string">'toggle'</span> → 显示问题
</code></pre>
<hr/>
<h5 data-id="heading-16">4.2 动态 message - 根据上下文生成问题文本</h5>
<p><strong>用途:</strong> 根据前面的答案动态生成问题内容</p>
<p><strong>语法:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-attr">message</span>: <span class="hljs-function">(<span class="hljs-params">prevValue</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`根据 <span class="hljs-subst">${prevValue}</span> 生成的问题文本`</span>
}
</code></pre>
<p><strong>create-unibest 实际案例:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">name</span>: <span class="hljs-string">'shouldOverwrite'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-function">(<span class="hljs-params">prevValue</span>) =&gt;</span> <span class="hljs-title function_">canSkipEmptying</span>(prevValue) ? <span class="hljs-literal">null</span> : <span class="hljs-string">'toggle'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-function">(<span class="hljs-params">prevValue</span>) =&gt;</span> {
    <span class="hljs-comment">// prevValue 是项目名</span>
    <span class="hljs-keyword">const</span> dirForPrompt = prevValue === <span class="hljs-string">'.'</span>
      ? <span class="hljs-string">'当前文件'</span>
      : <span class="hljs-string">`目标文件"<span class="hljs-subst">${prevValue}</span>"`</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${dirForPrompt}</span>非空，是否覆盖？`</span>
  },
  <span class="hljs-attr">initial</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">active</span>: <span class="hljs-string">'是'</span>,
  <span class="hljs-attr">inactive</span>: <span class="hljs-string">'否'</span>
}
</code></pre>
<p><strong>效果:</strong></p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 如果项目名是 "my-app"</span>
? 目标文件<span class="hljs-string">"my-app"</span>非空，是否覆盖？ › 否 / 是

<span class="hljs-comment">// 如果项目名是 "."</span>
? 当前文件非空，是否覆盖？ › 否 / 是
</code></pre>
<hr/>
<h4 data-id="heading-17">5. 验证器 (overwriteChecker) 模式</h4>
<p><strong>问题:</strong> 用户选择"否"时如何中断流程？</p>
<p><strong>解决方案:</strong> 使用隐藏的验证器问题</p>
<p><strong>代码:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">name</span>: <span class="hljs-string">'overwriteChecker'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-function">(<span class="hljs-params">prevValues</span>) =&gt;</span> {
    <span class="hljs-comment">// prevValues 是上一个问题的答案</span>
    <span class="hljs-keyword">if</span> (prevValues === <span class="hljs-literal">false</span>) {
      <span class="hljs-comment">// 用户选择了"否"，抛出错误中断</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'操作已取消'</span>)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-comment">// 返回 null 不显示问题</span>
  }
}
</code></pre>
<p><strong>工作原理:</strong></p>
<pre><code class="hljs language-bash" lang="bash">用户选择: 是否覆盖？
       ├─ 选择<span class="hljs-string">"是"</span> (<span class="hljs-literal">true</span>)
       │     ↓
       │  <span class="hljs-built_in">type</span>(<span class="hljs-literal">true</span>) → null → 跳过验证器 → 继续下一个问题
       │
       └─ 选择<span class="hljs-string">"否"</span> (<span class="hljs-literal">false</span>)
             ↓
          <span class="hljs-built_in">type</span>(<span class="hljs-literal">false</span>) → 抛出错误 → 整个流程中断
</code></pre>
<hr/>
<h4 data-id="heading-18">6. create-unibest 问答系统架构</h4>
<h5 data-id="heading-19">文件结构:</h5>
<pre><code class="hljs language-bash" lang="bash">src/question/
├── index.ts           <span class="hljs-comment"># 主入口，组合所有问题</span>
├── name.ts            <span class="hljs-comment"># 项目名问题</span>
├── file.ts            <span class="hljs-comment"># 文件覆盖问题</span>
└── template/
    ├── index.ts       <span class="hljs-comment"># 模板选择问题</span>
    └── templateDate.ts <span class="hljs-comment"># 模板数据</span>
</code></pre>
<hr/>
<h5 data-id="heading-20">6.1 主入口 (src/question/index.ts)</h5>
<p><strong>代码:</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> prompts <span class="hljs-keyword">from</span> <span class="hljs-string">'prompts'</span>
<span class="hljs-keyword">import</span> { bold, red } <span class="hljs-keyword">from</span> <span class="hljs-string">'kolorist'</span>
<span class="hljs-keyword">import</span> figures <span class="hljs-keyword">from</span> <span class="hljs-string">'prompts/lib/util/figures.js'</span>
<span class="hljs-keyword">import</span> projectName <span class="hljs-keyword">from</span> <span class="hljs-string">'./name'</span>
<span class="hljs-keyword">import</span> template <span class="hljs-keyword">from</span> <span class="hljs-string">'./template'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">question</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 组合所有问题</span>
  <span class="hljs-keyword">const</span> questions = [
    ...<span class="hljs-title function_">projectName</span>(),  <span class="hljs-comment">// 项目名 + 文件覆盖</span>
    <span class="hljs-title function_">template</span>(),        <span class="hljs-comment">// 模板选择</span>
  ]

  <span class="hljs-comment">// 取消处理</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onCancel</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${red(figures.cross)}</span> <span class="hljs-subst">${bold(<span class="hljs-string">'操作已取消'</span>)}</span>`</span>)
  }

  <span class="hljs-comment">// 执行问答</span>
  <span class="hljs-keyword">const</span> answers = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>(questions, { onCancel })

  <span class="hljs-keyword">return</span> answers
}
</code></pre>
<p><strong>关键点:</strong></p>
<ol>
<li>使用展开运算符 <code>...</code> 组合问题数组</li>
<li><code>onCancel</code> 处理用户按 Ctrl+C 的情况</li>
<li><code>await</code> 等待用户输入完成</li>
<li>返回答案对象</li>
</ol>
<hr/>
<h5 data-id="heading-21">6.2 项目名问题 (src/question/name.ts)</h5>
<p><strong>代码:</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">PromptObject</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'prompts'</span>
<span class="hljs-keyword">import</span> filePrompt <span class="hljs-keyword">from</span> <span class="hljs-string">'./file'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (): <span class="hljs-title class_">PromptObject</span>&lt;<span class="hljs-built_in">string</span>&gt;[] =&gt; {
  <span class="hljs-keyword">return</span> [
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'projectName'</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-string">'text'</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">'请输入项目名称:'</span>,
      <span class="hljs-attr">initial</span>: <span class="hljs-string">'unibest'</span>,
    },
    ...<span class="hljs-title function_">filePrompt</span>(),  <span class="hljs-comment">// 嵌入文件覆盖问题</span>
  ]
}
</code></pre>
<p><strong>特点:</strong></p>
<ul>
<li>返回问题<strong>数组</strong>（不是单个问题）</li>
<li>包含项目名问题 + 文件覆盖问题</li>
<li>使用 <code>...filePrompt()</code> 展开</li>
</ul>
<hr/>
<h5 data-id="heading-22">6.3 文件覆盖问题 (src/question/file.ts)</h5>
<p><strong>完整代码分析:</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">PromptObject</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'prompts'</span>
<span class="hljs-keyword">import</span> { bold, red } <span class="hljs-keyword">from</span> <span class="hljs-string">'kolorist'</span>
<span class="hljs-keyword">import</span> figures <span class="hljs-keyword">from</span> <span class="hljs-string">'prompts/lib/util/figures.js'</span>
<span class="hljs-keyword">import</span> { canSkipEmptying } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (targetDir?: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">PromptObject</span>&lt;<span class="hljs-built_in">string</span>&gt;[] =&gt; {
  <span class="hljs-keyword">return</span> [
    <span class="hljs-comment">// 问题 1: 覆盖确认</span>
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'shouldOverwrite'</span>,

      <span class="hljs-comment">// 🎯 动态 type: 根据目录状态决定是否显示</span>
      <span class="hljs-attr">type</span>: <span class="hljs-function"><span class="hljs-params">prevValue</span> =&gt;</span> (
        <span class="hljs-title function_">canSkipEmptying</span>(targetDir ?? prevValue)
          ? <span class="hljs-literal">null</span>        <span class="hljs-comment">// 目录空/不存在 → 跳过</span>
          : <span class="hljs-string">'toggle'</span>    <span class="hljs-comment">// 目录非空 → 显示 toggle</span>
      ),

      <span class="hljs-comment">// 🎯 动态 message: 根据目录名生成问题文本</span>
      <span class="hljs-attr">message</span>: <span class="hljs-function">(<span class="hljs-params">prevValue</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> _targetDir = targetDir ?? prevValue
        <span class="hljs-keyword">const</span> dirForPrompt = _targetDir === <span class="hljs-string">'.'</span>
          ? <span class="hljs-string">'当前文件'</span>
          : <span class="hljs-string">`目标文件"<span class="hljs-subst">${_targetDir}</span>"`</span>

        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${dirForPrompt}</span>非空，是否覆盖？`</span>
      },

      <span class="hljs-attr">initial</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">active</span>: <span class="hljs-string">'是'</span>,
      <span class="hljs-attr">inactive</span>: <span class="hljs-string">'否'</span>,
    },

    <span class="hljs-comment">// 问题 2: 验证器（隐藏）</span>
    {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'overwriteChecker'</span>,

      <span class="hljs-comment">// 🎯 如果用户选择"否"，抛出错误</span>
      <span class="hljs-attr">type</span>: <span class="hljs-function">(<span class="hljs-params">prevValues</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (prevValues === <span class="hljs-literal">false</span>)
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${red(figures.cross)}</span> <span class="hljs-subst">${bold(<span class="hljs-string">'操作已取消'</span>)}</span>`</span>)

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-comment">// 不显示这个问题</span>
      },
    },
  ]
}
</code></pre>
<p><strong>执行流程:</strong></p>
<pre><code class="hljs language-bash" lang="bash">场景 1: 目录不存在
  projectName = <span class="hljs-string">"new-app"</span>
       ↓
  canSkipEmptying(<span class="hljs-string">"new-app"</span>) = <span class="hljs-literal">true</span>
       ↓
  <span class="hljs-built_in">type</span>(prevValue) 返回 null
       ↓
  跳过 shouldOverwrite 问题
       ↓
  跳过 overwriteChecker 问题
       ↓
  继续模板选择

场景 2: 目录存在且非空，用户选择<span class="hljs-string">"是"</span>
  projectName = <span class="hljs-string">"existing-app"</span>
       ↓
  canSkipEmptying(<span class="hljs-string">"existing-app"</span>) = <span class="hljs-literal">false</span>
       ↓
  <span class="hljs-built_in">type</span>(prevValue) 返回 <span class="hljs-string">'toggle'</span>
       ↓
  显示: ? 目标文件<span class="hljs-string">"existing-app"</span>非空，是否覆盖？
       ↓
  用户选择: 是 (<span class="hljs-literal">true</span>)
       ↓
  overwriteChecker: <span class="hljs-built_in">type</span>(<span class="hljs-literal">true</span>) 返回 null
       ↓
  继续模板选择

场景 3: 目录存在且非空，用户选择<span class="hljs-string">"否"</span>
  projectName = <span class="hljs-string">"existing-app"</span>
       ↓
  显示: ? 目标文件<span class="hljs-string">"existing-app"</span>非空，是否覆盖？
       ↓
  用户选择: 否 (<span class="hljs-literal">false</span>)
       ↓
  overwriteChecker: <span class="hljs-built_in">type</span>(<span class="hljs-literal">false</span>) 抛出错误
       ↓
  整个流程中断，程序退出
</code></pre>
<hr/>
<h5 data-id="heading-23">6.4 模板选择问题 (src/question/template/index.ts)</h5>
<p><strong>代码:</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">PromptObject</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'prompts'</span>
<span class="hljs-keyword">import</span> { templateList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./templateDate'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (): <span class="hljs-title class_">PromptObject</span>&lt;<span class="hljs-built_in">string</span>&gt; =&gt; {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'templateType'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'select'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'请选择 uni-app 模板？'</span>,
    <span class="hljs-attr">hint</span>: <span class="hljs-string">'使用方向键选择，回车确认'</span>,
    <span class="hljs-attr">choices</span>: [
      ...templateList,  <span class="hljs-comment">// 从配置文件导入</span>
    ],
    <span class="hljs-attr">initial</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 默认选中第一个</span>
  }
}
</code></pre>
<p><strong>templateList 数据结构:</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// src/question/template/templateDate.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">templateList</span>: <span class="hljs-title class_">TemplateList</span>[] = [
  {
    <span class="hljs-attr">title</span>: <span class="hljs-string">`base<span class="hljs-subst">${green(<span class="hljs-string">'(推荐)'</span>)}</span>`</span>,        <span class="hljs-comment">// 显示文本</span>
    <span class="hljs-attr">description</span>: <span class="hljs-string">`<span class="hljs-subst">${red(<span class="hljs-string">'(多TAB base项目)'</span>)}</span>`</span>,  <span class="hljs-comment">// 描述</span>
    <span class="hljs-attr">value</span>: {                                <span class="hljs-comment">// 返回值</span>
      <span class="hljs-attr">type</span>: <span class="hljs-string">'base'</span>,
      <span class="hljs-attr">branch</span>: <span class="hljs-string">'base'</span>,
      <span class="hljs-attr">url</span>: {
        <span class="hljs-attr">gitee</span>: <span class="hljs-string">'https://gitee.com/codercup/unibest.git'</span>,
        <span class="hljs-attr">github</span>: <span class="hljs-string">'https://github.com/codercup/unibest.git'</span>,
      },
    },
  },
  <span class="hljs-comment">// ... 更多模板</span>
]
</code></pre>
<p><strong>显示效果:</strong></p>
<pre><code class="hljs language-scss" lang="scss">? 请选择 uni-app 模板？ › - 使用方向键选择，回车确认
❯ <span class="hljs-built_in">base</span>(推荐) - (多TAB base项目)
  <span class="hljs-built_in">demo</span>(演示项目) - (多TAB演示项目)
  <span class="hljs-built_in">i18n</span>(多语言) - (多TAB多语言项目)
</code></pre>
<hr/>
<h4 data-id="heading-24">7. 取消处理 (onCancel)</h4>
<p><strong>用途:</strong> 处理用户按 Ctrl+C 或 Esc 的情况</p>
<p><strong>语法:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">onCancel</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-comment">// 处理取消逻辑</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'操作已取消'</span>)  <span class="hljs-comment">// 抛出错误</span>
  <span class="hljs-comment">// 或</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  <span class="hljs-comment">// 返回 true 继续，false 抛出默认错误</span>
}

<span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>(questions, { onCancel })
</code></pre>
<p><strong>create-unibest 的实现:</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">onCancel</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${red(figures.cross)}</span> <span class="hljs-subst">${bold(<span class="hljs-string">'操作已取消'</span>)}</span>`</span>)
}

<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> answers = <span class="hljs-keyword">await</span> <span class="hljs-title function_">prompts</span>(questions, { onCancel })
} <span class="hljs-keyword">catch</span> (cancelled) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cancelled.<span class="hljs-property">message</span>)
  process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)
}
</code></pre>
<p><strong>效果:</strong></p>
<pre><code class="hljs">? 请输入项目名称: › ^C
✖ 操作已取消
</code></pre>
<hr/>
<h4 data-id="heading-25">8. 问答结果对象</h4>
<p><strong>输入示例:</strong></p>
<pre><code class="hljs language-bash" lang="bash">pnpm create unibest
</code></pre>
<p><strong>用户交互:</strong></p>
<pre><code class="hljs language-csharp" lang="csharp">? 请输入项目名称: › my-app
? 目标文件<span class="hljs-string">"my-app"</span>非空，是否覆盖？ › 是
? 请选择 uni-app 模板？ › <span class="hljs-keyword">base</span>(推荐)
</code></pre>
<p><strong>返回的 answers 对象:</strong></p>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">projectName</span>: <span class="hljs-string">'my-app'</span>,
  <span class="hljs-attr">shouldOverwrite</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">templateType</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'base'</span>,
    <span class="hljs-attr">branch</span>: <span class="hljs-string">'base'</span>,
    <span class="hljs-attr">url</span>: {
      <span class="hljs-attr">gitee</span>: <span class="hljs-string">'https://gitee.com/codercup/unibest.git'</span>,
      <span class="hljs-attr">github</span>: <span class="hljs-string">'https://github.com/codercup/unibest.git'</span>
    }
  }
}
</code></pre>
<p><strong>注意:</strong></p>
<ul>
<li><code>overwriteChecker</code> 不在结果中（它的 type 返回 null）</li>
<li>跳过的问题也不在结果中</li>
</ul>
<hr/>
<h4 data-id="heading-26">9. 完整执行流程</h4>
<pre><code class="hljs language-ini" lang="ini">用户执行: pnpm create unibest
       ↓
   printBanner()
       ↓
   解析参数: <span class="hljs-attr">projectName</span> = undefined
       ↓
   走路径 A: 完全交互式
       ↓
   调用 question() 函数
       ↓
┌─────────────────────────────────┐
│  问题 1: 请输入项目名称          │
│  用户输入: "my-app"              │
│  <span class="hljs-attr">answers.projectName</span> = <span class="hljs-string">"my-app"</span> │
└─────────────────────────────────┘
       ↓
   检查目录: canSkipEmptying("my-app")
       ├─ true  → 跳过问题 2
       └─ false → 显示问题 2
       ↓
┌─────────────────────────────────┐
│  问题 2: 是否覆盖？              │
│  用户选择: 是                    │
│  <span class="hljs-attr">answers.shouldOverwrite</span> = <span class="hljs-literal">true</span> │
└─────────────────────────────────┘
       ↓
   验证器检查: <span class="hljs-attr">shouldOverwrite</span> === <span class="hljs-literal">true</span>
       ↓ 通过
┌─────────────────────────────────┐
│  问题 3: 选择模板                │
│  用户选择: base                  │
│  <span class="hljs-attr">answers.templateType</span> = {...}   │
└─────────────────────────────────┘
       ↓
   返回 answers 对象
       ↓
   开始下载模板...
</code></pre>
<hr/>
<h3 data-id="heading-27">💡 设计思路总结</h3>
<h4 data-id="heading-28">1. 智能动态问题</h4>
<p><strong>问题:</strong> 不是所有情况都需要询问</p>
<p><strong>解决方案:</strong></p>
<ul>
<li>使用函数式 <code>type</code></li>
<li>根据上下文动态决定是否显示</li>
</ul>
<p><strong>好处:</strong></p>
<ul>
<li>减少不必要的问题</li>
<li>提升用户体验</li>
<li>逻辑清晰</li>
</ul>
<hr/>
<h4 data-id="heading-29">2. 链式验证模式</h4>
<p><strong>问题:</strong> 用户选择"否"时如何优雅退出？</p>
<p><strong>解决方案:</strong></p>
<ul>
<li>添加隐藏的验证器问题</li>
<li><code>type</code> 返回 <code>null</code> 不显示</li>
<li>在验证器中抛出错误</li>
</ul>
<p><strong>好处:</strong></p>
<ul>
<li>即时反馈</li>
<li>流程清晰</li>
<li>避免无效操作</li>
</ul>
<hr/>
<h4 data-id="heading-30">3. 问题模块化</h4>
<p><strong>架构:</strong></p>
<pre><code class="hljs language-bash" lang="bash">question/
├── index.ts     <span class="hljs-comment"># 组合器</span>
├── name.ts      <span class="hljs-comment"># 项目名模块</span>
├── file.ts      <span class="hljs-comment"># 文件覆盖模块</span>
└── template/    <span class="hljs-comment"># 模板选择模块</span>
</code></pre>
<p><strong>好处:</strong></p>
<ul>
<li>职责分离</li>
<li>易于维护</li>
<li>可复用</li>
</ul>
<hr/>
<h4 data-id="heading-31">4. 用户友好</h4>
<p><strong>细节:</strong></p>
<ol>
<li>提供默认值 (<code>initial: 'unibest'</code>)</li>
<li>提供提示 (<code>hint: '使用方向键选择，回车确认'</code>)</li>
<li>彩色高亮 (<code>green('(推荐)')</code>)</li>
<li>清晰的描述 (<code>description: '(多TAB base项目)'</code>)</li>
</ol>
<hr/>
<h3 data-id="heading-32">🔧 prompts API 速查表</h3>
<h4 data-id="heading-33">问题类型</h4>













































<table><thead><tr><th>类型</th><th>用途</th><th>返回值类型</th></tr></thead><tbody><tr><td><code>text</code></td><td>文本输入</td><td><code>string</code></td></tr><tr><td><code>number</code></td><td>数字输入</td><td><code>number</code></td></tr><tr><td><code>confirm</code></td><td>是/否</td><td><code>boolean</code></td></tr><tr><td><code>toggle</code></td><td>开关</td><td><code>boolean</code></td></tr><tr><td><code>select</code></td><td>单选</td><td><code>any</code></td></tr><tr><td><code>multiselect</code></td><td>多选</td><td><code>any[]</code></td></tr><tr><td><code>autocomplete</code></td><td>自动完成</td><td><code>any</code></td></tr></tbody></table>
<h4 data-id="heading-34">常用字段</h4>
<pre><code class="hljs language-typescript" lang="typescript">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'text'</span> | <span class="hljs-string">'number'</span> | <span class="hljs-string">'select'</span> | ...,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'fieldName'</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">'问题文本'</span>,
  <span class="hljs-attr">initial</span>: 默认值,
  <span class="hljs-attr">choices</span>: [{ title, value }],  <span class="hljs-comment">// select/multiselect</span>
  <span class="hljs-attr">active</span>: <span class="hljs-string">'是'</span>,                 <span class="hljs-comment">// toggle</span>
  <span class="hljs-attr">inactive</span>: <span class="hljs-string">'否'</span>,               <span class="hljs-comment">// toggle</span>
  <span class="hljs-attr">hint</span>: <span class="hljs-string">'提示信息'</span>,
  <span class="hljs-attr">validate</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">format</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> newValue,
  <span class="hljs-attr">onState</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> { ... }
}
</code></pre>
<h4 data-id="heading-35">动态字段</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 动态 type</span>
<span class="hljs-attr">type</span>: <span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> 条件 ? <span class="hljs-string">'类型'</span> : <span class="hljs-literal">null</span>

<span class="hljs-comment">// 动态 message</span>
<span class="hljs-attr">message</span>: <span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> <span class="hljs-string">`根据 <span class="hljs-subst">${prev}</span> 生成的消息`</span>

<span class="hljs-comment">// 验证</span>
<span class="hljs-attr">validate</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> || <span class="hljs-string">'不能为空'</span>
</code></pre>
<hr/>
<h3 data-id="heading-36">📚 延伸阅读</h3>
<h4 data-id="heading-37">prompts 官方文档</h4>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fterkelg%2Fprompts" target="_blank" title="https://github.com/terkelg/prompts" ref="nofollow noopener noreferrer">GitHub: terkelg/prompts</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fprompts" target="_blank" title="https://www.npmjs.com/package/prompts" ref="nofollow noopener noreferrer">npm: prompts</a></li>
</ul>
<h4 data-id="heading-38">其他交互式库</h4>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSBoudrias%2FInquirer.js" target="_blank" title="https://github.com/SBoudrias/Inquirer.js" ref="nofollow noopener noreferrer">inquirer</a> - 功能最全</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fenquirer%2Fenquirer" target="_blank" title="https://github.com/enquirer/enquirer" ref="nofollow noopener noreferrer">enquirer</a> - 性能更好</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnatemoo-re%2Fclack" target="_blank" title="https://github.com/natemoo-re/clack" ref="nofollow noopener noreferrer">clack</a> - 现代化设计</li>
</ul>
<hr/>
<h3 data-id="heading-39">✅ 阶段 3 总结</h3>
<h4 data-id="heading-40">你学到了:</h4>
<ol>
<li>✅ <strong>prompts 基本用法</strong> - 各种问题类型</li>
<li>✅ <strong>动态问题机制</strong> - type 和 message 函数</li>
<li>✅ <strong>验证器模式</strong> - 隐藏问题实现流程控制</li>
<li>✅ <strong>取消处理</strong> - onCancel 回调</li>
<li>✅ <strong>模块化架构</strong> - 问题组织和复用</li>
<li>✅ <strong>用户体验优化</strong> - 默认值、提示、彩色输出</li>
</ol>
<h4 data-id="heading-41">关键要点:</h4>





























<table><thead><tr><th>概念</th><th>作用</th></tr></thead><tbody><tr><td><code>type</code> 函数</td><td>动态决定是否显示问题</td></tr><tr><td><code>message</code> 函数</td><td>根据上下文生成问题文本</td></tr><tr><td>验证器模式</td><td>隐藏问题 + 错误抛出 = 流程控制</td></tr><tr><td><code>onCancel</code></td><td>处理用户取消操作</td></tr><tr><td>展开运算符</td><td>组合问题数组</td></tr></tbody></table>
<hr/>
<p><strong>准备好进入阶段 4 了吗?</strong> 🚀</p>
<p>下一阶段将学习 <strong>文件系统操作</strong>，揭秘目录遍历、清空、创建的实现！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[云栖实录 | 洋钱罐基于 EMR Serverless 产品构建全球一体化数字金融平台]]></title>    <link>https://juejin.cn/post/7573225720698634292</link>    <guid>https://juejin.cn/post/7573225720698634292</guid>    <pubDate>2025-11-17T09:28:47.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720698634292" data-draft-id="7573170756869963828" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="云栖实录 | 洋钱罐基于 EMR Serverless 产品构建全球一体化数字金融平台"/> <meta itemprop="keywords" content="大数据,运维"/> <meta itemprop="datePublished" content="2025-11-17T09:28:47.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云大数据AI技术"/> <meta itemprop="url" content="https://juejin.cn/user/2414974667341287"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            云栖实录 | 洋钱罐基于 EMR Serverless 产品构建全球一体化数字金融平台
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2414974667341287/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云大数据AI技术
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:28:47.000Z" title="Mon Nov 17 2025 09:28:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>演讲人：宋晓峰 洋钱罐大数据运维总监</p>
<h2 data-id="heading-0">十年破壁：从数据筑基到智能生态的全链路实践</h2>
<h3 data-id="heading-1">一、数据筑基——自建大数据集群的攻坚与突破</h3>
<h4 data-id="heading-2">背景介绍</h4>
<p>瓴岳科技（Fintopia）是以大数据和人工智能为基础的数字科技集团，为全球用户提供卓越的金融体验。2015年成立至今，瓴岳科技始终聚焦消费金融，业务遍布中国大陆、东南亚、拉丁美洲和非洲等；集团旗下拥有洋钱罐、Easycash等知名品牌，截至2025年，服务全球金融机构超过114家，全球注册用户超过1.81亿，全球累计交易额超过5400亿元。在公司发展的过程中，我们大数据部门为智能风控、精准营销、产品创新三大核心业务提供数据支撑，整合多源数据，利用机器学习算法实时识别欺诈风险，构建全流程风控体系，基于用户行为、偏好等数据，定制个性化金融服务推荐，通过分析市场趋势与用户需求数据，为产品开发提供精准方向，助力瓴岳科技全球化业务布局。</p>
<h4 data-id="heading-3">大数据技术栈迭代与升级路径</h4>
<p>过去十年，洋钱罐的大数据技术栈经历了多次迭代。</p>
<p>2018年，面对数据孤岛问题及传统MySQL数据库无法有效支持复杂分析任务的挑战，我们自建了首个基于十多个节点的Hadoop大数据集群。当时用户规模约2000万，每日新增数据量约300GB。</p>
<p>随着业务需求的增长，特别是在2018年至2021年间，原有的MapReduce 框架因处理延迟较高而难以满足日益增长的数据处理时效性要求。因此，在2021年，我们将离线数据处理引擎由MapReduce迁移至Apache spark 2.x，并同步升级了Hive版本至3.x以提升数据仓库性能。彼时，系统每天运行约3,000个批处理作业。</p>
<p>为进一步提高数据处理效率并响应业务对数据实时性的更高期待，2022年我们引入了数据湖技术Apache Hudi，从而将原本的日全量数据抽取转变为增量更新模式，显著提升了数据的新鲜度至小时级别。</p>
<p>此外，为了更好地支持交互式查询场景，在2023年我们采用StarRocks作为新的Ad-hoc查询引擎，取代了之前依赖于Spark Thrift Server实现的方法。截至目前，Ad-hoc 日均SQL查询请求量超过8,000，P95响应时间控制在60秒以内。鉴于全球化布局带来的弹性资源、业务稳定性和成本优化要求，我们在2024年对整个集群架构进行了重大升级，将自建集群迁移至阿里云EMR Serverless平台，Yarn 节点规模超过一千台，在此过程中，我们也将spark 2.x升级到了spark 3.x。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c31852e3ea4464aa09bfdc7dfd58762~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=qYSkdAVS2PxytKnIY6k0YTh0wHU%3D" alt="image.png" loading="lazy"/></p>
<p>当前，我们集群的整体存储能力已经达到单副本10PB的规模，每日新增数据量约为30TB。核心业务报表数量超过3000份，而调度工作流数量已突破15000个。在StarRocks集群方面，我们同时采用了存算一体化架构与存算分离架构，并根据不同的业务线进行了划分，因此目前拥有超过30个独立的StarRocks集群实例。左侧展示的是我们的调度能力和 Ad-hoc 查询能力，YARN日执行job量超过4万。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b47dbd019f244532afd73dc2aa66ed97~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=DnM1yX68XRimFB%2FZHRKknZqYMZU%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-4">从稳定性到效率：自建集群的困境解析</h4>
<p>在自建大数据集群的过程中，我们遇到了诸多挑战，主要集中在稳定性、弹性资源管理和运维效率三个方面。</p>
<p>首先，在稳定性方面，我们面临的主要问题是业务SLA破线。这种情况往往源于底层 NodeManager 因网络带宽限制或shuffle 量大而导致任务失败率上升。此外，在使用开源组件过程中，也存在一些 bug 或者性能问题，比如我们在使用 Hive3.x 开源版本时，在高并发的场景下会出现进程卡死等问题，从而影响业务稳定性，无法满足生产环境的要求。</p>
<p>其次，在弹性资源管理上，自建集群缺乏快速扩展的能力以应对突发流量需求。例如，在凌晨遇到紧急情况时，希望迅速增加计算资源来解决问题变得不可行。同时，即使进行了物理服务器的扩容，在YARN的容量调度策略下，也难以有效平衡不同队列之间的负载分布，导致部分队列利用率过高而其他队列则相对空闲，整体上降低了集群资源利用效率。</p>
<p>最后，关于运维效率的问题，大数据集群的维护工作相当复杂且耗时。从硬件采购到最终完成配置并投入使用，整个过程通常需要两至三天时间。此外，开发人员还需投入大量精力进行性能调优、故障排除及日常巡检等任务，这不仅增加了人力成本，也影响了团队的工作效率。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96e9adefcc4f4fa1a05b3e76414a7515~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=rJo5sSwg7lSkFb6L5O5lWGPq3e0%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-5">Spark 引擎核心痛点解析</h4>
<p>在使用Apache Spark引擎的过程中，我们遇到了几个核心痛点，这些问题主要集中在资源管理、性能与稳定性、版本升级以及成本控制等方面。</p>
<p>首先，在资源管理方面，我们面临的主要问题之一是峰值资源的优化。例如，在凌晨执行大规模任务时，该任务可能会占用队列中90%以上的资源，而其他较小的任务虽然只占用了剩余10%左右的资源，但其完成时间却可能更长。这表明了当前资源分配机制存在不合理之处，需要更加精细地调整以提高整体效率。另一个问题是谷值期间资源利用率低下。特别是在非高峰时段（如午夜过后），集群的整体资源利用率往往只能达到30%左右，导致大量计算能力被闲置。</p>
<p>其次，在性能与稳定性方面也存在问题。当我们使用自建的大数据集群部署Spark时，采用的是开源版的Shuffle Service作为NodeManager组件。然而，在高负载情况下，这种服务的表现并不理想，容易成为瓶颈，并且当单个NodeManager出现问题时，会严重影响到整个集群上运行任务的稳定性和性能。</p>
<p>第三点关于引擎版本固化的问题也非常突出。比如将 spark 2.x迁移到spark 3.x，不仅耗时较长，还需要充分考虑新旧版本之间的兼容性问题、系统稳定性测试以及对现有业务流程的影响评估等多方面因素。</p>
<p>最后，在成本控制方面同样存在着挑战。由于不同业务线之间可能存在交叉需求，比如风控场景下的离线数据仓库处理与Adhoc查询同时进行，这就使得很难按照单一业务维度来精确划分和管理相关费用。因此，如何有效地衡量并优化跨部门使用的Spark资源成本，成为了我们需要解决的重要课题之一。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6df1cb7bd8714549bce9acaeec6d887d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=xw%2FfTO72PB9Qd18F9DEJN%2Fanu3s%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-6">StarRocks 问题解析</h4>
<p>在使用 StarRocks 的过程中，我们也遇到了一些挑战，主要集中在数据导入、资源隔离及系统稳定性三个方面。</p>
<p>首先，在数据导入方面，StreamLoad 导入速度慢，支持的数据量有限，当提高数据导入频率时，可能会触发 FE 内存问题，会出现MVC相关报错。Broker Load 虽然导入速度快，但是软性资源隔离策略会影响读性能，最后我们还是要依赖Spark集群的Spark Load解决大数据量导入问题</p>
<p>其次，关于资源隔离的问题，虽然开源版StarRocks提供了基本的资源隔离功能，但它是软隔离，而非硬性隔离，数据导入与查询操作之间存在竞争关系，尤其是大规模查询请求可能会影响其他小型查询请求的响应时间。</p>
<p>最后，在系统运维与稳定性保障方面，开源版本没有自带的管控页面，运维人员不得不自行开发一系列脚本来完成扩缩容等请求，增加了运维难度。此外，在面对版本升级时，升级耗时长，还需额外进行业务回归测试以验证新版本兼容性和系统稳定性。</p>
<p>以上因素共同构成了 StarRocks 在实际应用中面临的主要技术挑战。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e064f5667264f1888c0017cfb57e663~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=ftYYZj96%2FkBfX2KPL4J34VsJUaU%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">二、云帆起航——迁移阿里云 EMR 的全链路实践</h3>
<p>面对上述挑战，我们对大数据架构进行了全面升级，全面切换至阿里云生态组件。此次升级的核心在于构建了一个符合数据湖理念的全新平台架构，该架构不仅满足了当前业务需求，还为公司未来向数据湖方向的发展奠定了坚实基础。此次升级主要对两个计算引擎进行了重大改造。</p>
<p>首先，我们将Hive SQL完全迁移至Spark SQL。因为相较于Hive SQL，Spark SQL展现出更优的执行效率，这也是业界共识。整体迁移过程非常丝滑，在性能与兼容性方面，EMR Serverless Spark 表现亮眼，还支持丰富的开源生态，如Kyuubi、Livy等。</p>
<p>其次，我们将 StarRocks 存算一体版本切换为了存算分离版本，这也顺应了Serverless 架构的发展趋势。</p>
<p>基于计算引擎升级，我们在上层构建了自己的数据应用产品，如一站式开发平台、标签系统、实时开发平台、数据质量监控系统、Ad-hoc查询等。</p>
<p>我们还将底层存储从传统HDFS切换为阿里云OSS-HDFS，消除了原生Hadoop文件系统中存在的单点故障问题。相比自建集群成本，新架构成本仅为其十分之一左右。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d07a12ef8c5484d905dcf5ebb4c3e43~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=mNn5KoNKm%2F1hMpOna0EDmjXZMfA%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-8">EMR Serverless Spark：一站式数据平台服务</h4>
<p>EMR Serverless Spark 提供了一站式的数据平台服务，包括任务开发、调试、调度和运维等，极大地简化了数据处理和模型训练的全流程。内置 SQLEditor、Notebook 开发环境，提供版本管理，工作流调度，以及运维诊断能力。 版本管理功能使得用户能轻松切换Spark版本，只需确保SQL语句能正常运行，数据能正常处理即可，无需考虑底层基础设施的复杂性。</p>
<p>针对Spark和Python环境，用户可以根据具体业务需求进行配置，如调整spark-defaults.conf文件中的参数值，来优化特定应用场景下的性能表现。通过简单的spark-submit命令配合相关参数，即可快速切换到所需的运行时环境，极大提高了工作效率。</p>
<p>监控与诊断方面，EMR Serverless Spark 还提供完善的监控与诊断功能。提供工作空间、队列以及任务等各种维度的资源指标统计，方便用户更清晰地掌握作业运行情况。在Spark任务完成之后，收集和分析该任务的各种资源消耗指标，并根据这些指标给出合理的优化建议。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5bf4f6f41ba44bbd9b0aa082222655af~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=V1%2BIbY2chWtg13Z7S6wbAmz9aPM%3D" alt="image.png" loading="lazy"/></p>
<p>EMR Serverless Spark 还提供极致资源弹性与性能。首先，在弹性伸缩方面，支持 Driver/Executor级别进程弹性，最低支持一核力度，容器拉起时间在20秒以内。资源供给方面，底层是 Iaas + 神龙资源池，提供海量供给，自迁移至 EMR Serverless Spark 以来，我们尚未遇到任何资源短缺问题。</p>
<p>此外，EMR Serverless Spark 采用类似于YARN的资源管理模式。Workspace/队列两层Quota管理支持用户根据业务特性选择合适的提交路径。平台提供了基于Workspace/队列/作业的多维度、精确到天/时/分的多周期资源观测能力。</p>
<p>性能方面，EMR Serverless Spark 自研 Fusion 引擎，内置高性能向量化计算和 RSS 能力，相比开源版本性能大幅提升。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a033b89182684ba0a2af37f0e739febb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=%2F8adrdU9TbXKVQnKDE%2F42tibRWA%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-9">EMR Serverless StarRocks：功能丰富、性能卓越</h4>
<p>EMR Serverless StarRocks在管控能力方面显著优于自建方案，提供实例管理功能，包括创建，扩容缩容，升降配，网络管理，白名单管理，操作任务管理，网关管理等。</p>
<p>此外，其管控平台提供实例健康报告与慢SQL诊断分析、可视化缓存管理、支持大/小版本主动触发滚动升级、支持全链路实例操作审计等功能。</p>
<p>值得一提的是，EMR Serverless StarRocks 实现了真正的存算分离架构，提供物理隔离能力，不同计算组作业负载相互独立，支持多计算组独立配置。在我们的实际应用场景下，存算分离内表查询较开源性能提升约100%，数据湖查询较开源性能提升约50%。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4f9ad3949fa24f8ca3f9312946be352f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=H2iQM%2FgQs%2F4hAaepOOkZxoRJD%2BI%3D" alt="image.png" loading="lazy"/></p>
<p>下图展示了基于EMR Serverless StarRocks 的湖仓新范式，StarRocks 作为统一 Lakehouse，基于湖表进行自助分析查询。数据写入 StarRocks 提供极速分析；数据写入开放数据湖，使用 StarRocks 直接分析数据湖；在DWD、DWS以及ADS层，通过构建物化视图并实施分层建模策略，不仅能够有效支撑各类报表需求，同时也为OLAP提供了强有力的支持。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f085f8a2d1614425bed1799900655653~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=5NqCSqrodpXqKKUfa%2BO3yMP3MMk%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-10">架构升级带来的关键价值</h4>
<p>上述重大架构升级，带来了哪些关键价值呢？</p>
<p>首先，在成本优化方面，通过引入弹性资源，显著提高了资源利用率。</p>
<p>其次，从业务稳定性角度来看，EMR Serverless Spark 自带的高性能 Shuffle 服务，极大地增强了系统的稳定性和可靠性。此外，StarRocks 的性能优化也进一步提升了整体业务处理能力与响应速度。</p>
<p>关于业务敏捷性，新架构支持快速部署新业务场景所需的计算资源，从而大幅缩短了业务上线周期。</p>
<p>运维效率方面，得益于 EMR Serverless Spark与 EMR Serverless StarRocks 丰富的管控能力，开发团队所需投入的日常维护工作量显著减少。同时，平台提供了全天候的技术支持服务，确保即使面对突发问题也能迅速获得解决方案，进一步保障了系统的连续可用性。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/779a7ef5859c41949dea78aa1aeaaef8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=bZAx%2FzRro6Bg7hmMIiuMqBfwOh4%3D" alt="image.png" loading="lazy"/></p>
<p>具体而言，在保持业务规模不变的前提下，与传统的自建方案相比，基于 EMR Serverless 构建的解决方案能够实现约25.4%的成本节约。基于 EMR Serverless StarRocks 进行查询（如标签系统和用户圈选场景），SQL 查询执行时长缩短了30%。此外，在相同成本情况下，EMR Serverless Spark 作业的执行时间也缩短了30%以上。最值得注意的是运维效率方面的改进，实现了近40%的大幅提升。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47c191d6612a470da1b7cce37a023b55~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=LAbmV7V01vC8hhXJp3cG8kvg3o8%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-11">三、智创未来——未来基于阿里云的智能生态布局</h3>
<p>在完成架构升级后，整体稳定性得到显著提升。展望未来，我们的目标是构建一个更加智能化的金融生态环境。为此，我们设想了四个主要发展方向：</p>
<p>首先，在数据处理方面，我们计划基于阿里云EMR及机器学习平台PAI来实现高效的数据协同架构。</p>
<p>其次，在业务流程优化上，通过整合阿里云的大规模模型能力，旨在创建一个既简化又高效的运营环境，涵盖预测式风控、自动化运营，大智能化监控等领域。</p>
<p>再者，在应用层面，致力于形成以数据为驱动并支持智能决策的完整业务闭环。</p>
<p>最后，在算法创新方面，我们将依托于阿里云机器学习平台PAI，专注于开发适用于特定行业的专属AI模型库。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cfe167d183244fb6b99a0455ab2a284e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5aSn5pWw5o2uQUnmioDmnK8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976526&amp;x-signature=xCPV1rLa5BLIz6dPZNo39JLBm0c%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AiOnly大模型深度测评：调用GPT-5 API+RAG知识库，快速构建智能客服机器人]]></title>    <link>https://juejin.cn/post/7573486671296856106</link>    <guid>https://juejin.cn/post/7573486671296856106</guid>    <pubDate>2025-11-17T09:26:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573486671296856106" data-draft-id="7573336057481281542" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AiOnly大模型深度测评：调用GPT-5 API+RAG知识库，快速构建智能客服机器人"/> <meta itemprop="keywords" content="OpenAI,AI编程"/> <meta itemprop="datePublished" content="2025-11-17T09:26:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="倔强的石头_"/> <meta itemprop="url" content="https://juejin.cn/user/3168119757484368"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AiOnly大模型深度测评：调用GPT-5 API+RAG知识库，快速构建智能客服机器人
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3168119757484368/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    倔强的石头_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:26:07.000Z" title="Mon Nov 17 2025 09:26:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>AI 技术加速渗透各行各业的今天，你是否也面临这样的困境：想调用 GPT-5、Claude4.5等顶尖模型却被海外注册、跨平台适配搞得焦头烂额？想快速搭建智能客服、内容生成工具，却因模型接口差异、成本不可控而望而却步？或是作为中小团队，既想享受 AI 红利，又受限于技术门槛和预算压力？</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aiionly.com%2Flogin%3FinviteCode%3D0047994" target="_blank" title="https://www.aiionly.com/login?inviteCode=0047994" ref="nofollow noopener noreferrer">AiOnly平台</a>的出现，正是为了打破这些壁垒。</p>
<p>本文将从实战角度出发，带你全方位解锁这个「全球顶尖大模型 MaaS 平台」：从 5 分钟完成注册到 API 密钥创建，从单模型调用到融合 RAG 知识库的智能体开发，然后手把手教你在 Windows 环境部署一个日均成本不足 0.5 元的电商客服机器人。无论你是 AI 开发者、企业运营者，还是想低成本尝试 AI 应用的新手，都能在这里找到从「想法」到「落地」的完整路径 —— 无需纠结底层技术，专注用 AI 解决实际问题。</p>
<h3 data-id="heading-1">第一部分：平台概览</h3>
<h4 data-id="heading-2">1.1 平台定位与核心价值</h4>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aiionly.com%2Flogin%3FinviteCode%3D0047994" target="_blank" title="https://www.aiionly.com/login?inviteCode=0047994" ref="nofollow noopener noreferrer">AiOnly</a> 是<strong>全球顶尖大模型 MaaS（模型即服务）平台</strong>，核心定位是 “降低模型应用门槛，加速场景智能化进程”，通过 “一键调用、敏捷开发” 的核心设计，将全球前沿模型（如 GPT-5、Claude 4.5）整合为标准化 API 接口与模块化 “智能积木”，让开发者无需关注底层技术细节，即可快速集成 AI 能力。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed90c65253ab42e3b746e7fc7a56dafb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=QK9%2BXlWYUNwuI5lAqvxTKgbid9Q%3D" alt="image.png" loading="lazy"/></p>
<p>其核心优势可概括为四点：</p>
<ul>
<li><strong>高效便捷</strong>：免海外模型开户、免跨平台注册，高速专线支持，开箱即用（如调用 GPT-5 无需 OpenAI 账号）；</li>
<li><strong>价格友好</strong>：按量计费（Token / 次数），价格低于官方刊例价，支持 “先用后付” 与 “优惠量包”，新人首充 1 元可享 100 元权益；</li>
<li><strong>类型全面</strong>：覆盖文本、图像、视频、语音、多模态全场景模型，海外（GPT/Claude/Gemini）与国产（DeepSeek/Qwen/Doubao）模型兼备；</li>
<li><strong>稳定流畅</strong>：官方正规授权，API 接口标准化兼容原厂全参数，SLA 达 99.9%，保障生产环境稳定运行。</li>
</ul>
<h4 data-id="heading-3">1.2 平台特色功能亮点</h4>
<ol>
<li>
<p><strong>统一 API 与密钥管理</strong>：一个 API Key 可调用多模型，支持 “标准模式”（基础 API）与 “融合模式”（关联组件 / 知识库），分应用创建密钥便于权限管控；</p>
</li>
<li>
<p><strong>增强开发工具</strong>：</p>
<ul>
<li><strong>Prompt 优解</strong>：自动优化提示词结构，提升模型推理准确率；</li>
<li><strong>RAG 知识库管理</strong>：多源数据（文档 / 表格）智能清洗 + 向量检索，实现精准问答；</li>
<li><strong>组件商店</strong>：三方集成 Claude Code、Dify（智能体平台）、WPS AI 等三方工具，无需额外开发；</li>
</ul>
</li>
<li>
<p><strong>精细化运营工具</strong>：实时调用统计（Token 消耗监控）、开通管理（量包使用状态）、财务计费（账单明细），降低企业成本管控难度；</p>
</li>
</ol>
<h3 data-id="heading-4">第二部分：AiOnly 平台使用详解</h3>
<h4 data-id="heading-5">2.1 平台注册与 API Key 创建（完整操作步骤）</h4>
<h5 data-id="heading-6">步骤 1：注册与登录（5 分钟完成）</h5>
<ol>
<li>访问官方平台：PC 端打开 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aiionly.com%2Flogin%3FinviteCode%3D0047994" target="_blank" title="https://www.aiionly.com/login?inviteCode=0047994" ref="nofollow noopener noreferrer">AiOnly官网</a></strong></li>
<li>点击右上角「登录 / 注册」，新用户<strong>必须选择 “手机号验证码登录”</strong>（首次注册需完成手机号验证），支持支付宝 / 微信快捷登录（老用户）；</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3beae11c805049ddaaae5bedb56643b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=793clJPonIImi8awruuEwRrMw9E%3D" alt="image.png" loading="lazy"/></p>
<ol start="3">
<li>登录后点击顶部「控制台」，进入核心操作页面（模型开通、Key 管理、财务等功能聚合于此）；
<ul>
<li>注意：新用户登录后自动发放 15 元代金券，金币与 RMB 1:1 等值，可直接抵扣模型调用费用。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d316e2de04bd48008841777a72522bf2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=ZFO%2FoNnm9hpKEldSf2xpud2zJng%3D" alt="image.png" loading="lazy"/></li>
</ul>
</li>
</ol>
<h5 data-id="heading-7">步骤 2：模型服务开通（以 GPT-5 为例）</h5>
<ol>
<li>
<p>进入模型广场：控制台左侧导航栏点击「模型广场」，或首页直接选择 “热门模型”→“GPT-5”；
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f31f6ee57aa844a5b1c2f5d5dc6cdf47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=SQlmR7XC3jaB8x6oMzCOl2pWYAY%3D" alt="image.png" loading="lazy"/></p>
</li>
<li>
<p>选择开通方式（二选一）：</p>
<ul>
<li><strong>先用后付</strong>：按实际 Token 消耗计费</li>
<li><strong>优惠量包</strong>：点击 “优惠量包” 切换页面，选择对应套餐</li>
</ul>
</li>
</ol>
<p>这里我们先选择先用后付进行测试
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3eb90003ecb24232a9efe332c99afb02~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=emagHTkKvCopT8b5MM8nAf9ycu0%3D" alt="image.png" loading="lazy"/></p>
<ol start="2">
<li>支付订单：
<ul>
<li>支持 “金币余额支付”（控制台「财务」→「余额充值」可补充金币）或 “现金支付”（微信 / 支付宝）；</li>
<li>勾选《AiOnly 服务订购协议》，点击「确认支付」；</li>
</ul>
</li>
<li>验证开通状态：支付成功后，进入控制台「开通管理」，若模型 “服务状态” 显示 “运行中”，即表示可正常调用。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76911c37d31642ea9fb6cd5b7a7c947c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=Nn4tq%2FhghZ6Wwq4xNM1fXCEdw1c%3D" alt="image.png" loading="lazy"/></li>
</ol>
<h5 data-id="heading-8">步骤 3：API Key 创建与 API URL 获取（核心凭证）</h5>
<ol>
<li>
<p><strong>API Key 创建（务必保密）</strong>：</p>
<ul>
<li>
<p>控制台左侧点击「API Key」→「新增 API Key」；
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/72b4abebf404466987fc0267cb2bce3a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=qLXCzwmPLMwZfZvE6wpdqQ3QP8c%3D" alt="image.png" loading="lazy"/></p>
</li>
<li>
<p>填写基础信息：</p>
<ul>
<li>类型：「标准模式」（仅调用基础模型 API）</li>
<li>名称：自定义别名（如 “GPT-5 客服项目 Key”）；</li>
<li>描述：可选，记录用途（如 “生产环境 - 电商客服机器人”）；</li>
</ul>
</li>
<li>
<p>点击「保存」，生成专属 API Key（长期生效，<strong>切勿公开分享</strong>，避免未授权调用导致经济损失）；
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d92628aa2cf440119807ca00a6dee42b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=%2FLLqYyQFOdYWMbUzNqSJUNhlntU%3D" alt="image.png" loading="lazy"/></p>
</li>
</ul>
</li>
<li>
<p><strong>API URL 获取（按功能区分）</strong>：</p>
<ul>
<li>
<p>方式 1：「开通管理」页面右上角点击 “接口 URL 地址”，获取当前模型的专属接口；
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fbb7b646760f4f10965546a15904a982~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=pj130XbZYl6nT0qjM9XW%2F1DTzMI%3D" alt="image.png" loading="lazy"/></p>
</li>
<li>
<p>方式 2：参考官方标准化接口（常用地址如下）：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/863d39fa8d3f4794b59ee8c0d36f7429~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=ktjBK%2BILDT5NzdaUIUF1PgkbOYg%3D" alt="image.png" loading="lazy"/></p>
</li>
</ul>
</li>
</ol>
<h4 data-id="heading-9">2.2 API 密钥管理与安全注意事项</h4>
<ul>
<li><strong>分场景隔离</strong>：为测试环境、生产环境创建独立 API Key（如 “GPT-5 - 测试 Key”“GPT-5 - 生产 Key”），避免测试误操作影响生产；</li>
<li><strong>安全防护</strong>：
<ul>
<li>不硬编码 API Key（通过环境变量或配置文件加载）；</li>
<li>不存储于公开代码仓库（如 GitHub）；</li>
<li>不通过邮件、即时通讯工具随意发送；</li>
</ul>
</li>
<li><strong>异常监控</strong>：通过「调用统计」实时查看 Key 的 Token 消耗，若发现异常波动（如突然激增），立即进入「API Key」页面点击 “停用”；</li>
<li><strong>权限最小化</strong>：非必要不使用 “融合模式” Key，避免权限过度开放导致风险。</li>
</ul>
<h4 data-id="heading-10">2.3 API 调用流程（Python 实战示例）</h4>
<p>以 “调用 GPT-5 实现文本对话” 为例，完整流程如下：</p>
<h5 data-id="heading-11">前提条件</h5>
<ul>
<li>已开通 GPT-5 模型服务（「开通管理」中状态为 “运行中”）；</li>
<li>已获取 API Key 与文本对话接口 URL；</li>
<li>本地环境：Python 3.7+（或其他支持 HTTP 请求的语言）。</li>
</ul>
<h5 data-id="heading-12">步骤 1：环境准备</h5>
<ol>
<li>
<p>安装依赖库（使用<code>requests</code>发送 HTTP 请求）：</p>
<pre><code class="hljs language-bash" lang="bash">pip install requests python-dotenv
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f508771bc3514b5e88ed50e56d0f7574~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=YaZs2xGlPfcXfCbhrqSENw4EpJE%3D" alt="a9bf9279c154ddb390d03b738cb78eec.png" loading="lazy"/></p>
</li>
<li>
<p>创建<code>.env</code>配置文件（避免硬编码 Key）：</p>
<pre><code class="hljs language-env" lang="env">AIONLY_API_KEY=your_api_key_here  # 替换为你的API Key
AIONLY_CHAT_URL=https://api.aiionly.com/v1/chat/completions
</code></pre>
</li>
</ol>
<h5 data-id="heading-13">步骤 2：编写调用代码</h5>
<p>运行</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv

<span class="hljs-comment"># 1. 加载配置</span>
load_dotenv()
API_KEY = os.getenv(<span class="hljs-string">"AIONLY_API_KEY"</span>)
API_URL = os.getenv(<span class="hljs-string">"AIONLY_CHAT_URL"</span>)
HEADERS = {
    <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">f"Bearer <span class="hljs-subst">{API_KEY}</span>"</span>,  <span class="hljs-comment"># 固定格式：Bearer + 空格 + API Key</span>
    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>
}

<span class="hljs-comment"># 2. 构造请求参数（Prompt设计）</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">build_chat_payload</span>(<span class="hljs-params">user_message, system_prompt=<span class="hljs-string">"你是专业的AI助手，回答简洁准确"</span></span>):
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">"model"</span>: <span class="hljs-string">"gpt-5"</span>,  <span class="hljs-comment"># 必须与开通的模型名称一致</span>
        <span class="hljs-string">"messages"</span>: [
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: system_prompt},  <span class="hljs-comment"># 系统指令（定义角色）</span>
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: user_message}       <span class="hljs-comment"># 用户输入</span>
        ],
        <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.7</span>,  <span class="hljs-comment"># 随机性：0（严谨）~1（创意）</span>
        <span class="hljs-string">"max_tokens"</span>: <span class="hljs-number">512</span>    <span class="hljs-comment"># 最大输出Token数（避免超长回复）</span>
    }

<span class="hljs-comment"># 3. 发送请求并解析结果</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">call_aionly_chat</span>(<span class="hljs-params">user_message</span>):
    payload = build_chat_payload(user_message)
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 发送POST请求</span>
        response = requests.post(API_URL, headers=HEADERS, json=payload)
        response.raise_for_status()  <span class="hljs-comment"># 捕获HTTP错误（如401密钥无效、403权限不足）</span>
        
        <span class="hljs-comment"># 解析响应</span>
        result = response.json()
        reply = result[<span class="hljs-string">"choices"</span>][<span class="hljs-number">0</span>][<span class="hljs-string">"message"</span>][<span class="hljs-string">"content"</span>]  <span class="hljs-comment"># 机器人回复</span>
        token_usage = result[<span class="hljs-string">"usage"</span>]  <span class="hljs-comment"># Token消耗统计（输入+输出）</span>
        
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">"success"</span>: <span class="hljs-literal">True</span>,
            <span class="hljs-string">"reply"</span>: reply,
            <span class="hljs-string">"token_used"</span>: token_usage[<span class="hljs-string">"total_tokens"</span>],
            <span class="hljs-string">"prompt_tokens"</span>: token_usage[<span class="hljs-string">"prompt_tokens"</span>],
            <span class="hljs-string">"completion_tokens"</span>: token_usage[<span class="hljs-string">"completion_tokens"</span>]
        }
    <span class="hljs-keyword">except</span> requests.exceptions.RequestException <span class="hljs-keyword">as</span> e:
        <span class="hljs-comment"># 错误处理</span>
        error_msg = <span class="hljs-built_in">str</span>(e)
        <span class="hljs-keyword">if</span> response:
            error_msg += <span class="hljs-string">f" | 错误详情：<span class="hljs-subst">{response.json()}</span>"</span>
        <span class="hljs-keyword">return</span> {<span class="hljs-string">"success"</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">"error"</span>: error_msg}

<span class="hljs-comment"># 4. 测试调用</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    user_input = <span class="hljs-string">"用Python写一个快速排序算法，带注释"</span>
    result = call_aionly_chat(user_input)
    <span class="hljs-keyword">if</span> result[<span class="hljs-string">"success"</span>]:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"AI回复：\n"</span>, result[<span class="hljs-string">"reply"</span>])
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\nToken消耗：总计<span class="hljs-subst">{result[<span class="hljs-string">'token_used'</span>]}</span>（输入<span class="hljs-subst">{result[<span class="hljs-string">'prompt_tokens'</span>]}</span>+输出<span class="hljs-subst">{result[<span class="hljs-string">'completion_tokens'</span>]}</span>）"</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"调用失败："</span>, result[<span class="hljs-string">"error"</span>])
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f4c5c626a55b4b53b6488d7ab693cd51~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=max0dWs9YSSr1gDedDowTvAXAMs%3D" alt="00fe8142-a922-46b7-863e-bd0ee120e981.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34d4342ffb0746e095ec134d5cec12a5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=cJqHB%2FTron%2FUeofyyRfsMeGEyX8%3D" alt="image.png" loading="lazy"/></p>
<p>可以看到和我们在平台-调用统计看到的结果是一致的
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2583a76d04f349f4ad8e4f2891bdf2e0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=J2eVDN8I1BJkmEQY4GfRPHBuwKs%3D" alt="image.png" loading="lazy"/></p>
<h5 data-id="heading-14">步骤 3：常见问题排查</h5>

























<table><thead><tr><th>错误码</th><th>可能原因</th><th>解决方案</th></tr></thead><tbody><tr><td>401</td><td>API Key 错误 / 已停用</td><td>检查 Key 是否正确，进入「API Key」确认状态</td></tr><tr><td>403</td><td>模型未开通 / Key 权限不匹配（如标准 Key 调用融合功能）</td><td>「开通管理」确认模型状态，重新创建对应类型 Key</td></tr><tr><td>429</td><td>QPS 超限（超过模型设定的并发限制）</td><td>降低调用频率，或联系客服提升 QPS</td></tr></tbody></table>
<h3 data-id="heading-15">第三部分：实战应用案例 —— 智能客服机器人开发</h3>
<h4 data-id="heading-16">3.1 项目背景与技术栈</h4>
<h5 data-id="heading-17">应用场景</h5>
<p>电商平台轻量化智能客服工具，聚焦<strong>订单查询、售后咨询、产品推荐</strong>等核心需求，适合中小商家快速部署，无需专业服务器维护，本地 Windows 环境即可运行，单日成本可控制在 0.5 元以内。</p>
<h5 data-id="heading-18">技术栈选型</h5>



































<table><thead><tr><th>模块</th><th>选型理由</th><th/></tr></thead><tbody><tr><td>核心接口</td><td>AiOnly API（GPT-5+RAG 知识库）</td><td>保持多模型兼容与知识库检索能力，降低开发复杂度</td></tr><tr><td>后端框架</td><td>Flask（轻量 Web 框架）</td><td>适合 Windows 环境快速启动，无需复杂配置</td></tr><tr><td>会话缓存</td><td>内存字典（Python 内置）</td><td>替代 Redis 存储对话上下文，简化部署（仅适合小规模使用）</td></tr><tr><td>前端</td><td>HTML+CSS+JavaScript</td><td>保留响应式界面，支持本地浏览器访问</td></tr><tr><td>运行环境</td><td>Windows 10/11 + Python 3.13.5</td><td>无需服务器，个人电脑即可部署测试</td></tr></tbody></table>
<h4 data-id="heading-19">3.2 核心功能设计</h4>
<ol>
<li><strong>基础多轮对话</strong>：通过内存字典存储用户历史对话（最多保留 10 轮），支持上下文关联（如连续咨询同一订单问题）；</li>
<li><strong>智能 RAG 融合</strong>：使用与知识库绑定的“融合模式” API Key，平台自动检索并融入知识库上下文，生成更精准回复；</li>
<li><strong>轻量化部署</strong>：无需安装数据库和服务器软件，Python 脚本直接运行，适合非技术人员操作。</li>
</ol>
<h4 data-id="heading-20">3.3 完整实现步骤（Windows 环境适配）</h4>
<h5 data-id="heading-21">步骤 1：AiOnly RAG 知识库创建（控制台操作）</h5>
<ol>
<li>
<p>进入知识库管理：控制台左侧点击「知识库管理」→「新建知识库」，命名 “电商客服 FAQ”；
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e70dcb32aea94d6cba5c6df490e0c5d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=MQWB492gTV%2FW2lj2uZ7SfnCwHVc%3D" alt="image.png" loading="lazy"/>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bdd2afd3c2b54a278ecf322379f0e235~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=CIBMaCKxvEcgZDM1nNXZP3Hk3Go%3D" alt="image.png" loading="lazy"/></p>
</li>
<li>
<p>上传 FAQ 数据：支持上传文档（.md/.docx）、表格（.xlsx），示例数据如下（“退款政策.md”）：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 电商客服FAQ</span>
<span class="hljs-bullet">1.</span> 退款申请后多久到账？
答：退款将在1-3个工作日内原路返回，具体到账时间以银行为准。

<span class="hljs-bullet">2.</span> 订单发货时间？
答：普通商品48小时内发货，预售商品以详情页标注时间为准。

<span class="hljs-bullet">3.</span> 如何修改收货地址？
答：订单发货前可在“我的订单”→“修改地址”中操作；已发货需联系快递拦截。
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c5496985cc1475591b97993586fa227~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=ZM6r1jCUcqYbM9dk7ra%2BCA33No0%3D" alt="image.png" loading="lazy"/></p>
</li>
</ol>
<h5 data-id="heading-22">步骤 2：创建融合模式 API Key（关键步骤）</h5>
<ul>
<li>
<p>进入「API Key」→「新增 API Key」，类型选择“融合模式”。</p>
</li>
<li>
<p>在“知识库”配置中选择“电商客服 FAQ”，开启绑定。</p>
</li>
<li>
<p>保存生成的 Key，并在 <code>.env</code> 中替换 <code>AIONLY_API_KEY</code>。</p>
</li>
<li>
<p>融合模式 Key 会自动在调用时进行知识库检索与上下文融合，无需手动检索接口。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8895932959bc437a8feeb7da2176f068~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=uz9HnDEOwAF1ZafmxYeLd4ofgvM%3D" alt="image.png" loading="lazy"/></p>
</li>
</ul>
<h5 data-id="heading-23">步骤 3：项目结构与代码实现</h5>
<h6 data-id="heading-24">3.1 项目结构</h6>
<pre><code class="hljs language-plaintext" lang="plaintext">ecommerce-ai-chatbot/
├── app.py          # Flask主程序（含会话管理）
├── aionly_client.py# AiOnly API客户端
├── .env            # 配置文件
├── requirements.txt# 依赖库
└── templates/
    └── index.html  # 前端界面
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/878aa812bf3f4523868caaf128682a44~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=FkTg3vlVP7vPqUKwCaNQ7lej7f0%3D" alt="5283e441-5cd2-4299-beb6-72e550218086.png" loading="lazy"/></p>
<h6 data-id="heading-25">3.2 依赖库配置（requirements.txt）</h6>
<pre><code class="hljs language-plaintext" lang="plaintext">flask==2.3.3
requests==2.31.0
python-dotenv==1.0.0
</code></pre>
<h6 data-id="heading-26">3.3 配置文件更新 (.env)</h6>
<pre><code class="hljs language-env" lang="env">AIONLY_API_KEY=your_fusion_mode_api_key_here
AIONLY_CHAT_URL=https://api.aiionly.com/v1/chat/completions
</code></pre>
<h6 data-id="heading-27">3.4 AiOnly API 客户端（aionly_client.py）</h6>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv

<span class="hljs-comment"># 全局内存存储用户对话历史（替代Redis）</span>
user_history = {}  <span class="hljs-comment"># 格式：{user_id: [{"role": "...", "content": "..."}, ...]}</span>

load_dotenv()

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AiOnlyClient</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.api_key = os.getenv(<span class="hljs-string">"AIONLY_API_KEY"</span>)
        self.chat_url = os.getenv(<span class="hljs-string">"AIONLY_CHAT_URL"</span>)
        self.headers = {
            <span class="hljs-string">"Authorization"</span>: <span class="hljs-string">f"Bearer <span class="hljs-subst">{self.api_key}</span>"</span>,
            <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>
        }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">retrieve_knowledge</span>(<span class="hljs-params">self, user_message</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_chat_reply</span>(<span class="hljs-params">self, user_id, user_message</span>):
        <span class="hljs-string">"""获取AI回复（含内存对话管理）"""</span>
        <span class="hljs-comment"># 1. 初始化/获取用户历史</span>
        <span class="hljs-keyword">if</span> user_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> user_history:
            user_history[user_id] = []
        
        messages = [
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"你是电商AI客服，请根据知识库内容和用户问题，友好地回答。"</span>}
        ] + user_history[user_id] + [{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: user_message}]
        
        payload = {
            <span class="hljs-string">"model"</span>: <span class="hljs-string">"gpt-5"</span>,
            <span class="hljs-string">"messages"</span>: messages,
            <span class="hljs-string">"temperature"</span>: <span class="hljs-number">0.6</span>,
            <span class="hljs-string">"max_tokens"</span>: <span class="hljs-number">1024</span>
        }
        
        <span class="hljs-keyword">try</span>:
            response = requests.post(self.chat_url, headers=self.headers, json=payload)
            response.raise_for_status()
            result = response.json()
            
            reply = result[<span class="hljs-string">"choices"</span>][<span class="hljs-number">0</span>][<span class="hljs-string">"message"</span>][<span class="hljs-string">"content"</span>]
            token_used = result[<span class="hljs-string">"usage"</span>][<span class="hljs-string">"total_tokens"</span>]
            
            <span class="hljs-comment"># 更新历史</span>
            user_history[user_id].append({<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: user_message})
            user_history[user_id].append({<span class="hljs-string">"role"</span>: <span class="hljs-string">"assistant"</span>, <span class="hljs-string">"content"</span>: reply})
            user_history[user_id] = user_history[user_id][-<span class="hljs-number">20</span>:]
            
            <span class="hljs-keyword">return</span> {<span class="hljs-string">"success"</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">"reply"</span>: reply, <span class="hljs-string">"token_used"</span>: token_used}
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            error_msg = <span class="hljs-built_in">str</span>(e)
            <span class="hljs-keyword">if</span> response:
                error_msg += <span class="hljs-string">f" | <span class="hljs-subst">{response.json()}</span>"</span>
            <span class="hljs-keyword">return</span> {<span class="hljs-string">"success"</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">"error"</span>: error_msg}

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_user_history</span>(<span class="hljs-params">self, user_id</span>):
        <span class="hljs-string">"""清除用户历史（内存版）"""</span>
        <span class="hljs-keyword">if</span> user_id <span class="hljs-keyword">in</span> user_history:
            <span class="hljs-keyword">del</span> user_history[user_id]
</code></pre>
<h6 data-id="heading-28">3.5 Flask 主程序（app.py）</h6>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonify, render_template
<span class="hljs-keyword">import</span> uuid
<span class="hljs-keyword">from</span> aionly_client <span class="hljs-keyword">import</span> AiOnlyClient

app = Flask(__name__)
ai_client = AiOnlyClient()

<span class="hljs-comment"># 1. 前端界面</span>
<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">"/"</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():
    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">"index.html"</span>)

<span class="hljs-comment"># 2. 对话API</span>
<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">"/api/chat"</span>, methods=[<span class="hljs-string">"POST"</span>]</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">chat</span>():
    data = request.json
    user_id = data.get(<span class="hljs-string">"user_id"</span>)
    user_message = data.get(<span class="hljs-string">"message"</span>, <span class="hljs-string">""</span>).strip()
    
    <span class="hljs-comment"># 生成用户ID（首次访问）</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user_id:
        user_id = <span class="hljs-built_in">str</span>(uuid.uuid4())
    
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user_message:
        <span class="hljs-keyword">return</span> jsonify({<span class="hljs-string">"success"</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">"error"</span>: <span class="hljs-string">"请输入有效消息"</span>})
    
    <span class="hljs-comment"># 获取回复</span>
    result = ai_client.get_chat_reply(user_id, user_message)
    result[<span class="hljs-string">"user_id"</span>] = user_id
    <span class="hljs-keyword">return</span> jsonify(result)

<span class="hljs-comment"># 3. 清除历史API</span>
<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">"/api/clear-history"</span>, methods=[<span class="hljs-string">"POST"</span>]</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_history</span>():
    data = request.json
    user_id = data.get(<span class="hljs-string">"user_id"</span>)
    <span class="hljs-keyword">if</span> user_id:
        ai_client.clear_user_history(user_id)
        <span class="hljs-keyword">return</span> jsonify({<span class="hljs-string">"success"</span>: <span class="hljs-literal">True</span>})
    <span class="hljs-keyword">return</span> jsonify({<span class="hljs-string">"success"</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">"error"</span>: <span class="hljs-string">"user_id不能为空"</span>}), <span class="hljs-number">400</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># Windows环境直接运行，默认端口5000</span>
    app.run(host=<span class="hljs-string">"127.0.0.1"</span>, port=<span class="hljs-number">5000</span>, debug=<span class="hljs-literal">True</span>)
</code></pre>
<h6 data-id="heading-29">3.6 前端界面（templates/index.html）</h6>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>电商AI客服<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        * { <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">box-sizing</span>: border-box; }
        <span class="hljs-selector-tag">body</span> { <span class="hljs-attribute">font-family</span>: Arial, sans-serif; <span class="hljs-attribute">max-width</span>: <span class="hljs-number">800px</span>; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>; }
        <span class="hljs-selector-class">.chat-container</span> { <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>; <span class="hljs-attribute">overflow</span>: hidden; }
        <span class="hljs-selector-class">.chat-header</span> { <span class="hljs-attribute">background</span>: <span class="hljs-number">#2272f9</span>; <span class="hljs-attribute">color</span>: white; <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span>; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>; }
        <span class="hljs-selector-class">.chat-history</span> { <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>; <span class="hljs-attribute">overflow-y</span>: auto; <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span>; <span class="hljs-attribute">background</span>: <span class="hljs-number">#fafafa</span>; }
        <span class="hljs-selector-class">.message</span> { <span class="hljs-attribute">margin</span>: <span class="hljs-number">8px</span> <span class="hljs-number">0</span>; <span class="hljs-attribute">max-width</span>: <span class="hljs-number">70%</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span>; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>; <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>; }
        <span class="hljs-selector-class">.user-message</span> { <span class="hljs-attribute">background</span>: <span class="hljs-number">#2272f9</span>; <span class="hljs-attribute">color</span>: white; <span class="hljs-attribute">margin-left</span>: auto; }
        <span class="hljs-selector-class">.ai-message</span> { <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>; <span class="hljs-attribute">margin-right</span>: auto; }
        <span class="hljs-selector-class">.system-message</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>; <span class="hljs-attribute">text-align</span>: center; <span class="hljs-attribute">margin</span>: <span class="hljs-number">8px</span> <span class="hljs-number">0</span>; }
        <span class="hljs-selector-class">.input-container</span> { <span class="hljs-attribute">display</span>: flex; <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>; }
        <span class="hljs-selector-id">#message-input</span> { <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span> <span class="hljs-number">16px</span>; <span class="hljs-attribute">border</span>: none; <span class="hljs-attribute">outline</span>: none; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>; }
        <span class="hljs-selector-id">#send-btn</span> { <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">24px</span>; <span class="hljs-attribute">background</span>: <span class="hljs-number">#2272f9</span>; <span class="hljs-attribute">color</span>: white; <span class="hljs-attribute">border</span>: none; <span class="hljs-attribute">cursor</span>: pointer; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>; }
        <span class="hljs-selector-id">#clear-btn</span> { <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">16px</span>; <span class="hljs-attribute">background</span>: <span class="hljs-number">#ff4444</span>; <span class="hljs-attribute">color</span>: white; <span class="hljs-attribute">border</span>: none; <span class="hljs-attribute">cursor</span>: pointer; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>; }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"chat-container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"chat-header"</span>&gt;</span>AiOnly电商AI客服（7×24小时在线）<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"chat-history"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"chat-history"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"system-message"</span>&gt;</span>欢迎咨询，我可以帮您查询订单、处理售后问题~<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input-container"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"message-input"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入您的问题（如：退款多久到账？）"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"clear-btn"</span>&gt;</span>清除历史<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"send-btn"</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// 从本地存储获取用户ID（避免刷新丢失）</span>
        <span class="hljs-keyword">let</span> userId = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">"ecommerce_chat_userid"</span>);
        <span class="hljs-keyword">const</span> chatHistory = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"chat-history"</span>);
        <span class="hljs-keyword">const</span> messageInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"message-input"</span>);
        <span class="hljs-keyword">const</span> sendBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"send-btn"</span>);
        <span class="hljs-keyword">const</span> clearBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"clear-btn"</span>);

        <span class="hljs-comment">// 添加消息到界面</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">addMessage</span>(<span class="hljs-params">content, isUser = <span class="hljs-literal">false</span></span>) {
            <span class="hljs-keyword">const</span> messageDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
            messageDiv.<span class="hljs-property">className</span> = isUser ? <span class="hljs-string">"message user-message"</span> : <span class="hljs-string">"message ai-message"</span>;
            messageDiv.<span class="hljs-property">textContent</span> = content;
            chatHistory.<span class="hljs-title function_">appendChild</span>(messageDiv);
            <span class="hljs-comment">// 滚动到底部</span>
            chatHistory.<span class="hljs-property">scrollTop</span> = chatHistory.<span class="hljs-property">scrollHeight</span>;
        }

        <span class="hljs-comment">// 发送消息</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">const</span> message = messageInput.<span class="hljs-property">value</span>.<span class="hljs-title function_">trim</span>();
            <span class="hljs-keyword">if</span> (!message) <span class="hljs-keyword">return</span>;

            <span class="hljs-comment">// 显示用户消息</span>
            <span class="hljs-title function_">addMessage</span>(message, isUser = <span class="hljs-literal">true</span>);
            messageInput.<span class="hljs-property">value</span> = <span class="hljs-string">""</span>;

            <span class="hljs-comment">// 调用后端API</span>
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"/api/chat"</span>, {
                    <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
                    <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span> },
                    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">user_id</span>: userId, <span class="hljs-attr">message</span>: message })
                });
                <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();

                <span class="hljs-comment">// 保存用户ID</span>
                userId = result.<span class="hljs-property">user_id</span>;
                <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">"ecommerce_chat_userid"</span>, userId);

                <span class="hljs-comment">// 显示AI回复</span>
                <span class="hljs-keyword">if</span> (result.<span class="hljs-property">success</span>) {
                    <span class="hljs-title function_">addMessage</span>(result.<span class="hljs-property">reply</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-title function_">addMessage</span>(<span class="hljs-string">`抱歉，服务暂时 unavailable：<span class="hljs-subst">${result.error}</span>`</span>, isUser = <span class="hljs-literal">false</span>);
                }
            } <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-title function_">addMessage</span>(<span class="hljs-string">"网络错误，请稍后再试"</span>, isUser = <span class="hljs-literal">false</span>);
            }
        }

        <span class="hljs-comment">// 清除历史</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">clearHistory</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (userId) {
                <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"/api/clear-history"</span>, {
                    <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
                    <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span> },
                    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">user_id</span>: userId })
                });
            }
            chatHistory.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">'&lt;div class="system-message"&gt;欢迎咨询，我可以帮您查询订单、处理售后问题~&lt;/div&gt;'</span>;
            <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">"ecommerce_chat_userid"</span>);
            userId = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-comment">// 绑定事件</span>
        sendBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, sendMessage);
        messageInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"keypress"</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">"Enter"</span>) <span class="hljs-title function_">sendMessage</span>();
        });
        clearBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, clearHistory);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h5 data-id="heading-30">步骤 3：Windows 环境部署与运行</h5>
<h6 data-id="heading-31">3.1 环境准备</h6>
<ol>
<li>
<p><strong>安装 Python 3.13.5</strong>：</p>
<ul>
<li>访问Python 官网下载对应 Windows 安装包</li>
<li>安装时勾选 “Add Python to PATH”，完成后打开命令提示符（Win+R→cmd）</li>
<li>验证安装：<code>python --version</code> 显示 3.13.5 即为成功</li>
</ul>
</li>
<li>
<p><strong>创建项目文件夹</strong>：</p>
<pre><code class="hljs language-cmd" lang="cmd">mkdir C:\ecommerce-ai-chatbot
cd C:\ecommerce-ai-chatbot
</code></pre>
</li>
<li>
<p><strong>创建配置文件</strong>：</p>
<ul>
<li>
<p>在文件夹中新建<code>.env</code>文件，内容如下：</p>
<pre><code class="hljs language-env" lang="env">AIONLY_API_KEY=你的API密钥
AIONLY_CHAT_URL=https://api.aiionly.com/v1/chat/completions
</code></pre>
</li>
</ul>
</li>
</ol>
<h6 data-id="heading-32">3.2 安装依赖与启动服务</h6>
<ol>
<li>
<p><strong>安装依赖库</strong>：</p>
<pre><code class="hljs language-cmd" lang="cmd">pip install -r requirements.txt
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d89a3d2f81154541a926f51251aea661~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=ogZIqGUG6KTWM%2B7ltv%2FmW%2F1CYj8%3D" alt="image.png" loading="lazy"/></p>
<p>（若提示 pip 版本问题，先运行<code>python -m pip install --upgrade pip</code>）</p>
</li>
<li>
<p><strong>启动服务</strong>：</p>
<pre><code class="hljs language-cmd" lang="cmd">python app.py
</code></pre>
<p>看到类似以下输出即为成功：</p>
<pre><code class="hljs language-plaintext" lang="plaintext">* Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
</code></pre>
<p>PS：警告忽略即可
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3d920bb43e6461693c326f557df6cf0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=a9gbUxqfG6W918z6%2FG96qr%2Fu4d4%3D" alt="image.png" loading="lazy"/></p>
</li>
<li>
<p><strong>访问客服界面</strong>：</p>
<ul>
<li>打开浏览器，输入<code>http://127.0.0.1:5000</code></li>
<li>即可开始使用智能客服（关闭命令提示符即停止服务）</li>
</ul>
</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e0f1acbd5f84a669a89b209755af848~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=GOulT2JYY6Y4GsMqCCQTp%2FXhCPk%3D" alt="" loading="lazy"/>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d1dd01602e6044c990065e75b8474cd1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976403&amp;x-signature=MQKWQypp15wbnxs5h7Zx85yTHwM%3D" alt="bace6d42b13227970f67168a34d8b873.png" loading="lazy"/></p>
<h4 data-id="heading-33">3.4 效果展示与适用场景</h4>
<h5 data-id="heading-34">功能测试结果</h5>





























<table><thead><tr><th>测试场景</th><th>实际效果</th><th>耗时</th><th>准确率</th></tr></thead><tbody><tr><td>FAQ 匹配（“退款到账时间”）</td><td>直接返回知识库答案</td><td>&lt;200ms</td><td>100%</td></tr><tr><td>多轮对话（“查订单→改地址”）</td><td>基于内存历史保持上下文理解</td><td>300-400ms</td><td>90%</td></tr><tr><td>复杂问题（“推荐性价比高的商品”）</td><td>调用 GPT-5 生成个性化推荐</td><td>400-600ms</td><td>85%</td></tr></tbody></table>
<h5 data-id="heading-35">适用场景</h5>
<ul>
<li>个人卖家或小团队：无需服务器，本地电脑即可部署，日均成本≈0.3 元</li>
<li>临时活动客服：促销期间快速上线，活动结束后直接关闭，无资源浪费</li>
<li>测试验证：快速验证 AI 客服效果，再决定是否扩展为企业级方案</li>
</ul>
<h5 data-id="heading-36">局限性说明</h5>
<ul>
<li>内存存储对话历史，重启服务后丢失（适合临时使用）</li>
<li>不支持高并发（建议同时在线用户≤10 人）</li>
<li>需保持命令提示符窗口开启（可最小化，不可关闭）</li>
</ul>
<h3 data-id="heading-37">第四部分：结语</h3>
<h4 data-id="heading-38">4.1 平台核心优势总结</h4>
<ol>
<li><strong>接入门槛极低</strong>：无需技术背景也能 10 分钟完成注册→开通模型→API 调用，开发者无需适配不同模型的接口差异；</li>
<li><strong>成本可控性强</strong>：按量计费 + 优惠量包 + 新人福利，大幅降低试错成本</li>
<li><strong>场景覆盖全面</strong>：从个人 AIGC 创作（图片 / 视频生成）到企业级智能体开发（客服 / 数据分析），全链路需求均可满足；</li>
<li><strong>技术支撑完善</strong>：标准化 API + 专业工单客服 + RAG/Prompt 优解工具，开发者专注业务逻辑，无需关注模型维护。</li>
</ol>
<h4 data-id="heading-39">4.2 适用人群与场景</h4>






























<table><thead><tr><th>人群 / 角色</th><th>推荐场景</th><th>核心价值</th></tr></thead><tbody><tr><td>AI 开发者</td><td>智能客服、代码助手、多模态交互系统</td><td>快速集成多模型，降低开发成本</td></tr><tr><td>内容创作者</td><td>短视频脚本生成、图片素材制作、文案撰写</td><td>提升创作效率，降低素材成本</td></tr><tr><td>企业运营 / 客服团队</td><td>7×24 小时智能客服、客户问题自动分类</td><td>替代 30% 人工工作，降低运营成本</td></tr><tr><td>高校科研人员</td><td>前沿模型实验、学术数据分析、论文辅助撰写</td><td>低成本调用顶尖模型，支持科研创新</td></tr></tbody></table>
<h4 data-id="heading-40">4.3 后续探索建议</h4>
<ol>
<li>尝试多模型协作：用 “GPT-5 生成文案 +Gemini-2.5-flash-image（Nano Banana） + Sora 2 生成短视频”，构建完整 AIGC 流水线；</li>
<li>深入 RAG 功能：上传企业私有文档（如产品手册、内部流程），构建专属知识库，提升回答精准度；</li>
</ol>
<p><strong>如需进一步学习，可访问
<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aiionly.com%2Flogin%3FinviteCode%3D0047994" target="_blank" title="https://www.aiionly.com/login?inviteCode=0047994" ref="nofollow noopener noreferrer">AiOnly企业级MaaS平台官网</a>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aiionly.com%2Flogin%3FinviteCode%3D0047994" target="_blank" title="https://www.aiionly.com/login?inviteCode=0047994" ref="nofollow noopener noreferrer">GPT/Claude/Gemini API接入文档</a>
获取最新技术动态与专属支持</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[VinciCoder：多模态统一代码生成框架和视觉反馈强化学习，数据代码模型权重已开源]]></title>    <link>https://juejin.cn/post/7573506713866354739</link>    <guid>https://juejin.cn/post/7573506713866354739</guid>    <pubDate>2025-11-17T09:31:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573506713866354739" data-draft-id="7573242085610700851" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="VinciCoder：多模态统一代码生成框架和视觉反馈强化学习，数据代码模型权重已开源"/> <meta itemprop="keywords" content="人工智能,OpenAI"/> <meta itemprop="datePublished" content="2025-11-17T09:31:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="机器之心"/> <meta itemprop="url" content="https://juejin.cn/user/1873223543167902"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            VinciCoder：多模态统一代码生成框架和视觉反馈强化学习，数据代码模型权重已开源
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1873223543167902/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    机器之心
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:31:31.000Z" title="Mon Nov 17 2025 09:31:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>长期以来，多模态代码生成（Multimodal Code Generation）的训练严重依赖于特定任务的监督微调（SFT）。尽管这种范式在 Chart-to-code 等单一任务上取得了显著成功 ，但其 “狭隘的训练范围” 从根本上限制了模型的泛化能力，阻碍了通用视觉代码智能（Generalized VIsioN Code Intelligence）的发展 。同时，「SFT-only」的范式在确保代码可执行性和高视觉保真度方面存在显著瓶颈 。</p>
<p>在此背景下，中科院 &amp; 美团研究团队推出了 VinciCoder ，一个旨在打破 SFT 瓶颈的统一多模态代码生成模型。VinciCoder 首次将强化学习的奖励机制从文本域转向视觉域，提出视觉强化学习（ViRL） ，专攻 SFT 无法解决的视觉保真度难题。</p>
<p>本文提出的系统性框架 VinciCoder，通过 “大规模 SFT + 粗细粒度 ViRL” 的两阶段策略，有效统一了从图表、网页、SVG 到科学绘图（LaTeX、化学分子）等多样化代码生成任务 。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b8192aa8a0b4165b13b88b48c401bd9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976690&amp;x-signature=3tyDaX38rb2TvKQemZuYgliBEiA%3D" alt="图片" loading="lazy"/></p>
<ul>
<li>
<p>论文标题：VinciCoder: Unifying Multimodal Code Generation via Coarse-to-fine Visual Reinforcement Learning </p>
</li>
<li>
<p>论文链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F2511.00391%25C2%25A0" target="_blank" title="https://arxiv.org/abs/2511.00391%C2%A0" ref="nofollow noopener noreferrer">arxiv.org/abs/2511.00…</a></p>
</li>
<li>
<p>Github 链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDocTron-hub%2FVinciCoder%25C2%25A0" target="_blank" title="https://github.com/DocTron-hub/VinciCoder%C2%A0" ref="nofollow noopener noreferrer">github.com/DocTron-hub…</a></p>
</li>
</ul>
<p>数据代码模型权重已开源。</p>
<p>核心创新与技术突破</p>
<p>该论文同样对传统 SFT 范式的局限性进行了深入分析，发现其关键问题在于训练目标与最终任务之间存在 “视觉鸿沟”：</p>
<ul>
<li>
<p>目标是局部的：SFT 采用自回归的 “下一词元预测” 目标 ，这本质上是局部的，无法为代码 “可执行性” 等全局属性提供监督信号 。</p>
</li>
<li>
<p>缺乏视觉反馈：模型在训练时完全看不到代码的渲染结果 。这是一个致命缺陷，因为在代码中 “微小的修改就可能导致渲染图像发生巨大变化” 。</p>
</li>
</ul>
<p>这种 “视觉 - 代码” 监督的缺失，直接导致了两个关键问题：</p>
<ul>
<li>
<p>保真度低且不可靠：模型仅在词元层面（token-level）进行优化 ，无法保证渲染出的图像在视觉上与输入对齐，也无法保证代码可以成功执行 。</p>
</li>
<li>
<p>泛化能力差：依赖特定任务的数据集进行 SFT，难以形成一个统一的多模态代码生成框架 。</p>
</li>
</ul>
<p>考虑到 SFT 的根本局限性，研究者认为必须引入一个能够提供全局视觉反馈的机制。然而，传统的 RL 方法依赖难以泛化的 “基于规则的文本奖励” 。VinciCoder 的破局点在于 —— 将奖励机制从文本域彻底转向视觉域 。</p>
<p>VinciCoder 的核心思路是：用大规模、多样化的 SFT 构建强大的代码基础能力 ，再通过创新的 ViRL 策略专门优化 SFT 无法触及的视觉保真度和可执行性 。训练框架由「1.6M 大规模 SFT 阶段」和「42k 粗细粒度 ViRL 阶段」两部分组成 ，核心是通过两阶段协作，同时实现强大的代码理解与高保真的视觉对齐。</p>
<ol>
<li>大规模 SFT 语料库与代码优化任务</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f448cf425444e14a164fae85639e6bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976690&amp;x-signature=R0IcEbXFpyWlc6LccAEdsMA1La4%3D" alt="图片" loading="lazy"/></p>
<p>研究团队首先构建了一个包含 1.6M 图像 - 代码对的大规模监督微调（SFT）语料库 。该语料库不仅覆盖了直接代码生成任务，还引入 “视觉代码优化” 的新任务 。在这项任务中，模型会接收到一个目标图像和一个 “有缺陷” 的代码片段（包含逻辑错误或只能部分渲染）。模型的目标是修正这段代码，使其视觉输出与目标图像精确对齐 。这一设计极大地提升了模型在代码层面的纠错和优化能力，为后续的强化学习阶段奠定了坚实基础 。</p>
<ol start="2">
<li>从 “文本奖励” 到 “视觉奖励”：粗细粒度 ViRL 框架</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/53a263acf8cf4775b27135a3847cda91~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976690&amp;x-signature=0Xsr4pMYWbhArXSRfnmgF6MaU08%3D" alt="图片" loading="lazy"/></p>
<p>传统 SFT 训练在多模态代码生成上存在根本缺陷：它缺乏 “视觉 - 代码” 的闭环反馈 ，且无法保证代码的全局可执行性 。</p>
<p>为解决此问题，VinciCoder 引入了视觉强化学习 (ViRL) 框架 。该框架摒弃了传统强化学习中脆弱的、基于规则的 “文本奖励” ，转而从视觉直接获取奖励信号 。</p>
<p>其核心突破在于一套粗 - 细粒度（Coarse-to-fine）视觉奖励机制：</p>
<ul>
<li>
<p>渲染与编码：模型生成的代码被实时渲染成图像 。</p>
</li>
<li>
<p>粗粒度（全局）：通过下采样生成缩略图，评估整体结构的相似性 。</p>
</li>
<li>
<p>细粒度（局部）：将高分辨率图像分割为多个局部图块（patches），精确计算局部细节的保真度 。</p>
</li>
<li>
<p>ViT 奖励模型：使用 DINOv2-L 计算渲染图像与目标图像在两个粒度上的视觉相似度，作为奖励信号。</p>
</li>
<li>
<p>对齐奖励 ：引入一个辅助的语言对齐奖励，用于惩罚生成了错误代码语言（如要求 Python 却生成了 LaTeX 的行为）</p>
</li>
<li>
<p>策略优化：采用群组相对策略优化 (GRPO) 算法 对模型进行微调，显著提升视觉对齐度和代码可执行性。</p>
</li>
</ul>
<p>据我们所知，VinciCoder 是第一个应用强化学习（RL）来实现统一视觉代码生成领域中 “跨领域视觉保真度” 提升的视觉语言模型 。</p>
<p>实验结果与性能表现</p>
<p>论文在五大多模态代码生成基准上进行了全面实验，对比了包括 Qwen、InternVL 等开源模型以及 Gemini-2.5-Pro、Claude-4.5、GPT-5 等闭源模型 ，核心结果如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/baf8581e0b1c4c248b966b9989dfa52e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976690&amp;x-signature=HRH3vvaR3VDl2xaQWsA7FUJWnVw%3D" alt="图片" loading="lazy"/></p>
<p>实验结果令人瞩目：VinciCoder 在多个主流多模态代码生成基准上均取得了卓越表现。</p>
<ul>
<li>
<p>SOTA 性能：VinciCoder 在开源模型对比中树立了新的 SOTA 标准 ，其性能显著优于所有同等规模的竞争对手 。</p>
</li>
<li>
<p>媲美闭源模型：在如 Image-to-SVG 和化学分子式生等高难度任务上，VinciCoder 展现出超越顶尖闭源模型的卓越性能 。</p>
</li>
<li>
<p>策略有效性：消融实验证明，仅 SFT 阶段的 VinciCoder-SFT 就已建立起强大的基线 ；而 ViRL 阶段的引入，则成功将模型性能提升至 SOTA 水平 ，充分验证了 SFT-ViRL 两阶段策略的压倒性优势。</p>
</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85479c23df78428583513967d097db13~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5py65Zmo5LmL5b-D:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976690&amp;x-signature=UW%2BUbfrf%2BCMcMiVxhmq2B7sq%2BFE%3D" alt="图片" loading="lazy"/></p>
<p>研究意义与应用前景</p>
<p>VinciCoder 的研究不仅在技术上取得了重大突破，也为多模态代码生成领域提供了全新的研究范式：</p>
<ul>
<li>
<p>验证 RL 新路径：证明了 “视觉强化学习” 是突破 SFT 瓶颈、提升代码视觉保真度的有效途径，将奖励机制从文本域成功扩展到视觉域 。</p>
</li>
<li>
<p>统一框架的实现：打破了过去模型 “各自为战” 的狭隘范式 ，提供了一个强大的统一框架，能够处理包括 Python、HTML、SVG、LaTeX 乃至化学 SMILES 在内的多样化代码生成任务 。</p>
</li>
<li>
<p>高保真度奖励机制：“粗 - 细粒度” 奖励设计为处理高分辨率、高复杂度视觉输入的 RL 任务提供了健壮且可扩展的解决方案 。</p>
</li>
</ul>
<p>结论</p>
<p>VinciCoder 的核心价值并非单纯地堆砌 SFT 数据，而是通过 “SFT + 粗细粒度 ViRL” 的组合，证明了 “以视觉反馈指导代码生成” 的可行性与优越性。这一思路不仅解决了传统 SFT 范式在可执行性与视觉保真度上的痛点，也为后续通用多模态智能体的研发提供了新的思路。</p>
<p>在总体思路上，该论文的思路与 R1-Style 方法高度相关，都验证了强化学习在提升基础模型高级能力上的巨大潜力。VinciCoder 的成功探索表明，RL 不仅可以用于优化数学推理等文本任务，更可以作为连接 “视觉” 与 “代码” 两大模态的桥梁，解决 SFT 无法企及的跨模态对齐难题。</p>
<p>更多细节请参阅原论文。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 一个小型游戏对象模型渐进式设计（二）——协议与默认实现：如何写出不用继承的多态]]></title>    <link>https://juejin.cn/post/7573525927792623642</link>    <guid>https://juejin.cn/post/7573525927792623642</guid>    <pubDate>2025-11-17T09:46:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573525927792623642" data-draft-id="7553830228105986102" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 一个小型游戏对象模型渐进式设计（二）——协议与默认实现：如何写出不用继承的多态"/> <meta itemprop="keywords" content="Swift"/> <meta itemprop="datePublished" content="2025-11-17T09:46:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unravel2025"/> <meta itemprop="url" content="https://juejin.cn/user/1116759541421880"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 一个小型游戏对象模型渐进式设计（二）——协议与默认实现：如何写出不用继承的多态
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759541421880/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unravel2025
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:46:56.000Z" title="Mon Nov 17 2025 09:46:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>用 protocol + extension 把上一篇的 BOSS 战例彻底重构，让代码轻量、可测试、易扩展</p>
<h2 data-id="heading-0">为什么“不用继承”</h2>
<p>上一篇我们用 <code>class Entity → Monster / Boss</code> 的经典继承树完成了需求，但留下几个隐痛：</p>
<ol>
<li>值类型无法参与：Swift 的 struct 不能继承 class。</li>
<li>多继承死路：一个 BOSS 既要“可攻击”又要“可飞行”还要“可分裂”，Swift 不支持多类继承。</li>
<li>隐式共享状态：父类新增的存储属性，所有子类被迫买单，造成“胖基类”。</li>
<li>单元测试困难：想单独测“狂暴逻辑”必须把整个 Boss 实例 new 出来，还要喂血量。</li>
</ol>
<h2 data-id="heading-1">协议（protocol）是什么</h2>
<p>一句话：协议只定义“契约”，不关心“怎么存”。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Attackable</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span>
}
</code></pre>
<p>任何类型（class / struct / enum / actor）只要实现 <code>attack()</code>，就自动“符合” Attackable，从而获得多态能力。</p>
<p>协议本身不能存属性，但可以通过“关联属性”或“协议扩展”给出默认实现，达到“代码复用”而“不强制继承”。</p>
<h2 data-id="heading-2">协议扩展：给协议加“默认实现”</h2>
<p>语法：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Attackable</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span> { <span class="hljs-number">10.0</span> }   <span class="hljs-comment">// 默认伤害</span>
}
</code></pre>
<p>现在任何符合者如果不自己写 <code>attack()</code>，就自动拿到 10 点伤害。</p>
<p>想定制？在自己的类型里重新实现即可，不需要 <code>override</code> 关键字——因为协议不涉继承链。</p>
<h2 data-id="heading-3">拆成“能力插件”</h2>
<ol>
<li>可攻击</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Attackable</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span>
}
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Attackable</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span> { <span class="hljs-number">10.0</span> }
}
</code></pre>
<ol start="2">
<li>可定位</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Locatable</span> {
    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
    <span class="hljs-keyword">var</span> y: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
</code></pre>
<ol start="3">
<li>可受伤</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Woundable</span> {
    <span class="hljs-keyword">var</span> hp: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
    <span class="hljs-keyword">var</span> maxHp: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> }
}
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Woundable</span> {
    <span class="hljs-keyword">var</span> isRage: <span class="hljs-type">Bool</span> { hp <span class="hljs-operator">&lt;</span> maxHp <span class="hljs-operator">*</span> <span class="hljs-number">0.2</span> }   <span class="hljs-comment">// 狂暴判断</span>
}
</code></pre>
<ol start="4">
<li>可随机伤害</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">RandomDamage</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">randomDamage</span>(<span class="hljs-params">base</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">range</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Double</span>
}
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">RandomDamage</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">randomDamage</span>(<span class="hljs-params">base</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">range</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Double</span> {
        <span class="hljs-type">Double</span>.random(in: <span class="hljs-number">0.0</span><span class="hljs-operator">..&lt;</span><span class="hljs-type">Double</span>(range)) <span class="hljs-operator">+</span> <span class="hljs-type">Double</span>(base)
    }
}
</code></pre>
<h2 data-id="heading-4">用 struct 组装各种实体</h2>
<p>Swift 的 struct 可以符合多个协议，享受所有默认实现，零继承。</p>
<ol>
<li>普通小怪</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Monster</span>: <span class="hljs-title class_">Attackable</span>, <span class="hljs-title class_">Locatable</span>, <span class="hljs-title class_">Woundable</span>, <span class="hljs-title class_">RandomDamage</span> {
    <span class="hljs-keyword">var</span> hp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> maxHp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> y: <span class="hljs-type">Double</span>
    
    <span class="hljs-comment">// 自己定制伤害</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span> {
        randomDamage(base: <span class="hljs-number">5</span>, range: <span class="hljs-number">6</span>)
    }
}
</code></pre>
<ol start="2">
<li>BOSS</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Boss</span>: <span class="hljs-title class_">Attackable</span>, <span class="hljs-title class_">Locatable</span>, <span class="hljs-title class_">Woundable</span> {
    <span class="hljs-keyword">var</span> hp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> maxHp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> y: <span class="hljs-type">Double</span>
    
    <span class="hljs-comment">// 狂暴机制</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span> {
        <span class="hljs-keyword">let</span> base: <span class="hljs-type">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>
        <span class="hljs-keyword">return</span> isRage <span class="hljs-operator">?</span> base <span class="hljs-operator">*</span> <span class="hljs-number">2</span> : base
    }
}
</code></pre>
<ol start="3">
<li>飞行小怪（新增能力，无需改旧代码）</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Flyable</span> {
    <span class="hljs-keyword">var</span> altitude: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">FlyingMonster</span>: <span class="hljs-title class_">Attackable</span>, <span class="hljs-title class_">Locatable</span>, <span class="hljs-title class_">Woundable</span>, <span class="hljs-title class_">Flyable</span>, <span class="hljs-title class_">RandomDamage</span> {
    <span class="hljs-keyword">var</span> hp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> maxHp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> y: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> altitude: <span class="hljs-type">Double</span>
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Double</span> {
        randomDamage(base: <span class="hljs-number">4</span>, range: <span class="hljs-number">5</span>) <span class="hljs-operator">+</span> <span class="hljs-number">2</span>   <span class="hljs-comment">// 空对地加 2</span>
    }
}
</code></pre>
<h2 data-id="heading-5">多态依旧可用：协议作为类型</h2>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> army: [<span class="hljs-keyword">any</span> <span class="hljs-type">Attackable</span> &amp; <span class="hljs-type">Woundable</span>] <span class="hljs-operator">=</span> [
    <span class="hljs-type">Monster</span>(hp: <span class="hljs-number">30</span>, maxHp: <span class="hljs-number">30</span>, x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>),
    <span class="hljs-type">Boss</span>(hp: <span class="hljs-number">100</span>, maxHp: <span class="hljs-number">100</span>, x: <span class="hljs-number">1</span>, y: <span class="hljs-number">1</span>),
    <span class="hljs-type">FlyingMonster</span>(hp: <span class="hljs-number">20</span>, maxHp: <span class="hljs-number">20</span>, x: <span class="hljs-number">2</span>, y: <span class="hljs-number">2</span>, altitude: <span class="hljs-number">10</span>)
]

<span class="hljs-keyword">for</span> unit <span class="hljs-keyword">in</span> army {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"伤害=<span class="hljs-subst">\(unit.attack())</span>, 狂暴=<span class="hljs-subst">\(unit.isRage)</span>"</span>)
}
</code></pre>
<p>打印示例：</p>
<pre><code class="hljs language-arduino" lang="arduino">伤害=<span class="hljs-number">8.857546603881572</span>, 狂暴=<span class="hljs-literal">false</span>
伤害=<span class="hljs-number">10.0</span>, 狂暴=<span class="hljs-literal">false</span>
伤害=<span class="hljs-number">9.333377580674401</span>, 狂暴=<span class="hljs-literal">false</span>
</code></pre>
<p>把 Boss 的血量打到 19 再跑一次，就能看到伤害翻倍，逻辑与继承版完全一致。</p>
<h2 data-id="heading-6">单元测试变得多简单？</h2>
<p>想测“狂暴判断”只要 new 一个符合 <code>Woundable</code> 的伪对象即可，完全不用构造整个 Boss：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mock</span>: <span class="hljs-title class_">Woundable</span> {
    <span class="hljs-keyword">var</span> hp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> maxHp: <span class="hljs-type">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>
}

<span class="hljs-keyword">let</span> mock <span class="hljs-operator">=</span> <span class="hljs-type">Mock</span>(hp: <span class="hljs-number">19</span>)
<span class="hljs-type">XCTAssertTrue</span>(mock.isRage)
</code></pre>
<h2 data-id="heading-7">协议组合（Protocol Composition）的语法糖</h2>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">GameUnit</span> <span class="hljs-operator">=</span> <span class="hljs-type">Attackable</span> &amp; <span class="hljs-type">Woundable</span> &amp; <span class="hljs-type">Locatable</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">move</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">unit</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">GameUnit</span>, <span class="hljs-params">toX</span> <span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>) {
    unit.x <span class="hljs-operator">=</span> x
    unit.y <span class="hljs-operator">=</span> y
}
</code></pre>
<p>一个类型别名即可把“能力包”当成一个整体使用，比继承树清爽得多。</p>
<h2 data-id="heading-8">什么时候仍需要 class 继承</h2>
<ol>
<li>需要 Objective-C 运行时动态替换（KVO、Swizzle）。</li>
<li>需要析构器 deinit 做资源清理。</li>
<li>需要共享引用语义（多个指针指向同一对象）。</li>
<li>需要互斥锁、原子操作等“引用计数”场景。</li>
</ol>
<p>其余场景，优先 struct + 协议。</p>
<h2 data-id="heading-9">小结：一条决策流程图</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ff7af0bc169b474690ac527b53e830e0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdW5yYXZlbDIwMjU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977615&amp;x-signature=ZX2RZsH76wXfyAmdoSf%2BwWi4BvU%3D" alt="image.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用户选剧情，AI写故事：Trae Solo+GLM-4.6实现沉浸式小说创作体验]]></title>    <link>https://juejin.cn/post/7573468493569589284</link>    <guid>https://juejin.cn/post/7573468493569589284</guid>    <pubDate>2025-11-17T09:26:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573468493569589284" data-draft-id="7573336057481297926" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用户选剧情，AI写故事：Trae Solo+GLM-4.6实现沉浸式小说创作体验"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2025-11-17T09:26:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="_摘星_"/> <meta itemprop="url" content="https://juejin.cn/user/2228036358374227"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用户选剧情，AI写故事：Trae Solo+GLM-4.6实现沉浸式小说创作体验
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2228036358374227/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    _摘星_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:26:00.000Z" title="Mon Nov 17 2025 09:26:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5198527003bf4a67a19606b3117e03e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=1299W9dvbcJ3i4%2B0wq3xaGoGK0g%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">用户选剧情，AI写故事：Trae Solo+GLM-4.6实现沉浸式小说创作体验</h2>
<h3 data-id="heading-1">项目背景</h3>
<p>在人工智能技术迅猛发展的今天，内容创作正经历从“人工主导”向“人机协同”的深刻变革。传统小说创作往往面临灵感枯竭、结构混乱、节奏把控难等痛点，而现有AI写作工具多为单向输出，缺乏互动性与叙事张力。为打破这一局限，我们打造了一款轻量级、免登录的 AI小说创作平台，旨在通过前沿大模型能力赋能每一位故事创作者。</p>
<p>本项目深度融合 Trae Solo 的高效前端开发与任务调度能力，以及 GLM-4.6 在中文叙事、情节构建和风格一致性上的卓越表现，构建出“用户选剧情，AI写故事”的沉浸式创作闭环。用户只需输入一个故事开头，系统即刻生成三个风格各异的情节分支概览；选定其一后，AI将续写300–500字的高质量正文，并在此基础上持续衍生新分支，形成一棵动态生长的故事树。整个过程无需注册，API Key 通过本地存储安全保存，兼顾隐私与便捷。</p>
<p>平台采用 新粗野主义（Neo-Brutalism） 视觉风格，以白色为基底，搭配橙、绿、蓝、灰等高对比色块，强调操作反馈与信息层级，营造出兼具个性与流畅交互的创作体验。我们相信，AI不应替代创作者，而应成为激发想象力的伙伴——这款平台正是对“人机共创”未来的一次实践探索。</p>
<h3 data-id="heading-2">智谱大模型</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bigmodel.cn%2F" target="_blank" title="https://www.bigmodel.cn/" ref="nofollow noopener noreferrer">智谱AI</a>（Zhipu AI）是中国领先的大模型技术公司，致力于推动通用人工智能（AGI）的发展。其自主研发的GLM（General Language Model）系列大模型，凭借强大的语言理解与生成能力、多模态融合能力以及高效的推理性能，已在学术界和产业界获得广泛认可。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74c638c4a9044b328a505562da46e508~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=GHZU9Lt2skEP4q77TIzWiS4XKHY%3D" alt="" loading="lazy"/></p>
<p>最新发布的GLM-4.6不仅在逻辑推理、代码生成、多语言支持等方面实现显著突破，还具备更强的上下文理解与长文本处理能力；</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/16ad64f02f4c413f9b5cab1bb8291e6e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=W6dlj6mH857S9IP3RnZipahsOV4%3D" alt="" loading="lazy"/></p>
<p>在“AI小说创作平台”这一应用中，我们正是依托 Trae Solo 的高效调度能力，结合 GLM-4.6 在叙事生成、情节延展与风格控制上的强大语言建模优势，实现了从用户输入的故事开头到多分支剧情概览、再到沉浸式章节内容的端到端智能创作。通过本地化 API 管理与无登录轻量架构，智谱大模型不仅为写作者提供了低门槛、高自由度的创作杠杆，更重新定义了 AI 驱动下互动式小说生成的新范式。</p>
<h4 data-id="heading-3">获取API KEY</h4>
<p>在智谱AI开放平台的<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bigmodel.cn%2Fusercenter%2Fproj-mgmt%2Fapikeys" target="_blank" title="https://www.bigmodel.cn/usercenter/proj-mgmt/apikeys" ref="nofollow noopener noreferrer">控制台</a>中，即可添加账号的API KEY</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/537e063ac2014f328d9b4dd0fb5a969e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=SKqj4ljcsZReLVV0MQaRnBOk2h4%3D" alt="" loading="lazy"/></p>
<p>添加完之后需要使用的时候直接复制API KEY即可</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4fc40498effa4bd4b10c0416abf9391c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=CNQpVQI8Kx26CX0yQPCCLATJP6w%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-4">GLM-4.6</h4>
<p>智谱最新旗舰，代码能力全面对齐 Claude Sonnet 4，是国内最好的编程模型。在真实编程、长上下文处理、推理能力、信息搜索、写作能力与智能体应用等多个方面实现全面提升。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/32ce7fbc26324b168158b02b97a3f13d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=%2FdeHGA7nkboVXwxR6NWmcvyL3S4%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a9fc3dcd13f4a4badc65e0e1c73a831~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=7y5NfvlJOhSiShMUNDbql21osNs%3D" alt="" loading="lazy"/></p>
<p>GLM-4.6调用示例</p>
<pre><code class="hljs language-vbnet" lang="vbnet">curl -X POST <span class="hljs-string">"https://open.bigmodel.cn/api/paas/v4/chat/completions"</span> \
    -H <span class="hljs-string">"Content-Type: application/json"</span> \
    -H <span class="hljs-string">"Authorization: Bearer your-api-key"</span> \
    -d <span class="hljs-comment">'{</span>
        <span class="hljs-string">"model"</span>: <span class="hljs-string">"glm-4.6"</span>,
        <span class="hljs-string">"messages"</span>: [
        {
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
            <span class="hljs-string">"content"</span>: <span class="hljs-string">"作为一名营销专家，请为我的产品创作一个吸引人的口号"</span>
        },
        {
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"assistant"</span>,
            <span class="hljs-string">"content"</span>: <span class="hljs-string">"当然，要创作一个吸引人的口号，请告诉我一些关于您产品的信息"</span>
        },
        {
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
            <span class="hljs-string">"content"</span>: <span class="hljs-string">"智谱AI 开放平台"</span>
        }
            ],
            <span class="hljs-string">"thinking"</span>: {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"enabled"</span>
        },
            <span class="hljs-string">"max_tokens"</span>: <span class="hljs-number">65536</span>,
            <span class="hljs-string">"temperature"</span>: <span class="hljs-number">1.0</span>
        }<span class="hljs-comment">'</span>
</code></pre>
<h3 data-id="heading-5">Trae Solo</h3>
<p>过去几年，Prompt Engineering（提示词工程）风靡一时——人们通过精心雕琢输入文本，试图“引导”大模型输出理想结果。然而，随着 AI 应用日益深入复杂场景，仅靠静态、孤立的提示词已难以为继。</p>
<p>以智能客服为例：系统不仅要理解用户当前的提问，还需融合历史对话、用户身份、业务状态，甚至动态调用不同后端服务。此时，传统 Prompt Engineering 的局限性暴露无遗——它把 AI 调用当作一次性的“黑箱请求”，缺乏对整体交互脉络的把握。</p>
<p>正是在这样的背景下，Context Engineering（上下文工程）应运而生，而 Trae Solo 正是这一范式演进的先行者与核心推动者。Trae Solo 不满足于仅仅优化提示词，而是构建了一个结构化、可演化、可追溯的上下文空间——在正确的时间，为正确的模型，注入正确的上下文信息。它将 AI 交互从“单次问答”升级为“持续、智能、情境感知的对话流”，真正实现了从 Prompt Engineering 到 Context Engineering 的跃迁。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/990aef66c4d348fc938f9964c164bea3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=gXsn2icpxRBasD0z%2FCpW3PJmv88%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6">Trae Solo开发实践</h3>
<h4 data-id="heading-7">开发提示词</h4>
<p>准备好下方的开发提示词并输入Solo：</p>
<pre><code class="hljs language-rust" lang="rust">我现在要开发一个叫做AI小说创作平台，流程是用户给出一个故事的开头,应用会调用GLM-<span class="hljs-number">4.6</span>,生成后续三个情节分支概览,用户可以任意选择一个分支。选择分支之后立马调用GLM-<span class="hljs-number">4.6</span>生成具体的情节,大约<span class="hljs-number">300</span>-<span class="hljs-number">500</span>百字左右。未被选择的分支就抛弃掉，选择的分支使用树形结构一级一级往下展示，但是始终展示当前的分支，持续重复。采用React技术，风格使用新粗野风格，多用白色、橙色、绿色、蓝色、灰色等，流畅的交互设计。这个没有登录，就是所有人都可以用，而且只有两个页面，一个是首页-核心功能，一个是API Key 的配置页面（保存到本地的local storage中），在产品需求文档中加入GLM4.<span class="hljs-number">6</span>调用示例：
<span class="hljs-keyword">const</span> url = ' https:<span class="hljs-comment">//open.bigmodel.cn/api/paas/v4/chat/completions ';</span>
<span class="hljs-keyword">const</span> options = {
method: <span class="hljs-symbol">'POST</span>',
headers: {Authorization: <span class="hljs-symbol">'Bearer</span> &lt;token&gt;', <span class="hljs-symbol">'Content</span>-Type': <span class="hljs-symbol">'application</span>/json'},
body: '{<span class="hljs-string">"model"</span>:<span class="hljs-string">"glm-4.6"</span>,<span class="hljs-string">"messages"</span>:[{<span class="hljs-string">"role"</span>:<span class="hljs-string">"system"</span>,<span class="hljs-string">"content"</span>:<span class="hljs-string">"你是一个有用的AI助手。"</span>},{<span class="hljs-string">"role"</span>:<span class="hljs-string">"user"</span>,<span class="hljs-string">"content"</span>:<span class="hljs-string">"请介绍一下人工智能的发展历程。"</span>}],<span class="hljs-string">"temperature"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"max_tokens"</span>:<span class="hljs-number">65536</span>,<span class="hljs-string">"stream"</span>:<span class="hljs-literal">false</span>}'};
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8ab6a0f282af490eace990dc6746fc34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=%2BK8wj5sL%2FMk0EpKTQXiULNb9amo%3D" alt="" loading="lazy"/></p>
<p>Solo首先会创建一份产品需求文档和技术架构文档：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/22a40973b64a4b338717698f2d6de011~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=VMo5eaTrZmQj88MgWzaEqbfeeyA%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/15747531b9cc4168a52001edef9eca3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=PxTq9YZZgDJn3Cso5UlM0WejSsY%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-8">开发文档</h4>
<p>产品需求文档：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/84e3bac35a5e4499a438930dc7df53dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=c777I%2F2wLOJygvxihjHP4uc3Utg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/caf96ec1189443259004b05a12980e70~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=zO1hRpgY20nxEtjTd3s7cTrdnpU%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># AI小说创作平台 - 产品需求文档</span>

<span class="hljs-section">## 1. 产品概述</span>

AI小说创作平台是一个基于GLM-4.6大语言模型的交互式故事创作工具，用户可以输入故事开头，系统自动生成多个情节分支供用户选择，形成个性化的故事发展路径。

该平台旨在为创作者、小说爱好者和娱乐用户提供一个简单易用的AI辅助创作工具，通过树形结构展示故事发展脉络，让每个用户都能创作出独特的故事。

<span class="hljs-section">## 2. 核心功能</span>

<span class="hljs-section">### 2.1 用户角色</span>

本产品无需用户注册登录，所有访问者均可直接使用全部功能。

<span class="hljs-section">### 2.2 功能模块</span>

我们的AI小说创作平台包含以下主要页面：

<span class="hljs-bullet">1.</span> <span class="hljs-strong">**首页（故事创作页面）**</span>：故事输入区域、情节分支选择区域、故事树形展示区域、当前情节显示区域
<span class="hljs-bullet">2.</span> <span class="hljs-strong">**API Key配置页面**</span>：API Key输入表单、配置保存功能、配置状态显示

<span class="hljs-section">### 2.3 页面详情</span>

| 页面名称        | 模块名称   | 功能描述                                     |
| ----------- | ------ | ---------------------------------------- |
| 首页          | 故事输入区域 | 提供文本输入框，用户输入故事开头（50-200字），包含输入提示和字数统计    |
| 首页          | 情节分支生成 | 调用GLM-4.6 API生成三个不同的情节分支概览，每个分支50-100字描述 |
| 首页          | 分支选择区域 | 展示三个情节分支选项，用户点击选择其中一个，包含分支预览和选择按钮        |
| 首页          | 详细情节生成 | 基于用户选择的分支调用GLM-4.6生成300-500字的详细情节内容      |
| 首页          | 故事树形展示 | 使用树形结构展示故事发展路径，高亮当前选择的分支，显示历史选择路径        |
| 首页          | 当前情节显示 | 展示当前生成的详细情节内容，包含继续创作和重新开始功能              |
| 首页          | 导航功能   | 提供返回上一步、重新开始、前往配置页面的导航按钮                 |
| API Key配置页面 | 配置表单   | 提供API Key输入框，包含输入验证和格式检查                 |
| API Key配置页面 | 本地存储   | 将API Key保存到localStorage，包含保存确认和清除功能      |
| API Key配置页面 | 配置状态   | 显示当前API Key配置状态，包含连接测试功能                 |

<span class="hljs-section">## 3. 核心流程</span>

<span class="hljs-strong">**主要用户操作流程：**</span>

<span class="hljs-bullet">1.</span> 用户访问首页，检查API Key配置状态
<span class="hljs-bullet">2.</span> 如未配置API Key，引导用户前往配置页面设置
<span class="hljs-bullet">3.</span> 用户在首页输入故事开头
<span class="hljs-bullet">4.</span> 系统调用GLM-4.6生成三个情节分支概览
<span class="hljs-bullet">5.</span> 用户选择其中一个分支
<span class="hljs-bullet">6.</span> 系统基于选择的分支生成详细情节内容
<span class="hljs-bullet">7.</span> 用户可以继续基于当前情节生成新的分支，或重新开始创作

<span class="hljs-strong">**GLM-4.6 API调用示例：**</span>

<span class="hljs-code">```javascript
const url = 'https://open.bigmodel.cn/api/paas/v4/chat/completions';

const options = {
  method: 'POST',
  headers: {
    Authorization: 'Bearer &lt;token&gt;', 
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    "model": "glm-4.6",
    "messages": [
      {
        "role": "system",
        "content": "你是一个专业的小说创作助手，擅长根据给定的故事开头创作引人入胜的情节发展。"
      },
      {
        "role": "user",
        "content": "请基于以下故事开头，生成三个不同的情节发展方向..."
      }
    ],
    "temperature": 1,
    "max_tokens": 65536,
    "stream": false
  })
};
```</span>

<span class="hljs-code">```mermaid
graph TD
  A[首页] --&gt; B{检查API Key}
  B --&gt;|未配置| C[API Key配置页面]
  B --&gt;|已配置| D[输入故事开头]
  C --&gt; E[保存API Key到localStorage]
  E --&gt; A
  D --&gt; F[生成三个情节分支]
  F --&gt; G[选择分支]
  G --&gt; H[生成详细情节]
  H --&gt; I[展示在故事树中]
  I --&gt; J{继续创作?}
  J --&gt;|是| F
  J --&gt;|否| K[重新开始]
  K --&gt; D
```</span>

<span class="hljs-section">## 4. 用户界面设计</span>

<span class="hljs-section">### 4.1 设计风格</span>

采用新粗野主义（Neo-Brutalism）设计风格，具体包括：

<span class="hljs-bullet">*</span> <span class="hljs-strong">**主色调**</span>：白色 (#FFFFFF) 作为背景色

<span class="hljs-bullet">*</span> <span class="hljs-strong">**强调色**</span>：橙色 (#FF6B35)、绿色 (#4ECDC4)、蓝色 (#45B7D1)

<span class="hljs-bullet">*</span> <span class="hljs-strong">**辅助色**</span>：深灰色 (#2C3E50)、浅灰色 (#BDC3C7)

<span class="hljs-bullet">*</span> <span class="hljs-strong">**按钮风格**</span>：粗边框、高对比度、方形设计，带有阴影效果

<span class="hljs-bullet">*</span> <span class="hljs-strong">**字体**</span>：粗体无衬线字体，主标题18-24px，正文14-16px

<span class="hljs-bullet">*</span> <span class="hljs-strong">**布局风格**</span>：网格化布局，明确的区块分割，大胆的色彩对比

<span class="hljs-bullet">*</span> <span class="hljs-strong">**图标风格**</span>：简洁的线性图标，配合品牌色彩

<span class="hljs-section">### 4.2 页面设计概览</span>

| 页面名称    | 模块名称   | UI元素                           |
| ------- | ------ | ------------------------------ |
| 首页      | 故事输入区域 | 白色背景的大型文本框，橙色边框，字数计数器，绿色提交按钮   |
| 首页      | 分支选择区域 | 三个并排的卡片，蓝色边框，悬停时橙色高亮，粗体标题      |
| 首页      | 故事树展示  | 深灰色背景，白色连接线，彩色节点（橙/绿/蓝），当前节点高亮 |
| 首页      | 情节内容区  | 白色背景，深灰色文字，绿色边框，滚动条样式定制        |
| 首页      | 导航按钮   | 粗边框按钮，不同功能使用不同颜色，悬停效果明显        |
| API配置页面 | 配置表单   | 居中布局，白色卡片，橙色输入框边框，大型保存按钮       |
| API配置页面 | 状态显示   | 彩色状态指示器，成功为绿色，错误为橙色，未配置为灰色     |

<span class="hljs-section">### 4.3 响应式设计</span>

产品采用桌面优先的响应式设计：

<span class="hljs-bullet">*</span> <span class="hljs-strong">**桌面端（1200px+）**</span>：三栏布局，故事树、内容区、分支选择并排显示

<span class="hljs-bullet">*</span> <span class="hljs-strong">**平板端（768px-1199px）**</span>：两栏布局，故事树折叠为抽屉式，主要显示内容区和分支选择

<span class="hljs-bullet">*</span> <span class="hljs-strong">**移动端（&lt;768px）**</span>：单栏布局，各模块垂直堆叠，优化触摸交互

<span class="hljs-bullet">*</span> <span class="hljs-strong">**交互优化**</span>：支持触摸手势，按钮尺寸适配移动端，文字大小自适应
</code></pre>
<p>技术架构文档：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3dd36b9954a148b1b3f80b485fec76b7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=g0obzgxngGqra1aSQbMGOVLK%2BQY%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d56b97a8f35644e4a4cbb7582f951736~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=LM7Mi26pWljLPuPnnGl5O6mIJtM%3D" alt="" loading="lazy"/></p>
<pre><code class="hljs language-css" lang="css"># AI小说创作平台 - 技术架构文档

## <span class="hljs-number">1</span>. 架构设计

```mermaid
graph <span class="hljs-selector-tag">TD</span>
  <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[用户浏览器]</span> --&gt; <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[React前端应用]</span>
  <span class="hljs-selector-tag">B</span> --&gt; C<span class="hljs-selector-attr">[GLM-4.6 API]</span>
  <span class="hljs-selector-tag">B</span> --&gt; D<span class="hljs-selector-attr">[LocalStorage]</span>

  subgraph "前端层"
    <span class="hljs-selector-tag">B</span>
    D
  end

  subgraph "外部服务"
    C
  end
```

## <span class="hljs-number">2</span>. 技术描述

- **前端**: React@<span class="hljs-number">18</span> + TypeScript + Vite + TailwindCSS
- **状态管理**: React Context + useReducer
- **HTTP客户端**: Fetch API
- **本地存储**: LocalStorage API
- **外部服务**: GLM-<span class="hljs-number">4.6</span> API (智谱AI)

## <span class="hljs-number">3</span>. 路由定义

| 路由 | 用途 |
|------|-----|
| / | 首页，故事创作主界面，包含输入区域、分支选择、故事树展示 |
| /config | API Key配置页面，用于设置和管理GLM-<span class="hljs-number">4.6</span>的API密钥 |

## <span class="hljs-number">4</span>. API定义

### <span class="hljs-number">4.1</span> GLM-<span class="hljs-number">4.6</span> API集成

**生成情节分支概览**
```
POST https://open.bigmodel.cn/api/paas/v4/chat/completions
```

请求参数:
| 参数名称 | 参数类型 | 是否必需 | 描述 |
|---------|---------|---------|------|
| model | string | true | 固定值 <span class="hljs-string">"glm-4.6"</span> |
| messages | array | true | 对话消息数组，包含系统提示和用户输入 |
| temperature | number | true | 生成随机性，设置为<span class="hljs-number">0.8</span>以保证创意性 |
| max_tokens | number | true | 最大生成token数，分支概览设置为<span class="hljs-number">200</span> |
| stream | boolean | true | 是否流式输出，设置为false |

响应参数:
| 参数名称 | 参数类型 | 描述 |
|---------|---------|------|
| choices | array | 生成的回复选项数组 |
| choices[<span class="hljs-number">0</span>].message.content | string | 生成的文本内容 |

**生成详细情节内容**
```
POST https://open.bigmodel.cn/api/paas/v4/chat/completions
```

请求参数:
| 参数名称 | 参数类型 | 是否必需 | 描述 |
|---------|---------|---------|------|
| model | string | true | 固定值 <span class="hljs-string">"glm-4.6"</span> |
| messages | array | true | 包含故事上下文和选择分支的消息数组 |
| temperature | number | true | 生成随机性，设置为<span class="hljs-number">0.7</span> |
| max_tokens | number | true | 最大生成token数，详细情节设置为<span class="hljs-number">800</span> |
| stream | boolean | true | 是否流式输出，设置为false |

示例请求:
```json
{
  "model": <span class="hljs-string">"glm-4.6"</span>,
  <span class="hljs-string">"messages"</span>: [
    {
      "role": <span class="hljs-string">"system"</span>,
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"你是一个专业的小说创作助手，擅长根据给定的故事开头和选择的情节方向创作引人入胜的详细情节。请生成300-500字的详细情节内容。"</span>
    },
    {
      "role": <span class="hljs-string">"user"</span>,
      <span class="hljs-string">"content"</span>: <span class="hljs-string">"故事开头：[用户输入的开头] \n选择的情节方向：[用户选择的分支] \n请基于以上内容生成详细的情节发展。"</span>
    }
  ],
  "temperature": <span class="hljs-number">0.7</span>,
  <span class="hljs-string">"max_tokens"</span>: <span class="hljs-number">800</span>,
  <span class="hljs-string">"stream"</span>: false
}
```

### <span class="hljs-number">4.2</span> 本地存储API

**API Key管理**
```typescript
// 保存API Key
localStorage<span class="hljs-selector-class">.setItem</span>('glm_api_key', apiKey);

// 获取API Key
const apiKey = localStorage<span class="hljs-selector-class">.getItem</span>('glm_api_key');

// 删除API Key
localStorage<span class="hljs-selector-class">.removeItem</span>('glm_api_key');
```

**故事数据缓存**
```typescript
// 保存当前故事状态
localStorage<span class="hljs-selector-class">.setItem</span>('current_story', JSON<span class="hljs-selector-class">.stringify</span>(storyData));

// 获取故事状态
const storyData = JSON<span class="hljs-selector-class">.parse</span>(localStorage<span class="hljs-selector-class">.getItem</span>('current_story') || '{}');
```

## <span class="hljs-number">5</span>. 数据模型

### <span class="hljs-number">5.1</span> 数据模型定义

```mermaid
erDiagram
  STORY ||<span class="hljs-attr">--o</span>{ STORY_NODE : contains
  STORY_NODE ||--o{ BRANCH_OPTION : has
  
  STORY {
    string id PK
    string title
    string initialContent
    date createdAt
    string currentNodeId
  }
  
  STORY_NODE {
    string id PK
    string storyId FK
    string parentNodeId FK
    string <span class="hljs-attribute">content</span>
    int level
    boolean isSelected
    date createdAt
  }
  
  BRANCH_OPTION {
    string id PK
    string nodeId FK
    string title
    string description
    boolean isSelected
    int <span class="hljs-attribute">order</span>
  }
```

### <span class="hljs-number">5.2</span> TypeScript类型定义

```typescript
// 故事分支选项
interface BranchOption {
  id: string;
  title: string;
  description: string;
  isSelected: boolean;
  <span class="hljs-attribute">order</span>: number;
}

// 故事节点
interface StoryNode {
  id: string;
  parentNodeId?: string;
  <span class="hljs-attribute">content</span>: string;
  level: number;
  isSelected: boolean;
  createdAt: Date;
  branches?: BranchOption[];
}

// 完整故事数据
interface Story {
  id: string;
  title: string;
  initialContent: string;
  nodes: StoryNode[];
  currentNodeId?: string;
  createdAt: Date;
}

// API响应类型
interface GLMResponse {
  choices: Array&lt;{
    message: {
      <span class="hljs-attribute">content</span>: string;
      role: string;
    };
    finish_reason: string;
  }&gt;;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

// 应用状态类型
interface AppState {
  story: Story | null;
  isLoading: boolean;
  error: string | null;
  apiKey: string | null;
  currentStep: <span class="hljs-string">'input'</span> | <span class="hljs-string">'branches'</span> | <span class="hljs-string">'content'</span>;
}
```

## <span class="hljs-number">6</span>. 组件架构

### <span class="hljs-number">6.1</span> 组件层次结构

```mermaid
graph <span class="hljs-selector-tag">TD</span>
  <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[App]</span> --&gt; <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[Router]</span>
  <span class="hljs-selector-tag">B</span> --&gt; C<span class="hljs-selector-attr">[HomePage]</span>
  <span class="hljs-selector-tag">B</span> --&gt; D<span class="hljs-selector-attr">[ConfigPage]</span>
  
  C --&gt; E<span class="hljs-selector-attr">[StoryInput]</span>
  C --&gt; F<span class="hljs-selector-attr">[BranchSelector]</span>
  C --&gt; G<span class="hljs-selector-attr">[StoryTree]</span>
  C --&gt; H<span class="hljs-selector-attr">[ContentDisplay]</span>
  C --&gt; <span class="hljs-selector-tag">I</span><span class="hljs-selector-attr">[Navigation]</span>
  
  D --&gt; J<span class="hljs-selector-attr">[ApiKeyForm]</span>
  D --&gt; K<span class="hljs-selector-attr">[ConfigStatus]</span>
  
  subgraph "共享组件"
    L<span class="hljs-selector-attr">[Button]</span>
    M<span class="hljs-selector-attr">[Loading]</span>
    N<span class="hljs-selector-attr">[ErrorMessage]</span>
    O<span class="hljs-selector-attr">[Modal]</span>
  end
```

### <span class="hljs-number">6.2</span> 核心组件说明

**StoryInput组件**
- 功能：处理用户故事开头输入
- Props：onSubmit, isLoading, maxLength
- 状态：inputValue, charCount, validation

**BranchSelector组件**
- 功能：展示和选择情节分支
- Props：branches, onSelect, isLoading
- 状态：selectedBranch, hoverBranch

**StoryTree组件**
- 功能：树形展示故事发展路径
- Props：story, currentNodeId, onNodeClick
- 状态：expandedNodes, treeLayout

**ContentDisplay组件**
- 功能：显示当前情节内容
- Props：<span class="hljs-attribute">content</span>, isLoading, onContinue
- 状态：displayText, animationState

**ApiKeyForm组件**
- 功能：API Key配置和验证
- Props：onSave, initialValue
- 状态：apiKey, isValid, testResult

## <span class="hljs-number">7</span>. 状态管理

### <span class="hljs-number">7.1</span> Context设计

```typescript
// 故事状态Context
const StoryContext = createContext&lt;{
  state: AppState;
  dispatch: Dispatch&lt;StoryAction&gt;;
}&gt;({} as any);

// 配置状态Context
const ConfigContext = createContext&lt;{
  apiKey: string | null;
  setApiKey: (key: string) =&gt; void;
  isConfigured: boolean;
}&gt;({} as any);
```

### <span class="hljs-number">7.2</span> 状态更新流程

```mermaid
graph LR
  <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[用户操作]</span> --&gt; <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[Action Dispatch]</span>
  <span class="hljs-selector-tag">B</span> --&gt; C<span class="hljs-selector-attr">[Reducer处理]</span>
  C --&gt; D<span class="hljs-selector-attr">[状态更新]</span>
  D --&gt; E<span class="hljs-selector-attr">[组件重渲染]</span>
  E --&gt; F<span class="hljs-selector-attr">[UI更新]</span>
```

## <span class="hljs-number">8</span>. 部署架构

### <span class="hljs-number">8.1</span> 构建配置

- **构建工具**: Vite
- **输出格式**: 静态HTML/CSS/JS文件
- **代码分割**: 路由级别的懒加载
- **资源优化**: 图片压缩、CSS/JS压缩

### <span class="hljs-number">8.2</span> 部署方案

- **推荐部署**: Vercel、Netlify等静态托管平台
- **备选方案**: GitHub Pages、云服务器静态托管
- **CDN加速**: 自动配置，提升全球访问速度
- **HTTPS**: 默认支持，确保API调用安全
</code></pre>
<h4 data-id="heading-9">开发调整</h4>
<p>检查完毕开发文档，发现确实按照自己所想的话，就可以直接让Solo根据文档进行开发了。如果文档有问题的话，可以手动进行调整，也可以让输入需求Solo进行调整。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/efc62e52276443c4b0b84438f6a606a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=x3KVlYv11yZf9JE8V4y8uWPc%2FRQ%3D" alt="" loading="lazy"/></p>
<p>Solo不仅会自动定义需要实现的要点和任务，也会初始化项目基础架构，包括下载依赖，配置环境这些，Solo统统给你打包完成，根本不需要自己操心：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3eee090585514739b334833272599eca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=BQJpnQLUq0zZVs6dX4tzPzrAxDA%3D" alt="" loading="lazy"/></p>
<p>Solo会严格按照自己指定的任务进行完成，如果我们再开发的过程中发现了Solo的方向不对，或者有需要补充的时候，可以直接打断Solo输入需求，因为Solo完全遵守上下文工程的理念的，不管从哪里开始，他都会项目目前各个信息整合之后进行开发，完全不用担心打断会对Solo的开发进度产生什么影响。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c0ff31fbb894fbeb5288c3ae095ef2d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=V09D0CqvOxM2AiTtMI0HtMoUorE%3D" alt="" loading="lazy"/></p>
<p>开发完毕之后可以再内置浏览其中进行操作测试</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d7efb5c78f8b4db0a2f77c905b4efe75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=WZjp%2BQhXU2%2BWPUwdarCNMbQEWfM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/030785197e6244a7908d64d464289bb8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=UUpj6HRSDcw%2BdKlM1k%2FS8EZXF64%3D" alt="" loading="lazy"/></p>
<p>但是我在测试的过程中发现，应用在API调用失败的时候会使用模拟数据，这是绝对不允许的，那么输入下方提示词让Solo给我改成回来！</p>
<pre><code class="hljs language-vbnet" lang="vbnet">项目中绝对不允许使用模拟数据，必须是AI生成的数据，API调用参考：
curl -X POST <span class="hljs-string">" https://open.bigmodel.cn/api/paas/v4/chat/completions "</span> \
-H <span class="hljs-string">"Content-Type: application/json"</span> \
-H <span class="hljs-string">"Authorization: Bearer your-api-key"</span> \
-d <span class="hljs-comment">'{</span>
<span class="hljs-string">"model"</span>: <span class="hljs-string">"glm-4.6"</span>,
<span class="hljs-string">"messages"</span>: [
{
<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
<span class="hljs-string">"content"</span>: <span class="hljs-string">"作为一名营销专家，请为我的产品创作一个吸引人的口号"</span>
},
{
<span class="hljs-string">"role"</span>: <span class="hljs-string">"assistant"</span>,
<span class="hljs-string">"content"</span>: <span class="hljs-string">"当然，要创作一个吸引人的口号，请告诉我一些关于您产品的信息"</span>
},
{
<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
<span class="hljs-string">"content"</span>: <span class="hljs-string">"智谱AI 开放平台"</span>
}
],
<span class="hljs-string">"thinking"</span>: {
<span class="hljs-string">"type"</span>: <span class="hljs-string">"enabled"</span>
},
<span class="hljs-string">"max_tokens"</span>: <span class="hljs-number">65536</span>,
<span class="hljs-string">"temperature"</span>: <span class="hljs-number">1.0</span>
}<span class="hljs-comment">'</span>
</code></pre>
<p>那么Solo在接收到修改需求之后，还是严格按照先定义任务列表，将大任务拆解成小任务一项一项的去完成任务这个理念：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d9c2abe870ed41979b4c7d362aa94044~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=pTLUtRyvGuLeIv6wxnkj6Akl%2B%2Fc%3D" alt="" loading="lazy"/></p>
<p>并且Solo在修改的过程中还会进行自测，确保我们想要的功能给到我们的时候是准备无误的。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d870ee6fd789431da358605b887fce51~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=fwu4XwXQAT6WDFLpEnX5lNv9amQ%3D" alt="" loading="lazy"/></p>
<p>这时候我又发现，在AI调用的过程中的超时时间太短了，导致AI报错，那么我们就可以直接点击控制台中的日志报错，添加到对话中，并给出具体的需求，这样Solo就会帮我们针对性的解决报错问题。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f58a0f040fa642498e77eb6ab97b2f3e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=48ttEARqR93DldNfmL8QKcPgHTY%3D" alt="" loading="lazy"/></p>
<p>如果页面中还有什么不满意的地方，也可以继续让Solo继续改正，比如我发现在生成文章分支的时候只是一味的转圈等待，并没有进度条显示，这样的话用户就会干等着，会让用户体验感下降，我们就可以跟Solo说让他加上动态效果的进度条，让用户知道我们后台正在持续不断的运行中~</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5601d4a9f87249399da41ceafa732177~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=sQO3ouHhUbOu6saz8R6V9Erfvf4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-10">部署展示</h3>
<p>所有的功能都按照自己的想法开发完毕之后，就可以进入到部署阶段。在 Trae Solo 中，Vercel 被深度集成作为默认的前端部署与托管平台，极大简化了从开发到上线的全流程。开发者只需在 Trae Solo 项目中完成基础配置（如框架类型、构建命令等），即可通过内置的 “Deploy to Vercel” 一键发布功能，将 React、Next.js 等现代前端应用快速部署至全球 CDN 网络。Vercel 提供的自动 HTTPS、边缘函数支持、预览部署（Preview Deployments）以及环境变量管理，与 Trae Solo 的 AI 辅助开发理念高度契合——不仅加速了迭代速度，还确保了生产环境的稳定性与安全性。此外，Vercel 的无缝 Git 集成（支持 GitHub、GitLab 等）使得每次代码推送都能自动触发构建与部署，真正实现“写完即上线”。对于像 AI 小说创作平台这类轻量级、静态优先的应用，Vercel 的免费套餐已完全满足需求，是 Trae Solo 推荐的高效、可靠部署方案。Trae Solo</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85004701916a48bea6f195810bc5a991~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=MePdHAsRasoqVnhkogWsW9YHuGE%3D" alt="" loading="lazy"/></p>
<p>在Solo中只需一句话即可完成部署，而且整个过程是完全自动的：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6656e6d77a284d51aa36eba00fb3dfd6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=ckOv4zl3IAJRqDXmIeOf4H4Gn7w%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7fb9fb1f4fe4d698d3d542004cdb189~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=FqDowsnxm9R1RtbSYemf1LAn5yc%3D" alt="" loading="lazy"/></p>
<p>并且这时候可以再vercel的项目管理中看到项目的运行状态：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4bca077e983a4af4ac8efde37ccb3497~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=2eO%2BcvVHEcCwAS8jPmF%2BjunwsTA%3D" alt="" loading="lazy"/></p>
<p>通过项目链接直接进入到项目中，在进入项目之前需要配置一下智谱的API KEY，这个操作在前文也提到过，这里不过多赘述：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/df97f33926014518aa8df03457166770~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=nX9jTdwL%2BhQXl7pM8d8sQzHjCUc%3D" alt="" loading="lazy"/></p>
<p>输入API KEY之后，点击测试配置，检验API KEY是否正确，或者账户余额是否充足，测试完毕之后即可保存设置</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7457fc1c0ad8414a951faba9a9689086~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=zrzARiVds1Xt2hrgPUdM9HI%2BSws%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4566a0a4e4a748d3b8978b4a7038efb0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=NDcm64SYINwJvMltxKip6VeKAlo%3D" alt="" loading="lazy"/></p>
<p>配置完毕之后，即可开启故事创作，那么需要自己先拟定一个故事标题，和故事的开头，然后点击生成故事分支</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ab4b19c05bf40278bca9ae2621d2e1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=HUt%2FVggabUrjgXPGbnywCMpT8c8%3D" alt="" loading="lazy"/></p>
<p>点击之后会先讲当前操作的内容保存到创作树中</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/edd8c60f67644a2d81dae4c03d7c5a29~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=lJTWbRi4CwUSPumiMMS6pEYbYW8%3D" alt="" loading="lazy"/></p>
<p>然后回到首页点击生成新分支</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd5fc87770f342ce96687ea5d9c19fe9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=UQ6jmbHaP%2F4B82JVVTPxzky5VuU%3D" alt="" loading="lazy"/></p>
<p>可以看到进度量实时展示着创作的进度</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/961031dfe4694110a12a142074894456~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=WV2ZidW6Mg7UTBoQgV57ty2AqkM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/231842353d524b5caeede14be8ac8c6e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=SD9qDNxvRcQFmCVH033433XNcHg%3D" alt="" loading="lazy"/></p>
<p>不一会儿就生成出三个不同的故事分支</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/006c48a2686f4cde86f426aa52ea908e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=sErmTbbOcHD7oLb%2BKer%2FNP3Yx2c%3D" alt="" loading="lazy"/></p>
<p>这里我们选择任一一个故事分支，点击生成分支的详细内容</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e55d13289204f6fbe6fb1f033fa3e4c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=YAZMySR9aKYzNRks7ln0CWj3qOE%3D" alt="" loading="lazy"/></p>
<p>可以看到生成的详细内容，可以说是很有创意性了</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1aa2367abd2406487d21b039e38c786~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=3bO6jIeWC7GG7697Sl%2B5Y5tZi%2BY%3D" alt="" loading="lazy"/></p>
<p>这时候再回到创作树中，可以看到刚刚选择的分支以及详情，这样不管创作多久也可以返回看到自己的创作历程</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1fb147e3465a4a53b4bdea0e14bcf421~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=aIsT3PiP6DmK8%2F9fdHgSvhH3OVQ%3D" alt="" loading="lazy"/></p>
<p>接下来就是不断重复这个过程，一遍又一遍选择新的分支，探索不同分支带来的不同结果，最后形成一篇小说</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3eb9c484e7d14f5199f32c668c6deba2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976360&amp;x-signature=sTntICxJeY3JKTGZSOBb56BDz78%3D" alt="" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 一个小型游戏对象模型渐进式设计（三）——把能力再抽象一层，写一套“伤害计算器”框架]]></title>    <link>https://juejin.cn/post/7573336057481412614</link>    <guid>https://juejin.cn/post/7573336057481412614</guid>    <pubDate>2025-11-17T09:51:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573336057481412614" data-draft-id="7553867623856652298" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 一个小型游戏对象模型渐进式设计（三）——把能力再抽象一层，写一套“伤害计算器”框架"/> <meta itemprop="keywords" content="Swift"/> <meta itemprop="datePublished" content="2025-11-17T09:51:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unravel2025"/> <meta itemprop="url" content="https://juejin.cn/user/1116759541421880"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 一个小型游戏对象模型渐进式设计（三）——把能力再抽象一层，写一套“伤害计算器”框架
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759541421880/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unravel2025
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:51:46.000Z" title="Mon Nov 17 2025 09:51:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">为什么要“再抽象一层”</h2>
<p>上两篇我们已经用协议把“攻击”拆成了能力插件，但遗留了一个硬核问题：</p>
<ul>
<li>游戏前期用 <code>Int</code> 足够，后期为了避免除法误差想换成 <code>Double</code>，甚至金融级精度要用 <code>Decimal</code>；</li>
<li>如果给每种数值类型都复制一份协议，就会出现 <code>AttackableInt</code>、<code>AttackableDouble</code>…爆炸式增长。</li>
</ul>
<p>Swift 的泛型（Generic）+ 关联类型（associatedtype）可以“一次性”写出算法，然后让编译器在调用点自动生成对应版本的代码，既保证类型安全，又保持运行时零成本。</p>
<h2 data-id="heading-1">把 Attackable 升级成泛型协议</h2>
<ol>
<li>定义“数值”契约</li>
</ol>
<p>先约定一个“可运算、可比较”的基本协议，把 <code>+</code>、<code>*</code>、<code>/</code>、<code>&gt;</code> 等运算符包进去：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">NumericValue</span>: <span class="hljs-title class_">Comparable</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">+</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">*</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">/</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">&gt;</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-type">Bool</span>   <span class="hljs-comment">// 与标量乘</span>
    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int</span>)                               <span class="hljs-comment">// 能从整数字面量初始化</span>
}
</code></pre>
<ol start="2">
<li>让标准库类型自动符合</li>
</ol>
<p>Swift 5.7 之后可以用 <code>extension</code> 给标准库类型“批量”实现：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span>: <span class="hljs-title class_">NumericValue</span> {}
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Double</span>: <span class="hljs-title class_">NumericValue</span> {}
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Decimal</span>: <span class="hljs-title class_">NumericValue</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">lhs</span>: <span class="hljs-type">Decimal</span>, <span class="hljs-params">rhs</span>: <span class="hljs-type">Double</span>) -&gt; <span class="hljs-type">Decimal</span> {
        lhs <span class="hljs-operator">*</span> <span class="hljs-type">Decimal</span>(rhs)
    }
}
</code></pre>
<p>（<code>Float</code>、<code>CGFloat</code> 同理）</p>
<ol start="3">
<li>泛型版 Attackable</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Attackable</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Value</span>: <span class="hljs-type">NumericValue</span>   <span class="hljs-comment">// ① 关联类型</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Value</span>
}
</code></pre>
<p>注意：</p>
<p>① 这里不能再给 <code>attack()</code> 提供默认实现，因为返回类型是泛型，不同数值的“默认伤害”语义不同；</p>
<p>② 如果确实想提供默认，可以再包一层泛型扩展</p>
<h2 data-id="heading-2">给“默认伤害”一个泛型实现</h2>
<p>利用协议扩展的“where 子句”只对特定数值生效：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Attackable</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Value</span> == <span class="hljs-title class_">Double</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Value</span> { <span class="hljs-number">10.0</span> }
}
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Attackable</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Value</span> == <span class="hljs-title class_">Int</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Value</span> { <span class="hljs-number">10</span> }
}
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Attackable</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Value</span> == <span class="hljs-title class_">Decimal</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Value</span> { <span class="hljs-type">Decimal</span>(<span class="hljs-number">10</span>) }
}
</code></pre>
<p>这样任何符合者只要 <code>Value</code> 是上述三种之一，不实现 <code>attack()</code> 也能编译通过；想定制就再写一遍覆盖即可。</p>
<h2 data-id="heading-3">把“伤害计算器”也做成泛型组件</h2>
<p>需求：</p>
<ul>
<li>支持“暴击”、“易伤”、“免伤”多层修正；</li>
<li>算法写一次，对 <code>Int / Double / Decimal</code> 全部生效；</li>
<li>编译期决定类型，无运行时派发。</li>
</ul>
<ol>
<li>定义计算器协议</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">DamageCalculator</span>&lt;<span class="hljs-title class_">Value</span>&gt; {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Value</span>: <span class="hljs-type">NumericValue</span>
    <span class="hljs-comment">/// 传入基础伤害，返回最终伤害</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">base</span>: <span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">Value</span>
}
</code></pre>
<ol start="2">
<li>默认实现：暴击 * 1.5</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CritCalculator</span>&lt;<span class="hljs-title class_">Value</span>: <span class="hljs-title class_">NumericValue</span>&gt;: <span class="hljs-title class_">DamageCalculator</span> {
    <span class="hljs-keyword">let</span> rate: <span class="hljs-type">Value</span>   <span class="hljs-comment">// 暴击倍率</span>
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">base</span>: <span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">Value</span> {
        base <span class="hljs-operator">*</span> rate
    }
}
</code></pre>
<ol start="3">
<li>链式组合：装饰器模式</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MultiplierCalculator</span>&lt;<span class="hljs-title class_">Value</span>: <span class="hljs-title class_">NumericValue</span>&gt;: <span class="hljs-title class_">DamageCalculator</span> {
    <span class="hljs-keyword">let</span> upstream: <span class="hljs-keyword">any</span> <span class="hljs-type">DamageCalculator</span>&lt;<span class="hljs-type">Value</span>&gt;  <span class="hljs-comment">// 上游计算器</span>
    <span class="hljs-keyword">let</span> multiplier: <span class="hljs-type">Double</span>
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">base</span>: <span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">Value</span> {
        <span class="hljs-keyword">let</span> upstreamDamage <span class="hljs-operator">=</span> upstream.calculate(base: base)
        <span class="hljs-keyword">return</span> upstreamDamage <span class="hljs-operator">*</span> multiplier
    }
}
</code></pre>
<p>使用：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> crit: <span class="hljs-keyword">any</span> <span class="hljs-type">DamageCalculator</span>&lt;<span class="hljs-type">Double</span>&gt; <span class="hljs-operator">=</span> <span class="hljs-type">CritCalculator</span>(rate: <span class="hljs-number">1.5</span>)
<span class="hljs-keyword">let</span> vulnerable <span class="hljs-operator">=</span> <span class="hljs-type">MultiplierCalculator</span>(upstream: crit, multiplier: <span class="hljs-number">1.2</span>)  <span class="hljs-comment">// 易伤 +20%</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">final</span> <span class="hljs-operator">=</span> vulnerable.calculate(base: <span class="hljs-number">100</span>)   <span class="hljs-comment">// 100 * 1.5 * 1.2 = 180.0</span>
</code></pre>
<h2 data-id="heading-4">把计算器塞进实体——“能力注入”</h2>
<p>我们不再让实体“继承”伤害逻辑，而是把计算器当成属性注入：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Warrior</span>&lt;<span class="hljs-title class_">Value</span>: <span class="hljs-title class_">NumericValue</span>&gt;: <span class="hljs-title class_">Attackable</span> {
    <span class="hljs-keyword">let</span> calculator: <span class="hljs-keyword">any</span> <span class="hljs-type">DamageCalculator</span>&lt;<span class="hljs-type">Value</span>&gt;
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() -&gt; <span class="hljs-type">Value</span> {
        <span class="hljs-keyword">let</span> base: <span class="hljs-type">Value</span> <span class="hljs-operator">=</span> <span class="hljs-type">Value</span>(<span class="hljs-number">50</span>)        <span class="hljs-comment">// 自己定基础值</span>
        <span class="hljs-keyword">return</span> calculator.calculate(base: base)
    }
}
</code></pre>
<p>使用：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> warriorD <span class="hljs-operator">=</span> <span class="hljs-type">Warrior</span>&lt;<span class="hljs-type">Double</span>&gt;(calculator: vulnerable)
<span class="hljs-built_in">print</span>(warriorD.attack())   <span class="hljs-comment">// 90.0</span>
</code></pre>
<h2 data-id="heading-5">一个文件里同时玩三种精度</h2>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> wInt    <span class="hljs-operator">=</span> <span class="hljs-type">Warrior</span>&lt;<span class="hljs-type">Int</span>&gt;(calculator: <span class="hljs-type">CritCalculator</span>(rate: <span class="hljs-number">2</span>))
<span class="hljs-keyword">let</span> wDouble <span class="hljs-operator">=</span> <span class="hljs-type">Warrior</span>&lt;<span class="hljs-type">Double</span>&gt;(calculator: <span class="hljs-type">CritCalculator</span>(rate: <span class="hljs-number">2</span>))
<span class="hljs-keyword">let</span> wDec    <span class="hljs-operator">=</span> <span class="hljs-type">Warrior</span>&lt;<span class="hljs-type">Decimal</span>&gt;(calculator: <span class="hljs-type">CritCalculator</span>(rate: <span class="hljs-number">2</span>))

<span class="hljs-built_in">print</span>(wInt.attack())     <span class="hljs-comment">// 100</span>
<span class="hljs-built_in">print</span>(wDouble.attack())  <span class="hljs-comment">// 100.0</span>
<span class="hljs-built_in">print</span>(wDec.attack())     <span class="hljs-comment">// 100</span>
</code></pre>
<p>同一套算法，编译器自动生成三份特化（specialization）代码，运行时无盒子、无动态派发。</p>
<h2 data-id="heading-6">性能实测：零开销承诺是否兑现？</h2>
<p>测试环境：M1 Mac / Swift 5.9 / -O 优化</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> p <span class="hljs-operator">=</span> <span class="hljs-type">Warrior</span>&lt;<span class="hljs-type">Double</span>&gt;(calculator: <span class="hljs-type">CritCalculator</span>(rate: <span class="hljs-number">1.8</span>))
measure {
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">1_000_000</span> { <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> p.attack() }
}
</code></pre>
<p>结果：</p>
<ul>
<li>泛型特化版本：0.047 s</li>
<li>手写 <code>Double</code> 专用版本：0.046 s</li>
</ul>
<p>差距在 2% 以内，属于测量误差；汇编层面已无线程堆分配、无 protocol witness 调用。</p>
<h2 data-id="heading-7">什么时候回到引用语义？</h2>
<ol>
<li>计算器需要状态缓存（如随机种子、CD 计时）且要共享；</li>
<li>需要继承 NSObjec 以兼容 KVO / Core Data；</li>
<li>需要互斥锁、原子引用计数。</li>
</ol>
<p>其余场景继续 <code>struct + 泛型协议</code>。</p>
<h2 data-id="heading-8">最终决策清单（速查表）</h2>



































<table><thead><tr><th>需求场景</th><th>首选方案</th><th>备选方案</th></tr></thead><tbody><tr><td>只是多态</td><td>protocol 默认实现</td><td>class + override</td></tr><tr><td>多精度算法</td><td>泛型 protocol + associatedtype</td><td>宏/模板代码生成</td></tr><tr><td>共享可变状态</td><td>class</td><td>actor</td></tr><tr><td>值语义 + 组合</td><td>struct + protocol</td><td>无</td></tr><tr><td>运行时动态替换</td><td>class + objc</td><td>SwiftUI 的 AnyView 类型擦除</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[技术融合创新：Trae+KAT-Coder+GLM-4.6打造医疗报告翻译官]]></title>    <link>https://juejin.cn/post/7573332163388735542</link>    <guid>https://juejin.cn/post/7573332163388735542</guid>    <pubDate>2025-11-17T09:24:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573332163388735542" data-draft-id="7573300346263224374" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="技术融合创新：Trae+KAT-Coder+GLM-4.6打造医疗报告翻译官"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2025-11-17T09:24:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="_摘星_"/> <meta itemprop="url" content="https://juejin.cn/user/2228036358374227"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            技术融合创新：Trae+KAT-Coder+GLM-4.6打造医疗报告翻译官
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2228036358374227/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    _摘星_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:24:33.000Z" title="Mon Nov 17 2025 09:24:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/93943b9c97b1427f8dc0bf354f1413ff~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=UjBKZ1XJm4Toa7xhsn848EU7QNc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">技术融合创新：Trae+KAT-Coder+GLM-4.6打造医疗报告翻译官</h2>
<h3 data-id="heading-1">摘要</h3>
<p>作为这款“医疗报告翻译官”应用的开发者，我深切体会到技术真正落地于生活痛点时的力量。面对父母辈拿着体检单一脸茫然的样子，我决定用自己手中的工具做点什么——于是，我将字节的 Trae IDE 作为开发主战场，接入快手 KAT-Coder 强大的代码生成与智能代理能力，并融合智谱 GLM-4.6 的语言理解与 GLM-4.5V 的视觉识别优势，构建出一个能“看懂报告、说得明白”的AI助手。从一句提示词出发，到完整项目自动生成、本地调试、反复迭代，整个过程高效而充满成就感。最终，这个应用不仅能把“低密度脂蛋白”变成“血管里的垃圾车”，更让医学知识不再高不可攀——这是我作为一名开发者，送给普通用户、尤其是中老年群体的一份技术温度。</p>
<h3 data-id="heading-2">产品展示</h3>
<p>进入到首页</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47e7a14b75f1439083488ea78b17a894~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=yx4Sk7AX3aY32Q%2Fe9rGZhh1REvs%3D" alt="" loading="lazy"/></p>
<p>首先要设置GLM密钥，才能使用后续的GLM4.6和GLM4.5V服务</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d0aa07e165364b1ba45b87781a708491~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=ipMj7qYkp7ie2q%2Fkl9Pk9FafK1Y%3D" alt="" loading="lazy"/></p>
<p>这里我们将这个病例单上传到应用中</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3098677e7f8d41db9ded2683052efea8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=2Mm7DP5KH0NptXp6KZSGNvTDnA8%3D" alt="" loading="lazy"/></p>
<p>GLM4.5V开始识别图片</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/873e91b30c514d46866bd3fbfd732672~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=z9yDAr4Bgz5TKUQ1F9l1shaMiAA%3D" alt="" loading="lazy"/></p>
<p>识别完毕之后还会对原有的内容进行一个结构化的内容输出</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b65b001db12a4a7baabd22cb7fadfbf4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=Y9%2Foq2Hcv3CJ9%2B7jv4ruU4cpOn4%3D" alt="" loading="lazy"/>点击继续翻译直接跳转到文本翻译中，当然这里也可以自己输入内容：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bc4f4ec38da641b59d90ead8a7b1b20f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=ZkkeNfPU5C1ZEkGj958ziUu%2BIS4%3D" alt="" loading="lazy"/></p>
<p>点击开始翻译会就将晦涩难懂的内容给翻译成通俗易懂的内容：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ba38b51ac964a7e89d342c866e9960c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=5qdMAKVxCVJZJU2lLbM87h3cFBg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/db7b9f959f844d278c564d080302c064~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=%2FocLrEyecJvfyWe9Qrdqi72K4DQ%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1491d193689a4052a356e262937d9d3b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=c6DvHYwIg%2FeSGOB%2F0Wm1FqrJfPk%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3">项目背景</h3>
<p>在当今医疗健康领域，医患沟通不畅已成为普遍问题。患者面对检查报告中的专业医学术语如"低密度脂蛋白胆固醇"、"C反应蛋白"等时，往往难以理解，这种信息不对称不仅影响健康管理决策，还可能导致不必要的焦虑和延误治疗。</p>
<p>据统计，超过60%的患者无法准确理解医疗报告中的关键指标，约40%的患者因此延误必要医疗干预。传统解决方案如医生口头解释或在线查询，存在时效性差、个性化不足等问题，尤其在医疗资源紧张的情况下难以满足需求。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1287119c3dbe4feeb7e36d513f53c3c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=BoTLRyWdtRNnpMy0IiIVBgqYenw%3D" alt="" loading="lazy"/></p>
<p>随着大语言模型技术的突破，AI为解决这一痛点提供了新可能。本项目旨在构建智能医疗报告翻译官应用，通过先进AI模型将专业医学术语转化为生活化语言，为患者提供即时、准确、易懂的报告解读服务，让专业医学知识变得触手可及。</p>
<h3 data-id="heading-4">KAT-Coder</h3>
<p>KAT-Coder官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.streamlake.com%2Fproduct%2Fkat-coder" target="_blank" title="https://www.streamlake.com/product/kat-coder" ref="nofollow noopener noreferrer">www.streamlake.com/product/kat…</a></p>
<p>KAT-Coder-Pro-V1是快手旗下StreamLake平台推出的一款顶级编码AI助手，代表了当前AI编程领域的最先进水平。 该模型在SWE-Bench评测中获得了73.4%的解决率，这一成绩甚至超过了GPT-5和Claude Sonnet 4等国际知名模型，展示了其在复杂任务处理方面的卓越能力。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d701028af128490bb0729e7570522077~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=UF7XJ460gm7kRXVfST6SZPrT1ew%3D" alt="" loading="lazy"/></p>
<p>KAT-Coder-Pro-V1的核心优势在于其先进的智能代理能力。该模型支持多工具并行调用，能够自主完成复杂任务，这种能力对于构建医疗报告翻译官这样需要多步骤处理的应用至关重要。 在实际应用中，KAT-Coder-Pro-V1生成的代码不仅可以直接运行，还展现出较为成熟的工程化水平，包括前端界面设计、内置应用集成等，这为快速构建完整的医疗应用提供了强大支持。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ea1809806384acab79a91d047e56c0f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=Db3hznXcPm%2F3BqpcGBOyc%2B5Mv1s%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-5">Trae</h3>
<p>Trae官网：<a href="https://www.trae.ai/" target="_blank" title="https://www.trae.ai/" ref="nofollow noopener noreferrer">www.trae.ai/</a></p>
<p>Trae是由字节跳动推出的一款AI驱动的智能集成开发环境（IDE），旨在通过人工智能技术显著提升软件开发效率。 作为一款现代化的AI编程助手，Trae不仅支持主流的AI模型如Anthropic和OpenAI，还提供了强大的自定义模型集成能力，这使其成为构建专业领域AI应用的理想平台。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1c64605228e844f1b4155a5659f79f1e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=yRK0rkYy%2BQatTqbWVndqdb1sFFI%3D" alt="" loading="lazy"/></p>
<p>Trae对OpenRouter等开放平台的支持，这为开发者提供了更大的灵活性，使其能够根据具体需求选择和集成最适合的AI模型。 同时，社区正在积极推动对自定义模型服务商base_url的支持能力，这将进一步增强Trae在企业级应用中的适应性。这些特性使得Trae成为连接自定义AI模型（如KAT-Coder-Pro-V1）与专业应用场景（如医疗报告翻译）的理想桥梁，为我们的项目提供了坚实的技术基础。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/12a7ba79f1894defa4a8035f452bfb61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=2dRomH3ncH51%2BXiOvQApT%2FxNhX4%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6">Trae接入自定义模型KAT-Coder</h3>
<p>官方文档参考：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FKXSRoBaME_Wvv2wlRZ_FaA" target="_blank" title="https://mp.weixin.qq.com/s/KXSRoBaME_Wvv2wlRZ_FaA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/KXSRoBaME…</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f08abee52b174284bd2e2eed7afb06bd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=kGMrgH1HX7H%2FZq%2F9QOa8xYb3224%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-7">获取API Key</h4>
<p>访问：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnovita.ai%2Fsettings%2Fkey-management" target="_blank" title="https://novita.ai/settings/key-management" ref="nofollow noopener noreferrer">novita.ai/settings/ke…</a>novita.ai服务商点击密钥管理</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a0a2577f207a4cbcbcd21e79d40003b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=etaQg8ggsNNuuSD%2FiTWlOZk5BsM%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-8">接入Trae</h4>
<p>Trae中点击【设置】-【模型】-【自定义模型】</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ad7b15e4334447a8dbdadc5f935e0d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=xe2aiiMQTw%2BnJXe7lNC303vEmZg%3D" alt="" loading="lazy"/></p>
<p>选择novita.ai服务商，模型输入kat-coder，密钥就是刚刚创建的密钥</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8128fe0fb5414c0bb7d4003fba84fea7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=iurHxI5cnV2otKA10Hjne5RE2XE%3D" alt="" loading="lazy"/></p>
<p>自定义模型kat-coder加入成功</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a9dc43699c442d9b7066bc8eedc273e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=VMz91FWxkvwvFeSa8wUZzCMQuVc%3D" alt="" loading="lazy"/></p>
<p>在对话中选择Kat-coder</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ffd741ad816d4dab92a04e487229e52a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=mMlaZn%2F9%2FCt%2BBDsKrTHyy9IyI3c%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-9">智谱大模型</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bigmodel.cn%2F" target="_blank" title="https://www.bigmodel.cn/" ref="nofollow noopener noreferrer">智谱AI</a>（Zhipu AI）是中国领先的大模型技术公司，致力于推动通用人工智能（AGI）的发展。其自主研发的GLM（General Language Model）系列大模型，凭借强大的语言理解与生成能力、多模态融合能力以及高效的推理性能，已在学术界和产业界获得广泛认可。</p>
<p>在医疗报告翻译官应用中，我们采用GLM-4.6与GLM-4.5V双模型协同架构，分别负责语言理解和视觉识别两大核心功能。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/246130590e974d9da4d7e948b3d61096~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=RCq4HwHS%2B5Mtca1T0FJ3EftBh88%3D" alt="" loading="lazy"/></p>
<p>GLM-4.6作为智谱AI的旗舰语言模型，采用355B参数的混合专家架构，拥有200K超长上下文处理能力，稳居国内模型性能榜首。 该模型在工具使用和代理任务方面表现卓越，能高效集成到复杂的工作流中，特别适合将专业医疗术语转化为生活化表达。 其token消耗比前代降低30%，为实时交互提供了成本效益保障。</p>
<p>GLM-4.5V则是专为视觉任务设计的开源多模态模型，在42个视觉语言基准测试中表现优异。 该模型具备强大的OCR能力，能够精准提取医疗报告图像中的文字内容，包括复杂的医学图表和手写体。 在医疗影像分析方面，GLM-4.5V能精确定位图像中的关键元素，为后续的语言解释提供准确的视觉输入。</p>
<p>双模型协同工作流程为：GLM-4.5V负责处理用户上传的纸质或电子报告图片，通过OCR技术提取文本内容；GLM-4.6则接收提取的文本，将专业医学术语转化为通俗易懂的日常表达。 这种分工模式充分发挥了各自优势，确保系统既能"看得清"报告内容，又能"说得懂"医学含义，为患者提供无缝的医疗报告解读体验。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4b7f27517345433ca1f70b2be2ee8ceb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=%2Fjo3WohWHAXYHt1KOQM44WKFkPY%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-10">获取API KEY</h4>
<p>在智谱AI开放平台的<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bigmodel.cn%2Fusercenter%2Fproj-mgmt%2Fapikeys" target="_blank" title="https://www.bigmodel.cn/usercenter/proj-mgmt/apikeys" ref="nofollow noopener noreferrer">控制台</a>中，即可添加账号的API KEY</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8644bb20b9a348218f8d470ef90a821f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=YngpTsJ%2BPBv%2FePJnZyxnXdssrB8%3D" alt="" loading="lazy"/></p>
<p>添加完之后需要使用的时候直接复制API KEY即可</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c844a16587443aebe38f8cfb4fc4f72~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=Jm0RQ6%2FYS89laq53BlSh6733KTY%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-11">GLM-4.6</h4>
<p>智谱最新旗舰，代码能力全面对齐 Claude Sonnet 4，是国内最好的编程模型。在真实编程、长上下文处理、推理能力、信息搜索、写作能力与智能体应用等多个方面实现全面提升。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99b5860fe92f4e2f9a655f179c064cfa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=t4M7gUJDRaPlCkKqatau2kj%2BTK8%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/141ad591f4b94e6a80806b8d0043a307~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=Ckh8JR0ahM3Ri%2BXMhaLsDaBUfBU%3D" alt="" loading="lazy"/></p>
<p>GLM-4.6调用示例</p>
<pre><code class="hljs language-vbnet" lang="vbnet">curl -X POST <span class="hljs-string">"https://open.bigmodel.cn/api/paas/v4/chat/completions"</span> \
    -H <span class="hljs-string">"Content-Type: application/json"</span> \
    -H <span class="hljs-string">"Authorization: Bearer your-api-key"</span> \
    -d <span class="hljs-comment">'{</span>
        <span class="hljs-string">"model"</span>: <span class="hljs-string">"glm-4.6"</span>,
        <span class="hljs-string">"messages"</span>: [
        {
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
            <span class="hljs-string">"content"</span>: <span class="hljs-string">"作为一名营销专家，请为我的产品创作一个吸引人的口号"</span>
        },
        {
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"assistant"</span>,
            <span class="hljs-string">"content"</span>: <span class="hljs-string">"当然，要创作一个吸引人的口号，请告诉我一些关于您产品的信息"</span>
        },
        {
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
            <span class="hljs-string">"content"</span>: <span class="hljs-string">"智谱AI 开放平台"</span>
        }
            ],
            <span class="hljs-string">"thinking"</span>: {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"enabled"</span>
        },
            <span class="hljs-string">"max_tokens"</span>: <span class="hljs-number">65536</span>,
            <span class="hljs-string">"temperature"</span>: <span class="hljs-number">1.0</span>
        }<span class="hljs-comment">'</span>
</code></pre>
<h4 data-id="heading-12">GLM-4.5V</h4>
<p>GLM-4.5V 是智谱新一代基于 MOE 架构的视觉推理模型，以 106B 的总参数量和 12B 激活参数量，在各类基准测试中达到全球同级别开源多模态模型 SOTA，涵盖图像、视频、文档理解及 GUI 任务等常见任务。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b85eec11df3425ca128370d4f9c8536~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=fTLtcoDp3wjPiKTKI1w2M3xS%2Bb8%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d0a52341548740a58dceb6b1b33a0a0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=towuAW%2BYwiRNjbb23QXQkh%2FWpTU%3D" alt="" loading="lazy"/></p>
<p>调用示例</p>
<pre><code class="hljs language-arduino" lang="arduino">curl -X POST \
  https:<span class="hljs-comment">//open.bigmodel.cn/api/paas/v4/chat/completions \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{</span>
    <span class="hljs-string">"model"</span>: <span class="hljs-string">"glm-4.5v"</span>,
    <span class="hljs-string">"messages"</span>: [
      {
        <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
        <span class="hljs-string">"content"</span>: [
          {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"image_url"</span>,
            <span class="hljs-string">"image_url"</span>: {
              <span class="hljs-string">"url"</span>: <span class="hljs-string">"https://cloudcovert-1305175928.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87grounding.PNG"</span>
            }
          },
          {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span>,
            <span class="hljs-string">"text"</span>: <span class="hljs-string">"Where is the second bottle of beer from the right on the table?  Provide coordinates in [[xmin,ymin,xmax,ymax]] format"</span>
          }
        ]
      }
    ],
    <span class="hljs-string">"thinking"</span>: {
      <span class="hljs-string">"type"</span>:<span class="hljs-string">"enabled"</span>
    }
  }'
</code></pre>
<h3 data-id="heading-13">开发实践</h3>
<h4 data-id="heading-14">开发提示词</h4>
<p>准备好开发提示词并输入：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">我要做一个医疗报告翻译官应用，目的是解决中老年人看不懂纸质病例上的专业医学术语
功能：
<span class="hljs-number">1</span>、语言交互：输入检查报告结论，调用GLM-<span class="hljs-number">4.6</span>用生活化语言解释指标意义，也就是说将繁琐的医疗术语翻译成普通人都能听得懂的样子（如“低密度脂蛋白=血管垃圾车”），翻译出的语言用精美柔和的卡片风格展示。
<span class="hljs-number">2</span>、视觉交互：拍照上传医院的纸质报告单或者电子报告单，调用GLM-<span class="hljs-number">4.5</span>V识别文字后，再重复语言交互的过程
<span class="hljs-number">3</span>、GLM的密钥存放在localstorage中，每次进入页面的时候需要在设置中手动输入，设置中包含测试链接的按钮
<span class="hljs-number">4</span>、整体以医疗极简风格，使用低饱和的辅助色（如蓝、绿）：蓝色代表信任与科技，绿色代表健康与安心，避免使用红色、橙色等刺激性暖色
GLM4.<span class="hljs-number">6</span>接入示例：
curl -X POST <span class="hljs-string">"https://open.bigmodel.cn/api/paas/v4/chat/completions"</span> \
    -H <span class="hljs-string">"Content-Type: application/json"</span> \
    -H <span class="hljs-string">"Authorization: Bearer your-api-key"</span> \
    -d <span class="hljs-comment">'{</span>
        <span class="hljs-string">"model"</span>: <span class="hljs-string">"glm-4.6"</span>,
        <span class="hljs-string">"messages"</span>: [
        {
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
            <span class="hljs-string">"content"</span>: <span class="hljs-string">"作为一名营销专家，请为我的产品创作一个吸引人的口号"</span>
        },
        {
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"assistant"</span>,
            <span class="hljs-string">"content"</span>: <span class="hljs-string">"当然，要创作一个吸引人的口号，请告诉我一些关于您产品的信息"</span>
        },
        {
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
            <span class="hljs-string">"content"</span>: <span class="hljs-string">"智谱AI 开放平台"</span>
        }
            ],
            <span class="hljs-string">"thinking"</span>: {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"enabled"</span>
        },
            <span class="hljs-string">"max_tokens"</span>: <span class="hljs-number">65536</span>,
            <span class="hljs-string">"temperature"</span>: <span class="hljs-number">1.0</span>
        }<span class="hljs-comment">'</span>
GLM4.<span class="hljs-number">5</span>V接入示例：
curl -X POST \
  https://open.bigmodel.cn/api/paas/v4/chat/completions \
  -H <span class="hljs-string">"Authorization: Bearer your-api-key"</span> \
  -H <span class="hljs-string">"Content-Type: application/json"</span> \
  -d <span class="hljs-comment">'{</span>
    <span class="hljs-string">"model"</span>: <span class="hljs-string">"glm-4.5v"</span>,
    <span class="hljs-string">"messages"</span>: [
      {
        <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
        <span class="hljs-string">"content"</span>: [
          {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"image_url"</span>,
            <span class="hljs-string">"image_url"</span>: {
              <span class="hljs-string">"url"</span>: <span class="hljs-string">"https://cloudcovert-1305175928.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87grounding.PNG"</span>
            }
          },
          {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span>,
            <span class="hljs-string">"text"</span>: <span class="hljs-string">"Where is the second bottle of beer from the right on the table?  Provide coordinates in [[xmin,ymin,xmax,ymax]] format"</span>
          }
        ]
      }
    ],
    <span class="hljs-string">"thinking"</span>: {
      <span class="hljs-string">"type"</span>:<span class="hljs-string">"enabled"</span>
    }
  }<span class="hljs-comment">'</span>
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7d384bb83af44a8b0116bcf350d2803~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=OMv4QHOG%2BcY5Sm7XWoXGNq7zzx0%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-15">开发文档</h4>
<p>我会先让其生成开发文档，这样不会在后续的过程中走偏方向，以下是文档的具体内容：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">## 1. 产品概述</span>
医疗报告翻译官应用旨在帮助中老年人理解纸质病历上的专业医学术语，将复杂的医疗报告转化为通俗易懂的生活化语言。

通过AI技术将医疗术语翻译成形象的比喻（如"低密度脂蛋白=血管垃圾车"），让普通用户能够轻松理解自己的健康状况。

<span class="hljs-section">## 2. 核心功能</span>

<span class="hljs-section">### 2.1 用户角色</span>
| 角色 | 注册方式 | 核心权限 |
|------|----------|----------|
| 普通用户 | 无需注册，直接使用 | 文本输入翻译、图片上传识别、API密钥设置 |

<span class="hljs-section">### 2.2 功能模块</span>
应用包含以下主要页面：
<span class="hljs-bullet">1.</span> <span class="hljs-strong">**首页**</span>：功能选择、使用引导、最近翻译记录
<span class="hljs-bullet">2.</span> <span class="hljs-strong">**文本翻译页**</span>：医疗术语输入、翻译结果展示、收藏功能
<span class="hljs-bullet">3.</span> <span class="hljs-strong">**图片识别页**</span>：拍照上传、图片预览、识别结果展示
<span class="hljs-bullet">4.</span> <span class="hljs-strong">**设置页**</span>：API密钥输入、测试连接、使用说明

<span class="hljs-section">### 2.3 页面详情</span>
| 页面名称 | 模块名称 | 功能描述 |
|-----------|-------------|-------------|
| 首页 | 功能选择区 | 显示文本翻译和图片识别两个主要功能入口，使用大图标和简洁文字说明 |
| 首页 | 使用引导 | 展示应用使用步骤，帮助用户快速上手 |
| 首页 | 最近记录 | 显示最近5条翻译记录，点击可查看详情 |
| 文本翻译页 | 输入区域 | 多行文本框输入医疗报告结论，支持粘贴和清空操作 |
| 文本翻译页 | 翻译按钮 | 调用GLM-4.6 API进行翻译，显示加载状态 |
| 文本翻译页 | 结果展示 | 精美卡片展示翻译结果，包含原文和通俗解释 |
| 文本翻译页 | 收藏功能 | 支持收藏常用翻译结果，本地存储 |
| 图片识别页 | 拍照上传 | 支持拍照和从相册选择，图片压缩和预览 |
| 图片识别页 | 识别过程 | 显示识别进度，调用GLM-4.5V API提取文字 |
| 图片识别页 | 结果确认 | 展示识别的文字内容，用户可编辑修正 |
| 图片识别页 | 翻译跳转 | 识别完成后跳转到文本翻译页继续翻译 |
| 设置页 | API密钥设置 | 输入GLM API密钥，本地存储在localStorage |
| 设置页 | 连接测试 | 测试API连接状态，显示成功或失败提示 |
| 设置页 | 使用说明 | 详细的应用使用指南和注意事项 |

<span class="hljs-section">## 3. 核心流程</span>

<span class="hljs-section">### 文本翻译流程</span>
<span class="hljs-bullet">1.</span> 用户在文本翻译页输入医疗报告结论
<span class="hljs-bullet">2.</span> 点击翻译按钮，调用GLM-4.6 API
<span class="hljs-bullet">3.</span> API返回生活化语言解释
<span class="hljs-bullet">4.</span> 以精美卡片形式展示翻译结果
<span class="hljs-bullet">5.</span> 用户可选择收藏或分享

<span class="hljs-section">### 图片识别翻译流程</span>
<span class="hljs-bullet">1.</span> 用户在图片识别页拍照或选择图片
<span class="hljs-bullet">2.</span> 图片预览和压缩处理
<span class="hljs-bullet">3.</span> 调用GLM-4.5V API识别图片中的文字
<span class="hljs-bullet">4.</span> 展示识别结果，用户可编辑修正
<span class="hljs-bullet">5.</span> 将修正后的文本发送到文本翻译流程

<span class="hljs-code">```mermaid
graph TD
    A[首页] --&gt; B[文本翻译页]
    A --&gt; C[图片识别页]
    C --&gt; D[图片预览]
    D --&gt; E[文字识别]
    E --&gt; F[识别结果确认]
    F --&gt; B
    B --&gt; G[翻译结果展示]
    A --&gt; H[设置页]
    H --&gt; I[API密钥配置]
    I --&gt; J[连接测试]
```</span>

<span class="hljs-section">## 4. 用户界面设计</span>

<span class="hljs-section">### 4.1 设计风格</span>
<span class="hljs-bullet">-</span> <span class="hljs-strong">**主色调**</span>：低饱和度蓝色 (#4A90E2) - 代表信任与科技
<span class="hljs-bullet">-</span> <span class="hljs-strong">**辅助色**</span>：低饱和度绿色 (#7ED321) - 代表健康与安心
<span class="hljs-bullet">-</span> <span class="hljs-strong">**背景色**</span>：浅灰色 (#F5F7FA) - 营造医疗专业感
<span class="hljs-bullet">-</span> <span class="hljs-strong">**按钮样式**</span>：圆角矩形，柔和阴影，悬停效果
<span class="hljs-bullet">-</span> <span class="hljs-strong">**字体**</span>：思源黑体，主标题18px，正文14px，小字12px
<span class="hljs-bullet">-</span> <span class="hljs-strong">**布局风格**</span>：卡片式布局，大间距，简洁明了
<span class="hljs-bullet">-</span> <span class="hljs-strong">**图标风格**</span>：线性图标，简洁易懂

<span class="hljs-section">### 4.2 页面设计概述</span>
| 页面名称 | 模块名称 | UI元素 |
|-----------|-------------|-------------|
| 首页 | 功能选择区 | 两个大圆形按钮，蓝色和绿色渐变，中央放置图标和文字，按钮间距充足 |
| 首页 | 使用引导 | 三步流程图，使用柔和的绿色连接线，每步配有简洁图标 |
| 首页 | 最近记录 | 白色卡片列表，显示原文摘要和翻译时间，右侧箭头指示 |
| 文本翻译页 | 输入区域 | 浅蓝色边框的文本域，圆角设计，支持自动高度调整 |
| 文本翻译页 | 翻译按钮 | 绿色渐变按钮，圆形设计，包含翻译图标 |
| 文本翻译页 | 结果展示 | 精美的白色卡片，蓝色标题栏，内部展示通俗解释，底部操作按钮 |
| 图片识别页 | 拍照区域 | 虚线边框的上传区域，中央相机图标，支持拖拽上传 |
| 图片识别页 | 图片预览 | 圆角图片展示，支持缩放和旋转，底部操作栏 |
| 设置页 | API输入 | 安全的密码输入框，显示/隐藏切换按钮，测试按钮 |

<span class="hljs-section">### 4.3 响应式设计</span>
<span class="hljs-bullet">-</span> <span class="hljs-strong">**桌面优先**</span>：主要面向平板和手机使用，采用响应式设计
<span class="hljs-bullet">-</span> <span class="hljs-strong">**断点设置**</span>：768px（平板）、1024px（桌面）
<span class="hljs-bullet">-</span> <span class="hljs-strong">**触摸优化**</span>：按钮尺寸最小44px，支持手势操作
<span class="hljs-bullet">-</span> <span class="hljs-strong">**字体适配**</span>：根据屏幕大小自动调整字体大小
</code></pre>
<h4 data-id="heading-16">开发交互</h4>
<p>开始生成之后可以在控制台实时监控</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39136e590790407290e6078698c513c2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=cqs53ZlCs3vpkJo%2B3KH9j6e4vYE%3D" alt="" loading="lazy"/></p>
<p>不一会就生成成了一整个完整的项目</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cec5b6f58deb444db992dfebc7c9a0cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=TuCpiKBwI8PPLIA8RxhsCXSXHzY%3D" alt="" loading="lazy"/></p>
<p>并且也是在本地启动了，这时候我们需要进行一次测试，并且不断的给出反馈：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/90e406b4226b41688f3d2cfe373ed18c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=8l51YhqFF9511aZ421U4LgF3bzA%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee887db02a4346bb842e105ad7daae0c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=lou%2Bl2hjJncm1HSbfJpjvEVRCyY%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ebd394f5153a405fbdfb5a2f2716d87d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=4ADOxtHGauUpfB9NyVHsnetXoMs%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/68ccc461859e4b6d9ad59540ec620ca7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976273&amp;x-signature=6jp54cbJAoupW2fDkv%2FpuLrEsoQ%3D" alt="" loading="lazy"/></p>
<p>重复几次之后就会得到我们想要的结果，接下来就是部署上线~</p>
<h4 data-id="heading-17">总结</h4>
<p>本文系统介绍了“医疗报告翻译官”应用的开发全流程，聚焦于解决中老年人难以理解专业医疗术语的核心痛点。项目基于<strong>Trae IDE</strong>作为开发环境，集成<strong>KAT-Coder</strong>（由快手StreamLake提供）实现高效代码生成与工程化能力，并结合<strong>智谱AI</strong>的双模型架构——<strong>GLM-4.6</strong>（负责自然语言理解与通俗化翻译）与<strong>GLM-4.5V</strong>（负责医疗报告图像的OCR识别与结构化提取）——构建端到端的智能翻译系统。应用支持文本输入与图片上传两种交互模式，采用医疗友好型UI设计，强调低饱和蓝绿色调与卡片式布局，注重可用性与情感体验。整个开发过程通过提示词驱动、自动生成、本地测试与迭代优化，体现了AI原生开发范式在垂直领域产品落地中的高效性与可行性。</p>
<h4 data-id="heading-18">参考链接</h4>
<ul>
<li><strong>Trae IDE 官网</strong>：<a href="https://www.trae.ai/" target="_blank" title="https://www.trae.ai/" ref="nofollow noopener noreferrer">www.trae.ai/</a></li>
<li><strong>KAT-Coder 产品页</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.streamlake.com%2Fproduct%2Fkat-coder" target="_blank" title="https://www.streamlake.com/product/kat-coder" ref="nofollow noopener noreferrer">www.streamlake.com/product/kat…</a></li>
<li><strong>智谱AI 开放平台</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bigmodel.cn%2F" target="_blank" title="https://www.bigmodel.cn/" ref="nofollow noopener noreferrer">www.bigmodel.cn/</a></li>
<li><strong>GLM-4.6 与 GLM-4.5V API 文档</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fopen.bigmodel.cn%2F" target="_blank" title="https://open.bigmodel.cn/" ref="nofollow noopener noreferrer">open.bigmodel.cn/</a></li>
<li><strong>自定义模型接入 Trae 指南</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FKXSRoBaME_Wvv2wlRZ_FaA" target="_blank" title="https://mp.weixin.qq.com/s/KXSRoBaME_Wvv2wlRZ_FaA" ref="nofollow noopener noreferrer">mp.weixin.qq.com/s/KXSRoBaME…</a></li>
<li><strong>Novita.ai 密钥管理</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnovita.ai%2Fsettings%2Fkey-management" target="_blank" title="https://novita.ai/settings/key-management" ref="nofollow noopener noreferrer">novita.ai/settings/ke…</a></li>
</ul>
<p>#AI医疗 #智能翻译 #Trae #KATCoder #GLM4.6 #GLM4.5V</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Trae Solo+豆包Version1.6+Seedream4.0打造"AI识菜通"]]></title>    <link>https://juejin.cn/post/7573336057481314310</link>    <guid>https://juejin.cn/post/7573336057481314310</guid>    <pubDate>2025-11-17T09:26:30.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573336057481314310" data-draft-id="7573332163388751926" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Trae Solo+豆包Version1.6+Seedream4.0打造&quot;AI识菜通&quot;"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2025-11-17T09:26:30.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="_摘星_"/> <meta itemprop="url" content="https://juejin.cn/user/2228036358374227"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Trae Solo+豆包Version1.6+Seedream4.0打造"AI识菜通"
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2228036358374227/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    _摘星_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:26:30.000Z" title="Mon Nov 17 2025 09:26:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c1476bdb094a450384058ad83af0cbc1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=d5KReQaPMwCngvjpc5g%2FdWUavVc%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">Trae Solo+豆包Version1.6+Seedream4.0打造"AI识菜通"</h2>
<h3 data-id="heading-1">摘要</h3>
<p>在人工智能技术迅猛发展的今天，大模型正以前所未有的深度与广度渗透进日常生活的各个场景。从智能客服到内容创作，从代码生成到图像理解，AI 正在重塑人与信息、人与服务之间的交互方式。而在餐饮这一高频、高感知的领域，语言障碍与菜单理解困难长期困扰着跨国旅行者、留学生乃至本地食客——面对一张满是陌生文字或模糊排版的菜单，如何快速识别菜品、理解其风味、并准确下单？正是在这一现实痛点驱动下，我们开发了“AI识菜通”——一款融合多模态感知、跨语言理解与生成式视觉的智能点餐助手。</p>
<p>“AI识菜通”的核心目标，是让用户只需上传一张任意语言的菜单图片，即可在数秒内获得结构化、本地化（中文）的菜品列表，每道菜附带精准描述与逼真图像，并支持一键加入购物车、生成可直接向服务员展示的点餐字符串。这一看似简单的流程背后，实则涉及图像识别、多语言翻译、语义理解、图像生成、状态管理与前端交互等多个技术模块的协同。而要让这些模块高效、准确、一致地工作，关键不在于单个模型的性能上限，而在于如何构建一个强大、灵活、可维护的<strong>上下文工程（Context Engineering）体系</strong>。</p>
<p>在本项目中，我们创新性地以 <strong>Trae Solo</strong> 作为上下文工程的核心引擎，协同 <strong>字节跳动豆包大模型 Version 1.6</strong>（负责多语言理解与结构化输出）与 <strong>Seedream 4.0</strong>（负责高质量菜品图像生成），共同构建了一个端到端的智能点餐系统。本文将重点剖析 Trae Solo 在“AI识菜通”中的上下文工程实践，揭示其如何通过精细化的上下文设计、动态记忆管理与多轮意图对齐，显著提升整个系统的准确性、鲁棒性与用户体验。</p>
<h3 data-id="heading-2">Trae Solo</h3>
<p>官网：<a href="https://www.trae.ai/solo" target="_blank" title="https://www.trae.ai/solo" ref="nofollow noopener noreferrer">www.trae.ai/solo</a>，目前Trae Solo模式需要在官网申请体验码，感兴趣的小伙伴赶快去申请吧。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4864a1e6e0fb43e4bf124213ddeb4744~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=ocv1W%2FvhtqxZjPQW7zMXXS55SFs%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-3">1. 从 Prompt Engineering 到 Context Engineering</h4>
<p>过去几年，Prompt Engineering（提示词工程）被视为驾驭大模型的核心技能。开发者通过精心设计输入文本，引导模型输出期望结果。然而，随着AI应用场景从单轮问答走向多步骤、多模态、状态依赖的复杂任务（如智能客服、自动化办公、个性化推荐），静态、孤立的 prompt 已显乏力。问题在于：真实世界的任务往往具有<strong>上下文依赖性</strong>——当前操作依赖于历史行为，模型输出需与系统状态对齐，用户意图在交互中动态演化。</p>
<p>正是在这一背景下，<strong>上下文工程（Context Engineering）</strong> 应运而生。它不再将AI调用视为一次性的“黑箱请求”，而是将其嵌入一个<strong>结构化、可演化、可追溯的上下文空间</strong>中。上下文工程关注的核心问题是：<strong>如何在正确的时间，向正确的模型，提供正确的上下文信息，以驱动整个系统达成目标？</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c268c13c980e49cb875d209c3bd68836~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=EAsk6zKst2zA92OacoNUag29F0U%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-4">2. Trae Solo：上下文工程的操作系统</h4>
<p>Trae Solo 并非一个大语言模型，而是一个专为复杂AI应用设计的<strong>上下文编排与推理调度平台</strong>。它旨在成为AI系统的“操作系统”，负责管理任务流、维护状态、协调多模型协作，并确保上下文在全生命周期中的一致性与有效性。</p>
<p>Trae Solo 的核心能力可概括为以下四点：</p>
<p><strong>（1）结构化上下文建模</strong><br/>
Trae Solo 允许开发者以声明式方式定义整个应用的上下文结构。这包括：</p>
<ul>
<li><strong>输入上下文</strong>：用户上传的图像、文本、地理位置、设备类型等原始数据；</li>
<li><strong>系统状态上下文</strong>：当前任务阶段、已提取的实体、用户选择、错误状态等；</li>
<li><strong>模型能力上下文</strong>：各AI模型的接口规范、输入输出格式、性能边界、调用成本等；</li>
<li><strong>领域知识上下文</strong>：预加载的行业术语、常见实体库、业务规则等。</li>
</ul>
<p>这些上下文被组织为一个动态更新的“上下文图谱”（Context Graph），所有模块均可读写，确保信息同步。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c1f1aa5b7554ea19fe84c8fc336e1ab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=AXWpEv599h5A0wIuE8iWurRkcik%3D" alt="" loading="lazy"/></p>
<p><strong>（2）动态上下文注入与路由</strong><br/>
在调用任一AI模型前，Trae Solo 会根据当前任务阶段与系统状态，<strong>动态组装最合适的上下文包</strong>。例如，在菜单识别阶段，它会将图像、语言先验、菜系知识、任务指令等打包发送给豆包模型；而在生成点餐字符串时，则只传递选中的菜品列表与格式要求。这种按需注入机制，既提升了模型输出的相关性，又避免了信息过载。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5c8767d29664092b9d52d4769cdd9f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=8VvOo%2FyzfXfnVu7qmXrvo0sv9lc%3D" alt="" loading="lazy"/></p>
<p><strong>（3）多轮意图对齐与状态管理</strong><br/>
用户交互是动态的。Trae Solo 内置强大的状态机与意图识别模块，能够实时捕获用户行为（如点击、取消、修改），并更新上下文图谱。更重要的是，它支持<strong>上下文回溯、分支与合并</strong>——当用户修改选择时，系统能快速撤销相关操作，而不会导致状态混乱。这种对用户意图的持续对齐，是构建流畅体验的基础。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b0a35fe3e05043f89134d8a32228117b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=GjIHZhGo2CDUae98Fw9Eqg49%2BkM%3D" alt="" loading="lazy"/></p>
<p><strong>（4）错误处理与降级策略</strong><br/>
AI模型并非100%可靠。Trae Solo 提供了完善的错误监控与降级机制。例如，若豆包模型返回格式错误，系统可自动切换至备用OCR+翻译流程；若Seedream图像生成失败，则回退至默认占位图。所有错误均被记录到上下文日志中，便于后续分析与优化。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cdf930b7895a4396a866d83bf4ae2c48~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=RR9PDcBq6C5dK59CjguOM1DZtl0%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-5">3. 上下文工程的价值：从“能用”到“好用”</h4>
<p>通过 Trae Solo 实施上下文工程，AI系统实现了三大跃升：</p>
<ul>
<li><strong>准确性提升</strong>：上下文提供领域知识与任务约束，显著减少模型幻觉；</li>
<li><strong>鲁棒性增强</strong>：状态管理与错误处理机制保障系统在异常情况下仍可运行；</li>
<li><strong>可维护性提高</strong>：上下文结构清晰，模块解耦，便于迭代与调试。</li>
</ul>
<p>可以说，上下文工程是AI应用从“技术演示”走向“产品落地”的必经之路。而 Trae Solo，正是这条路上的强大引擎。</p>
<p>而 <strong>Trae Solo</strong>，正是为实现这一目标而设计的上下文工程框架。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7d35e5dd88c4347afd46901599d1256~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=%2FncVco1RlxdSzClaxPZfAFadCkM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6">豆包大模型接入指南</h3>
<p>本项目所用的视觉理解大模型和文生图大模型均采用火山引擎Mass平台，分别是doubao-seed-1-6-vision-250815和doubao-seedream-4-0-250828</p>
<h4 data-id="heading-7">火山引擎Mass平台</h4>
<p>官网：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.volcengine.com%2F" target="_blank" title="https://www.volcengine.com/" ref="nofollow noopener noreferrer">www.volcengine.com/</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/780d34c2eec64d9696ed5e6a04b4f134~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=Kow7mqm2Q8U8w1LxfP2XzEAOGxw%3D" alt="" loading="lazy"/></p>
<p>点击需要的AI API进入</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/db94acdcff9c48fbbf019560b652b9a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=2otmfEzkYTdujC1bzTS3HfhMtzc%3D" alt="" loading="lazy"/></p>
<p>进行快捷API 接入即可</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3886602a3c2d42ffaad04c0e35520f5f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=jCKDbBaS2StvuDvwzwUknmW5rPg%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-8">doubao-seed-1-6-vision</h4>
<p>doubao-seed-1-6-vision：适用于视频理解、Grounding、GUI Agent等高复杂度的场景，与Doubao-1.5-thinking-vision-pro相比，在教育、图像审核、巡检与安防和AI搜索问答等场景下展现出更强的通用多模态理解和推理能力，支持 256k 上下文窗口，输出长度支持最大 64k tokens。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/eae046d7fd274303b87a3931f42d1c88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=CmUuEgAs7v7fDhWzJtBhCqHQmT8%3D" alt="" loading="lazy"/></p>
<p>下方是调用示例：</p>
<pre><code class="hljs language-arduino" lang="arduino">curl https:<span class="hljs-comment">//ark.cn-beijing.volces.com/api/v3/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your api key" \
  -d $'{</span>
    <span class="hljs-string">"model"</span>: <span class="hljs-string">"doubao-seed-1-6-vision-250815"</span>,
    <span class="hljs-string">"messages"</span>: [
        {
            <span class="hljs-string">"content"</span>: [
                {
                    <span class="hljs-string">"image_url"</span>: {
                        <span class="hljs-string">"url"</span>: <span class="hljs-string">"https://ark-project.tos-cn-beijing.ivolces.com/images/view.jpeg"</span>
                    },
                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"image_url"</span>
                },
                {
                    <span class="hljs-string">"text"</span>: <span class="hljs-string">"图片主要讲了什么?"</span>,
                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span>
                }
            ],
            <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>
        }
    ]
}'
</code></pre>
<h4 data-id="heading-9">doubao-seedream-4.0</h4>
<p>doubao-seedream-4.0基于领先架构的SOTA级多模态图像创作模型。其打破传统文生图模型的创作边界，原生支持文本、单图和多图输入，用户可自由融合文本与图像，在同一模型下实现基于主体一致性的多图融合创作、图像编辑、组图生成等多样玩法，让图像创作更加自由可控。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/12f9c8570e75490eb91a0d21ed90dc7f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=OBc0OBHrxIhw5lAV%2B2ndbTZbEtg%3D" alt="" loading="lazy"/></p>
<p>下方是接入示例：</p>
<pre><code class="hljs language-arduino" lang="arduino">curl -X POST https:<span class="hljs-comment">//ark.cn-beijing.volces.com/api/v3/images/generations \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your api key" \
  -d '{</span>
    <span class="hljs-string">"model"</span>: <span class="hljs-string">"doubao-seedream-4-0-250828"</span>,
    <span class="hljs-string">"prompt"</span>: <span class="hljs-string">"Generate 3 images of a girl and a cow plushie happily riding a roller coaster in an amusement park, depicting morning, noon, and night."</span>,
    <span class="hljs-string">"image"</span>: [<span class="hljs-string">"https://ark-doc.tos-ap-southeast-1.bytepluses.com/doc_image/seedream4_imagesToimages_1.png"</span>, <span class="hljs-string">"https://ark-doc.tos-ap-southeast-1.bytepluses.com/doc_image/seedream4_imagesToimages_2.png"</span>],
    <span class="hljs-string">"sequential_image_generation"</span>: <span class="hljs-string">"auto"</span>,
    <span class="hljs-string">"sequential_image_generation_options"</span>: {
        <span class="hljs-string">"max_images"</span>: <span class="hljs-number">3</span>
    },
    <span class="hljs-string">"response_format"</span>: <span class="hljs-string">"url"</span>,
    <span class="hljs-string">"size"</span>: <span class="hljs-string">"2K"</span>,
    <span class="hljs-string">"stream"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"watermark"</span>: <span class="hljs-literal">true</span>
}'
</code></pre>
<h3 data-id="heading-10">项目开发</h3>
<h4 data-id="heading-11">开发提示词</h4>
<p>准备好如下开发提示词：</p>
<pre><code class="hljs language-bash" lang="bash">我要做一个AI识菜通应用。功能是：用户可以上传一张任何语言菜单图片，调用视觉理解模型doubao-seed-1-6-vision-250815，分析菜单中的内容并翻译为中文，之后进入第二个页面：点菜页面，点菜页面会将AI翻译后的中文菜单一一展示，并且用户可以点菜。每一道菜都包含它的名字、它的介绍和一张图片，图片调用doubao-seedream-4-0-250828模型的生成图片，然后用户点加号可以把这道菜加入他的购物车，最后点提交生成一个一串字符，上面写他想要点哪些菜，方便他跟服务员说他要点哪些。这个字符应该包合中文名和他元语言的名字。项目需要使用react 实现，使用 shadcn、redix 组件库。AI模型的API KEY放在<span class="hljs-built_in">local</span> storage，通过网页右上角的齿轮按钮输入。
</code></pre>
<p>输入到Trae Solo对话框中，Trae Solo不会直接开始开发，而是会先设计两份文档，待我们确认之后才会开始开发。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ca5eab56f6249f998b81b49d0610f80~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=Xk1xR%2FyWMUm3D5nce4%2F7reTpS5w%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-12">项目文档</h4>
<p>Trae Solo会自动帮你创建两份文档，分别是需求文档和架构文档：</p>
<h5 data-id="heading-13">AI识菜通产品需求文档</h5>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-comment"># AI识菜通产品需求文档</span>

<span class="hljs-comment">## 1. 产品概述</span>

AI识菜通是一款智能菜单识别与点餐应用，帮助用户快速理解任何语言的菜单内容并完成点餐。
用户只需上传菜单图片，AI即可自动识别并翻译菜单内容，生成精美的菜品图片，让用户轻松完成点餐流程。
该产品主要面向出国旅游、商务出差或在多语言环境用餐的用户，解决语言障碍带来的点餐困扰。

<span class="hljs-comment">## 2. 核心功能</span>

<span class="hljs-comment">### 2.1 用户角色</span>

本产品无需用户注册，所有功能对所有用户开放。

<span class="hljs-comment">### 2.2 功能模块</span>

我们的AI识菜通应用包含以下主要页面：

1. **首页**：菜单上传功能、应用介绍、导航菜单
2. **点餐页面**：菜品展示列表、购物车管理、订单生成
3. **设置页面**：API密钥配置、应用设置

<span class="hljs-comment">### 2.3 页面详情</span>

| 页面名称 | 模块名称   | 功能描述                              |
| ---- | ------ | --------------------------------- |
| 首页   | 菜单上传区域 | 支持拖拽或点击上传菜单图片，显示上传进度和预览           |
| 首页   | 应用介绍   | 展示应用功能特色和使用说明                     |
| 首页   | 导航栏    | 包含设置按钮和应用标题                       |
| 点餐页面 | 菜品列表   | 展示AI识别的菜品信息，包含中文名称、原文名称、描述和AI生成图片 |
| 点餐页面 | 购物车    | 显示已选菜品数量和总览，支持增减数量                |
| 点餐页面 | 订单生成   | 生成包含中文和原文的点餐清单字符串                 |
| 设置页面 | API配置  | 输入和保存Doubao API密钥                 |
| 设置页面 | 应用设置   | 语言偏好、主题设置等基础配置                    |

<span class="hljs-comment">## 3. 核心流程</span>

**主要用户操作流程：**

1. 用户进入首页，点击或拖拽上传菜单图片
2. 系统调用视觉识别AI分析菜单内容并翻译为中文
3. 跳转到点餐页面，展示识别结果和AI生成的菜品图片
4. 用户浏览菜品，点击加号将心仪菜品加入购物车
5. 确认选择后，生成包含中文和原文的点餐清单
6. 用户可将清单展示给服务员完成点餐

```mermaid
graph TD
    A[首页] --&gt; B[上传菜单图片]
    B --&gt; C[AI识别处理]
    C --&gt; D[点餐页面]
    D --&gt; E[浏览菜品]
    E --&gt; F[添加到购物车]
    F --&gt; G[生成点餐清单]
    A --&gt; H[设置页面]
    H --&gt; I[配置API密钥]
```

<span class="hljs-comment">## 4. 用户界面设计</span>

<span class="hljs-comment">### 4.1 设计风格</span>

* **主色调**：现代蓝色 (<span class="hljs-comment">#3B82F6) 和温暖橙色 (#F59E0B)</span>

* **辅助色**：中性灰色系 (<span class="hljs-comment">#6B7280, #F3F4F6)</span>

* **按钮样式**：圆角设计，悬停效果，阴影层次

* **字体**：中文使用思源黑体，英文使用 Inter 字体，主要字号 16px

* **布局风格**：卡片式设计，顶部导航，响应式网格布局

* **图标风格**：线性图标，统一的视觉语言，支持深浅主题

<span class="hljs-comment">### 4.2 页面设计概览</span>

| 页面名称 | 模块名称 | 界面元素                       |
| ---- | ---- | -------------------------- |
| 首页   | 上传区域 | 虚线边框的拖拽区域，上传图标，进度条，图片预览卡片  |
| 首页   | 导航栏  | 应用Logo，标题，设置齿轮图标按钮         |
| 点餐页面 | 菜品卡片 | 圆角卡片，AI生成图片，菜名标题，描述文本，加号按钮 |
| 点餐页面 | 购物车  | 浮动购物车图标，数量徽章，侧边栏展开面板       |
| 设置页面 | 配置表单 | 输入框，保存按钮，状态提示，分组设置项        |

<span class="hljs-comment">### 4.3 响应式设计</span>

应用采用移动优先的响应式设计，完美适配手机、平板和桌面设备。在移动端优化触摸交互体验，确保按钮大小适合手指操作。

4.4 API调用示例

doubao-seedream-4-0-250828调用示例如下

curl -X POST &lt;https://ark.cn-beijing.volces.com/api/v3/images/generations&gt; \

-H <span class="hljs-string">"Content-Type: application/json"</span> \

-H <span class="hljs-string">"Authorization: Bearer your api key"</span> \

-d '{

<span class="hljs-string">"model"</span>: <span class="hljs-string">"doubao-seedream-4-0-250828"</span>,

<span class="hljs-string">"prompt"</span>: <span class="hljs-string">"Generate 3 images of a girl and a cow plushie happily riding a roller coaster in an amusement park, depicting morning, noon, and night."</span>,

<span class="hljs-string">"image"</span>: [<span class="hljs-string">" &lt;https://ark-doc.tos-ap-southeast-1.bytepluses.com/doc_image/seedream4_imagesToimages_1.png&gt; "</span>, <span class="hljs-string">" &lt;https://ark-doc.tos-ap-southeast-1.bytepluses.com/doc_image/seedream4_imagesToimages_2.png&gt; "</span>],

<span class="hljs-string">"sequential_image_generation"</span>: <span class="hljs-string">"auto"</span>,

<span class="hljs-string">"sequential_image_generation_options"</span>: {

<span class="hljs-string">"max_images"</span>: 3

},

<span class="hljs-string">"response_format"</span>: <span class="hljs-string">"url"</span>,

<span class="hljs-string">"size"</span>: <span class="hljs-string">"2K"</span>,

<span class="hljs-string">"stream"</span>: true,

<span class="hljs-string">"watermark"</span>: true

}'

doubao-seed-1-6-vision-250815调用示例

curl &lt;https://ark.cn-beijing.volces.com/api/v3/chat/completions&gt; \

-H <span class="hljs-string">"Content-Type: application/json"</span> \

-H <span class="hljs-string">"Authorization: Bearer your api key"</span> \

-d $'{

<span class="hljs-string">"model"</span>: <span class="hljs-string">"doubao-seed-1-6-vision-250815"</span>,

<span class="hljs-string">"messages"</span>: [

{

<span class="hljs-string">"content"</span>: [

{

<span class="hljs-string">"image_url"</span>: {

<span class="hljs-string">"url"</span>: <span class="hljs-string">" &lt;https://ark-project.tos-cn-beijing.ivolces.com/images/view.jpeg&gt; "</span>

},

<span class="hljs-string">"type"</span>: <span class="hljs-string">"image_url"</span>

},

{

<span class="hljs-string">"text"</span>: <span class="hljs-string">"图片主要讲了什么?"</span>,

<span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span>

}

],

<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>

}

]

}'
</code></pre>
<h5 data-id="heading-14">AI识菜通技术架构文档</h5>
<pre><code class="hljs language-php" lang="php"><span class="hljs-comment"># AI识菜通技术架构文档</span>

<span class="hljs-comment">## 1. Architecture design</span>

```mermaid
graph TD
    A[用户浏览器] --&gt; B[React前端应用]
    B --&gt; C[Doubao Vision API]
    B --&gt; D[Doubao Image Generation API]
    B --&gt; E[LocalStorage]

    subgraph <span class="hljs-string">"前端层"</span>
        B
        F[shadcn/ui组件]
        G[Radix UI组件]
        H[状态管理]
        B --&gt; F
        B --&gt; G
        B --&gt; H
    end

    subgraph <span class="hljs-string">"外部服务"</span>
        C
        D
    end

    subgraph <span class="hljs-string">"本地存储"</span>
        E
    end
```

<span class="hljs-comment">## 2. Technology Description</span>

* Frontend: React@<span class="hljs-number">18</span> + TypeScript + Vite + TailwindCSS

* UI Components: shadcn/ui + Radix UI

* State Management: React Context + useState/useReducer

* HTTP Client: Fetch API

* Storage: LocalStorage

* Icons: Lucide React

* External APIs: Doubao Vision API, Doubao Image Generation API

<span class="hljs-comment">## 3. Route definitions</span>

| Route     | Purpose               |
| --------- | --------------------- |
| /         | 首页，菜单图片上传和AI处理        |
| /menu     | 点菜页面，显示翻译后的菜品列表和购物车功能 |
| /settings | 设置页面，配置API密钥和应用设置     |

<span class="hljs-comment">## 4. API definitions</span>

<span class="hljs-comment">### 4.1 Core API</span>

<span class="hljs-comment">#### Doubao Vision API 调用</span>

```
POST https:<span class="hljs-comment">//ark.cn-beijing.volces.com/api/v3/chat/completions</span>
```

Request Headers:

| Header Name   | Value             | Description |
| ------------- | ----------------- | ----------- |
| Authorization | Bearer {API_KEY} | API密钥认证     |
| Content-Type  | application/json  | 请求内容类型      |

Request Body:

```json
{
  <span class="hljs-string">"model"</span>: <span class="hljs-string">"doubao-seed-1-6-vision-250815"</span>,
  <span class="hljs-string">"messages"</span>: [
    {
      <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
      <span class="hljs-string">"content"</span>: [
        {
          <span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span>,
          <span class="hljs-string">"text"</span>: <span class="hljs-string">"请识别这张菜单图片中的所有菜品，并翻译为中文。请按照以下JSON格式返回：{"</span>dishes<span class="hljs-string">": [{"</span>originalName<span class="hljs-string">": "</span>原文名称<span class="hljs-string">", "</span>chineseName<span class="hljs-string">": "</span>中文名称<span class="hljs-string">", "</span>description<span class="hljs-string">": "</span>菜品描述<span class="hljs-string">", "</span>estimatedPrice<span class="hljs-string">": "</span>预估价格<span class="hljs-string">"}]}"</span>
        },
        {
          <span class="hljs-string">"type"</span>: <span class="hljs-string">"image_url"</span>,
          <span class="hljs-string">"image_url"</span>: {
            <span class="hljs-string">"url"</span>: <span class="hljs-string">"data:image/jpeg;base64,{base64_image}"</span>
          }
        }
      ]
    }
  ]
}
```

<span class="hljs-comment">#### Doubao Image Generation API 调用</span>

```
POST https:<span class="hljs-comment">//ark.cn-beijing.volces.com/api/v3/images/generations</span>
```

Request Headers:

| Header Name   | Value             | Description |
| ------------- | ----------------- | ----------- |
| Authorization | Bearer {API_KEY} | API密钥认证     |
| Content-Type  | application/json  | 请求内容类型      |

Request Body:

```json
{
  <span class="hljs-string">"model"</span>: <span class="hljs-string">"doubao-seedream-4-0-250828"</span>,
  <span class="hljs-string">"prompt"</span>: <span class="hljs-string">"高质量的{菜品名称}美食摄影，专业餐厅级别，自然光线，精美摆盘"</span>,
  <span class="hljs-string">"n"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-string">"size"</span>: <span class="hljs-string">"1024x1024"</span>,
  <span class="hljs-string">"quality"</span>: <span class="hljs-string">"standard"</span>
}
```

<span class="hljs-comment">### 4.2 数据类型定义</span>

```typescript
<span class="hljs-comment">// 菜品信息</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Dish</span> </span>{
  id: <span class="hljs-keyword">string</span>;
  originalName: <span class="hljs-keyword">string</span>;
  chineseName: <span class="hljs-keyword">string</span>;
  description: <span class="hljs-keyword">string</span>;
  estimatedPrice?: <span class="hljs-keyword">string</span>;
  imageUrl?: <span class="hljs-keyword">string</span>;
  isGeneratingImage?: <span class="hljs-keyword">boolean</span>;
}

<span class="hljs-comment">// 购物车项目</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CartItem</span> </span>{
  dish: Dish;
  quantity: number;
}

<span class="hljs-comment">// API配置</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApiConfig</span> </span>{
  visionApiKey: <span class="hljs-keyword">string</span>;
  imageApiKey: <span class="hljs-keyword">string</span>;
}

<span class="hljs-comment">// 应用状态</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AppState</span> </span>{
  dishes: Dish[];
  cart: CartItem[];
  isProcessing: <span class="hljs-keyword">boolean</span>;
  processingStep: <span class="hljs-string">'uploading'</span> | <span class="hljs-string">'analyzing'</span> | <span class="hljs-string">'translating'</span> | <span class="hljs-string">'generating_images'</span> | <span class="hljs-string">'completed'</span>;
  apiConfig: ApiConfig;
}
```

<span class="hljs-comment">## 5. Data model</span>

<span class="hljs-comment">### 5.1 LocalStorage 数据结构</span>

由于这是一个纯前端应用，所有数据都存储在浏览器的LocalStorage中：

```typescript
<span class="hljs-comment">// API配置存储</span>
localStorage.<span class="hljs-title function_ invoke__">setItem</span>(<span class="hljs-string">'ai-menu-api-config'</span>, JSON.<span class="hljs-title function_ invoke__">stringify</span>({
  <span class="hljs-attr">visionApiKey</span>: <span class="hljs-keyword">string</span>,
  <span class="hljs-attr">imageApiKey</span>: <span class="hljs-keyword">string</span>
}));

<span class="hljs-comment">// 最近处理的菜单缓存</span>
localStorage.<span class="hljs-title function_ invoke__">setItem</span>(<span class="hljs-string">'ai-menu-recent-dishes'</span>, JSON.<span class="hljs-title function_ invoke__">stringify</span>({
  <span class="hljs-attr">timestamp</span>: number,
  <span class="hljs-attr">dishes</span>: Dish[]
}));

<span class="hljs-comment">// 用户偏好设置</span>
localStorage.<span class="hljs-title function_ invoke__">setItem</span>(<span class="hljs-string">'ai-menu-preferences'</span>, JSON.<span class="hljs-title function_ invoke__">stringify</span>({
  <span class="hljs-attr">language</span>: <span class="hljs-string">'zh-CN'</span>,
  <span class="hljs-attr">imageQuality</span>: <span class="hljs-string">'standard'</span>,
  <span class="hljs-attr">autoGenerateImages</span>: <span class="hljs-literal">true</span>
}));
```

<span class="hljs-comment">### 5.2 组件状态管理</span>

```typescript
<span class="hljs-comment">// 全局应用状态 Context</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AppContext</span> = createContext&lt;{
  state: AppState;
  dispatch: React.Dispatch&lt;AppAction&gt;;
}&gt;();

<span class="hljs-comment">// 状态更新动作</span>
type AppAction = 
  | { type: <span class="hljs-string">'SET_DISHES'</span>; payload: Dish[] }
  | { type: <span class="hljs-string">'ADD_TO_CART'</span>; payload: Dish }
  | { type: <span class="hljs-string">'REMOVE_FROM_CART'</span>; payload: <span class="hljs-keyword">string</span> }
  | { type: <span class="hljs-string">'UPDATE_CART_QUANTITY'</span>; payload: { dishId: <span class="hljs-keyword">string</span>; quantity: number } }
  | { type: <span class="hljs-string">'SET_PROCESSING'</span>; payload: <span class="hljs-keyword">boolean</span> }
  | { type: <span class="hljs-string">'SET_PROCESSING_STEP'</span>; payload: AppState[<span class="hljs-string">'processingStep'</span>] }
  | { type: <span class="hljs-string">'UPDATE_DISH_IMAGE'</span>; payload: { dishId: <span class="hljs-keyword">string</span>; imageUrl: <span class="hljs-keyword">string</span> } };
```

<span class="hljs-comment">## 6. 项目结构</span>

```
ai-menu/
├── src/
│   ├── components/
│   │   ├── ui/                 <span class="hljs-comment"># shadcn/ui组件</span>
│   │   ├── ImageUpload.tsx     <span class="hljs-comment"># 图片上传组件</span>
│   │   ├── DishCard.tsx        <span class="hljs-comment"># 菜品卡片组件</span>
│   │   ├── Cart.tsx            <span class="hljs-comment"># 购物车组件</span>
│   │   ├── OrderSummary.tsx    <span class="hljs-comment"># 订单摘要组件</span>
│   │   └── ApiKeySettings.tsx  <span class="hljs-comment"># API密钥设置组件</span>
│   ├── pages/
│   │   ├── HomePage.tsx        <span class="hljs-comment"># 首页</span>
│   │   ├── MenuPage.tsx        <span class="hljs-comment"># 点菜页面</span>
│   │   └── SettingsPage.tsx    <span class="hljs-comment"># 设置页面</span>
│   ├── hooks/
│   │   ├── useApiConfig.ts     <span class="hljs-comment"># API配置管理</span>
│   │   ├── useImageUpload.ts   <span class="hljs-comment"># 图片上传处理</span>
│   │   └── useCart.ts          <span class="hljs-comment"># 购物车逻辑</span>
│   ├── services/
│   │   ├── doubaoApi.ts        <span class="hljs-comment"># Doubao API调用</span>
│   │   └── imageService.ts     <span class="hljs-comment"># 图片处理服务</span>
│   ├── context/
│   │   └── AppContext.tsx      <span class="hljs-comment"># 全局状态管理</span>
│   ├── types/
│   │   └── index.ts            <span class="hljs-comment"># TypeScript类型定义</span>
│   ├── utils/
│   │   ├── storage.ts          <span class="hljs-comment"># LocalStorage工具</span>
│   │   └── imageUtils.ts       <span class="hljs-comment"># 图片处理工具</span>
│   └── App.tsx
├── <span class="hljs-keyword">public</span>/
├── package.json
├── tailwind.config.js
├── vite.config.ts
└── tsconfig.json
```
</code></pre>
<h4 data-id="heading-15">上下文工程开发</h4>
<p>如果说对于SOLO生成的文档不满意，或者有部分地方需要修改的话，是可以直接在文档中进行编辑的，这一点 做得可谓是非常丝滑，SOLO给我的整体体验就是整个项目开发过程全在你的掌控中一般。👍</p>
<p>文档其实就是Trae对整个项目的理解，这个修正过程是很有必要的，在确保Trae完全理解了我们的意思，也就是确认文档无误之后即可向Trae Solo发出命令：按照文档进行开发！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/732b69e5d2cc4a8bb5c1076481e95ab9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=e0BTgkMdJehWQj2wC3SS47QR%2Be4%3D" alt="" loading="lazy"/></p>
<p>Trae Solo会在开发的过程中自动下载依赖、创建配置文件、生成函数、运行终端，运到的问题也都会被当做上下文继续完善开发，不愧是国产之光，第一位上下文工程IDE，让整个从0到1的过程无比丝滑流畅：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/714cd0caec8a404491f1276859de9c73~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=gjqKnZeM7B0glSTY%2Fl5QkqKc3sE%3D" alt="" loading="lazy"/></p>
<p>可以看到Trae Solo不光是会创建文件，下载依赖，并且下载依赖中的错误，也都一并给解决掉：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c8d700f566a4cd686cad24fdd4d91b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=AMoycdiIu8eDFLq5pms3T%2Bzo7Mg%3D" alt="" loading="lazy"/></p>
<p>遇到错误之后也可以一键添加到上下文中进行修复，并且还会根据上下文自测一番，比起传统的复制控制台的错误，再进行自测，这种方式不知道有多让程序员安心：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d813b7399cbb44f98bb4893906c031e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=muT15VsNqAo%2BIkkNlLsO1lT4d14%3D" alt="" loading="lazy"/></p>
<p>若有什么小问题也可以随时打断并提出问题，Trae Solo会根据上下文进行重新思考，并且会结合已经生成的内容加上刚刚提出的内容进行综合考量，所以不必担心说突然的打断会让Trae乱了阵脚，这其实一切都在它的掌控之中。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c0cfa96054074fbaaa2abb26db99b76e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=wTkTKNhBsugvYImlAbPDvptavLo%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-16">成果展示</h3>
<h4 data-id="heading-17">1. 部署阶段</h4>
<p>在项目“AI识菜通”的最终部署阶段，我选择了 Vercel 作为前端应用的托管平台。Vercel 以其卓越的开发者体验和对现代前端框架的深度支持，极大简化了部署流程。本项目基于 React 构建，并使用了 shadcn/ui 和 Radix UI 组件库，Vercel 能自动识别项目结构，实现一键部署和持续集成。每次代码推送至 GitHub 仓库，Vercel 都会自动构建并生成预览链接，方便快速测试与迭代。更重要的是，Vercel 提供全球边缘网络分发，确保用户无论身处何地，都能快速加载应用页面。整个“AI识菜通”从前端交互、图片上传，到调用豆包大模型进行多语言菜单识别与菜品图像生成，最终生成点餐字符串，全部通过 Vercel 高效、稳定地交付给用户。借助 Vercel 的免费计划和无缝 DevOps 能力，我得以将精力聚焦在核心 AI 功能开发上，而无需担心服务器运维，真正实现了“开发即部署”的现代 Web 开发体验。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9a28175eda0480c9d763a163df8f364~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=ywg84FUoWdJJ4H6kPbDDS6PSOTw%3D" alt="" loading="lazy"/></p>
<p>并且整体的部署流程也仅仅只需要一句话而已，如果说缺少了KEY或者依赖等等，Trae也会及时的提醒你补充信息，省去了繁琐的部署流程。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d41e6bd5cb1342a59628deb1064156a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=PUpvlUgwm%2Btthk42HEncyG9vaQk%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-18">2. 首页</h4>
<p>那么在部署完毕之后访问AI识菜通网址的第一印象就是首页，可以说这个界面整体，简洁大气，比很多竞品生成的都要爽目，这也是我喜欢Trae Solo的点，审美非常在线！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fbd94394485b42c0a8d18bd1a8f0fe47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=kdEFjkXU71MQ4uymHFBLbNICSC4%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-19">3. 设置API密钥</h4>
<p>那么想要使用本项目的话，第一件事就是设置豆包大模型的API密钥，这里声明一下：用户自己的API密钥存放在本地的storage中，并不会上传到云端，确保用户的密钥安全。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6cf0991be7c84779ba4be14ddd42d2ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=kShZ5EDCp8cUwbvXnueAhOryRW4%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/732bddb7b9944556ba522f961734402b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=WId%2Fqww%2FLYh%2B824qRSK1gB5owrU%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-20">4. 识别菜单</h4>
<p>前置条件准备好之后，我从网上下载了一份英文菜单进行测试，看看项目到底能不能打：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a8b01c7e6484bd98197f4c200a9e38d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=OZMZdEIyZ9fBJpp%2BwJD51P%2Bl5SI%3D" alt="" loading="lazy"/></p>
<p>上传图片之后项目就会调用豆包大模型进行分析，整体的时间根据菜单内容的多少会有些出入，静静等待几分钟就好：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fbf62791e0014ee98df2d66986f2e322~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=kp0FqrH4up%2FIWKIUTO0GVvoKEPs%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7d9e028a4ee4c5bb94e9f3f0d2dd55f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=qMfrUtCdE4UMPZaBEt3XKOKNvDk%3D" alt="" loading="lazy"/></p>
<p>菜单识别完毕之后，首页会提示，点击去点菜即可看到生成的中文菜单</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b631edb6b82d42c18b7b1a2bf7c883bf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=TaTJnHFmWyJpLnOy4SX11UjHiZQ%3D" alt="" loading="lazy"/></p>
<p>以下是生成后的结果，可以看到，生成的图片是很符合菜单中的样子的，这样让本来晦涩难懂的菜单有了活力，这也许就是科技带给我们的意义吧，服务生活，然后这样就可以顺利点菜了：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a3e3884fc3d4951ba4e2b16380db4f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=Z%2B2z0xzacf8fNPu%2FhTeh15FjACQ%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b2f02085bd4648a6a7da0d6b6f7c6684~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=y%2BlCJkUMqHGyFfsMl1e7tTG%2BmOw%3D" alt="" loading="lazy"/></p>
<h4 data-id="heading-21">5. 点餐进入购物车</h4>
<p>选择自己需要点的视频加入购物车</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ea2e4fe2efa4c6881d76b269c6771df~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=LnmpmS2uK6Oie9dbabQZ34gupDo%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/afa908f196ee491cbc60bf5a327a4023~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=GQ3xRpiE8vcWCXt8VzWHFZAeJH0%3D" alt="" loading="lazy"/></p>
<p>点击生成订单汇总，会生成一份刚刚的点菜TXT格式的清单：<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6182f8189e7c422999cef368d8bf236c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgX-aRmOaYn18=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976390&amp;x-signature=hPaq8oUHX%2FnSKYg9G%2BK5Rmhp1Gs%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-22">总结</h3>
<p>“AI识菜通”是一个融合多模态AI能力的智能点餐应用，通过用户上传任意语言的菜单图片，自动调用豆包大模型（doubao-seed-1.6-vision）进行视觉识别与翻译，再结合 Seedream 4.0 生成高质量菜品图像，最终实现结构化中文菜单展示、购物车管理与点餐清单生成。整个项目采用 React + TypeScript 技术栈，集成 shadcn/ui 与 Radix UI 组件库，所有数据（包括 API 密钥）均本地存储于浏览器 LocalStorage，无需后端依赖。项目通过 Vercel 实现一键部署，具备完整的响应式设计与流畅的用户交互体验。</p>
<p>在开发过程中，上下文工程（Context Engineering）成为项目成功的关键。相比传统 Prompt Engineering，Trae Solo 提供的结构化上下文建模、动态注入、多轮意图对齐与错误降级机制，显著提升了系统在复杂任务中的准确性与鲁棒性。尤其在多模型协同（视觉识别 + 图像生成）、状态管理（如购物车同步、图片生成状态追踪）和异常处理（如 API 调用失败回退）方面，上下文工程让整个流程更可控、可维护。此外，将 API 密钥统一简化为单字段配置、加入识别进度条等细节优化，也极大提升了用户体验。</p>
<p>Trae Solo 不仅是一款开发工具，更像一位“全栈 AI 工程师搭档”。它从需求理解开始，自动生成产品文档与技术架构，再逐步完成项目初始化、依赖安装、组件开发、错误修复与部署上线，全程丝滑流畅。其上下文感知能力极强——即使中途打断或修改需求，也能基于已有上下文智能调整，确保逻辑连贯。更难得的是，它对开发者体验极度友好：自动处理依赖冲突、一键修复语法错误、实时预览效果，真正实现了“Talk. Think. Ship.”的开发哲学。作为国产上下文工程 IDE 的先行者，Trae Solo 极大降低了复杂 AI 应用的开发门槛，堪称“国产之光”。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[京东云张晨 受邀参加KCD 杭州站 x OpenInfra Days China，分享AI时代的大型集群数据处理之道]]></title>    <link>https://juejin.cn/post/7573521516323815451</link>    <guid>https://juejin.cn/post/7573521516323815451</guid>    <pubDate>2025-11-17T09:41:05.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573521516323815451" data-draft-id="7573525927792541722" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="京东云张晨 受邀参加KCD 杭州站 x OpenInfra Days China，分享AI时代的大型集群数据处理之道"/> <meta itemprop="keywords" content="程序员"/> <meta itemprop="datePublished" content="2025-11-17T09:41:05.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="京东云开发者"/> <meta itemprop="url" content="https://juejin.cn/user/2634854380340008"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            京东云张晨 受邀参加KCD 杭州站 x OpenInfra Days China，分享AI时代的大型集群数据处理之道
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2634854380340008/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    京东云开发者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:41:05.000Z" title="Mon Nov 17 2025 09:41:05 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>AI正在重塑一切，驱动云原生基础设施经历其诞生以来最深刻的变革。这一变革对底层设施提出了前所未有的新要求：更极致的弹性伸缩、更高效的算力利用、更复杂的跨域调度和更全面的安全防护。面对如此系统性的挑战，单一技术栈或社区已难以给出完美答案。</p>
<p>KCD（Kubernetes Community Days，Kubernetes 社区日）是由社区组织的活动，汇聚开源和云原生领域的采用者和技术人员，旨在促进教育、协作和交流。KCD 活动由云原生计算基金会（CNCF）提供支持。</p>
<p>OpenInfra Days 每年由开源社区生态系统中的本地用户组和公司组织和主办，包含主题演讲、分组会议甚至研讨会。这是一个绝佳的机会，在活动上可以直接聆听杰出的开源基础设施领导者的演讲，学习用户案例，建立人脉，并融入当地社区。</p>
<p><strong>今年由两个社区组织联合发起的开创性融合盛会，标志着云计算领域两大核心基础设施技术的深度协作与创新。它充分展现了开源社区的开放精神和跨社区协作的强大力量，我们将共同推动 AI 与云计算技术 的进步与发展。</strong></p>
<p>本次会议由 京东，亚马逊, Nvidia, 阿里，蚂蚁，字节，百度，华为，中科院, Linux foundation等国内外顶级专家学者分享CNCF/openinfra相关技术议题。本次会议JDOS 的Chen因Kata container等开源社区贡献受邀参加此次会议并做出技术分享。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0469bfb7087b47c4a753dff947d127e8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977265&amp;x-signature=EES9X8mAFeQwfaPuRytoIE43uw8%3D" alt="图片" loading="lazy"/></p>
<p>作为对共同挑战的回应，KCD杭州站与OpenInfra Days China将于11月15日在杭州首度联合举办，共同呈现一场开创性的技术盛会。这标志着围Kubernetes敏捷应用编排与OpenInfra稳定基础设施构建的两大生态，正主动打破壁垒，迈向融合协同的新阶段。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d83cde56dca44b0bb57855e1c052686~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977265&amp;x-signature=F7bhyXMWkCte05huL5Kp7m0V748%3D" alt="图片" loading="lazy"/></p>
<p>京东云高级工程师张晨受邀将在本次大会中进行分享，他的主题是《大型集群中的数据处理：如何兼顾效率、可拓展性与可持续性》。</p>
<h4 data-id="heading-0">Chen Zhang</h4>
<p>Chen Zhang is a staff software engineer at JD cloud and a maintainer of the </p>
<p>QEMU project. He works in the virtualization field for many years.  As an accomplished speaker, Chen has presented at several international conferences, including KVM Forum 2022, Xen Summit 2019, LinuxCon China 2017, Open Source Summit Japan 2017, and CLK 2022, among others.</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4860af0c2a64a8eab8964ab2d3b7dc2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977265&amp;x-signature=Xnfa1HtQP0Zw1VTzZY0PNR%2B%2BRJQ%3D" alt="图片" loading="lazy"/>在AI驱动的数据洪流时代，大规模集群的数据处理能力是衡量云基础设施核心竞争力的关键。张晨将基于京东云在超大规模复杂场景下的深厚实践，分享如何构建既高效、又可平滑扩展，同时保证长期运营可持续性的数据处理架构与策略。他的分享将为业界同行应对相似挑战提供宝贵的思路与实战经验。<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e7ba332520f47d59cca2b0227d0c03b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977265&amp;x-signature=jzC%2B6ImdtXZiZHjYCpzgFs1OhRs%3D" alt="图片" loading="lazy"/>运营大型 Kubernetes 集群的企业面临一个关键难题：如何在不牺牲容器性能与密度的前提下实现强隔离。通过采用 Kata 容器，京东云成功实现了安全与性能隔离，并支持在线应用与离线任务在数十万个节点上的共处而彼此互不干扰，大幅提高物理 CPU 的利用率以节省巨额成本。这一方式在“618 购物节”期间显著降低能耗。本次演讲将深入解析京东在部署 Kata 容器中的历程，涵盖架构设计、动机出发点及关键性能指标。另外分享京东自研的Kata Disk I/O 性能加速技术，对比默认配置可最高提升40%的通用磁盘性能。我将分享一套经实际部署的方案经验，如何在严苛的真实场景中基于虚拟机的隔离提升安全性与效率，并剖析其实际应用价值与注意事项。<br/>
京东云高级工程师-张晨 《大型集群中的数据处理：如何兼顾效率、可拓展性与可持续性》现场分享内容<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/80230b8bba7e46e998ca6975e4a74b23~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lqs5Lic5LqR5byA5Y-R6ICF:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977265&amp;x-signature=FvMjxeLHw5uoaDBD7XClAe35T2k%3D" alt="图片" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Win11最新开发版开源工具新版发布，蓝屏、死机原因、内存诊断功能都有，教程来了]]></title>    <link>https://juejin.cn/post/7573525927792607258</link>    <guid>https://juejin.cn/post/7573525927792607258</guid>    <pubDate>2025-11-17T09:43:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573525927792607258" data-draft-id="7566845621001535498" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" Win11最新开发版开源工具新版发布，蓝屏、死机原因、内存诊断功能都有，教程来了"/> <meta itemprop="keywords" content="GitHub"/> <meta itemprop="datePublished" content="2025-11-17T09:43:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="搜罗万相"/> <meta itemprop="url" content="https://juejin.cn/user/4116175105041085"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             Win11最新开发版开源工具新版发布，蓝屏、死机原因、内存诊断功能都有，教程来了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4116175105041085/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    搜罗万相
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:43:11.000Z" title="Mon Nov 17 2025 09:43:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">什么工具？</h2>
<p>ViveTool是一款专为Windows系统设计的开源工具，主要用于启用系统中的实验性隐藏功能。</p>
<p>它是一个第三方开源的C#库和控制台应用程序，也提供GUI版本。ViveTool通过功能ID来识别可用功能，可以通过命令行或GUI实用程序，使用功能ID来启用或禁用Windows计算机上的某些功能。例如，使用“vivetool /enable /id:功能ID”命令可以启用特定功能，使用“vivetool /disable /id:功能ID”命令则可以禁用功能。</p>
<p>ViveTool主要用于Windows 10和Windows 11系统，特别是对于那些运行Windows 11开发版或Insider Preview版本的用户来说，它可以帮助用户绕过微软实施的A/B测试限制，一些仅对部分用户开放的新功能可以被所有感兴趣的用户所使用。这些功能本质上是实验性的，激活它们有时可能会导致一些问题，因此在使用前最好备份系统。</p>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5bf1d23644c84db5875aa3eb02a5012f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=gB8Y6BEvUPkIdmDfhW6I1ofqXrE%3D" alt="alt text" loading="lazy"/>​</p>
<p>微软官方表示，推出该功能的主要目的是帮助提升系统的可靠性。如果你的电脑出现错误检查（意外重启），可能会在登录时看到一条通知：建议进行快速内存扫描。</p>
<h2 data-id="heading-1">常见的一些问题</h2>
<p>蓝屏奔溃问题；</p>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d72fbcbda1d64082a6ef795bb80344ac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=uYuUVr5aXsnL0h%2B8RyEtYWkgbKY%3D" alt="alt text" loading="lazy"/>​</p>
<p>莫名未知问题；</p>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6db9e8fa7b53474e8b71578abd4df67d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=e3M19%2FFf61bZLvhgQ9izMDk7%2B8o%3D" alt="alt text" loading="lazy"/>​</p>
<p>和内存相关的崩溃、蓝屏死机及黑屏问题，而且这种故障的诱因较为多样，像内存运行不稳定、内存硬件出现故障、内存模块型号不兼容，或者是XMP/EXPO超频参数设置不合理等，都可能导致问题发生。</p>
<p>通过主动执行内存诊断扫描，该软件可以判断设备崩溃是否由内存相关问题引发还是什么其它原因。</p>
<p>内存诊断功能将率先在Windows 11 Insider Preview Build 26220.6982（开发者频道）中上线。</p>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aaef316666a744699d986917d8c197c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=o6d5de9VeGt2SmH%2BooToREQLwNE%3D" alt="alt text" loading="lazy"/>​</p>
<h2 data-id="heading-2">使用教程</h2>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ba2e4cb907f4bc8aa8634922fc5adc6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=utTqBS7vZybLJYW4r%2BIDRWKRDZU%3D" alt="alt text" loading="lazy"/>​</p>
<p>命令提示符：右键点击开始菜单选择终端或终端管理员，在终端设置里找到命令提示符，将管理员身份运行配置文件启用。</p>
<p>终端设置需要点击右上角的小箭头选中</p>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9195b7acd434aa0bd21ac1193e622d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=w01jf89cqRb7%2FfIet9ddNw9ZL%2Bg%3D" alt="alt text" loading="lazy"/>​</p>
<p>然后在终端设置里带点击左侧导航栏的启动，在最上面将默认配置文件修改为命令提示符，完成后再点击底部保存按钮。如果是PowerShell也可以。</p>
<p>首先下载 ViveTool 工具，下载完成后将其解压到电脑任意指定位置。接下来找到 ViveTool 的解压文件夹并进入，在文件路红上面直接输入cmd按回车。</p>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a7fd120ba6f644a29d010ae95323cef7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=KtwO2K%2FOUwC48M3u3Y5GdH%2FUxDY%3D" alt="alt text" loading="lazy"/>​</p>
<p>然后在终端里敲入 “vivetool”，按回车看看会不会报错。如果能正常弹出一堆参数说明，就说明之前的步骤都没问题；如果是弹出红色错误或者提示找不到命令，那可能是文件夹没找对，继续重新来一遍。</p>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/714d59ac17714c3b85aa9ce9abaeac9b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=HnhN75Hjt9wc7%2FWMlf1nPcgNLaw%3D" alt="alt text" loading="lazy"/>​</p>
<pre><code class="hljs language-bash" lang="bash">
<span class="hljs-comment">#在ViveTool v3.0+版中，启用和禁用功能分别如下</span>
<span class="hljs-comment">#启用某个功能</span>
vivetool /enable /id:数字
<span class="hljs-comment">#禁用某个功能</span>
vivetool /disable /id:数字
<span class="hljs-comment">#数字代表功能的标识符</span>
<span class="hljs-comment">#在ViveTool 2.0及以下版本中启用和禁用功能分别如下</span>
<span class="hljs-comment">#启用某个功能</span>
vivetool addconfig 数字 2
<span class="hljs-comment">#禁用某个功能</span>
vivetool delconfig 数字 2
</code></pre>
<p>比如启用功能：输入以下命令并按回车键：vivetool /enable /id:57048231,47205210,56328729,48433719</p>
<p>新的界面</p>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23327ff3ed1b4c09ac49b5fe6143bb83~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=lZCGIWZly2HrXqiwaygHFL%2BdOj8%3D" alt="alt text" loading="lazy"/>​</p>
<p>注意要重启电脑</p>
<p>​<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3525dad746d54328b72b70f9031a9e57~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pCc572X5LiH55u4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763977390&amp;x-signature=8p43JYln3oBdYy68pPpj2%2Bg6PoQ%3D" alt="alt text" loading="lazy"/>​</p>
<h2 data-id="heading-3">ViveTool最新版下载地址：</h2>
<p>前往Github项目主页下载ViveTool最新版：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fthebookisclosed%2FViVe%2Freleases%2F" target="_blank" title="https://github.com/thebookisclosed/ViVe/releases/" ref="nofollow noopener noreferrer">github.com/thebookiscl…</a></p>
<p>如果不好下载，我这里也提供了</p>
<p>地址获取一： <a href="https://link.juejin.cn?target=https%3A%2F%2Fweibo.com%2Fttarticle%2Fp%2Fshow%3Fid%3D2309405227188327940866" target="_blank" title="https://weibo.com/ttarticle/p/show?id=2309405227188327940866" ref="nofollow noopener noreferrer">系统优化工具一</a></p>
<p>地址获取二： <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.toutiao.com%2Farticle%2F7566624543708561947%2F" target="_blank" title="https://www.toutiao.com/article/7566624543708561947/" ref="nofollow noopener noreferrer">系统优化工具二</a></p>
<p>‍</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Gemini 3“超前点映”效果炸场，巴菲特305亿重仓谷歌]]></title>    <link>https://juejin.cn/post/7573172586840375348</link>    <guid>https://juejin.cn/post/7573172586840375348</guid>    <pubDate>2025-11-17T10:02:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573172586840375348" data-draft-id="7573512056088592419" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Gemini 3“超前点映”效果炸场，巴菲特305亿重仓谷歌"/> <meta itemprop="keywords" content="Gemini,AI编程,Trae"/> <meta itemprop="datePublished" content="2025-11-17T10:02:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="量子位"/> <meta itemprop="url" content="https://juejin.cn/user/2858385963484488"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Gemini 3“超前点映”效果炸场，巴菲特305亿重仓谷歌
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2858385963484488/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    量子位
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T10:02:25.000Z" title="Mon Nov 17 2025 10:02:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Gemini 3 还未正式发布，“超前点映” 已悄悄亮相。</p>
<p>许多网友都分享了自己的一手实测，表示 Gemini 3 的表现实在是强到飞起。</p>
<p>它可以将不同游戏缝合到一起，在网页中创建一个《我的世界》风格的塔防游戏；</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aa5a0e6c4f574f04859ac67f879e4da1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=0Qh%2BSvvG3ftWOhNlpDghKMOwV7I%3D" alt="" loading="lazy"/></p>
<p>也可以用 SVG 动画直接在网页中复刻一个 Switch，还是带屏幕能模拟宝可梦的那种。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6e6f5f91533042e9a763a4efb5d1720b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=2p9xkFdblWHrIofRwlzHdyaspKE%3D" alt="" loading="lazy"/></p>
<p>不仅能力超强，Gemini 3 的关注度也是相当火热。</p>
<p>甚至有机构发起了猜猜乐，消息还被谷歌 CEO 劈柴哥亲自转发，并配上了两个耐人寻味的 emoji 符号。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c580357af5b43c3bdbe4b992d57737b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=50jRdYMaB2xVQhR53iIbCgAKXw0%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">Gemini 3“超前点映” 上线</h2>
<p>据网友介绍，Gemini 3“超前点映” 的入口藏在 APP 当中。</p>
<p>需要将 APP 更新然后打开，并使用基于 Gemini Pro 2.5 的 Canvas 功能，实际调用的就是 Gemini 3。</p>
<p>这名网友还放出了 APP 和网页端的对比 ，同样使用 2.5 版本的 Canvas，结果表现差异明显。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61bbb8c3f4ac42fbbee61760a9218023~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=WJSt2283o9JhMXvdHACqgevhI5E%3D" alt="" loading="lazy"/></p>
<p>不过随后又有其他网友表示，网页端也已经上线了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2031479b450e45e296db0c728d88c601~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=yZd90Ke7oOzNAxTr2IGCV2%2BF24k%3D" alt="" loading="lazy"/></p>
<p>除了官方途径之外，一些第三方平台，例如 OpenRouter 当中，也据传藏有 Gemini 3.0。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/031a403610794ced9b27fa1ab64bda5b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=UlNr13qLdfyclU9ZBp2jfao3dGU%3D" alt="" loading="lazy"/></p>
<p>想亲自体验的话可以按照上面说的试试，接下来我们继续看 Gemini 3 都被网友玩出了哪些花样。</p>
<p>比如做一个 “新粗野风格” 的网页，Gemini 3 的设计优美，看上去颜值相当在线。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6b0f80bcd6c642bc84418209afb5aee1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=PxUgGBN%2BM48uHmM7pOWbrwf4zq0%3D" alt="" loading="lazy"/></p>
<p>并且 Gemini 3 在 SVG 图形绘制上大有长进，绘制出的苹果手机，已经完全没有了矢量元素拼接的不真实感。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47d688f4f9c84d00b7e3f6492229061a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=akHqsSb9gBzTCgiNMFp5T%2FH4oso%3D" alt="" loading="lazy"/></p>
<p>而且 SVG 不仅限于静态，还支持交互，比如这个网页版风扇，不仅形状和谐，还支持开关和风速调节。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/73faafce381841d18025882bb750a42c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=lLwFd6NrjQymUP05gnyefV8l2H8%3D" alt="" loading="lazy"/></p>
<p>当然说到交互，还有更复杂的效果，下面这个《我的世界》风格的竞技场，不仅画风毫无二致，还支持像在真的游戏当中一样移动探索。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f39cefedfa934bf5a6d751960669e566~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=IgHhMRun%2FWAZmCdlX2b7y%2BReL8A%3D" alt="" loading="lazy"/></p>
<p>甚至是克隆一个 YouTube，还是有视频能播放的那种。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79b6cd3cf0094670804b4983bea747da~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=Qy3KF98cFdD86ru%2FFU17KNnyJ4o%3D" alt="" loading="lazy"/></p>
<p>凭借这样的表现，Gemini 3 这波 “超前点映” 除了吸引了网友的目光，也让投资界开始蠢蠢欲动。</p>
<h2 data-id="heading-1">巴菲特 305 亿重仓谷歌</h2>
<p>谷歌 Gemini 3 发布在即，对市场观望已久的股神巴菲特出手了，直接抛出 43 亿美元（约 305 亿人民币）加仓 Alphabet。</p>
<p>并且据传谷歌让他提前体验了一波 Gemini 3，他看到 Gemini 3 一次就完成了一个复杂的 Python 到 Rust 迁移任务之后，做出了重仓的决定。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4a2a0b5525bf462bb18be7398b0a0114~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=KTDE5hysMBmkriBu1qFknhyrBuI%3D" alt="" loading="lazy"/></p>
<p>巴菲特的伯克希尔 · 哈撒韦公司披露，Alphabet 已成为该集团第十大最有价值的持股。</p>
<p>对比更鲜明的是，过去一年多以来，巴菲特揣着大把现金就是不投资，一直在回避 AI 热潮。</p>
<p>他此前的 1540 亿美元财富，也是通过投资可靠但并不引人注目的公司获得，基本上避开了科技投资。</p>
<p>今年以来，Alphabet 的股价飙升了 46%，人工智能的需求推动了其云业务的发展，并巩固了其在搜索和 YouTube 领域的统治地位。</p>
<p>实际上，自从 2022 年底 ChatGPT 横空出世以来，大家普遍觉得谷歌好像在 AI 上慢了一拍，在后面拼命追赶。</p>
<p>为了追赶，谷歌使出了它的看家本领，也就是全栈优势——它不仅自己有能力研发 AI 模型，还拥有庞大的产品来分销，更有自己的云业务提供基础技术设施支持。</p>
<p>特别是随着 Nano Banana 的炸场，使用 Gemini 的用户快速飙升，而且 AI 非但没有动摇谷歌最赚钱的广告生意，反而使其得到了增强。</p>
<p>增长之下，要求 CEO 劈柴哥辞职的呼声也逐渐平息。</p>
<p>巴菲特甚至承认，多年前没有买入谷歌是他 “错失良机”。</p>
<h2 data-id="heading-2">One More Thing</h2>
<p>除了 Gemini 3，Nano Banana2 也据传将在本周发布。</p>
<p>另外还有知情人士表示，除了这两个模型，谷歌还将会有其他发布。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/82490317a70e4bc3b28f74af3fcd7d7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6YeP5a2Q5L2N:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763978545&amp;x-signature=qST0%2FUv%2B6EBOBmx86VDZrTu25%2FQ%3D" alt="" loading="lazy"/></p>
<p>可以狠狠期待一波了。</p>
<p>参考链接：<br/>
[1]<a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fminchoi%2Fstatus%2F1989372162336301115" target="_blank" title="https://x.com/minchoi/status/1989372162336301115" ref="nofollow noopener noreferrer">x.com/minchoi/sta…</a><br/>
[2]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.businessinsider.com%2Fgemini-3-launch-google-ai-race-chatgpt-2025-11" target="_blank" title="https://www.businessinsider.com/gemini-3-launch-google-ai-race-chatgpt-2025-11" ref="nofollow noopener noreferrer">www.businessinsider.com/gemini-3-la…</a><br/>
[3]<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.dailymail.co.uk%2Fyourmoney%2Farticle-15292817%2Fwarren-buffett-alphabet-investment.html" target="_blank" title="https://www.dailymail.co.uk/yourmoney/article-15292817/warren-buffett-alphabet-investment.html" ref="nofollow noopener noreferrer">www.dailymail.co.uk/yourmoney/a…</a></p>
<p><strong>欢迎在评论区留下你的想法！</strong></p>
<p>— <strong>完</strong> —</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 一个小型游戏对象模型渐进式设计（四）——类型擦除与 Existential：当泛型遇见动态派发]]></title>    <link>https://juejin.cn/post/7573521516323962907</link>    <guid>https://juejin.cn/post/7573521516323962907</guid>    <pubDate>2025-11-17T09:57:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573521516323962907" data-draft-id="7553845995845124142" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 一个小型游戏对象模型渐进式设计（四）——类型擦除与 Existential：当泛型遇见动态派发"/> <meta itemprop="keywords" content="Swift"/> <meta itemprop="datePublished" content="2025-11-17T09:57:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unravel2025"/> <meta itemprop="url" content="https://juejin.cn/user/1116759541421880"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 一个小型游戏对象模型渐进式设计（四）——类型擦除与 Existential：当泛型遇见动态派发
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759541421880/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unravel2025
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:57:18.000Z" title="Mon Nov 17 2025 09:57:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">为什么“泛型”还不够</h2>
<p>上一篇我们写出了这样的代码：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> calc: <span class="hljs-keyword">any</span> <span class="hljs-type">DamageCalculator</span>&lt;<span class="hljs-type">Double</span>&gt; <span class="hljs-operator">=</span> <span class="hljs-type">CritCalculator</span>(rate: <span class="hljs-number">1.5</span>)
</code></pre>
<p>它编译得快、跑得也快，但当你想把它存进数组、或者作为属性逃逸到运行时，就会遇到三个灵魂问题：</p>
<ol>
<li>编译器不知道具体类型有多大，如何分配内存？</li>
<li>协议里有 <code>associatedtype</code>，为什么不能用 <code>DamageCalculator</code> 直接当做类型？</li>
<li>同样一句 <code>calculate(base:)</code>，为什么有时走内联、有时走虚表？</li>
</ol>
<p>答案都指向同一个机制：Existential Container（存在性容器），社区俗称“类型擦除盒”。</p>
<h2 data-id="heading-1">Existential 是什么</h2>
<p>Swift 把“符合某个协议的值”打包成一种统一大小的盒子，这个盒子就叫 existential。</p>
<p>语法层面：</p>
<ul>
<li><code>any Protocol</code>  // Swift 5.6+ 显式 existential</li>
<li>老代码里的 <code>Protocol</code>  // 隐式 existential，即将被逐步废弃</li>
</ul>
<p>盒子内部到底长什么样？继续看。</p>
<h2 data-id="heading-2">Existential Container 的内存布局</h2>
<p>以 64 bit 为例，标准布局 5 个字（40 byte）：</p>
<pre><code class="hljs language-lua" lang="lua">+<span class="hljs-comment">-------- 0:  value buffer (3 ptr = 24 byte)  </span>
+<span class="hljs-comment">--------24:  value witness table (VWT)  </span>
+<span class="hljs-comment">--------32:  protocol witness table (PWT)  </span>
</code></pre>
<ol>
<li>
<p>value buffer</p>
<ul>
<li>小值（Int、Double、CGPoint…）直接内联；</li>
<li>大值（String、Array、自定义 class）堆分配，buffer 存指针；</li>
</ul>
</li>
<li>
<p>VWT</p>
<p>管理“值语义”生命周期：拷贝、销毁、搬移。</p>
</li>
<li>
<p>PWT</p>
<p>管理“协议方法”派发地址，相当于 C++ 的 vtable。</p>
</li>
</ol>
<p>结论：哪怕只是一个 <code>Double</code>，装进 <code>any NumericValue</code> 后也会膨胀到 40 字节；如果频繁在数组里拷贝，就会带来隐式堆分配和缓存抖动。</p>
<h2 data-id="heading-3">关联类型协议的“额外”盒子</h2>
<p>当协议带 <code>associatedtype</code> 时，existential 还需要一份通用签名（generic environment），用于在运行时保存类型元数据。</p>
<p>因此：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> x: <span class="hljs-keyword">any</span> <span class="hljs-type">Attackable</span>        <span class="hljs-comment">// ❌ 编译错误：associatedtype Value 未定</span>
<span class="hljs-keyword">let</span> y: <span class="hljs-keyword">any</span> <span class="hljs-type">Attackable</span>&lt;<span class="hljs-type">Int</span>&gt;   <span class="hljs-comment">// ✅ Swift 5.9 新语法：parameterized existential</span>
</code></pre>
<p>后者内部比“无关联类型”再多 8 byte，总计 48 byte。</p>
<p>苹果在 WWDC23 给出的性能警告：&lt; 3 个 witness 方法且 value ≤ 24 byte 时，existential 才基本无额外开销；否则请考虑“手写类型擦除”或“泛型特化”。</p>
<h2 data-id="heading-4">实战：手写 AnyDamageCalculator</h2>
<p>目标：</p>
<ul>
<li>对外暴露固定大小（无动态盒子）；</li>
<li>对内保存任意具体计算器；</li>
<li>仍保持 <code>Value</code> 泛型参数。</li>
</ul>
<ol>
<li>定义抽象基类（引用语义）</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyDamageCalculatorBox</span>&lt;<span class="hljs-title class_">Value</span>: <span class="hljs-title class_">NumericValue</span>&gt;: <span class="hljs-title class_">DamageCalculator</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">base</span>: <span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">Value</span> { <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"abstract"</span>) }
}
</code></pre>
<ol start="2">
<li>定义具体盒子（泛型类）</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteBox</span>&lt;<span class="hljs-title class_">T</span>: <span class="hljs-title class_">DamageCalculator</span>&gt;: <span class="hljs-title class_">AnyDamageCalculatorBox</span>&lt;<span class="hljs-title class_">T</span>.<span class="hljs-title class_">Value</span>&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> concrete: <span class="hljs-type">T</span>
    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">concrete</span>: <span class="hljs-type">T</span>) { <span class="hljs-keyword">self</span>.concrete <span class="hljs-operator">=</span> concrete }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">base</span>: <span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">Value</span> {
        concrete.calculate(base: base)
    }
}
</code></pre>
<ol start="3">
<li>定义值包装（对外类型）</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AnyDamageCalculator</span>&lt;<span class="hljs-title class_">Value</span>: <span class="hljs-title class_">NumericValue</span>&gt;: <span class="hljs-title class_">DamageCalculator</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> box: <span class="hljs-type">AnyDamageCalculatorBox</span>&lt;<span class="hljs-type">Value</span>&gt;
    
    <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">C</span>: <span class="hljs-type">DamageCalculator</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">concrete</span>: <span class="hljs-type">C</span>) <span class="hljs-keyword">where</span> <span class="hljs-type">C</span>.<span class="hljs-type">Value</span> <span class="hljs-operator">==</span> <span class="hljs-type">Value</span> {
        <span class="hljs-keyword">self</span>.box <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteBox</span>(concrete)
    }
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">base</span>: <span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">Value</span> {
        box.calculate(base: base)
    }
}
</code></pre>
<ol start="4">
<li>使用：</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> crit <span class="hljs-operator">=</span> <span class="hljs-type">CritCalculator</span>(rate: <span class="hljs-number">1.5</span>)
<span class="hljs-keyword">let</span> erased: <span class="hljs-type">AnyDamageCalculator</span>&lt;<span class="hljs-type">Double</span>&gt; <span class="hljs-operator">=</span> <span class="hljs-type">AnyDamageCalculator</span>(crit)
array.append(erased)   <span class="hljs-comment">// 数组元素大小 = 1 ptr，无 existential 盒子</span>
</code></pre>
<ul>
<li>内存大小：8 byte（一个 class 指针）；</li>
<li>拷贝成本：一次 ARC  retain；</li>
<li>方法派发：虚表一次，但不再额外带 VWT/PWT。</li>
</ul>
<h2 data-id="heading-5">Swift 5.9 新武器：Parameterized Existential</h2>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> list: [<span class="hljs-keyword">any</span> <span class="hljs-type">DamageCalculator</span>&lt;<span class="hljs-type">Double</span>&gt;] <span class="hljs-operator">=</span> [
    <span class="hljs-type">CritCalculator</span>(rate: <span class="hljs-number">1.5</span>),
    <span class="hljs-type">MultiplierCalculator</span>(upstream: <span class="hljs-type">CritCalculator</span>(rate: <span class="hljs-number">2</span>), multiplier: <span class="hljs-number">1.2</span>)
]
</code></pre>
<p>编译器会自动生成“隐藏盒子”，但仍带 48 byte 拷贝成本。</p>
<p>适合场景：</p>
<ul>
<li>原型阶段、快速迭代；</li>
<li>对性能不敏感的工具代码；</li>
</ul>
<p>高性能路径（渲染、音频、网络解析）继续用手写擦除或泛型特化。</p>
<h2 data-id="heading-6">类型擦除的通用套路（模板）</h2>
<p>任何带 <code>associatedtype</code> 的协议，都可以套下面 4 步：</p>
<ol>
<li>创建 <code>AnyProtocolBase&lt;AssociatedType&gt;</code> 抽象类；</li>
<li>创建 <code>ConcreteBox&lt;T: Protocol&gt;</code> 具体类，持有 <code>T</code>；</li>
<li>创建 <code>AnyProtocol&lt;AssociatedType&gt;</code> 值类型，内部存 <code>AnyProtocolBase</code> 指针；</li>
<li>对外 API 全部 <code>override / forward</code> 到抽象类。</li>
</ol>
<h2 data-id="heading-7">什么时候用哪种形态？</h2>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section">需求 \ 方案        泛型特化   any Protocol   手写擦除
------------------------------------------------------------</span>
编译期已知类型       ✅          ❌             ❌
需要进数组/逃逸      ❌          ✅             ✅
对性能极度敏感       ✅          ❌             ✅
不想写样板代码       ✅          ✅             ❌（可用宏）
</code></pre>
<p>一句话：编译期能定类型就用泛型；运行时再决定就用擦除；原型阶段先 <code>any</code> 再说。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 一个小型游戏对象模型渐进式设计（五）——Swift 并发世界：把 Attackable 搬进 actor]]></title>    <link>https://juejin.cn/post/7573468493569769508</link>    <guid>https://juejin.cn/post/7573468493569769508</guid>    <pubDate>2025-11-17T10:04:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573468493569769508" data-draft-id="7553845995845173294" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 一个小型游戏对象模型渐进式设计（五）——Swift 并发世界：把 Attackable 搬进 actor"/> <meta itemprop="keywords" content="Swift"/> <meta itemprop="datePublished" content="2025-11-17T10:04:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unravel2025"/> <meta itemprop="url" content="https://juejin.cn/user/1116759541421880"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 一个小型游戏对象模型渐进式设计（五）——Swift 并发世界：把 Attackable 搬进 actor
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759541421880/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unravel2025
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T10:04:00.000Z" title="Mon Nov 17 2025 10:04:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">为什么“并发”突然成了刚需</h2>
<p>真实场景里：</p>
<ul>
<li>游戏服务器：32 条网络线程并发处理玩家技能；</li>
<li>客户端：主线程发动画，后台线程算伤害，Timer 触发 dot；</li>
<li>单机多核：SceneKit 物理回调、Vision 识别、Swift Concurrency Task 同时读写同一 BOSS 的血量。</li>
</ul>
<p>如果还用传统锁：</p>
<pre><code class="hljs language-swift" lang="swift">objc_sync_enter(<span class="hljs-keyword">self</span>)
hp <span class="hljs-operator">-=</span> damage
objc_sync_exit(<span class="hljs-keyword">self</span>)
</code></pre>
<p>轻则性能抖动，重则死锁；而 Swift 5.5 起的 Actor 模型 把“互斥”升级为消息队列，编译期即可检查“跨 actor 引用是否安全”，让“数据竞争”成为编译错误。</p>
<h2 data-id="heading-1">Actor 101：30 秒速览</h2>
<ol>
<li>定义</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">actor</span> <span class="hljs-title class_">Boss</span> {
    <span class="hljs-keyword">var</span> hp: <span class="hljs-type">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">takeDamage</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) {
        hp <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, hp <span class="hljs-operator">-</span> amount)
    }
}
</code></pre>
<ol start="2">
<li>调用规则</li>
</ol>
<ul>
<li>内部：同步函数，直接访问 <code>hp</code>；</li>
<li>外部：必须通过 <code>await</code> 异步消息，编译器自动加队列。</li>
</ul>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> boss <span class="hljs-operator">=</span> <span class="hljs-type">Boss</span>()
<span class="hljs-keyword">await</span> boss.takeDamage(<span class="hljs-number">10</span>)   <span class="hljs-comment">// 编译通过</span>
boss.hp                     <span class="hljs-comment">// ❌ 编译错误：actor-isolated</span>
</code></pre>
<ol start="3">
<li>关键保证</li>
</ol>
<p>Actor 隔离域（isolation domain）：同一时间只有一条消息在执行，天然“可线性化”（Serializability）。</p>
<h2 data-id="heading-2">把协议能力搬进 actor</h2>
<p>目标：</p>
<ul>
<li>不破坏前两篇的泛型协议架构；</li>
<li>让任何实体既能以“值语义”跑在单线程，也能以“ actor 引用”跑在多线程；</li>
<li>客户端/服务器共用同一套算法。</li>
</ul>
<ol>
<li>定义并发版协议</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-comment">/// 可并发受伤</span>
<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">ConcurrentWoundable</span>: <span class="hljs-title class_">AnyObject</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Value</span>: <span class="hljs-type">NumericValue</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">takeDamage</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Value</span>) <span class="hljs-keyword">async</span>
    <span class="hljs-keyword">var</span> currentHp: <span class="hljs-type">Value</span> { <span class="hljs-keyword">get</span> }
}
</code></pre>
<p>注意：</p>
<ul>
<li><code>AnyObject</code> 限制只让 class/actor 符合，因为需要共享引用；</li>
<li>方法标记 <code>async</code>，调用方必须 <code>await</code>。</li>
</ul>
<ol start="2">
<li>让 actor 直接符合</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">actor</span> <span class="hljs-title class_">ConcurrentBoss</span>&lt;<span class="hljs-title class_">Value</span>: <span class="hljs-title class_">NumericValue</span>&gt;: <span class="hljs-title class_">ConcurrentWoundable</span> {
    <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> hp: <span class="hljs-type">Value</span>
    <span class="hljs-keyword">let</span> maxHp: <span class="hljs-type">Value</span>
    
    <span class="hljs-keyword">init</span>(<span class="hljs-params">hp</span>: <span class="hljs-type">Value</span>, <span class="hljs-params">maxHp</span>: <span class="hljs-type">Value</span>) {
        <span class="hljs-keyword">self</span>.hp <span class="hljs-operator">=</span> hp; <span class="hljs-keyword">self</span>.maxHp <span class="hljs-operator">=</span> maxHp
    }
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">takeDamage</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Value</span>) <span class="hljs-keyword">async</span> {
        hp <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(<span class="hljs-type">Value</span>(<span class="hljs-number">0</span>), hp <span class="hljs-operator">-</span> amount)
    }
    
    <span class="hljs-keyword">nonisolated</span> <span class="hljs-keyword">var</span> currentHp: <span class="hljs-type">Value</span> { hp }   <span class="hljs-comment">// 只读快照，无需 await</span>
}
</code></pre>
<p><code>nonisolated</code> 关键字：编译器允许外部同步读取，但不能写。</p>
<ol start="3">
<li>并发安全暴击算法</li>
</ol>
<p>把上篇的 <code>DamageCalculator</code> 泛型算法保持值语义，计算过程无锁；只有最后 <code>takeDamage</code> 进 actor 才排队。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> calc <span class="hljs-operator">=</span> <span class="hljs-type">AnyDamageCalculator</span>(<span class="hljs-type">Double</span>.<span class="hljs-keyword">self</span>) { base <span class="hljs-keyword">in</span> base <span class="hljs-operator">*</span> <span class="hljs-number">1.5</span> }
<span class="hljs-keyword">let</span> damage <span class="hljs-operator">=</span> calc.calculate(base: <span class="hljs-number">50</span>)          <span class="hljs-comment">// 无锁计算</span>
<span class="hljs-keyword">await</span> boss.takeDamage(damage)                  <span class="hljs-comment">// 一次消息</span>
</code></pre>
<p>分离“计算”与“状态变更”：计算无锁、变更串行，兼顾性能与安全。</p>
<h2 data-id="heading-3">分布式 Actor：跨进程也能 “await boss.takeDamage”</h2>
<p>Swift 5.9 起引入 <code>distributed actor</code>，同一语法即可跨进程/跨机器：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">distributed</span> <span class="hljs-keyword">actor</span> <span class="hljs-title class_">RemoteBoss</span>: <span class="hljs-title class_">ConcurrentWoundable</span> {
    <span class="hljs-keyword">distributed</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">takeDamage</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Value</span>) <span class="hljs-keyword">async</span> {
        hp <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(<span class="hljs-type">Value</span>(<span class="hljs-number">0</span>), hp <span class="hljs-operator">-</span> amount)
    }
}
</code></pre>
<p>调用方：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> boss <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> <span class="hljs-type">RemoteBoss</span>.resolve(id: bossID, using: .<span class="hljs-keyword">init</span>())
<span class="hljs-keyword">await</span> boss.takeDamage(<span class="hljs-number">30</span>)
</code></pre>
<p>底层由 Swift gRPC 传输消息，开发者零成本获得分布式对象模型。</p>
<h2 data-id="heading-4">实战：并发 Boss 战模拟器</h2>
<p>场景：</p>
<ul>
<li>4 个玩家并发放技能，伤害随机；</li>
<li>1 个后台线程每 0.5 s 触发 dot；</li>
<li>1 个渲染线程每帧读血量更新 UI；</li>
</ul>
<p>代码：</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">NumericValue</span>: <span class="hljs-title class_">Comparable</span> &amp; <span class="hljs-title class_">Sendable</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">+</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">-</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">*</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">/</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">&gt;</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-type">Bool</span>   <span class="hljs-comment">// 与标量乘</span>
    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">Int</span>)                               <span class="hljs-comment">// 能从整数字面量初始化</span>
}
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Double</span>: <span class="hljs-title class_">NumericValue</span> {}

<span class="hljs-comment">/// 可并发受伤</span>
<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">ConcurrentWoundable</span>: <span class="hljs-title class_">AnyObject</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Value</span>: <span class="hljs-type">NumericValue</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">takeDamage</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Value</span>) <span class="hljs-keyword">async</span>
    <span class="hljs-keyword">var</span> currentHp: <span class="hljs-type">Value</span> { <span class="hljs-keyword">get</span> }
}

<span class="hljs-comment">// 1. 并发 BOSS</span>
<span class="hljs-keyword">actor</span> <span class="hljs-title class_">BossBattle</span>: @<span class="hljs-title class_">preconcurrency</span> <span class="hljs-title class_">ConcurrentWoundable</span> {
    <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> hp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> maxHp: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">init</span>(<span class="hljs-params">hp</span>: <span class="hljs-type">Double</span>) {
        <span class="hljs-keyword">self</span>.hp <span class="hljs-operator">=</span> hp;
        <span class="hljs-keyword">self</span>.maxHp <span class="hljs-operator">=</span> hp
    }
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">takeDamage</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) <span class="hljs-keyword">async</span> {
        hp <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, hp <span class="hljs-operator">-</span> amount)
        <span class="hljs-keyword">if</span> hp <span class="hljs-operator">==</span> <span class="hljs-number">0</span> { <span class="hljs-built_in">print</span>(<span class="hljs-string">"BOSS 被击败！"</span>) }
    }
    
    <span class="hljs-keyword">var</span> currentHp: <span class="hljs-type">Double</span> { hp }
}

<span class="hljs-comment">// 2. 玩家技能</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">playerTask</span>(<span class="hljs-params">id</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">boss</span>: <span class="hljs-type">BossBattle</span>) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">5</span> {
        <span class="hljs-keyword">let</span> damage <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>.random(in: <span class="hljs-number">5</span><span class="hljs-operator">...</span><span class="hljs-number">15</span>)
        <span class="hljs-keyword">await</span> boss.takeDamage(damage)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Player<span class="hljs-subst">\(id)</span> 造成 <span class="hljs-subst">\(damage)</span>"</span>)
        <span class="hljs-keyword">try?</span> <span class="hljs-keyword">await</span> <span class="hljs-type">Task</span>.sleep(for: .milliseconds(.random(in: <span class="hljs-number">100</span><span class="hljs-operator">...</span><span class="hljs-number">300</span>)))
    }
}

<span class="hljs-comment">// 3. dot 后台</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">dotTask</span>(<span class="hljs-params">boss</span>: <span class="hljs-type">BossBattle</span>) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">await</span> boss.currentHp <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> {
        <span class="hljs-keyword">await</span> boss.takeDamage(<span class="hljs-number">3</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"dot 3 点"</span>)
        <span class="hljs-keyword">try?</span> <span class="hljs-keyword">await</span> <span class="hljs-type">Task</span>.sleep(for: .milliseconds(<span class="hljs-number">500</span>))
    }
}

<span class="hljs-comment">// 4. 渲染线程（只读）</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">renderTask</span>(<span class="hljs-params">boss</span>: <span class="hljs-type">BossBattle</span>) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">await</span> boss.currentHp <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> {
        <span class="hljs-keyword">let</span> hp <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> boss.currentHp
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"UI 血量：<span class="hljs-subst">\(Int(hp))</span>"</span>)
        <span class="hljs-keyword">try?</span> <span class="hljs-keyword">await</span> <span class="hljs-type">Task</span>.sleep(for: .seconds(<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">60</span>))
    }
}

<span class="hljs-comment">// 5. 启动</span>

<span class="hljs-type">Task</span> {
    <span class="hljs-keyword">let</span> boss <span class="hljs-operator">=</span> <span class="hljs-type">BossBattle</span>(hp: <span class="hljs-number">100</span>)
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> withDiscardingTaskGroup { group <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">4</span> {
            group.addTask {
                <span class="hljs-keyword">await</span> playerTask(id: i, boss: boss)
            }
        }
        
        group.addTask {
            <span class="hljs-keyword">await</span> dotTask(boss: boss)
        }
        
        group.addTask {
            <span class="hljs-keyword">await</span> renderTask(boss: boss)
        }
    }
}
</code></pre>
<p>运行结果（节选）：</p>
<pre><code class="hljs language-erlang" lang="erlang">Player3 造成 <span class="hljs-number">11.0</span>
Player1 造成 <span class="hljs-number">8.0</span>
dot <span class="hljs-number">3</span> 点
UI 血量：<span class="hljs-number">78</span>
...
BOSS 被击败！
</code></pre>
<p>全程无需手动加锁，编译器保证任何时刻只有一条消息在修改 <code>hp</code>。</p>
<h2 data-id="heading-5">与 SwiftUI 无缝衔接</h2>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-meta">@MainActor</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BossModel</span>: <span class="hljs-title class_">ObservableObject</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> boss <span class="hljs-operator">=</span> <span class="hljs-type">BossBattle</span>(hp: <span class="hljs-number">100</span>)
    
    <span class="hljs-meta">@Published</span> <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> hpText <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">start</span>() <span class="hljs-keyword">async</span> {
        <span class="hljs-keyword">await</span> renderLoop()
    }
    
    <span class="hljs-meta">@MainActor</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">renderLoop</span>() <span class="hljs-keyword">async</span> {
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">await</span> boss.currentHp <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> {
            hpText <span class="hljs-operator">=</span> <span class="hljs-string">"血量 <span class="hljs-subst">\(Int(await boss.currentHp))</span>"</span>
            <span class="hljs-keyword">try?</span> <span class="hljs-keyword">await</span> <span class="hljs-type">Task</span>.sleep(for: .seconds(<span class="hljs-number">1</span>))
        }
        hpText <span class="hljs-operator">=</span> <span class="hljs-string">"BOSS 被击败"</span>
    }
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">attack</span>() <span class="hljs-keyword">async</span> {
        <span class="hljs-keyword">await</span> boss.takeDamage(<span class="hljs-type">Double</span>.random(in: <span class="hljs-number">10</span><span class="hljs-operator">...</span><span class="hljs-number">20</span>))
    }
}
</code></pre>
<p><code>@MainActor</code> 保证所有 SwiftUI 状态更新跑在主线程；业务逻辑在后台 actor 串行执行，零数据竞争。</p>
<h2 data-id="heading-6">常见坑与最佳实践</h2>
<ol>
<li>
<p>在 actor 里访问全局可变状态</p>
<p>同样要 <code>await</code>，否则编译报错。</p>
</li>
<li>
<p><code>nonisolated</code> 只能读，不能写；写必须走消息。</p>
</li>
<li>
<p>不要把长时间阻塞代码（sleep、sync I/O）直接放进 actor，会卡住消息队列；应拆到 <code>Task.detached</code> 或 <code>AsyncSequence</code>。</p>
</li>
<li>
<p>跨 actor 调用时，值类型会被拷贝，不要传递大型数组；可改用 <code>AsyncSequence</code> 流式输出。</p>
</li>
<li>
<p>分布式 actor 的方法参数/返回值必须遵循 <code>Codable</code>，否则无法序列化</p>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[告别JMeter！我用 k6 5 分钟完成高并发压测]]></title>    <link>https://juejin.cn/post/7573512056088444963</link>    <guid>https://juejin.cn/post/7573512056088444963</guid>    <pubDate>2025-11-17T09:32:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573512056088444963" data-draft-id="7572836557142540288" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="告别JMeter！我用 k6 5 分钟完成高并发压测"/> <meta itemprop="keywords" content="后端,测试"/> <meta itemprop="datePublished" content="2025-11-17T09:32:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="虎子_layor"/> <meta itemprop="url" content="https://juejin.cn/user/1109832819826707"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            告别JMeter！我用 k6 5 分钟完成高并发压测
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1109832819826707/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    虎子_layor
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:32:26.000Z" title="Mon Nov 17 2025 09:32:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{font-family:-apple-system,BlinkMacSystemFont,PingFang SC,Helvetica Neue,Helvetica,Arial,sans-serif;word-break:break-word;line-height:1.75;font-weight:200;font-size:16px;overflow-x:hidden;color:#666;letter-spacing:.5px}.markdown-body a{text-decoration:none;color:#0064c8;position:relative}.markdown-body a:after{content:"";position:absolute;bottom:-2px;left:0;width:100%;height:1px;background-color:rgba(0,100,200,.7);transform:scale(0);transition:all .4s ease-in-out}.markdown-body a:link:hover:after{transform:scale(1)}.markdown-body code{padding:2px 4px;font-size:.9em;font-family:Menlo,Monaco,Consolas,Courier New,monospace;border-radius:2px;background-color:rgba(0,46,70,.0431);color:#39f}.markdown-body strong{font-weight:400}.markdown-body em{color:#ff6a00}.markdown-body del,.markdown-body s{color:#bbb}.markdown-body small{font-size:.8em;color:#bbb}.markdown-body kbd{margin:0 .1em;padding:5px 8px 3px;border:1px solid #d1d5d9;border-radius:3px;box-shadow:0 1px 0 0 #e3e4e6,inset 0 0 0 2px #fff;background-color:#eee;font-weight:600;font-size:.8em;font-family:Arial,Helvetica Neue,Helvetica,sans-serif;white-space:nowrap;color:#666}.markdown-body kbd:first-child{margin-left:0}.markdown-body kbd:last-child{margin-right:0}.markdown-body img{display:block;border:0;max-width:calc(100% - 20px);min-width:20px;min-height:20px;margin:0 10px;box-shadow:0 2px 8px 2px rgba(0,0,0,.2);transition:all .25s ease-in-out}.markdown-body img:hover{transform:translateY(-4px)}.markdown-body blockquote,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{line-height:inherit;font-size:inherit;color:inherit}.markdown-body blockquote:first-child,.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child,.markdown-body ol:first-child,.markdown-body p:first-child,.markdown-body pre:first-child,.markdown-body table:first-child,.markdown-body ul:first-child{margin-top:0}.markdown-body blockquote:last-child,.markdown-body h1:last-child,.markdown-body h2:last-child,.markdown-body h3:last-child,.markdown-body h4:last-child,.markdown-body h5:last-child,.markdown-body h6:last-child,.markdown-body ol:last-child,.markdown-body p:last-child,.markdown-body pre:last-child,.markdown-body table:last-child,.markdown-body ul:last-child{margin-bottom:0}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:1.6em 0 .6em;color:#333;font-weight:400;position:relative}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{position:absolute;left:-2em}.markdown-body h1{font-size:1.75em}.markdown-body h1:before{content:"#"}.markdown-body h1:first-child{margin-top:0}.markdown-body h2{font-size:1.5em}.markdown-body h3{font-size:1.35em}.markdown-body h4{font-size:1.2em}.markdown-body h5{font-size:1.1em}.markdown-body h6{font-size:1em}.markdown-body blockquote,.markdown-body ol,.markdown-body pre,.markdown-body table,.markdown-body ul{margin:1em 0}.markdown-body p{margin:.7em 0;word-break:break-word}.markdown-body pre{padding:8px 12px;color:#666;background-color:rgba(0,46,70,.0431);border:1px solid #ebebeb;tab-size:4;white-space:pre-wrap;line-height:1.4}.markdown-body pre code{color:inherit;background-color:transparent;padding:0}.markdown-body ol,.markdown-body ul{margin:1em 0 1em 2em;padding:0;line-height:1.5!important;font-size:inherit;color:inherit}.markdown-body ol:first-child,.markdown-body ul:first-child{margin-top:0}.markdown-body ol:last-child,.markdown-body ul:last-child{margin-bottom:0}.markdown-body ol li,.markdown-body ul li{margin:.5em 0;list-style:inherit}.markdown-body ul{list-style:disc outside}.markdown-body ul ul{list-style-type:circle}.markdown-body ul ul ul{list-style-type:square}.markdown-body ol{list-style:decimal outside}.markdown-body ol ol{list-style-type:lower-alpha}.markdown-body ol ol ol{list-style-type:lower-roman}.markdown-body blockquote{font-size:.9em;padding:8px 20px 8px 15px;color:#666;border-left:5px solid rgba(0,100,200,.7);background-color:rgba(0,100,200,.1)}.markdown-body table{border-collapse:collapse;border-spacing:0;max-width:100%;min-width:50%;word-wrap:break-word;color:inherit}.markdown-body table thead tr{background-color:#f4f6f7}.markdown-body table td,.markdown-body table th{padding:4px 16px;font-size:.95em;text-align:left;color:inherit;border:0;min-width:72px}.markdown-body table td[align=center],.markdown-body table th[align=center]{text-align:center}.markdown-body table td[align=right],.markdown-body table th[align=right]{text-align:right}.markdown-body table th{border-bottom:2px solid #e3e4e6;color:#333;font-weight:400;white-space:nowrap}.markdown-body table td{border-bottom:1px solid #ebebeb}.markdown-body hr{margin:1.5em 0;padding:0;border:0;background:linear-gradient(90deg,rgba(0,46,70,.0431),#ebebeb 50%,rgba(0,46,70,.0431));height:1px}.markdown-body br{content:"";display:block}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">为什么选择 k6，而不是JMeter。</h2>
<blockquote>
<p>曾经我也用 JMeter 做压测——拖拽组件、配置线程组、调试监听器……看似图形化，实则繁琐低效。直到遇见 <strong>k6</strong>：一个用 JavaScript 写脚本、命令行一键运行、天然集成 CI/CD 的现代压测工具。</p>
</blockquote>
<p><strong>选择 k6，不是因为它“取代”了 JMeter，而是因为它解决了 JMeter 在“开发者工作流”中的痛点</strong>：</p>
<ul>
<li>脚本难维护 → 用 JS 写，Git 友好</li>
<li>资源消耗大 → 轻量高效</li>
<li>CI 集成麻烦 → 命令行原生支持</li>
<li>监控复杂 → 一键对接 Grafana</li>
</ul>
<p>如果你也厌倦了 JMeter 的笨重配置，k6 能让你用写代码的方式，5 分钟完成一次高并发压测。</p>
<h2 data-id="heading-1">快速安装</h2>
<ul>
<li>
<p>macOS：brew install k6</p>
</li>
<li>
<p>Linux（Debian/Ubuntu）：</p>
<ul>
<li>添加仓库密钥与源，执行 sudo apt-get install k6</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69

<span class="hljs-built_in">echo</span> <span class="hljs-string">'deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main'</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/k6.list

sudo apt-get update &amp;&amp; sudo apt-get install k6

</code></pre>
<ul>
<li>
<p>Windows（Scoop/WSL）：</p>
<ul>
<li>scoop install k6 或在 WSL 内安装</li>
</ul>
</li>
<li>
<p>验证安装</p>
</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">k6 version

<span class="hljs-comment"># 输出：k6.exe v1.4.0 (commit/a9f9e3b28a, go1.25.4, windows/amd64)</span>
</code></pre>
<p><strong>核心概念</strong></p>
<ul>
<li>VU（Virtual User）：虚拟用户，模拟真实用户行为。</li>
<li>Iteration：每个 VU 执行一次 default 函数即一次迭代。</li>
<li>Options：并发数、持续时间、阈值、阶段（stages）。</li>
<li>Checks：断言，不影响请求但计入通过率。</li>
<li>Thresholds：性能阈值（如 P95 &lt; 200ms），违反则测试失败。</li>
</ul>
<h2 data-id="heading-2"><strong>第一个脚本：测试短链跳转</strong></h2>
<ul>
<li>
<p>文件：web/k6/redirect.js</p>
</li>
<li>
<p>脚本要点：</p>
<ul>
<li>运行阶段（stages）模拟并发爬坡与回落。</li>
<li>阈值约束 p95，防止性能回归。</li>
<li>支持环境变量覆盖 BASE、CODES、VUS。</li>
<li>内置 HTML 报告生成（无需额外安装）。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'k6/http'</span>
<span class="hljs-keyword">import</span> { check, sleep } <span class="hljs-keyword">from</span> <span class="hljs-string">'k6'</span>
<span class="hljs-keyword">import</span> { htmlReport } <span class="hljs-keyword">from</span> <span class="hljs-string">'https://raw.githubusercontent.com/benc-uk/
k6-reporter/main/dist/bundle.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">stages</span>: [
    { <span class="hljs-attr">duration</span>: <span class="hljs-string">'30s'</span>, <span class="hljs-attr">target</span>: <span class="hljs-title class_">Number</span>(__ENV.<span class="hljs-property">VUS1</span> || <span class="hljs-number">100</span>) },
    { <span class="hljs-attr">duration</span>: <span class="hljs-string">'2m'</span>, <span class="hljs-attr">target</span>: <span class="hljs-title class_">Number</span>(__ENV.<span class="hljs-property">VUS2</span> || <span class="hljs-number">500</span>) },
    { <span class="hljs-attr">duration</span>: <span class="hljs-string">'30s'</span>, <span class="hljs-attr">target</span>: <span class="hljs-number">0</span> },
  ],
  <span class="hljs-attr">thresholds</span>: {
    <span class="hljs-attr">http_req_duration</span>: [<span class="hljs-string">'p(95)&lt;300'</span>],
    <span class="hljs-attr">checks</span>: [<span class="hljs-string">'rate&gt;0.99'</span>],
  },
}
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BASE</span> = __ENV.<span class="hljs-property">BASE</span> || <span class="hljs-string">'http://localhost:8080'</span>
<span class="hljs-keyword">let</span> codes = (__ENV.<span class="hljs-property">CODES</span> || <span class="hljs-string">'千问,腾讯技术'</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-property">trim</span>
()).<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>)
<span class="hljs-keyword">if</span> (codes.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) codes = [<span class="hljs-string">'test'</span>]
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> code = codes[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * codes.<span class="hljs-property">length</span>)]
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${BASE}</span>/<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(code)}</span>`</span>
  <span class="hljs-keyword">const</span> res = http.<span class="hljs-title function_">get</span>(url, { <span class="hljs-attr">redirects</span>: <span class="hljs-number">0</span> })
  <span class="hljs-title function_">check</span>(res, { <span class="hljs-string">'302'</span>: <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">status</span> === <span class="hljs-number">302</span> })
  <span class="hljs-title function_">sleep</span>(<span class="hljs-title class_">Number</span>(__ENV.<span class="hljs-property">SLEEP</span> || <span class="hljs-number">0.3</span>))
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSummary</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-keyword">return</span> { <span class="hljs-string">'summary.json'</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">'summary.html'</span>: 
  <span class="hljs-title function_">htmlReport</span>(data) }
}
</code></pre>
<blockquote>
<p>脚本可以直接让ai生成大大加快压测速度</p>
</blockquote>
<ul>
<li>
<p>运行：</p>
<ul>
<li>cd web/k6</li>
<li>k6 run .\redirect.js</li>
<li>生成 summary.html / summary.json（用浏览器打开 HTML 即可）。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-3"><strong>压测结果分析</strong></h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89a103b67ca4458395572099ab9202ea~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JmO5a2QX2xheW9y:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976746&amp;x-signature=hrjKKWuMhahhU9FyhUiBHVjV%2Bzo%3D" alt="屏幕截图 2025-11-17 141055.png" loading="lazy"/></p>
<ul>
<li>http_reqs：总请求与速率（QPS），衡量吞吐。</li>
<li>http_req_duration：总时延（p50/p90/p95）；p95 是体验目标的主指标。</li>
<li>http_req_waiting：TTFB（服务端处理主耗时）；若≈duration，瓶颈在服务端。</li>
<li>http_req_failed / checks：错误率与断言通过率；理想≈0%、≈100%。</li>
<li>被违反阈值（breached thresholds）：性能目标未达标的直接证据。</li>
<li>趋势曲线：随阶段变化的延迟与吞吐，拐点暴露瓶颈（连接池/线程/队列/GC）。</li>
</ul>
<blockquote>
<p>HTML 报告适合单次测试查看，但长期性能趋势分析仍需对接 Grafana。</p>
</blockquote>
<h2 data-id="heading-4"><strong>生成实时可视化报告（InfluxDB + Grafana）</strong></h2>
<p>目标：压测过程中就能看到并发、QPS、延迟曲线，便于定位时段性问题。</p>
<ul>
<li>
<p>准备（Docker，不装即用）</p>
<ul>
<li>docker pull influxdb:1.8 &amp;&amp; docker run -d --name influxdb -p 8086:8086 influxdb:1.8</li>
<li>docker exec -it influxdb influx -execute "CREATE DATABASE k6"</li>
<li>docker pull grafana/grafana:latest &amp;&amp; docker run -d --name grafana -p 3000:3000 grafana/grafana:latest</li>
</ul>
</li>
<li>
<p>将 k6 写入 InfluxDB：</p>
<ul>
<li>k6 run -o influxdb=<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A8086%2Fk6" target="_blank" title="http://localhost:8086/k6" ref="nofollow noopener noreferrer">http://localhost:8086/k6</a> .\redirect.js</li>
</ul>
</li>
<li>
<p>Grafana 配置：</p>
<ul>
<li>访问 <a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A3000%25EF%25BC%258C%25E5%25AF%2586%25E7%25A0%2581%25E9%25BB%2598%25E8%25AE%25A4%25EF%25BC%2588admin%2Cadmin%25EF%25BC%2589" target="_blank" title="http://localhost:3000%EF%BC%8C%E5%AF%86%E7%A0%81%E9%BB%98%E8%AE%A4%EF%BC%88admin,admin%EF%BC%89" ref="nofollow noopener noreferrer">http://localhost:3000，密码默认（admin,admin）</a></li>
<li>添加数据源 InfluxDB：URL <a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A8086%25EF%25BC%258CDB%25C2%25A0k6" target="_blank" title="http://localhost:8086%EF%BC%8CDB%C2%A0k6" ref="nofollow noopener noreferrer">http://localhost:8086，DB k6</a></li>
<li>导入 k6 看板 ID 10660</li>
<li>即可实时查看 VUs、RPS、http_req_duration、错误率曲线</li>
</ul>
</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6043b5252fb14f3f9d35ece2476f7e90~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JmO5a2QX2xheW9y:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763976746&amp;x-signature=vQvzp%2FGmVXkrJIucMF1B6qFrCkw%3D" alt="屏幕截图 2025-11-17 171252.png" loading="lazy"/></p>
<h2 data-id="heading-5"><strong>将压测集成到 CI/CD：实现自动化性能回归</strong></h2>
<p>光有本地压测还不够。真正的工程实践是：<strong>每次代码提交，自动运行压测，性能下降立即告警</strong>。</p>
<p>以 GitHub Actions 为例，在项目中添加 <code>.github/workflows/perf-test.yml</code>：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Performance</span> <span class="hljs-string">Test</span>
<span class="hljs-attr">on:</span>
  <span class="hljs-attr">push:</span>
    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">main</span> ]  <span class="hljs-comment"># 推送到主分支时触发</span>
<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">k6:</span>
    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">k6</span> <span class="hljs-string">test</span>
        <span class="hljs-attr">env:</span>
          <span class="hljs-attr">BASE_URL:</span> <span class="hljs-string">https://example.com</span> <span class="hljs-comment">#按需修改</span>
        <span class="hljs-attr">run:</span> <span class="hljs-string">|
          docker run -i --rm -v ${PWD}:/scripts -e BASE_URL \
            grafana/k6 run /scripts/web/k6/redirect.js
</span></code></pre>
<hr/>
<p><strong>总结</strong>：k6 不是 JMeter 的替代品，而是为开发者量身打造的“性能验证工具”。它用代码代替配置，用自动化代替手动，让你在开发阶段就能发现性能问题。</p>
<p><strong>参考资料</strong></p>
<ul>
<li>k6 官网与文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fk6.io%2F" target="_blank" title="https://k6.io/" ref="nofollow noopener noreferrer">k6.io</a></li>
<li>k6 Reporter：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbenc-uk%2Fk6-reporter" target="_blank" title="https://github.com/benc-uk/k6-reporter" ref="nofollow noopener noreferrer">github.com/benc-uk/k6-…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【Numpy数据运算】Numpy速学手册]]></title>    <link>https://juejin.cn/post/7573170756869128244</link>    <guid>https://juejin.cn/post/7573170756869128244</guid>    <pubDate>2025-11-17T06:31:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573170756869128244" data-draft-id="7573241978901659663" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【Numpy数据运算】Numpy速学手册"/> <meta itemprop="keywords" content="Python,NumPy"/> <meta itemprop="datePublished" content="2025-11-17T06:31:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AI小云"/> <meta itemprop="url" content="https://juejin.cn/user/4153318871926912"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【Numpy数据运算】Numpy速学手册
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4153318871926912/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AI小云
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:31:40.000Z" title="Mon Nov 17 2025 06:31:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、Numpy的基本介绍和配置</h3>
<h4 data-id="heading-1">1.1 numpy基本介绍</h4>
<p>numpy是Python语言的一个第三方科学计算库，它的意思是“Numeric Python”，它是一个由多维数组对象和用于处理数组的函数集合组成的库。</p>
<p>numpy支持N维数组运算、处理大型矩阵、成熟的广播函数库、矢量计算、线性代数等常见科学运算操作，而且处理效率非常高，特别是针对数组运算，所以是非常常用的一个科学计算和数据分析用的库。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d237438b8c344369962d9b2d833655b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlsI_kupE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965899&amp;x-signature=hcvQq%2Fq8x0%2FB4bjPD6zh5JeDL54%3D" alt="1.png" loading="lazy"/></p>
<h4 data-id="heading-2">1.2 numpy的优势</h4>
<p>numpy的数组在运算时是非常高效的，特别是在多维向量运算时远比python数组快得多。我们可以通过一个简单的例子来对比python数组和numpy数组的运行效率哪个更高，代码如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># numpy和python原生列表求和计算的对比</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> time
py_list = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000000</span>):
    py_list.append(random.random())   <span class="hljs-comment"># 生成100000000个元素的随机数列表</span>
np_list = np.array(py_list)  <span class="hljs-comment"># 将100000000个元素的随机数列表放入到ndarray中</span>
<span class="hljs-comment"># 原生python list求和</span>
st1 = time.time()  <span class="hljs-comment"># 记录开始时间</span>
<span class="hljs-built_in">sum</span>(py_list)        <span class="hljs-comment"># 直接使用python列表提供的sum方法对列表求和</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"用原生python列表计算耗时为："</span>, time.time()-st1)
<span class="hljs-comment"># 用ndarray求和</span>
st2 = time.time()
np.<span class="hljs-built_in">sum</span>(np_list)     <span class="hljs-comment"># 利用numpy提供的sum方法对列表求和</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"用ndarray计算耗时为："</span>, time.time()-st2)
</code></pre>
<p>python为什么慢？</p>
<ol start="0">
<li>标准的python中用列表保存一组值，可以当作数组使用。但由于列表的元素可以是任何对象，因此列表中保存的是对象的指针（地址）。对于数值运算来说，这种结构显然比较浪费内存和CPU运算。</li>
<li>Python提供了array模块，能直接保存数值，但由于它不支持多维数组，也没有各种运算函数，因为也不适合做数值运算。</li>
</ol>
<h3 data-id="heading-3">二、Numpy基础使用</h3>
<h4 data-id="heading-4">2.1 生成numpy数组</h4>
<p>在numpy中，最重要的对象是被称为叫ndarray的N维数组类型。ndarray中的每个元素在内存中使用相同大小的块，它描述相同类型的元素集合。这个集合中的元素是基于零的索引来进行访问。</p>
<ul>
<li>创建一个基本的numpy数组</li>
</ul>

<pre><code class="hljs language-php" lang="php">import numpy <span class="hljs-keyword">as</span> np
my_array = np.<span class="hljs-keyword">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-keyword">print</span>(my_array)
</code></pre>
<p>实际上上面的代码是将一个python数组转化为了一个numpy数组。</p>
<p>除了可以将python数组转化为一个numpy数组外，numpy还内置了几种常见的创建数组的方式。</p>
<ul>
<li>创建指定形状的全0的二维数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">ndarr1</span> = np.zeros(shape=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>), dtype=np.int_)  <span class="hljs-comment"># np.int_是numpy里面自带的整型类型</span>
print(ndarr1)
打印出来的结果是：
<span class="hljs-section">[[0 0 0 0]</span>
 <span class="hljs-section">[0 0 0 0]</span>
 <span class="hljs-section">[0 0 0 0]]</span>
</code></pre>
<ul>
<li>创建指定形状全1的二维数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd2</span> = np.<span class="hljs-literal">on</span>es(shape=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>), dtype=np.float_) <span class="hljs-comment"># 注意，指定的是float类型</span>
print(nd2)
输出结果为：
<span class="hljs-section">[[1. 1. 1. 1.]</span>
 <span class="hljs-section">[1. 1. 1. 1.]</span>
 <span class="hljs-section">[1. 1. 1. 1.]]</span>
</code></pre>
<p>这些方法的主要意义是方便用户快速创建指定大小的全零数组，并将其作为其他计算和操作的基础。</p>
<ul>
<li>生成指定维数的多维数组，比如三维数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">np.full(<span class="hljs-attr">shape</span>=(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>), fill_value=<span class="hljs-number">1.23</span>) <span class="hljs-comment"># 生成一个三维数组，第一维有3行，第二维有4行，第三维有5个元素。所有的元素都用1.23来填充。</span>
运行结果如下：
array(<span class="hljs-section">[[[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]]</span>,
       <span class="hljs-section">[[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]]</span>,
       <span class="hljs-section">[[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]</span>,
        <span class="hljs-section">[1.23, 1.23, 1.23, 1.23, 1.23]]]</span>)
</code></pre>
<ul>
<li>生成随机数组</li>
</ul>

<pre><code class="hljs language-scss" lang="scss">np<span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.randint</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">20</span>)  # 生成一个<span class="hljs-number">1</span>-<span class="hljs-number">100</span>之间，<span class="hljs-number">20</span>个随机的整数值
运行结果如下：
<span class="hljs-built_in">array</span>([<span class="hljs-number">83</span>, <span class="hljs-number">26</span>, <span class="hljs-number">69</span>, <span class="hljs-number">60</span>, <span class="hljs-number">86</span>, <span class="hljs-number">92</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">21</span>, <span class="hljs-number">13</span>, <span class="hljs-number">28</span>, <span class="hljs-number">71</span>, <span class="hljs-number">61</span>, <span class="hljs-number">49</span>, <span class="hljs-number">28</span>, <span class="hljs-number">34</span>, <span class="hljs-number">71</span>, <span class="hljs-number">13</span>,
       <span class="hljs-number">63</span>, <span class="hljs-number">68</span>, <span class="hljs-number">25</span>])
</code></pre>
<ul>
<li>生成0-1之间的随机数</li>
</ul>

<pre><code class="hljs language-lua" lang="lua">np.<span class="hljs-built_in">random</span>.rand(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)  # 生成<span class="hljs-number">3</span>行<span class="hljs-number">5</span>列的<span class="hljs-number">0</span><span class="hljs-number">-1</span>之间的随机数
运行结果如下：
array(<span class="hljs-string">[[0.99575551, 0.15548124, 0.22529574, 0.51938085, 0.45664922],
       [0.90502429, 0.3120783 , 0.8739342 , 0.94432649, 0.68055903],
       [0.47818137, 0.17935855, 0.03667778, 0.1575434 , 0.03999879]]</span>)
</code></pre>
<ul>
<li>生成等差数列</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">np.arange(1, 100, <span class="hljs-attr">step</span>=<span class="hljs-number">2</span>)  <span class="hljs-comment"># 生成差值为2的等差序列</span>
运行结果如下：
array(<span class="hljs-section">[ 1,  3,  5,  7,  9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33,
       35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67,
       69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]</span>)
np.linspace(1, 10, <span class="hljs-attr">num</span>=<span class="hljs-number">20</span>)  <span class="hljs-comment"># 生成从1-10之间的有20个数的等差数列</span>
运行结果如下：
array(<span class="hljs-section">[ 1.        ,  1.47368421,  1.94736842,  2.42105263,  2.89473684,
        3.36842105,  3.84210526,  4.31578947,  4.78947368,  5.26315789,
        5.73684211,  6.21052632,  6.68421053,  7.15789474,  7.63157895,
        8.10526316,  8.57894737,  9.05263158,  9.52631579, 10.        ]</span>)
注意，两者的区别是：
1. arange是左开右闭，并且可以通过参数指定等差的步长。
2. linspace是左开右开，通过参数指定的是等差数列的值的个数，无法指定步长
</code></pre>
<ul>
<li>创建单位数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">np.eye(4)   <span class="hljs-comment"># 创建一个4行4列的数组，对角线全为1</span>
输出结果：
array(<span class="hljs-section">[[1., 0., 0., 0.]</span>,
       <span class="hljs-section">[0., 1., 0., 0.]</span>,
       <span class="hljs-section">[0., 0., 1., 0.]</span>,
       <span class="hljs-section">[0., 0., 0., 1.]]</span>)
</code></pre>
<ul>
<li>创建对角数组</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">np.diag(<span class="hljs-section">[2,3,4,8]</span>)  <span class="hljs-comment"># 根据列表参数创建对角数组</span>
输出结果：
array(<span class="hljs-section">[[2, 0, 0, 0]</span>,
       <span class="hljs-section">[0, 3, 0, 0]</span>,
       <span class="hljs-section">[0, 0, 4, 0]</span>,
       <span class="hljs-section">[0, 0, 0, 8]]</span>)
</code></pre>
<h4 data-id="heading-5">2.2 其他运算操作</h4>
<p>数组的聚合运算：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-selector-tag">a</span> = np<span class="hljs-selector-class">.array</span>([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]])
<span class="hljs-built_in">print</span>(np.sum(a))
<span class="hljs-built_in">print</span>(np.average(a))
<span class="hljs-built_in">print</span>(np.mean(a))
<span class="hljs-built_in">print</span>(np.std(a))
<span class="hljs-built_in">print</span>(np.var(a))
<span class="hljs-built_in">print</span>(np.min(a))
<span class="hljs-built_in">print</span>(np.max(a))
<span class="hljs-built_in">print</span>(np.median(a))
</code></pre>
<p>转换方向：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">print</span>(np.rot90(a))        <span class="hljs-comment"># 旋转90度</span>
<span class="hljs-built_in">print</span>(np.rot90(a, k=3))    <span class="hljs-comment"># 旋转270度</span>
</code></pre>
<p>特殊运算：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">print</span>(np.power(a, 2))   <span class="hljs-comment"># 各数的平方</span>
<span class="hljs-built_in">print</span>(np.exp(a))        <span class="hljs-comment"># e的各数次方</span>
<span class="hljs-built_in">print</span>(np.log(a))        <span class="hljs-comment"># 自然对数</span>
<span class="hljs-built_in">print</span>(np.log2(a))        <span class="hljs-comment"># 2为底数</span>
<span class="hljs-built_in">print</span>(np.log10(a))        <span class="hljs-comment"># 10为底数</span>
</code></pre>
<h4 data-id="heading-6">2.2 查看数组属性</h4>
<p>新建一个数组，并查看数组的各个常见属性。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd</span> = np.random.rand(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)
array(<span class="hljs-section">[[0.68500603, 0.33329822, 0.95843204, 0.88017799, 0.27872737]</span>,
       <span class="hljs-section">[0.33032208, 0.26202034, 0.64646861, 0.79371605, 0.18761317]</span>,
       <span class="hljs-section">[0.06157604, 0.2343893 , 0.55365721, 0.60644976, 0.81372911]]</span>)
<span class="hljs-comment"># 查看数组的形状</span>
nd.shape  <span class="hljs-comment">#(3, 5)</span>
<span class="hljs-comment"># 查看数组的长度</span>
nd.size   <span class="hljs-comment"># 15</span>
<span class="hljs-comment"># 查看数组元素类型</span>
nd.dtype  <span class="hljs-comment"># dtype('float64')</span>
<span class="hljs-comment"># 查看数组的维度</span>
nd.ndim   <span class="hljs-comment"># 2</span>
</code></pre>
<h4 data-id="heading-7">2.3 常见数据类型</h4>
<p>在numpy中，常见的数据类型包括int，float，str，和datetime64等类型。</p>
<pre><code class="hljs language-ini" lang="ini">np.array(<span class="hljs-section">[1,2,3,4]</span>, <span class="hljs-attr">dtype</span>=<span class="hljs-string">"float16"</span>)  <span class="hljs-comment"># 创建数组时指定数据类型</span>
输出结果：
array(<span class="hljs-section">[1., 2., 3., 4.]</span>, <span class="hljs-attr">dtype</span>=float16)
<span class="hljs-comment"># 文本型数据类型</span>
np.array(list('hello'))
输出结果：array(<span class="hljs-section">['h', 'e', 'l', 'l', 'o']</span>, <span class="hljs-attr">dtype</span>=<span class="hljs-string">'&lt;U1'</span>)
也可以进行数据类型的转换
<span class="hljs-attr">nd</span> = np.random.rand(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)
nd.dtype   <span class="hljs-comment"># float64</span>
np.asarray(nd, <span class="hljs-attr">dtype</span>=<span class="hljs-string">"float16"</span>)   <span class="hljs-comment"># 将nd数组由float64位变为float16位，精度减小</span>
np.asarray(nd, <span class="hljs-attr">dtype</span>=<span class="hljs-string">"int8"</span>)     <span class="hljs-comment"># 将nd数组变成int类型，结果全部是0，因为小数位数舍去了</span>
通过对象自身的astype进行类型转换
nd.astype(<span class="hljs-attr">dtype</span>=<span class="hljs-string">"float32"</span>)
</code></pre>
<p>时间类型的用法 datetime64 类型是 Numpy 中一种用于表示日期和时间的数据类型。下面是一个使用方法的示例：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-comment"># 创建一个 datetime 对象表示 2022-01-01 12:00:00</span>
dt = np.datetime64(<span class="hljs-string">'2022-01-01T12:00:00'</span>)
<span class="hljs-comment"># 输出对象以及其数据类型</span>
<span class="hljs-built_in">print</span>(dt)
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(dt))
<span class="hljs-comment"># 创建一个包含多个 datetime 对象的数组</span>
dt_arr = np.array([<span class="hljs-string">'2022-01-01T12:00:00'</span>, <span class="hljs-string">'2022-01-02T06:30:00'</span>, <span class="hljs-string">'2022-01-03T14:15:00'</span>], dtype=<span class="hljs-string">'datetime64'</span>)
<span class="hljs-built_in">print</span>(dt_arr)
</code></pre>
<h4 data-id="heading-8">2.4 数组元素的索引</h4>
<h5 data-id="heading-9">2.4.1 一维数组的索引</h5>
<p>一维数组的索引方式跟python中的列表元素的索引方式是相同的，都是通过0开始的数字来进行索引，也支持倒序-1开始的索引。</p>
<h5 data-id="heading-10">2.4.2 多维数组的索引</h5>
<ul>
<li>二维数组的索引操作</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd</span> = np.random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, size=(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))
输出内容：
array(<span class="hljs-section">[[47,  9, 51, 16,  9, 18]</span>,
       <span class="hljs-section">[23, 74, 58, 91, 63, 84]</span>,
       <span class="hljs-section">[97, 44, 33, 27,  9, 77]</span>,
       <span class="hljs-section">[11, 41, 35, 61, 10, 71]</span>,
       <span class="hljs-section">[87, 71, 20, 57, 83,  2]]</span>)
nd<span class="hljs-section">[0, 1:]</span>  <span class="hljs-comment"># 第1行第2个到最后一个数</span>
输出内容：
array(<span class="hljs-section">[ 9, 51, 16,  9, 18]</span>)
nd<span class="hljs-section">[:, 0]</span>  <span class="hljs-comment"># 所有行的第一个数字</span>
输出内容：
array(<span class="hljs-section">[47, 23, 97, 11, 87]</span>)
nd<span class="hljs-section">[1:4, 1:5]</span>  <span class="hljs-comment"># 第2到4行，第2到5列的数字</span>
输出内容：
array(<span class="hljs-section">[[74, 58, 91, 63]</span>,
       <span class="hljs-section">[44, 33, 27,  9]</span>,
       <span class="hljs-section">[41, 35, 61, 10]]</span>)
nd<span class="hljs-section">[::2, ::-1]</span>  <span class="hljs-comment"># 隔一行取，并且每行的数字反序输出</span>
输出内容：
array(<span class="hljs-section">[[18,  9, 16, 51,  9, 47]</span>,
       <span class="hljs-section">[77,  9, 27, 33, 44, 97]</span>,
       <span class="hljs-section">[ 2, 83, 57, 20, 71, 87]]</span>)
nd<span class="hljs-section">[2:, (1,4,5)]</span>   <span class="hljs-comment"># 指定选择某几列的数字</span>
输出内容：
array(<span class="hljs-section">[[44,  9, 77]</span>,
       <span class="hljs-section">[41, 10, 71]</span>,
       <span class="hljs-section">[71, 83,  2]]</span>)
nd<span class="hljs-section">[(1,3,4), 2:]</span>  <span class="hljs-comment"># 指定选择某几行的数字</span>
输出内容：
array(<span class="hljs-section">[[58, 91, 63, 84]</span>,
       <span class="hljs-section">[35, 61, 10, 71]</span>,
       <span class="hljs-section">[20, 57, 83,  2]]</span>)
<span class="hljs-comment"># 单条件筛选，筛选出所有大于50的数字</span>
print(nd<span class="hljs-section">[nd&gt;50]</span>)
<span class="hljs-comment"># 多条件筛选，筛选出所有大于50但小于70的数字</span>
print(nd<span class="hljs-section">[(nd&gt;50) &amp; (nd&lt;70)]</span>)
<span class="hljs-comment"># 多条件筛选，筛选出小于10或者是大于90的</span>
print(nd<span class="hljs-section">[(nd&lt;10) | (nd&gt;90)]</span>)
nd<span class="hljs-section">[(1,2,3,4), (1,2,4,3)]</span>  <span class="hljs-comment"># 花式索引。规则，要取的每个元素的行和列索引，分别组成行的索引数组和列的索引数组。</span>
输出内容：
array(<span class="hljs-section">[74, 33, 10, 57]</span>)
</code></pre>
<p>注意，花式索引的用法如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/810dfd3a429245c3871361d5819191fa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlsI_kupE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965899&amp;x-signature=XCh1kZuJyhnnqebgaPRlkzD0k%2BA%3D" alt="2.png" loading="lazy"/></p>
<ul>
<li>三维数组的索引操作</li>
</ul>

<pre><code class="hljs language-lua" lang="lua">nd = np.arange(<span class="hljs-number">18</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)  # 生成一个三维数组
输出内容：
array(<span class="hljs-string">[[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8]]</span>,
       <span class="hljs-string">[[ 9, 10, 11],
        [12, 13, 14],
        [15, 16, 17]]</span>])
# 取三维数组每组的第一行数据。
# 参数包含<span class="hljs-number">3</span>个部分
# 第一个参数指定要取哪些组
# 第二个参数指定要取第几行
# 第三个参数指定要取哪几列的值
nd[:, <span class="hljs-number">0</span>, :]
输出内容：
array(<span class="hljs-string">[[ 0,  1,  2],
       [ 9, 10, 11]]</span>)
nd[:, :, <span class="hljs-number">0</span>]   # 取所有行的第一列的值
输出内容：
array(<span class="hljs-string">[[ 0,  3,  6],
       [ 9, 12, 15]]</span>)
nd[:, ::<span class="hljs-number">2</span>, ::<span class="hljs-number">2</span>]   # 隔一行隔一列取值
输出内容：
array(<span class="hljs-string">[[[ 0,  2],
        [ 6,  8]]</span>,
       <span class="hljs-string">[[ 9, 11],
        [15, 17]]</span>])
</code></pre>
<h4 data-id="heading-11">2.5 变换数组形态</h4>
<p>数组的形态变换主要涉及到重塑、展平、堆叠、拼接和分割。</p>
<h5 data-id="heading-12">2.5.1 重塑reshape（重点）</h5>
<p>使用reshape可以将一个数组转化为一个任意形状的数组。注意，转换时必须使元素能够对齐。</p>
<pre><code class="hljs language-lua" lang="lua">nd = np.arange(<span class="hljs-number">18</span>)   # 生成一个<span class="hljs-number">18</span>个元素的一维数组
nd.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)  # 将一维变成二维
输出结果：
array(<span class="hljs-string">[[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17]]</span>)
nd.reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)    # 元素个数能对齐可以生成
输出结果：
array(<span class="hljs-string">[[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8]]</span>,
       <span class="hljs-string">[[ 9, 10, 11],
        [12, 13, 14],
        [15, 16, 17]]</span>])
nd.reshape(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)   # 维度相乘和总的数值个数不符，元素无法对齐
输出结果：
<span class="hljs-comment">---------------------------------------------------------------------------</span>
ValueError Traceback (most recent call last)
~\AppData\Local\Temp\ipykernel_26616\<span class="hljs-number">1265043701.</span>py <span class="hljs-keyword">in</span> &lt;<span class="hljs-built_in">module</span>&gt;
<span class="hljs-comment">----&gt; 1 nd.reshape(2,4,3)</span>
ValueError: cannot reshape array of size <span class="hljs-number">18</span> into shape (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)
nd.reshape(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>)    # 从三维降到二维
输出结果：
array(<span class="hljs-string">[[ 0,  1,  2,  3,  4,  5,  6,  7,  8],
       [ 9, 10, 11, 12, 13, 14, 15, 16, 17]]</span>)
nd.reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)   # 任一维度设置成<span class="hljs-number">-1</span>表示该维度自动计算
输出结果：
array(<span class="hljs-string">[[[ 0,  1,  2],
        [ 3,  4,  5]]</span>,
       <span class="hljs-string">[[ 6,  7,  8],
        [ 9, 10, 11]]</span>,
       <span class="hljs-string">[[12, 13, 14],
        [15, 16, 17]]</span>])
注意，一次只能有一个维度的值设置为<span class="hljs-number">-1</span>让numpy自行计算。
</code></pre>
<h5 data-id="heading-13">2.5.2 展平flatten（重点）</h5>
<p>展平操作就是将多维数组变成一维的数组，俗称降维操作。</p>
<pre><code class="hljs language-ini" lang="ini">nd.flatten()    <span class="hljs-comment"># 横向展平，将多维降为一维</span>
输出内容：
array(<span class="hljs-section">[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
       17]</span>)
nd.flatten(<span class="hljs-attr">order</span>=<span class="hljs-string">'F'</span>)   <span class="hljs-comment"># 按列方向进行拼接展平</span>
输出内容：
array(<span class="hljs-section">[ 0,  6, 12,  1,  7, 13,  2,  8, 14,  3,  9, 15,  4, 10, 16,  5, 11,
       17]</span>)
</code></pre>
<h5 data-id="heading-14">2.5.6 拼接concatenate（重点）</h5>
<p>concatenate和stack非常类似，都是用于把多个数组进行拼接。唯一区别是concatenate是使用参数来控制拼接方向。</p>
<pre><code class="hljs language-ini" lang="ini">np.concatenate(<span class="hljs-section">[nd1, nd2]</span>, <span class="hljs-attr">axis</span>=<span class="hljs-number">0</span>)    <span class="hljs-comment"># 0轴是竖直方向进行拼接，必须保证两个数组的列数一致</span>
np.concatenate(<span class="hljs-section">[nd1, nd2]</span>, <span class="hljs-attr">axis</span>=<span class="hljs-number">1</span>)    <span class="hljs-comment"># 1轴是水平方向进行拼接，必须保证两个数组的行数一致</span>
</code></pre>
<h4 data-id="heading-15">2.6 数组的运算</h4>
<p>数组运算又叫通用函数运算，是指numpy的数组中的每个值都参与运算。这里面又分为数组与值之间的运算和数组与数组之间的运算两种情况。</p>
<p>通用函数运算会使用到numpy的广播机制，所谓广播机制是指当我们使用通用函数对两个数组进行计算时，通用函数会对这两个数组的对应元素进行运算，因此它要求这两个数组shape相同。如果形状不同时不一定能进行运算，要看情况。</p>
<p>一、数组与单个值之间的运算</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd1</span> = np.arange(<span class="hljs-number">18</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)
nd1 * 3    <span class="hljs-comment"># 直接将nd1中的每个元素乘以3</span>
</code></pre>
<p>二、数组与数组之间的运算</p>
<ul>
<li>数组形状一致</li>
</ul>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">nd1</span> = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
<span class="hljs-attr">nd2</span> = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
nd1 * nd2     <span class="hljs-comment"># 两个数组形状一致，则会将每个数组对应位置的数字进行运算</span>
输出结果：
array(<span class="hljs-section">[[  0,   1,   4,   9]</span>,
       <span class="hljs-section">[ 16,  25,  36,  49]</span>,
       <span class="hljs-section">[ 64,  81, 100, 121]]</span>)
</code></pre>
<p>数组形状一致，可以利用广播机制对对应位置的数字进行运算。</p>
<ul>
<li>数组形状不同</li>
</ul>
<p>当两个NumPy数组的维度不同时，这两个Numpy数组不一定能够进行运算，是否能够运算取决于Numpy的广播机制。广播机制规则如下：</p>
<ol>
<li>如果两个数组的维数不同，则向较少维度的数组添加一个”1″以匹配两个数组的形状</li>
<li>如果两个数组在某个维度上的大小不同，但至少有一个数组的该维度大小为 1，则使用带有大小 1 的该维度的数组进行操作，以匹配另一个数组的形状；</li>
<li>如果两个数组在某个维度上的大小不同且都不为 1，则无法进行广播。对于不同形状的数组，通常需要通过重塑数组来进行匹配。</li>
</ol>

<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># 广播规则一，维数不同，reshape较少维度数组以适配两个数组的形状</span>
import numpy as np
<span class="hljs-attr">a</span> = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment"># 形状为一维 (3,)，会自动reshape到(1, 3),相当于执行了a.reshape(1,3)</span>
<span class="hljs-attr">b</span> = np.array([[<span class="hljs-number">4</span>], [<span class="hljs-number">5</span>], [<span class="hljs-number">6</span>]])  <span class="hljs-comment"># 形状为 (3, 1),注意，必须有一个维度的值为1，否则无法计算</span>
<span class="hljs-comment"># 可以进行广播计算</span>
<span class="hljs-attr">result</span> = a + b
print(result)
<span class="hljs-comment"># 广播规则二，维数相同，但两个数组在某个维度上的大小不同，且至少有一个数组的该维度大小为 1</span>
import numpy as np
<span class="hljs-attr">a</span> = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])  <span class="hljs-comment"># 形状为 (2, 3)</span>
<span class="hljs-attr">b</span> = np.array([[<span class="hljs-number">10</span>], [<span class="hljs-number">11</span>]])  <span class="hljs-comment"># 形状为 (2, 1)</span>
<span class="hljs-comment"># 可以进行广播计算</span>
<span class="hljs-attr">result</span> = a + b
print(result)
<span class="hljs-comment"># 广播规则三，如果两个数组在某个维度上的大小不同且都不为 1，则无法进行广播</span>
import numpy as np
<span class="hljs-attr">a</span> = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])  <span class="hljs-comment"># 形状为 (2, 3)</span>
<span class="hljs-attr">b</span> = np.array([[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])  <span class="hljs-comment"># 形状为 (2, 2)</span>
<span class="hljs-comment"># 无法进行广播计算</span>
<span class="hljs-attr">result</span> = a + b
print(result)
</code></pre>
<p>如果是多维数组之间进行运算，应尽量保证形状相同，否则因为numpy去调整数组的形状后，很容易产生计算错误。</p>
<h3 data-id="heading-16">三、矩阵运算</h3>
<p>矩阵乘法规则：矩阵A的列数必须等于矩阵B的行数，才能相乘。 A(M行，N列) * B(N行，P列) = C(M行，P列)， 且，A中行号i与B中列号j相同时相乘，再求和即可。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/87ff0f079c014db9b3075fb5b1f6d9f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlsI_kupE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965899&amp;x-signature=vwrdD7%2BH%2BW5LtS2vMf1E%2BFdNlY8%3D" alt="3.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab867d79859f4f0ab6e46135368bfe16~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlsI_kupE=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763965899&amp;x-signature=DbxtHMpmS2RxrAbxlEzAG2v493o%3D" alt="4.png" loading="lazy"/></p>
<p>结果矩阵中，9的来源为：<code>1*3+3*2=9</code>，19的来源为：<code>5*3+2*2=19</code>，12的来源为：<code>0*4+4*3=12</code></p>
<pre><code class="hljs language-css" lang="css"># 定义数组<span class="hljs-selector-tag">A</span>为<span class="hljs-number">3</span>行<span class="hljs-number">4</span>列
<span class="hljs-selector-tag">A</span> = np<span class="hljs-selector-class">.array</span>(<span class="hljs-selector-attr">[[11,12,13,14]</span>,<span class="hljs-selector-attr">[21,22,23,24]</span>,<span class="hljs-selector-attr">[31,32,33,34]</span>])
# 定义数组<span class="hljs-selector-tag">B</span>为<span class="hljs-number">4</span>行<span class="hljs-number">2</span>列
<span class="hljs-selector-tag">B</span> = np<span class="hljs-selector-class">.array</span>(<span class="hljs-selector-attr">[[41,42]</span>, <span class="hljs-selector-attr">[51,52]</span>, <span class="hljs-selector-attr">[61,62]</span>, <span class="hljs-selector-attr">[71, 72]</span>])
# 则最终矩阵乘法的结果为<span class="hljs-number">3</span>行<span class="hljs-number">2</span>列
print(np<span class="hljs-selector-class">.dot</span>(<span class="hljs-selector-tag">A</span>, <span class="hljs-selector-tag">B</span>))
# 输出结果为：
'''
<span class="hljs-selector-attr">[[2850 2900]</span>
 <span class="hljs-selector-attr">[5090 5180]</span>
 <span class="hljs-selector-attr">[7330 7460]</span>]
'''
</code></pre>
<p>其实明白了运算规则，即使使用最原始的Python也一样可以快速搞定</p>
<pre><code class="hljs language-less" lang="less"># <span class="hljs-selector-tag">A</span>中的每一行与<span class="hljs-selector-tag">B</span>中的第一列相乘，得到结果<span class="hljs-selector-tag">C</span>中的第一列，<span class="hljs-selector-tag">A</span>中的每一行与<span class="hljs-selector-tag">B</span>中的第二列相乘，得到结果<span class="hljs-selector-tag">C</span>中的第二列
<span class="hljs-selector-tag">listA</span> = <span class="hljs-selector-attr">[[11,12,13,14]</span>,
         <span class="hljs-selector-attr">[21,22,23,24]</span>,
         <span class="hljs-selector-attr">[31,32,33,34]</span>]
<span class="hljs-selector-tag">listB</span> = <span class="hljs-selector-attr">[[41,42]</span>,
         <span class="hljs-selector-attr">[51,52]</span>,
         <span class="hljs-selector-attr">[61,62]</span>,
         <span class="hljs-selector-attr">[71, 72]</span>]
<span class="hljs-selector-tag">listC</span> = <span class="hljs-selector-attr">[[0,0]</span>,<span class="hljs-selector-attr">[0,0]</span>,<span class="hljs-selector-attr">[0,0]</span>]  # 初始化为<span class="hljs-number">3</span>行<span class="hljs-number">2</span>列的列表
# 循环<span class="hljs-selector-tag">B</span>的列数
<span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(listB[<span class="hljs-number">0</span>])):
    # 循环<span class="hljs-selector-tag">A</span>的行数
    <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(listA)):
        <span class="hljs-selector-tag">sum</span> = <span class="hljs-number">0</span>
        # 循环<span class="hljs-selector-tag">A</span>的列数，由<span class="hljs-selector-tag">A</span>的行和列取得每个数，并与<span class="hljs-selector-tag">B</span>的列相乘再求和
        <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">ai</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(listA[a])):
            <span class="hljs-selector-tag">sum</span> += (listA[a][ai] * listB[ai][b])
        <span class="hljs-selector-tag">listC</span><span class="hljs-selector-attr">[a]</span><span class="hljs-selector-attr">[b]</span> = <span class="hljs-selector-tag">sum</span>
<span class="hljs-selector-tag">print</span>(listC)
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[[python探本] 内存数据存储机制]]></title>    <link>https://juejin.cn/post/7573310642959613990</link>    <guid>https://juejin.cn/post/7573310642959613990</guid>    <pubDate>2025-11-17T07:35:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573310642959613990" data-draft-id="7573002274324660270" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="[python探本] 内存数据存储机制"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2025-11-17T07:35:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="rimoyee"/> <meta itemprop="url" content="https://juejin.cn/user/564483199874953"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            [python探本] 内存数据存储机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/564483199874953/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    rimoyee
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T07:35:28.000Z" title="Mon Nov 17 2025 07:35:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎙️ 前言</h2>
<p>python是一门迷惑性很强的编程语言。</p>
<p>在刚开始接触的时候, 大学期间让人头疼的编程语言突然从面目狰狞的C变成了python。直接无痛入门。</p>
<p>从头到尾敲完一本《python编程-从入门到实践》, 总觉着自己牛逼坏了, 这不全都掌握了, 小小python一举拿下。</p>
<p>后面再去接触爬虫, 一整个大傻眼。这都啥? 大脑一片空白。😣</p>
<p>再回头重新反思自己的学习道路, 发现很大的缺陷就在于一直都是按照书本上或者是视频上的案例在誊抄代码, 并没有形成自己的编程思维; 以及底层的数据结构仍然是不了解状态。尤其是当ai工具出现之后, 本身就站立不住的腿多了这条拐杖, 更是拿走后一步都走不远。</p>
<p>已经拿到了python这把利器, 却无法充分发挥它的效用, 通过自己的尝试去落地有趣好玩的项目, 实在是件蛮遗憾的事情。</p>
<p>抛弃掉自己的自负, 踏踏实实回头重新梳理基础。不仅仅是被动接收, 而是理解为什么要这么设计? 需求可以用这种方式实现, 换种方式可不可以? 更新的版本中有没有提供更好用的模块, 从而避免自己重复造轮子?</p>
<p>为此我重新梳理了自己的学习笔记, 希望不仅仅是对我, 还是对像我一样仍然困在半路的苦行者, 能有一点点帮助。</p>
<h2 data-id="heading-1">🗂️ 存储管理系统</h2>
<p>程序中直接使用的数据保存在计算机的内存储器(简称<strong>内存</strong>)中, 内存可以<strong>通过CPU直接访问</strong>。暂时不使用的数据存储在外存储器(磁盘、光盘等, 简称<strong>外存</strong>)中, 如果想要读取外存中的数据, 需要先装入内存, 然后CPU才能正常使用。</p>
<p>内存存储的结构是线性的, 每个单元的大小相同, 可以保存一个单位大小的数据。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35180c7a39df429095b6683261acd303~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=UCC04F7OpGj%2FAH2Ba82JfJFkQEk%3D" alt="image-20251114105523498.png" loading="lazy"/></p>
<p>为了方便访问, <strong>每个存储单元都有一个地址(数据标识)</strong>, 在程序执行时, 直接找到地址就可以读取存储的数据内容。
同时, 程序在运行时会处理各种各样的数据, 如果数据存储在相邻的一块或者几块区域, 访问就会很方便。
内存中的存储单元是有限的, 所以要做到合理的分配和利用。</p>
<p>python提供<strong>存储管理系统</strong>来负责数据的存储和管理工作, 不需要像C和C++一样, 手动分配和回收内存, 大大提升了编写代码的便捷性。</p>
<p>同时python作为<strong>面向对象</strong>的语言, <strong>将数据和操作数据的方法都封装在对象中, 通过和对象的交互来完成任务</strong>。
在程序运行的过程中, 不断建立对象并使用它们, 创建的每个对象都有一个确定的唯一标识(即地址), 用于识别和使用这个对象。在一个对象的存续期间, 地址是保持不变的。</p>
<p>如何去查看对象在程序运行时的地址标识?</p>
<p>通过内置函数<code>id()</code></p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(a)))  <span class="hljs-comment"># 通过hex()将地址转化为十六进制, 方便观看</span>
<span class="hljs-comment"># 0x7ffb06ab4ad8  </span>
</code></pre>
<p>同时可以也通过<code>is</code>和<code>is not</code>关键字来判断是否是同一个对象, 这种方法就是通过对比地址来判断的</p>
<pre><code class="hljs language-python" lang="python">a = <span class="hljs-number">10</span>
b = <span class="hljs-number">10</span>
c = <span class="hljs-number">20</span>
<span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)  <span class="hljs-comment"># True</span>
<span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> c)  <span class="hljs-comment"># False</span>
<span class="hljs-built_in">print</span>(b <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> c)  <span class="hljs-comment"># True</span>
</code></pre>
<p>上面的代码有个很有意思的现象, 会发现定义的变量a和变量b是一个对象, 即内存中存储的地址是一个。</p>
<p>为什么会这样?</p>
<p>这就涉及到了内存中数据的存储方式。内存中, 包含有三个区域: <strong>代码区、栈区和堆区</strong>。</p>
<p>(1) <strong>代码区</strong>: 存储编写的代码</p>
<p>(2) <strong>栈区</strong>: 存储变量名和地址, 以及函数调用相关信息, 遵循LIFO(先进后出)原则, 存储小型、临时数据</p>
<p>(3) <strong>堆区</strong>: 存储真正的变量数据, 无序存储, 生命周期较长, 存储复杂或大型数据</p>
<p>下面先通过栈与堆的存储机制来了解这三个区域都是如何工作的。</p>
<h2 data-id="heading-2">🛒 栈与堆的存储</h2>
<p>上面我们提到, 内存中存储了大量的数据和操作方法, 均封装在对象中, 可以称之为<strong>数据对象</strong>。这些数据对象被存储在容器中, 容器支持对这些数据存储、管理和使用。</p>
<p><strong>栈和队列都是保存数据元素的容器</strong>, 是计算中最广泛的<strong>缓存结构</strong>。主要用于在计算过程中保存临时数据, 这些数据都是在计算中发现或者产生的, 在后面的计算中可能使用它们。</p>
<p>在栈区主要使用栈来操作数据, 下面先来介绍一下栈的机制。</p>
<h3 data-id="heading-3">🤔 栈是什么?</h3>
<p>栈是限制在一端进行插入操作和删除操作的线性表, 允许进行操作的一端称为"栈顶", 另一固定端称为"栈底", 当栈中没有元素时称为"空栈"。栈内元素遵循LIFO(先进后出)的原则。</p>
<p>栈的机制如下图所示:  <code>s1 = (a1,a2,...,an)</code></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3e056b484fca4a76ac5364231245c18b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=kjWHHfwINQrDTrAho%2FO2ZHFICu8%3D" alt="image-20251114150244267.png" loading="lazy"/></p>
<p>栈的抽象数据类型(预定义的操作):</p>
<ul>
<li>栈的创建 (创建一个空栈)</li>
<li>判断栈是否为空</li>
<li>将元素压入栈中 (也称进栈或入栈)</li>
<li>从栈中弹出元素并将其返回 (也称退栈或出栈)</li>
<li>检查栈元素 (访问最后入栈元素)</li>
</ul>
<p><strong>python中的栈机制</strong></p>
<p>三个区域的存储情况如下图所示</p>
<p><strong>栈区中存储的是对象的引用(指针)</strong>,也就是说存储的并不是数据, 真正的数据存储在堆区中。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e420e7d5ea9410e83eedc08417f3660~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=yW4ccDoyGnE00iM%2FheWFrUyQbh4%3D" alt="image-20251114164920222.png" loading="lazy"/></p>
<h3 data-id="heading-4">🤔 堆是什么?</h3>
<p>上面说到, 栈本质上是一种线性表, 而python中的 "堆", 并不是一种固定的数据结构, 而是解释器向操作系统申请的动态内存区域, 由python的内存管理器在这个区域内进行灵活分配。</p>
<p>在区域的内部, python使用<strong>pymalloc分配器</strong>进行管理。</p>
<p>下面是堆区总体结构图:</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ed6169f5d8e44cbebcb03ca87fb5a519~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=%2B2eXtnZ0%2BKrmhLfypUtwSQ3fgc8%3D" alt="image-20251114153418482.png" loading="lazy"/></p>
<h2 data-id="heading-5">🗑️ 垃圾回收机制</h2>
<p>内存空间是有限的, 既然有存储, 就必然有回收。</p>
<p>python使用<strong>引用计数</strong>作为主要机制, 辅以<strong>标记-清除</strong>和<strong>分代回收</strong>来处理循环应用问题。</p>
<p><strong>引用计数</strong></p>
<p>如下图所示, 在堆区中, 每个对象都包含一个引用计数, 用于统计当前对象被引用的次数。当引用计数为0时, 该对象被垃圾回收机制回收。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/43ba327faa8c4834b8626cb7430c4ee8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=5sUvCz%2B%2BtpjRJPouAsLB21iNRY4%3D" alt="image-20251117112540368.png" loading="lazy"/></p>
<p>可以通过<code>sys.getrefcount()</code>方法来查看引用计数的数量</p>
<p>📍 Note: 需要在python交互式解释器下执行, 在其他环境下, 会做优化处理, 导致结果不符</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">532</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>y = x
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.getrefcount(x)
<span class="hljs-number">3</span>
</code></pre>
<p><strong>🎃 一个有趣的尝试</strong></p>
<p>定义变量a和b, 并存储到变量c中, 查看各个变量的引用计数</p>
<pre><code class="hljs language-ini" lang="ini">&gt;&gt;&gt; <span class="hljs-attr">a</span> = <span class="hljs-number">10</span>
&gt;&gt;&gt; <span class="hljs-attr">b</span> = <span class="hljs-number">20</span>
&gt;&gt;&gt; <span class="hljs-attr">c</span> = [a,b]
&gt;&gt;&gt; sys.getrefcount(a)
4294967295
&gt;&gt;&gt; sys.getrefcount(b)
4294967295
&gt;&gt;&gt; sys.getrefcount(c)
2
</code></pre>
<p>在上面的代码中, 会发现a和b的计数数值尤其大。按道理来说不应该a和b的应用计数都是1吗?</p>
<p>🔍 原因分析</p>
<p>小整数对象(通常在-5~256)会被缓存和复用, 这些缓存对象的应用计数机制被优化掉了, 当<code>sys.getrefcount()</code>检测到这种情况时, 会返回一个特殊值。</p>
<p>在堆区总体结构图中, 可以看到在对象池/缓存池中, 有小整数池。常用的小整数对象存储在这里, 避免频繁创建和销毁, 减少了内存分配的开销。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d760f70b7404bfb90b06a3924a2b1aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=kJQfnoj23eBM9jgQDT4tdPic7OA%3D" alt="image-20251116101843128.png" loading="lazy"/></p>
<h2 data-id="heading-6">🔎 相同对象判断 <code>==</code> 与 <code>is</code></h2>
<p>在 <em>⌈存储管理系统⌋</em> 的章节中, 我们了解到可以使用<code>is</code>关键字来判断是否是同一个对象。</p>
<p>同时, 我们也可以通过<code>==</code>运算符来判断两者的值是否相同, 那么在使用的时候, 这两者有什么需要注意的吗?</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 定义三个变量, 这三个变量的值是一样的</span>
s1 = <span class="hljs-string">"helloworld"</span>
s2 = <span class="hljs-string">"hello"</span> + <span class="hljs-string">"world"</span>
s3 = <span class="hljs-string">""</span>.join([<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>])

<span class="hljs-built_in">print</span>(s1, s2, s3)  <span class="hljs-comment"># helloworld</span>

<span class="hljs-comment"># 看一下这些对象的地址</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(s1)))  <span class="hljs-comment"># 0x2f489ed91f0</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(s2)))  <span class="hljs-comment"># 0x2f489ed91f0</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">id</span>(s3)))  <span class="hljs-comment"># 0x2f489fa3570</span>
</code></pre>
<p>查看地址后发现, <code>s1</code>和<code>s2</code>的地址是一样的, 但是<code>s3</code>的地址却不同。</p>
<p>我们分别使用<code>==</code>和<code>is</code>来判断这些变量</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">print</span>(s1 == s2)  <span class="hljs-comment"># True</span>
<span class="hljs-built_in">print</span>(s1 == s3)  <span class="hljs-comment"># True</span>

<span class="hljs-built_in">print</span>(s1 <span class="hljs-keyword">is</span> s2)  <span class="hljs-comment"># True</span>
<span class="hljs-built_in">print</span>(s1 <span class="hljs-keyword">is</span> s3)  <span class="hljs-comment"># False</span>
</code></pre>
<p>🙋‍ 通过上面的案例, 我产生了下面的疑问:</p>
<p>❓ 问题1: 为什么<code>s3</code>和<code>s1</code>与<code>s2</code>的地址不同?</p>
<p>❓ 问题2: <code>==</code>和<code>is</code>的底层判断机制是怎样的? 为什么会有不一样的返回结果?</p>
<h3 data-id="heading-7">💡 <strong>字符串驻留机制</strong></h3>
<p>python的一种优化技术, 它保存不可变对象(如字符串)的唯一副本, 当需要时, 让多个应用指向这个副本, 以节省内存。</p>
<p>但并不是所有的字符串都会被驻留, 字符串的创建方式会影响它们是否被驻留(<code>Interned</code>)。</p>
<p>自动驻留的规则:</p>
<ul>
<li>编译时常量: 在代码编译时就能确定的字符串字面量</li>
<li>短字符串: 通常只包含字母、数字、下划线的短字符串</li>
<li>标识符: 变量名、函数名等</li>
</ul>
<p>🙋‍ 如果在定义字符串变量的时候加入空格会怎么样?</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">&gt;&gt;&gt; </span>s1 = <span class="hljs-string">"hello world"</span>  
<span class="hljs-meta">&gt;&gt;&gt; </span>s2 = <span class="hljs-string">"hello"</span> + <span class="hljs-string">" "</span> + <span class="hljs-string">"world"</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s1 <span class="hljs-keyword">is</span> s2
<span class="hljs-literal">False</span>
</code></pre>
<p>在python交互式解释器中查看, 可以看到因为包含有空格, 定义的对象并没有被驻留, 所以<code>s1</code>和<code>s2</code>并不是同一个对象。</p>
<p>⬆️ 解答问题1</p>
<p>了解上面的知识点之后, 再去分析上面的代码</p>
<p>(1) <code>s1</code>是一个字符串字面量, 在编译时被创建, 会被驻留</p>
<p>(2) <code>s2</code>作为表达式, 在编译时会被优化成字符串字面量, 因此和<code>s1</code>是同一个对象</p>
<p>(3) <code>s3</code>是在运行时通过<code>join</code>方法动态创建的字符串, 无法在编译时确定结果, 因此并不会被驻留优化, 是一个新的字符串对象</p>
<p>通过上面的分析, 我们就了解了为什么会有值相同但地址不同的现象。</p>
<p>⬆️ 解答问题2</p>
<p>调用<code>==</code>来比对两个变量的值时, 调用对象的<code>__eq__()</code>方法(继承自<code>object</code>), 如下图所示</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/195c450a35414b198bb683dd2915a5d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgcmltb3llZQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763969728&amp;x-signature=3XHh0dbrrAsd2NM7U28iA81cSyI%3D" alt="image-20251117110420927.png" loading="lazy"/></p>
<p>而上面的案例中, 两个变量的类型是字符串, <code>str()</code>方法会重写继承的<code>__eq__()</code>方法, 使得判断的时候比较的是两者的值, 而不是地址。</p>
<p>而调用<code>is</code>比较两个变量时, 比较的就是两者的地址是否相同。</p>
<p>📍 Tips: 内存中存储的常量, 如<code>True</code>, <code>False</code>, <code>None</code>, 判断的时候直接使用<code>is</code>关键字, 不要用<code>==</code>。因为这些常量在内存中的存储地址只有一个, 通过<code>is</code>去判断地址即可。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[实时光线追踪加速硬件结构（详细版）]]></title>    <link>https://juejin.cn/post/7573225720697536564</link>    <guid>https://juejin.cn/post/7573225720697536564</guid>    <pubDate>2025-11-17T06:47:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720697536564" data-draft-id="7490815158190571546" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="实时光线追踪加速硬件结构（详细版）"/> <meta itemprop="keywords" content="游戏,GPU,计算机图形学"/> <meta itemprop="datePublished" content="2025-11-17T06:47:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="像素之境"/> <meta itemprop="url" content="https://juejin.cn/user/721729778626808"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            实时光线追踪加速硬件结构（详细版）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/721729778626808/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    像素之境
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:47:42.000Z" title="Mon Nov 17 2025 06:47:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读20分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="atom-one-dark-reasonable">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-keyword,.hljs-operator,.hljs-pattern-match{color:#f92672}.hljs-function,.hljs-pattern-match .hljs-constructor{color:#61aeee}.hljs-function .hljs-params{color:#a6e22e}.hljs-function .hljs-params .hljs-typing{color:#fd971f}.hljs-module-access .hljs-module{color:#7e57c2}.hljs-constructor{color:#e2b93d}.hljs-constructor .hljs-string{color:#9ccc65}.hljs-comment,.hljs-quote{color:#b18eb1;font-style:italic}.hljs-doctag,.hljs-formula{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>近几年一些大型游戏开始支持<strong>光线追踪渲染</strong>，在设置中开启光追后，画质能有明显的提升。但要实现这种<strong>实时的光追渲染</strong>并不简单，其不仅需要游戏中编写了相关的<strong>算法及程序</strong>，更需要你的<strong>电脑硬件</strong>支持。</p>
<p>但光追算法特殊，且计算量大，普通GPU是无法达成实时渲染要求的，目前各处理器厂商都是搭配专门的<strong>实时光线追踪加速硬件</strong>进行支持，比如<code>NVIDIA</code>的<code>RT Cores</code>，<code>AMD</code>的<code>Ray Accelerator</code>等等。</p>
<p>这篇文章我们主要理清<strong>实时光追加速硬件的大致结构和其实现原理</strong>，会偏向于广度，略过一些详细部分。因为光线追踪加速硬件是对光线追踪算法的实现，所以下面先对<strong>光线追踪算法</strong>做一些提及，再梳理<strong>硬件</strong>的知识。</p>
<h2 data-id="heading-0">1 光线追踪技术</h2>
<p>光线追踪是一种模拟现实世界，光线在场景中多次<strong>反射、折射</strong>的一个过程。所以光追算法里，物体所受光照除了主要来自光源直接照射外，还来自其它间接的光线。若能考虑到<strong>足够数量的间接光线</strong>，就可以得到更真实的渲染效果。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/27488e23cfe5463b9e8e3d9959e3001d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=PSNL4PPWD4sKarqDVddiWtfQ5Io%3D" alt="rays.png" loading="lazy"/></p>
<p>光线追踪属于全局光照技术的一种，起初较为完善的是“基于Whitted”风格的光线追踪，后续学者们在其基础上改善，衍生出许多其它算法，如：光子映射、梅特波利斯光照传输、双向路径追踪等。它们核心的步骤如下：</p>
<ol>
<li><strong>构建场景树</strong>：将场景按空间、物体（三角形组成）划分为一颗<strong>树形数据</strong>保存，方便第2步使用。</li>
<li><strong>光线求交</strong>：光线从光源出发，在<strong>场景树</strong>中查找，判断是与哪一个物体相交，计算具体的交点。</li>
<li><strong>光照效果计算</strong>：在相交点处要计算光线的辐射强度、亮度，进行微面元模拟、菲涅尔效果等等，记录这条光线光照效果。</li>
<li><strong>生成次级光线</strong>：交点处要根据物体材质产生<strong>次级光线</strong>（反射、折射、阴影光线），光线能量衰减到阈值，或者进入摄像机后结束。</li>
<li><strong>着色计算</strong>：每条光线都重复2,3,4步骤，直到所有的光线在场景中完成传播和计算。每个点的着色由其上方半空间内所有光线积分得到。</li>
</ol>
<p><strong>耗时的部分</strong>：</p>
<ul>
<li>光线与基元的求交：每秒数十亿的光线，数百万的三角形场景，每条光线要计算与哪个三角形相交，这个数量非常庞大。</li>
<li>点的着色：每个光线相交点需要计算辐射度、能量衰减、菲涅尔效果等，最终每个像素点还要对其上半空间的光线进行积分（一条光线包括其从光源多次反射折射）得到最终颜色。这一系列计算非常复杂。</li>
</ul>
<p>以上说的只是大概思想，具体算法会有所变化，再对应到光追硬件又会<strong>有所简化</strong>，具体在提到相关硬件架构时细述。</p>
<h2 data-id="heading-1">2 光线追踪管线</h2>
<p>光线追踪管线是对<strong>光线追踪技术</strong>实现过程的一个<strong>抽象</strong>，总体使用基于Whitted风格的光线追踪。现有的光追硬件多数都按照一个过程实现。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e95ba77713014ab9854e1e05c73240a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=BvYgfyBOCoATis%2FWn%2FfxmeChALQ%3D" alt="ray-tra-pipline.png" loading="lazy"/></p>
<ul>
<li><strong>加速结构构建</strong>：将给定的场景按照空间、<strong>基元</strong>（三角形）划分成一颗树形结构。</li>
<li><strong>主光线生成</strong>：相机向各像素点投射指定数量的光线。</li>
<li><strong>光线遍历</strong>：生成的主光线和次级光线（相交后折射/反射等产生）要在第一步生成的<strong>加速结构</strong>中遍历，判断与哪个叶子空间相交。</li>
<li><strong>光线求交</strong>：遍历得到的叶子空间中可能包含多个基元，要继续计算与哪个基于相交及交点坐标，并产生次级光线。</li>
<li><strong>着色</strong>：每个像素根据当前点材质、纹理、有贡献的光线，进行最终的着色计算。</li>
</ul>
<h2 data-id="heading-2">3 实时光线追踪硬件</h2>
<p>实时光线追踪硬件架构可以按专用性分成两类：</p>
<ul>
<li>一类是<strong>混合架构</strong>，结合CPU，GPU，优化算法、辅以部分硬件等方式实现。更多的可编程性，早期和移动端采用的较多。</li>
<li>另一类是<strong>专用架构</strong>，从一开始就是为光线追踪而设计，功能多用新的硬件直接实现，性能更佳。</li>
</ul>
<p>我们主要讲述的是一个大致结构，所以会提到多种架构的知识。以下是一个偏专用型光追架构的示意图。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0cbd642b80e24be7bde0a06e737bd24c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=%2B5g4oBvHgITIoz6d2QhQWNbsYXU%3D" alt="ray-trace.png" loading="lazy"/></p>
<p><strong>CPU</strong>：应用程序主体仍然在cpu运行，但编译后的着色器代码、场景数据、参数等要经过系统总线发送到光追加速硬件上执行。</p>
<ul>
<li><strong>着色器</strong>：有自定义<strong>光线生成着色器</strong>（初始主光线生成）、<strong>相交着色器</strong>（自定义几何体的相交检测）、命中/未命中等着色器。若光追硬件支持，那么着色器程序在使用硬件厂商提供的编译器<strong>编译</strong>之后发送。</li>
<li><strong>场景三角形</strong>：3d场景由众多三角形构成，需要将其发送到光追硬件用于构建<strong>加速结构</strong>。</li>
<li>其它配置：场景物体上用到的纹理贴图、摄像机位置、光源位置等配置。</li>
</ul>
<p><strong>TBU</strong>：（Tree Building Unit）构建器，根据<code>kd-Tree</code>算法或<code>BVH</code>算法构建一个<strong>树形加速结构</strong>，每一帧都需要根据场景的变化构建或<strong>更新加速结构</strong>，其结果在RTU上使用。</p>
<p><strong>RTU</strong>：（Ray Tracing Unit）光追单元，光线的生成、遍历、相交计算、着色计算在这个单元进行。</p>
<p><strong>External Memory</strong>：一个共享内存，使用的几何数据、加速结构等存储在这里。</p>
<h2 data-id="heading-3">4 TBU详细</h2>
<p>因为场景可能是<strong>动态变化</strong>的，所以每一帧，TBU都要构建出对应场景的<strong>加速结构</strong>，这是实现实时光追的一个重要前提条件。</p>
<p><strong>混合架构</strong>中不含TBU单元，而是利用CPU和一些其它方式实现，具体如下：</p>
<ul>
<li><strong>树的构建</strong>：混合架构中构建加速结构会让CPU实现，因为CPU的<strong>多级缓存</strong>和优秀的<strong>控制流</strong>，这两点适合树的构建过程。</li>
<li><strong>树的更新</strong>：若每帧都让CPU构建再传到光追硬件，这样的方式非常缓慢。还需要配合一个<code>GTU</code>（树更新单元）拟合变化的部分，再配合一些树改造、算法调整等方式达到实时构建的要求。</li>
</ul>
<p>硬件<code>TBU</code>一般有<code>kd-tree</code>或<code>BVH</code>算法实现的两种，这两者只要进行足够调优都能达到相近的性能。它们通常不支持编程，但为了支持<strong>动态更新场景</strong>，<code>TBU</code>会支持三条特殊<strong>指令</strong>：“更新节点”、“处理叶子”和“加载顶点”。CPU只需将变化了的部分几何数据发给TBU即可。</p>
<p>使用TBU硬件来构建加速结构的情况一般比使用CPU/GPU构建的速度快4倍左右。</p>
<h3 data-id="heading-4">4.1 使用SAH+BVH的TBU</h3>
<p>下面先大致介绍一下BVH算法，再叙述相关硬件结构，方便理解。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/839290c8281248749f3dd99659982bd0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=HTpGpky%2BI75jVBvJxZigXXXe%2BQE%3D" alt="BVH-struct.png" loading="lazy"/></p>
<p><strong>BVH</strong>（Bounding Volume Hierarchy）包围体层次结构</p>
<ul>
<li>先对场景空间进行二分，再对分割出的子场景进行二分。</li>
<li>每次分割递归时要为当前子空间中的所有几何体计算一个可以包围它们的<strong>包围盒</strong>（通常使用BBAA包围盒——立方体）。</li>
<li>一直分割到只剩一个或少量几个物体为止。</li>
<li>分割和计算所得包围盒存储在一个树形结构的数据中。</li>
</ul>
<p><strong>SAH</strong>（Surface Area Heuristic）：一种划分方法。进行空间二分时，根据包围盒的表面积和光线与包围盒相交的概率来选择划分点，以最小化求交计算的成本。</p>
<p>构建器整体架构如下图（a）所示：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7ff179f4cfc48da8757aabb766408ac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=jJDYpauN4ve6R6R7owq0ZWnrUHI%3D" alt="sah-bvh.jpg" loading="lazy"/></p>
<p><strong>DRAM</strong>：动态存储器。在构建开始之前，场景图元会被分配到各个DRAM对中。</p>
<p><strong>upper builder(上层构建器)</strong>：直接读写<code>DRAM</code>中的图元数据，负责构建层次结构的上层。</p>
<ul>
<li>该构建器包含划分单元、分箱单元以及一对 SAH计算器（详细参考下面的子树构建器）</li>
<li>上层构建器的工作较少，只有一个线程负责。</li>
</ul>
<p><strong>subtree builder（子树构建器）</strong>：如上右图（b）所示，负责构建上层构建器传来的子树。</p>
<ul>
<li><strong>Buffer(图元缓冲区)</strong>：有一排成对的buffer，每对中的一个Buffer先接收上层构建器划分来的图元，另一个缓冲区则保持为空。</li>
<li><strong>PUnit(分区单元)</strong>：从Buffer读取图元向量，它们的分割点由<code>Bin unit</code>和<code>SAH</code>计算得出，根据结果，分区单元对其Buffer中的图元进行划分，将结果写入另一个Buffer。在下一次递归划分时，两个Buffer的作用互换。</li>
<li><strong>Bin Unit(分箱单元)</strong>：每个<code>PUnit</code>连接到三个<code>Bin Unit</code>——Bin x/y/z它们分别处理图元AABB（包围盒）各轴的中心点，最后输出在三个轴上选择的分箱位置，以及用于计算这些分箱位置的原始图元AABB。</li>
<li><strong>SAH Calc(实现SAH算法的计算器)</strong>：<code>Bin Unit</code>输出的AABB及其选择的分箱位置被输入到SAH计算器中，这些计算器为每个轴上的每个分箱累积一个AABB和一个计数器。一旦所有图元都被累积，SAH计算器就会评估每个可能划分的SAH成本，并输出找到的最低成本划分，将划分信息反馈到<code>PUnit</code>。</li>
<li><strong>Main Control Logic(主控逻辑)</strong>：用于控制子树逻辑的运行、各单元的执行顺序、缓冲区的负载均衡等。</li>
<li><strong>子树的多线程</strong>：上层构建器是一个线程执行，划分到各子树后，每个子树都会生成一个新的线程来执行。一个线程由1个寄存器（存储当前划分图元在buffer中的开始与结束地址），1个划分方案（SAH计算得的划分信息），1个栈（划分图元时辅助操作用）和栈顶指针等组成。</li>
</ul>
<h3 data-id="heading-5">4.2 PLOCTree：另一种实现BVH的TBU</h3>
<p>PLOCTree是一种基于并行局部<strong>有序聚类</strong>（Parallel Locally-Ordered Clustering，PLOC）算法的树构建加速器。PLOC算法从树的底部开始构建，对所有图元的AABB包围盒进行聚类（距离较近的一些图元归为一类，为它们计算1个新的包围盒），逐层使用该方法，最终只有一个包围盒时整颗树构建完成。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a58b5a10ea44428ac10fa8c3dbb2420~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=3hj2mFT%2BStheJu%2BsGHzPfA3Rch8%3D" alt="ploctree-bvh.png" loading="lazy"/></p>
<ul>
<li>从左侧输入所有图元的AABB包围盒。</li>
<li>为每个包围盒的<code>x,y,z</code>坐标生成莫顿码，使用排序器按莫顿码排序（排序上相邻的其空间位置上也相邻）</li>
<li>将这些包围盒分给多个扫描流水线，每个流水线有1个扫描窗口将扫描的包围盒存入窗口缓冲区。</li>
<li>将2R+1个输入到2R个<strong>距离评估器</strong>中（<code>Distance Metric Evaluator DME</code>）。</li>
<li><strong>比较树</strong>（<code>Comparator Tree</code>）接收来自DME组的2R个距离作为输入，并输出具有最低距离的AABB的相对索引</li>
<li><strong>后处理模块</strong>（<code>Postprocessing</code>）从比较树的结果中将最相近的两个AABB合并，用一个新的AABB表示，再次从最左侧输入进行第二轮处理。</li>
</ul>
<h3 data-id="heading-6">4.3 FastTree：一个实现kd-tree算法的TBU</h3>
<p>BVH算法的一个固有问题是：<strong>同一级别的两个节点在空间上可能重叠</strong>（包围盒的重叠），因此在定位到命中之前可能会访问大量节点。kd树算法没有存储包围盒，不存在这个问题，但在处理图元时需要额外的处理步骤。</p>
<p><code>FastTree</code>架构图及功能描述如下：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d489d903e6b24a0987914b5a81553ca2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=oIzM%2FFdl5i2TXk%2BzsAwJ9rUHee8%3D" alt="FasterTree-kdTree.png" loading="lazy"/></p>
<ul>
<li><strong>SBCU(场景边界计算单元)</strong>：从右上角批量输入的图元中计算它们的<code>x, y, z</code>最大最小值更新为边界值。</li>
<li><strong>MCGU(莫顿码生成单元)</strong>：计算输入图元的包围盒，并为每个图元生成莫顿码。</li>
<li><strong>PSU(前缀和单元)</strong>：计算数组的前缀和，配合RSU单元进行排序。</li>
<li><strong>RSU(基数排序单元)</strong>：设计为多轮计数排序，用前缀和计算，依据莫顿码排序。</li>
<li><strong>LNGU(叶节点生成单元)</strong>：获取排序数组中相邻的两个莫顿码码字，相距较近基元的做为一组叶节点，否则单独作为一个叶节点。</li>
<li><strong>INGU(内部节点生成单元)</strong>：输入两个叶子节点的莫顿码，确定1个分割平面，将两个叶子节点划分到不同子空间,结果发送到位编码单元（BEU）。编码结果通过片上缓存写入片外存储器。</li>
<li><strong>PCU(路径压缩单元)</strong>：输入每个节点的莫顿码，查找其父节点，判断父节点是否为必要节点，不是则舍弃，直到找到一个必要节点。</li>
</ul>
<h2 data-id="heading-7">5 RTU详细</h2>
<p>这里选用一个资料较详细的<code>SGRT</code>架构做主要讲解，适当拓展其它架构知识。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a450140ae8d4bd5b151446a84cc7dfd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=7g3xNWqWqmtlISKxrjzMj8vWEy8%3D" alt="SGRT.png" loading="lazy"/></p>
<p>SGRT是一个移动端的实时光线追踪图形系统，属于混合型架构，没有<code>TBU</code>硬件，其加速结构在CPU构建。<code>SGRT</code>使用的静态场景测试，暂未添加<strong>树更新单元</strong>，但他的架构是为态场景设计的，只是暂未扩展，可做我们参考用。</p>
<p>SGRT拥有多个核心，每个核心都包含一个<code>T&amp;I</code>（遍历与相交）单元和一个<strong>SRP</strong>（三星可重构处理器）单元。各部分详细结构及功能如下：</p>
<h3 data-id="heading-8">5.1 SRP结构</h3>
<p><code>SRP</code>使用的是[Lee等人2011]中开发的GPU着色器核心，用于执行<strong>光线生成</strong>（初始生成的主光线、遍历、相交时产生的<strong>次级光线</strong>）、相交等各种光线<strong>着色器程序</strong>和<strong>着色计算</strong>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a6f370233dbd44c3a7c2dfe1827a6a9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=eOQgrf98921davfM%2FyWWNyDfmrc%3D" alt="SRP.png" loading="lazy"/></p>
<p><strong>VLIW</strong>（超长指令字）引擎适用于通用计算，例如函数调用和分支选择。<strong>CGRA</strong>（粗粒度可重构阵列）使用SIMD架构（单指令多数据），用于高效执行密集型计算。</p>
<p>主机端调用<code>SGRT</code>提供的<strong>编译器</strong>，对着色器代码（光线生成、相交等）进行编译时，会针对<code>VLIW,CGRA</code>的特性进行处理，比如控制流语句在VLIW中执行，光线的计算在CGRA中执行。</p>
<p><strong>Configuration Memory</strong>：SRP提供的为设计人员自定义的一些<strong>配置</strong>用来辅助实现功能。</p>
<p><strong>FU</strong>（功能单元）： 内部的组件包括：<strong>本地缓冲区</strong>、<strong>算术逻辑单元</strong>（ALU）、输入和输出<strong>多路复用器</strong>以及<strong>寄存器文件</strong>（RF）。</p>
<h3 data-id="heading-9">5.2 光线生成与着色</h3>
<p><code>SGRT</code>架构的主光线生成直接由SRP执行光线生成着色器产生，在<strong>编译</strong>时，SGRT提供的编译器会为各类型的光线执行不同的内核代码，并为它们添加<strong>着色代码</strong>。生成的光线会被放到缓冲区，以便被批量分配给T&amp;I单元。</p>
<p><strong>光线生成单元</strong>：一些专用型光追架构中会单独用硬件实现<strong>主光线生成</strong>，可以为主光线按莫顿顺序（空间上排序）以提高缓存效率。还可以剔除在三角形背面生成的阴影光线，生成采样光线以支持分布式光线追踪和超级采样抗锯齿等。</p>
<p><strong>着色</strong>：部分硬件架构支持<strong>自定义着色代码</strong>，但<code>SGRT</code>架构的着色由编译时附加，具体如下：</p>
<ul>
<li>在<strong>编译</strong>时对不同的光线类型和是否命中分类（阴影光线未命中、其它光线命中等），添加不同的着色内核代码。</li>
<li>其他光线且命中的情况是计算量最大的，编译时为其添加的内核代码中会包括：中心坐标计算法向量、是否生成次级光线、纹理映射、<strong>光照计算</strong>。</li>
<li>当前光线计算出的颜色被添加到着色缓冲区中的先前颜色上；最终颜色由从给定像素生成的所有光线的颜色值<strong>累加得到</strong>。</li>
</ul>
<p><strong>光照计算</strong>：由于辐射度的计算方式复杂，实现成本高，且实现了的辐射度方法依然很难达到实时帧率要求，所以现在实时光追硬件中的光照计算几乎都使用更简单的<code>Phong</code>光照模型。</p>
<h3 data-id="heading-10">5.3 T&amp;I单元详细</h3>
<p>光线的遍历与相交计算是整个光追管线中<strong>最耗资源的阶段</strong>，所以多数光追架构中都含有<code>T&amp;I</code>单元，其硬件化程度高，多采用硬连线代替通用寄存器，且包含<code>TRV</code>和<code>IST</code>硬件。</p>
<p><code>SGRT</code>的<code>T&amp;I</code>由<strong>光线分配单元（RD）</strong> 、四个<strong>遍历单元（TRV）</strong> 和一个<strong>相交单元（IST）</strong> 组成。每个单元都通过一个内部缓冲区连接，缓冲区将光线从一个单元传递到其他单元。T&amp;I单元和SRP通过基于FIFO的<strong>专用接口</strong>进行通信。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a078ad273ec4ee2926dde265b63b366~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YOP57Sg5LmL5aKD:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763966862&amp;x-signature=%2BVsT0B6apyTIVjEDz2Nj7uddPtw%3D" alt="SGRT-T&amp;I.png" loading="lazy"/></p>
<p><strong>光线分配单元</strong>（<code>RD</code>）：从光线缓冲区中获取光线（主光线与次级光线），并首先将其分配给空闲的<code>TRV</code>（每个周期只提供一条光线）。</p>
<p><strong>TRV</strong>：将所给的光线在<code>TBU</code>所构建的加速结构中遍历，查找到与当前光线相交的<strong>叶子节点</strong>（包含1个或多个基元）</p>
<ul>
<li>每个TRV都由一个内存处理模块（输入缓冲区、RAU、L1缓存、短栈）和计算流水线组成。</li>
<li>TRV流水线的输出分为三条路径：一条反馈回路路径返回输入缓冲区，用于对内部节点进行迭代访问；</li>
<li>一条输出路径用于在光线到达叶节点时将光线发送到<code>IST</code>。</li>
<li>还有一条输出路径用于在光线完成<code>BVH</code>树遍历后将光线发送到<strong>SRP（着色资源处理器）</strong> 。</li>
<li><code>TRV</code>的<strong>计算流水线</strong>由4个浮点加法器、4个浮点乘法器和11个浮点比较器组成。</li>
</ul>
<p><strong>IST</strong>：计算当前光线与TRV所给的多个<strong>基元</strong>（一般是三角形）是否相交，及其交点。</p>
<ul>
<li>其由一个内存处理模块（输入缓冲区、RAU、L1缓存）和计算流水线组成。</li>
<li><code>IST</code>流水线的输出分为两条路径：一条反馈回路路径返回输入缓冲区，用于对同一叶节点中的三角形进行迭代测试；</li>
<li>还有一条输出路径用于将光线发送到<code>TRV</code>，以便访问下一个树节点。</li>
</ul>
<p><strong>三阶段相交计算</strong>：较好的T&amp;I硬件有<strong>三阶段相交测试单元</strong>，该单元将相交测试阶段分为三个阶段。</p>
<ul>
<li>第一阶段是光线平面测试：判断光线是否与三角形所在的平面有交点，没有则终止。</li>
<li>第二阶段是重心坐标测试：判断光线是否与该三角形有交点，没有则终止。</li>
<li>第三阶段是最终的命中点计算：计算确切的相交坐标。</li>
</ul>
<p><strong>包追踪与单光线追踪</strong>：T&amp;I可以设计为多条光线或单条光线一起进行处理，两者各有差别：</p>
<ul>
<li>包追踪（多条光线）：对与单个盒子相交的多条光线进行<code>SIMD</code>（单指令多数据）并行化，但由于分支发散问题，它不适用于次级光线。一般会应用光线重新排序、排序或调度算法以提高光线连贯性。</li>
<li>单光线追踪：每条光线都被视为一个单独的线程，这意味着在处理非相干光线时可以获得更高的硬件利用率。对于不连贯光线而言，单光线追踪更稳健。<code>SGRT</code>的T&amp;I就采用这种方式。</li>
</ul>
<h3 data-id="heading-11">5.4 计算架构</h3>
<p>光线追踪过程会产生大量的光线，对这些光线需要高并行性的处理和计算，T&amp;I的<code>SIMD</code>架构方式是较适合处理光线的方法之一。还有其它几种计算架构，以下是他们的使用情况：</p>
<p><strong>SIMD</strong>：每条光线都由相同的遍历程序处理，但使用数据不同，这一点很适合使用SIMD结构。只是光线在场景中反射、折射，与基元相交、未相交等情况存在许多分支指令情况，纯SIMD机制无法提供足够的灵活性。</p>
<p><strong>SIMD+SIMT</strong>：引入<code>SIMT</code>（单指令多线程）可以为一组SIMD硬件执行的作业中的分支指令提供更灵活的支持；与多线程集成，通过时间复用SIMD硬件来隐藏内存延迟。但这种模型不适合非相干光线追踪，因为它会导致<strong>分支发散</strong>和<strong>共享内存争用</strong>。</p>
<p><strong>MIMD</strong>（多指令多数据）：每个核心都有自己的光线缓冲区，有独立的指令流和数据流，增加多组指令获取、解码和分发逻辑。<code>MIMD</code>架构提供了最佳的执行灵活性，但更复杂，硅面积占用多。</p>
<h2 data-id="heading-12">6 总结</h2>
<p><strong>实时光追硬件</strong>根据面向的场景不同，其硬件化程度有很大差异，一般面向专用集成电路、专用集成处理器的情况，硬件程度高，可能有专门实现的<code>TBU</code>、<strong>光线生成、着色单元</strong>等硬件。它们虽然有更好的性能，但可编程性少、灵活度低。</p>
<p>面向<strong>通用处理器</strong>，也就是大众用户的情况，则要有一定的灵活性，通常支持部分<strong>自定义着色器</strong>程序。移动端限于空间、发热等条件，更多使用混合架构，即：树构建在CPU执行，配合一个异步构建的<strong>树更新单元</strong>，着色器的执行也可能与<code>GPU</code>共用。</p>
<p>PC端的相关研究较多，能达到更高的性能，好的实时光追硬件多会用TBU硬件、更适合光追的<code>MIMD</code>架构。光追硬件一般放到显卡中，作为<code>GPU</code>架构的一部分。</p>
<p><strong>光追效果与性能</strong>：光追渲染中，因为每个物体考虑到了更多的间接光线，所以画面效果更亮；阴影、镜面、倒影等效果更明显，更真实。高端光追硬件每秒可执行<strong>数亿~百亿</strong>根光线。</p>
<p>但实际应用中有高清像素、帧率的要求，高端的实时光追硬件也很容易产生<strong>噪点</strong>，一般会结合<strong>降噪算法</strong>后处理，<strong>光流插帧</strong>技术提升帧率等。软件端渲染一个场景时也不一定全用光追渲染，比如远处的场景使用传统<strong>光栅化渲染</strong>，近处场景用光追渲染，最后两者结合。</p>
<h2 data-id="heading-13">7 主要参考</h2>
<ol>
<li>A Hardware Unit for Fast SAH-optimised BVH Construction</li>
<li>PLOCTree: A Fast, High-Quality Hardware BVH Builder</li>
<li>FastTree: A Hardware KD-Tree Construction Acceleration Engine for Real-Time Ray Tracing</li>
<li>HART: A Hybrid Architecture for Ray Tracing Animated Scenes</li>
<li>MergeTree: a HLBVH constructor for mobile systems</li>
<li>MRTP: Mobile Ray Tracing Processor With Reconfigurable Stream Multi-Processors for High Datapath Utilization</li>
<li>RayCore: A ray-tracing hardware architecture for mobile devices</li>
<li>SGRT: A Mobile GPU Architecture for Real-Time Ray Tracing</li>
<li>A Reconfigurable SIMT Processor for Mobile Ray Tracing With Contention Reduction in Shared Memory</li>
<li>T&amp;I Engine: Traversal and Intersection Engine for Hardware Accelerated Ray Tracing</li>
<li>Toward Real-Time Ray Tracing: A Survey on Hardware Acceleration and Microarchitecture Techniques</li>
<li>TRaX: A Multicore Hardware Architecture for Real-Time Ray Tracing</li>
<li>光线追踪硬件加速方案综述</li>
<li>《全局光照》</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Python入门到实战：网络请求与数据获取]]></title>    <link>https://juejin.cn/post/7573242085610176563</link>    <guid>https://juejin.cn/post/7573242085610176563</guid>    <pubDate>2025-11-17T08:10:21.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573242085610176563" data-draft-id="7572939250586910771" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Python入门到实战：网络请求与数据获取"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2025-11-17T08:10:21.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="烤汉堡"/> <meta itemprop="url" content="https://juejin.cn/user/3563932375586313"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Python入门到实战：网络请求与数据获取
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3563932375586313/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    烤汉堡
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:10:21.000Z" title="Mon Nov 17 2025 08:10:21 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><h2 data-id="heading-0">一、环境准备，安装requests库</h2>
<h3 data-id="heading-1">1.安装命令（终端执行）</h3>
<pre><code class="hljs language-python" lang="python"> <span class="hljs-comment">#安装requests库</span>
pip install requests -i https://pypi.tuna.tsinghua.edu.cn/simple/
<span class="hljs-comment">#(该方式是临时指定的,每次下载需要去cmd终端下载库 相对来说比较麻烦，每次添加库的时候就要去cmd终端去下载)</span>
</code></pre>
<h3 data-id="heading-2">2.解决安装超时的问题（配置国内镜像源）</h3>
<pre><code class="hljs language-python" lang="python">pip config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>.index-url https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<h6 data-id="heading-3"><strong>说明：默认连接Python官方仓库，国内镜像源（如清华源）可提升下载速度。</strong></h6>
<h2 data-id="heading-4">二、基本用法：发起GET请求</h2>
<h3 data-id="heading-5">1.导入模块与基础请求</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests <span class="hljs-comment">#导入requests库</span>
<span class="hljs-comment"># 在要获取数据的浏览器页面里，找到目标URL（以疾病查询页面为例）,键盘按下Fn+F12，查看是什么请求方式</span>
url = <span class="hljs-string">'https://www.youlai.cn/dise'</span>
<span class="hljs-comment"># 发起get请求，获取响应对象 将获取到的响应对象的结果给到变量res</span>
res = requests.get(url) 
<span class="hljs-comment"># 打印响应内容（如果响应结果是HTML文本内容）</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"响应内容："</span>,res.text)
</code></pre>
<h3 data-id="heading-6">2.处理中文乱码问题</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
url = <span class="hljs-string">'https://www.tjwenming.cn/'</span>
res = requests.get(url)
<span class="hljs-comment"># 手动指定编码（根据目标网页的meta标签设置，此处以gb2312为例）</span>
res.encoding = <span class="hljs-string">'gb2312'</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'处理后的中午内容：'</span>,res.text)
</code></pre>
<p>调用encoding前
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bce0d84f852c4b6c9d13bb336241f93d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Ok5rGJ5aCh:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972330&amp;x-signature=umqPC17N76SSDKgpedcmdYWtBIc%3D" alt="628f3e95-898f-4d77-a032-162c7db7f13d.png" loading="lazy"/>
调用encoding后
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4b8bc3c9ad848bca09247983e316e10~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg54Ok5rGJ5aCh:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972330&amp;x-signature=rquQvudDyFSshS0D29PUtjqH7Lo%3D" alt="33a8a6bb-8de0-4500-9089-7971429fd69e.png" loading="lazy"/></p>
<h6 data-id="heading-7"><strong>关键步骤：</strong></h6>
<ul>
<li>检查网页源码中的&lt;metacharset="xxx"&gt;标签，获取编码格式（如utf-8、gbk、gb2312）。</li>
<li>通过response.encoding设置编码，确保中文正常显示。</li>
</ul>
<h2 data-id="heading-8">三、带参数的GET请求</h2>
<h3 data-id="heading-9">1.参数传递方式</h3>
<h4 data-id="heading-10">方式一：URL拼接参数（直接在URL中携带参数）</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
<span class="hljs-comment">#包含参数的完整URL（从浏览器复制）</span>
url=<span class="hljs-string">'https://careers.tencent.com/tencentcareer/api/post/Query?timestamp=1763364793381&amp;countryId=&amp;cityId=&amp;bgIds=&amp;productId=&amp;categoryId=&amp;parentCategoryId=&amp;attrId=2,3&amp;keyword=&amp;pageIndex=1&amp;pageSize=10&amp;language=zh-cn&amp;area=cn'</span>
res = requests.get(url)
<span class="hljs-built_in">print</span>(res.text)
</code></pre>
<h4 data-id="heading-11">方式二：通过params参数传递</h4>
<pre><code class="hljs language-python" lang="python">url = <span class="hljs-string">'https://careers.tencent.com/tencentcareer/api/post/Query'</span> <span class="hljs-comment"># 注意写基础的URL 不带后面的请求参数</span>
params = { <span class="hljs-comment"># 将请求参数通过字典的形式存起来，给到params</span>
    <span class="hljs-string">'timestamp'</span>: <span class="hljs-number">1763364793381</span>,
    <span class="hljs-string">'ountryId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'cityId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'bgIds'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'productId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'categoryId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'parentCategoryId'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'attrId'</span>: <span class="hljs-string">'2,3'</span>, <span class="hljs-comment"># 注意参数为字符串类型</span>
    <span class="hljs-string">'keyword'</span>: <span class="hljs-string">''</span>,
    <span class="hljs-string">'pageIndex'</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">'pageSize'</span>: <span class="hljs-number">10</span>,
    <span class="hljs-string">'language'</span>: <span class="hljs-string">'zh-cn'</span>,
    <span class="hljs-string">'area'</span>: <span class="hljs-string">'cn'</span>
}
<span class="hljs-comment"># 发起请求时传递params参数</span>
res = requests.get(url,params=params)
<span class="hljs-built_in">print</span>(res.text)
</code></pre>
<h2 data-id="heading-12">四、获取二进制数据（图片、视频等）</h2>
<h3 data-id="heading-13">：下载网络图片并保存</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> requests
url = <span class="hljs-string">'http://pic.enorth.com.cn/005/026/920/00502692031_21660ab6.jpg'</span>
res = requests.get(url)
<span class="hljs-comment">#如果请求网址对应的数据为图片视频音频</span>
<span class="hljs-comment">#获取数据的方式：响应对象.content---&gt;字节数据</span>
res_img = res.content 
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'1.jpg'</span>,<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:
    f.write(res_img)
</code></pre>
<h6 data-id="heading-14"><strong>关键点：</strong></h6>
<ul>
<li>二进制数据通过response.content获取，而非text。</li>
<li>文件扩展名需与内容类型匹配（如.gif、.mp4、.jpg）。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我为什么说全栈正在杀死前端？]]></title>    <link>https://juejin.cn/post/7573172586839834676</link>    <guid>https://juejin.cn/post/7573172586839834676</guid>    <pubDate>2025-11-17T08:15:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573172586839834676" data-draft-id="7573170756869701684" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我为什么说全栈正在杀死前端？"/> <meta itemprop="keywords" content="前端,JavaScript,后端"/> <meta itemprop="datePublished" content="2025-11-17T08:15:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"/> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我为什么说全栈正在杀死前端？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:15:42.000Z" title="Mon Nov 17 2025 08:15:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我又来了🤣。</p>
<p>打开2025年的招聘软件，十个资深前端岗位，有八个在JD（职位描述）里写着：“<strong>有Node.js/Serverless/全栈经验者优先</strong>”。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/396bd4a478b94074abdb22cf0bcd992c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972142&amp;x-signature=KgZ0NpU4hqp6nYYJQiiCF2T8pPI%3D" alt="50fb0729f6733fc5092ecfc91f063c6.jpg" loading="lazy"/></p>
<p>全栈 👉 成了我们前端工程师内卷的一种方式。仿佛你一个干前端的，要是不懂点BFF、不会配Nginx、不聊聊K8s，你都不好意思跟人说你是资深。</p>
<p>我们都在拼命地，去学Nest.js、学数据库、学运维。<strong>我们看起来，变得越来越全能了。</strong></p>
<p>但今天，我想泼一盆冷水🤔：</p>
<p><strong>全栈正在杀死前端。</strong></p>
<hr/>
<h4 data-id="heading-0"><strong>全栈到底是什么</strong></h4>
<p>我们先要搞清楚，现在公司老板们想要的全栈，到底是什么？</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/983308b05bc44a6987b2efdfb2ef63f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972142&amp;x-signature=rmdBMjFP0%2BDvXkU9IDhKJ6aceP0%3D" alt="image.png" loading="lazy"/></p>
<p>他们想要的，不是一个T型人才（在一个领域是专家，同时懂其他领域）。</p>
<p>他们想要的是：一个能干两个人（前端+后端）的活，但只需要付1.5个人的工资。</p>
<p>但一个人的精力，毕竟是有限的。</p>
<ul>
<li>当我花了3个月，去死磕K8s的部署和Nest.js的依赖注入时，我必然没有时间，去研究新出炉的<code>INP</code>性能指标该如何优化。</li>
<li>当我花了半周时间，去设计数据库表结构和BFF接口时，我必然没有精力，去打磨那个React组件的可访问性，无障碍（a11y）和动画细节。</li>
</ul>
<p>我们引以为傲的前端精神，正在被全栈的广度要求，稀释得一干二净。</p>
<p><strong>全栈的趋势，正在逼迫我们，从一个能拿90分的前端专家，变成一个前后端都是及格的功能实现者。</strong></p>
<hr/>
<h4 data-id="heading-1"><strong>关于前端体验</strong></h4>
<p>做全栈的后果，最终由谁来买单？</p>
<p><strong>是用户。</strong></p>
<p>我们来看看全栈前端主导下，最容易出现的受灾现场：</p>
<p><strong>1.能用就行的交互</strong></p>
<p>全栈思维，是功能驱动的。</p>
<p>数据能从数据库里查出来，通过API发到前端，再用v-for渲染出来，好了，这个功能完成了😁。</p>
<p>至于：</p>
<ul>
<li>列表的虚拟滚动做了吗？</li>
<li>图片的懒加载做了吗？</li>
<li>按钮的<code>loading</code>和<code>disabled</code>状态，在API请求时加了吗？</li>
<li>页面切换的骨架屏做了吗？</li>
<li>弱网环境下的超时和重试逻辑写了吗？</li>
<li>UI测试呢？</li>
</ul>
<p><strong>抱歉，没时间。我还要去写BFF层的单元测试。</strong></p>
<p><strong>2.无障碍，可访问性（a11y）</strong></p>
<p>你猜一个全栈，在用 <code>&lt;div&gt;</code> 还是 <code>&lt;button&gt;</code> 来实现一个按钮时，会思考 <code>aria-*</code> 属性吗？他会关心Tab键的焦点顺序吗？</p>
<p><strong>根本不会。</strong></p>
<p>因为可访问性这个东西，是纯粹的纯前端范围，它不属于全栈能力范围。</p>
<p><strong>3. 性能优化</strong></p>
<p>当一个全栈工程师的注意力，被数据库索引、Nginx缓存、Docker镜像大小给占满时，他还有多少脑容量，去关心LCP、CLS、Tree Shaking、Code Splitting？</p>
<p><code>useMemo</code>？<code>PureComponent</code>？能跑就行了，别搞那么复杂。</p>
<p><strong>前端，正在从用户体验的第一负责人，被降维成了全栈流程的最后一个环节——那个把数据显示出来UI就行。</strong></p>
<hr/>
<h4 data-id="heading-2"><strong>一个前端的专业性</strong></h4>
<p>最让我发慌的，是一种风气的转变。</p>
<p>五年前，我们团队，会为一个<strong>如何把白屏时间再减少100ms</strong>的议题，在白板前吵一个下午。我们会为<strong>该用<code>padding</code>还是<code>margin</code>来实现间距</strong> 这种像素级的细节，在CR（Code Review）里吵架。</p>
<p>现在呢？</p>
<p>CR时，大家都在聊：你这个BFF的Controller层，不该写业务逻辑、你这个数据库类型定义不规范。</p>
<p><strong>没人再关心那个前端按钮逻辑了。</strong></p>
<p>全栈，正在杀死前端的专业性。它让前端这个职业，变得不再纯粹，不再专注一个领域。</p>
<hr/>
<h4 data-id="heading-3"><strong>我不想做全栈开发😠</strong></h4>
<p>聊了这么多，我不是在贩卖焦虑，也不是在抵制学习后端知识。</p>
<p>作为8年老前端，我现在给自己的定位是：<strong>一个T型前端工程师。</strong></p>
<p>我必须是团队里，对浏览器渲染原理、JS性能优化、CSS布局、组件化架构、可访问性理解最深的那个人。这是我的前端身份，是我的技能。</p>
<p>我懂Node.js，是为了能和后端吵架时，提出更合理的BFF接口设计。</p>
<p>我懂Docker，是为了能理解我的代码，是如何在CI/CD上闪退的。</p>
<p>我懂SQL，是为了能理解为什么我的一个查询，会导致查询慢。</p>
<hr/>
<p>请大家别再神话全栈了😒。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/533b70c9236940c8819809215bc94615~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763972142&amp;x-signature=A7U8o8c6C9mMuLLE5cHg7Wrw%2F7M%3D" alt="Suggestion.gif" loading="lazy"/></p>
<p>全栈的尽头，很可能是全废了，这个也不精，那个也不精。</p>
<p>我宁愿要做一个95分的前端专家，和一个95分的后端专家，让他们强强联手；</p>
<p>也不想要两个及格的全栈工程师，最终交付一个50分的、能跑就行的垃圾代码💩。</p>
<p>欢呼大家，尊重前端这个职业的专业性。</p>
<p>谢谢🙌</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Set 和 Map常用场景代码片段]]></title>    <link>https://juejin.cn/post/7573468493569179684</link>    <guid>https://juejin.cn/post/7573468493569179684</guid>    <pubDate>2025-11-17T08:23:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573468493569179684" data-draft-id="7571490332372172819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Set 和 Map常用场景代码片段"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2025-11-17T08:23:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MoMoDad"/> <meta itemprop="url" content="https://juejin.cn/user/2788017221151342"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Set 和 Map常用场景代码片段
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2788017221151342/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    MoMoDad
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:23:48.000Z" title="Mon Nov 17 2025 08:23:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">一、Set 实用代码片段</h3>
<h4 data-id="heading-1">1. 数组去重（基础版）</h4>
<p><strong>场景</strong>：接口返回数组、用户输入列表等需要快速去重。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 数组去重（支持基本类型，引用类型需额外处理）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">arr</span> - 待去重数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Array</span>} 去重后数组
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">uniqueArray</span> = (<span class="hljs-params">arr</span>) =&gt; [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];

<span class="hljs-comment">// 示例</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">uniqueArray</span>(arr)); <span class="hljs-comment">// [1, 2, 3, 'a']</span>
</code></pre>
<h4 data-id="heading-2">2. 检查数组是否有重复元素</h4>
<p><strong>场景</strong>：表单验证（如 “标签不可重复”）、数据校验。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 检查数组是否存在重复元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} <span class="hljs-variable">arr</span> - 待检查数组
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} 是否有重复
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">hasDuplicates</span> = (<span class="hljs-params">arr</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr).<span class="hljs-property">size</span> !== arr.<span class="hljs-property">length</span>;

<span class="hljs-comment">// 示例</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasDuplicates</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// true</span>
</code></pre>
<h4 data-id="heading-3">3. 集合操作（交集 / 并集 / 差集）</h4>
<p><strong>场景</strong>：权限对比（如 “用户权限与角色权限的交集”）、数据筛选。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-ini" lang="ini">// 交集：两个数组的共同元素
const <span class="hljs-attr">intersection</span> = (arr1, arr2) =&gt; {
  const <span class="hljs-attr">set2</span> = new Set(arr2)<span class="hljs-comment">;</span>
  return arr1.filter(<span class="hljs-attr">item</span> =&gt; set2.has(item))<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

// 并集：两个数组的所有元素（去重）
const <span class="hljs-attr">union</span> = (arr1, arr2) =&gt; [...new Set([...arr1, ...arr2])]<span class="hljs-comment">;</span>

// 差集：arr1 有但 arr2 没有的元素
const <span class="hljs-attr">difference</span> = (arr1, arr2) =&gt; {
  const <span class="hljs-attr">set2</span> = new Set(arr2)<span class="hljs-comment">;</span>
  return arr1.filter(<span class="hljs-attr">item</span> =&gt; !set2.has(item))<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

// 示例
const <span class="hljs-attr">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">;</span>
const <span class="hljs-attr">b</span> = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<span class="hljs-comment">;</span>
console.log(intersection(a, b))<span class="hljs-comment">; // [2, 3]</span>
console.log(union(a, b))<span class="hljs-comment">; // [1, 2, 3, 4]</span>
console.log(difference(a, b))<span class="hljs-comment">; // [1]</span>
</code></pre>
<h4 data-id="heading-4">4. 临时存储 “已处理项”（避免重复操作）</h4>
<p><strong>场景</strong>：批量处理数据时记录已处理 ID，防止重复请求 / 计算。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 记录已处理的任务ID</span>
const processedTaskIds = new <span class="hljs-built_in">Set</span>();

<span class="hljs-comment">/**
 * 处理任务（仅处理未处理过的）
 * @param {number} taskId - 任务ID
 */</span>
const processTask = (taskId) =&gt; {
  if (processedTaskIds.has(taskId)) {
    console<span class="hljs-selector-class">.log</span>(`任务 ${taskId} 已处理，跳过`);
    return;
  }
  <span class="hljs-comment">// 模拟处理逻辑</span>
  console<span class="hljs-selector-class">.log</span>(`处理任务 ${taskId}`);
  processedTaskIds<span class="hljs-selector-class">.add</span>(taskId);
};

<span class="hljs-comment">// 示例</span>
<span class="hljs-built_in">processTask</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 处理任务 1</span>
<span class="hljs-built_in">processTask</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 任务 1 已处理，跳过</span>
<span class="hljs-built_in">processTask</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 处理任务 2</span>
</code></pre>
<h3 data-id="heading-5">二、Map 实用代码片段</h3>
<h4 data-id="heading-6">1. 复杂键名映射（替代对象的局限性）</h4>
<p><strong>场景</strong>：用对象（如 DOM 元素、实例）作为键存储数据（对象的键会被转为字符串，无法直接用对象当键）。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 场景：给DOM元素绑定额外数据（如点击次数、状态）</span>
<span class="hljs-keyword">const</span> elementData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-comment">// 获取DOM元素</span>
<span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'submit-btn'</span>);
<span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'username-input'</span>);

<span class="hljs-comment">// 存储数据（键为DOM元素，值为任意类型）</span>
elementData.<span class="hljs-keyword">set</span>(btn, { clickCount: <span class="hljs-number">0</span>, disabled: <span class="hljs-keyword">false</span> });
elementData.<span class="hljs-keyword">set</span>(input, { value: <span class="hljs-string">''</span>, touched: <span class="hljs-keyword">false</span> });

<span class="hljs-comment">// 更新数据</span>
btn.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> data = elementData.<span class="hljs-keyword">get</span>(btn);
  elementData.<span class="hljs-keyword">set</span>(btn, { ...data, clickCount: data.clickCount + <span class="hljs-number">1</span> });
  console.log(`按钮点击次数：${elementData.<span class="hljs-keyword">get</span>(btn).clickCount}`);
});
</code></pre>
<h4 data-id="heading-7">2. 接口数据缓存（避免重复请求）</h4>
<p><strong>场景</strong>：同一参数的接口请求，优先返回缓存数据，减少接口调用。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 带缓存的接口请求工具
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">fetchFn</span> - 实际请求函数（返回Promise）
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Function</span>} 包装后的请求函数
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">withCache</span> = (<span class="hljs-params">fetchFn</span>) =&gt; {
  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 缓存：键为参数字符串，值为请求结果</span>

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (...args) =&gt; {
    <span class="hljs-comment">// 生成唯一缓存键（将参数转为字符串，支持多参数）</span>
    <span class="hljs-keyword">const</span> cacheKey = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args);

    <span class="hljs-comment">// 命中缓存：直接返回</span>
    <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(cacheKey)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'使用缓存数据'</span>);
      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(cacheKey);
    }

    <span class="hljs-comment">// 未命中：请求并缓存</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'发起新请求'</span>);
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchFn</span>(...args);
    cache.<span class="hljs-title function_">set</span>(cacheKey, result);
    <span class="hljs-keyword">return</span> result;
  };
};

<span class="hljs-comment">// 示例：包装一个获取用户信息的接口</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">userId</span>) =&gt; {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/user/<span class="hljs-subst">${userId}</span>`</span>);
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();
};

<span class="hljs-comment">// 使用缓存版请求</span>
<span class="hljs-keyword">const</span> fetchUserWithCache = <span class="hljs-title function_">withCache</span>(fetchUser);

<span class="hljs-comment">// 第一次请求（无缓存）</span>
<span class="hljs-title function_">fetchUserWithCache</span>(<span class="hljs-number">1</span>); 
<span class="hljs-comment">// 第二次请求同一用户（用缓存）</span>
<span class="hljs-title function_">fetchUserWithCache</span>(<span class="hljs-number">1</span>); 
</code></pre>
<h4 data-id="heading-8">3. 多维度数据映射（快速查询）</h4>
<p><strong>场景</strong>：同一份数据需要通过多个 “键” 查询（如用户信息可通过 ID、手机号、用户名查询）。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// 原始用户数据</span>
<span class="hljs-keyword">const</span> users = [
  { id: <span class="hljs-number">1</span>, name: <span class="hljs-string">'张三'</span>, phone: <span class="hljs-string">'13800138000'</span> },
  { id: <span class="hljs-number">2</span>, name: <span class="hljs-string">'李四'</span>, phone: <span class="hljs-string">'13900139000'</span> }
];

<span class="hljs-comment">// 构建多维度映射</span>
<span class="hljs-keyword">const</span> userMaps = {
  byId: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),    <span class="hljs-comment">// 键：id</span>
  byName: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),  <span class="hljs-comment">// 键：name</span>
  byPhone: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-comment">// 键：phone</span>
};

users.forEach(user =&gt; {
  userMaps.byId.<span class="hljs-keyword">set</span>(user.id, user);
  userMaps.byName.<span class="hljs-keyword">set</span>(user.name, user);
  userMaps.byPhone.<span class="hljs-keyword">set</span>(user.phone, user);
});

<span class="hljs-comment">// 快速查询示例</span>
console.log(userMaps.byId.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// {id:1, name:'张三', ...}</span>
console.log(userMaps.byPhone.<span class="hljs-keyword">get</span>(<span class="hljs-string">'13900139000'</span>)); <span class="hljs-comment">// {id:2, ...}</span>
</code></pre>
<h4 data-id="heading-9">4. 有序键值对遍历（保留插入顺序）</h4>
<p><strong>场景</strong>：需要按 “插入顺序” 遍历键值对（对象的键遍历顺序不稳定，尤其是数字键）。</p>
<p>javascript</p>
<p>运行</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 场景：按用户操作顺序记录日志（需保留顺序）</span>
<span class="hljs-keyword">const</span> actionLog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

<span class="hljs-comment">// 按顺序插入操作</span>
actionLog.<span class="hljs-title function_">set</span>(<span class="hljs-string">'login'</span>, { <span class="hljs-attr">time</span>: <span class="hljs-string">'09:00'</span>, <span class="hljs-attr">user</span>: <span class="hljs-string">'张三'</span> });
actionLog.<span class="hljs-title function_">set</span>(<span class="hljs-string">'view'</span>, { <span class="hljs-attr">time</span>: <span class="hljs-string">'09:05'</span>, <span class="hljs-attr">page</span>: <span class="hljs-string">'首页'</span> });
actionLog.<span class="hljs-title function_">set</span>(<span class="hljs-string">'logout'</span>, { <span class="hljs-attr">time</span>: <span class="hljs-string">'10:00'</span>, <span class="hljs-attr">user</span>: <span class="hljs-string">'张三'</span> });

<span class="hljs-comment">// 按插入顺序遍历（Map 会保留插入顺序）</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [action, detail] <span class="hljs-keyword">of</span> actionLog) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${action}</span>：<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(detail)}</span>`</span>);
}
<span class="hljs-comment">// 输出顺序：login → view → logout（与插入顺序一致）</span>
</code></pre>
<h3 data-id="heading-10">三、使用小贴士</h3>
<ol>
<li>
<p><strong>选择 Set 还是 Map</strong>？</p>
<ul>
<li>只需要 “唯一元素集合” → 用 Set；</li>
<li>需要 “键值对映射”（尤其是复杂键） → 用 Map。</li>
</ul>
</li>
<li>
<p><strong>性能考量</strong>：</p>
<ul>
<li>Set/Map 的 <code>has</code>/<code>get</code>/<code>set</code> 操作时间复杂度为 O (1)，比数组的 <code>indexOf、includes</code>等（O (n)）更高效，数据量大时优先使用。</li>
</ul>
</li>
<li>
<p><strong>转换技巧</strong>：</p>
<ul>
<li>Set 转数组：<code>[...mySet]</code> 或 <code>Array.from(mySet)</code>；</li>
<li>Map 转对象（键为字符串时）：<code>Object.fromEntries(myMap)</code>。</li>
</ul>
</li>
<li>
<p><strong>转换技巧</strong>：</p>
<ul>
<li>Set/Map 的 <code>has</code>/<code>get</code>/<code>set</code> 操作都是 O (1)，比数组 <code>indexOf</code>（O (n)）、对象循环查询快，<strong>数据量大（&gt;100）时优先用</strong>。</li>
<li>临时缓存（比如接口缓存）如果不需要持久化，用 Map 即可；需要持久化到 localStorage，要先转成数组 / 对象（因为 localStorage 只能存字符串）。</li>
</ul>
</li>
<li>
<p><strong>避坑提醒</strong></p>
<ul>
<li>Set 存引用类型（对象、数组）时，不会自动去重（因为引用地址不同），比如 <code>new Set([{a:1}, {a:1}])</code> 会存两个对象。</li>
<li>Map 的键是 “引用相等”，比如 <code>map.set({}, 1)</code> 和 <code>map.set({}, 2)</code> 是两个不同的键（对象引用不同）。</li>
</ul>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端代码一键打包上传服务器？10分钟配好永久告别手动部署！]]></title>    <link>https://juejin.cn/post/7573299401046802478</link>    <guid>https://juejin.cn/post/7573299401046802478</guid>    <pubDate>2025-11-17T08:26:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573299401046802478" data-draft-id="7573506713865682995" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端代码一键打包上传服务器？10分钟配好永久告别手动部署！"/> <meta itemprop="keywords" content="前端,Node.js"/> <meta itemprop="datePublished" content="2025-11-17T08:26:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="扑棱蛾子"/> <meta itemprop="url" content="https://juejin.cn/user/2823201593493790"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端代码一键打包上传服务器？10分钟配好永久告别手动部署！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2823201593493790/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    扑棱蛾子
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:26:46.000Z" title="Mon Nov 17 2025 08:26:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p>搞了一个服务器准备折腾一下，但是每次打包用FTP一个个传文件太麻烦了。
受不了于是准备搞个脚本自动部署下。</p>
<p>于是乎，我今天教你配一套<strong>自动化部署脚本</strong>，以后改完代码直接一个命令<code>npm run deploy</code>，喝杯咖啡十分钟的功夫，就自动打包部署完了。</p>
<h2 data-id="heading-0">第一步：配置免密登录</h2>
<p>让本地电脑和服务器之间建立信任关系，不然每次上传都要输密码，烦都烦死。</p>
<p><strong>本地生成密钥</strong>（如果你之前没搞过的话）：</p>
<pre><code class="hljs language-bash" lang="bash">ssh-keygen -t rsa -b 4096 -C “your-email@example.com”
</code></pre>
<p>一路回车就行。这就像给你的电脑办了张身份证。</p>
<p><strong>查看刚生成的密钥</strong>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub
</code></pre>
<p>会出来一长串字符，全选复制它！这是你电脑的“身份证号”。</p>
<p><strong>登录服务器添加信任</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">ssh username@your-server-ip
</code></pre>
<p>输完密码进去后，执行下面这几条命令：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建存放密钥的文件夹</span>
<span class="hljs-built_in">mkdir</span> -p ~/.ssh

<span class="hljs-comment"># 设置文件夹权限</span>
<span class="hljs-built_in">chmod</span> 700 ~/.ssh

<span class="hljs-comment"># 把刚才复制的公钥粘贴进去</span>
<span class="hljs-built_in">echo</span> “粘贴你刚才复制的那一长串” &gt;&gt; ~/.ssh/authorized_keys

<span class="hljs-comment"># 设置密钥文件权限</span>
<span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys
</code></pre>
<blockquote>
<p><strong>测试一下有没有配好</strong>：退出服务器后重新执行<code>ssh username@your-server-ip</code>，如果不用输密码直接进去了，那就成了！</p>
</blockquote>
<h2 data-id="heading-1">第二步：部署脚本</h2>
<p>在项目根目录新建一个<code>deploy。js</code>文件，直接把下面代码复制进去：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// deploy.js - 完整的部署脚本（直接上传文件版本）</span>
<span class="hljs-keyword">import</span> { execSync } <span class="hljs-keyword">from</span> <span class="hljs-string">'child_process'</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>

<span class="hljs-comment">// 配置信息 - 根据你的实际情况修改</span>
<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">server</span>: <span class="hljs-string">'username@your-server-ip'</span>, <span class="hljs-comment">// 替换为你的服务器信息</span>
  <span class="hljs-attr">deployPath</span>: <span class="hljs-string">'yourpath'</span>
}

<span class="hljs-comment">// 彩色日志</span>
<span class="hljs-keyword">const</span> colors = {
  <span class="hljs-attr">reset</span>: <span class="hljs-string">'\x1b[0m'</span>,
  <span class="hljs-attr">red</span>: <span class="hljs-string">'\x1b[31m'</span>,
  <span class="hljs-attr">green</span>: <span class="hljs-string">'\x1b[32m'</span>,
  <span class="hljs-attr">yellow</span>: <span class="hljs-string">'\x1b[33m'</span>,
  <span class="hljs-attr">blue</span>: <span class="hljs-string">'\x1b[34m'</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">message, color = colors.reset</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(color + message + colors.<span class="hljs-property">reset</span>)
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">runCommand</span>(<span class="hljs-params">command, description</span>) {
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`📝 <span class="hljs-subst">${description}</span>`</span>, colors.<span class="hljs-property">blue</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`  执行: <span class="hljs-subst">${command}</span>`</span>, colors.<span class="hljs-property">yellow</span>)

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> output = <span class="hljs-title function_">execSync</span>(command, { <span class="hljs-attr">stdio</span>: <span class="hljs-string">'inherit'</span> })
    <span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ <span class="hljs-subst">${description}</span> 成功`</span>, colors.<span class="hljs-property">green</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-title function_">log</span>(<span class="hljs-string">`❌ <span class="hljs-subst">${description}</span> 失败: <span class="hljs-subst">${error.message}</span>`</span>, colors.<span class="hljs-property">red</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }
}

<span class="hljs-comment">// 递归获取目录中的所有文件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllFiles</span>(<span class="hljs-params">dirPath, arrayOfFiles = []</span>) {
  <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(dirPath)

  files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">join</span>(dirPath, file)
    <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">statSync</span>(fullPath).<span class="hljs-title function_">isDirectory</span>()) {
      arrayOfFiles = <span class="hljs-title function_">getAllFiles</span>(fullPath, arrayOfFiles)
    } <span class="hljs-keyword">else</span> {
      arrayOfFiles.<span class="hljs-title function_">push</span>(fullPath)
    }
  })

  <span class="hljs-keyword">return</span> arrayOfFiles
}

<span class="hljs-comment">// 主部署函数</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">deploy</span>(<span class="hljs-params"/>) {
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'🚀 开始直接文件上传部署流程'</span>, colors.<span class="hljs-property">blue</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">50</span>))

  <span class="hljs-comment">// 1. 检查 dist 目录是否存在，如果不存在则构建</span>
  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(<span class="hljs-string">'dist'</span>)) {
    <span class="hljs-title function_">log</span>(<span class="hljs-string">'📦 dist 目录不存在，开始构建项目...'</span>, colors.<span class="hljs-property">yellow</span>)
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">runCommand</span>(<span class="hljs-string">'npm run build'</span>, <span class="hljs-string">'项目构建'</span>)) {
      <span class="hljs-keyword">return</span>
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">log</span>(<span class="hljs-string">'📦 发现已存在的 dist 目录，跳过构建'</span>, colors.<span class="hljs-property">green</span>)
  }

  <span class="hljs-comment">// 2. 获取 dist 目录中的所有文件</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'📋 扫描 dist 目录中的文件...'</span>, colors.<span class="hljs-property">blue</span>)
  <span class="hljs-keyword">const</span> distFiles = <span class="hljs-title function_">getAllFiles</span>(<span class="hljs-string">'dist'</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`📄 找到 <span class="hljs-subst">${distFiles.length}</span> 个文件需要上传`</span>, colors.<span class="hljs-property">green</span>)

  <span class="hljs-comment">// 3. 测试服务器连接</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'🔗 测试服务器连接...'</span>, colors.<span class="hljs-property">blue</span>);
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">runCommand</span>(<span class="hljs-string">`ssh -o ConnectTimeout=10 <span class="hljs-subst">${config.server}</span> "echo '连接成功'; exit"`</span>, <span class="hljs-string">'测试SSH连接'</span>)) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 4. 在服务器上创建备份</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'💾 在服务器上创建备份...'</span>, colors.<span class="hljs-property">blue</span>);
  <span class="hljs-keyword">const</span> backupCommands = <span class="hljs-string">`set -e; cd <span class="hljs-subst">${config.deployPath}</span>; echo "备份当前文件..."; if [ -f "index.html" ] || [ -d "assets" ]; then tar -czf backup_old.tar.gz index.html assets 2&gt;/dev/null || true; echo "✅ 当前文件已备份为 backup_old.tar.gz"; else echo "⚠️ 没有找到当前文件，跳过备份"; fi; echo "清理旧文件..."; rm -rf index.html assets; echo "✅ 服务器准备完成"; exit 0`</span>;
  
  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">runCommand</span>(<span class="hljs-string">`ssh -o ConnectTimeout=30 <span class="hljs-subst">${config.server}</span> "<span class="hljs-subst">${backupCommands}</span>"`</span>, <span class="hljs-string">'服务器准备'</span>)) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 5. 逐个上传文件到服务器</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'📤 开始上传文件到服务器...'</span>, colors.<span class="hljs-property">blue</span>)
  <span class="hljs-keyword">let</span> uploadedCount = <span class="hljs-number">0</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> filePath <span class="hljs-keyword">of</span> distFiles) {
    <span class="hljs-keyword">const</span> relativePath = path.<span class="hljs-title function_">relative</span>(<span class="hljs-string">'dist'</span>, filePath)
    <span class="hljs-keyword">const</span> remotePath = path
      .<span class="hljs-title function_">join</span>(config.<span class="hljs-property">deployPath</span>, relativePath)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>)
    <span class="hljs-keyword">const</span> remoteDir = path.<span class="hljs-title function_">dirname</span>(remotePath).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">'/'</span>)

    <span class="hljs-comment">// 确保远程目录存在</span>
    <span class="hljs-keyword">const</span> mkdirCommand = <span class="hljs-string">`ssh <span class="hljs-subst">${config.server}</span> "mkdir -p <span class="hljs-subst">${remoteDir}</span>"`</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">runCommand</span>(mkdirCommand, <span class="hljs-string">`创建目录: <span class="hljs-subst">${remoteDir}</span>`</span>)) {
      <span class="hljs-keyword">continue</span>
    }

    <span class="hljs-comment">// 上传文件</span>
    <span class="hljs-keyword">const</span> scpCommand = <span class="hljs-string">`scp <span class="hljs-subst">${filePath}</span> <span class="hljs-subst">${config.server}</span>:<span class="hljs-subst">${remotePath}</span>`</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">runCommand</span>(scpCommand, <span class="hljs-string">`上传文件: <span class="hljs-subst">${relativePath}</span>`</span>)) {
      uploadedCount++
    }
  }

  <span class="hljs-title function_">log</span>(
    <span class="hljs-string">`✅ 文件上传完成: <span class="hljs-subst">${uploadedCount}</span>/<span class="hljs-subst">${distFiles.length}</span> 个文件`</span>,
    colors.<span class="hljs-property">green</span>
  )

  <span class="hljs-comment">// 6. 在服务器上设置文件权限</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'🔒 设置服务器文件权限...'</span>, colors.<span class="hljs-property">blue</span>);
  <span class="hljs-keyword">const</span> permissionCommands = <span class="hljs-string">`set -e; cd <span class="hljs-subst">${config.deployPath}</span>; echo "设置文件权限..."; chmod -R 755 .; echo "✅ 权限设置完成"; exit 0`</span>;
  
  <span class="hljs-title function_">runCommand</span>(<span class="hljs-string">`ssh -o ConnectTimeout=30 <span class="hljs-subst">${config.server}</span> "<span class="hljs-subst">${permissionCommands}</span>"`</span>, <span class="hljs-string">'设置文件权限'</span>);

  <span class="hljs-comment">// 7. 验证部署</span>
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'🔍 验证部署结果...'</span>, colors.<span class="hljs-property">blue</span>);
  <span class="hljs-title function_">runCommand</span>(
    <span class="hljs-string">`ssh -o ConnectTimeout=10 <span class="hljs-subst">${config.server}</span> "cd <span class="hljs-subst">${config.deployPath}</span> &amp;&amp; ls -la &amp;&amp; echo '--- 文件统计 ---' &amp;&amp; find . -type f | wc -l; exit"`</span>,
    <span class="hljs-string">'检查部署目录'</span>
  );

  <span class="hljs-title function_">log</span>(<span class="hljs-string">'\n🎉 部署完成！'</span>, colors.<span class="hljs-property">green</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`🌐 请访问: http://<span class="hljs-subst">${config.server.split(<span class="hljs-string">'@'</span>)[<span class="hljs-number">1</span>]}</span>`</span>, colors.<span class="hljs-property">green</span>)
  <span class="hljs-title function_">log</span>(<span class="hljs-string">'='</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">50</span>))
}

<span class="hljs-comment">// 执行部署</span>
<span class="hljs-title function_">deploy</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
  <span class="hljs-title function_">log</span>(<span class="hljs-string">`💥 部署过程出现错误: <span class="hljs-subst">${error.message}</span>`</span>, colors.<span class="hljs-property">red</span>)
  process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)
})
</code></pre>
<p><strong>这脚本干了啥？</strong></p>
<ol>
<li>自动检查有没有打包文件，没有就先打包</li>
<li>测试服务器连接（别传到一半断了）</li>
<li>备份服务器上的旧文件（万一新版本有问题能回滚）</li>
<li>上传所有新文件</li>
<li>设置好权限让Nginx能访问</li>
</ol>
<h2 data-id="heading-2">第三步：配置打包命令</h2>
<p>打开<code>package.json</code>，在<code>scripts</code>里加一行：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite build"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"preview"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite preview"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"deploy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite build &amp;&amp; node deploy.js"</span>
<span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre>
<p>就这么简单！</p>
<h2 data-id="heading-3">开始享受一键部署</h2>
<p>以后每次改完代码需要部署的时候，终端里输入：</p>
<pre><code class="hljs language-bash" lang="bash">npm run deploy
</code></pre>
<p>然后你就会看到彩色的日志在跑，<strong>打包→上传→部署</strong>一气呵成。等出现<code>🎉 部署完成！</code>的时候，刷新浏览器就能看到新版本了。没看到记得重启一下nginx。</p>
<p><strong>是不是超简单？</strong></p>
<p>以后再也不用打开一堆工具手动传文件了，改完代码一个命令搞定，省下的时间够你多摸几次鱼了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【hvigor专栏】OpenHarmony应用开发-hvigor插件之动态修改应用hap文件名]]></title>    <link>https://juejin.cn/post/7573300346262945846</link>    <guid>https://juejin.cn/post/7573300346262945846</guid>    <pubDate>2025-11-17T08:30:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573300346262945846" data-draft-id="7573486671296643114" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【hvigor专栏】OpenHarmony应用开发-hvigor插件之动态修改应用hap文件名"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-11-17T08:30:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Winslei"/> <meta itemprop="url" content="https://juejin.cn/user/4336129592008104"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【hvigor专栏】OpenHarmony应用开发-hvigor插件之动态修改应用hap文件名
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4336129592008104/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Winslei
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:30:03.000Z" title="Mon Nov 17 2025 08:30:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在OpenHarmony应用开发中，动态修改应用hap文件名是较为常见的功能，比如文件名包含版本号、构建时间、编译模式等等。下文会以一个完整的示例为大家讲述如何实现此功能。</p>
<h2 data-id="heading-1">开发环境</h2>
<p><strong>DevEco Studio：</strong> DevEco Studio 6.0.0 Release（Build Version： 6.0.0.858）</p>
<h2 data-id="heading-2">开发流程</h2>
<h3 data-id="heading-3">前置步骤</h3>
<ol>
<li>
<p>创建新工程。</p>
</li>
<li>
<p>编译工程，可以看到<code>build/default/outputs/default/</code>目录下生成了名为<strong>entry-default-unsigned.hap</strong>的默认hap。</p>
</li>
</ol>
<h3 data-id="heading-4">新增artifactName</h3>
<p>在<code>entry</code>模块的<code>build-profile.json5</code>下新增</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  ···
  <span class="hljs-attr">"targets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"default"</span><span class="hljs-punctuation">,</span>
      ···
      <span class="hljs-attr">"output"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"artifactName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"samples"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 data-id="heading-5">新增hvigor任务</h3>
<p>在根目录<code>hvigorfile.ts</code>里修改为以下代码</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { appTasks, <span class="hljs-title class_">OhosAppContext</span>, <span class="hljs-title class_">OhosHapContext</span>, <span class="hljs-title class_">OhosPluginId</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos/hvigor-ohos-plugin'</span>;
<span class="hljs-keyword">import</span> { hvigor } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ohos/hvigor'</span>;

<span class="hljs-comment">// 动态修改应用hap文件名</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">dynamicChangeNamePlugin</span>(<span class="hljs-params"/>): <span class="hljs-title class_">HvigorPlugin</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">pluginId</span>: <span class="hljs-string">'dynamicChangeNamePlugin'</span>,
    <span class="hljs-title function_">context</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">data</span>: <span class="hljs-string">'modify output name'</span>
      };
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">apply</span>(<span class="hljs-attr">currentNode</span>: <span class="hljs-title class_">HvigorNode</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
      <span class="hljs-comment">// 获取app插件的上下文对象</span>
      <span class="hljs-keyword">const</span> appContext = currentNode.<span class="hljs-title function_">getContext</span>(<span class="hljs-title class_">OhosPluginId</span>.<span class="hljs-property">OHOS_APP_PLUGIN</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OhosAppContext</span>;
      <span class="hljs-comment">// 通过上下文对象获取从根目录build-profile.json5文件中读出来的obj对象</span>
      <span class="hljs-keyword">const</span> buildProfileOpt = appContext.<span class="hljs-title function_">getBuildProfileOpt</span>();
      <span class="hljs-keyword">const</span> appJsonOpt = appContext.<span class="hljs-title function_">getAppJsonOpt</span>();
      <span class="hljs-comment">// 修改obj对象为想要的，此处举例修改app中的signingConfigs</span>
      <span class="hljs-keyword">const</span> products = buildProfileOpt.<span class="hljs-property">app</span>.<span class="hljs-property">products</span>;
      <span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
      <span class="hljs-keyword">let</span> formatDate = date.<span class="hljs-title function_">getFullYear</span>().<span class="hljs-title function_">toString</span>() + (date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>) +
      date.<span class="hljs-title function_">getDate</span>().<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>) + <span class="hljs-string">'_'</span> + date.<span class="hljs-title function_">getHours</span>().<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>) +
      date.<span class="hljs-title function_">getMinutes</span>().<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>) + date.<span class="hljs-title function_">getSeconds</span>().<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> product <span class="hljs-keyword">of</span> products) {
        <span class="hljs-keyword">if</span> (product.<span class="hljs-property">name</span> == <span class="hljs-string">'default'</span>) {
          product.<span class="hljs-property">output</span>.<span class="hljs-property">artifactName</span> = formatDate + <span class="hljs-string">'_'</span> + appJsonOpt.<span class="hljs-property">app</span>.<span class="hljs-property">versionName</span> + <span class="hljs-string">'_'</span> +
          product.<span class="hljs-property">output</span>.<span class="hljs-property">artifactName</span> + <span class="hljs-string">'_'</span> + appContext.<span class="hljs-title function_">getBuildMode</span>();
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`output app name: <span class="hljs-subst">${product.output.artifactName}</span>`</span>);
        }
      }
      <span class="hljs-comment">// 将obj对象设置回上下文对象以使能到构建的过程与结果中</span>
      appContext.<span class="hljs-title function_">setBuildProfileOpt</span>(buildProfileOpt);
      hvigor.<span class="hljs-title function_">nodesEvaluated</span>(<span class="hljs-keyword">async</span> () =&gt; {
        currentNode.<span class="hljs-title function_">subNodes</span>(<span class="hljs-function">(<span class="hljs-params">node: HvigorNode</span>) =&gt;</span> {
          <span class="hljs-comment">// 获取hpp插件的上下文对象</span>
          <span class="hljs-keyword">const</span> hapContext = node.<span class="hljs-title function_">getContext</span>(<span class="hljs-title class_">OhosPluginId</span>.<span class="hljs-property">OHOS_HAP_PLUGIN</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OhosHapContext</span>;
          <span class="hljs-comment">// 通过上下文对象获取从根目录build-profile.json5文件中读出来的obj对象</span>
          <span class="hljs-keyword">const</span> hapBuildProfileOpt = hapContext?.<span class="hljs-title function_">getBuildProfileOpt</span>();
          <span class="hljs-keyword">if</span> (hapBuildProfileOpt != <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">const</span> targets = hapBuildProfileOpt[<span class="hljs-string">'targets'</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> target <span class="hljs-keyword">of</span> targets) {
              <span class="hljs-keyword">if</span> (target.<span class="hljs-property">name</span> == <span class="hljs-string">'default'</span> &amp;&amp; target.<span class="hljs-property">output</span>?.<span class="hljs-property">artifactName</span> != <span class="hljs-literal">undefined</span>) {
                target.<span class="hljs-property">output</span>.<span class="hljs-property">artifactName</span> = formatDate + <span class="hljs-string">'_'</span> + appJsonOpt.<span class="hljs-property">app</span>.<span class="hljs-property">versionName</span> + <span class="hljs-string">'_'</span> +
                target.<span class="hljs-property">output</span>.<span class="hljs-property">artifactName</span> + <span class="hljs-string">'_'</span> + appContext.<span class="hljs-title function_">getBuildMode</span>();
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`output hap name: <span class="hljs-subst">${target.output?.artifactName}</span>`</span>);
              }
            }
            hapContext.<span class="hljs-title function_">setBuildProfileOpt</span>(hapBuildProfileOpt);
          }
        })
      })
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">system</span>: appTasks, <span class="hljs-comment">/* Built-in plugin of Hvigor. It cannot be modified. */</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">dynamicChangeNamePlugin</span>()
  ]       <span class="hljs-comment">/* Custom plugin to extend the functionality of Hvigor. */</span>
}
</code></pre>
<h3 data-id="heading-6">编译验证</h3>
<ol>
<li>编译工程，可以看到<code>build/default/outputs/default/</code>目录下生成了名为<strong>20251117_113634_1.0.0_samples_debug-unsigned.hap</strong>的自定义文件名hap，其中包含了构建时间、版本号、自定义产物名、编译模式、是否签名等信息。</li>
</ol>
<h3 data-id="heading-7">注意事项</h3>
<ol>
<li>如果自定义文件名里包含了时间规则，那么因为时间的变化，每次打出的hap都不会覆盖前一个，而是会创建一个新的，从而导致hap越来越多，本地工程体积越来越大。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[17. Vue3 业务组件库按需加载的实现原理]]></title>    <link>https://juejin.cn/post/7572480736362119174</link>    <guid>https://juejin.cn/post/7572480736362119174</guid>    <pubDate>2025-11-16T09:53:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572480736362119174" data-draft-id="7567194020462133274" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="17. Vue3 业务组件库按需加载的实现原理"/> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"/> <meta itemprop="datePublished" content="2025-11-16T09:53:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Cobyte"/> <meta itemprop="url" content="https://juejin.cn/user/668147376989517"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            17. Vue3 业务组件库按需加载的实现原理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/668147376989517/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Cobyte
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T09:53:14.000Z" title="Sun Nov 16 2025 09:53:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    31
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1:first-child,.markdown-body h2:first-child,.markdown-body h3:first-child,.markdown-body h4:first-child,.markdown-body h5:first-child,.markdown-body h6:first-child{margin-top:-1.5rem;margin-bottom:1rem}.markdown-body h1:before,.markdown-body h2:before,.markdown-body h3:before,.markdown-body h4:before,.markdown-body h5:before,.markdown-body h6:before{content:"#";display:inline-block;color:#3eaf7c;padding-right:.23em}.markdown-body h1{position:relative;font-size:2.5rem;margin-bottom:5px}.markdown-body h1:before{font-size:2.5rem}.markdown-body h2{padding-bottom:.5rem;font-size:2.2rem;border-bottom:1px solid #ececec}.markdown-body h3{font-size:1.5rem;padding-bottom:0}.markdown-body h4{font-size:1.25rem}.markdown-body h5{font-size:1rem}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body strong{color:#3eaf7c}.markdown-body img{max-width:100%;border-radius:2px;display:block;margin:auto;border:3px solid rgba(62,175,124,.2)}.markdown-body hr{border:none;border-top:1px solid #3eaf7c;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;overflow-x:auto;padding:.2rem .5rem;margin:0;color:#3eaf7c;font-weight:700;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:6px;border:2px solid #3eaf7c}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{font-weight:500;text-decoration:none;color:#3eaf7c}.markdown-body a:active,.markdown-body a:hover{border-bottom:1.5px solid #3eaf7c}.markdown-body a:before{content:"⇲"}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #3eaf7c}.markdown-body thead{background:#3eaf7c;color:#fff;text-align:left}.markdown-body tr:nth-child(2n){background-color:rgba(62,175,124,.2)}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:.5rem solid;border-color:#42b983;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{outline:none;border:none;border-left:4px solid #3eaf7c;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary::-webkit-details-marker{color:#3eaf7c}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body ol li::marker{color:#3eaf7c}.markdown-body ul li{list-style:none}.markdown-body ul li:before{content:"•";margin-right:4px;color:#3eaf7c}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>最近在公司实现一个业务组件库按需加载的需求。简单来说，有两个需求，第一个是实现业务组件库的按需加载，第二，因为业务组件库里面有引用了类似 Element Plus 的第三方组件库，所以在实现业务组件库按需加载的同时，业务组件库里面的引用的第三方组件库也要实现按需加载。</p>
<p>作为一个编程技术人员，即便有了AI，也需要研究底层的技术原理，甚至需要比没有AI的时代，需要更加深入研究，在AI时代，基础的都通过AI实现了，只有AI解决不了的问题，最终还得靠你自己的专业知识去解决，而这将是你的核心竞争力的体现，所以在AI时代对技术人员的技术素养要求将更加的高。</p>
<p>扯远了，我们回到业务组件库按需加载的实现原理的主题上来。</p>
<p>一般在项目中如果没有进行组件库按需加载配置，都是一开始就全量加载进行全局组件注册，这样就等于整个组件库在初始化的时候就全部加载了，如果在追求性能的项目中，这是不可接受的。这时我们就要实现组件库的按需加载，来提高性能。</p>
<h3 data-id="heading-1">按需加载的基本实现原理</h3>
<p>首先什么是按需加载？</p>
<p>所谓按需加载，顾名思义就是有需要就加载，不需要就不加载，比如 <code>Element Plus</code> 组件库有几十个组件，可能在我们的项目只用到了到了其中一个组件 <code>&lt;el-button&gt;</code>，那么我们就希望只加载跟这个按钮组件相关的代码，从而达到减少打包体积的效果。</p>
<p>按需加载最简单的实现方式就是手动设置，实现如下：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElButton</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus/es/components/button'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'element-plus/es/components/button/style/index'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">components</span>: { <span class="hljs-title class_">ElButton</span> },
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>我们像上述例子这样手动引用第三方组件库的话，在打包的时候就只会打包引用到的组件，因为目前的开源组件库基本都实现了利于 Tree Shaking 的 <code>ESM</code> 模块化实现。</p>
<p>如果每个业务组件都需要进行上述设置，其实还是挺繁琐的，所以我们希望只在 template 中直接调用就好，其他什么设置都不需要，就像全局注册组件那样使用。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>而剩下部分的代码，我们希望在打包或者运行的时候自动设置上去。主要是以下部分的代码：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElButton</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus/es/components/button'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'element-plus/es/components/button/style/index'</span>
</code></pre>
<p>上述部分的代码，希望自动加载，而不需要手动设置。整个所谓按需加载所需要实现的就是上述的功能。</p>
<p>那么怎么实现呢？</p>
<p>首先上述模板代码的编译结果如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { createTextVNode <span class="hljs-keyword">as</span> _createTextVNode, resolveComponent <span class="hljs-keyword">as</span> _resolveComponent, withCtx <span class="hljs-keyword">as</span> _withCtx, createVNode <span class="hljs-keyword">as</span> _createVNode, openBlock <span class="hljs-keyword">as</span> _openBlock, createElementBlock <span class="hljs-keyword">as</span> _createElementBlock } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">const</span> _component_el_button = <span class="hljs-title function_">_resolveComponent</span>(<span class="hljs-string">"el-button"</span>)

  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createElementBlock</span>(<span class="hljs-string">"template"</span>, <span class="hljs-literal">null</span>, [
    <span class="hljs-title function_">_createVNode</span>(_component_el_button, <span class="hljs-literal">null</span>, {
      <span class="hljs-attr">default</span>: <span class="hljs-title function_">_withCtx</span>(<span class="hljs-function">() =&gt;</span> [
        <span class="hljs-title function_">_createTextVNode</span>(<span class="hljs-string">"按钮"</span>)
      ], <span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>),
      <span class="hljs-attr">_</span>: <span class="hljs-number">1</span> <span class="hljs-comment">/* STABLE */</span>
    })
  ]))
}
</code></pre>
<p>我们只需要找到 Vue3 的内置函数 <code>_resolveComponent("el-button")</code> 部分，然后替换成对应的组件代码即可。例如：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-addition">+ import { ElButton } from 'element-plus/es/components/button'</span>
<span class="hljs-addition">+ import 'element-plus/es/components/button/style/index'</span>
import { createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache, $props, $setup, $data, $options) {
<span class="hljs-deletion">-  const _component_el_button = _resolveComponent("el-button")</span>
<span class="hljs-addition">+ const _component_el_button = ElButton</span>

  return (_openBlock(), _createElementBlock("template", null, [
    _createVNode(_component_el_button, null, {
      default: _withCtx(() =&gt; [
        _createTextVNode("按钮")
      ], undefined, true),
      _: 1 /* STABLE */
    })
  ]))
}
</code></pre>
<p>上述就是组件库按需加载的基本实现原理。</p>
<h3 data-id="heading-2">使用 Vite 打包组件库</h3>
<p>为了更好还原实际场景，我们快速创建一个组件库项目并且通过 Vite 进行打包。
首先创建一个 <code>cobyte-vite-ui</code> 的组件库目录，在根目录下初始化 Node 项目，执行 <code>pnpm init</code>, 会自动生成 <code>package.json</code>  文件，内容如下：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cobyte-vite-ui"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"index.js"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"keywords"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"author"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"license"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ISC"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"packageManager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"pnpm@10.20.0"</span><span class="hljs-punctuation">,</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>在根目录新建 <code>pnpm-workspace.yaml</code> 文件进行 Monorepo 项目配置：</p>
<pre><code class="hljs language-markdown" lang="markdown">packages:
<span class="hljs-bullet">  -</span> packages/*
<span class="hljs-bullet">  -</span> play
</code></pre>
<p>总的目录结构如下：</p>
<pre><code class="hljs language-go" lang="go">├── packages
│   ├── components
│   ├── hooks
│   └── utils
├── play
├── <span class="hljs-keyword">package</span>.json
└── pnpm-workspace.yaml
</code></pre>
<p>接着我们安装一些必要的依赖：</p>
<pre><code class="hljs language-sql" lang="sql">pnpm <span class="hljs-keyword">add</span> vite typescript <span class="hljs-variable">@vitejs</span><span class="hljs-operator">/</span>plugin<span class="hljs-operator">-</span>vue sass <span class="hljs-variable">@types</span><span class="hljs-operator">/</span>node <span class="hljs-operator">-</span>D <span class="hljs-operator">-</span>w
</code></pre>
<p>接着我们安装一下 vue 依赖：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> vue -w
</code></pre>
<p>基础依赖安装完毕，我们设置一下 TS 的配置，因为我们这个项目是一个 TS 的项目，在根目录创建一个 <code>tsconfig.json</code>，配置内容可以简单设置如下：</p>
<pre><code class="hljs language-js" lang="js">{
    <span class="hljs-string">"compilerOptions"</span>: {
      <span class="hljs-string">"target"</span>: <span class="hljs-string">"ESNext"</span>,
      <span class="hljs-string">"module"</span>: <span class="hljs-string">"NodeNext"</span>,
      <span class="hljs-string">"sourceMap"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 关键：启用源映射</span>
      <span class="hljs-string">"outDir"</span>: <span class="hljs-string">"./dist"</span>, <span class="hljs-comment">// 可选：指定输出目录</span>
      <span class="hljs-string">"esModuleInterop"</span>: <span class="hljs-literal">true</span>
    }
}
</code></pre>
<p>接着我们就在 <code>packages/components</code> 目录下创建一个测试按钮组件</p>
<p>目录路径：<code>packages/components/button/button.vue</code>，内容如下：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>测试按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-title function_">defineOptions</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'co-button'</span>,
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">button</span> {
  <span class="hljs-attribute">color</span>: red;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p>目录路径：<code>packages/components/button/index.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> button <span class="hljs-keyword">from</span> <span class="hljs-string">"./button.vue"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">CoButton</span> = button;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CoButton</span>;
</code></pre>
<p>目录路径：<code>packages/components/components.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">CoButton</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./button'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
    <span class="hljs-title class_">CoButton</span>
]
</code></pre>
<p>将所有组件集中在一个数组中统一导出，方便批量管理和使用。</p>
<p>目录路径：<code>packages/components/defaults.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">App</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> components <span class="hljs-keyword">from</span> <span class="hljs-string">'./components'</span>;

<span class="hljs-keyword">const</span> install = <span class="hljs-keyword">function</span> (<span class="hljs-params">app: App</span>) {
    components.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">component</span> =&gt;</span> {
        app.<span class="hljs-title function_">component</span>(component.<span class="hljs-property">name</span>, component);
    });
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    install
};
</code></pre>
<p>目录路径：<code>packages/components/index.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./button'</span>;

<span class="hljs-keyword">import</span> install <span class="hljs-keyword">from</span>  <span class="hljs-string">'./defaults'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> install;
</code></pre>
<p>我们再配置一个测试文件，目录路径：<code>packages/utils/index.ts</code>，内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testUtils</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'testUtils'</span>);
}
</code></pre>
<p>如果大家对创建组件库比较有经验的话，就知道上述步骤，是 Vue3 组件库的基础设置，各大组件库的实现虽然差异很大，但最核心机制都可以简单归纳为上述设置内容。
大家如果想详细了解更多也可以看看本栏目前面章节的内容。</p>
<p>接着我们就到了我们最核心的组件库打包的环节了，我们在根本目录创建一个 <code>vite.config.ts</code>，设置内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-vue"</span>;
<span class="hljs-keyword">import</span> path, { resolve } <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">"fs"</span>;

<span class="hljs-comment">// 动态获取组件目录列表</span>
<span class="hljs-keyword">const</span> componentsDir = <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./packages/components"</span>);
<span class="hljs-keyword">const</span> modules = fs.<span class="hljs-title function_">readdirSync</span>(componentsDir).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">join</span>(componentsDir, name);
    <span class="hljs-comment">// 只获取目录，排除文件</span>
    <span class="hljs-keyword">return</span> fs.<span class="hljs-title function_">statSync</span>(fullPath).<span class="hljs-title function_">isDirectory</span>();
});

<span class="hljs-keyword">const</span> entryArr = {
    <span class="hljs-comment">// 主入口</span>
    <span class="hljs-attr">index</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./packages/components/index.ts"</span>),

    <span class="hljs-comment">// 工具入口</span>
    <span class="hljs-attr">utils</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./packages/utils/index.ts"</span>),
};

<span class="hljs-comment">// 为每个组件创建独立入口</span>
modules.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
    entryArr[<span class="hljs-string">`components/<span class="hljs-subst">${name}</span>/index`</span>] = <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">`./packages/components/<span class="hljs-subst">${name}</span>/index.ts`</span>);
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(<span class="hljs-function">(<span class="hljs-params">{ command, mode }</span>) =&gt;</span> {
    <span class="hljs-comment">// 主构建配置</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">plugins</span>: [
            <span class="hljs-title function_">vue</span>(),
        ],
        <span class="hljs-attr">build</span>: {
            <span class="hljs-attr">lib</span>: {
                <span class="hljs-attr">entry</span>: entryArr,
                <span class="hljs-attr">formats</span>: [<span class="hljs-string">"es"</span>], <span class="hljs-comment">// 只构建 ES 模块</span>
                <span class="hljs-attr">cssFileName</span>: <span class="hljs-string">"style"</span>,
            },
            <span class="hljs-attr">rollupOptions</span>: {
                <span class="hljs-attr">external</span>: [
                    <span class="hljs-string">"vue"</span>,
                ],
                <span class="hljs-attr">output</span>: {
                    <span class="hljs-attr">format</span>: <span class="hljs-string">"es"</span>,
                    <span class="hljs-attr">preserveModules</span>: <span class="hljs-literal">true</span>,
                },
            },
        },
    };
});
</code></pre>
<p>设置完 Vite 配置文件后，我们还要设置 <code>packages.json</code> 中的打包命令脚本配置，设置如下：</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"vite build"</span>
  },
</code></pre>
<p>这样我们就可以在根目录运行打包命令了：<code>pnpm build</code>。</p>
<p>运行结果如下，我们成功打包了我们的组件库。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c195ef5bfdd043c2a61e6435e0d4c4f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=uSri%2FlN4ICmesLuFyDi%2BF3Vssl8%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-3">通过 pnpm 安装本地 npm 包</h3>
<p>接着我们在根目录下创建一个测试项目：</p>
<pre><code class="hljs language-lua" lang="lua">pnpm <span class="hljs-built_in">create</span> vite play <span class="hljs-comment">--template vue-ts</span>
</code></pre>
<p>上述 play 就是测试项目目录，我们原本就建了一个 play 目录，现在这条命令会直接在 play 目录中生成一个使用 Vite 创建的 Vue 项目。</p>
<p>接着我们修改根目录的 package.json 文件：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-deletion">- "main": "index.js",</span>
<span class="hljs-addition">+ "module": "/dist/index.mjs",</span>
</code></pre>
<p>接着我们进入 play 目录，通过 pnpm 安装本地 npm 包，命令如下：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> ../
</code></pre>
<p>运行完上述命令，我们可以看到 <code>./play/packages.json</code> 文件变化如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3f21a2e6b8f4ee08a4a56ae78e9f51e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=GmvFW3i3GJ9n8Fuw656PlJx5h%2Fc%3D" alt="image.png" loading="lazy"/></p>
<p>可以看到我们成功把我们本地的 npm 包安装到 play 测试项目中了。</p>
<p>接着修改 <code>./play/main.ts</code> 内容如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">CobyteViteUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'cobyte-vite-ui'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'cobyte-vite-ui/dist/style.css'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
app.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">CobyteViteUI</span>)
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<p>我们直接引用我们本地创建的 npm 包。</p>
<p>接着修改 <code>./play/App.vue</code> 内容如下：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">co-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">co-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>最后我们运行 play 测试项目，结果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74f6c189f9d44171887736447e2e142d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=kvnojOly9beWhKfj52wsCyNla5U%3D" alt="image.png" loading="lazy"/></p>
<p>我们可以看到成功运行了本地组件库的 npm 包。</p>
<p>接下来我们希望不进行完整引入组件库：</p>
<pre><code class="hljs language-diff" lang="diff">import { createApp } from 'vue'
import App from './App.vue'
<span class="hljs-deletion">- import CobyteViteUI from 'cobyte-vite-ui'</span>
<span class="hljs-deletion">- import 'cobyte-vite-ui/dist/style.css'</span>

const app = createApp(App)
<span class="hljs-deletion">- app.use(CobyteViteUI)</span>
app.mount('#app')
</code></pre>
<p>即便这样我们同样可以在测试项目中使用我们的测试组件。</p>
<h3 data-id="heading-4">通过静态分析实现按需加载</h3>
<p>根据上文我们知道 App.vue 的模板内容会被编译成：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { resolveComponent <span class="hljs-keyword">as</span> _resolveComponent, createVNode <span class="hljs-keyword">as</span> _createVNode, openBlock <span class="hljs-keyword">as</span> _openBlock, createElementBlock <span class="hljs-keyword">as</span> _createElementBlock } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">const</span> _component_co_button = <span class="hljs-title function_">_resolveComponent</span>(<span class="hljs-string">"co-button"</span>)

  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createElementBlock</span>(<span class="hljs-string">"template"</span>, <span class="hljs-literal">null</span>, [
    <span class="hljs-title function_">_createVNode</span>(_component_co_button)
  ]))
}
</code></pre>
<p>那么根据上文我们知道需要把 <code>_resolveComponent("co-button")</code> 部分替换成对应的组件对象，内容如下：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-addition">+ import CoButton from 'cobyte-vite-ui/dist/components/button'</span>
<span class="hljs-addition">+ import 'cobyte-vite-ui/dist/style.css'</span>
import { resolveComponent as _resolveComponent, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

export function render(_ctx, _cache, $props, $setup, $data, $options) {
<span class="hljs-deletion">-  const _component_co_button = _resolveComponent("co-button")</span>
<span class="hljs-addition">+  const _component_co_button = CoButton</span>

  return (_openBlock(), _createElementBlock("template", null, [
    _createVNode(_component_co_button)
  ]))
}
</code></pre>
<p>那么要实现上述功能，我们得通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2Fguide%2Fapi-plugin" target="_blank" title="https://cn.vitejs.dev/guide/api-plugin" ref="nofollow noopener noreferrer">Vite 插件</a>来实现，我们在上面安装了一个 <code>@vitejs/plugin-vue</code> 插件，这个 Vite 插件的主要功能就是把 <code>.vue</code> 文件编译成上述的 js 内容。那么我们这样在它的后面继续添加一个插件在编译后的 js 内容中去实现上述替换功能即可。</p>
<p>我们在 <code>./packages/utils/index.ts</code> 文件中实现这个自动加载组件的 Vite 插件，实现如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MagicString</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'magic-string'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">VitePluginAutoComponents</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// 插件名称，用于调试和错误信息</span>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'vite-plugin-auto-component'</span>,

    <span class="hljs-comment">// transform 钩子函数，在转换模块时调用</span>
    <span class="hljs-comment">// code: 文件内容，id: 文件路径</span>
    <span class="hljs-title function_">transform</span>(<span class="hljs-params">code, id</span>) {
      <span class="hljs-comment">// 使用正则表达式检查文件是否为.vue文件</span>
      <span class="hljs-comment">// 如果不是.vue文件，不进行处理</span>
      <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/\.vue$/</span>.<span class="hljs-title function_">test</span>(id)) {
          <span class="hljs-comment">// 创建 MagicString 实例，用于高效地修改字符串并生成 source map</span>
          <span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MagicString</span>(code)
          <span class="hljs-comment">// 初始化结果数组，用于存储匹配到的组件信息</span>
          <span class="hljs-keyword">const</span> results = []

          <span class="hljs-comment">// 使用 matchAll 方法查找所有匹配的 resolveComponent 调用</span>
          <span class="hljs-comment">// 正则表达式解释：</span>
          <span class="hljs-comment">// _?resolveComponent\d* - 匹配可能的函数名变体（可能带下划线或数字后缀）</span>
          <span class="hljs-comment">// \("(.+?)"\) - 匹配括号内的字符串参数</span>
          <span class="hljs-comment">// g - 全局匹配</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> code.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/_?resolveComponent\d*\("(.+?)"\)/g</span>)) {
              <span class="hljs-comment">// match[1] 是第一个捕获组，即组件名称字符串</span>
              <span class="hljs-keyword">const</span> matchedName = match[<span class="hljs-number">1</span>]
              <span class="hljs-comment">// 检查匹配是否有效：</span>
              <span class="hljs-comment">// match.index != null - 确保有匹配位置</span>
              <span class="hljs-comment">// matchedName - 确保捕获到组件名</span>
              <span class="hljs-comment">// !matchedName.startsWith('_') - 确保组件名不以_开头（可能是内部组件）</span>
              <span class="hljs-keyword">if</span> (match.<span class="hljs-property">index</span> != <span class="hljs-literal">null</span> &amp;&amp; matchedName &amp;&amp; !matchedName.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'_'</span>)) {
                  <span class="hljs-comment">// 计算匹配字符串的起始位置</span>
                  <span class="hljs-keyword">const</span> start = match.<span class="hljs-property">index</span>
                  <span class="hljs-comment">// 计算匹配字符串的结束位置</span>
                  <span class="hljs-keyword">const</span> end = start + match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>
                  <span class="hljs-comment">// 将匹配信息存入结果数组</span>
                  results.<span class="hljs-title function_">push</span>({
                      <span class="hljs-attr">rawName</span>: matchedName,  <span class="hljs-comment">// 原始组件名称</span>
                      <span class="hljs-comment">// 创建替换函数，使用 MagicString 的 overwrite 方法替换指定范围的文本</span>
                      <span class="hljs-attr">replace</span>: <span class="hljs-function"><span class="hljs-params">resolved</span> =&gt;</span> s.<span class="hljs-title function_">overwrite</span>(start, end, resolved),
                  })
              }
          }

          <span class="hljs-comment">// 遍历所有匹配结果进行处理</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { rawName, replace } <span class="hljs-keyword">of</span> results) {
              <span class="hljs-comment">// 定义要替换的变量名（这里暂时编码为 CoButton）</span>
              <span class="hljs-keyword">const</span> varName = <span class="hljs-string">`CoButton`</span>
              <span class="hljs-comment">// 在代码开头添加导入语句：</span>
              <span class="hljs-comment">// 1. 导入 CoButton 组件</span>
              <span class="hljs-comment">// 2. 导入样式文件</span>
              s.<span class="hljs-title function_">prepend</span>(<span class="hljs-string">`import CoButton from 'cobyte-vite-ui/dist/components/button';\nimport 'cobyte-vite-ui/dist/style.css';\n`</span>)

              <span class="hljs-comment">// 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名</span>
              <span class="hljs-title function_">replace</span>(varName)
          }

          <span class="hljs-comment">// 返回转换后的代码</span>
          <span class="hljs-keyword">return</span> {
              <span class="hljs-attr">code</span>: s.<span class="hljs-title function_">toString</span>(),  <span class="hljs-comment">// 转换后的代码字符串</span>
              <span class="hljs-attr">map</span>: <span class="hljs-literal">null</span>, 
          }
      }
    },
  }
}
</code></pre>
<p>我们在上述 Vite 插件中使用到了一个新工具库 <code>magic-string</code>，我们需要安装一下它的依赖：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> magic-<span class="hljs-built_in">string</span> -D -w
</code></pre>
<p><code>magic-string</code> 是一个专注于字符串操作，主要作用是对源代码可以进行<strong>精准的插入、删除、替换等操作</strong>。</p>
<p>上述编写的 Vite 的插件主要是实现在<code>.vue</code> 文件中查找所有形如 <code>resolveComponent("xxx")</code> 的函数调用，对于每一个找到的调用，它会在文件顶部添加一个固定的导入语句，例如导入 <code>CoButton</code> 组件和样式。最后把找到的<code>resolveComponent("xxx")</code> 替换成对应的组件，例如 <code>CoButton</code>。</p>
<p>然后我们在根目录重新打包，接着在 play 目录中的 <code>vite.config.ts</code> 文件中进行以下修改：</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
<span class="hljs-addition">+ import AutoComponents from 'cobyte-vite-ui/dist/utils'</span>

// https://vite.dev/config/
export default defineConfig({
<span class="hljs-deletion">-  plugins: [vue()],</span>
<span class="hljs-addition">+  plugins: [vue(), AutoComponents()],</span>
})
</code></pre>
<p>接着我们再次重启 play 测试项目，我们可以看到即便我们不导入任何我们编写的组件库设置，我们依然可以在 play 项目中成功使用 <code>CoButton</code> 组件。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74f6c189f9d44171887736447e2e142d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=kvnojOly9beWhKfj52wsCyNla5U%3D" alt="image.png" loading="lazy"/></p>
<p>同时我们在网络窗口可以查看到 App.vue 文件的内容变化如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f36029b5c57d4c9ca82ddb0fecd2f3be~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=t1CzRagQrOlUssF9zNOZpEvdDqI%3D" alt="image.png" loading="lazy"/></p>
<p>可以看到<strong>我们通过静态分析代码，识别并替换 Vue3 的组件解析函数，成功实现了组件的自动导入功能</strong>。但上述实现为了快速验证功能，无论匹配到的组件名是什么，都导入 <code>CoButton</code> 组件，并替换为 <code>CoButton</code>。这显然是不正确的，应该根据匹配到的组件名动态导入对应的组件。</p>
<h3 data-id="heading-5">自动化路径解析</h3>
<p>因为我们的组件编译后的调用变成 <code>_resolveComponent("co-button")</code>，组件名称变成了 <code>co-button</code>，而我们在导入的语句是这样的 <code>import CoButton from 'cobyte-vite-ui/dist/components/button'</code>，组件名称又需要变成 <code>CoButton</code>，所以我们需要把匹配到的 <code>co-button</code> 变成 <code>CoButton</code>。</p>
<p>代码迭代如下：</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-addition">+ // 将字符串转换为帕斯卡命名（即大驼峰，每个单词首字母大写）</span>
<span class="hljs-addition">+ export function pascalCase(str: string) {</span>
<span class="hljs-addition">+    return capitalize(camelCase(str))</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ // 将字符串转换为驼峰命名  </span>
<span class="hljs-addition">+ export function camelCase(str: string) {</span>
<span class="hljs-addition">+    return str.replace(/-(\w)/g, (_, c) =&gt; (c ? c.toUpperCase() : ''))</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ // 将字符串的首字母大写，使用 charAt(0) 获取第一个字符并转换为大写，然后加上剩余字符串（从索引1开始）</span>
<span class="hljs-addition">+ export function capitalize(str: string) {</span>
<span class="hljs-addition">+    return str.charAt(0).toUpperCase() + str.slice(1)</span>
<span class="hljs-addition">+ }</span>

export default function VitePluginAutoComponents() {
    return {
      // 插件名称，用于调试和错误信息
      name: 'vite-plugin-auto-component',
  
      // transform 钩子函数，在转换模块时调用
      // code: 文件内容，id: 文件路径
      transform(code, id) {
        // 使用正则表达式检查文件是否为.vue文件
        // 如果不是.vue文件，不进行处理
        if(/\.vue$/.test(id)) {
            // 省略...
  
            // 遍历所有匹配结果进行处理
            for (const { rawName, replace } of results) {
<span class="hljs-addition">+                // 将字符串转换为大驼峰</span>
<span class="hljs-addition">+                const name = pascalCase(rawName)</span>
<span class="hljs-addition">+                // 只处理 Co 开头的组件</span>
<span class="hljs-addition">+                if (!name.match(/^Co[A-Z]/)) return</span>
                // 定义要替换的变量名
<span class="hljs-deletion">-                const varName = `CoButton`</span>
<span class="hljs-addition">+                const varName = name</span>
                // 在代码开头添加导入语句：
                // 1. 导入 CoButton 组件
                // 2. 导入样式文件
                s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/button';\nimport 'cobyte-vite-ui/dist/style.css';\n`)
  
                // 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名
                replace(varName)
            }
  
            // 返回转换后的代码
            return {
                code: s.toString(),  // 转换后的代码字符串
                map: null, 
            }
        }
      },
    }
}
</code></pre>
<p>经过上述实现还是存在以下问题，无论 <code>rawName</code> 是什么，组件都是从 <code>'cobyte-vite-ui/dist/components/button'</code> 这个固定路径导入。这意味着即使使用了 <code>resolveComponent("CoTable")</code>，插件依然会尝试从 <code>button</code> 文件导入，这显然是不正确的。理想情况下，导入路径应根据组件名动态生成。所以我们继续实现动态组件路径，例如 <code>CoTableColumn</code> 组件映射到 <code>'cobyte-vite-ui/dist/components/table-column'</code>。</p>
<p>我们上述的组件是 "CoButton"，那么转换过程则是：<br/>
"CoButton" -&gt; 去掉"Co" -&gt; "Button" -&gt; kebabCase -&gt; "button"。</p>
<p>我们通过实现一个 kebabCase 函数进行组件路径转换解析，实现如下：</p>
<pre><code class="hljs language-diff" lang="diff">// 省略...

<span class="hljs-addition">+ // 将驼峰命名的字符串转换为短横线分隔的字符串（即kebab-case）</span>
<span class="hljs-addition">+ export function kebabCase(key: string) {</span>
<span class="hljs-addition">+    const result = key.replace(/([A-Z])/g, ' $1').trim()</span>
<span class="hljs-addition">+    return result.split(' ').join('-').toLowerCase()</span>
<span class="hljs-addition">+ }</span>

export default function VitePluginAutoComponents() {
    return {
      // 插件名称，用于调试和错误信息
      name: 'vite-plugin-auto-component',
  
      // transform 钩子函数，在转换模块时调用
      // code: 文件内容，id: 文件路径
      transform(code, id) {
        // 使用正则表达式检查文件是否为.vue文件
        // 如果不是.vue文件，不进行处理
        if(/\.vue$/.test(id)) {
            // 省略...
  
            // 遍历所有匹配结果进行处理
            for (const { rawName, replace } of results) {
                // 将字符串转换为大驼峰
                const name = pascalCase(rawName)
                // 只处理 Co 开头的组件
                if (!name.match(/^Co[A-Z]/)) return
<span class="hljs-addition">+                // 组件路径转换</span>
<span class="hljs-addition">+                const partialName = kebabCase(name.slice(2))</span>
                // 定义要替换的变量名
                const varName = name
                // 在代码开头添加导入语句：
                // 1. 导入 CoButton 组件
                // 2. 导入样式文件
<span class="hljs-deletion">-                s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/button';\nimport 'cobyte-vite-ui/dist/style.css';\n`)</span>
<span class="hljs-addition">+                s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/${partialName}';\nimport 'cobyte-vite-ui/dist/style.css';\n`)</span>
  
                // 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名
                replace(varName)
            }
  
            // 返回转换后的代码
            return {
                code: s.toString(),  // 转换后的代码字符串
                map: null, 
            }
        }
      },
    }
}
</code></pre>
<p>经过上述迭代后，我们重新打包，重新启动 play 测试项目，我们发现我们的代码是能够正常运行的，说明我们上述的迭代是没有问题的。<strong>至此我们为组件自动导入提供了核心的路径解析能力</strong>。</p>
<h3 data-id="heading-6">引入解析器 (Resolver) 概念</h3>
<p>当前插件硬编码了组件库的路径和样式文件，只能用于特定的组件库（cobyte-vite-ui）。我们可以通过引入解析器(Resolver)，让插件支持不同的组件库，用户可以根据需要配置不同的解析器。</p>
<p>解析器的作用是根据组件名返回一个解析结果，包括组件的导入路径和样式文件路径以及组件原始名称。这样，插件就可以通过解析器返回的对象信息动态获取组件的导入信息，而不是固定写死。</p>
<p>在实现解析器之前，我们先设计解析器返回的对象结构如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> component = {
    name, <span class="hljs-comment">// 组件原始名称</span>
    <span class="hljs-attr">from</span>: <span class="hljs-string">`cobyte-vite-ui/dist/components/<span class="hljs-subst">${partialName}</span>`</span>, <span class="hljs-comment">// 组件的导入路径</span>
    <span class="hljs-attr">sideEffects</span>: [<span class="hljs-string">'cobyte-vite-ui/dist/style.css'</span>] <span class="hljs-comment">// 组件的样式文件路径</span>
}
</code></pre>
<p>为什么要这样设计？</p>
<ol>
<li>组件名 (name):<br/>
用于在导入语句中作为标识符。这里使用的是帕斯卡命名，因为它在 Vue 中通常用于组件注册和模板中。</li>
<li>导入路径 (from):<br/>
这里使用模板字符串动态构建导入路径。其中，<code>partialName</code> 是通过将组件名去掉前两个字符（即去掉"Co"）并转换为 kebab-case 得到的。<br/>
例如，组件名 "CoTableColumn" 转换为 "table-column"，然后拼接成路径 'cobyte-vite-ui/dist/components/table-column'。<br/>
这样设计是因为组件库的目录结构可能是按照 kebab-case 命名的，而组件在代码中是以帕斯卡命名使用的。</li>
<li>副作用 (sideEffects):<br/>
这是一个数组，指定在导入组件时需要同时导入的样式文件或其他资源。这里指定了组件库的全局样式文件。<br/>
注意：这个样式文件是全局的，也就是说，不管导入哪个组件，都会导入整个组件库的样式。这可能会造成样式冗余。<br/>
更精细的做法是为每个组件指定其对应的样式文件，例如：<br/>
sideEffects: [<code>cobyte-vite-ui/dist/components/${partialName}/style.css</code>]</li>
</ol>
<p>但是，我们当前组件库没有为每个组件单独提供样式文件，我们只提供了固定的全局样式文件。</p>
<p>上面设计解析器返回的对象封装了组件的完整导入信息，作为数据载体传递给后续处理函数，我们可以基于此进行迭代：</p>
<pre><code class="hljs language-diff" lang="diff">// 省略...

<span class="hljs-addition">+ // 根据传入的信息生成对应的导入语句字符串</span>
<span class="hljs-addition">+ export function stringifyImport(info) {</span>
<span class="hljs-addition">+    if (typeof info === 'string')</span>
<span class="hljs-addition">+      return `import '${info}'`</span>
<span class="hljs-addition">+    if (!info.as)</span>
<span class="hljs-addition">+      return `import '${info.from}'`</span>
<span class="hljs-addition">+    else if (info.name)</span>
<span class="hljs-addition">+      return `import { ${info.name} as ${info.as} } from '${info.from}'`</span>
<span class="hljs-addition">+    else</span>
<span class="hljs-addition">+      return `import ${info.as} from '${info.from}'`</span>
<span class="hljs-addition">+ }</span>
<span class="hljs-addition">+ // 根据组件的导入信息生成完整的导入语句，包括组件本身的导入和其副作用（如样式文件）的导入。</span>
<span class="hljs-addition">+ export function stringifyComponentImport({ as: name, from: path, name: importName, sideEffects }) {</span>
<span class="hljs-addition">+    const imports = [</span>
<span class="hljs-addition">+      // 生成组件导入语句</span>
<span class="hljs-addition">+      stringifyImport({ as: name, from: path, name: importName }),</span>
<span class="hljs-addition">+    ]</span>
  
<span class="hljs-addition">+    if (sideEffects) {</span>
<span class="hljs-addition">+      // 生成副作用导入语句</span>
<span class="hljs-addition">+      sideEffects.forEach(i =&gt; imports.push(stringifyImport(i)))</span>
<span class="hljs-addition">+    }</span>
  
<span class="hljs-addition">+    return imports.join(';')</span>
<span class="hljs-addition">+ }</span>

  export default function VitePluginAutoComponents() {
    return {
      // 插件名称，用于调试和错误信息
      name: 'vite-plugin-auto-component',
  
      // transform 钩子函数，在转换模块时调用
      // code: 文件内容，id: 文件路径
      transform(code, id) {
        // 使用正则表达式检查文件是否为.vue文件
        // 如果不是.vue文件，不进行处理
        if(/\.vue$/.test(id)) {
            // 省略...
<span class="hljs-addition">+            let no = 0</span>
            // 遍历所有匹配结果进行处理
            for (const { rawName, replace } of results) {
                // 将字符串转换为大驼峰
                const name = pascalCase(rawName)
                // 只处理 Co 开头的组件
                if (!name.match(/^Co[A-Z]/)) return
                // 组件路径转换
                const partialName = kebabCase(name.slice(2))
<span class="hljs-addition">+                // 封装了组件的完整导入信息，作为数据载体传递给后续处理函数</span>
<span class="hljs-addition">+                const component = {</span>
<span class="hljs-addition">+                    name,</span>
<span class="hljs-addition">+                    from: `cobyte-vite-ui/dist/components/${partialName}`,</span>
<span class="hljs-addition">+                    sideEffects: ['cobyte-vite-ui/dist/style.css']</span>
<span class="hljs-addition">+                }</span>
<span class="hljs-deletion">-                // 定义要替换的变量名（这里暂时编码为 CoButton）</span>
<span class="hljs-deletion">-                const varName = name</span>
<span class="hljs-addition">+                // 使用特殊前缀减少与用户变量的冲突，以及使用递增的序号，保证唯一性，避免变量名冲突</span>
<span class="hljs-addition">+                const varName = `__unplugin_components_${no}`</span>
                // 在代码开头添加导入语句：
                // 1. 导入 CoButton 组件
                // 2. 导入样式文件
<span class="hljs-deletion">-                 s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/${partialName}';\nimport 'cobyte-vite-ui/dist/style.css';\n`)</span>
<span class="hljs-addition">+                // 这里将 component 对象展开，并添加 as: varName 参数，形成完整的导入配置</span>
<span class="hljs-addition">+                s.prepend(`${stringifyComponentImport({ ...component, as: varName })};\n`)</span>
<span class="hljs-addition">+                no += 1</span>
                // 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名
                replace(varName)
            }
  
            // 返回转换后的代码
            return {
                code: s.toString(),  // 转换后的代码字符串
                map: null, 
            }
        }
      },
    }
}
</code></pre>
<p>我们添加了根据传入的信息生成对应的导入语句字符串的 <code>stringifyImport</code> 函数和根据组件的导入信息生成完整的导入语句，包括组件本身的导入和其副作用（如样式文件）的导入的 <code>stringifyComponentImport</code> 函数。其中 stringifyImport 处理单一导入语句，<code>stringifyComponentImport</code> 处理组合多个相关导入，实现了职责分离和配置灵活的设计优势。这两个函数共同构成了一个灵活的导入语句生成系统，为自动导入插件提供了强大的代码生成能力。</p>
<p>我们设计了一个解析结果包括：<code>name</code>（组件名）、<code>from</code>（导入路径）、<code>sideEffects</code>（样式等副作用导入）的数据结构对象 <code>component</code> 作为数据载体传递给后续处理函数，后续程序基于此来生成导入语句和替换代码。</p>
<p>其中变量名生成策略使用特殊前缀减少与用户变量的冲突从而<strong>避免污染</strong>，同时使用递增序号来<strong>保证唯一性</strong>。</p>
<p>最终我们实现了一个基于数据驱动的架构，将来解析器只负责识别组件和返回路径的数据信息，然后导入生成器函数，也就是上述的 <code>stringifyComponentImport</code> 和 <code>stringifyImport</code> 负责根据配置生成导入代码，我们整体的 Vite 插件就只负责协调流程和代码修改。</p>
<p>这种架构为后续引入真正的多解析器支持奠定了良好基础，只需要将硬编码的解析逻辑替换为可配置的解析器数组即可。</p>
<h3 data-id="heading-7">实现解析器 (Resolver)</h3>
<p>我们引入解析器是为了提高插件的灵活性和可扩展性。当前插件硬编码了组件库的路径和样式文件，只能用于特定的组件库（cobyte-vite-ui）。通过引入解析器，我们可以让插件支持不同的组件库，用户可以根据需要配置不同的解析器。</p>
<p>解析器的作用是根据组件名返回一个解析结果，包括组件的导入路径和样式文件路径等。这样，插件就可以通过解析器来动态获取组件的导入信息，而不是固定写死。</p>
<p>改造步骤：</p>
<ol>
<li>修改插件函数，使其可以接受一个选项对象，选项中包含解析器数组。</li>
<li>在插件内部，遍历解析器数组，对每个组件名尝试使用解析器进行解析。</li>
<li>如果某个解析器返回了结果，则使用该结果来生成导入语句。</li>
<li>如果没有解析器匹配，可以跳过该组件，也可以根据需求做其他处理。</li>
</ol>
<p>参考 <code>NaiveUi</code> 基于 <code>unplugin-vue-components</code> 实现的解析器结构：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">NaiveUiResolver</span>(<span class="hljs-params"/>): <span class="hljs-title class_">ComponentResolver</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'component'</span>,
    <span class="hljs-attr">resolve</span>: <span class="hljs-function">(<span class="hljs-params">name: string</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^(N[A-Z]|n-[a-z])/</span>))
        <span class="hljs-keyword">return</span> { name, <span class="hljs-attr">from</span>: <span class="hljs-string">'naive-ui'</span>, <span class="hljs-attr">sideEffects</span>: [] }
    },
  }
}
</code></pre>
<ul>
<li>解析器是一个对象，包含一个<code>resolve</code>方法，该方法接收组件名，返回一个解析结果对象或undefined。</li>
<li>解析结果对象包括：<code>name</code>（组件名，可选，默认使用原始名），<code>from</code>（导入路径），<code>sideEffects</code>（样式文件路径等，可选）</li>
</ul>
<p>我们还可以支持多种解析器，这样插件可以同时支持多个组件库。</p>
<p>下面我们按照这个思路改造插件代码。首先基于上述 <code>NaiveUi</code> 的解析器实现我们的测试组件的解析器，<code>./packages/utils/index.ts</code> 新增代码如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 解析器函数</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">CobyteViteUiResolver</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'component'</span>,
    <span class="hljs-attr">resolve</span>: <span class="hljs-function">(<span class="hljs-params">name: string</span>) =&gt;</span> {
      <span class="hljs-comment">// 只处理 Co 开头的组件</span>
      <span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^Co[A-Z]/</span>)) {
        <span class="hljs-keyword">const</span> partialName = <span class="hljs-title function_">kebabCase</span>(name.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// CoTableColumn -&gt; table-column</span>
        <span class="hljs-keyword">return</span> { 
          name, 
          <span class="hljs-attr">from</span>: <span class="hljs-string">`cobyte-vite-ui/dist/components/<span class="hljs-subst">${partialName}</span>`</span>, 
          <span class="hljs-attr">sideEffects</span>: [<span class="hljs-string">'cobyte-vite-ui/dist/style.css'</span>] 
        }
      }
    },
  }
}
</code></pre>
<p>接下来修改插件函数，使其可以接受一个选项对象，选项中包含解析器数组，采用上下文管理，因此我们引入 Context 类，创建 Context 类来管理插件配置和解析器，并缓存解析结果，接着在 transform 钩子中，使用 Context 实例来查找组件，而不是硬编码解析逻辑。</p>
<pre><code class="hljs language-diff" lang="diff"><span class="hljs-addition">+ export class Context {</span>
<span class="hljs-addition">+  options: any;</span>
<span class="hljs-addition">+  private _componentNameMap = {} // 组件缓存</span>
<span class="hljs-addition">+  constructor(private rawOptions: any) {</span>
<span class="hljs-addition">+    this.options = rawOptions</span>
<span class="hljs-addition">+  }</span>

<span class="hljs-addition">+  async findComponent(name: string) {</span>
<span class="hljs-addition">+    // 1. 检查缓存中是否有该组件的信息</span>
<span class="hljs-addition">+    let info = this._componentNameMap[name]</span>
<span class="hljs-addition">+    if (info) {</span>
<span class="hljs-addition">+      return info // 缓存命中，直接返回</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    // 2. 遍历所有解析器</span>
<span class="hljs-addition">+    for (const resolver of this.options.resolvers) {</span>
<span class="hljs-addition">+      const result = await resolver.resolve(name)</span>
<span class="hljs-addition">+      // 3. 判断解析器是否返回了结果</span>
<span class="hljs-addition">+      if (!result) {</span>
<span class="hljs-addition">+        continue</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      // 4. 构建完整组件信息</span>
<span class="hljs-addition">+      info = {</span>
<span class="hljs-addition">+        as: name, // 添加别名</span>
<span class="hljs-addition">+        ...result,</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      // 5. 存入缓存</span>
<span class="hljs-addition">+      this._componentNameMap[name] = info</span>
<span class="hljs-addition">+      return info</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    // 所有解析器都不匹配，返回 undefined</span>
<span class="hljs-addition">+  }</span>
<span class="hljs-addition">+ }</span>

<span class="hljs-deletion">-  export default function VitePluginAutoComponents() {</span>
<span class="hljs-addition">+  export default function VitePluginAutoComponents(options = {}) {</span>
<span class="hljs-addition">+    // 创建 Context 实例，用于存储插件配置和组件信息</span>
<span class="hljs-addition">+    const ctx = new Context(options)</span>
    return {
      // 插件名称，用于调试和错误信息
      name: 'vite-plugin-auto-component',
  
      // transform 钩子函数，在转换模块时调用
      // code: 文件内容，id: 文件路径
      async transform(code, id) {
        // 使用正则表达式检查文件是否为.vue文件
        // 如果不是.vue文件，不进行处理
        if(/\.vue$/.test(id)) {
            // 省略...
            
            let no = 0
            // 遍历所有匹配结果进行处理
            for (const { rawName, replace } of results) {
                // 将字符串转换为大驼峰
                const name = pascalCase(rawName)
<span class="hljs-deletion">-                // 只处理 Co 开头的组件</span>
<span class="hljs-deletion">-                 if (!name.match(/^Co[A-Z]/)) return</span>
<span class="hljs-deletion">-                // 组件路径转换</span>
<span class="hljs-deletion">-                 const partialName = kebabCase(name.slice(2))</span>
<span class="hljs-deletion">-                // 封装了组件的完整导入信息，作为数据载体传递给后续处理函数</span>
<span class="hljs-deletion">-                 const component = {</span>
<span class="hljs-deletion">-                     name,</span>
<span class="hljs-deletion">-                     from: `cobyte-vite-ui/dist/components/${partialName}`,</span>
<span class="hljs-deletion">-                     sideEffects: ['cobyte-vite-ui/dist/style.css']</span>
<span class="hljs-deletion">-                 }</span>
<span class="hljs-addition">+                const component = await ctx.findComponent(name)</span>
<span class="hljs-addition">+                if (component) {</span>
                  // 定义要替换的变量名（这里暂时编码为 CoButton）
                  // const varName = name
                  // 使用特殊前缀减少与用户变量的冲突，以及使用递增的序号，保证唯一性，避免变量名冲突
                  const varName = `__unplugin_components_${no}`
                  // 在代码开头添加导入语句：
                  // 1. 导入 CoButton 组件
                  // 2. 导入样式文件
                  // s.prepend(`\nimport ${varName} from 'cobyte-vite-ui/dist/components/${partialName}';\nimport 'cobyte-vite-ui/dist/style.css';\n`)
                  // 这里将 component 对象展开，并添加 as: varName 参数，形成完整的导入配置
                  s.prepend(`${stringifyComponentImport({ ...component, as: varName })};\n`)
                  no += 1
                  // 执行替换：将 resolveComponent("xxx") 调用替换为组件变量名
                  replace(varName)
<span class="hljs-addition">+                }</span>
            }
  
            // 返回转换后的代码
            return {
                code: s.toString(),  // 转换后的代码字符串
                map: null, 
            }
        }
      },
    }
}
</code></pre>
<p>插件初始化时，创建 Context 实例，传入options，其中包含解析器 resolvers。Context 类提供了一个findComponent方法，用于根据组件名查找组件信息。该方法会先查看缓存，如果缓存中没有，则依次调用每个解析器的 resolve 方法，直到有一个解析器返回结果。然后将结果缓存起来。在 transform 钩子中，使用 Context 实例的findComponent 方法来查找组件信息，而不再是硬编码解析逻辑。这次迭代使插件从单一组件库的支持扩展到多组件库，使用缓存提高性能，通过解析器模式提高扩展性，并且通过异步解析查找组件信息、为未来异步解析预留接口。</p>
<p>经过此次的迭代，我们的插件实现了真正的解耦，插件核心只负责流程控制，解析逻辑则完全由解析器处理，配置管理则由 Context 统一管理，标准化了解析器的接口，这样所有解析器都遵循相同的接口，由此实现了强大的拓展性。</p>
<p>接着我们更新 play 项目中的 Vite 配置文件 <code>vite.config.ts</code>，更新如下：</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
<span class="hljs-deletion">- import AutoComponents from 'cobyte-vite-ui/dist/utils'</span>
<span class="hljs-addition">+ import AutoComponents, { CobyteViteUiResolver} from 'cobyte-vite-ui/dist/utils'</span>

export default defineConfig({
<span class="hljs-deletion">-  plugins: [vue(), AutoComponents()]</span>
<span class="hljs-addition">+  plugins: [vue(), AutoComponents({</span>
<span class="hljs-addition">+    resolvers: [CobyteViteUiResolver()]</span>
<span class="hljs-addition">+  })],</span>
})
</code></pre>
<p>接着重新打包组件库，再重启 play 项目，我们发现依然正常，说明我们上述的改动是正确的。</p>
<h3 data-id="heading-8">多解析器配置</h3>
<p>上文说了我们实现了插件从单一组件库的支持扩展到多组件库的按需加载解析，那么下面就让我们来测试一下。
首先我们往 <code>packages/utils/index.ts</code> 文件添加 Naive UI 的解析器，代码如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/**
 * Resolver for Naive UI
 *
 * <span class="hljs-doctag">@link</span> https://www.naiveui.com/
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">NaiveUiResolver</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'component'</span>,
    <span class="hljs-attr">resolve</span>: <span class="hljs-function">(<span class="hljs-params">name: string</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'NaiveUiResolver'</span>, name, name.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^(N[A-Z]|n-[a-z])/</span>));
      <span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^(N[A-Z]|n-[a-z])/</span>))
        <span class="hljs-keyword">return</span> { name, <span class="hljs-attr">from</span>: <span class="hljs-string">'naive-ui'</span> }
    },
  }
}
</code></pre>
<p>这个解析器是完全从 <code>unplugin-vue-components</code> 插件中搬过来的，我们测试一下是否能够在我们实现的插件中使用。</p>
<p>接着我们在 play 项目中安装 Naive UI 的依赖：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> naive-ui
</code></pre>
<p>然后在 App.vue 文件中引用 Naive UI 的组件：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">co-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">co-button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">n-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>&gt;</span>naive-ui<span class="hljs-tag">&lt;/<span class="hljs-name">n-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>接着修改 <code>./play/vite.config.ts</code> 文件中的配置。</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
<span class="hljs-deletion">- import AutoComponents, { CobyteViteUiResolver } from 'cobyte-vite-ui/dist/utils'</span>
<span class="hljs-addition">+ import AutoComponents, { CobyteViteUiResolver, NaiveUiResolver } from 'cobyte-vite-ui/dist/utils'</span>

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue(), AutoComponents({
<span class="hljs-deletion">-   resolvers: [CobyteViteUiResolver()]</span>
<span class="hljs-addition">+    resolvers: [CobyteViteUiResolver(), NaiveUiResolver()]</span>
  })],
})
</code></pre>
<p>接着我们重新打包我们的测试组件库，再重启 play 测试项目，测试结果如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f9fc0afaa6f74916a0a1ba1e7f0b866c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=NmSVWgC%2B09BWju5OVR4Mw3s6Ev8%3D" alt="01.png" loading="lazy"/></p>
<p>我们可以看到成功验证了我们上述的结论：<strong>我们实现了插件从单一组件库的支持扩展到多组件库的按需加载解</strong>。</p>
<p>我们上面所实现的插件其实就是 <code>unplugin-vue-components</code> 库的实现原理，在 Vue 技术栈中都是通过这个库来实现组件按需加载的。</p>
<h3 data-id="heading-9">业务组件库按需加载实践</h3>
<p>我们在 play 项目中安装 <code>unplugin-vue-components</code> 库来替换我们手写的插件。安装命令如下：</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> unplugin-vue-components -D 
</code></pre>
<p>接着修改 play 项目中的 <code>vite.config.ts</code> 文件。</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
<span class="hljs-deletion">- import AutoComponent, { CobyteViteUiResolver, NaiveUiResolver } from 'cobyte-vite-ui/dist/utils'</span>
<span class="hljs-addition">+ import { CobyteViteUiResolver, NaiveUiResolver } from 'cobyte-vite-ui/dist/utils'</span>
<span class="hljs-addition">+ import AutoComponents from 'unplugin-vue-components/vite';</span>

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue(), AutoComponents({
    resolvers: [CobyteViteUiResolver(), NaiveUiResolver()]
  })],
})
</code></pre>
<p>然后重启 play 项目，我们发现我们的测试例子依然是正常运行的。所以我们一般的组件库或者业务组件库想要实现按需加载，只需要参考 <code>unplugin-vue-components</code> 库中提供的解析器，写一个符合自己的组件库的解析器再配合 <code>unplugin-vue-components</code> 即可。当然还有一个重要的前提，你的组件库得设计成模块化，即一个组件一个模块，互不关联或者弱关联。</p>
<h3 data-id="heading-10">业务组件库引用第三方组件库的按需加载</h3>
<p>我们知道所谓业务组件库，就是一些基于第三方组件库开发的组件库，比如基于 Element Plus、Naive UI 开发的组件库。那么我们修改一下我们的测试组件库 <code>./packages/components/button</code>，让它使用 Naive UI 的 button 组件，修改如下：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">n-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"warning"</span>&gt;</span>
    Warning
  <span class="hljs-tag">&lt;/<span class="hljs-name">n-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-title function_">defineOptions</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'co-button'</span>,
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"scss"</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-tag">button</span> {
  <span class="hljs-attribute">color</span>: red;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<p>接着我们重新打包测试组件库，然后重启 play 项目。我们发现测试组件库中 Naive UI 的按钮 Button 并没有生效。并且在浏览器的控制台报以下警报：</p>
<pre><code class="hljs language-css" lang="css">Failed <span class="hljs-selector-tag">to</span> resolve component: n-button
</code></pre>
<p>这是因为我们使用 Vite 来打包组件库，Vite 默认会把代码进行压缩混淆。我们可以看一下打包后的测试 button 组件的代码。可以看到原本应该是 <code>_resolveComponent("n-button")</code> 的代码，因为 Vite 进行了压缩混淆而变成了 o("n-button")。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0a1fd47f258b45e7825b38666b32cef5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=xj9PMv0rEFl1dTwVMX%2F0Hu3GpE4%3D" alt="02.png" loading="lazy"/></p>
<p>而我们的插件是基于 <code>_resolveComponent</code> 为前缀进行匹配的，现在前缀被压缩了也就肯定匹配到不到了。所以简单的处理方法就是修改 Vite 打包配置，让其不进行压缩混淆，毕竟 Element Plus、Naive UI 这些开源组件库打包后的产物也没有进行压缩混淆。所以我们修改 Vite 打包配置禁止构建压缩混淆。修改根目录下的 <code>vite.config.ts</code> 如下：</p>
<pre><code class="hljs language-diff" lang="diff">// 省略...

export default defineConfig(({ command, mode }) =&gt; {
    // 主构建配置
    return {
        // 省略...
        build: {
<span class="hljs-addition">+            minify: false, // 禁止压缩混淆</span>
            // 省略...
        },
    };
});
</code></pre>
<p>我们发现打包后的组件代码不压缩混淆了，但还是不生效，这是因为我们写的插件只解析 <code>.vue</code> 文件，而我们打包后的文件变成了 <code>.mjs</code> 了，所以我们要修改一下 play 项目的 Vite 配置让 <code>.mjs</code> 文件也可以被解析。修改 <code>./play/vite.config.ts</code>  文件如下：</p>
<pre><code class="hljs language-diff" lang="diff">  // 省略...
export default defineConfig({
  plugins: [vue(), AutoComponents({
<span class="hljs-addition">+    include: [</span>
<span class="hljs-addition">+      /\.vue$/,</span>
<span class="hljs-addition">+      /\.mjs$/</span>
<span class="hljs-addition">+    ],</span>
    resolvers: [CobyteViteUiResolver(), NaiveUiResolver()]
  })],
})
</code></pre>
<p>经过上述修改后我们重启 play 项目，发现基于 Naive UI 二次开发的组件可以成功加载了。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/40241ada01dc43be8f8adfdd50ebac34~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=fTIbzwPyquF5rKqzxpe8urIlk2g%3D" alt="03.png" loading="lazy"/></p>
<h3 data-id="heading-11">依赖预构建配置</h3>
<p>我们知道 Vite 会在第一次启动的时候把依赖预构建并缓存到 <code>node_modules/.vite</code> 目录中。主要有以下几个原因：</p>
<ol>
<li>模块格式转换</li>
</ol>
<p>许多 npm 包使用的是 CommonJS 或 UMD 格式，而 Vite 在开发环境中使用的是原生 ES 模块（ESM）。预构建会将这些包转换为 ESM 格式，使其能够在浏览器中直接运行。</p>
<ol start="2">
<li>性能优化 - 减少 HTTP 请求</li>
</ol>
<p>某些包会有很多内部模块，如果不预构建，浏览器可能需要发起数百个 HTTP 请求。预构建会将这些模块打包成一个或少数几个文件。</p>
<p>典型例子：</p>
<ul>
<li>lodash-es 有超过 600 个内置模块</li>
<li>如果不预构建，会导致 600+ 个 HTTP 请求</li>
<li>预构建后只需要 1-2 个请求</li>
</ul>
<ol start="3">
<li>提升页面加载速度</li>
</ol>
<p>预构建使用 esbuild（用 Go 编写），速度比传统 JavaScript 打包工具快 10-100 倍。通过将依赖预先打包并缓存，可以显著提升开发服务器的启动速度和模块热更新（HMR）的响应速度。</p>
<p>默认的时候 Vite 是通过 import 语句进行分析需要预构建的依赖的，但我们使用按需加载的插件之后，在代码中就有些 npm 包不存在 import 语句了，所以需要我们手动通过 <code>optimizeDeps.include</code> 选项设置预构建。</p>
<p>我们对 <code>./play/vite.config.ts</code> 设置如下：</p>
<pre><code class="hljs language-diff" lang="diff">import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { CobyteViteUiResolver, NaiveUiResolver } from 'cobyte-vite-ui/dist/utils'
import AutoComponents from 'unplugin-vue-components/vite';
<span class="hljs-addition">+ import pkg from './package.json';</span>
<span class="hljs-addition">+ const dependencies = Object.keys(pkg.dependencies);</span>

export default defineConfig({
  plugins: [vue(), AutoComponents({
    include: [
      /\.vue$/,
      /\.mjs$/
    ],
    resolvers: [CobyteViteUiResolver(), NaiveUiResolver()]
  })],
<span class="hljs-addition">+  optimizeDeps: {</span>
<span class="hljs-addition">+    include: [...dependencies]</span>
<span class="hljs-addition">+  }</span>
})
</code></pre>
<p>由于 Node 不处理虚拟链接，同时为了更真实验证真实场景，我们把测试组件库改成更加真实，首先修改 <code>./play/packages.json</code></p>
<pre><code class="hljs language-diff" lang="diff">{
  // 省略...
  "dependencies": {
<span class="hljs-deletion">-    "cobyte-vite-ui": "link:..",</span>
    "cobyte-vite-ui": "^1.0.0",
    "naive-ui": "^2.43.1",
    "vue": "^3.5.22"
  },
  // 省略...
}
</code></pre>
<p>同时删掉 <code>./play/node_modules</code> 目录中的 <code>cobyte-vite-ui</code> 虚拟目录，再重新创建一个 <code>cobyte-vite-ui</code> 目录，同时把根目录下的 <code>./dist</code> 目录中的内容和根目录下的 <code>packages.json</code> 文件复制到刚刚新创建的
<code>cobyte-vite-ui</code> 目录中，这相当于手动安装我们创建的测试组件库的依赖了。之后我们再删掉 <code>./play/node_modules/.vite</code> 目录的预构建缓存，再重启 play 项目。这时我们发现 <code>cobyte-vite-ui</code> 组件库中引用的 Naive UI 的 button 组件不生效了。这是因为我们把 <code>cobyte-vite-ui</code> 进行预构建后，它的内容就会被预构建后缓存到 <code>./play/node_modules/.vite</code> 目录中了，而 unplugin-vue-components 插件默认是不解析 <code>node_modules</code> 目录中的文件的，所以我们可以修改 unplugin-vue-components 插件的配置让其可以解析 <code>node_modules</code> 目录中的文件，但这不是最优的方案。最优的方案是在打包 <code>cobyte-vite-ui</code> 组件库的时候就
进行按需打包。我们在根目录下安装 <code>unplugin-vue-components</code> 依赖。</p>
<pre><code class="hljs language-csharp" lang="csharp">pnpm <span class="hljs-keyword">add</span> unplugin-vue-components -D -w
</code></pre>
<p>我们在安装上述依赖的时候，可能会报以下错误：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6746af5fde3446af853e12ef3aa69e0e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29ieXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763905528&amp;x-signature=AaAWOg3oR8etvN4X%2FocknaSdzaQ%3D" alt="04.png" loading="lazy"/></p>
<p>这是因为我们刚刚把 play 目录中的测试组件库 <code>cobyte-vite-ui</code> 改了正式库一样的依赖，我们可以暂时把它改回虚拟依赖。</p>
<pre><code class="hljs language-diff" lang="diff">"dependencies": {
<span class="hljs-deletion">-    "cobyte-vite-ui": "^1.0.0",</span>
<span class="hljs-addition">+    "cobyte-vite-ui": "link:..",</span>
    "naive-ui": "^2.43.1",
    "vue": "^3.5.22"
},
</code></pre>
<p>再进行安装即可。</p>
<p>然后新增根目录下的 <code>vite.config.ts</code> 文件的配置：</p>
<pre><code class="hljs language-diff" lang="diff">// 省略...
<span class="hljs-addition">+ import AutoComponents from 'unplugin-vue-components/vite';</span>
<span class="hljs-addition">+ import { NaiveUiResolver } from 'unplugin-vue-components/resolvers';</span>

// 省略...

export default defineConfig(({ command, mode }) =&gt; {
    // 主构建配置
    return {
        plugins: [
            vue(),
<span class="hljs-addition">+            AutoComponents({</span>
<span class="hljs-addition">+                resolvers: [NaiveUiResolver()]</span>
<span class="hljs-addition">+            })</span>
        ],
        build: {
            // 省略...
            rollupOptions: {
                external: [
                    "vue", 
<span class="hljs-addition">+                    "naive-ui", // 排除打包</span>
                ],
            // 省略..
            },
        },
    };
});
</code></pre>
<p>配置完后，重新打包我们的测试组件库，打包完后，重新删掉 <code>./play/node_modules/.vite</code> 中的缓存，和 <code>./play/node_modules/cobyte-vite-ui</code> 中的内容，重新把刚刚新打包的根目录下的 <code>./dist</code> 目录中的内容和根目录下的 <code>packages.json</code> 文件复制到 <code>./play/node_modules/cobyte-vite-ui</code> 中，同时恢复修改的 <code>./play/packages.json</code> 文件，然后重启 play 项目。</p>
<p>这时我们就发现测试项目可以正常渲染了。</p>
<p>至此我们业务组件库按需加载的实现原理就都讲得差不多了，有什么可以在评论区交流。</p>
<h3 data-id="heading-12">总结</h3>
<p>看完了全篇文章相信你会觉得，所谓组件库按需加载或者业务组件库按需加载其实很简单，首先组件库的每一个组件都得设计成独立的模块，并且可以按模块导入，也就是 ESM 化，可以进行 Tree Shaking，只有这样按需加载才有意义，才能达到减小包体积的作用。</p>
<p>全局组件在模板中使用被编译后会通过一个内置函数 <strong>resolveComponent</strong> 来调用组件，按需加载的实现原理就是通过插件进行正则匹配查找编译后的模板代码中的 <strong>resolveComponent</strong> 函数的相关代码来找到需要按需加载的组件，然后自动按编译后的代码的头部添加需要加载的组件的导入语句代码以及替换掉 <strong>resolveComponent</strong> 函数的相关代码为对应的组件对象。</p>
<p>而业务组件实现按需加载的关键是需要在业务组件库打包的时候也进行按需加载配置。虽然这个关键步骤很简单，但由于这是一个低频且跨项目的需求，所以AI对低频的需求的实现和给的解决方案都不尽人意，至少本人解决上述问题时，AI提供方案没有一个可以实现的，虽然最后的实现其实很简单。</p>
<p>最后，再说说个人对AI的一些感悟吧，个人觉得在AI时代，就编程这个领域而言对个人的专业要求会比以前更加的高，至少你得有能力去解决AI不会的问题。</p>
<p>上述组件库测试代码地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Famebyte%2Fcobyte-vite-ui" target="_blank" title="https://github.com/amebyte/cobyte-vite-ui" ref="nofollow noopener noreferrer">github.com/amebyte/cob…</a></p>
<p>欢迎关注本专栏，了解更多 Element Plus 组件库知识</p>
<p>本专栏文章：</p>
<p><a href="https://juejin.cn/post/7143196940992413709" target="_blank" title="https://juejin.cn/post/7143196940992413709">1. Vue3 组件库的设计和实现原理</a></p>
<p><a href="https://juejin.cn/post/7146183222425518093" target="_blank" title="https://juejin.cn/post/7146183222425518093">2. 组件库工程化实战之 Monorepo 架构搭建</a></p>
<p><a href="https://juejin.cn/post/7153659360177029150" target="_blank" title="https://juejin.cn/post/7153659360177029150">3. ESLint 核心原理剖析</a></p>
<p><a href="https://juejin.cn/post/7157743898939359262" target="_blank" title="https://juejin.cn/post/7157743898939359262">4. ESLint 技术原理与实战及代码规范自动化详解</a></p>
<p><a href="https://juejin.cn/post/7161063570594070559" target="_blank" title="https://juejin.cn/post/7161063570594070559">5. 从终端命令解析器说起谈谈 npm 包管理工具的运行原理</a></p>
<p><a href="https://juejin.cn/post/7165503808217284616" target="_blank" title="https://juejin.cn/post/7165503808217284616">6. CSS 架构模式之 BEM 在组件库中的实践</a></p>
<p><a href="https://juejin.cn/post/7168835045984043022" target="_blank" title="https://juejin.cn/post/7168835045984043022">7. 组件实现的基本流程及 Icon 组件的实现</a></p>
<p><a href="https://juejin.cn/post/7170716245762048036" target="_blank" title="https://juejin.cn/post/7170716245762048036">8. 为什么组件库或插件需要定义 peerDependencies</a></p>
<p><a href="https://juejin.cn/post/7179257832632483896" target="_blank" title="https://juejin.cn/post/7179257832632483896">9. 组件开发中 Vue3 相关知识的应用与解析及 Button 组件的实现</a></p>
<p><a href="https://juejin.cn/post/7186683381470462007" target="_blank" title="https://juejin.cn/post/7186683381470462007">10. CSS 系统颜色和暗黑模式的关系及意义</a></p>
<p><a href="https://juejin.cn/post/7190370726677839932" target="_blank" title="https://juejin.cn/post/7190370726677839932">11. 深入理解组件库中SCSS和CSS变量的架构应用和实践</a></p>
<p><a href="https://juejin.cn/post/7204454572890046501" target="_blank" title="https://juejin.cn/post/7204454572890046501">12. 组件 v-model 的封装实现原理及 Input 组件的核心实现</a></p>
<p><a href="https://juejin.cn/post/7217399337989881911" target="_blank" title="https://juejin.cn/post/7217399337989881911">13. 深入理解 Vue3 的 v-model 及自定义指令的实现原理</a></p>
<p><a href="https://juejin.cn/post/7249299811497066551" target="_blank" title="https://juejin.cn/post/7249299811497066551">14. React 和 Vue 都离不开的表单验证工具库 async-validator 之策略模式的应用</a></p>
<p><a href="https://juejin.cn/post/7258966810350174263" target="_blank" title="https://juejin.cn/post/7258966810350174263">15. Form 表单的设计与实现</a></p>
<p><a href="https://juejin.cn/post/7313380227160522763" target="_blank" title="https://juejin.cn/post/7313380227160522763">16. 组件库的打包原理与实践详解</a></p>
<p><a href="https://juejin.cn/post/7572480736362119174" target="_blank" title="https://juejin.cn/post/7572480736362119174">17. Vue3 业务组件库按需加载的实现原理</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[我用 SOLO Coder 做 Excalidraw 开源项目二次开发]]></title>    <link>https://juejin.cn/post/7572697146286735410</link>    <guid>https://juejin.cn/post/7572697146286735410</guid>    <pubDate>2025-11-16T00:17:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572697146286735410" data-draft-id="7572387666979979290" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="我用 SOLO Coder 做 Excalidraw 开源项目二次开发"/> <meta itemprop="keywords" content="Trae"/> <meta itemprop="datePublished" content="2025-11-16T00:17:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不惑_"/> <meta itemprop="url" content="https://juejin.cn/user/1471609400466218"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我用 SOLO Coder 做 Excalidraw 开源项目二次开发
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1471609400466218/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不惑_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T00:17:44.000Z" title="Sun Nov 16 2025 00:17:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>我总觉得，真正的二次开发不是把功能贴到代码里那么简单，而是要在一个有生命力的开源项目里，摸索出它的气质和脉络，然后把自己的改动像一块合适的木料，打磨到恰好咬合的位置。Excalidraw 正好是那种适合雕琢的项目：接口清晰、结构分明、社区稳健，甚至它的白板本身就鼓励你在上面画来画去。于是我把一个小愿望丢给 SOLO Coder：把文本 → 图形的智能生成做进来，流程图也好，思维导图也罢，最好的结果就是我能在编辑器里写一句话，轻轻一点，就看到图像在面前成形。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/44c9372d06e84782bc5118f4f5aad85a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=RC5YxC7RVoQcAgqy1bxDgb8PN4M%3D" alt="image.png" loading="lazy"/></p>
<p>这是一篇完整的AI绘图功能二次开发笔记：我用 SOLO Coder 在 Excalidraw 开源项目中增加文本→图形的 AI 能力，支持流程图与思维导图，并在编辑器里直接预览和插入。文章覆盖环境搭建、前后端改造、联调验证、问题处理与可复制的操作步骤，先看效果吧。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ccc064be923f4f33aa161ff06c16a3b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=RaInPrvxWlWbgdAc6HCl%2F1%2Fj1tE%3D" alt="1114-2.gif" loading="lazy"/></p>
<p>你将获得</p>
<ul>
<li>在主菜单新增AI绘图入口，打开文本转图对话框（TTD）</li>
<li>前端将文本与图类型发送到后端；后端接入豆包（Volcengine Ark）生成 Mermaid 文本</li>
<li>预览区渲染并一键插入到画布；失败时有清洗与兜底策略</li>
</ul>
<p>在此之前，我们已经通过SOLO Coder 部署了本地的Excalidraw，接着要找入口，找一个人走近白板时自然会按下的地方。我把AI绘图放到主菜单里，让它像一个轻微的邀请而不是强制的引导。点击以后，前端抛给我第一个态度不好的报错：<code>setAppState is not a function</code>。两秒钟的心情起伏之后，我意识到是这个问题可以通过AI去解决，于是我把AI产生的问题换个了AI。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5f338985e11406b9860ce6e8fcf6165~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=SJLxzCniCWg6aBii2Pvtg3Yj9Bo%3D" alt="image.png" loading="lazy"/>
不难发现，它很快修复了这个问题，Excalidraw 的命令式接口里没有这个方法，应该用 <code>updateScene</code>。把全局事件改成 <code>updateScene({ appState: { openDialog: ... } })</code>，对话框乖乖弹出来，像终于滑到桌面正中间的一杯茶。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ff559656a01476f87b1c4964105393b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=QxiB4NbZKEmsniQ%2FAzMthsodwDg%3D" alt="image.png" loading="lazy"/>
这扇窗叫 TTD，对话框的全名是 Text-to-Diagram。也就是 Text-to-Diagram。对话框的形态很友好，左边一个文本框，右边一个预览区，鼠标在文本框里点击一下，那种手指压下去的瞬间，我顺手截了一张图，留作交互起点的标记。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d2a10c0cf9c474eaa863bed731efa38~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=unYW20bZPrUY%2FyH1AhcX1cZ0HUY%3D" alt="image.png" loading="lazy"/>
第一次按下Generate，我看到的是一片沉默，预览区安静地不动，还给我抛了一个Generated an invalid diagram。我把这个截图也留下，作为一次不太成功的尝试。那会儿我就明白了，这不是没调用，而是调用了，但返回的 Mermaid 文本不合身。思维导图的 Mermaid 语法算是实验性，转换库不是对所有情况都拿得很稳。于是我把后端派上台，搭了一个干净的 ai-backend ，用 Express 做路由，让它站在 excalidraw-master 的旁边，同时悄悄接入豆包（Volcengine Ark）的 Chat Completions，用 .env.local 留住密钥，不往前端暴露，保持整个结构清爽。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2678a90256624a3d928c1cf9c57e0aa3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=H07Z5HgwuhGmbTnB3mWtOEkwAKM%3D" alt="image.png" loading="lazy"/></p>
<p>后端这边，我直接把豆包API输入个SOLO。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/788f70c912c3481ba51dab0abaf55e2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=ryqs5pm7F3UA%2BSSpRI%2B2DI3CE6U%3D" alt="image.png" loading="lazy"/></p>
<p>这里有详解的API文档：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8a761f7773fc40099239adccf93a0852~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=pZg82gVjaAonuZXXlMvFp284wM4%3D" alt="image.png" loading="lazy"/></p>
<p>接下来会新建一个 <code>ai-backend</code>，让它站在主项目的旁侧，单纯、安静，读 <code>.env.local</code> 里的密钥，不把任何敏感信息暴露到前端，也不往仓库里乱提交。路由只做一件事：<code>/v1/ai/text-to-diagram/generate</code> 接受 <code>prompt</code> 和 <code>type</code>，优先调用豆包 Ark Chat Completions，把返回的内容清洗一下。</p>
<p>我很在意交互的微妙。TTD 对话框里那段英文提示，说系统目前用 Mermaid 当中间步骤，这句话像一个前置的协议：你要么给我流程、要么给我结构，我来想办法帮你成长为图像。用户写的是人话，模型理解的是人话，但预览需要的是规整的语言。所以我把类型的选择前置到生成动作的上方，让这组 UI 形成一个心智链条：输入、选择、生成、预览、插入。你能感到手势的顺畅，能看到预期的结果，这比任何文档提示都有效。</p>
<p>过程中有一些次要的插曲，比如浏览器标签意外打开旧端口 3000，所以事件监听并没有注册到你看的页面上；比如我一度尝试用 <code>window.addEventListener</code> 做一些全局控制，后来还是把它规整到 <code>useEffect</code>，跟着 <code>excalidrawAPI</code> 走生命周期；比如Mermaid 原文那一页会让人想查看细节，我就保留了View as Mermaid的跳转，给调试者一个后备的工具。每一个小动作都不是必须，但它们是贴心，我希望这套体验不是硬塞进去的功能，而是一种自然的延伸。</p>
<p>豆包的接入自己也带了一点个性。我把密钥放在本地 <code>.env.local</code> 里，不在代码里落笔，也不在终端里写长串的临时变量。模型的参数没有走极端，<code>max_completion_tokens</code> 设个温和的上限，<code>reasoning_effort</code> 放在中等，确保稳定和成本可控。有时为了让预览稳定，我会把 Mindmap 的生成提示悄悄引导成 Flowchart 的层级表达，毕竟转换链路对流程图更友好，这不是背叛，更像是一个实用主义的选择。用户要的是看到结构并可编辑的图形，图的样式可以慢慢打磨，但空白的预览等不及。</p>
<p>这时候整条链路开始有了握手的感觉。我在首页截图之后，又截了一个主菜单展开的画面，那里有AI绘图这个新朋友。我点开对话框，在文本框里敲了一段结构——比如把项目规划放在首行，然后用短句把目标范围时间资源团队预算一行一行列出来，然后按下Generate。这回预览区不再冷场，图像从右边长出来，节点紧紧排列，像把散落的书页用线穿在一起。我让它落到画布中央，放大一点，给这个时刻留一张干净的截图。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/06827f2c5b5f47cea490247124f5e17a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=4bEMWKimkbIA9yfzYrI7EG5AcW0%3D" alt="image.png" loading="lazy"/></p>
<p>接下来点击Insert按钮，就可以将内容插入到画布中。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6508bd6916cc41dbb9b238748e363c0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5oORXw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763857063&amp;x-signature=vbRCSy2zV9VNECpx1p1IKCLSYKs%3D" alt="image.png" loading="lazy"/></p>
<p>偶尔，它还会闹些情绪。比如你输入了太长的一段话，没有清晰的结构，它会再次用Generated an invalid diagram提醒你，语气像朋友。这个时候，不要把锅丢给模型，稍微调整一下文本，把主题放在第一行，把一级要点一行一个，风格更像大纲，再按一下生成。它会给你面子，预览就出来了。如果你想更确定一点，把右上角的类型切到 Flowchart，它几乎不会让你失望。</p>
<p>写到这里，我开始觉得这件事并不只是给项目加了一个AI功能。它更像是让一个成熟的工具，学会听另一种语言。Excalidraw 原本鼓励你用手去画，现在它也可以理解你说画一个这样的结构。TTD 对话框不是魔法，它只是一个理性的桥梁，把人的表达连接到图的表达，帮你跨过去。SOLO Coder 在这件事上扮演的角色，是把那些易碎的衔接点，替你稳稳地固定住。下载、安装、起服务、修事件、接模型、清文本、兜底，这些看起来像是工程细节，但它们构成了整个体验的实感。</p>
<p>如果你问我，SOLO Coder 在这件事里做了什么，我想说它并没有替我写掉所有代码，但它帮我把那条从下载到看见的路径铺平了。在本地拉起项目，协调工作区依赖、启动 Vite，修好入口事件，把后端服务跑起来，豆包的密钥藏在 .env.local ，调用链条串上去，预览链条又稳住，再给这条路放几个路标，这些工作听起来不起眼，却让一切变得顺畅。二次开发真正的魅力在于此：你不是把自己的想法贴上去，而是把它揉进来，跟项目的语言在一起，跟它的节奏在一起。</p>
<p>我把这篇文章写成一段连续的叙事，不讲首先、其次、最后，不做报告那样堆观点。我只是把自己的实操摊开，让那些按键、链接、路径、拐角、错误和修复全都在地上，带着你走过一次。等你走完，你会发现你也能这样，把一个想法交给 SOLO Coder，给它一个被验证的出口，只要你愿意在中间补上一点点耐心，这条路会变得像一条平整的木板道，踩上去不会发出吱嘎的声响。这个项目于是有了一个新习惯：不仅用手画，还能用话画。图像不再需要你去一个个摆放，它可以按照你的文字，自己站在画布上。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 中的迭代机制：Sequence、Collection 与 Iterator 完全拆解]]></title>    <link>https://juejin.cn/post/7573506713865863219</link>    <guid>https://juejin.cn/post/7573506713865863219</guid>    <pubDate>2025-11-17T08:23:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573506713865863219" data-draft-id="7571729676344049727" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 中的迭代机制：Sequence、Collection 与 Iterator 完全拆解"/> <meta itemprop="keywords" content="Swift"/> <meta itemprop="datePublished" content="2025-11-17T08:23:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unravel2025"/> <meta itemprop="url" content="https://juejin.cn/user/1116759541421880"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 中的迭代机制：Sequence、Collection 与 Iterator 完全拆解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1116759541421880/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unravel2025
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:23:31.000Z" title="Mon Nov 17 2025 08:23:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>日常开发里，我们写 <code>for item in list</code> 像呼吸一样自然。</p>
<p>但 Swift 编译器在背后悄悄做了三件事：</p>
<ol>
<li>调用 <code>list.makeIterator()</code> 拿到一个迭代器</li>
<li>反复调用 <code>iterator.next()</code></li>
<li>把返回的可选值解包后赋给 <code>item</code></li>
</ol>
<p>一旦理解这三步，你就能</p>
<ul>
<li>自己写“能 for-in 的数据结构”</li>
<li>避免“遍历同时修改”导致的崩溃</li>
<li>把回调式 API 优雅地转成 <code>AsyncSequence</code></li>
</ul>
<h2 data-id="heading-1">Sequence：最小迭代单元</h2>
<p>协议定义（核心部分，Swift 5.9 仍不变）</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Iterator</span>: <span class="hljs-type">IteratorProtocol</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span> <span class="hljs-operator">==</span> <span class="hljs-type">Element</span>
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IteratorProtocol</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Element</span>?
}
</code></pre>
<p>关键知识点</p>
<ol>
<li>Sequence 只承诺“能生成迭代器”，不保证能反复遍历，也不保证有 <code>count</code>。</li>
<li>迭代器几乎总是 <code>struct</code>：值语义保证“复制一份就从头开始”，不会意外共享状态。</li>
<li>单趟序列（例如网络流）完全合法；第二次 <code>makeIterator()</code> 可以返回空迭代器。</li>
</ol>
<p>代码示例：自定义一个“从 n 倒数到 0”的序列</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Countdown</span>: <span class="hljs-title class_">Sequence</span> {
    <span class="hljs-keyword">let</span> start: <span class="hljs-type">Int</span>
    
    <span class="hljs-comment">// 每次 for-in 都会调用一次，生成新的迭代器</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span> {
        <span class="hljs-type">Iterator</span>(current: start)
    }
    
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iterator</span>: <span class="hljs-title class_">IteratorProtocol</span> {
        <span class="hljs-keyword">var</span> current: <span class="hljs-type">Int</span>
        
        <span class="hljs-comment">// 返回 nil 时代表迭代结束</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Int</span>? {
            <span class="hljs-keyword">guard</span> current <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> }
            <span class="hljs-keyword">defer</span> { current <span class="hljs-operator">-=</span> <span class="hljs-number">1</span> }          <span class="hljs-comment">// 先返回，再减</span>
            <span class="hljs-keyword">return</span> current
        }
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> <span class="hljs-type">Countdown</span>(start: <span class="hljs-number">3</span>) {
    <span class="hljs-built_in">print</span>(number)   <span class="hljs-comment">// 3 2 1 0</span>
}
</code></pre>
<h2 data-id="heading-2">Collection：在 Sequence 上加了三把锁</h2>
<p>Collection 额外保证</p>
<ul>
<li>可多次遍历且顺序稳定（除非自己把文档写错）</li>
<li>提供 <code>count</code>、<code>endIndex</code>、下标访问</li>
<li>支持切片、前缀、后缀等默认实现</li>
</ul>
<p>协议片段</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Collection</span>: <span class="hljs-title class_">Sequence</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Index</span>: <span class="hljs-type">Comparable</span>
    <span class="hljs-keyword">var</span> startIndex: <span class="hljs-type">Index</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> endIndex: <span class="hljs-type">Index</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">position</span>: <span class="hljs-type">Index</span>) -&gt; <span class="hljs-type">Element</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">after</span> <span class="hljs-params">i</span>: <span class="hljs-type">Index</span>) -&gt; <span class="hljs-type">Index</span>
}
</code></pre>
<p>因为多趟安全，<code>map</code>、<code>filter</code> 可以提前分配内存；</p>
<p>因为下标存在，<code>Array</code>、<code>Dictionary</code>、<code>Set</code> 都直接 conform。</p>
<h2 data-id="heading-3">for-in 的糖衣剥开长这样</h2>
<p>编译器把</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> container {
    <span class="hljs-built_in">print</span>(element)
}
</code></pre>
<p>翻译成</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">var</span> iterator <span class="hljs-operator">=</span> container.makeIterator()
<span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> element <span class="hljs-operator">=</span> iterator.next() {
    <span class="hljs-built_in">print</span>(element)
}
</code></pre>
<p>理解这段模板代码，你就能：</p>
<ul>
<li>在 Playground 里手动模拟 <code>for</code> 循环</li>
<li>把“遍历同时修改”的崩溃场景复现出来</li>
</ul>
<h2 data-id="heading-4">遍历同时修改：崩溃现场与三种安全写法</h2>
<p>现场：遍历数组时删除元素</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">var</span> todoItems <span class="hljs-operator">=</span> [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>]

<span class="hljs-comment">// 目前倒是没有崩溃，但是也不是很符合逻辑</span>
<span class="hljs-keyword">for</span> (index, item) <span class="hljs-keyword">in</span> todoItems.enumerated() {
    <span class="hljs-keyword">if</span> item <span class="hljs-operator">==</span> <span class="hljs-string">"B"</span> {
        todoItems.remove(at: index)   <span class="hljs-comment">// ❌ Fatal error: Collection modified while enumerating</span>
    }
}
</code></pre>
<p>原因：数组缓冲区搬迁，迭代器指针失效。</p>
<p>三种安全写法：</p>
<ol>
<li>官方一次性 API</li>
</ol>
<pre><code class="hljs language-swift" lang="swift">todoItems.removeAll { <span class="hljs-variable">$0</span> <span class="hljs-operator">==</span> <span class="hljs-string">"B"</span> }
</code></pre>
<ol start="2">
<li>先记下索引，后删除</li>
</ol>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">let</span> indexesToRemove <span class="hljs-operator">=</span> todoItems.indices.filter { todoItems[<span class="hljs-variable">$0</span>] <span class="hljs-operator">==</span> <span class="hljs-string">"B"</span> }
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> indexesToRemove.reversed() {
    todoItems.remove(at: i)
}
</code></pre>
<ol start="3">
<li>过滤后整体替换</li>
</ol>
<pre><code class="hljs language-swift" lang="swift">todoItems <span class="hljs-operator">=</span> todoItems.filter { <span class="hljs-variable">$0</span> <span class="hljs-operator">!=</span> <span class="hljs-string">"B"</span> }
</code></pre>
<h2 data-id="heading-5">AsyncSequence：把“迭代”搬到异步世界</h2>
<p>协议定义</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AsyncSequence</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">AsyncIterator</span>: <span class="hljs-type">AsyncIteratorProtocol</span> <span class="hljs-keyword">where</span> <span class="hljs-type">AsyncIterator</span>.<span class="hljs-type">Element</span> <span class="hljs-operator">==</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeAsyncIterator</span>() -&gt; <span class="hljs-type">AsyncIterator</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AsyncIteratorProtocol</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() <span class="hljs-keyword">async</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Element</span>?
}
</code></pre>
<p>消费方式</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> element <span class="hljs-keyword">in</span> stream {
    <span class="hljs-built_in">print</span>(element)          <span class="hljs-comment">// 会在每次 next() 挂起时让出线程</span>
}
</code></pre>
<p>桥接回调式 API 的模板：进度条场景</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">makeProgressStream</span>() -&gt; <span class="hljs-type">AsyncStream</span>&lt;<span class="hljs-type">Double</span>&gt; {
    <span class="hljs-type">AsyncStream</span> { continuation <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">let</span> token <span class="hljs-operator">=</span> <span class="hljs-type">ProgressCenter</span>.onUpdate { value <span class="hljs-keyword">in</span>
            continuation.yield(value)
            <span class="hljs-keyword">if</span> value <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1.0</span> { continuation.finish() }
        }
        continuation.onTermination <span class="hljs-operator">=</span> { <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span>
            <span class="hljs-type">ProgressCenter</span>.removeObserver(token)
        }
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-type">Task</span> {
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> p <span class="hljs-keyword">in</span> makeProgressStream() {
        progressView.progress <span class="hljs-operator">=</span> <span class="hljs-type">Float</span>(p)
    }
}
</code></pre>
<h2 data-id="heading-6">自己动手：一个固定容量的 RingBuffer</h2>
<p>需求：保持最新 N 条日志，支持 for-in 打印。</p>
<pre><code class="hljs language-swift" lang="swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RingBuffer</span>&lt;<span class="hljs-title class_">Element</span>&gt;: <span class="hljs-title class_">Collection</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> storage: [<span class="hljs-type">Element</span>?]   <span class="hljs-comment">// 用 Optional 占位</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> head <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tail <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">private(set)</span> <span class="hljs-keyword">var</span> count <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> capacity: <span class="hljs-type">Int</span>
    
    <span class="hljs-keyword">init</span>(<span class="hljs-params">capacity</span>: <span class="hljs-type">Int</span>) {
        <span class="hljs-keyword">self</span>.capacity <span class="hljs-operator">=</span> capacity
        storage <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>(repeating: <span class="hljs-literal">nil</span>, count: capacity)
    }
    
    <span class="hljs-comment">// 写入新元素，覆盖最旧数据</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">append</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">newElement</span>: <span class="hljs-type">Element</span>) {
        storage[tail] <span class="hljs-operator">=</span> newElement
        tail <span class="hljs-operator">=</span> (tail <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">%</span> capacity
        <span class="hljs-keyword">if</span> count <span class="hljs-operator">==</span> capacity {
            head <span class="hljs-operator">=</span> (head <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">%</span> capacity   <span class="hljs-comment">// 丢弃最旧</span>
        } <span class="hljs-keyword">else</span> {
            count <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>
        }
    }
    
    <span class="hljs-comment">// MARK: Collection 必备</span>
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">Index</span> <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>
    
    <span class="hljs-keyword">var</span> startIndex: <span class="hljs-type">Int</span> { <span class="hljs-number">0</span> }
    <span class="hljs-keyword">var</span> endIndex: <span class="hljs-type">Int</span> { count }
    
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">after</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> {
        <span class="hljs-built_in">precondition</span>(i <span class="hljs-operator">&lt;</span> endIndex, <span class="hljs-string">"Index out of bounds"</span>)
        <span class="hljs-keyword">return</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>
    }
    
    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">position</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Element</span> {
        <span class="hljs-built_in">precondition</span>((<span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>count).contains(position), <span class="hljs-string">"Index out of bounds"</span>)
        <span class="hljs-keyword">let</span> offset <span class="hljs-operator">=</span> (head <span class="hljs-operator">+</span> position) <span class="hljs-operator">%</span> capacity
        <span class="hljs-keyword">return</span> storage[offset]<span class="hljs-operator">!</span>
    }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">var</span> buffer <span class="hljs-operator">=</span> <span class="hljs-type">RingBuffer</span>&lt;<span class="hljs-type">Int</span>&gt;(capacity: <span class="hljs-number">3</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">5</span> {
    buffer.append(i)   <span class="hljs-comment">// 1,2,3 → 2,3,4 → 3,4,5</span>
}

<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> buffer {
    <span class="hljs-built_in">print</span>(value)   <span class="hljs-comment">// 3 4 5</span>
}
</code></pre>
<h2 data-id="heading-7">总结与扩展场景</h2>
<ol>
<li>协议层次</li>
</ol>
<p><code>IteratorProtocol</code> → <code>Sequence</code> → <code>Collection</code> → <code>BidirectionalCollection</code> → <code>RandomAccessCollection</code></p>
<p>每一层只加必要约束，绝不多要一颗糖。</p>
<ol start="2">
<li>值语义是 Swift 迭代的灵魂</li>
</ol>
<p>结构体迭代器复制即“新游标”，避免共享状态，这点与 Objective-C 的 NSEnumerator 形成鲜明对比。</p>
<ol start="3">
<li>遍历同时修改的崩溃本质是“迭代器失效”</li>
</ol>
<p>所有带指针/索引的集合都存在，掌握“先记录后改”或“一次性 API”即可。</p>
<ol start="4">
<li>AsyncSequence 让“事件流”变成普通 for-in</li>
</ol>
<p>网络下载、蓝牙数据、用户点击序列都能用同一套思维建模；配合 <code>AsyncStream</code> 几乎零成本桥接老代码。</p>
<ol start="5">
<li>自定义 Collection 是架构试金石</li>
</ol>
<p>RingBuffer 这类小容器写一遍，你会深刻理解“下标换算”、“容量与 count 区别”、“前置条件断言”这些日常被标准库隐藏的细节。</p>
<h2 data-id="heading-8">学习资料</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.donnywals.com%2Fa-deep-dive-into-collections-sequences-and-iterators-in-swift%2F" target="_blank" title="https://www.donnywals.com/a-deep-dive-into-collections-sequences-and-iterators-in-swift/" ref="nofollow noopener noreferrer">www.donnywals.com/a-deep-dive…</a></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Nacos 源码深度畅游：注册中心核心流程详解]]></title>    <link>https://juejin.cn/post/7572537221540560911</link>    <guid>https://juejin.cn/post/7572537221540560911</guid>    <pubDate>2025-11-16T01:15:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572537221540560911" data-draft-id="7572502156486606874" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Nacos 源码深度畅游：注册中心核心流程详解"/> <meta itemprop="keywords" content="后端,GitHub,分布式"/> <meta itemprop="datePublished" content="2025-11-16T01:15:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="方圆想当图灵"/> <meta itemprop="url" content="https://juejin.cn/user/386633160473101"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Nacos 源码深度畅游：注册中心核心流程详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/386633160473101/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    方圆想当图灵
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T01:15:36.000Z" title="Sun Nov 16 2025 01:15:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，我是 <strong>方圆</strong>。本篇文章我们来了解一下 Nacos 另一大功能：<strong>注册中心</strong>。本文会先介绍一下 Nacos 注册中心的数据存储模型，让大家对 Nacos 注册中心有一个大致的理解，随后根据流程图简要介绍 Nacos 注册中心的核心流程，避免直接阅读源码时太过晦涩，并让大家对 Nacos 注册中心有一个基本的了解，随后阅读这一部分源码能让大家对分布式服务或注册中心有一个更好的认识，更好的理解 CP 或 AP 定理；注册中心内对数据一致性的保证；以及复杂流程中如何将各个操作解耦并不使操作丢失等等，以辅助大家日后的系统设计。</p>
<hr/>
<p>Nacos 的注册中心服务将服务的注册信息的 <strong>存储模型</strong> 分为三级，如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1efe507f1b814d8fb8154e6a881fe0f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=pZjupmcm1sQSwZGm3dnaLF9BGPA%3D" alt="img_2.png" loading="lazy"/></p>
<ol>
<li>一级是 <strong>服务</strong>：例如系统的微服务划分，提供用户服务的 <code>user-service</code>，服务的类定义在 Nacos 中是 <code>com.alibaba.nacos.naming.core.v2.pojo.Service</code></li>
<li>二级是 <strong>集群</strong>：比如可以按区域机房划分集群，北京集群、上海集群、广州集群等等，集群在 Nacos 中没有专门的类定义，使用 <code>clusterName</code> 识别</li>
<li>三级是 <strong>实例</strong>：例如北京机房的某台服务器部署的某个实例，实例的类定义在 Nacos 中是 <code>com.alibaba.nacos.api.naming.pojo.Instance</code></li>
</ol>
<p>如果我们向 <code>test-server</code> 服务下，集群为 <code>clusterA</code> 下注册两个实例时（默认 public 的命名空间），在控制台查询实例信息时如下所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74bad56d73de417ba3787f5c94b46b4a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=xVvXXpTJR5rwElMiC0cUdGZYACw%3D" alt="img_3.png" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ad7092ab3594418815cd1f4898b4ee1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=1YIPxPzIozbwoSMEOE7gG9O5Mz8%3D" alt="img_4.png" loading="lazy"/></p>
<p>在服务详情中会展示这个集群下所有的实例信息。在深入分析源码之前，我们还是根据流程图简述一下 Nacos 作为注册中心时，注册实例信息的核心流程：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/82d5e2b6f92d4684befb47e65262331d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=EY6A5O2YJRhCBnHrAEK%2FIOP%2BarM%3D" alt="nacos-naming.drawio.png" loading="lazy"/></p>
<p>首先，Nacos Client 会对 Nacos Server 集群中某一个节点发送 gRPC 请求进行实例注册；服务端处理客户端请求时，会先将 <strong>Service 信息</strong> 和 <strong>实例信息</strong> 写入本地缓存，并触发 <code>ClientRegisterServiceEvent</code> 和 <code>ClientChangedEvent</code> 两个事件。</p>
<p><code>ClientRegisterServiceEvent</code> 事件的作用是创建推送给订阅了服务的客户端的任务，在 <code>ScheduledExecutorService</code> 中定时异步执行，并且有失败重试机制，保证客户端及时接收到注册实例发生变更的数据。</p>
<p><code>ClientChangedEvent</code> 事件的作用是创建延迟执行 Distro 协议数据同步的任务，同样也是依赖 <code>ScheduledExecutorService</code> 延迟执行。<strong>Distro 协议是 Nacos 中专门用于处理临时实例数据一致性的分布式协议</strong>，它保证集群内数据一致性的方法非常简单，由接收到实例注册信息的节点将数据异步发送给集群内其他节点，其他节点会向该节点一样执行一次实例注册的流程。能通过这么简单的方式来完成数据同步，因为以下原因：</p>
<ol>
<li><strong>服务注册数据模型的属性简化了分布式一致性问题，避免了复杂的冲突解决机制</strong>：<strong>服务实例通过多个维度确定唯一性</strong>：命名空间 + 服务名 + 集群名 + IP地址 + 端口号，这种唯一性设计确保了同一个服务实例的注册信息在任何节点都是相同的，所以同一实例的注册信息在不同节点、不同时间先后写入都不会存在数据冲突问题，<strong>写入操作是幂等的</strong>，大大降低了保证数据一致性的复杂度</li>
<li>服务实例的注册信息是 <strong>临时数据</strong>：数据具有生命周期，会自动过期或被清理，不需要持久化存储，丢失后可以重新生成，降低了维护实例数据的难度</li>
<li>业务场景能够接受数据的 <strong>最终一致性</strong>：可用性（Availability）比一致性（Consistency）更重要，短时间内部分实例注册信息不一致不影响业务</li>
<li>多个 Nacos Client 客户端会连接到不同的 Nacos Server 服务端，相当于进行了 <strong>分片</strong>：每个服务节点负责特定的客户端实例，客户端注册的操作基本只在一个服务节点发生，大大降低了发生写入冲突的可能</li>
</ol>
<p>所以 Distro 协议才能如此简单和高效，保证 Nacos 集群内注册实例信息的 <strong>最终一致性</strong>。以上便是在 Nacos 注册中心注册实例的大致流程，做了一些省略，但是主要的原理没有改变：同步写入本地缓存记录服务和实例信息，异步处理事件执行客户端的订阅推送和 Distro 协议的数据同步，保证集群内实例信息的数据一致性，如果大家想深入到源码的细节中，欢迎阅读以下内容。</p>
<h3 data-id="heading-0">源码分析</h3>
<p>以如下源码来作为注册服务实例的入口来验证向 Nacos 注册中心注册服务实例的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNaming</span> {
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNacosNamingService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, NacosException {
        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
        properties.put(PropertyKeyConst.SERVER_ADDR, <span class="hljs-string">"127.0.0.1:8848"</span>);
        properties.put(PropertyKeyConst.NAMESPACE, <span class="hljs-string">"public"</span>);
        <span class="hljs-type">NamingService</span> <span class="hljs-variable">namingService</span> <span class="hljs-operator">=</span> NacosFactory.createNamingService(properties);

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 注册一个服务实例</span>
            namingService.registerInstance(<span class="hljs-string">"test-service"</span>, <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">"clusterA"</span>);

            <span class="hljs-comment">// 添加事件监听器</span>
            namingService.subscribe(<span class="hljs-string">"test-service"</span>, event -&gt; System.out.println(<span class="hljs-string">"服务实例变化: "</span> + event));
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"服务注册失败(预期，因为服务器可能未启动): "</span> + e.getMessage());
        }

        TimeUnit.HOURS.sleep(<span class="hljs-number">5</span>);

        namingService.shutDown();
    }
}
</code></pre>
<p>最先它会执行 <code>NamingService#registerInstance</code> 方法，<code>Instance</code> 对象便是存储模型的实例信息：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosNamingService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NamingService</span> {

    <span class="hljs-keyword">private</span> NamingClientProxy clientProxy;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(String serviceName, String groupName, String ip, <span class="hljs-type">int</span> port, String clusterName)</span>
            <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-type">Instance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Instance</span>();
        instance.setIp(ip);
        instance.setPort(port);
        <span class="hljs-comment">// 默认权重值为 1</span>
        instance.setWeight(<span class="hljs-number">1.0</span>);
        instance.setClusterName(clusterName);
        registerInstance(serviceName, groupName, instance);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 参数校验</span>
        NamingUtils.checkInstanceIsLegal(instance);
        checkAndStripGroupNamePrefix(instance, groupName);
        <span class="hljs-comment">// 在这里实际上使用了静态代理模式来区分是使用 HTTPClient 还是 GrpcClient，默认为后者</span>
        clientProxy.registerService(serviceName, groupName, instance);
    }
}
</code></pre>
<p>实际执行注册的为 <code>NamingGrpcClientProxy</code> 实现类，在向注册中心注册服务的逻辑中，我们 <strong>只关注创建临时（Ephemeral）服务实例</strong> 的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingGrpcClientProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNamingClientProxy</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NamingGrpcRedoService redoService;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerService</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span> <span class="hljs-keyword">throws</span> NacosException {
        NAMING_LOGGER.info(<span class="hljs-string">"[REGISTER-SERVICE] {} registering service {} with instance {}"</span>, namespaceId, serviceName,
                instance);
        <span class="hljs-comment">// [registerInstance] 步骤1：创建服务实例区分是否为临时</span>
        <span class="hljs-keyword">if</span> (instance.isEphemeral()) { 
            registerServiceForEphemeral(serviceName, groupName, instance);
        } <span class="hljs-keyword">else</span> {
            doRegisterServiceForPersistent(serviceName, groupName, instance);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerServiceForEphemeral</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span>
            <span class="hljs-keyword">throws</span> NacosException {
        redoService.cacheInstanceForRedo(serviceName, groupName, instance);
        doRegisterService(serviceName, groupName, instance);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterService</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 客户端创建注册实例请求对象，包含命名空间、服务名、分组名和实例信息</span>
        <span class="hljs-type">InstanceRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceRequest</span>(namespaceId, serviceName, groupName,
                NamingRemoteConstants.REGISTER_INSTANCE, instance);
        <span class="hljs-comment">// [registerInstance] 步骤2：通过gRPC协议向服务端发送注册请求</span>
        requestToServer(request, Response.class);
        redoService.instanceRegistered(serviceName, groupName);
    }
}
</code></pre>
<p>在上述步骤中，可以发现分别两次调用了 <code>redoServer</code> 的 <code>cacheInstanceForRedo</code> 和 <code>instanceRegistered</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingGrpcRedoService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConnectionEventListener</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, InstanceRedoData&gt; registeredInstances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    
    <span class="hljs-comment">// 创建 InstanceRedoData 对象在 ConcurrentMap 中</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cacheInstanceForRedo</span><span class="hljs-params">(String serviceName, String groupName, Instance instance)</span> {
        <span class="hljs-comment">// eg: DEFAULT_GROUP@@test-service</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);
        <span class="hljs-type">InstanceRedoData</span> <span class="hljs-variable">redoData</span> <span class="hljs-operator">=</span> InstanceRedoData.build(serviceName, groupName, instance);
        <span class="hljs-keyword">synchronized</span> (registeredInstances) {
            registeredInstances.put(key, redoData);
        }
    }
}
</code></pre>
<p>首先它会创建 <code>InstanceRedoData</code> 对象保存在 <code>ConcurrentMap</code> 中，初始字段值如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e384e223d7864c9e8ffe2f6384976b38~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=GjJ0dffh%2BVrt%2BPLe5jHzzQZ1NtA%3D" alt="img.png" loading="lazy"/></p>
<p>在成功调用向服务端注册实例后，会将 <code>InstanceRedoData#registered</code> 字段标记为 true：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingGrpcRedoService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConnectionEventListener</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, InstanceRedoData&gt; registeredInstances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instanceRegistered</span><span class="hljs-params">(String serviceName, String groupName)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> NamingUtils.getGroupedName(serviceName, groupName);
        <span class="hljs-keyword">synchronized</span> (registeredInstances) {
            <span class="hljs-type">InstanceRedoData</span> <span class="hljs-variable">redoData</span> <span class="hljs-operator">=</span> registeredInstances.get(key);
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != redoData) {
                <span class="hljs-comment">// 标记 registered 字段为 true</span>
                redoData.registered();
            }
        }
    }
}
</code></pre>
<p>至于 <code>InstanceRedoData</code> 对象有什么作用我们之后再看，我们还是先回到 gRPC 请求服务端注册实例的逻辑中。Nacos Client 会向服务端发送 <code>InstanceRequest</code> 请求，并有 Nacos Server 端的 <code>InstanceRequestHandler</code> 承接：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceRequestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestHandler</span>&lt;InstanceRequest, InstanceResponse&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EphemeralClientOperationServiceImpl clientOperationService;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InstanceRequestHandler</span><span class="hljs-params">(EphemeralClientOperationServiceImpl clientOperationService)</span> {
        <span class="hljs-built_in">this</span>.clientOperationService = clientOperationService;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@NamespaceValidation</span>
    <span class="hljs-meta">@TpsControl(pointName = "RemoteNamingInstanceRegisterDeregister", name = "RemoteNamingInstanceRegisterDeregister")</span>
    <span class="hljs-meta">@Secured(action = ActionTypes.WRITE)</span>
    <span class="hljs-meta">@ExtractorManager</span>.Extractor(rpcExtractor = InstanceRequestParamExtractor.class)
    <span class="hljs-keyword">public</span> InstanceResponse <span class="hljs-title function_">handle</span><span class="hljs-params">(InstanceRequest request, RequestMeta meta)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// [registerInstance] 步骤3：根据请求参数创建服务对象，设置为ephemeral（临时）服务</span>
        <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Service.newService(request.getNamespace(), request.getGroupName(), request.getServiceName(),
                <span class="hljs-literal">true</span>);
        InstanceUtil.setInstanceIdIfEmpty(request.getInstance(), service.getGroupedServiceName());
        <span class="hljs-keyword">switch</span> (request.getType()) {
            <span class="hljs-keyword">case</span> NamingRemoteConstants.REGISTER_INSTANCE:
                <span class="hljs-comment">// 根据请求类型分发到具体的注册实例方法</span>
                <span class="hljs-keyword">return</span> registerInstance(service, request, meta);
            <span class="hljs-keyword">case</span> NamingRemoteConstants.DE_REGISTER_INSTANCE:
                <span class="hljs-keyword">return</span> deregisterInstance(service, request, meta);
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosException</span>(NacosException.INVALID_PARAM,
                        String.format(<span class="hljs-string">"Unsupported request type %s"</span>, request.getType()));
        }
    }

    <span class="hljs-keyword">private</span> InstanceResponse <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(Service service, InstanceRequest request, RequestMeta meta)</span>
            <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 调用客户端操作服务注册实例，传入服务、实例和连接ID</span>
        clientOperationService.registerInstance(service, request.getInstance(), meta.getConnectionId());
        <span class="hljs-comment">// 发布实例注册跟踪事件，记录注册操作的详细信息</span>
        NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegisterInstanceTraceEvent</span>(System.currentTimeMillis(),
                NamingRequestUtil.getSourceIpForGrpcRequest(meta), <span class="hljs-literal">true</span>, service.getNamespace(), service.getGroup(),
                service.getName(), request.getInstance().getIp(), request.getInstance().getPort()));
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceResponse</span>(NamingRemoteConstants.REGISTER_INSTANCE);
    }
}
</code></pre>
<p>它会创建 <code>Service</code> 对象，它是存储模型中的服务信息，如下所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37b23fbb9a9e4a7ea343c8d4e90d6487~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pa55ZyG5oOz5b2T5Zu-54G1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860535&amp;x-signature=bDn4A65AAZlt%2BrS0O7PvXd7rfx8%3D" alt="img_1.png" loading="lazy"/></p>
<p>接下来我们先深入到其中调用的 <code>EphemeralClientOperationServiceImpl#registerInstance</code> 方法中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EphemeralClientOperationServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClientOperationService</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerInstance</span><span class="hljs-params">(Service service, Instance instance, String clientId)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-comment">// 验证实例的合法性（IP、端口等）</span>
        NamingUtils.checkInstanceIsLegal(instance);

        <span class="hljs-comment">// [registerInstance] 步骤4：从服务管理器获取单例服务对象</span>
        <span class="hljs-type">Service</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> ServiceManager.getInstance().getSingleton(service);
        <span class="hljs-keyword">if</span> (!singleton.isEphemeral()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosRuntimeException</span>(NacosException.INVALID_PARAM,
                    String.format(<span class="hljs-string">"Current service %s is persistent service, can't register ephemeral instance."</span>,
                            singleton.getGroupedServiceName()));
        }
        <span class="hljs-comment">// 获取客户端连接对象并验证其合法性</span>
        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> clientManager.getClient(clientId);
        checkClientIsLegal(client, clientId);
        <span class="hljs-comment">// 将实例信息转换为发布信息对象</span>
        <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">instanceInfo</span> <span class="hljs-operator">=</span> getPublishInfo(instance);
        <span class="hljs-comment">// [registerInstance] 步骤5：将实例信息 InstancePublishInfo 添加到客户端的服务实例列表中</span>
        client.addServiceInstance(singleton, instanceInfo);
        client.setLastUpdatedTime();
        client.recalculateRevision();
        <span class="hljs-comment">// 发布客户端注册服务事件</span>
        NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientOperationEvent</span>(singleton, clientId));
        <span class="hljs-comment">// 发布实例元数据事件，完成注册流程</span>
        NotifyCenter
                .publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MetadataEvent</span>.InstanceMetadataEvent(singleton, instanceInfo.getMetadataId(), <span class="hljs-literal">false</span>));
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceManager</span> {

    <span class="hljs-comment">// 单例模式：饿汉式</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ServiceManager</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceManager</span>();
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ServiceManager <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> INSTANCE;
    }


    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Service, Service&gt; singletonRepository;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;Service&gt;&gt; namespaceSingletonMaps;

    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ServiceManager</span><span class="hljs-params">()</span> {
        singletonRepository = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>);
        namespaceSingletonMaps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>);
    }
    
    <span class="hljs-keyword">public</span> Service <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(Service service)</span> {
        <span class="hljs-comment">// 首先在 singletonRepository 中查找或创建服务单例</span>
        <span class="hljs-type">Service</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> singletonRepository.computeIfAbsent(service, key -&gt; {
            NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MetadataEvent</span>.ServiceMetadataEvent(service, <span class="hljs-literal">false</span>));
            <span class="hljs-keyword">return</span> service;
        });
        <span class="hljs-comment">// [registerInstance] 关键数据写入：将服务添加到命名空间服务映射表中 namespaceSingletonMaps</span>
        namespaceSingletonMaps.computeIfAbsent(result.getNamespace(), namespace -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashSet</span>&lt;&gt;()).add(result);
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre>
<p>在 <strong>[registerInstance] 步骤4</strong> 中完成了 <strong>服务实例信息注册后本地缓存的写入</strong>，它会被记录到 <code>ServiceManager#singletonRepository</code> 和 <code>ServiceManager#namespaceSingletonMaps</code> 两个变量中，并且在在首次通过 <code>ConcurrentHashMap#computeIfAbsent</code> 方法添加时会触发 <code>ServiceMetadataEvent</code> 事件，这个事件用于更新服务信息的元数据，比较简单就不再解释了，这有一点 <strong>代码规范</strong> 需要注意：它将 <code>ServiceManager#getSingleton</code> 命名为获取服务实例的方法，但是却在这个 <code>get</code> 方法中执行了写入逻辑，具有迷惑性，应该修改命名为 <code>registerAndGetSingleton</code> 才对。再回到 <code>registerInstance</code> 方法中，<strong>[registerInstance] 步骤5</strong> 也是一段重要的逻辑，它会在 <code>ConcurrentHashMap&lt;Service, InstancePublishInfo&gt; publishers</code> 记录注册实例的发布信息 <code>InstancePublishInfo</code>，包含 <strong>实例的 IP，端口和集群等必要信息</strong>，后续会从发布信息中来获取这些字段值，并且会触发 <code>ClientChangedEvent</code> 事件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Client</span> {

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Service, InstancePublishInfo&gt; publishers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">1</span>);
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addServiceInstance</span><span class="hljs-params">(Service service, InstancePublishInfo instancePublishInfo)</span> {
        <span class="hljs-keyword">if</span> (instancePublishInfo <span class="hljs-keyword">instanceof</span> BatchInstancePublishInfo) {
            <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> publishers.put(service, instancePublishInfo);
            MetricsMonitor.incrementIpCountWithBatchRegister(old, (BatchInstancePublishInfo) instancePublishInfo);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 记录实例的发布信息，用于后续从发布信息中解析获取注册实例的 IP 信息等</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == publishers.put(service, instancePublishInfo)) {
                MetricsMonitor.incrementInstanceCount();
            }
        }
        <span class="hljs-comment">// 触发 ClientChangedEvent 事件</span>
        NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientEvent</span>.ClientChangedEvent(<span class="hljs-built_in">this</span>));
        Loggers.SRV_LOG.info(<span class="hljs-string">"Client change for service {}, {}"</span>, service, getClientId());
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>在 <code>registerInstance</code> 方法中还会发布两个事件：<code>ClientRegisterServiceEvent</code> 和 <code>InstanceMetadataEvent</code>，后者用于写入实例的元数据比较简单，就不再赘述了。在以上逻辑中，我们知道了服务信息 <code>Service</code> 被记录在了 <code>ServiceManager</code> 中，服务下实例的信息被保存在了 <code>AbstractClient#publishers</code> 字段中，接下来我们看 <code>ClientRegisterServiceEvent</code> 事件和 <code>ClientChangedEvent</code> 事件是如何被处理的。</p>
<h4 data-id="heading-1">ClientRegisterServiceEvent</h4>
<p><code>ClientRegisterServiceEvent</code> 事件由 <code>ClientServiceIndexesManager</code> 订阅并消费，在这里也会记录服务信息，如下方代码所示，它还会触发 <code>ServiceChangedEvent</code> 事件：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientServiceIndexesManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SmartSubscriber</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Service, Set&lt;String&gt;&gt; publisherIndexes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleClientOperation</span><span class="hljs-params">(ClientOperationEvent event)</span> {
        <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> event.getService();
        <span class="hljs-type">String</span> <span class="hljs-variable">clientId</span> <span class="hljs-operator">=</span> event.getClientId();
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientOperationEvent.ClientRegisterServiceEvent) {
            <span class="hljs-comment">// [registerInstance] 步骤6：处理客户端注册服务事件，将服务和客户端ID添加到发布者索引 publisherIndexes 中</span>
            addPublisherIndexes(service, clientId);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientOperationEvent.ClientDeregisterServiceEvent) {
            removePublisherIndexes(service, clientId);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientOperationEvent.ClientSubscribeServiceEvent) {
            addSubscriberIndexes(service, clientId);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientOperationEvent.ClientUnsubscribeServiceEvent) {
            removeSubscriberIndexes(service, clientId);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPublisherIndexes</span><span class="hljs-params">(Service service, String clientId)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">serviceChangedType</span> <span class="hljs-operator">=</span> Constants.ServiceChangedType.INSTANCE_CHANGED;
        <span class="hljs-keyword">if</span> (!publisherIndexes.containsKey(service)) {
            <span class="hljs-comment">// 唯一需要更新索引的时间是 "首次" 创建服务的时</span>
            serviceChangedType = Constants.ServiceChangedType.ADD_SERVICE;
        }
        <span class="hljs-comment">// 发布服务变更事件，通知订阅者有新的服务实例注册</span>
        NotifyCenter.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceEvent</span>.ServiceChangedEvent(service, serviceChangedType, <span class="hljs-literal">true</span>));
        publisherIndexes.computeIfAbsent(service, key -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashSet</span>&lt;&gt;()).add(clientId);
    }
}
</code></pre>
<p><code>ServiceChangedEvent</code> 事件被 <code>NamingSubscriberServiceV2Impl</code> 订阅并消费：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamingSubscriberServiceV2Impl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SmartSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NamingSubscriberService</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTaskExecuteEngine delayTaskEngine;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Event event)</span> {
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ServiceEvent.ServiceChangedEvent) {
            <span class="hljs-comment">// [registerInstance] 步骤7：处理服务变更事件，创建推送任务将服务变更通知给所有订阅者</span>
            ServiceEvent.<span class="hljs-type">ServiceChangedEvent</span> <span class="hljs-variable">serviceChangedEvent</span> <span class="hljs-operator">=</span> (ServiceEvent.ServiceChangedEvent) event;
            <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> serviceChangedEvent.getService();
            delayTaskEngine.addTask(service, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushDelayTask</span>(service, PushConfig.getInstance().getPushTaskDelay()));
            MetricsMonitor.incrementServiceChangeCount(service);
        }
    }
}
</code></pre>
<p>它会创建一个 <code>PushDelayTask</code> 添加到 <code>NacosDelayTaskExecuteEngine#tasks</code> 中，这个 <code>NacosDelayTaskExecuteEngine</code> 我们在配置发布的章节介绍过，本质上它是一个 <code>ScheduledExecutorService</code> 在每 100ms 执行一个 <code>ConcurrentHashMap&lt;Object, AbstractDelayTask&gt; tasks</code> 的任务。接下来我们先来了解一下 <code>PushDelayTask</code> 任务，重点关注注释信息：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushDelayTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDelayTask</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Service service;

    <span class="hljs-comment">// 是否推送给所有订阅服务信息的 Client</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> pushToAll;

    <span class="hljs-keyword">private</span> Set&lt;String&gt; targetClients;

    <span class="hljs-comment">// 创建推送所有订阅者的任务，上文中便是调用的这个构造函数</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PushDelayTask</span><span class="hljs-params">(Service service, <span class="hljs-type">long</span> delay)</span> {
        <span class="hljs-built_in">this</span>.service = service;
        pushToAll = <span class="hljs-literal">true</span>;
        targetClients = <span class="hljs-literal">null</span>;
        setTaskInterval(delay);
        setLastProcessTime(System.currentTimeMillis());
    }

    <span class="hljs-comment">// 创建推送某一个订阅者的任务，专门用于处理某个 IP 推送失败的情况</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PushDelayTask</span><span class="hljs-params">(Service service, <span class="hljs-type">long</span> delay, String targetClient)</span> {
        <span class="hljs-built_in">this</span>.service = service;
        <span class="hljs-built_in">this</span>.pushToAll = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">this</span>.targetClients = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(<span class="hljs-number">1</span>);
        <span class="hljs-built_in">this</span>.targetClients.add(targetClient);
        setTaskInterval(delay);
        setLastProcessTime(System.currentTimeMillis());
    }

    <span class="hljs-comment">// 合并任务，避免多次重复调用</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(AbstractDelayTask task)</span> {
        <span class="hljs-keyword">if</span> (!(task <span class="hljs-keyword">instanceof</span> PushDelayTask)) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-type">PushDelayTask</span> <span class="hljs-variable">oldTask</span> <span class="hljs-operator">=</span> (PushDelayTask) task;
        <span class="hljs-keyword">if</span> (isPushToAll() || oldTask.isPushToAll()) {
            pushToAll = <span class="hljs-literal">true</span>;
            targetClients = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
            targetClients.addAll(oldTask.getTargetClients());
        }
        setLastProcessTime(Math.min(getLastProcessTime(), task.getLastProcessTime()));
        Loggers.PUSH.info(<span class="hljs-string">"[PUSH] Task merge for {}"</span>, service);
    }

    <span class="hljs-keyword">public</span> Service <span class="hljs-title function_">getService</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> service;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPushToAll</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> pushToAll;
    }

    <span class="hljs-comment">// 获取目标推送 Client</span>
    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getTargetClients</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> targetClients;
    }
}
</code></pre>
<p>我们能了解到 <code>PushDelayTask</code> 能够 <strong>区分是推送给所有客户端还是只推送单一客户端，这么做的目的是可以针对某些推送异常的客户端进行任务重试</strong>。随后 <code>PushDelayTask</code> 会被 <code>PushDelayTaskProcessor</code> 处理，会被封装到 <code>PushExecuteTask</code> 任务中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushDelayTaskProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NacosTaskProcessor</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTaskExecuteEngine executeEngine;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PushDelayTaskProcessor</span><span class="hljs-params">(PushDelayTaskExecuteEngine executeEngine)</span> {
        <span class="hljs-built_in">this</span>.executeEngine = executeEngine;
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(NacosTask task)</span> {
        <span class="hljs-type">PushDelayTask</span> <span class="hljs-variable">pushDelayTask</span> <span class="hljs-operator">=</span> (PushDelayTask) task;
        <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> pushDelayTask.getService();
        <span class="hljs-comment">// [registerInstance] 步骤8：分发推送任务到执行器，准备将服务变更推送给客户端</span>
        NamingExecuteTaskDispatcher.getInstance()
                .dispatchAndExecuteTask(service, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushExecuteTask</span>(service, executeEngine, pushDelayTask));
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p><code>NamingExecuteTaskDispatcher#dispatchAndExecuteTask</code> 方法会执行到如下逻辑中，分配给某一条线程去处理：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosExecuteTaskExecuteEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNacosTaskExecuteEngine</span>&lt;AbstractExecuteTask&gt; {

    <span class="hljs-comment">// 本质上是多条线程</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TaskExecuteWorker[] executeWorkers;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NacosExecuteTaskExecuteEngine</span><span class="hljs-params">(String name, Logger logger, <span class="hljs-type">int</span> dispatchWorkerCount)</span> {
        <span class="hljs-built_in">super</span>(logger);
        executeWorkers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskExecuteWorker</span>[dispatchWorkerCount];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; mod &lt; dispatchWorkerCount; ++mod) {
            executeWorkers[mod] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskExecuteWorker</span>(name, mod, dispatchWorkerCount, getEngineLog());
        }
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTask</span><span class="hljs-params">(Object tag, AbstractExecuteTask task)</span> {
        <span class="hljs-type">NacosTaskProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> getProcessor(tag);
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != processor) {
            processor.process(task);
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 分配给某个线程处理</span>
        <span class="hljs-type">TaskExecuteWorker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> getWorker(tag);
        worker.process(task);
    }

    <span class="hljs-keyword">private</span> TaskExecuteWorker <span class="hljs-title function_">getWorker</span><span class="hljs-params">(Object tag)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> (tag.hashCode() &amp; Integer.MAX_VALUE) % workersCount();
        <span class="hljs-keyword">return</span> executeWorkers[idx];
    }
}
</code></pre>
<p>以上逻辑还未涉及 <code>PushExecuteTask</code> 推送服务变更的逻辑处理，大家只需要了解到，至此将推送任务转交到了某个单一的线程中去执行了，接下来我们看一下 <code>PushExecuteTask</code> 的具体逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushExecuteTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecuteTask</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTaskExecuteEngine delayTaskEngine;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTask delayTask;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// [registerInstance] 步骤9：生成推送数据，包含服务实例信息和元数据</span>
            <span class="hljs-type">PushDataWrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> generatePushData();
            <span class="hljs-type">ClientManager</span> <span class="hljs-variable">clientManager</span> <span class="hljs-operator">=</span> delayTaskEngine.getClientManager();
            <span class="hljs-comment">// 遍历目标客户端，向订阅了该服务的客户端推送数据</span>
            <span class="hljs-keyword">for</span> (String each : getTargetClientIds()) {
                <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> clientManager.getClient(each);
                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == client) {
                    <span class="hljs-comment">// means this client has disconnect</span>
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-type">Subscriber</span> <span class="hljs-variable">subscriber</span> <span class="hljs-operator">=</span> client.getSubscriber(service);
                <span class="hljs-comment">// skip if null</span>
                <span class="hljs-keyword">if</span> (subscriber == <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-comment">// 通过推送执行器向客户端推送服务变更通知</span>
                delayTaskEngine.getPushExecutor().doPushWithCallback(each, subscriber, wrapper,
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServicePushCallback</span>(each, subscriber, wrapper.getOriginalData(), delayTask.isPushToAll()));
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            Loggers.PUSH.error(<span class="hljs-string">"Push task for service"</span> + service.getGroupedServiceName() + <span class="hljs-string">" execute failed "</span>, e);
            <span class="hljs-comment">// 异常重试</span>
            delayTaskEngine.addTask(service, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushDelayTask</span>(service, <span class="hljs-number">1000L</span>));
        }
    }

    <span class="hljs-comment">// 初始推送时获取所有订阅服务信息的 Client；如果不是推送所有，说明是处理失败重试的场景，则只推送目标 Client 即可</span>
    <span class="hljs-keyword">private</span> Collection&lt;String&gt; <span class="hljs-title function_">getTargetClientIds</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> delayTask.isPushToAll() ? delayTaskEngine.getIndexesManager().getAllClientsSubscribeService(service)
                : delayTask.getTargetClients();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServicePushCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NamingPushCallback</span> {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">()</span> {
            <span class="hljs-comment">// monitor and log</span>
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFail</span><span class="hljs-params">(Throwable e)</span> {
            <span class="hljs-type">long</span> <span class="hljs-variable">pushCostTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - executeStartTime;
            <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> NoRequiredRetryException)) {
                Loggers.PUSH.error(<span class="hljs-string">"Reason detail: "</span>, e);
                <span class="hljs-comment">// 如果针对某个 IP 推送失败，则创建推送针对目标 IP 的任务重试推送</span>
                delayTaskEngine.addTask(service,
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushDelayTask</span>(service, PushConfig.getInstance().getPushTaskRetryDelay(), clientId));
            }
            <span class="hljs-type">PushResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> PushResult
                    .pushFailed(service, clientId, actualServiceInfo, subscriber, pushCostTime, e, isPushToAll);
            PushResultHookHolder.getInstance().pushFailed(result);
        }
    }

}
</code></pre>
<p>从以上逻辑中可知：服务注册信息将推送给每个订阅了这个服务的 Client，如果推送失败会重新添加 <code>PushDelayTask</code> 任务重试，以此来保证订阅服务实例信息的 Client 都接收到变更。需要注意的是在 <strong>[registerInstance] 步骤9</strong> 中有以下非常关键的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushExecuteTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecuteTask</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PushDelayTaskExecuteEngine delayTaskEngine;
    
    <span class="hljs-comment">// 生成推送请求信息</span>
    <span class="hljs-keyword">private</span> PushDataWrapper <span class="hljs-title function_">generatePushData</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 获取要推送的服务信息，包含实例信息</span>
        <span class="hljs-type">ServiceInfo</span> <span class="hljs-variable">serviceInfo</span> <span class="hljs-operator">=</span> delayTaskEngine.getServiceStorage().getPushData(service);
        <span class="hljs-type">ServiceMetadata</span> <span class="hljs-variable">serviceMetadata</span> <span class="hljs-operator">=</span> delayTaskEngine.getMetadataManager().getServiceMetadata(service).orElse(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushDataWrapper</span>(serviceMetadata, serviceInfo);
    }
}

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceStorage</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Service, Set&lt;String&gt;&gt; serviceClusterIndex;
    
    <span class="hljs-keyword">public</span> ServiceInfo <span class="hljs-title function_">getPushData</span><span class="hljs-params">(Service service)</span> {
        <span class="hljs-type">ServiceInfo</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> emptyServiceInfo(service);
        <span class="hljs-keyword">if</span> (!ServiceManager.getInstance().containSingleton(service)) {
            <span class="hljs-keyword">return</span> result;
        }
        <span class="hljs-type">Service</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> ServiceManager.getInstance().getSingleton(service);
        result.setHosts(getAllInstancesFromIndex(singleton));
        serviceDataIndexes.put(singleton, result);
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">private</span> ServiceInfo <span class="hljs-title function_">emptyServiceInfo</span><span class="hljs-params">(Service service)</span> {
        <span class="hljs-type">ServiceInfo</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceInfo</span>();
        result.setName(service.getName());
        result.setGroupName(service.getGroup());
        result.setLastRefTime(System.currentTimeMillis());
        result.setCacheMillis(switchDomain.getDefaultPushCacheMillis());
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// 获取服务下所有的实例信息</span>
    <span class="hljs-keyword">private</span> List&lt;Instance&gt; <span class="hljs-title function_">getAllInstancesFromIndex</span><span class="hljs-params">(Service service)</span> {
        Set&lt;Instance&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        Set&lt;String&gt; clusters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        <span class="hljs-comment">// 获取 ClientId</span>
        <span class="hljs-keyword">for</span> (String each : serviceIndexesManager.getAllClientsRegisteredService(service)) {
            <span class="hljs-comment">// 获取实例注册信息 InstancePublishInfo</span>
            Optional&lt;InstancePublishInfo&gt; instancePublishInfo = getInstanceInfo(each, service);
            <span class="hljs-keyword">if</span> (instancePublishInfo.isPresent()) {
                <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">publishInfo</span> <span class="hljs-operator">=</span> instancePublishInfo.get();
                <span class="hljs-comment">//If it is a BatchInstancePublishInfo type, it will be processed manually and added to the instance list</span>
                <span class="hljs-keyword">if</span> (publishInfo <span class="hljs-keyword">instanceof</span> BatchInstancePublishInfo) {
                    <span class="hljs-type">BatchInstancePublishInfo</span> <span class="hljs-variable">batchInstancePublishInfo</span> <span class="hljs-operator">=</span> (BatchInstancePublishInfo) publishInfo;
                    List&lt;Instance&gt; batchInstance = parseBatchInstance(service, batchInstancePublishInfo, clusters);
                    result.addAll(batchInstance);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 根据请求时 InstancePublishInfo 的注册实例对象创建出 Instance 实例</span>
                    <span class="hljs-type">Instance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> parseInstance(service, instancePublishInfo.get());
                    result.add(instance);
                    clusters.add(instance.getClusterName());
                }
            }
        }
        <span class="hljs-comment">// 缓存记录这个服务的集群</span>
        serviceClusterIndex.put(service, clusters);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(result);
    }
}
</code></pre>
<p>在 <code>generatePushData</code> 方法中，生成了 <code>ServiceInfo</code> 对象，其中包含服务和该服务下注册的所有实例，实例信息是从 <code>InstancePublishInfo</code> 中解析出来的，实例的发布信息我们在上文中提到过。除此之外，还需要注意在 <code>getAllInstancesFromIndex</code> <strong>读方法中包含了缓存写入的逻辑</strong>，这种写法是非常不推荐的，具有迷惑性：谁会想到在读方法中还会包含写逻辑呢？所以在日常开发中一定要避免这种写法！</p>
<p>总结一下：<code>ClientRegisterServiceEvent</code> 事件的作用是将服务实例的变更信息推送给订阅了这个服务的所有客户端。</p>
<h4 data-id="heading-2">ClientChangedEvent</h4>
<p><code>ClientChangedEvent</code> 事件会被 <code>DistroClientDataProcessor</code> 订阅并消费，在它的 <code>onEvent</code> 方法中的 <code>else</code> 逻辑中可以发现它调用了 <code>syncToAllServer</code> 方法，从方法名中可以大概能猜出来，在 Nacos 采用集群模式部署时，会通过这个方法将注册的服务信息同步到其他节点上：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroClientDataProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SmartSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DistroDataStorage</span>, DistroDataProcessor {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroProtocol distroProtocol;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Event event)</span> {
        <span class="hljs-keyword">if</span> (EnvUtil.getStandaloneMode()) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientEvent.ClientVerifyFailedEvent) {
            syncToVerifyFailedServer((ClientEvent.ClientVerifyFailedEvent) event);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// [registerInstance] 步骤10：同步所有服务</span>
            syncToAllServer((ClientEvent) event);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syncToAllServer</span><span class="hljs-params">(ClientEvent event)</span> {
        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> event.getClient();
        <span class="hljs-keyword">if</span> (isInvalidClient(client)) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// 区分客户端断开连接的事件客户端变更事件</span>
        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientEvent.ClientDisconnectEvent) {
            <span class="hljs-type">DistroKey</span> <span class="hljs-variable">distroKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroKey</span>(client.getClientId(), TYPE);
            distroProtocol.sync(distroKey, DataOperation.DELETE);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ClientEvent.ClientChangedEvent) {
            <span class="hljs-type">DistroKey</span> <span class="hljs-variable">distroKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroKey</span>(client.getClientId(), TYPE);
            distroProtocol.sync(distroKey, DataOperation.CHANGE);
        }
    }
}
</code></pre>
<p>在这个方法中，可以发现调用了 <code>DistroProtocol#sync</code> 方法，<code>DistroProtocol</code> 表示 <strong>Distro 协议</strong>：<strong>专门用于处理临时实例数据一致性的分布式协议</strong>，接下来我们通过 Nacos 的逻辑来了解一下这个协议。在 <code>DistroProtocol#sync</code> 方法中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroProtocol</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroTaskEngineHolder distroTaskEngineHolder;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sync</span><span class="hljs-params">(DistroKey distroKey, DataOperation action)</span> {
        sync(distroKey, action, DistroConfig.getInstance().getSyncDelayMillis());
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sync</span><span class="hljs-params">(DistroKey distroKey, DataOperation action, <span class="hljs-type">long</span> delay)</span> {
        <span class="hljs-keyword">for</span> (Member each : memberManager.allMembersWithoutSelf()) {
            syncToTarget(distroKey, action, each.getAddress(), delay);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syncToTarget</span><span class="hljs-params">(DistroKey distroKey, DataOperation action, String targetServer, <span class="hljs-type">long</span> delay)</span> {
        <span class="hljs-type">DistroKey</span> <span class="hljs-variable">distroKeyWithTarget</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroKey</span>(distroKey.getResourceKey(), distroKey.getResourceType(),
                targetServer);
        <span class="hljs-comment">// 创建异步 DistroDelayTask 任务</span>
        <span class="hljs-type">DistroDelayTask</span> <span class="hljs-variable">distroDelayTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroDelayTask</span>(distroKeyWithTarget, action, delay);
        <span class="hljs-comment">// 添加到任务列表中延迟执行</span>
        distroTaskEngineHolder.getDelayTaskExecuteEngine().addTask(distroKeyWithTarget, distroDelayTask);
        <span class="hljs-keyword">if</span> (Loggers.DISTRO.isDebugEnabled()) {
            Loggers.DISTRO.debug(<span class="hljs-string">"[DISTRO-SCHEDULE] {} to {}"</span>, distroKey, targetServer);
        }
    }
}
</code></pre>
<p>它会创建一个 <code>DistroDelayTask</code> 添加到 <code>NacosDelayTaskExecuteEngine#tasks</code> 中，这个 <code>NacosDelayTaskExecuteEngine</code> 我们在配置发布的章节介绍过，本质上它是一个 <code>ScheduledExecutorService</code> 在每 100ms 执行一个 <code>ConcurrentHashMap&lt;Object, AbstractDelayTask&gt; tasks</code> 的任务。<code>DistroDelayTask</code> 任务中没有什么重要的逻辑，直接来看处理这个任务的实现类 <code>DistroDelayTaskProcessor</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroDelayTaskProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NacosTaskProcessor</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroTaskEngineHolder distroTaskEngineHolder;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroComponentHolder distroComponentHolder;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistroDelayTaskProcessor</span><span class="hljs-params">(DistroTaskEngineHolder distroTaskEngineHolder,
                                    DistroComponentHolder distroComponentHolder)</span> {
        <span class="hljs-built_in">this</span>.distroTaskEngineHolder = distroTaskEngineHolder;
        <span class="hljs-built_in">this</span>.distroComponentHolder = distroComponentHolder;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(NacosTask task)</span> {
        <span class="hljs-keyword">if</span> (!(task <span class="hljs-keyword">instanceof</span> DistroDelayTask)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-type">DistroDelayTask</span> <span class="hljs-variable">distroDelayTask</span> <span class="hljs-operator">=</span> (DistroDelayTask) task;
        <span class="hljs-type">DistroKey</span> <span class="hljs-variable">distroKey</span> <span class="hljs-operator">=</span> distroDelayTask.getDistroKey();
        <span class="hljs-keyword">switch</span> (distroDelayTask.getAction()) {
            <span class="hljs-keyword">case</span> DELETE:
                <span class="hljs-type">DistroSyncDeleteTask</span> <span class="hljs-variable">syncDeleteTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroSyncDeleteTask</span>(distroKey, distroComponentHolder);
                distroTaskEngineHolder.getExecuteWorkersManager().addTask(distroKey, syncDeleteTask);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">case</span> CHANGE:
            <span class="hljs-keyword">case</span> ADD:
                <span class="hljs-comment">// [registerInstance] 步骤11：创建 DistroSyncChangeTask 任务异步执行</span>
                <span class="hljs-type">DistroSyncChangeTask</span> <span class="hljs-variable">syncChangeTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroSyncChangeTask</span>(distroKey, distroComponentHolder);
                distroTaskEngineHolder.getExecuteWorkersManager().addTask(distroKey, syncChangeTask);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
}
</code></pre>
<p><strong>[registerInstance] 步骤11</strong> 会创建 <code>DistroSyncChangeTask</code> 任务同样添加到延迟执行的任务队列中等待处理，这个任务的逻辑我们先来看一下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroSyncChangeTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDistroExecuteTask</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DataOperation</span> <span class="hljs-variable">OPERATION</span> <span class="hljs-operator">=</span> DataOperation.CHANGE;
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistroSyncChangeTask</span><span class="hljs-params">(DistroKey distroKey, DistroComponentHolder distroComponentHolder)</span> {
        <span class="hljs-built_in">super</span>(distroKey, distroComponentHolder);
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> DataOperation <span class="hljs-title function_">getDataOperation</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> OPERATION;
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doExecute</span><span class="hljs-params">()</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> getDistroKey().getResourceType();
        <span class="hljs-type">DistroData</span> <span class="hljs-variable">distroData</span> <span class="hljs-operator">=</span> getDistroData(type);
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == distroData) {
            Loggers.DISTRO.warn(<span class="hljs-string">"[DISTRO] {} with null data to sync, skip"</span>, toString());
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-comment">// gRPC 通知其他节点服务实例信息</span>
        <span class="hljs-keyword">return</span> getDistroComponentHolder().findTransportAgent(type).syncData(distroData, getDistroKey().getTargetServer());
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doExecuteWithCallback</span><span class="hljs-params">(DistroCallback callback)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> getDistroKey().getResourceType();
        <span class="hljs-type">DistroData</span> <span class="hljs-variable">distroData</span> <span class="hljs-operator">=</span> getDistroData(type);
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == distroData) {
            Loggers.DISTRO.warn(<span class="hljs-string">"[DISTRO] {} with null data to sync, skip"</span>, toString());
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// gRPC 通知其他节点服务实例信息</span>
        getDistroComponentHolder().findTransportAgent(type).syncData(distroData, getDistroKey().getTargetServer(), callback);
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"DistroSyncChangeTask for "</span> + getDistroKey().toString();
    }
    
    <span class="hljs-comment">// 获取 Distro 要推送的数据</span>
    <span class="hljs-keyword">private</span> DistroData <span class="hljs-title function_">getDistroData</span><span class="hljs-params">(String type)</span> {
        <span class="hljs-type">DistroData</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> getDistroComponentHolder().findDataStorage(type).getDistroData(getDistroKey());
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != result) {
            result.setType(OPERATION);
        }
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre>
<p>它的源码很简短，主要关注 <code>doExecute</code> 和 <code>doExecuteWithCallback</code> 方法，这两个方法的逻辑是借助 gRPC 通知集群中其他节点，区别是是否在 gRPC 调用完成后执行回调函数，这个任务的执行是在 <code>NacosExecuteTaskExecuteEngine</code> 中异步执行的，因为在上文中讲解过就不再赘述了，失败重试采用的还是重新添加到任务队列中等待执行。除此之外我们也要弄清楚推送的 DistroData 中到底都包含哪些信息，如下代码所示，它会执行到 <code>AbstractClient#generateSyncData</code> 的逻辑中：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Client</span> {
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ClientSyncData <span class="hljs-title function_">generateSyncData</span><span class="hljs-params">()</span> {
        List&lt;String&gt; namespaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;String&gt; groupNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;String&gt; serviceNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();

        List&lt;String&gt; batchNamespaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;String&gt; batchGroupNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;String&gt; batchServiceNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();

        List&lt;InstancePublishInfo&gt; instances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        List&lt;BatchInstancePublishInfo&gt; batchInstancePublishInfos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-type">BatchInstanceData</span>  <span class="hljs-variable">batchInstanceData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchInstanceData</span>();
        <span class="hljs-keyword">for</span> (Map.Entry&lt;Service, InstancePublishInfo&gt; entry : publishers.entrySet()) {
            <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">instancePublishInfo</span> <span class="hljs-operator">=</span> entry.getValue();
            <span class="hljs-keyword">if</span> (instancePublishInfo <span class="hljs-keyword">instanceof</span> BatchInstancePublishInfo) {
                <span class="hljs-type">BatchInstancePublishInfo</span> <span class="hljs-variable">batchInstance</span> <span class="hljs-operator">=</span> (BatchInstancePublishInfo) instancePublishInfo;
                batchInstancePublishInfos.add(batchInstance);
                buildBatchInstanceData(batchInstanceData, batchNamespaces, batchGroupNames, batchServiceNames, entry);
                batchInstanceData.setBatchInstancePublishInfos(batchInstancePublishInfos);
            } <span class="hljs-keyword">else</span> {
                namespaces.add(entry.getKey().getNamespace());
                groupNames.add(entry.getKey().getGroup());
                serviceNames.add(entry.getKey().getName());
                instances.add(entry.getValue());
            }
        }
        <span class="hljs-comment">// 包含了命名空间、服务信息和实例信息（InstancePublishInfo 或 BatchInstanceData）等</span>
        <span class="hljs-type">ClientSyncData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientSyncData</span>(getClientId(), namespaces, groupNames, serviceNames, instances, batchInstanceData);
        data.getAttributes().addClientAttribute(REVISION, getRevision());
        <span class="hljs-keyword">return</span> data;
    }
}
</code></pre>
<p>虽然比较长，只看注释相关的内容即可，推送内容包含了命名空间、服务信息和实例信息等，这些信息大部分都来自 <code>InstancePublishInfo</code>，可见这个对象多么重要。</p>
<p><code>DistroSyncChangeTask</code> 任务会向其他节点发送 <code>DistroDataRequest</code> 请求，这个请求是如何被处理的呢？继续看 <code>DistroDataRequestHandler</code> 的逻辑：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@InvokeSource(source = {RemoteConstants.LABEL_SOURCE_CLUSTER})</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroDataRequestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RequestHandler</span>&lt;DistroDataRequest, DistroDataResponse&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroProtocol distroProtocol;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistroDataRequestHandler</span><span class="hljs-params">(DistroProtocol distroProtocol)</span> {
        <span class="hljs-built_in">this</span>.distroProtocol = distroProtocol;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@Secured(apiType = ApiType.INNER_API)</span>
    <span class="hljs-keyword">public</span> DistroDataResponse <span class="hljs-title function_">handle</span><span class="hljs-params">(DistroDataRequest request, RequestMeta meta)</span> <span class="hljs-keyword">throws</span> NacosException {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">switch</span> (request.getDataOperation()) {
                <span class="hljs-keyword">case</span> VERIFY:
                    <span class="hljs-keyword">return</span> handleVerify(request.getDistroData(), meta);
                <span class="hljs-keyword">case</span> SNAPSHOT:
                    <span class="hljs-keyword">return</span> handleSnapshot();
                <span class="hljs-keyword">case</span> ADD:
                <span class="hljs-keyword">case</span> CHANGE:
                <span class="hljs-keyword">case</span> DELETE:
                    <span class="hljs-comment">// [registerInstance] 步骤12 处理 DistroDataRequest 请求</span>
                    <span class="hljs-keyword">return</span> handleSyncData(request.getDistroData());
                <span class="hljs-keyword">case</span> QUERY:
                    <span class="hljs-keyword">return</span> handleQueryData(request.getDistroData());
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroDataResponse</span>();
            }
        } <span class="hljs-keyword">catch</span> (Exception e) {
            Loggers.DISTRO.error(<span class="hljs-string">"[DISTRO-FAILED] distro handle with exception"</span>, e);
            <span class="hljs-type">DistroDataResponse</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroDataResponse</span>();
            result.setResultCode(ResponseCode.FAIL.getCode());
            result.setErrorCode(ResponseCode.FAIL.getCode());
            result.setMessage(<span class="hljs-string">"handle distro request with exception"</span>);
            <span class="hljs-keyword">return</span> result;
        }
    }

    <span class="hljs-keyword">private</span> DistroDataResponse <span class="hljs-title function_">handleSyncData</span><span class="hljs-params">(DistroData distroData)</span> {
        <span class="hljs-type">DistroDataResponse</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistroDataResponse</span>();
        <span class="hljs-keyword">if</span> (!distroProtocol.onReceive(distroData)) {
            result.setErrorCode(ResponseCode.FAIL.getCode());
            result.setMessage(<span class="hljs-string">"[DISTRO-FAILED] distro data handle failed"</span>);
        }
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre>
<p>我们需要关注 <code>DistroProtocol#onReceive</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroProtocol</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DistroComponentHolder distroComponentHolder;
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(DistroData distroData)</span> {
        Loggers.DISTRO.info(<span class="hljs-string">"[DISTRO] Receive distro data type: {}, key: {}"</span>, distroData.getType(),
                distroData.getDistroKey());
        <span class="hljs-type">String</span> <span class="hljs-variable">resourceType</span> <span class="hljs-operator">=</span> distroData.getDistroKey().getResourceType();
        <span class="hljs-type">DistroDataProcessor</span> <span class="hljs-variable">dataProcessor</span> <span class="hljs-operator">=</span> distroComponentHolder.findDataProcessor(resourceType);
        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == dataProcessor) {
            Loggers.DISTRO.warn(<span class="hljs-string">"[DISTRO] Can't find data process for received data {}"</span>, resourceType);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> dataProcessor.processData(distroData);
    }
}
</code></pre>
<p>它会执行到 <code>DistroClientDataProcessor#processData</code> 方法，其中的 <code>upgradeClient</code> 方法是关键：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistroClientDataProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SmartSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DistroDataStorage</span>, DistroDataProcessor {
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">processData</span><span class="hljs-params">(DistroData distroData)</span> {
        <span class="hljs-keyword">switch</span> (distroData.getType()) {
            <span class="hljs-keyword">case</span> ADD:
            <span class="hljs-keyword">case</span> CHANGE:
                <span class="hljs-comment">// [registerInstance] 步骤12：处理 Distro 协议同步的数据</span>
                <span class="hljs-type">ClientSyncData</span> <span class="hljs-variable">clientSyncData</span> <span class="hljs-operator">=</span> ApplicationUtils.getBean(Serializer.class)
                        .deserialize(distroData.getContent(), ClientSyncData.class);
                handlerClientSyncData(clientSyncData);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">case</span> DELETE:
                <span class="hljs-type">String</span> <span class="hljs-variable">deleteClientId</span> <span class="hljs-operator">=</span> distroData.getDistroKey().getResourceKey();
                Loggers.DISTRO.info(<span class="hljs-string">"[Client-Delete] Received distro client sync data {}"</span>, deleteClientId);
                clientManager.clientDisconnected(deleteClientId);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerClientSyncData</span><span class="hljs-params">(ClientSyncData clientSyncData)</span> {
        Loggers.DISTRO
                .info(<span class="hljs-string">"[Client-Add] Received distro client sync data {}, revision={}"</span>, clientSyncData.getClientId(),
                        clientSyncData.getAttributes().getClientAttribute(ClientConstants.REVISION, <span class="hljs-number">0L</span>));
        clientManager.syncClientConnected(clientSyncData.getClientId(), clientSyncData.getAttributes());
        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> clientManager.getClient(clientSyncData.getClientId());
        <span class="hljs-comment">// upgrade 是升级的含义，实际逻辑是完成 Distro 数据的写入</span>
        upgradeClient(client, clientSyncData);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">upgradeClient</span><span class="hljs-params">(Client client, ClientSyncData clientSyncData)</span> {
        Set&lt;Service&gt; syncedService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        <span class="hljs-comment">// process batch instance sync logic</span>
        processBatchInstanceDistroData(syncedService, client, clientSyncData);
        List&lt;String&gt; namespaces = clientSyncData.getNamespaces();
        List&lt;String&gt; groupNames = clientSyncData.getGroupNames();
        List&lt;String&gt; serviceNames = clientSyncData.getServiceNames();
        List&lt;InstancePublishInfo&gt; instances = clientSyncData.getInstancePublishInfos();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; namespaces.size(); i++) {
            <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Service.newService(namespaces.get(i), groupNames.get(i), serviceNames.get(i));
            <span class="hljs-comment">// 注册并获取服务信息</span>
            <span class="hljs-type">Service</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> ServiceManager.getInstance().getSingleton(service);
            syncedService.add(singleton);
            <span class="hljs-type">InstancePublishInfo</span> <span class="hljs-variable">instancePublishInfo</span> <span class="hljs-operator">=</span> instances.get(i);
            <span class="hljs-keyword">if</span> (!instancePublishInfo.equals(client.getInstancePublishInfo(singleton))) {
                <span class="hljs-comment">// 执行的是 [registerInstance] 步骤5 的逻辑：将实例信息 InstancePublishInfo 添加到客户端的服务实例列表中</span>
                client.addServiceInstance(singleton, instancePublishInfo);
                <span class="hljs-comment">// 触发 ClientRegisterServiceEvent 事件</span>
                NotifyCenter.publishEvent(
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientOperationEvent</span>.ClientRegisterServiceEvent(singleton, client.getClientId()));
                NotifyCenter.publishEvent(
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MetadataEvent</span>.InstanceMetadataEvent(singleton, instancePublishInfo.getMetadataId(), <span class="hljs-literal">false</span>));
            }
        }
        <span class="hljs-keyword">for</span> (Service each : client.getAllPublishedService()) {
            <span class="hljs-keyword">if</span> (!syncedService.contains(each)) {
                client.removeServiceInstance(each);
                NotifyCenter.publishEvent(
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientOperationEvent</span>.ClientDeregisterServiceEvent(each, client.getClientId()));
            }
        }
        client.setRevision(clientSyncData.getAttributes().&lt;Integer&gt;getClientAttribute(ClientConstants.REVISION, <span class="hljs-number">0</span>));
    }
}
</code></pre>
<p><code>DistroClientDataProcessor#upgradeClient</code> 方法会执行时就和开篇介绍的 <code>EphemeralClientOperationServiceImpl#registerInstance</code> 方法基本一致的逻辑，注册 <code>Service</code> 信息，写入实例信息 <code>InstancePublishInfo</code>，并在随后发布 <code>ClientRegisterServiceEvent</code> 事件，这个事件我们在上一个小节专门介绍过，它的作用是将服务实例的变更信息推送给订阅了这个服务的所有客户端。</p>
<p>总而言之，通过 Distro 协议同步数据给集群中其他节点相当于在其他节点重新执行了一次实例注册的逻辑。不过，大家有没有考虑过这个问题：为什么 Distro 协议能够通过如此简单的方式在服务发现场景下保证数据的最终一致性呢？</p>
<p>最主要的原因是：<strong>服务注册数据模型的属性简化了分布式一致性问题，避免了复杂的冲突解决机制</strong>。该如何理解这个特点呢？</p>
<ul>
<li><strong>服务实例通过多个维度确定唯一性</strong>：命名空间 + 服务名 + 集群名 + IP地址 + 端口号，这种唯一性设计确保了同一个服务实例的注册信息在任何节点都是相同的，所以同一实例的注册信息在不同节点、不同时间先后写入都不会存在数据冲突问题，<strong>写入操作是幂等的</strong>，大大降低了保证数据一致性的复杂度。</li>
</ul>
<p>理解了这一点，我觉得便清楚了 Distro 协议的精髓。此外，还有以下原因使得 Distro 协议适用：</p>
<ol>
<li>服务实例的注册信息是 <strong>临时数据</strong>：数据具有生命周期，会自动过期或被清理，不需要持久化存储，丢失后可以重新生成，降低了维护实例数据的难度</li>
<li>业务场景能够接受数据的 <strong>最终一致性</strong>：可用性（Availability）比一致性（Consistency）更重要，短时间内部分实例注册信息不一致不影响业务</li>
<li>多个 Nacos Client 客户端会连接到不同的 Nacos Server 服务端，相当于进行了 <strong>分片</strong>：每个服务节点负责特定的客户端实例，客户端注册的操作基本只在一个服务节点发生，大大降低了发生写入冲突的可能</li>
</ol>
<p>接下来我们看一下在 Distro 协议中是如何清理过期数据的，核心逻辑在 <code>ExpiredClientCleaner</code> 中，它是一个定期执行的任务，任务逻辑如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpiredClientCleaner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EphemeralIpPortClientManager clientManager;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-comment">// 获取当前 Nacos Server 下连接的所有客户端</span>
        <span class="hljs-keyword">for</span> (String each : clientManager.allClientId()) {
            <span class="hljs-comment">// 遍历处理客户端信息</span>
            <span class="hljs-type">IpPortBasedClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> (IpPortBasedClient) clientManager.getClient(each);
            <span class="hljs-comment">// 如果客户端已经失效（在规定时间段内失去心跳）了</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != client &amp;&amp; isExpireClient(currentTime, client)) {
                <span class="hljs-comment">// 执行客户端断开的逻辑，会触发 ClientDisconnectEvent 事件，删除失效的链接并通知集群内其他节点</span>
                clientManager.clientDisconnected(each);
            }
        }
    }
}
</code></pre>
<p>这个定时任务会在 Nacos Server 启动时，在 <code>ScheduledExecutorService</code> 中定期 5s 执行一次：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EphemeralIpPortClientManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClientManager</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EphemeralIpPortClientManager</span><span class="hljs-params">(DistroMapper distroMapper, SwitchDomain switchDomain)</span> {
        <span class="hljs-comment">// 默认定期 5s 检查一次</span>
        GlobalExecutor.scheduleExpiredClientCleaner(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpiredClientCleaner</span>(<span class="hljs-built_in">this</span>, switchDomain), <span class="hljs-number">0</span>,
                Constants.DEFAULT_HEART_BEAT_INTERVAL, TimeUnit.MILLISECONDS);
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>以此来保证过期的实例数据能及时被移除。</p>
<hr/>
<h3 data-id="heading-3">巨人的肩膀</h3>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falibaba%2Fnacos" target="_blank" title="https://github.com/alibaba/nacos" ref="nofollow noopener noreferrer">Github - alibaba/nacos</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fwenxuehai%2Fp%2F16179629.html" target="_blank" title="https://www.cnblogs.com/wenxuehai/p/16179629.html" ref="nofollow noopener noreferrer">博客园 - Nacos的基本使用（注册中心、配置中心）</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude发布新功能Agent Skills，让你的Agent更专业]]></title>    <link>https://juejin.cn/post/7572714389942435892</link>    <guid>https://juejin.cn/post/7572714389942435892</guid>    <pubDate>2025-11-16T01:18:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572714389942435892" data-draft-id="7567208390369247272" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude发布新功能Agent Skills，让你的Agent更专业"/> <meta itemprop="keywords" content="Claude,AIGC"/> <meta itemprop="datePublished" content="2025-11-16T01:18:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小溪彼岸"/> <meta itemprop="url" content="https://juejin.cn/user/976781670357400"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude发布新功能Agent Skills，让你的Agent更专业
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/976781670357400/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小溪彼岸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T01:18:54.000Z" title="Sun Nov 16 2025 01:18:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>大家好，我是小溪，见字如面。2025年10月16日，Anthropic发布了Claude模型的一项重大更新Agent Skills，它允许用户将专业知识、脚本和资源打包成模块化的“技能文件夹”（Skill folders），让 AI 能在特定工作场景中更专业地执行任务。对Claude Code CLI往期内容感兴趣的小伙伴也可以看往期内容：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493170%26idx%3D1%26sn%3D13e9d5122d788175ab587ce33720f777%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493170&amp;idx=1&amp;sn=13e9d5122d788175ab587ce33720f777&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Hooks才是Claude Code CLI 的革命性更新</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493196%26idx%3D1%26sn%3Db4efa96c86f66fff3acd21c175ceb89f%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493196&amp;idx=1&amp;sn=b4efa96c86f66fff3acd21c175ceb89f&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Claude Code颠覆编程风格的Output Styles</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493228%26idx%3D1%26sn%3D7bb969019478e4e38974776bb04fedda%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493228&amp;idx=1&amp;sn=7bb969019478e4e38974776bb04fedda&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">分享一个Claude Code宝藏网站Claude Code Templates</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493269%26idx%3D1%26sn%3D4775c90a4fab04126502bf79b0f75d70%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493269&amp;idx=1&amp;sn=4775c90a4fab04126502bf79b0f75d70&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">Claude Code上线插件系统，AI编程模式再次升级</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493288%26idx%3D1%26sn%3D0274d7f3a741cbfde4d09adf7a595efb%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493288&amp;idx=1&amp;sn=0274d7f3a741cbfde4d09adf7a595efb&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">如何从零开始创建一个Claude Code插件</a></li>
</ul>
<h2 data-id="heading-1">当前使用版本</h2>
<p>2.0.24 (Claude Code)</p>
<h2 data-id="heading-2">简介</h2>
<p>官方的描述是：“代理技能将专业知识打包到可发现的功能中。每个技能都由一个 SKILL.md 文件组成，其中包含Claude在需要时阅读的 说明、脚本 和 模板 等可选支持文件”。</p>
<p>用白话讲就是，Agent Skill是一个用于告诉模型如何执行某项操作的Markdown文件，同时允许附带额外的文档和预先编写的脚本，通过运行这些脚本，使模型在执行特定任务时更专业、更高效，是AI“可加载的能力包”</p>
<p>官网地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.claude.com%2Fen%2Fdocs%2Fclaude-code%2Fskills" target="_blank" title="https://docs.claude.com/en/docs/claude-code/skills" ref="nofollow noopener noreferrer">docs.claude.com/en/docs/cla…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbaf20322f164eda82b6bdb74dddb3d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=cqXXFH5QK%2BT4hFH5I2Xs3zE2e98%3D" alt="图片" loading="lazy"/></p>
<p>Anthropic提供了一系列Skill示例，部分已经集成到了Claude Code桌面端，也可以在Claude Code CLI中使用，感兴趣的小伙伴可以自行了解。</p>
<p>Github地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fanthropics%2Fskills" target="_blank" title="https://github.com/anthropics/skills" ref="nofollow noopener noreferrer">github.com/anthropics/…</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31ad3b7da1224a5b9b049e643cd29f30~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=aOUWIj6Gd4yGTG3L9YztKUoriI8%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-3">优势</h2>
<p>Agent Skills具备如下特性：</p>
<ul>
<li>为您的特定工作流程扩展 Claude 的功能</li>
<li>通过 git 在团队中共享专业知识</li>
<li>减少重复提示</li>
<li>为复杂任务编写多种技能</li>
</ul>
<h2 data-id="heading-4">如何调用？</h2>
<p>技能是模型调用的，Claude 根据您的请求和技能的描述自主决定何时使用它们。</p>
<h2 data-id="heading-5">Skills类型</h2>
<p>Agent Skills有 3种类型，Claude Code从以下来源自动发现Skills：</p>
<ul>
<li>个人(全局)技能：作用于所有项目，路径在 ~/.claude/skills/ 目录下</li>
<li>项目技能：作用于特定项目，路径在 .claude/skills/ 目录下</li>
<li>插件技能：与已安装的插件捆绑在一起</li>
</ul>
<h2 data-id="heading-6">Skills目录及操作</h2>
<h3 data-id="heading-7">Skill目录结构</h3>
<p>Agent Skills的文件结构大致如下：</p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-keyword">my</span>-skill/
├── SKILL.md <span class="hljs-comment"># 指令与说明文件 必需项</span>
├── reference.md <span class="hljs-comment"># 文档（可选）</span>
├── examples.md <span class="hljs-comment"># 示例（可选）</span>
├── scripts/ <span class="hljs-comment"># 脚本（可选）</span>
│   └── helper.py
└── templates/  <span class="hljs-comment"># 模版（可选）</span>
    └── template.txt
</code></pre>
<h3 data-id="heading-8">SKILL.md</h3>
<p>每个Skills都定义在具有以下结构的 Markdown 文件中：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">your-skill-name</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">Introduce</span> <span class="hljs-string">the</span> <span class="hljs-string">Skills</span> <span class="hljs-string">function。Description</span> <span class="hljs-string">of</span> <span class="hljs-string">when</span> <span class="hljs-string">this</span> <span class="hljs-string">Skill</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-string">invoked</span>
<span class="hljs-attr">allowed-tools:</span> <span class="hljs-string">which</span> <span class="hljs-string">tools</span> <span class="hljs-string">Claude</span> <span class="hljs-string">can</span> <span class="hljs-string">use</span> <span class="hljs-string">when</span> <span class="hljs-string">a</span> <span class="hljs-string">Skill</span> <span class="hljs-string">is</span> <span class="hljs-string">active</span>
<span class="hljs-string">license：skill</span> <span class="hljs-string">license</span>
<span class="hljs-meta">---</span>
<span class="hljs-string">Skill</span> <span class="hljs-string">Implementation</span> <span class="hljs-string">and</span> <span class="hljs-string">Requirements</span>
</code></pre>
<p>Skill技能Markdown Frontmatter属性：</p>
<ul>
<li>name：Skill名称</li>
<li>description：描述Skill功能及何时应该调用此Skill</li>
<li>allowed-tools：Skill处于活动状态时可以使用的工具</li>
<li>license：开源许可协议</li>
</ul>
<p>Skill中可以引用其他额外的文件作为上下文：</p>
<pre><code class="hljs language-scss" lang="scss">For advanced usage, see <span class="hljs-selector-attr">[reference.md]</span>(reference.md).
</code></pre>
<p>也可以使用文件路径形式</p>
<pre><code class="hljs language-bash" lang="bash">For advanced usage, see ./reference.md
</code></pre>
<p>需要执行脚本的操作，可以使用如下方式指定：</p>
<pre><code class="hljs language-go" lang="go">Run the helper script:
<span class="hljs-string">``</span><span class="hljs-string">`bash
python scripts/helper.py input.txt
`</span><span class="hljs-string">``</span>
</code></pre>
<p>对于 allowed-tools 的使用，可以在 frontmatter 中来限制 Claude 在技能处于活动状态时可以使用的工具：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">your-skill-name</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">Introduce</span> <span class="hljs-string">the</span> <span class="hljs-string">Skills</span> <span class="hljs-string">function。Description</span> <span class="hljs-string">of</span> <span class="hljs-string">when</span> <span class="hljs-string">this</span> <span class="hljs-string">Skill</span> <span class="hljs-string">should</span> <span class="hljs-string">be</span> <span class="hljs-string">invoked</span>
<span class="hljs-attr">allowed-tools:</span> <span class="hljs-string">Read,</span> <span class="hljs-string">Grep,</span> <span class="hljs-string">Glob</span>
<span class="hljs-meta">---
</span></code></pre>
<h2 data-id="heading-9">基本使用</h2>
<h3 data-id="heading-10">前提条件</h3>
<ul>
<li>Claude Code 版本 1.0 或更高版本</li>
</ul>
<h3 data-id="heading-11">官方Skill安装使用</h3>
<p>首先以Claude Code官方Skill 市场为例，在交互式命令中输入如下指令添加Skill市场：</p>
<pre><code class="hljs language-bash" lang="bash">/plugin marketplace add anthropics/skills
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/76b51ed79fe44f21be947774fda099b0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=tXfzksxxUkyi%2BuF5DLKp0CW0mE4%3D" alt="图片" loading="lazy"/></p>
<p>在插件市场选择【Browse and install plugins】浏览并安装</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c3ac55bc3fb945ad8886307c0891c197~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=rdpFaS2I6CjMib0bE6YISU3tD9c%3D" alt="图片" loading="lazy"/></p>
<p>或者通过以下命令直接安装：</p>
<pre><code class="hljs language-typescript" lang="typescript">/plugin install <span class="hljs-variable language_">document</span>-skills\<span class="hljs-meta">@anthropic</span>-agent-skills
/plugin install example-skills\<span class="hljs-meta">@anthropic</span>-agent-skills
</code></pre>
<p>document-skills 和 example-skills 包含的Skills如下所示：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/59b3b19575114609ba101408b7f4be8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=bJtdGd3lTOVZBjSQZGFG7zUwC%2Fk%3D" alt="图片" loading="lazy"/></p>
<p>安装完成后，根据提示重启Claude Code CLI</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c51b45603f3a4bdb902bb0e06d218bcf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=sQbiUb6BPwb4sLXU3MRvU8Zifa8%3D" alt="图片" loading="lazy"/></p>
<p>在交互式命令中直接输入提示词：</p>
<pre><code class="hljs language-bash" lang="bash">提取 /Users/username/Desktop/工作簿1.xlsx 文件内容 
</code></pre>
<p>Claude Code CLI会先进行权限请求，然后启动Excel处理技能</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2b6a82c077ba439d8e1d8548612b1e35~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=mSn%2FRUkiXeXZO9tbG2Mqnhj299w%3D" alt="图片" loading="lazy"/></p>
<p>允许后，Claude Code CLI会安装所需的依赖并创建脚本</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1df6bf7bf2c74e6ebbc7d58cacb75a63~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=4G2S%2B6u8JCdpooAKNrypZRVow0I%3D" alt="图片" loading="lazy"/></p>
<p>允许脚本后最终读取到了Excel表格内容</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1873d8d1fd5b4602a257e58ce16c973c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=WFC1qRxMIlBUBTvDL35agKgJA9I%3D" alt="图片" loading="lazy"/></p>
<p>最后看一下传统Claude Code CLI读取Excel表格的效果</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d04c69d89837447aacf2f1c8bd577905~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=Z2fIbFAW8KwBCzT8Qc8XeGqoVGA%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-12">三方Skill安装使用</h3>
<p>这里以Claude Code Templates提供的Skills为例，对Claude Code Templates还不了解的小伙伴可以看往期内容：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5Njg3ODUzOA%3D%3D%26mid%3D2247493228%26idx%3D1%26sn%3D7bb969019478e4e38974776bb04fedda%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzU5Njg3ODUzOA==&amp;mid=2247493228&amp;idx=1&amp;sn=7bb969019478e4e38974776bb04fedda&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">分享一个Claude Code宝藏网站Claude Code Templates</a></p>
<p>进入项目根目录，在命令行终端输入如下指令进行安装：</p>
<pre><code class="hljs language-ini" lang="ini">$ npx claude-code-templates\@latest <span class="hljs-attr">--skill</span>=creative-design/canvas-design --<span class="hljs-literal">yes</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ebaee8eeced443e836dd6816fa30d36~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=AltEG%2B2VIw1KNnX6pcg7fzrw6Lo%3D" alt="图片" loading="lazy"/></p>
<p>安装完成后，项目 .claude/ 目录会多出一个 skills 目录</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/755ed8a633cf4e91beb7f978278fa55a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=iJn8Pa43k6yVBKFy9EA6hwvt1fo%3D" alt="图片" loading="lazy"/></p>
<p>完整的 SKILL.md 内容如下：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">name:</span> canvas-design
<span class="hljs-symbol">description:</span> Create beautiful visual art <span class="hljs-keyword">in</span> .png <span class="hljs-built_in">and</span> .pdf documents <span class="hljs-keyword">using</span> design philosophy. You should use this skill <span class="hljs-keyword">when</span> the user asks <span class="hljs-keyword">to</span> create a poster, piece <span class="hljs-keyword">of</span> art, design, <span class="hljs-built_in">or</span> other <span class="hljs-keyword">static</span> piece. Create original visual designs, never copying existing artists<span class="hljs-comment">' work to avoid copyright violations.</span>
<span class="hljs-symbol">license:</span> Complete terms <span class="hljs-keyword">in</span> LICENSE.txt
--------------------------------------

These are instructions <span class="hljs-keyword">for</span> creating design philosophies - aesthetic movements that are <span class="hljs-keyword">then</span> EXPRESSED VISUALLY. Output only .md files, .pdf files, <span class="hljs-built_in">and</span> .png files.
Complete this <span class="hljs-keyword">in</span> two steps:

<span class="hljs-number">1</span>.  Design Philosophy Creation (.md file)
<span class="hljs-number">2</span>.  Express <span class="hljs-keyword">by</span> creating it <span class="hljs-keyword">on</span> a canvas (.pdf file <span class="hljs-built_in">or</span> .png file)
    First, undertake this task:

## DESIGN PHILOSOPHY CREATION

<span class="hljs-keyword">To</span> begin, create a VISUAL PHILOSOPHY (<span class="hljs-built_in">not</span> layouts <span class="hljs-built_in">or</span> templates) that will be interpreted through:

*   Form, space, color, composition
*   Images, graphics, shapes, patterns
*   Minimal <span class="hljs-keyword">text</span> <span class="hljs-keyword">as</span> visual accent

### THE CRITICAL UNDERSTANDING

*   What <span class="hljs-built_in">is</span> received: Some subtle input <span class="hljs-built_in">or</span> instructions <span class="hljs-keyword">by</span> the user that should be taken <span class="hljs-keyword">into</span> account, but used <span class="hljs-keyword">as</span> a foundation; it should <span class="hljs-built_in">not</span> constrain creative freedom.
*   What <span class="hljs-built_in">is</span> created: A design philosophy/aesthetic movement.
*   What happens <span class="hljs-keyword">next</span>: <span class="hljs-keyword">Then</span>, the same version receives the philosophy <span class="hljs-built_in">and</span> EXPRESSES IT VISUALLY - creating artifacts that are <span class="hljs-number">90%</span> visual design, <span class="hljs-number">10%</span> essential <span class="hljs-keyword">text</span>.
    Consider this approach:
*   Write a manifesto <span class="hljs-keyword">for</span> an art movement
*   The <span class="hljs-keyword">next</span> phase involves making the artwork
    The philosophy must emphasize: Visual expression. Spatial communication. Artistic interpretation. Minimal words.

### HOW <span class="hljs-keyword">TO</span> GENERATE A VISUAL PHILOSOPHY

**Name the movement** (<span class="hljs-number">1</span>-<span class="hljs-number">2</span> words): <span class="hljs-string">"Brutalist Joy"</span> / <span class="hljs-string">"Chromatic Silence"</span> / <span class="hljs-string">"Metabolist Dreams"</span>
**Articulate the philosophy** (<span class="hljs-number">4</span>-<span class="hljs-number">6</span> paragraphs - concise but complete):
<span class="hljs-keyword">To</span> capture the VISUAL essence, express how the philosophy manifests through:

*   Space <span class="hljs-built_in">and</span> form
*   Color <span class="hljs-built_in">and</span> material
*   Scale <span class="hljs-built_in">and</span> rhythm
*   Composition <span class="hljs-built_in">and</span> balance
*   Visual hierarchy
    **CRITICAL GUIDELINES:**
*   **Avoid redundancy**: <span class="hljs-keyword">Each</span> design aspect should be mentioned once. Avoid repeating points about color theory, spatial relationships, <span class="hljs-built_in">or</span> typographic principles unless adding <span class="hljs-built_in">new</span> depth.
*   **Emphasize craftsmanship REPEATEDLY**: The philosophy MUST stress multiple times that the final work should appear <span class="hljs-keyword">as</span> though it took countless hours <span class="hljs-keyword">to</span> create, was labored over <span class="hljs-keyword">with</span> care, <span class="hljs-built_in">and</span> comes <span class="hljs-keyword">from</span> someone at the absolute top <span class="hljs-keyword">of</span> their field. This framing <span class="hljs-built_in">is</span> essential - repeat phrases <span class="hljs-built_in">like</span> <span class="hljs-string">"meticulously crafted,"</span> <span class="hljs-string">"the product of deep expertise,"</span> <span class="hljs-string">"painstaking attention,"</span> <span class="hljs-string">"master-level execution."</span>
*   **Leave creative space**: Remain specific about the aesthetic direction, but concise enough that the <span class="hljs-keyword">next</span> Claude has room <span class="hljs-keyword">to</span> make interpretive choices also at a extremely high level <span class="hljs-keyword">of</span> craftmanship.
    The philosophy must guide the <span class="hljs-keyword">next</span> version <span class="hljs-keyword">to</span> express ideas VISUALLY, <span class="hljs-built_in">not</span> through <span class="hljs-keyword">text</span>. Information lives <span class="hljs-keyword">in</span> design, <span class="hljs-built_in">not</span> paragraphs.

### PHILOSOPHY EXAMPLES

**<span class="hljs-string">"Concrete Poetry"</span>**
<span class="hljs-symbol">Philosophy:</span> Communication through monumental form <span class="hljs-built_in">and</span> bold geometry.
Visual expression: Massive color blocks, sculptural typography (huge <span class="hljs-type">single</span> words, tiny labels), Brutalist spatial divisions, Polish poster energy meets Le Corbusier. Ideas expressed through visual weight <span class="hljs-built_in">and</span> spatial tension, <span class="hljs-built_in">not</span> explanation. <span class="hljs-keyword">Text</span> <span class="hljs-keyword">as</span> rare, powerful gesture - never paragraphs, only essential words integrated <span class="hljs-keyword">into</span> the visual architecture. Every element placed <span class="hljs-keyword">with</span> the precision <span class="hljs-keyword">of</span> a master craftsman.
**<span class="hljs-string">"Chromatic Language"</span>**
<span class="hljs-symbol">Philosophy:</span> Color <span class="hljs-keyword">as</span> the primary information system.
Visual expression: Geometric precision <span class="hljs-keyword">where</span> color zones create meaning. Typography minimal - small sans-serif labels letting chromatic fields communicate. Think Josef Albers<span class="hljs-comment">' interaction meets data visualization. Information encoded spatially and chromatically. Words only to anchor what color already shows. The result of painstaking chromatic calibration.</span>
**<span class="hljs-string">"Analog Meditation"</span>**
<span class="hljs-symbol">Philosophy:</span> Quiet visual contemplation through texture <span class="hljs-built_in">and</span> breathing room.
Visual expression: Paper grain, ink bleeds, vast negative space. Photography <span class="hljs-built_in">and</span> illustration dominate. Typography whispered (small, restrained, serving the visual). Japanese photobook aesthetic. Images breathe across pages. <span class="hljs-keyword">Text</span> appears sparingly - <span class="hljs-type">short</span> phrases, never explanatory blocks. <span class="hljs-keyword">Each</span> composition balanced <span class="hljs-keyword">with</span> the care <span class="hljs-keyword">of</span> a meditation practice.
**<span class="hljs-string">"Organic Systems"</span>**
<span class="hljs-symbol">Philosophy:</span> Natural clustering <span class="hljs-built_in">and</span> modular growth patterns.
Visual expression: Rounded forms, organic arrangements, color <span class="hljs-keyword">from</span> nature through architecture. Information shown through visual diagrams, spatial relationships, iconography. <span class="hljs-keyword">Text</span> only <span class="hljs-keyword">for</span> <span class="hljs-keyword">key</span> labels floating <span class="hljs-keyword">in</span> space. The composition tells the story through expert spatial orchestration.
**<span class="hljs-string">"Geometric Silence"</span>**
<span class="hljs-symbol">Philosophy:</span> Pure <span class="hljs-keyword">order</span> <span class="hljs-built_in">and</span> restraint.
Visual expression: Grid-based precision, bold photography <span class="hljs-built_in">or</span> stark graphics, dramatic negative space. Typography precise but minimal - small essential <span class="hljs-keyword">text</span>, large quiet zones. Swiss formalism meets Brutalist material honesty. <span class="hljs-keyword">Structure</span> communicates, <span class="hljs-built_in">not</span> words. Every alignment the work <span class="hljs-keyword">of</span> countless refinements.
*These are condensed examples. The actual design philosophy should be <span class="hljs-number">4</span>-<span class="hljs-number">6</span> substantial paragraphs.*

### ESSENTIAL PRINCIPLES

\- **VISUAL PHILOSOPHY**: Create an aesthetic worldview <span class="hljs-keyword">to</span> be expressed through design
\- **MINIMAL <span class="hljs-keyword">TEXT</span>**: Always emphasize that <span class="hljs-keyword">text</span> <span class="hljs-built_in">is</span> sparse, essential-only, integrated <span class="hljs-keyword">as</span> visual element - never lengthy
\- **SPATIAL EXPRESSION**: Ideas communicate through space, form, color, composition - <span class="hljs-built_in">not</span> paragraphs
\- **ARTISTIC FREEDOM**: The <span class="hljs-keyword">next</span> Claude interprets the philosophy visually - provide creative room
\- **PURE DESIGN**: This <span class="hljs-built_in">is</span> about making ART OBJECTS, <span class="hljs-built_in">not</span> documents <span class="hljs-keyword">with</span> decoration
\- **EXPERT CRAFTSMANSHIP**: Repeatedly emphasize the final work must look meticulously crafted, labored over <span class="hljs-keyword">with</span> care, the product <span class="hljs-keyword">of</span> countless hours <span class="hljs-keyword">by</span> someone at the top <span class="hljs-keyword">of</span> their field
**The design philosophy should be <span class="hljs-number">4</span>-<span class="hljs-number">6</span> paragraphs <span class="hljs-type">long</span>.** Fill it <span class="hljs-keyword">with</span> poetic design philosophy that brings together the core vision. Avoid repeating the same points. Keep the design philosophy generic without mentioning the intention <span class="hljs-keyword">of</span> the art, <span class="hljs-keyword">as</span> <span class="hljs-keyword">if</span> it can be used wherever. Output the design philosophy <span class="hljs-keyword">as</span> a .md file.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## DEDUCING THE SUBTLE REFERENCE

**CRITICAL <span class="hljs-keyword">STEP</span>**: Before creating the canvas, identify the subtle conceptual thread <span class="hljs-keyword">from</span> the original request.
**THE ESSENTIAL PRINCIPLE**:
The topic <span class="hljs-built_in">is</span> a **subtle, niche reference embedded within the art itself** - <span class="hljs-built_in">not</span> always literal, always sophisticated. Someone familiar <span class="hljs-keyword">with</span> the subject should feel it intuitively, <span class="hljs-keyword">while</span> others simply experience a masterful abstract composition. The design philosophy provides the aesthetic language. The deduced topic provides the soul - the quiet conceptual DNA woven invisibly <span class="hljs-keyword">into</span> form, color, <span class="hljs-built_in">and</span> composition.
This <span class="hljs-built_in">is</span> **VERY IMPORTANT**: The reference must be refined so it enhances the work<span class="hljs-comment">'s depth without announcing itself. Think like a jazz musician quoting another song - only those who know will catch it, but everyone appreciates the music.</span>
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CANVAS CREATION

<span class="hljs-keyword">With</span> both the philosophy <span class="hljs-built_in">and</span> the conceptual framework established, express it <span class="hljs-keyword">on</span> a canvas. <span class="hljs-keyword">Take</span> a moment <span class="hljs-keyword">to</span> gather thoughts <span class="hljs-built_in">and</span> clear the mind. Use the design philosophy created <span class="hljs-built_in">and</span> the instructions below <span class="hljs-keyword">to</span> craft a masterpiece, embodying all aspects <span class="hljs-keyword">of</span> the philosophy <span class="hljs-keyword">with</span> expert craftsmanship.
**IMPORTANT**: <span class="hljs-keyword">For</span> any type <span class="hljs-keyword">of</span> content, even <span class="hljs-keyword">if</span> the user requests something <span class="hljs-keyword">for</span> a movie/game/book, the approach should still be sophisticated. Never lose sight <span class="hljs-keyword">of</span> the idea that this should be art, <span class="hljs-built_in">not</span> something that<span class="hljs-comment">'s cartoony or amateur.</span>
<span class="hljs-keyword">To</span> create museum <span class="hljs-built_in">or</span> magazine quality work, use the design philosophy <span class="hljs-keyword">as</span> the foundation. Create one <span class="hljs-type">single</span> page, highly visual, design-forward PDF <span class="hljs-built_in">or</span> PNG output (unless asked <span class="hljs-keyword">for</span> more pages). Generally use repeating patterns <span class="hljs-built_in">and</span> perfect shapes. Treat the abstract philosophical design <span class="hljs-keyword">as</span> <span class="hljs-keyword">if</span> it were a scientific bible, borrowing the visual language <span class="hljs-keyword">of</span> systematic observation—dense accumulation <span class="hljs-keyword">of</span> marks, repeated elements, <span class="hljs-built_in">or</span> layered patterns that build meaning through patient repetition <span class="hljs-built_in">and</span> reward sustained viewing. Add sparse, clinical typography <span class="hljs-built_in">and</span> systematic reference markers that suggest this could be a diagram <span class="hljs-keyword">from</span> an imaginary discipline, treating the invisible subject <span class="hljs-keyword">with</span> the same reverence typically reserved <span class="hljs-keyword">for</span> documenting observable phenomena. Anchor the piece <span class="hljs-keyword">with</span> simple phrase(s) <span class="hljs-built_in">or</span> details positioned subtly, <span class="hljs-keyword">using</span> a limited color palette that feels intentional <span class="hljs-built_in">and</span> cohesive. Embrace the paradox <span class="hljs-keyword">of</span> <span class="hljs-keyword">using</span> analytical visual language <span class="hljs-keyword">to</span> express ideas about human experience: the result should feel <span class="hljs-built_in">like</span> an artifact that proves something ephemeral can be studied, mapped, <span class="hljs-built_in">and</span> understood through careful attention. This <span class="hljs-built_in">is</span> <span class="hljs-literal">true</span> art. 
**<span class="hljs-keyword">Text</span> <span class="hljs-keyword">as</span> a contextual element**: <span class="hljs-keyword">Text</span> <span class="hljs-built_in">is</span> always minimal <span class="hljs-built_in">and</span> visual-first, but <span class="hljs-keyword">let</span> context guide whether that means whisper-quiet labels <span class="hljs-built_in">or</span> bold typographic gestures. A punk venue poster might have larger, more aggressive type than a minimalist ceramics studio identity. Most <span class="hljs-keyword">of</span> the time, font should be thin. All use <span class="hljs-keyword">of</span> fonts must be design-forward <span class="hljs-built_in">and</span> prioritize visual communication. Regardless <span class="hljs-keyword">of</span> <span class="hljs-keyword">text</span> scale, <span class="hljs-literal">nothing</span> falls <span class="hljs-keyword">off</span> the page <span class="hljs-built_in">and</span> <span class="hljs-literal">nothing</span> overlaps. Every element must be contained within the canvas boundaries <span class="hljs-keyword">with</span> proper margins. Check carefully that all <span class="hljs-keyword">text</span>, graphics, <span class="hljs-built_in">and</span> visual elements have breathing room <span class="hljs-built_in">and</span> clear separation. This <span class="hljs-built_in">is</span> non-negotiable <span class="hljs-keyword">for</span> professional execution. **IMPORTANT: Use different fonts <span class="hljs-keyword">if</span> writing <span class="hljs-keyword">text</span>. Search the `./canvas-fonts` directory. Regardless <span class="hljs-keyword">of</span> approach, sophistication <span class="hljs-built_in">is</span> non-negotiable.**
Download <span class="hljs-built_in">and</span> use whatever fonts are needed <span class="hljs-keyword">to</span> make this a reality. <span class="hljs-keyword">Get</span> creative <span class="hljs-keyword">by</span> making the typography actually part <span class="hljs-keyword">of</span> the art itself -- <span class="hljs-keyword">if</span> the art <span class="hljs-built_in">is</span> abstract, bring the font onto the canvas, <span class="hljs-built_in">not</span> typeset digitally.
<span class="hljs-keyword">To</span> push boundaries, follow design instinct/intuition <span class="hljs-keyword">while</span> <span class="hljs-keyword">using</span> the philosophy <span class="hljs-keyword">as</span> a guiding principle. Embrace ultimate design freedom <span class="hljs-built_in">and</span> choice. Push aesthetics <span class="hljs-built_in">and</span> design <span class="hljs-keyword">to</span> the frontier. 
**CRITICAL**: <span class="hljs-keyword">To</span> achieve human-crafted quality (<span class="hljs-built_in">not</span> AI-generated), create work that looks <span class="hljs-built_in">like</span> it took countless hours. Make it appear <span class="hljs-keyword">as</span> though someone at the absolute top <span class="hljs-keyword">of</span> their field labored over every detail <span class="hljs-keyword">with</span> painstaking care. Ensure the composition, spacing, color choices, typography - everything screams expert-level craftsmanship. <span class="hljs-type">Double</span>-check that <span class="hljs-literal">nothing</span> overlaps, formatting <span class="hljs-built_in">is</span> flawless, every detail perfect. Create something that could be shown <span class="hljs-keyword">to</span> people <span class="hljs-keyword">to</span> prove expertise <span class="hljs-built_in">and</span> rank <span class="hljs-keyword">as</span> undeniably impressive.
Output the final result <span class="hljs-keyword">as</span> a <span class="hljs-type">single</span>, downloadable .pdf <span class="hljs-built_in">or</span> .png file, alongside the design philosophy used <span class="hljs-keyword">as</span> a .md file.
------------------------------------------------------------------------------------------------------------------------

\## FINAL <span class="hljs-keyword">STEP</span>
**IMPORTANT**: The user ALREADY said <span class="hljs-string">"It isn't perfect enough. It must be pristine, a masterpiece if craftsmanship, as if it were about to be displayed in a museum."</span>
**CRITICAL**: <span class="hljs-keyword">To</span> refine the work, avoid adding more graphics; instead refine what has been created <span class="hljs-built_in">and</span> make it extremely crisp, respecting the design philosophy <span class="hljs-built_in">and</span> the principles <span class="hljs-keyword">of</span> minimalism entirely. Rather than adding a fun filter <span class="hljs-built_in">or</span> refactoring a font, consider how <span class="hljs-keyword">to</span> make the existing composition more cohesive <span class="hljs-keyword">with</span> the art. <span class="hljs-keyword">If</span> the instinct <span class="hljs-built_in">is</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">call</span> a <span class="hljs-built_in">new</span> <span class="hljs-keyword">function</span> <span class="hljs-built_in">or</span> draw a <span class="hljs-built_in">new</span> shape, <span class="hljs-keyword">STOP</span> <span class="hljs-built_in">and</span> instead ask: <span class="hljs-string">"How can I make what's already here more of a piece of art?"</span>
<span class="hljs-keyword">Take</span> a second pass. Go back <span class="hljs-keyword">to</span> the code <span class="hljs-built_in">and</span> refine/polish further <span class="hljs-keyword">to</span> make this a philosophically designed masterpiece.

## MULTI-PAGE <span class="hljs-keyword">OPTION</span>

<span class="hljs-keyword">To</span> create additional pages <span class="hljs-keyword">when</span> requested, create more creative pages along the same lines <span class="hljs-keyword">as</span> the design philosophy but distinctly different <span class="hljs-keyword">as</span> well. Bundle those pages <span class="hljs-keyword">in</span> the same .pdf <span class="hljs-built_in">or</span> many .pngs. Treat the first page <span class="hljs-keyword">as</span> just a <span class="hljs-type">single</span> page <span class="hljs-keyword">in</span> a whole coffee table book waiting <span class="hljs-keyword">to</span> be filled. Make the <span class="hljs-keyword">next</span> pages unique twists <span class="hljs-built_in">and</span> memories <span class="hljs-keyword">of</span> the original. Have them almost tell a story <span class="hljs-keyword">in</span> a very tasteful way. Exercise full creative freedom.
</code></pre>
<p>包含 执行流程、设计理念关键理解、哲学示例、画布创建 等操作描述。</p>
<p>重启Claude Code CLI，要查看当前所有可用的技能，可以在交互式命令中直接询问 Claude Code CLI：</p>
<pre><code class="hljs language-arduino" lang="arduino">List all available Skills
</code></pre>
<p>Claude Code CLI会查找所有可用的Skill</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3c76ed90d9cb4c99ac3c2ab284967072~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=USF%2BaXxiAouSxtj%2B9G2t0dpxosw%3D" alt="图片" loading="lazy"/></p>
<p>Skill的使用也很简单，直接输入提示词：</p>
<pre><code class="hljs">「流浪猫领养公益海报，视觉主体是 3 只不同毛色的流浪猫（橘猫、三花猫、黑猫，姿态温顺，睁着圆眼看向镜头），趴在铺着柔软灰色毛毯的木质平台上，背景是浅薄荷绿纯色背景，角落点缀小型白色爱心图案，风格为清新治愈的扁平插画风，
色调以薄荷绿、奶白、橘色为主，顶部用圆润字体写‘给它一个家 —— 流浪猫领养日’，下方标注时间（10.1-10.7）和地点（城市中心广场），画面无尖锐元素，整体温暖柔和，传递‘关爱生命’的氛围」，根据上面提示词生成对应内容海报
</code></pre>
<p>Claude Code CLI会根据Skill要求先进行设计哲学创作并保存到 tender_sanctuary_philosophy.md 文件</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ca013a34c324535a53821b8b4b2a1a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=NV9hkW9IJtX0LRkWvw77tcGpFws%3D" alt="图片" loading="lazy"/></p>
<p>然后根据创作设计文件编写Python脚本绘制图片</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d78c9de9a8c147c0a6c0d26a67b2d65d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=JTlrKQBhYXHiH1s47OhmbVys7HU%3D" alt="图片" loading="lazy"/></p>
<p>绘制完成后，效果如下，效果有点一言难尽，对中文支持有问题，中文没有展示出来</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5c3c3fa44640400e908b0b972a1cedae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=Xa%2BwItPw41pT7wRG1ewQ8pUmcZw%3D" alt="图片" loading="lazy"/></p>
<p>最后替换为英文版，效果如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96da3fefc42443d695aadd5876d261b9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=yBcqq5bKWS3%2FcSx6CCMYHweWe9A%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-13">自定义Skill</h3>
<p>这里我们以一个简单的待办事项为例，自定义Skill首先需要创建一个 skills目录，可以手动创建，也可以通过以下命令创建：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_">$</span><span class="bash"> <span class="hljs-built_in">mkdir</span> -p .claude/skills/my-skill-name</span>
</code></pre>
<p>在 my-skill-name 目录下创建 SKILL.md 文件，首先创建一个简单的Skill输入提示词内容：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-meta">---</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">my-first-skill</span>
<span class="hljs-attr">description:</span> <span class="hljs-string">调用个人工作流。当用户需要执行个人工作流时调用该Skill</span>
<span class="hljs-attr">allowed-tools:</span> <span class="hljs-string">Read,Grep,Glob</span>
<span class="hljs-meta">---
</span>
<span class="hljs-comment">## 执行步骤</span>
<span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">查找项目中</span> <span class="hljs-string">task.md</span> <span class="hljs-string">文件：</span>
<span class="hljs-string">```bash</span>
<span class="hljs-string">find</span> <span class="hljs-string">.</span> <span class="hljs-string">-name</span> <span class="hljs-string">"task.md"</span>
<span class="hljs-string">```</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">没有查找到输出</span> <span class="hljs-string">“项目中不存在task.md”</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">执行下一步</span>
<span class="hljs-number">2</span><span class="hljs-string">.</span> <span class="hljs-string">输出</span> <span class="hljs-string">task.md</span> <span class="hljs-string">文件中的未读项</span>
</code></pre>
<p>调用也很简单，直接输入提示词：</p>
<pre><code class="hljs">调用个人工作流Skill 
</code></pre>
<p>Claude Code CLI会按照指定的Shell语句查找 task.md 文件，没有找到最终输出了“项目中不存在task.md”</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5dbea69612df4641b67ef4cf7f8ac052~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=d5BKk0i81k1J4Yp2F1U9Hq1kirw%3D" alt="图片" loading="lazy"/></p>
<p>我们在项目根目录创建一个 task.md 文件</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/565a492e7a8f4db59b7a895f1c1bdaba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=eRDagrb2aA43DyD6eV02sUr%2FuEw%3D" alt="图片" loading="lazy"/></p>
<p>再次执行自定义Skill，可以看到输出结果如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/61fa819a90514dca967bf73217d84ae4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=WmWfLOKJUEp3Y6iekbnZ7Fc93JA%3D" alt="图片" loading="lazy"/></p>
<p>我们也可以将 task.md 文件的查找和输出规则进行调整，对Skill进行完善和优化</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d7f9b5c9b064511b557eb93d246f4de~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=RwH%2BffPVaej%2BFkN%2Bnkowqj1xHJY%3D" alt="图片" loading="lazy"/></p>
<pre><code class="hljs language-markdown" lang="markdown">name: my-first-skill
description: 调用个人工作流。当用户需要执行个人工作流时调用该Skill
<span class="hljs-section">allowed-tools: Read,Grep,Glob
-----------------------------</span>

<span class="hljs-section">## 执行步骤</span>

<span class="hljs-bullet">1.</span> 查找项目根目录是否存在 task.md 文件， 参考 [<span class="hljs-string">reference.md</span>](<span class="hljs-link">./reference.md</span>)：
    - 没有查找到输出 “项目中不存在task.md”
    - 找到执行下一步
<span class="hljs-bullet">2.</span> 输出 task.md 文件中的未读项
    - 没有未读项输出 “没有未读项”
    - 输出未读项，输出格式参考 [<span class="hljs-string">templates.md</span>](<span class="hljs-link">./templates/templates.md</span>)
</code></pre>
<p>reference.md</p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># task.md文件查找规则</span>
<span class="hljs-string">``</span><span class="hljs-string">`bash
find . -name "task.md"
`</span><span class="hljs-string">``</span>
</code></pre>
<p>templates.md</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 任务未读项格式</span>
<span class="hljs-bullet">-</span> 【任务1】（未完成）
<span class="hljs-bullet">-</span> 【任务2】（未完成）
</code></pre>
<p>再次执行Skill任务，可以发现AI按照我们指定的规则输出了结果</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/04d622c4789c46b78a316d69b79aa716~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bCP5rqq5b285bK4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763860734&amp;x-signature=dEJOXp4q7X8O5Cui%2BOB%2FMwnMzgo%3D" alt="图片" loading="lazy"/></p>
<p>当然Skill还可以做更多更强大的能力扩展，以上只是简单的抛砖引玉。</p>
<h2 data-id="heading-14">友情提示</h2>
<p>见原文：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FP674ZIjwoeD1kjUELMkaBg" target="_blank" title="https://mp.weixin.qq.com/s/P674ZIjwoeD1kjUELMkaBg" ref="nofollow noopener noreferrer">Claude发布新功能Agent Skills，让你的Agent更专业</a></p>
<blockquote>
<p>本文同步自微信公众号 "<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FP674ZIjwoeD1kjUELMkaBg" target="_blank" title="https://mp.weixin.qq.com/s/P674ZIjwoeD1kjUELMkaBg" ref="nofollow noopener noreferrer">程序员小溪</a>" ，这里只是同步，想看及时消息请移步我的公众号，不定时更新我的学习经验。友情提示友情提示</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Flutter,Compose,Web 在Android平台上从布局到屏幕的机制探究]]></title>    <link>https://juejin.cn/post/7572480736362266630</link>    <guid>https://juejin.cn/post/7572480736362266630</guid>    <pubDate>2025-11-16T12:41:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572480736362266630" data-draft-id="7572525491538821162" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Flutter,Compose,Web 在Android平台上从布局到屏幕的机制探究"/> <meta itemprop="keywords" content="Flutter,Android,WebView"/> <meta itemprop="datePublished" content="2025-11-16T12:41:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="apigfly"/> <meta itemprop="url" content="https://juejin.cn/user/2488950054453613"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Flutter,Compose,Web 在Android平台上从布局到屏幕的机制探究
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2488950054453613/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    apigfly
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T12:41:46.000Z" title="Sun Nov 16 2025 12:41:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读27分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>最近用到了 Flutter 做跨平台项目，比较好奇跨平台项目是怎么能够在 Android 设备上显示出来的，就有了今天的文章，因为之前写的 <a href="https://juejin.cn/post/6944960866404007944" target="_blank" title="https://juejin.cn/post/6944960866404007944">Android 图形显示系统</a> ，也算是承上启下了吧，毕竟这么多年没更啦</p>
</blockquote>
<h2 data-id="heading-0"><strong>1. 核心架构基础：Android 图形栈与数据流</strong></h2>
<p>理解任何 Android UI 组件的渲染过程，都必须从操作系统的底层图形架构开始，特别是缓冲区管理、Surface 抽象以及系统合成器的功能。</p>
<h3 data-id="heading-1"><strong>1.1. Android 渲染数据流：BufferQueue, Surface 与 Layer 模型</strong></h3>
<p>Android 图形系统基于<code>生产者-消费者</code>模型。
在这种模型中，应用或其渲染引擎被视为<code>生产者</code>，而系统合成器 <code>SurfaceFlinger</code> 则充当<code>消费者</code>。具体大家可以看之前的文章：<a href="https://juejin.cn/post/6944960866404007944#heading-0" target="_blank" title="https://juejin.cn/post/6944960866404007944#heading-0">显示原理</a></p>
<p>简要示意图如下：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1eb1d3858e0a4552bdcf7f7ab7935270~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=dv7A%2FgboMU5H0jYcGQ0o2kt6evw%3D" alt="graphics-pipeline.png" loading="lazy"/></p>
<h4 data-id="heading-2"><code>BufferQueue</code></h4>
<p>数据交换的核心。这是一个先进先出（FIFO）队列，位于 <code>libgui IPC</code> 库中，用于跨进程安全地传输图形缓冲区。</p>
<p><code>生产者</code>负责向队列中写入已渲染的帧，而<code>消费者</code>则从队列中取出帧进行合成。
这种机制的设计目标是确保数据的原子性传输和同步。</p>
<p><code>消费者</code>通常是 Android 的核心合成器 <code>SurfaceFlinger</code>，但也可以是其他组件，例如 <code>SurfaceView</code>、<code>SurfaceTexture</code> 或 <code>ImageReader</code>。</p>
<h4 data-id="heading-3"><code>Surface</code></h4>
<p><code>Surface</code> 对象是应用进程用于与 <code>BufferQueue</code> 交互的高级 API 接口。
它本身并不存储像素数据，而是持有一个对底层 <code>IGraphicBufferProducer</code> 接口的引用。
这个接口允许应用跨进程将渲染完成的图形缓冲区排队等待消费。</p>
<h4 data-id="heading-4"><code>Layer</code></h4>
<p><code>Layer</code> 是 <code>SurfaceFlinger</code> 内部用于合成的基本单位。
它与 <code>Surface</code> 不同，<code>Surface</code> 专注于像素内容的生产，而 <code>Layer</code> 专注于该内容的合成方式。
一个 <code>Layer</code> 封装了合成所需的全部元数据和状态信息，包括：Z 轴顺序（决定遮挡关系）、可见性、混合模式（Alpha 混合）、裁剪区域、完整的 2D/3D 转换矩阵（Translation, Rotation, Scale）。</p>
<h4 data-id="heading-5">零拷贝优化</h4>
<p>现代 Android 图形系统严重依赖 <code>AHardwareBuffer (API 26+)</code> 来实现高性能、低延迟的图形数据传输。<br/>
<code>AHardwareBuffer</code> 代表一种硬件支持的缓冲区，可以高效地在不同系统组件和进程之间共享，通常用于实现零拷贝操作。<br/>
<code>AHardwareBuffer</code>支持多层纹理数组和立方体贴图的定义，特别适用于 Vulkan 后端或跨进程图形传输<br/>
<code>WebView</code> 的进程外光栅化（OOPR）就需要利用<code>AHardwareBuffer</code>机制实现高效的缓冲区共享。</p>
<p><strong>生产者与消费者的“距离”与隔离</strong>
<code>BufferQueue</code> 机制的核心价值在于，它使得<code>生产者</code>和<code>消费者</code>能够在不同的线程甚至不同的进程中独立、并行地运行。这种隔离性是 Android 实现流畅 UI 和高保真媒体播放的关键：</p>
<ol>
<li><strong>线程隔离（距离近）：</strong> 生产者（如应用中的 RenderThread 或 GLSurfaceView 的专用渲染线程）可以在高频下（如 60FPS）渲染，而不会阻塞接收该缓冲区的消费者（通常是 <code>SurfaceFlinger</code>）。这确保了渲染任务不会拖累应用的主 UI 线程。</li>
<li><strong>进程隔离（距离远）：</strong> <code>Surface</code> 对象实现了 <code>Parcelable</code> 接口，因此可以安全地通过 <code>Binder IPC</code> 机制跨越进程边界传输。这种能力使得一个独立进程的渲染结果能够直接提交给另一个进程中的接收者（例如 <code>SurfaceFlinger</code> 或 <code>SurfaceView</code>）。</li>
</ol>
<p><strong>SF 之外的消费者 (应用程序主动选择的数据处理流)</strong></p>
<ol>
<li><strong>SurfaceTexture (GPU 纹理消费者):</strong>
<ul>
<li><strong>场景：</strong> 实时相机预览、将视频流作为纹理应用到 3D 游戏或 AR 场景中。</li>
<li><strong>机制：</strong> <code>SurfaceTexture</code> 充当 <code>BufferQueue</code> 的消费者。它接收生产者（如相机驱动或视频解码器）提交的帧数据，并将其转换为一个 <strong>OpenGL ES 纹理</strong>，供应用内的 GLES 线程绑定和使用。这允许开发者在 GPU 上直接处理这些数据（例如应用滤镜、进行几何变换），<strong>而无需将数据提交给 SurfaceFlinger 进行系统合成</strong>。这种路径允许应用在本地 GPU 上完成渲染和处理，但最终如果需要显示，应用通常需要将这个<strong>处理后的纹理</strong>绘制到自己的主 <code>Surface</code> 上（最终仍由 SF 合成）。</li>
</ul>
</li>
<li><strong>ImageReader (数据处理消费者):</strong>
<ul>
<li><strong>场景：</strong> 截屏、图像分析（如人脸识别）、自定义相机捕获原始帧。</li>
<li><strong>机制：</strong> ImageReader 也充当 BufferQueue 的消费者。它允许应用程序从队列中获取图像数据（Image 对象），通常是原始像素数据。数据随后被发送到应用的 CPU/NDK 层，用于进一步的软件处理、分析或保存，<strong>完全绕过了 Android 的硬件加速显示路径</strong>，是纯粹的数据获取和处理通道。</li>
</ul>
</li>
</ol>
<p><strong>SF 跨进程/跨线程能力的常见示例 (显示场景)</strong></p>
<ul>
<li><strong>视频播放 (SurfaceView 场景):</strong>
<ul>
<li><strong>生产者：</strong> 视频解码器（通常是运行在独立进程中的硬件或系统服务）。</li>
<li><strong>消费者：</strong> SurfaceFlinger。</li>
<li><strong>优势：</strong> 解码器将视频帧直接绘制到从 SurfaceView 获得的 Surface 上。由于 SurfaceFlinger 直接从 BufferQueue 获取缓冲区，整个过程<strong>完全绕过了应用的主 CPU/GPU 管线</strong>。这实现了零拷贝的数据路径，对高吞吐量的视频帧传输至关重要，确保了低延迟和低功耗。</li>
</ul>
</li>
<li><strong>多窗口/系统 UI 合成 (SurfaceFlinger 核心功能):</strong>
<ul>
<li><strong>生产者：</strong> 应用 A 的主渲染 Layer (Native View/Compose 的 RenderThread 提交)；应用 B 的独立 Layer；系统状态栏和导航栏 Layer。</li>
<li><strong>消费者：</strong> SurfaceFlinger。</li>
<li><strong>优势：</strong> SurfaceFlinger 接收来自<strong>多个不同应用进程</strong>和<strong>系统进程</strong>的独立 Layer，并管理它们的 Z 轴顺序、位置和变换。这种隔离确保了即使一个应用崩溃，也不会影响其他应用或系统 UI 的显示。</li>
</ul>
</li>
<li><strong>进程外 WebView 渲染 (OOPR 模式):</strong>
<ul>
<li><strong>生产者：</strong> 沙箱隔离的 Chrome Render Process（一个独立进程）。</li>
<li><strong>消费者：</strong> SurfaceFlinger。</li>
<li><strong>优势：</strong> WebView 的内容渲染发生在应用主进程之外。渲染进程将结果提交到专用的 Surface 缓冲区，SurfaceFlinger 将其作为独立 Layer 合成。这提供了极佳的安全性和稳定性隔离，即使 Web 内容中的 JavaScript 导致渲染进程崩溃，主机应用也可以通过回调机制恢复。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-6"><strong>1.2. 系统合成器：<code>SurfaceFlinger</code> 与硬件合成器 (<code>HWC</code>) 的角色</strong></h3>
<p><code>SurfaceFlinger (SF)</code> 是 Android 的核心系统服务，充当所有可见 UI 元素的最终合成器。</p>
<h4 data-id="heading-7"><code>SurfaceFlinger (SF)</code> 的职责</h4>
<p><code>SF</code> 接收来自所有可见窗口和系统 UI 组件的图形缓冲区，这些缓冲区通过 <code>Layer</code> 的形式提交给 <code>SF</code> 。<br/>
<code>SF</code> 的任务是：</p>
<ul>
<li>管理所有 <code>Layer</code> 的 Z 轴顺序、位置、变换和剪裁。</li>
<li>根据 <code>Layer</code> 的属性（例如透明度、相对 Z 轴、圆角等）决定如何进行合成。</li>
<li>将最终合成的结果发送给显示硬件。</li>
</ul>
<h4 data-id="heading-8"><code>SurfaceFlinger</code> 的核心地位</h4>
<p>无论采用哪种渲染技术栈（<code>Native View</code>, <code>Compose</code>, <code>Flutter</code>, <code>WebView</code>, <code>GLSurfaceView</code>），它们最终都必须通过各自的 <code>Surface</code> 接口向 <code>BufferQueue</code> 提交渲染完成的图形缓冲区。<br/>
因此，可以确定，在 Android 平台上，所有五种技术路线的渲染结果，都会以独立的或应用主 Layer 的形式，统一由 <code>SurfaceFlinger</code> 来接收和处理，这是它们最终得以在屏幕上显示的必经之路。</p>
<h4 data-id="heading-9">硬件合成器 (HWC) 优化</h4>
<p>为了最大化性能和降低功耗，<code>SurfaceFlinger</code> 倾向于将合成任务卸载给硬件合成器（<code>Hardware Composer, HWC</code>）。<br/>
<code>HWC</code> 是一个 SoC 厂商实现的 HAL（硬件抽象层）模块，能够直接处理 Layer 的合成，通常以零拷贝的方式操作缓冲区。这极大地提高了效率。<br/>
只有当 <code>Layer</code> 具有复杂的混合、变换或特效，<code>HWC</code> 无法直接处理时，<code>SF</code> 才会退回到使用 GPU 进行合成（GPU Compositing），这会增加系统的渲染开销。</p>
<h3 data-id="heading-10"><strong>1.3. 绘制指令模式对比：即时与保留</strong></h3>
<p>UI 框架在生成绘图指令时，主要遵循两种模式：保留模式 (Retained Mode) 和即时模式 (Immediate Mode)。</p>
<h4 data-id="heading-11">保留模式 (Retained Mode)</h4>
<p>在这种模式下，UI 元素的结构和属性被存储为一个场景图或对象层级结构（在 Android <code>Native/Compose</code> 中称为 <code>RenderNode</code> 或 <code>Display List</code>）。当 UI 状态发生变化时，系统只需更新场景图中发生变化的部分，而不是重新执行所有绘图指令。这种模式非常适合动态或频繁变化的 UI，因为它允许更灵活和高效的更新 。Android Native Views 和 Jetpack Compose 都是基于保留模式的实现。</p>
<h4 data-id="heading-12">即时模式 (Immediate Mode)</h4>
<p>在这种模式下，每一次帧更新，应用程序都需要重新发送完整的绘图指令序列。系统不存储 UI 状态图。即时模式要求开发者对底层的图形 API（如 OpenGL ES 或 Skia Canvas）有更直接的控制。它在静态 UI 中可能资源占用较少，但在动态 UI 中可能性能较差，除非底层引擎进行了高效优化（如 Flutter 的 Skia）。<br/>
GLSurfaceView 和 Flutter 的核心渲染流程属于即时模式。</p>
<p><strong>绘制模式 (Immediate vs. Retained) 特性对比</strong></p>






























<table><thead><tr><th align="left">特性</th><th align="left">保留模式 (Retained Mode)</th><th align="left">即时模式 (Immediate Mode)</th></tr></thead><tbody><tr><td align="left"><strong>核心机制</strong></td><td align="left">场景图/显示列表 (RenderNode) 存储状态</td><td align="left">立即执行绘图指令，不存储状态</td></tr><tr><td align="left"><strong>更新效率</strong></td><td align="left">高效 (仅重绘变动部分)</td><td align="left">依赖框架/引擎 (Skia 优化了底层效率)</td></tr><tr><td align="left"><strong>线程隔离</strong></td><td align="left">RenderThread 机制提供原生的 CPU/GPU 隔离</td><td align="left">需用户/引擎自行实现专用 Raster/GLES 线程</td></tr><tr><td align="left"><strong>代表技术</strong></td><td align="left">Android Native View, Jetpack Compose</td><td align="left">Flutter (Skia), GLSurfaceView</td></tr></tbody></table>
<h2 data-id="heading-13"><strong>2. 保留模式下的原生 UI 渲染管线：Native View 与 Compose</strong></h2>
<p>Android 原生 UI 框架（无论是基于 View 还是 Compose）都依赖于 AOSP 的保留模式渲染架构，核心在于 <code>RenderThread</code>。</p>
<h3 data-id="heading-14"><strong>2.1. Android 原生 View 渲染流程：Record, Execute 与 RenderThread</strong></h3>
<p>当 <code>View</code> 层次结构需要更新时，渲染流程在应用进程内分两个主要阶段进行：</p>
<h4 data-id="heading-15">1. UI 线程：记录 (<code>Record</code>) 阶段</h4>
<p>UI 线程（或主线程）负责所有的业务逻辑、布局计算（Measure 和 Layout），以及绘图指令的记录。在硬件加速开启的前提下，<code>View#draw(Canvas)</code>的调用不会直接执行 GPU 渲染，而是将绘图操作记录到关联的 <code>RenderNode</code>（即 <code>Display List</code>）中。</p>
<ul>
<li><strong>性能风险：</strong> 尽管记录 Display List 通常很快，但如果应用代码在此阶段涉及复杂的 CPU 密集型操作，例如绘制到 Bitmap（这会触发 CPU 软件渲染），则会占用 UI 线程时间，可能导致帧率下降（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F476477559" target="_blank" title="https://zhuanlan.zhihu.com/p/476477559" ref="nofollow noopener noreferrer">Jank指标</a>）。</li>
</ul>
<h4 data-id="heading-16">2. RenderThread：执行 (Execute) 阶段</h4>
<p><code>RenderThread</code> 是一个系统管理的新线程，自 Android Lollipop 引入，旨在将 GPU 相关的重型工作负载从 UI 线程分离出来。</p>
<ul>
<li><strong>JANK 隔离：</strong> <code>RenderThread</code> 的核心价值在于，即使 UI 线程被阻塞（例如，因垃圾回收或复杂业务逻辑），它仍能继续执行先前提交的 Display List，从而保持动画、触摸反馈和 <code>Material Design</code> 特效（如涟漪效果）的平滑运行。</li>
<li><strong>执行与优化：</strong> <code>RenderThread</code> 接收 UI 线程提交的 <code>RenderNode</code>，负责对指令进行优化（例如，批处理），将它们翻译成低级的 GPU API 调用（GLES 或 Vulkan），并最终通过 <code>eglSwapBuffers()</code> 提交到 <code>Surface</code> 的 <code>BufferQueue</code> 中。</li>
<li><strong>潜在的性能陷阱：</strong> 某些 <code>Canvas</code> 操作，如绘制非常大的或复杂的 <code>Path</code> 对象，在 UI 线程上的记录成本很低，但在 <code>RenderThread</code> 执行时可能触发昂贵的 CPU 或 GPU 计算，导致 <code>RenderThread</code> 成为新的瓶颈。系统分析工具（如 Systrace）常用于识别这类问题。</li>
</ul>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 专用 <code>RenderThread</code>。</li>
<li><strong>驱动机制：</strong> <strong>强依赖 VSync 信号。</strong> 当应用需要渲染时，系统会向 <code>Choreographer</code> 注册一个回调，等待 <code>VSync</code> 信号的到来。</li>
<li><strong>频率控制：</strong> 渲染频率主要由系统 <code>VSync 频率</code>（通常 60Hz 或 120Hz）控制。应用通过 <code>View.invalidate()</code> 标记 <code>View</code> 为脏，但实际的绘制执行始终与 <code>VSync</code> 同步，以避免画面撕裂。</li>
</ul>
<h4 data-id="heading-17">原生 View 渲染流程</h4>
<p>时序图：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/798ae6ffa43b42c194fe7292b8475ea0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=0lmRV1St0QkWybG1WhxQYVmJK%2BA%3D" alt="image.png" loading="lazy"/></p>
<p>该流程描述了 Native View 从输入事件到最终显示的序列：</p>
<ol>
<li><strong>Application UI Thread：</strong> 执行 <code>View</code> 层次结构的 <code>Measure</code> &amp; <code>Layout</code> 阶段，确定所有组件的尺寸和位置。</li>
<li><strong>Application UI Thread：</strong> 执行 <code>Record</code> 阶段，调用 <code>View#draw</code>，将所有绘图操作（如绘制文本、形状）记录到 <code>RenderNode (Display List)</code> 中。</li>
<li><strong>Application UI Thread -&gt; RenderThread：</strong> 分发记录好的 <code>RenderNode</code> 数据到独立的 <strong>RenderThread</strong>。</li>
<li><strong>RenderThread：</strong> 优化 <code>RenderNode</code> 中的指令，将其转化为低级 GPU 调用 (GLES 或 Vulkan)。</li>
<li><strong>RenderThread -&gt; GPU：</strong> 发出 <strong>光栅化指令</strong>，在 <code>VSync</code> 信号驱动下，在应用独占的缓冲区中绘制 View 的像素内容。<strong>此步骤在应用进程内完成所有 UI 元素的绘制。</strong></li>
<li><strong>RenderThread -&gt; SurfaceFlinger：</strong> 通过 <code>EGLSurface</code> 调用 <code>eglSwapBuffers()</code>，将绘制完成的缓冲区提交给系统合成器<code>SF</code>。</li>
<li><strong>SurfaceFlinger/HWC：</strong> 接收应用缓冲区，进行 <strong>系统级合成 (Composition)</strong> 和最终显示。<code>HWC</code> 确定最佳合成路径，将此 <code>Layer</code> 与状态栏、导航栏、其他应用窗口等所有 <code>Layer</code> 合并，并最终显示到屏幕上。</li>
</ol>
<h3 data-id="heading-18"><strong>2.2. Jetpack Compose 渲染管线：声明式与 GraphicsLayer 优化</strong></h3>
<p><code>Jetpack Compose</code> 采用了声明式 UI 模型，其渲染管线遵循 <code>Composition</code>（节点创建）、<code>Measure</code>、<code>Layout</code>，最终到达 <code>Drawing</code> 阶段。尽管其编程范式发生了根本性变化，但在 Android 平台上，<code>Compose</code> 最终仍复用 <code>Native View</code> 的底层硬件加速机制。</p>
<h4 data-id="heading-19"><code>Draw</code> 阶段与 <code>Canvas</code> 的关联</h4>
<p><code>Compose</code> 框架在 <code>Draw</code> 阶段，底层仍然依赖于 <code>View</code> 系统的 <code>Canvas API</code> 进行实际的像素操作 。<br/>
然而，<code>Compose</code> 通过 <code>DrawScope</code> 抽象简化了传统的 <code>View</code> 绘图模型，例如替开发者管理复杂的 <code>Paint</code> 对象配置，确保性能优化。<br/>
<strong>GraphicsLayer 与 RenderNode 的复用</strong><br/>
<code>Compose</code>通过 <code>Modifier.graphicsLayer</code> 引入了与 <code>Native View</code> 中 <code>RenderNode</code> 相似的概念 。<br/>
使用 <code>graphicsLayer</code> 意味着 <code>Composable</code> 组件的绘图指令会被捕获并缓存到一个 <code>Layer</code> 中 。</p>
<ul>
<li><strong>性能收益：</strong> 这种缓存机制允许渲染管线高效地重发这些绘图指令，尤其适用于频繁的几何变换、透明度变化或缩放动画。一旦指令被捕获，RenderThread 可以在不依赖 UI 线程重新执行 Composable 代码的情况下，重复执行这些已缓存的指令。</li>
</ul>
<h4 data-id="heading-20">Offscreen Rasterization (离屏光栅化)</h4>
<p><code>graphicsLayer</code> 的进一步优化是离屏光栅化，也被称为纹理缓存。<br/>
在这种情况下，<code>RenderThread</code> 会执行 <code>RenderNode</code> 中的指令，并将结果捕获到一个离屏 GPU 纹理中。<br/>
在后续的帧中，<code>RenderThread</code> 只需要发送一个简单的指令：“绘制这个纹理”，这极大减少了 CPU 和 GPU 的重复计算，尤其对于复杂的、不常变化的组件（如 <code>LazyList</code> 中滚动的条目）的性能优化至关重要。</p>
<h4 data-id="heading-21">渲染管线性能瓶颈聚焦</h4>
<p>原生 View 和 Compose 共享 RenderThread 执行管线，这表明它们的 GPU 性能优化途径是相似的。它们的主要性能差异体现在 UI 线程的记录阶段：</p>
<ul>
<li>原生 View 的性能瓶颈通常集中在传统的 View 层次结构遍历和 Measure/Layout 效率上。</li>
<li>Compose 的性能瓶颈则集中在 Composition/Recomposition 逻辑的效率和状态管理上。<br/>
即使 RenderThread 隔离了 GPU 执行，如果 Composition 或 Layout 阶段耗时超过每帧预算（例如 16ms），UI 线程的阻塞仍会导致新的 RenderNode 无法及时提交，从而引发 JANK。因此，无论是 Native 还是 Compose，优化策略的重点都必须放在减少 UI 线程的负载上。</li>
</ul>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 共享 AOSP 的 RenderThread。</li>
<li><strong>驱动机制：</strong> <strong>强依赖 VSync 信号。</strong> Compose 状态（State）变化触发 UI 线程的重组和布局计算。RenderThread 的光栅化执行（绘制）同样严格对齐 VSync 脉冲。</li>
<li><strong>频率控制：</strong> 无法直接控制。频率由系统 VSync 确定。Compose 仅在需要时（状态改变）才触发新的帧提交。</li>
</ul>
<h4 data-id="heading-22">Jetpack Compose 渲染流程</h4>
<p>时序图：<br/>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb044636c992468d8eb5196c5104a544~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=Gsih9xpjFxOn3PZdMsAjsDkgJmk%3D" alt="image.png" loading="lazy"/></p>
<p>该流程描述了 Compose 从状态变化到渲染的序列：</p>
<ol>
<li><strong>UI Thread (Composition/Layout)：</strong> 执行 <strong>Composition</strong> 阶段，根据状态（State）变化确定需要创建、更新或跳过哪些 UI 节点。</li>
<li><strong>UI Thread (Composition/Layout)：</strong> 执行 <strong>Measure &amp; Layout</strong> 阶段，确定所有 Composable 组件的最终尺寸和屏幕位置。</li>
<li><strong>UI Thread (Composition/Layout)：</strong> 执行 <strong>Draw Phase</strong>，捕获绘图操作，并将其存储在 GraphicsLayer 中。</li>
<li><strong>UI Thread -&gt; RenderThread：</strong> 将封装了绘图指令的 RenderNode/GraphicsLayer 提交给 RenderThread。</li>
<li><strong>RenderThread -&gt; GPU：</strong> <strong>RenderThread</strong> 在 VSync 驱动下，在 GPU 上执行光栅化指令，包括处理离屏纹理缓存等优化，在应用 Surface 缓冲区中绘制 Composable UI 像素。</li>
<li><strong>RenderThread -&gt; SurfaceFlinger：</strong> 调用缓冲区交换函数，提交渲染完成的帧缓冲区。</li>
<li><strong>SurfaceFlinger：</strong> 接收缓冲区，执行系统级合成，并最终交给 HWC 进行显示。</li>
</ol>
<h2 data-id="heading-23"><strong>3. 即时模式与专用渲染管线：Flutter 与 GLSurfaceView</strong></h2>
<p>与依赖 <code>AOSP</code> <code>RenderThread</code> 的 <code>Native/Compose</code> 不同，<code>Flutter</code> 和 <code>GLSurfaceView</code> 使用即时模式渲染，并创建了独立于 <code>AOSP</code> 图形栈的专用渲染环境。</p>
<h3 data-id="heading-24"><strong>3.1. Flutter View 渲染管线</strong></h3>
<p><code>Flutter</code> 在 Android 上运行于一个名为 <code>Flutter Embedder</code> 的 C++ 组件中，并管理着一组专用的线程：平台线程（负责与宿主 OS 通信）、UI 线程（运行 Dart 逻辑和 Widget 树构建），以及关键的 Raster Thread（栅格化线程）。</p>
<h4 data-id="heading-25">双线程模型</h4>
<p><code>Flutter</code> 的高性能渲染基于其严格隔离的双线程模型：</p>
<ol>
<li><strong>Dart UI Thread：</strong> 负责处理应用逻辑、Widget 构建、Element Tree 维护、Render Tree 创建以及布局计算。</li>
<li><strong>Flutter Raster Thread (也称 GPU Thread)：</strong> 这是一个专用的 C++ 线程，负责将 Dart UI Thread 生成的 Layer Tree 传递给 Flutter 引擎。Flutter 引擎在此线程上将高层级绘图指令翻译成低层级的 GPU/CPU 指令，执行光栅化，并利用 GPU 加速，确保高效渲染。</li>
</ol>
<blockquote>
<p>Flutter 的 UI 线程负责构建高层次的 Layer Tree。然后，Raster Thread 专门负责消耗这个 Layer Tree，并使用其集成的 Skia 或更新的 Impeller 渲染引擎生成低级图形命令。</p>
</blockquote>
<blockquote>
<p>Impeller 旨在通过提前编译着色器等方式，进一步优化移动 GPU 性能</p>
</blockquote>
<h4 data-id="heading-26">即时模式与底层优化</h4>
<p><code>Flutter Android Embedder</code> 负责与 Android 系统进行底层交互。它为 Flutter 的输出获取一个专用的 Android <code>Surface</code>，为 <code>Raster Thread</code> 设置必要的 <code>EGL</code> 或 <code>Vulkan</code> 上下文，并处理低级的缓冲区提交逻辑。</p>
<p><code>Skia/Impeller</code> 最终将整个应用 UI 渲染到一个 <code>Surface</code> 中，作为 Android 系统的一个独立 <code>Layer</code> 提交给 <code>SurfaceFlinger</code>。</p>
<p>虽然 <code>Flutter</code> 在 <code>Dart</code> 侧的 <code>Widget</code> 构建和 <code>Render Tree</code> 创建可以被视为每帧都可能重新发生的即时模式行为，但 <code>Skia/Impeller</code> 在底层对这些指令进行高度优化、批处理和硬件加速。</p>
<h4 data-id="heading-27">渲染架构的独立性</h4>
<p>Flutter <code>Raster Thread</code> 的存在绕过了 AOSP 的 <code>RenderThread</code> 机制。这赋予了 <code>Flutter Engine</code> 对渲染管线的完全控制权和跨平台性能的确定性。</p>
<p>这种架构决策避免了与原生 View 系统的复杂交互，但代价是在集成原生组件时需要引入额外的桥接层和合成模式，如 <code>Platform Views</code>。</p>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 独立于 AOSP 的 <code>Raster Thread</code> (C++ 实现)。</li>
<li><strong>驱动机制：</strong> <code>Flutter Engine</code> 内部具备自己的调度器，但它会监听和对齐<strong>平台 VSync 信号</strong>，以确保渲染帧与显示器的刷新率同步（目标 60 FPS 或 120 FPS）。渲染工作在 UI Thread 和 <code>Raster Thread</code> 之间分工。</li>
<li><strong>频率控制：</strong> 由 <code>Skia/Impeller</code> 控制，同步于系统 <code>VSync</code> 频率。</li>
</ul>
<h4 data-id="heading-28"><strong>Flutter Platform Views 的集成方案深度对比</strong></h4>
<p>Flutter Engine 作为一个完全独立的渲染引擎，当需要嵌入原生 Android View（如 MapView 或 WebView）时，必须采用特殊的机制来桥接 Flutter 的 Raster Thread 与 Android 的 Surface 机制。</p>
<p>Flutter 提供了两种核心渲染机制，选择哪一种取决于对原生组件保真度、Flutter 动画性能以及是否需要 Flutter 侧变换的需求。</p>























<table><thead><tr><th align="left">模式</th><th align="left">适用场景/优势</th><th align="left">限制/劣势</th><th align="left">选择判断</th></tr></thead><tbody><tr><td align="left"><strong>Hybrid Composition (HC)</strong></td><td align="left"><strong>原生视图保真度和性能至上：</strong> 适用于对输入处理、本地视图生命周期和渲染保真度要求极高（接近原生体验）的组件。它提供<strong>最佳的 Android View 性能和保真度</strong></td><td align="left"><strong>牺牲 Flutter 性能：</strong> 由于 SurfaceFlinger 需要进行系统级合成，Flutter UI 的 FPS 会有所降低 <strong>不支持 Flutter 侧变换：</strong> 无法对嵌入的原生视图应用所有 Flutter Widget 的几何变换、透明度或裁剪效果。</td><td align="left"><strong>原生 View 包含 SurfaceView</strong> (如视频、相机)，且原生视图性能优先于 Flutter 动画流畅度。</td></tr><tr><td align="left"><strong>Texture Layer (TLHC)</strong></td><td align="left"><strong>Flutter 动画和变换能力至上：</strong> 适用于需要对嵌入的 View 进行旋转、缩放、裁剪或应用透明度效果的场景。它提供<strong>最佳的 Flutter 渲染性能</strong>。</td><td align="left"><strong>原生视图滚动可能出现卡顿 (Jank)：</strong> 由于将原生 View 渲染到纹理需要额外的处理延迟，快速滚动（如内嵌的 WebView）可能出现卡顿 [17]。SurfaceView 组件在此模式下表现不佳。</td><td align="left"><strong>需要对原生 View 应用 Flutter 侧变换</strong>（如 3D 旋转、裁剪），且原生 View 内容更新频率不高或不需要使用 SurfaceView。</td></tr></tbody></table>
<p><strong>默认机制与自动选择</strong></p>
<ul>
<li><strong>Texture Layer Hybrid Composition (TLHC)</strong> 是目前 Flutter 框架中推荐且默认的 Platform View 渲染模式。</li>
<li><strong>回退机制：</strong> 当原生视图树中包含 SurfaceView 组件时（例如视频播放器、相机预览等），TLHC 模式会遇到困难，系统可能会自动回退到 Hybrid Composition (HC) 模式。</li>
</ul>
<h4 data-id="heading-29">Flutter 渲染架构 (流程描述)</h4>
<p>时序图：<br/>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fd5ef9e3e3cd4e94a7c95cb5a3be3614~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=FMKlOo8nbpJ%2BzpZOHwNlhvYu%2F9Y%3D" alt="image.png" loading="lazy"/></p>
<p>该流程描述了 Flutter 引擎的渲染序列：</p>
<ol>
<li><strong>Dart UI Thread (Engine)：</strong> 执行 Widget Tree 的构建，转换为 Element Tree。</li>
<li><strong>Dart UI Thread (Engine)：</strong> 在 VSync 信号开始时，执行 Layout 阶段，计算 Render Tree，最终生成包含 Skia/Impeller 绘图指令的 Layer Tree。</li>
<li><strong>Dart UI Thread -&gt; Raster Thread (Skia/GPU Thread)：</strong> 将 Layer Tree 传输到独立的 Raster Thread。</li>
<li><strong>Raster Thread (Skia/GPU Thread) -&gt; GPU：</strong> <strong>Skia 引擎</strong> 在其专用线程上执行 <strong>光栅化</strong>，将 Layer Tree 指令转换为低级 GPU 调用，在 Flutter 的 Surface 缓冲区中绘制整个 UI 像素内容。</li>
<li><strong>Raster Thread -&gt; SurfaceFlinger (System)：</strong> 提交应用 Surface 缓冲区，作为单一 Layer 提交给系统。</li>
<li><strong>SurfaceFlinger (System)：</strong> 接收 Flutter 的 Layer，进行系统级合成，并最终交给 HWC 显示。</li>
</ol>
<h3 data-id="heading-30"><strong>3.2. <code>GLSurfaceView</code>：面向 <code>GLES</code> 的低层级控制</strong></h3>
<p><code>GLSurfaceView</code> 为需要进行高性能、自定义 GLES 渲染的应用提供了一个直接的接口，如游戏或视频处理。</p>
<h4 data-id="heading-31">EGL 环境与线程要求</h4>
<p><code>GLSurfaceView</code> 的主要功能是管理 <code>GLES</code> 渲染所需的 <code>EGL</code> 环境。这包括在生命周期回调中创建 <code>EGLContext</code> 和 <code>EGLSurface</code> 实例。</p>
<ul>
<li><strong>专用 GLES 线程：</strong> <code>GLES</code> 规范要求所有的绘图操作必须在特定的 <code>GLES</code> 线程上执行，绝对不能在 UI 线程上执行。<code>GLSurfaceView</code> 内部创建了一个专用的渲染线程来满足这一要求，确保了重型 GPU 负载与应用主线程的彻底隔离。</li>
</ul>
<p>即时模式与缓冲区控制<br/>
开发者在 <code>GLES</code> 线程中执行即时模式的绘图指令。当一帧渲染完成后，必须通过调用 <code>eglSwapBuffers()</code> 来明确地提交当前缓冲区。这个方法名源于传统的双缓冲机制，它将渲染好的后台缓冲区提交到前台供消费者使用。</p>
<ul>
<li><strong>帧率控制：</strong> 默认情况下，<code>GLSurfaceView</code> 可能以显示器的刷新率（例如 60fps）连续渲染。然而，通过设置 <code>RENDERMODE_WHEN_DIRTY</code>，开发者可以只在 UI 逻辑或输入事件明确要求时才请求渲染 (<code>requestRender()</code>)，这对于非实时动画或静态场景的电源和性能优化至关重要。</li>
</ul>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 专用 Dedicated GLES Thread。</li>
<li><strong>驱动机制：</strong> <strong>可控模式。</strong>
<ul>
<li><strong>RENDERMODE_CONTINUOUSLY：</strong> 渲染循环持续运行，默认与 <code>VSync</code> 对齐，尝试达到最高刷新率。</li>
<li><strong>RENDERMODE_WHEN_DIRTY：</strong> 渲染循环仅在应用明确调用 requestRender() 时执行一帧。</li>
</ul>
</li>
<li><strong>频率控制：</strong> <strong>开发者完全控制。</strong> 可以选择连续渲染（高频/Vsync 约束）或事件驱动渲染（低频/按需）。</li>
</ul>
<h4 data-id="heading-32">GLSurfaceView 渲染流程</h4>
<p>时序图：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e20a6d4865e74adc97d21e2272733167~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=uflmgBv89AJ4rNSbyG1L0qB%2BBio%3D" alt="image.png" loading="lazy"/></p>
<p>该流程描述了 <code>GLSurfaceView</code> 的渲染序列：</p>
<ol>
<li><strong>Application UI Thread -&gt; Dedicated GLES Thread：</strong> UI 线程在生命周期回调中，请求 <code>GLES</code> 线程设置 <code>EGL</code> 环境，创建 <code>EGLContext</code> 和 <code>EGLSurface</code> 实例。</li>
<li><strong>Application UI Thread -&gt; Dedicated GLES Thread：</strong> UI 线程通过事件或动画循环，触发 GLES 线程调用 <code>requestRender()</code> 或保持连续渲染模式。</li>
<li><strong>Dedicated GLES Thread -&gt; GPU：</strong> 执行用户定义的 OpenGL ES 绘图命令（即时模式），直接利用 GPU <strong>光栅化</strong> 3D/2D 内容到当前的 EGL 缓冲区。<strong>这是开发者对 GPU 绘图的最直接控制</strong>。</li>
<li><strong>Dedicated GLES Thread -&gt; BufferQueue (EGLSurface)：</strong> 调用 <code>eglSwapBuffers()</code>，将刚刚绘制的缓冲区提交给 <code>BufferQueue</code> 消费者。</li>
<li><strong>BufferQueue (EGLSurface) -&gt; SurfaceFlinger (System)：</strong> 缓冲区作为独立 <code>Layer</code> 提交给系统合成器。</li>
<li><strong>SurfaceFlinger (System)：</strong> 将 <code>GLSurfaceView</code> 的独立 Layer 与其他系统 UI 合成，并通过 HWC 显示。</li>
</ol>
<h2 data-id="heading-33"><strong>4. 混合与跨进程渲染：<code>WebView</code> 与 Platform Views</strong></h2>
<p>复杂的 UI 场景往往涉及不同渲染技术的混合，这要求系统合成器 <code>SurfaceFlinger</code> 介入处理多个独立渲染源的 <code>Layer</code> 合成。</p>
<h3 data-id="heading-34"><strong>4.1. 现代 <code>WebView</code> 渲染机制：Out-of-Process Rasterization (OOPR)</strong></h3>
<p><code>WebView</code> 承载了复杂的 <code>Web</code> 渲染引擎（<code>Chromium</code>）。为了增强安全性和稳定性，现代 Android 系统（API 30 及以上）默认使用进程外光栅化 (<code>OOPR</code>) 模式。<br/>
在 Android API 30 (Android R) 之前，<code>WebView</code> 的渲染模式取决于具体的 <code>Android</code> 版本和设备的内存条件：</p>
<ul>
<li>进程内渲染 (In-Process Renderer): 在 Android Lollipop (API 21) 到 Android Nougat (API 25) 期间，进程内渲染是默认模式。在这种模式下，<code>Chromium</code> 渲染引擎（包括布局和光栅化）与主机应用运行在同一个进程内，共享资源和内存空间。这导致 Web 内容的复杂操作可能直接阻塞应用的主 UI 线程。</li>
<li>进程外渲染的过渡 (Oreo - Q): 从 Android Oreo (API 26) 到 Android Q (API 29)，系统通常会启用进程外渲染，但对于低内存设备，可能会回退到进程内渲染模式。</li>
<li><code>OOPR</code> 默认化 (Android R/API 30+): 由于 Android R 对内存管理的优化，WebView 在 Android R 及以上版本中总是默认使用进程外光栅化 (<code>OOPR</code>) 模式，确保了隔离性。</li>
</ul>
<h4 data-id="heading-35">进程隔离与 Surface IPC</h4>
<p>在 OOPR 模式下，实际的 Web 内容渲染工作发生在宿主应用进程之外的 Chrome Render Process 中。</p>
<ul>
<li><strong>数据流：</strong> <code>Chrome</code> 渲染进程将其渲染结果绘制到一个专用的 Surface 中。这个 <code>Surface</code> 对象通过 <code>Android</code> 的 <code>Binder IPC</code> 机制被传递和管理。渲染进程充当 <code>Surface</code> 的生产者，负责将渲染好的 <code>GraphicBuffer</code> (或 <code>AHardwareBuffer</code>) 提交给 <code>SurfaceFlinger</code>。</li>
<li><strong>宿主应用职责：</strong> 宿主应用的主进程只需要管理 <code>WebView</code> 的生命周期、输入事件转发以及 <code>Surface</code> 的分配，渲染工作负载被完全卸载到远程进程，实现了极高的隔离性。</li>
</ul>
<h4 data-id="heading-36">WebView 的绘制模式与崩溃隔离</h4>
<p><strong>绘制模式：</strong> 尽管 <code>WebView</code> 是作为 Android Native View 层次结构的一部分被托管，其内部的 Chromium 渲染引擎遵循 <code>保留模式 (Retained Mode)</code> 的原则。<br/>
Web 平台的 文档对象模型 (DOM) 充当了其保留状态的模型。浏览器维护 DOM 的状态，并可以在不需要 JavaScript 持续重新发送所有绘图指令的情况下进行渲染，这与 <code>Android View</code> 使用 <code>RenderNode</code> 的思路一致 。</p>
<p><strong>崩溃隔离：</strong> <code>WebView</code> 的进程外光栅化（<code>OOPR</code>）旨在通过将渲染工作负载转移到沙箱隔离的进程中 ，从而提高稳定性和安全性。<br/>
然而，如果发生严重的渲染故障，例如未捕获的 <code>JavaScript</code> 异常导致 <code>Chrome Render Process</code> 崩溃，这仍然可能导致主机应用程序受到影响。<br/>
为了实现进程级别的鲁棒性，Android 平台在 API 26 及更高版本中提供了 <code>WebViewClient#onRenderProcessGone</code> 回调方法。通过重写此方法，主机应用可以在渲染进程崩溃时被通知，从而允许应用进行恢复操作，例如重新加载 WebView 或显示错误信息，防止整个应用程序崩溃。</p>
<p><strong>渲染驱动逻辑与 VSync 依赖</strong></p>
<ul>
<li><strong>渲染线程：</strong> 隔离的 <code>Chrome Render Process</code> 内部的渲染线程。</li>
<li><strong>驱动机制：</strong> <strong>内部 VSync 对齐。</strong> 渲染进程的渲染循环独立运行，但会与系统 VSync 信号对齐。主机应用通过滚动、页面加载或 JavaScript 动画等触发更新，渲染进程负责高效地将新内容光栅化。</li>
<li><strong>频率控制：</strong> 由 Chromium 引擎内部控制。主机应用无法直接调节其帧率。</li>
</ul>
<h4 data-id="heading-37">SurfaceFlinger 的参与</h4>
<p>由于 <code>WebView</code> 的内容是作为独立进程的输出，它必定是一个独立的 Layer 提交给 SurfaceFlinger。</p>
<ul>
<li><strong>性能影响：</strong> 尽管 <code>OOPR</code> 提供了卓越的进程隔离，但它强制 <code>WebView</code> 成为一个独立 <code>Layer</code>，无法内嵌到应用主界面的 <code>RenderNode</code> 中进行优化。这意味着 <code>WebView</code> 内容的任何更新都必须经过 SurfaceFlinger 的系统级合成步骤。这增加了系统合成的开销，尤其是在高频更新的场景下。</li>
</ul>
<h4 data-id="heading-38">WebView OOPR 渲染流程</h4>
<p>时序图：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30b0ed54774140a29a80c515f029b1c7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgYXBpZ2ZseQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763902138&amp;x-signature=OMYido96TIS69haAc46aTK6tGMs%3D" alt="image.png" loading="lazy"/></p>
<p><code>WebView</code> <code>OOPR</code> 渲染架构 (流程描述) 该流程描述了 WebView 跨进程渲染的组件交互：</p>
<ol>
<li>App Host Process (WVHost)： 调用 WebView.loadUrl() 或 loadData()，触发 Web 内容加载。</li>
<li>App Host Process (WVHost) -&gt; Chrome Render Process (WebEngine)： Host 进程通过 Binder IPC 机制向 Chrome 渲染进程分发加载请求、生命周期控制和输入事件。</li>
<li>Chrome Render Process (WebEngine)： Web 引擎（Blink）在远程进程中执行页面解析、布局计算，并构建 Web Layer Tree。</li>
<li>Chrome Render Process (WebEngine) -&gt; GPU： 渲染进程的 GPU 线程执行 光栅化，将 Web 内容绘制到专用的 AHardwareBuffer 中。渲染帧率内部与 VSync 对齐。</li>
<li>Chrome Render Process (WebEngine) -&gt; Android Graphics Subsystem (SF/BQ): Chrome 进程通过 Surface 生产者接口，将渲染好的缓冲区提交到 BufferQueue。</li>
<li>Android Graphics Subsystem (SF/BQ) -&gt; SurfaceFlinger (System)： SurfaceFlinger 接收 WebView 的独立 Layer。</li>
<li>SurfaceFlinger (System)： 执行系统级合成，将 WebView Layer 放置在正确的 Z 轴顺序和位置上，并最终显示。</li>
</ol>
<h2 data-id="heading-39">5. <strong>总结与建议</strong></h2>








































<table><thead><tr><th align="left">技术栈</th><th align="left">系统集成度</th><th align="left">线程隔离粒度</th><th align="left">关键性能关注点</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left"><strong>Native/Compose</strong></td><td align="left">高 (共享 RenderThread)</td><td align="left">CPU/GPU 隔离 (RT)</td><td align="left">优化 UI 线程的记录/重组负载。</td><td align="left">标准 UI 界面，需要高度原生平台特性。</td></tr><tr><td align="left"><strong>Flutter</strong></td><td align="left">低 (独立引擎)</td><td align="left">彻底隔离 (Raster Thread)</td><td align="left">跨平台一致性，减少 Platform View 的合成开销。</td><td align="left">高性能、高自定义度 UI，跨平台项目。</td></tr><tr><td align="left"><strong>GLSurfaceView</strong></td><td align="left">中 (独立 Surface)</td><td align="left">彻底隔离 (GLES Thread)</td><td align="left">自主控制 eglSwapBuffers 频率。</td><td align="left">游戏引擎，实时视频流，自定义 3D 渲染。</td></tr><tr><td align="left"><strong>WebView</strong></td><td align="left">中 (跨进程 Surface)</td><td align="left">彻底隔离 (OOPR)</td><td align="left">跨进程通信延迟和 SurfaceFlinger 的 Layer 合成开销。</td><td align="left">嵌入复杂 HTML/JS 内容。</td></tr></tbody></table>
<p><strong>原生 UI 的瓶颈转移：</strong> 对于 Native View 和 Compose，AOSP 已经通过 RenderThread 解决了 GPU 执行阻塞 UI 线程的问题。然而，性能优化的重点已从 GPU 转移到 UI 线程的 <strong>记录/布局/重组</strong> 阶段。</p>
<p><strong>独立 Surface 的开销：</strong> 无论采用 Flutter、WebView 还是 GLSurfaceView，当它们使用独立的 Surface 对象时，都不可避免地成为 SurfaceFlinger 的一个独立 Layer。虽然这提供了极佳的线程隔离，但也意味着每一次更新都必须经过系统合成器的处理。对于需要大量 Layer 合成或复杂混合的场景，这可能导致比 HWC 零拷贝合成更高的系统资源消耗。</p>
<p><strong>高性能图形的选择：</strong> 对于需要实时（60fps 或 120fps）更新和完全控制图形管线的场景，GLSurfaceView 或 Flutter Engine 是最佳选择。它们通过专用的渲染线程实现了高确定性性能，将光栅化工作负载从 AOSP 的主渲染路径中完全解耦。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java 中 UnaryOperator 接口与 Lambda 表达式的应用示例]]></title>    <link>https://juejin.cn/post/7572459757107724342</link>    <guid>https://juejin.cn/post/7572459757107724342</guid>    <pubDate>2025-11-15T19:21:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572459757107724342" data-draft-id="7572481101710278710" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java 中 UnaryOperator 接口与 Lambda 表达式的应用示例"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-11-15T19:21:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Dcs"/> <meta itemprop="url" content="https://juejin.cn/user/3679404422861902"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java 中 UnaryOperator 接口与 Lambda 表达式的应用示例
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3679404422861902/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Dcs
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-15T19:21:15.000Z" title="Sat Nov 15 2025 19:21:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-15
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家好，这里是<strong>架构资源栈</strong>！点击上方关注，添加“<strong>星标</strong>”，一起学习大厂前沿架构！</p>
<p>关注、发送<code>C1</code>即可获取JetBrains全家桶激活工具和码！</p>
<hr/>
<p>在 Java 8 引入 Lambda 表达式的过程中，开发者面临了许多新的接口，其中不乏一些看起来颇为学术、难以理解的名称。<strong>UnaryOperator</strong> 接口就是其中之一，但其实它的用途和实现非常简单。</p>
<h3 data-id="heading-0"><strong>UnaryOperator 的功能</strong></h3>
<p><strong>UnaryOperator</strong> 接口的功能就是接收一个对象，处理它后返回相同类型的对象。这个“unary”特性意味着输入和输出的对象类型是相同的。</p>
<p>从技术角度看，<strong>UnaryOperator</strong> 接口继承了 <strong>Function</strong> 接口，并且定义了一个名为 <strong>apply</strong> 的方法。</p>
<pre><code class="hljs language-java" lang="java">java.util.function.UnaryOperator
<span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UnaryOperator</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&lt;T, T&gt; {
    T <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d097d6e6669f4bb18fab03c2cf0e8b8d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGNz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763839275&amp;x-signature=o%2FmS%2BTD3RyuHY%2FPqILCHUprgWVs%3D" alt="image" loading="lazy"/></p>
<p>比如，你可能想从一个对一个字符串做特殊处理后返回新的字符串。这正是 <strong>UnaryOperator</strong> 的应用场景——输入和输出都是字符串。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ee962e4a8162472282a1f590454d9889~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGNz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763839275&amp;x-signature=1psbfMxnAYBytTYGDR85E1LAyWk%3D" alt="image" loading="lazy"/></p>
<h3 data-id="heading-1"><strong>UnaryOperator 实现示例</strong></h3>
<p>首先来看一个传统的实现方式，我们创建一个类 <code>UnaryOperatorExample</code> 来实现 <strong>UnaryOperator</strong> 接口，并提供 <code>apply</code> 方法：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> com.xiaod.lambda;


<span class="hljs-keyword">import</span> java.util.function.UnaryOperator;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryOperatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UnaryOperator</span>&lt;String&gt; {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-keyword">return</span> name+<span class="hljs-string">"，财运滚滚！"</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryOperatorImplTest</span> {

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUnaryOperatorImpl</span><span class="hljs-params">()</span> {
        <span class="hljs-type">UnaryOperatorImpl</span> <span class="hljs-variable">unaryOperatorImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnaryOperatorImpl</span>();
        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">"小D"</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> unaryOperatorImpl.apply(name);
        <span class="hljs-comment">// 小D，财运滚滚！</span>
        System.out.println(result);
    }

}
</code></pre>
<p>执行上述代码后，控制台将输出字符串 <code>小D，财运滚滚！</code>。</p>
<h3 data-id="heading-2"><strong>UnaryOperator 的 Lambda 表达式示例</strong></h3>
<p>使用 Java 的 Lambda 表达式可以简化代码，不再需要创建完整的类。通过 Lambda 表达式，我们可以直接实现 <strong>UnaryOperator</strong> 接口：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUnaryOperatorImplLambda</span><span class="hljs-params">()</span> {
        UnaryOperator&lt;String&gt; extensionAdder = (String name) -&gt; { <span class="hljs-keyword">return</span> name+<span class="hljs-string">"，财运滚滚！"</span>;} ;
        <span class="hljs-type">String</span> <span class="hljs-variable">newText</span> <span class="hljs-operator">=</span> extensionAdder.apply(<span class="hljs-string">"小D1"</span>);
        <span class="hljs-comment">// 小D1，财运滚滚！</span>
        System.out.println(newText);
    }

</code></pre>
<p>Lambda 表达式使得代码更加简洁和紧凑，能够快速传达功能意图。</p>
<h3 data-id="heading-3"><strong>进一步简化 Lambda 表达式</strong></h3>
<p>你还可以进一步简化 Lambda 表达式，省略类型声明，使得代码更加简洁：</p>
<pre><code class="hljs language-java" lang="java">UnaryOperator&lt;String&gt; extensionAdder = text -&gt; text + <span class="hljs-string">".txt"</span>;
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUnaryOperatorImplLambda1</span><span class="hljs-params">()</span> {
        UnaryOperator&lt;String&gt; extensionAdder = (name)-&gt; name+<span class="hljs-string">"，财运滚滚！"</span> ;
        <span class="hljs-type">String</span> <span class="hljs-variable">newText</span> <span class="hljs-operator">=</span> extensionAdder.apply(<span class="hljs-string">"小D2"</span>);
        <span class="hljs-comment">// 小D2，财运滚滚！</span>
        System.out.println(newText);
    }
</code></pre>
<h3 data-id="heading-4"><strong>Java API 中 UnaryOperator 的应用</strong></h3>
<p><strong>UnaryOperator</strong> 接口在 Java API 中广泛应用。例如，它作为参数传递给 <strong>Stream</strong> 类的 <code>iterate</code> 方法。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">iterate</span><span class="hljs-params">(T seed, UnaryOperator&lt;T&gt; f)</span>;
</code></pre>
<p>这种方法签名可能对初学者来说比较陌生，但通过 <strong>UnaryOperator</strong> 的简单示例，我们可以清晰地理解：它只是接收并返回相同类型的数据。Lambda 表达式的引入，使得 Java 编程更简洁易读，也极大提高了开发效率。</p>
<h3 data-id="heading-5"><strong>总结</strong></h3>
<p>通过这个简单的示例，我们深入了解了 <strong>UnaryOperator</strong> 接口及其在 Java Lambda 表达式中的应用。作为一个功能强大的工具，它简化了 Java 编程的复杂性，使得代码更加简洁和易于维护。</p>
<hr/>
<p><strong>喜欢就奖励一个“👍”和“在看”呗~</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5097f5cd8ee944e4893201a7b6deaf68~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRGNz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763839275&amp;x-signature=7sqwJIDs3EuLkoLjDfBQIt0ezFo%3D" alt="image" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【底层机制】Ashmem匿名共享内存：原理与应用深度解析]]></title>    <link>https://juejin.cn/post/7573239644156067867</link>    <guid>https://juejin.cn/post/7573239644156067867</guid>    <pubDate>2025-11-17T08:47:12.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573239644156067867" data-draft-id="7573506713865977907" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【底层机制】Ashmem匿名共享内存：原理与应用深度解析"/> <meta itemprop="keywords" content="Android,面试"/> <meta itemprop="datePublished" content="2025-11-17T08:47:12.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="沐怡旸"/> <meta itemprop="url" content="https://juejin.cn/user/2875978146656750"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【底层机制】Ashmem匿名共享内存：原理与应用深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2875978146656750/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    沐怡旸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:47:12.000Z" title="Mon Nov 17 2025 08:47:12 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h4 data-id="heading-0"><strong>一、 核心概念：什么是Ashmem？</strong></h4>
<p>Ashmem，全称Android Shared Memory，是Android自定义的一套匿名共享内存机制。它的核心作用是：<strong>在进程间高效地共享一块匿名的内存区域</strong>。</p>
<p>我们可以从它的名字来分解理解：</p>
<ul>
<li><strong>匿名：</strong> 与传统Linux System V IPC的共享内存需要通过一个全局的<code>key</code>来标识不同，Ashmem不需要显式的名字。它通过文件描述符（File Descriptor）来引用，这使得其管理和权限控制更加灵活。</li>
<li><strong>共享：</strong> 多个进程可以将同一块物理内存映射到各自的进程虚拟地址空间，从而实现数据的共享，避免了数据的多次拷贝。</li>
<li><strong>内存：</strong> 它本质上是对一段内存区域的管理。</li>
</ul>
<h4 data-id="heading-1"><strong>二、 为什么需要Ashmem？对比传统方案的优劣</strong></h4>
<p>要理解Ashmem的价值，我们必须先看它解决了什么问题。</p>
<ol>
<li>
<p><strong>对比Linux System V SHM：</strong></p>
<ul>
<li><strong>资源泄露问题：</strong> System V SHM的<code>key</code>是全局的，如果进程崩溃后没有正确释放，这块共享内存会一直存在，导致资源泄露。Ashmem与进程的生命周期绑定更紧密，并且有回收机制。</li>
<li><strong>权限控制弱：</strong> System V SHM的权限控制比较简单。Ashmem基于文件描述符，可以继承Binder的权限模型，进行更精细的管控。</li>
<li><strong>pin / unpin机制：</strong> 这是Ashmem的核心创新，后面会详述。</li>
</ul>
</li>
<li>
<p><strong>对比Binder：</strong></p>
<ul>
<li><strong>Binder限制：</strong> Binder虽然强大，但其设计初衷是为了高频率、小数据量的进程间调用（RPC）。它对于传输数据有大小限制（通常约为1MB），并且数据需要经过多次序列化与反序列化，对于大块数据（如图片、大文件）效率低下。</li>
<li><strong>Ashmem的优势：</strong> Ashmem专为<strong>大块数据</strong>的共享而生。一旦内存映射建立，进程可以直接读写内存，几乎没有大小限制，性能极高。典型的应用场景就是传递Bitmap。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong> Ashmem是Android为弥补Binder在大数据传递上的短板，并改进传统共享内存缺陷而设计的“大块数据高速公路”。</p>
<h4 data-id="heading-2"><strong>三、 核心原理与工作机制</strong></h4>
<p>Ashmem的运作主要涉及三个核心环节：创建、映射和管理。</p>
<p><strong>1. 创建与获取文件描述符</strong></p>
<p>Ashmem的入口是<code>ashmem_create_region</code>函数（Native层）。这个函数会：</p>
<ul>
<li>在内核中开辟一块指定大小的匿名共享内存区域。</li>
<li>返回一个指向该内存区域的<strong>文件描述符（fd）</strong>。</li>
</ul>
<p>这个<code>fd</code>是整个Ashmem机制的核心。它本身只是一个数字，但进程可以通过它找到背后那块真正的物理内存。</p>
<p><strong>2. 内存映射</strong></p>
<p>单个进程拿到<code>fd</code>后，还需要通过<code>mmap</code>系统调用，将这块共享内存映射到自己的进程虚拟地址空间。这样，进程就可以像访问普通内存一样（通过指针）来读写这块共享内存了。</p>
<p>关键点在于：<strong>多个进程可以拿到同一个<code>fd</code>（或其副本），并各自执行<code>mmap</code>，最终它们的不同虚拟地址会指向同一块物理内存</strong>。这就是进程间共享的本质。</p>
<p><strong>3. pin / unpin 内存回收机制</strong></p>
<p>这是Ashmem最精妙的设计。它允许系统在内存紧张时，回收那些被进程标记为“未锁定”的内存页。</p>
<ul>
<li><strong>Pin：</strong> 进程通过<code>ioctl</code>接口告诉内核，某块内存区域目前正在被使用，不能被回收。这相当于给内存上了锁。</li>
<li><strong>Unpin：</strong> 进程告诉内核，某块内存区域已经使用完毕，如果系统内存不足，可以回收这部分内存。回收可能意味着将其换出到硬盘（如果支持），或者直接丢弃（如果是只读的脏页，可以从源文件恢复）。</li>
</ul>
<p><strong>工作流程示例：</strong>
假设进程A创建了一块Ashmem，并写入数据。</p>
<ol>
<li>进程A将数据写入后，调用unpin，表示“我的工作完成了，必要时你可以回收”。</li>
<li>进程B拿到<code>fd</code>，进行<code>mmap</code>并读取数据。在读取期间，进程B会调用pin锁定内存，防止被回收。</li>
<li>进程B读取完毕，调用unpin。</li>
<li>此时如果系统内存不足，内核就可以安全地回收这块内存，因为它被两个进程都标记为unpin状态。</li>
</ol>
<p>这个机制完美地解决了传统共享内存“一旦分配就常驻”的浪费问题，实现了按需内存管理。</p>
<h4 data-id="heading-3"><strong>四、 核心应用场景</strong></h4>
<p><strong>1. 跨进程传递大数据（尤其是Bitmap）</strong></p>
<p>这是Ashmem最经典的应用。当你在<code>Intent</code>中直接传递一个大的Bitmap对象时，Android系统底层会自动使用Ashmem来优化。</p>
<ul>
<li><strong>过程：</strong> 系统会将Bitmap的像素数据放入一块Ashmem区域，然后在进程间只传递这个Ashmem的<code>fd</code>。接收进程通过<code>fd</code>直接映射并读取像素数据。</li>
<li><strong>优势：</strong> 避免了将几MB的像素数据通过Binder进行拷贝，极大地提升了效率，并突破了Binder的大小限制。</li>
</ul>
<p><strong>2. 系统内部使用</strong></p>
<p>很多Android系统服务都重度依赖Ashmem：</p>
<ul>
<li><strong><code>OpenGL</code>、<code>SurfaceFlinger</code>：</strong> 用于图形缓冲区（<code>GraphicBuffer</code>）的共享。应用绘制的画面数据就存放在Ashmem中，供<code>SurfaceFlinger</code>合成最终图像。</li>
<li><strong><code>MediaServer</code>：</strong> 用于共享音视频数据流。</li>
</ul>
<p><strong>3. 进程间自定义大数据通信</strong></p>
<p>开发者也可以直接使用Ashmem API（主要通过<code>MemoryFile</code>这个Java封装类）来实现自定义的进程间大数据共享。</p>
<h4 data-id="heading-4"><strong>五、 开发者视角：如何使用Ashmem</strong></h4>
<p>对于应用开发者，最方便的接口是<code>android.os.MemoryFile</code>。</p>
<p><strong>创建并提供MemoryFile的示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 服务端：创建并准备数据</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> {
    <span class="hljs-keyword">private</span> ParcelFileDescriptor mPfd;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 1. 创建MemoryFile， 大小为 1MB</span>
            <span class="hljs-type">MemoryFile</span> <span class="hljs-variable">memoryFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemoryFile</span>(<span class="hljs-string">"my_shmem"</span>, <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);
            <span class="hljs-comment">// 2. 写入数据</span>
            <span class="hljs-type">byte</span>[] data = <span class="hljs-string">"Hello from Server!"</span>.getBytes();
            memoryFile.writeBytes(data, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.length);
            
            <span class="hljs-comment">// 3. 关键：获取其ParcelFileDescriptor，以便通过Binder传递</span>
            <span class="hljs-type">Method</span> <span class="hljs-variable">getFileDescriptor</span> <span class="hljs-operator">=</span> MemoryFile.class.getDeclaredMethod(<span class="hljs-string">"getFileDescriptor"</span>);
            <span class="hljs-type">FileDescriptor</span> <span class="hljs-variable">fd</span> <span class="hljs-operator">=</span> (FileDescriptor) getFileDescriptor.invoke(memoryFile);
            mPfd = ParcelFileDescriptor.dup(fd); <span class="hljs-comment">// 复制一份fd</span>

            <span class="hljs-comment">// 4. 通过Binder将mPfd传递给客户端</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IMyAidlInterface</span>.Stub() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> ParcelFileDescriptor <span class="hljs-title function_">getSharedMemoryFd</span><span class="hljs-params">()</span> {
                    <span class="hljs-keyword">return</span> mPfd;
                }
            };
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
}
</code></pre>
<p><strong>客户端接收并读取的示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 客户端：通过AIDL接口获取ParcelFileDescriptor并读取</span>
<span class="hljs-type">IMyAidlInterface</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> ...; <span class="hljs-comment">// 从onServiceConnected获取</span>
<span class="hljs-type">ParcelFileDescriptor</span> <span class="hljs-variable">pfd</span> <span class="hljs-operator">=</span> service.getSharedMemoryFd();
<span class="hljs-keyword">if</span> (pfd != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">try</span> {
        <span class="hljs-type">FileDescriptor</span> <span class="hljs-variable">fd</span> <span class="hljs-operator">=</span> pfd.getFileDescriptor();
        <span class="hljs-comment">// 1. 将fd包装成FileInputStream（或者直接使用JNI的mmap）</span>
        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fd);
        <span class="hljs-comment">// 2. 读取数据</span>
        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];
        <span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> inputStream.read(buffer);
        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, <span class="hljs-number">0</span>, bytesRead);
        Log.d(<span class="hljs-string">"Client"</span>, <span class="hljs-string">"Received: "</span> + message);
        
        inputStream.close();
    } <span class="hljs-keyword">catch</span> (IOException e) {
        e.printStackTrace();
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">try</span> {
            pfd.close();
        } <span class="hljs-keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>注意事项：</strong></p>
<ul>
<li><code>MemoryFile.getFileDescriptor()</code>是一个<code>@hide</code>方法，上述示例使用了反射，在生产环境中需要考虑兼容性或寻找其他方式。</li>
<li>核心在于<code>ParcelFileDescriptor</code>可以通过Binder传递。</li>
</ul>
<h4 data-id="heading-5"><strong>六、 总结与启示</strong></h4>
<ul>
<li><strong>Ashmem是Android高效内存管理的基石之一</strong>，它通过文件描述符和pin/unpin机制，实现了高性能、可回收的进程间大内存共享。</li>
<li>它在图形系统、多媒体等性能关键路径上扮演着不可替代的角色。</li>
<li>对于普通开发者，理解其原理有助于我们明白系统底层（如Bitmap传输）是如何工作的。在特定场景下（如需要自己实现跨进程大数据传输），直接使用<code>MemoryFile</code>或Native API是一个高效的解决方案。</li>
</ul>
<p>通过这篇解析，希望你能理解Ashmem在Android生态系统中的地位和价值，并能在实际开发中更好地利用或规避相关技术点。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[搞不懂作用域链？这篇文章让你一眼秒懂！]]></title>    <link>https://juejin.cn/post/7573241978902560783</link>    <guid>https://juejin.cn/post/7573241978902560783</guid>    <pubDate>2025-11-17T08:39:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573241978902560783" data-draft-id="7572524368875126819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="搞不懂作用域链？这篇文章让你一眼秒懂！"/> <meta itemprop="keywords" content="JavaScript,面试"/> <meta itemprop="datePublished" content="2025-11-17T08:39:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="soda_yo"/> <meta itemprop="url" content="https://juejin.cn/user/3270387091383163"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            搞不懂作用域链？这篇文章让你一眼秒懂！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3270387091383163/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    soda_yo
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:39:33.000Z" title="Mon Nov 17 2025 08:39:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>新手哈基米搞不懂什么是作用域链？深入了解JS代码的执行过程让你秒懂作用域链！</p>
<h2 data-id="heading-1">经典案例</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">'南北绿豆'</span>
    <span class="hljs-title function_">fn</span>()
}
<span class="hljs-keyword">var</span> myName = <span class="hljs-string">'哈基米'</span>
<span class="hljs-title function_">fn2</span>()
</code></pre>
<ul>
<li>究竟是会出现"哈基米",还是"南北绿豆"呢？诶，先不要着急哈气。想要真正弄清输出结果是"哈基米"还是"南北绿豆"。我们先要深入理解一下这段js代码究竟是怎样的一个执行过程。</li>
</ul>
<h2 data-id="heading-2">作用域与它的动态载体</h2>
<h3 data-id="heading-3">作用域</h3>
<ul>
<li>在程序中定义变量的区域，该位置决定了变量的生命周期。通俗来讲，作用域就是变量和函数的可访问范围</li>
</ul>
<h3 data-id="heading-4">函数执行上下文 : 函数作用域的动态载体</h3>
<ol>
<li>什么是函数执行上下文？
<ul>
<li>当一个函数被调用时，js引擎会先创建一个对应的“函数执行上下文”对象，并将函数中声明的变量与函数都存在其中。供函数执行时使用，由此才实现了函数作用域的概念。</li>
</ul>
</li>
<li>其主要组成部分：
<ul>
<li>变量环境：保存使用var关键字声明的对象和函数内部声明的子函数，由此实现常见的“函数作用域”。</li>
<li>词法环境：保存使用let关键字声明的对象，主要用于实现“块级作用域”的功能，非本文重点，不做详细描述。</li>
</ul>
</li>
<li>例子：</li>
</ol>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">'南北绿豆'</span>
    <span class="hljs-title function_">fn</span>()
}
</code></pre>
<p>图片的抽象表达：js引擎会为本函数创建一个函数上下文</p>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cdcc28cc26114fc0ad66c6318156df3d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=hwoF71y8tSAxALF1lkMbk9bJ%2B3A%3D" alt="75EE8152-FE72-438e-A284-A224F6A6E135.png" width="70%" loading="lazy"/>
<ol start="4">
<li>新手可能都会有个疑问？
<ul>
<li>为什么fn函数没有存在这个函数执行上下文当中呢？
<ul>
<li>欸，这就告诉你fn函数的声明被存在哪里。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 data-id="heading-5">全局执行上下文：全局作用域的动态载体</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">'南北绿豆'</span>
    <span class="hljs-title function_">fn</span>()
}
<span class="hljs-keyword">var</span> myName = <span class="hljs-string">'哈基米'</span>
<span class="hljs-title function_">fn2</span>()
</code></pre>
<ol>
<li>全局执行上下文与函数执行上下文类似</li>
</ol>
<ul>
<li>
<p>由这份代码可知，在该js文件的全局下，声明了两个函数：fn与fn2，声明了一个变量： myName。</p>
</li>
<li>
<p>所以js引擎同样会为其创建一个“全局执行上下文供全局参考，由此形成全局作用域。</p>
</li>
</ul>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5541e3a683b54beea6c49a6868512f22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=vD4lkRdalQB24TuMYC3xgqRVnrU%3D" alt="461C8CE8-56E8-431a-80AB-0A5FD7C8D366.png" width="70%" loading="lazy"/>
<h3 data-id="heading-6">待解决的疑问</h3>
<ul>
<li>光靠这些我们还无法得知fn2是如何调用到fn函数的，所以我们还得了解这两个执行上下文的出现顺序，以及js引擎是如何对他们进行处理，才能够正常的执行代码。所以我们的新朋友“调用栈”便可以登场了。</li>
</ul>
<h2 data-id="heading-7">js引擎的好兄弟：调用栈</h2>
<ul>
<li>帮助js引擎控制代码执行顺序的“无形态大手”</li>
</ul>
<h3 data-id="heading-8">什么是调用栈？</h3>
<ul>
<li>后进先出：它与我们所知的“栈”这一数据结构一样，有着“后进先出”（LIFO）的特点。</li>
<li>“函数执行上下文生命周期”的管理者：js引擎通过调用栈间接控制“函数执行上下文的生命周期”来管理“函数的执行顺序”，由此直接决定代码的执行流程。
<ul>
<li>具体过程是： 每当一个函数被调用时，js引擎会为其创建一个“函数执行上下文”，然后将该“函数执行上下文”压入栈顶，js引擎就会开始执行处于栈顶的函数，当函数执行完毕，便会让栈顶元素出栈。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-9">函数执行上下文被压入栈的过程</h3>
<ul>
<li>全局被编译时，js引擎创建全局执行上下文并将其压入调用栈，然后开始执行全局沿着全局一行一行往下执行。</li>
</ul>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/358b3cf9cdef45f59bd2289aae100160~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=TreJroaU7Ha4%2BepljARmCDIjgog%3D" alt="845D93CB-BD81-438d-A3B5-9D490ADB5C7A.png" width="50%" loading="lazy"/>
<ul>
<li>当准备执行fn2（）时，js引擎会在全局执行上下文中寻找fn2（）的定义，发现其存在。js引擎对其进行编译并创建对应函数执行上下文并将其压入调用栈，然后开始执行函数fn2，一行一行往下执行。</li>
</ul>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/02e9da1731114f0aa29a92bb1036bbbf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=fxnyu1jr4cnaHIKWdbwyGcU0P08%3D" alt="C06E8B4E-D793-49e6-9A11-21AEFA2F357C.png" width="50%" loading="lazy"/>
<ul>
<li>当准备执行fn（）时，js引擎会在fn2函数执行上下文中寻找fn（）的定义，未发现定义，于是继续向全局执行上下文中寻找fn（）的定义。发现fn（）定义，js引擎对其进行编译并创建对应函数执行上下文压入调用栈，然后开始执行fn，一行一行往下执行。</li>
</ul>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/966cd531e81740eea28e8aca67b5645a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=%2ByNFrpf7Oeck93JwTW%2BWAjSm3YY%3D" alt="9C03BEC2-0DD7-4b97-A119-037D2BC2A8C7.png" width="50%" loading="lazy"/>
<h3 data-id="heading-10">消失的“南北绿豆”：交流的失败？</h3>
<p>js引擎对变量与函数的寻找过程难道真的只是“由内向外寻找”？如果是这样输出的结果应该是“南北绿豆”才对。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e3b7cfac2e44af2903c235390a8383c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=IVZYRXakE%2BaKvhNOGc%2FpILajpL0%3D" alt="951C6781-E75B-4942-BB5D-BBEE88EA7C0E.png" loading="lazy"/></p>
<p>怎么是哈基米？</p>
<h2 data-id="heading-11">作用域链：作用域之间以outer指针为链接，形成的单向链表</h2>
<h3 data-id="heading-12">outer指针：函数执行上文间的链接者,向外寻找的罪魁祸首</h3>
<ul>
<li>outer指针：当一个函数执行上文被创建时，其内部存在一个指针outer指向该函数被定义时所在的词法作用域</li>
<li>词法作用域：一个函数被编译时一定会用一个outer指针记录该执行上下文（作用域）的外层（作用域）是谁。</li>
</ul>

<ul>
<li>例子：</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> num=<span class="hljs-number">0</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"/>)
{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);
}
<span class="hljs-title function_">fn1</span>()
</code></pre>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fdda3bbc54c84ba59cd73ab61f1df32d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=bwYsk0FbZFIt2mhId32V82tYZbM%3D" alt="9E981168-8FAF-4a64-AB56-40E2074FAC46.png" width="70%" loading="lazy"/> 
<p>由此形成了一个最简单的作用域链</p>
<ul>
<li>当执行函数内部时，在函数执行上文内部无法找到num的声明，js引擎便会沿着outer指针指向的全局执行上下文，寻找num的声明</li>
<li>全局执行上文中存在num的声明，且num为1</li>
<li>于是程序执行输出为1</li>
</ul>
<h3 data-id="heading-13">作用域链：作用域之间以outer指针为链接，形成的单向链表</h3>
<ul>
<li>由上述逻辑不断推导，最开始的“南北绿豆”消失之迷便迎刃而解了。</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">'南北绿豆'</span>
    <span class="hljs-title function_">fn</span>()
}
<span class="hljs-keyword">var</span> myName = <span class="hljs-string">'哈基米'</span>
<span class="hljs-title function_">fn2</span>()
</code></pre>
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b6b287f23fbc41f5a6620ac4e81b2ad3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc29kYV95bw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763973573&amp;x-signature=qvajKXFUHrK1c8q5Wtg3O3WLFng%3D" alt="882B21C2-CB2A-4e9b-8527-4C939FA5927E.png" width="70%" loading="lazy"/>
<h3 data-id="heading-14">执行fn（）函数时，寻找myName的定义的过程：</h3>
<ul>
<li>第一步：在fn函数执行上文中寻找，未查找到。</li>
<li>第二部：沿着outer指针指向查找上一级，在全局执行上下文中寻找到myName=“哈基米”</li>
<li>输出哈基米</li>
<li>由此我们发现：作用域链的形成与函数调用的过程无关。</li>
<li>作用域链的形成：依赖outer指针的指向。</li>
</ul>
<h2 data-id="heading-15">总结</h2>
<ol>
<li>作用域： 在程序中定义变量的区域，该位置决定了变量的生命周期。通俗来讲，作用域就是变量和函数的可访问范围</li>
<li>调用栈：LIFO（后进先出）的执行上下文栈，用于管理函数调用顺序</li>
<li>执行上下文：作用域的动态载体，存储变量的具体环境</li>
<li>outer指针：每一个函数内部都会存在一个指针outer，指向该函数的外层作用域（其所在的词法作用域）</li>
<li>词法作用域：函数或者变量被定义时的代码嵌套位置</li>
<li>作用域链：作用域之间以outer指针为链接，形成的单向链表</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[大模型成本太高？阿里云Serverless AI原生架构，教你极致省钱又稳健部署！]]></title>    <link>https://juejin.cn/post/7573225720698339380</link>    <guid>https://juejin.cn/post/7573225720698339380</guid>    <pubDate>2025-11-17T08:54:25.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720698339380" data-draft-id="7572010680896176168" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="大模型成本太高？阿里云Serverless AI原生架构，教你极致省钱又稳健部署！"/> <meta itemprop="keywords" content="Serverless"/> <meta itemprop="datePublished" content="2025-11-17T08:54:25.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            大模型成本太高？阿里云Serverless AI原生架构，教你极致省钱又稳健部署！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:54:25.000Z" title="Mon Nov 17 2025 08:54:25 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：赵世振</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd49fd38d1b04d2da2cb476e52a16258~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=LruOxfCVqSnGg4EmRl7LLXiAokk%3D" alt="image.png" loading="lazy"/></p>
<p><em>本文整理自 2025 云栖大会，阿里云智能集团产品架构师</em> <em><strong>赵世振</strong></em> <em>的主题演讲《Serverless AI 原生应用架构》</em></p>
<p>在 AI 大模型浪潮席卷全球的今天，企业纷纷加速拥抱 AI，推动智能客服、内容生成、流程自动化等场景快速落地。然而，许多企业在实践中却遭遇了“三高困境”——<strong>成本高、复杂度高、风险高</strong>。</p>
<p>一位互联网公司 CTO 曾坦言：“智能客服流量暴增，模型服务很容易被打挂，紧急手动扩容后，GPU 闲置率高达 90%，月底账单翻倍，还有数据泄漏风险。”</p>
<p>这并非个例——大量企业仍在用“传统架构”承载“新型 AI 业务”，要让 AI 业务简单、稳定、安全落地，我们必须从基础设施到业务接入层，进行一场 <strong>AI 原生的架构重塑</strong>。</p>
<h2 data-id="heading-0">架构变革的底层逻辑</h2>
<p>过去十余年间，应用架构持续演进：从单体架构到垂直拆分，历经 SOA、微服务，走向云原生，直至今日的 AI 原生架构。这一进程的本质，是<strong>业务逻辑不断解耦、分布化与智能化的过程</strong>，旨在实现更快速的业务响应、更灵活的协同能力。</p>
<p>与此同时，底层基础设施也同步进化——从物理机、虚拟机到容器、Kubernetes，再到 Serverless，如今迈向 Serverless AI 的新阶段。其核心在于<strong>对资源与能力的极致抽象</strong>，实现按需弹性、自动伸缩，让计算如同水电一般随取随用、高效便捷。</p>
<p>两条演进主线共同揭示了一个清晰的趋势：未来的技术重心将愈发聚焦于业务逻辑本身的创新与实现，而基础设施则趋于全面抽象化、自动化和智能化。开发者无需再过多关注底层运维细节，而是可以专注于创造更高价值的业务场景。这不仅是技术的跃迁，更是生产力的一次深刻变革。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cbe8ddfc320d486d85e28355da12993a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=AgSyJH%2BWQI38h5h5QccW31ZqzOI%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-1">AI 原生应用架构的三大核心需求</h2>
<p>通过与 300 余家企业的深度交流，AI 原生应用架构的核心需求可归纳为<strong>高模型算力</strong>、<strong>高可用性</strong>及<strong>严格安全管控</strong>三大维度：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/259ed5f1e65a4c249541b5bba4d73d60~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=myzycWolUlgi46Wd8hJhREMbWLk%3D" alt="图片" loading="lazy"/></p>
<p><strong>1. 算力需求</strong></p>
<ul>
<li><strong>成本优化：</strong> GPU 算力成本是 CPU 的数倍，且供应波动大。需提供灵活的卡型选择（如 N 分之一卡）、按需付费模式及预留闲置资源策略，以平衡成本与性能。</li>
<li><strong>稳定性保障：</strong> 通过多可用区部署与动态资源调度，确保模型调用的持续性与资源利用率最大化。</li>
</ul>
<p><strong>2. 高可用性需求</strong></p>
<ul>
<li><strong>全链路容灾：</strong> 支持多可用区部署，避免单点故障；</li>
<li><strong>限流与 fallback 机制：</strong> 突发流量时自动限流，模型服务异常时无缝切换至备用模型，保障业务连续性。</li>
</ul>
<p><strong>3. 安全管控需求</strong></p>
<ul>
<li><strong>输入输出合规性：</strong> 模型输入输出均设内容安全防护，过滤违规内容、敏感信息等；</li>
<li><strong>消费者鉴权：</strong> 不同团队或不同用户请求带有不同的鉴权凭证，权限最小化；</li>
<li><strong>全链路监控：</strong> 实现从网关到算力的全链路可观测体系；</li>
</ul>
<p>总结来说，AI 原生应用架构需要的是：<strong>简单易用的开发体验、生产级的性能、稳定性和安全保障。</strong></p>
<h2 data-id="heading-2">Serverless AI 原生架构的全栈能力支撑</h2>
<p>为满足上述需求，Serverless AI 原生应用架构应运而生。在该架构中，模型可通过 Serverless GPU（即函数计算 FC）进行部署，与 Agent 相关的 Sandbox、MCP Server、E2B 等服务也可托管于 FC。AI 网关作为模型与 MCP 服务的代理层，提供限流、鉴权、可观测性与安全护栏等功能。AI Agent 的开发支持低代码、零代码及高代码方式，可部署于 FC 或 SAE。Agent 前端通过网关进行代理，全链路配备 AI 应用观测能力，实现端到端可观测。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/286004560bb74cd6993c7024af971c4d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=LAlZibIcB2x9%2FFDoTfesWjyKUAk%3D" alt="图片" loading="lazy"/></p>
<p>该架构具备以下特点：</p>
<h3 data-id="heading-3">特征一：全栈 Serverless，极致简化运维</h3>
<p>整个架构中，函数计算 FC、SAE（Serverless应用引擎）、MSE Nacos、RocketMQ、AI 网关等关键组件均为 Serverless 形态或具备 Serverless 特性。无需管理底层服务器，自动扩缩容真正做到“一键部署、开箱即用”。</p>
<h3 data-id="heading-4">特征二：全链路高可用，保障业务连续性</h3>
<p>架构中的每一个产品节点均支持多可用区部署，具备跨区域容灾能力。特别是函数计算 FC 提供的 Serverless GPU 实例，已实现三可用区冗余部署，并配备实例级健康检查与自动恢复机制，极大提升了模型服务的稳定性。</p>
<p>此外，AI 网关内置 Fallback 机制，在主模型不可用时可自动切换至备用模型，确保关键业务不中断。</p>
<h3 data-id="heading-5">特征三：双层安全保障，构筑可信 AI 防线</h3>
<p>安全贯穿整个调用链路：</p>
<ul>
<li><strong>运行时安全</strong>：FC 和 SAE 采用实例隔离机制，防止租户间干扰；</li>
<li><strong>调用层安全</strong>：AI 网关提供消费者鉴权、API Key 管理、内容审核等功能，有效防范未授权访问与恶意攻击。</li>
</ul>
<h3 data-id="heading-6">特征四：简单易用，加速 AI 创新落地</h3>
<p>所有产品都是云上托管，一键部署启动，常见模型与 MCP 服务已封装为模板，可在 <strong>FunctionAI 平台一键部署</strong>，不管你是零代码用户、低代码开发者，还是资深工程师，都能找到适合你的入口。</p>
<h2 data-id="heading-7">Serverless AI 架构的核心组件</h2>
<h3 data-id="heading-8">函数计算 FC：定义 Serverless 终极形态</h3>
<p>定位为弹性经济的全托管 Serverless 计算服务，专用于部署大模型与 MCP 工具：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb7e9a2d750c475aa4a1bd43c20f4de4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=qAJIv2A%2FhJh0YlehUjpPcT7MlHk%3D" alt="图片" loading="lazy"/></p>
<ul>
<li><strong>经济降本</strong>：支持卡切分（1/N GPU）、阶梯定价、常驻实例等策略，整体 GPU 利用率超 50%，成本更低。</li>
<li><strong>极致弹性</strong>：<strong>GPU 实例启动快（毫秒级/秒级）</strong> ，通过<strong>请求感知调度显著降低 RT 抖动，</strong> 支持定时/水位伸缩、延迟释放、会话亲和。</li>
<li><strong>开发框架集成</strong>：内置 MCP Server、Sandbox 等服务运行时，支持模型微调镜像一键部署；  </li>
<li><strong>运维能力</strong>：提供镜像加速、资源调度、请求级监控日志，实现零运维体验。</li>
</ul>
<h3 data-id="heading-9">AI 网关：企业级 AI 流量中枢</h3>
<p>作为<strong>模型、MCP、Agent 的统一接入入口</strong>，承担安全、治理与调度职责：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5be4c0ead99e4d3b909484dd08900a06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974465&amp;x-signature=f1%2FUq1Ri4N8nUDftJQmEiCo9w1k%3D" alt="图片" loading="lazy"/></p>
<ul>
<li><strong>统一代理</strong>：支持多模型路由、MCP 协议适配、Agent API 封装，简化调用复杂度；</li>
<li><strong>安全鉴权</strong>：集中管理 API-KEY，支持二次分发与消费者身份验证，设置 AI 安全护栏防范恶意输入与输出；</li>
<li><strong>高可用保障</strong>：多可用区部署 + fallback 机制，异常时自动切换备用模型，支持精细化限流，保障核心业务稳定性； </li>
<li><strong>成本优化</strong>：内置 AI 缓存减少算力资源消耗，结合观测能力实现 Token 级成本监控；</li>
<li><strong>灵活扩展</strong>：支持动态组装 MCP 新工具链，快速接入外部 AI 服务。</li>
</ul>
<h2 data-id="heading-10">总结展望</h2>
<p>Serverless AI 原生架构不仅是技术演进，更是企业智能化转型的关键基础设施。它让开发者聚焦业务逻辑，让企业告别“基建焦虑”，让 AI 真正“飞入寻常百姓家”。</p>
<p>正如本次演讲尾声所说：“<strong>让架构为业务赋能，让 AI 为世界创造更多可能。</strong> ”</p>
<p>阿里云将持续投入 Serverless 与 AI 原生架构研发，携手更多行业伙伴，共同构建开放、智能、安全的新一代 AI 应用生态。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Claude Code 是如何构建的]]></title>    <link>https://juejin.cn/post/7573225720698322996</link>    <guid>https://juejin.cn/post/7573225720698322996</guid>    <pubDate>2025-11-17T08:53:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720698322996" data-draft-id="7573273271798972456" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Claude Code 是如何构建的"/> <meta itemprop="keywords" content="Claude"/> <meta itemprop="datePublished" content="2025-11-17T08:53:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="是魔丸啊"/> <meta itemprop="url" content="https://juejin.cn/user/3217622495411292"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Claude Code 是如何构建的
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3217622495411292/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    是魔丸啊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T08:53:53.000Z" title="Mon Nov 17 2025 08:53:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fnewsletter.pragmaticengineer.com%2Fp%2Fhow-claude-code-is-built" target="_blank" title="https://newsletter.pragmaticengineer.com/p/how-claude-code-is-built" ref="nofollow noopener noreferrer">转载</a></p>
<p><strong>作者：</strong> Gergely Orosz
<strong>发布日期：</strong> 2025年9月24日
<strong>来源：</strong> The Pragmatic Engineer</p>
<hr/>
<h2 data-id="heading-0">概述</h2>
<p>Claude Code 自今年 5 月正式发布以来，在开发者世界中掀起了风暴。该工具目前年化收入超过 5 亿美元，自 5 月发布以来的三个月内，使用量增长了超过 10 倍。</p>
<p>我最近与 Claude Code 的两位创始工程师进行了深入交流：Boris Cherny（提出原始原型想法的项目创始工程师）和 Sid Bidasaria（Claude Code 的第 2 号工程师，subagents 功能的创建者），以及创始产品经理 Cat Wu。</p>
<p>我了解了 Claude Code 是如何构建的，并深入了解了成功的"AI 优先工程团队"是如何运作的。这有点像窥探水晶球，看到了快速发展的初创公司未来的运作方式。好消息是，软件工程师在这个未来中仍然非常有需求……</p>
<h2 data-id="heading-1">本文涵盖内容</h2>
<ol>
<li>
<p><strong>一切是如何开始的</strong> - Claude Code 的想法来源于一个使用 Claude 来告知工程师工作时正在听什么音乐的命令行工具。在获得文件系统访问权限后，它在 Anthropic 内部像野火一样传播开来。如今，Claude Code 已拥有自己成熟的团队。</p>
</li>
<li>
<p><strong>技术栈和架构</strong> - TypeScript、React、Ink、Yoga 和 Bun。技术栈的选择是为了"分布内"并发挥模型的优势。有趣的事实：Claude Code 中 90% 的代码是由其自身编写的！</p>
</li>
<li>
<p><strong>以天而不是周为单位构建和发布功能</strong> - 团队以极快的速度工作，每个工程师每天大约发布 5 个版本。原型制作速度惊人：我们为一个新功能制作了 10 多个实际原型。看起来 AI agents 确实加速了迭代过程。</p>
</li>
<li>
<p><strong>重新设计终端用户体验</strong> - Claude Code 为终端用户体验带来了许多创新功能，这些功能在我们能够与 LLM 驱动的终端交互之前是不需要的。让我们来看看其中的一些。</p>
</li>
<li>
<p><strong>"AI 优先"软件工程是什么样的</strong> - 使用 AI agents 进行代码审查和测试、测试驱动开发（TDD）的复兴、自动化事件响应，以及谨慎使用功能标志。这是否预示着未来"AI 优先"工程团队的工作方式？</p>
</li>
<li>
<p><strong>构建子代理</strong> - 深入了解 subagents 功能是如何在短短三天内构建完成的，其中两天的工作被废弃。</p>
</li>
<li>
<p><strong>AI 辅助工程团队的未来？</strong> - 工程团队可以从 Anthropic 的运作中学到什么，以及需要记住哪些使其独特但可能不太容易转移的东西。</p>
</li>
</ol>
<hr/>
<h2 data-id="heading-2">1. 一切是如何开始的</h2>
<p>Boris Cherny 于 2024 年 9 月加入 Anthropic，并开始使用 Claude 3.6 模型构建一系列不同的原型。当时，他想更熟悉 Anthropic 的公共 API。Boris 回忆道：</p>
<p>"我开始在终端中使用 Claude 进行实验。第一个版本非常简陋：它无法读取文件，无法使用 bash，完全不能做任何工程相关的事情。但它可以与计算机交互。</p>
<p>我将这个原型连接到 AppleScript：它可以告诉我工作时正在听什么音乐。然后它还可以根据我的输入更改正在播放的音乐。</p>
<p>这是一个很酷的演示，但并不是很有趣。"</p>
<p>与此同时，Cat Wu 正在研究 AI agents 的计算机使用情况，以及 agents 使用它们时产生的新能力。在与 Cat 交谈后，Boris 有了给终端提供比仅使用 AppleScript 更多功能的想法。他说：</p>
<p>"我尝试给它一些与文件系统和批处理交互的工具；它可以读取文件、写入文件和运行批处理命令。</p>
<p>突然间，这个 agent 变得非常有趣。我在我们的代码库中运行它，并开始询问相关问题。Claude 然后开始探索文件系统并读取文件。它会读取一个文件，查看导入，然后读取导入中定义的文件！它一直继续，直到找到好的答案。Claude 探索文件系统对我来说是惊人的，因为我从未使用过这样的工具。</p>
<p>在 AI 中，我们谈论"产品过载"，这就是我们在原型中发现的。产品过载意味着模型能够做特定的事情，但 AI 运行其中的产品并没有以能够捕捉这种能力的方式构建。我发现 Claude 探索文件系统是纯粹的产品过载。模型已经能够做到这一点，但没有围绕这个能力构建产品！"</p>
<h3 data-id="heading-3">产品市场匹配</h3>
<p>Boris 开始在工作中每天使用他的原型。然后他与将成为 Claude Code 核心团队的成员分享了它，其他开发人员也开始每天使用它。</p>
<p>Boris 和 Claude Code 团队在 2024 年 11 月发布了适合内部测试的版本——距离第一个原型两个月后。第一天，大约 20% 的工程团队使用了它，到第五天，50% 的工程师都在使用 Claude Code。那时，Boris 相当确信 Claude Code 在外部世界也会成为热门产品。</p>
<p>但对于是否要发布这个工具，还是仅供内部使用，内部存在争议。Boris 回忆道：</p>
<p>"我们实际上甚至不确定是否要公开发布 Claude Code，因为我们认为这可能成为我们的竞争优势，就像我们的'秘密武器'：如果它给我们带来优势，为什么要发布它？</p>
<p>最终，我们达成了以下立场：</p>
<ul>
<li>Anthropic 的核心是一家模型安全公司</li>
<li>我们了解模型安全和能力的方式是制作人们使用的工具</li>
<li>Claude Code 几乎肯定会成为人们使用的工具，因为整个 Anthropic 都对它上了瘾</li>
</ul>
<p>因此，通过发布这个工具，我们可以更多地了解模型安全性和能力。"</p>
<h3 data-id="heading-4">组建 Claude Code 工程团队</h3>
<p>最初，团队只有 Boris。2024 年 11 月，Sid Bidasaria 加入 Anthropic 并遇到了早期版本的 Claude Code。他喜欢这个想法并加入了 Boris 的项目。</p>
<p>他们的两人团队工作方式有很多自由度。Sid 告诉我：</p>
<p>"我们大部分工作都是非常快速地制作原型，并构建展示底层模型强大能力的产品。团队内部没有正式流程：一切都超级灵活。我们可以几乎随心所欲地工作，所以我们一直选择最有前景的想法。"</p>
<p>到 7 月，团队增长到约 10 名工程师，此后招聘一直在继续。如今，它是一个成熟的完整产品团队，包括工程师、产品管理、设计和数据科学人员——而且他们还在招聘。</p>
<h3 data-id="heading-5">Claude Code 不仅面向编码人员</h3>
<p>如今，超过 80% 编写代码的 Anthropic 工程师日常使用 Claude Code，但不仅仅是他们。Boris 说：</p>
<p>"我走进办公室时，瞥了一眼一位数据科学家的屏幕。他正在运行 Claude Code。我说：'等等，你为什么在运行 Claude Code？'他说：'我搞清楚了如何让这个东西为我写查询。'</p>
<p>这些天，当我走过数据科学家的一排时，他们都在运行 Claude Code——其中许多人同时运行多个实例——运行查询、创建可视化以及做其他类型的有帮助的工作。"</p>
<p>有趣的一点是，Boris 心中只想着为软件工程师设计 Claude Code——因此得名！但该产品表明它在其他领域也有进一步的实用性。</p>
<h3 data-id="heading-6">团队规模翻倍的同时提高工程产出</h3>
<p>如果我们以每个工程师的 pull requests 作为指标；当工程团队规模迅速翻倍时，这个过程通常会拉低这个指标。这是因为现有工程师花更多时间培训新同事，编码时间更少，而新加入者需要先熟悉情况。像任何指标一样，每个工程师的 pull requests（PR）不是完美的指标，但它确实给人一种迭代节奏的感觉。PR 吞吐量被 GitHub、Dropbox、Monzo、Adyen 等公司衡量。</p>
<p>但 Anthropic 在团队规模翻倍的同时看到了 67% 的 PR 吞吐量增长——这要归功于 Claude Code。平均 PR 合并指标下降本来是正常的，但实际上却上升了！这归功于 Claude Code：工程师们使用它能更快地完成 PR。在一系列可能幸运的事件中，Anthropic 在 Claude Code 被整个工程部门采用的大致时间将工程人员数量翻了一番。</p>
<p>我也注意到，使用 Claude Code 完成工作明显更快，而且我在编码任务上取得了更好的进展。当我构建 Claude Code 可以通过运行程序并检查输出来验证代码正确性的东西时，它也很有帮助。</p>
<hr/>
<h2 data-id="heading-7">2. 技术栈和架构</h2>
<h3 data-id="heading-8">Claude Code 的技术栈：</h3>
<ul>
<li><strong>TypeScript</strong> - Claude Code 建立在这种语言之上</li>
<li><strong>React with Ink</strong> - UI 使用 React 编写，使用 Ink 框架实现交互式命令行元素</li>
<li><strong>Yoga</strong> - 布局系统，由 Meta 开源。它是一个基于约束的布局系统，效果很好。基于终端的应用程序有需要支持所有终端尺寸的缺点，所以你需要一个布局系统来实用地做到这一点</li>
<li><strong>Bun</strong> - 用于构建和打包。团队选择它是为了与 Webpack、Vite 等其他构建系统相比的速度优势</li>
</ul>
<p>Ink 框架是一个出色的组件，允许在终端中创建美观的 UI。例如，要创建这个 UI</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/def96c4814fb46108be9c19a2fdf388c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=vfe1K60ReUkVyWe7E%2Bx%2BRnJPLt0%3D" alt="image.png" loading="lazy"/></p>
<p>你可以用 React 编写代码：</p>
<pre><code class="hljs language-ini" lang="ini">import React, { useState, useEffect } from 'react'<span class="hljs-comment">;</span>
import { render, Text } from 'ink'<span class="hljs-comment">;</span>

const <span class="hljs-attr">Counter</span> = () =&gt; {
  const <span class="hljs-section">[counter, setCounter]</span> = useState(0)<span class="hljs-comment">;</span>

  useEffect(() =&gt; {
    const <span class="hljs-attr">timer</span> = setInterval(() =&gt; {
      setCounter(<span class="hljs-attr">previousCounter</span> =&gt; previousCounter + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
    }, 100)<span class="hljs-comment">;</span>

    return () =&gt; {
      clearInterval(timer)<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>
  }, <span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>

  return &lt;Text <span class="hljs-attr">color</span>=<span class="hljs-string">"green"</span>&gt;{counter} tests passed&lt;/Text&gt;<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

render(&lt;Counter /&gt;)<span class="hljs-comment">;</span>
</code></pre>
<p>npm 用于分发 Claude Code。它是 Node 生态系统中最流行的包管理器。要开始使用 Claude Code，你需要安装 Node 18 或更高版本，然后运行：</p>
<pre><code class="hljs language-bash" lang="bash">npm install -g @anthropic-ai/claude-code
</code></pre>
<p>完成后，你可以使用 claude 命令启动工具。</p>
<h3 data-id="heading-9">技术栈选择：分布内</h3>
<p>技术栈的选择是为了 Claude 模型的"分布内"。在 AI 中，有"分布内"和"分布外"这两个术语。"分布内"意味着模型已经知道如何做，"分布外"意味着它不擅长。</p>
<p>团队希望为 Claude 选择一个它已经很擅长的"分布内"技术栈。TypeScript 和 React 是模型非常擅长的两种技术，因此是合理的选择。然而，如果团队选择了 Claude 不太擅长的更奇特的技术栈，那将是"分布外"技术栈。Boris 总结道：</p>
<p>"使用分布外技术栈，模型仍然可以学习。但你必须指导它并投入工作。我们想要一个不需要我们教的技术栈：一个 Claude Code 可以自我构建的技术栈。而且效果很好；Claude Code 中大约 90% 的代码是用 Claude Code 编写的。"</p>
<h3 data-id="heading-10">架构：选择最简单的选项</h3>
<p>有趣的是，就模块、组件和复杂的客户端业务逻辑而言，Claude Code 并没有那么多内容。对于一个执行诸如遍历文件系统和代码库等相当复杂任务的工具来说，这有点令人惊讶！但 Claude Code 只是 Claude 模型之上的一个轻量级外壳。这是因为模型完成了几乎所有的工作：</p>
<ul>
<li>定义 UI，并暴露钩子让模型修改它</li>
<li>暴露工具供模型使用</li>
<li>……然后让开道路</li>
</ul>
<p>Claude Code 团队尝试编写尽可能少的业务逻辑。Boris 告诉我：</p>
<p>"这听起来可能很奇怪，但我们构建这个东西的方式是希望人们尽可能原始地感受模型。我们相信模型可以做比今天产品允许的更多的事情。</p>
<p>当你看到很多编码产品时，它们阻碍了模型；它们通过添加 UI 元素和其他混乱的部分来添加脚手架，所以在这些工具中运行的模型感觉像是在单腿跳跳。旨在对用户有帮助的功能最终限制了模型。因此，我们尽量使 UI 尽可能最小。</p>
<p>每次有新模型发布时，我们都会删除一堆代码。例如，对于 4.0 模型，我们删除了大约一半的系统提示，因为我们不再需要它了。我们尽量在模型周围放置尽可能少的代码，这包括最小化提示和最小化工具数量。我们不断删除工具并试验新的工具。"</p>
<h3 data-id="heading-11">本地运行而非虚拟化</h3>
<p>Claude Code 不使用虚拟化——它在本地运行。一个主要的设计决定是是否在虚拟机中运行 Claude Code——比如在 Docker 容器中，或在云端——从而创建沙箱环境。但团队决定使用本地运行的版本，因为：简单！Boris 说：</p>
<p>"对于每个设计决定，我们几乎总是选择最简单的选项。对于"在哪里运行批处理命令？"和"从哪里读取文件系统？"这些问题的最简单答案是什么？就是在本地做。</p>
<p>所以我们选择了这样：Claude Code 在本地运行批处理命令，并读写文件系统。没有虚拟化。"</p>
<h3 data-id="heading-12">权限系统</h3>
<p>Claude Code 最复杂的部分是权限系统。在本地运行 Claude Code 的风险是 agent 可能会做它不应该做的不可逆转的事情，比如删除文件。但这如何安全地完成呢？</p>
<p>再次，团队选择了简单性，并构建了一个在执行操作之前寻求权限的权限系统。然后用户可以决定：</p>
<ul>
<li>授予权限一次</li>
<li>为未来的会话也授予权限</li>
<li>拒绝权限</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7842479649748f9b7fcf83ef00e735c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=1d4AvNnNZu8LRP4%2B2ph62HsE6Kk%3D" alt="image.png" loading="lazy"/></p>
<p>Boris 告诉我，正确处理权限需要努力：</p>
<p>"我们最重要的原则是：如果你开始运行 Claude Code，它不应该在没有权限的情况下更改你系统上的东西。这可能是危险的。</p>
<p>但是，我们也应该给人们提供选择退出的方式，比如说出诸如"实际上，在我工作的上下文中，我不想每次都给予权限"这样的话。</p>
<p>不过，权限系统中有很多细微差别。例如，当命令进来时，我们对其进行静态分析，以检查这是否是设置文件中（settings.json 文件中）已经允许的内容。</p>
<p>设置系统是一个多层系统，可以按项目、按用户和按公司进行配置。你还可以与团队共享设置。我们观察到团队共享设置文件，将命令列入白名单，这样 Claude Code 就不会请求权限，比如检查到源代码控制中。"</p>
<h3 data-id="heading-13">其他功能</h3>
<p>Claude Code 在某些方面很简单，但有很多功能增加了其复杂性。其中一些已被记录。值得注意的是：</p>
<ul>
<li><strong>Hooks</strong>：为 Claude Code 创建自定义 shell 命令</li>
<li><strong>MCP 支持</strong>：通过连接到 MCP 服务器给 Claude Code 更多功能。请参阅我们关于模型上下文协议（MCP）的深度解析</li>
<li><strong>GitHub 和 GitLab 支持</strong>：使用 GitHub Actions 并将 Claude Code 集成到 GitLab CI/CD 中</li>
<li><strong>输出样式</strong>：能够切换输出样式，或定义自己的样式。可以切换的内置输出样式包括：
<ul>
<li>解释性：向你解释实现选择</li>
<li>学习性：协作风格，Claude 要求你自己做小任务。这是一个非常聪明的方法来保持参与度、动手实践和学习！对于经验较少的工程师或那些不熟悉的人来说，这可能是一个很好的学习方式</li>
</ul>
</li>
<li><strong>配置</strong>：使用各种配置文件和设置来配置你的终端、模型、状态行等</li>
<li><strong>Subagents</strong>：下文将详细介绍</li>
<li><strong>企业功能</strong>：设置身份和访问管理（IAM）以在整个组织中使用 Claude Code，并访问组织范围的分析以跟踪使用情况</li>
<li><strong>Claude Code SDK</strong>：使用驱动 Claude Code 的 agent 构建自定义 AI agents</li>
<li>……以及 Claude Code 中最近新功能的汇总</li>
</ul>
<hr/>
<h2 data-id="heading-14">3. 以天而不是周为单位构建和发布功能</h2>
<p>对于一个大约十几名工程师的团队来说，他们工作得非常快：</p>
<ul>
<li>
<p><strong>每天约 60-100 次内部发布</strong> - 每当工程师对 Claude Code 进行更改时，他们会在内部发布一个新的 npm 包。Anthropic 的每个人都使用内部版本，开发团队会获得快速反馈。</p>
</li>
<li>
<p><strong>夏季期间，工程师每天推动大约 5 个 pull requests</strong> - 这比大多数科技公司每天 1-2 个 pull requests 的正常速度快得多。</p>
</li>
<li>
<p><strong>每天 1 次外部发布</strong> - 几乎每天都会发布新版本作为部署的一部分。</p>
</li>
</ul>
<h3 data-id="heading-15">2 天内 20 个原型：构建 todo 列表</h3>
<p>这种开发让我惊讶的是，团队比我所习惯的看到的多得多地使用 Claude Code 进行原型制作。例如，Boris 向我展示了他在两天内几个小时内为新功能 todo 列表制作了大约 20 个原型。</p>
<p>他慷慨地分享了他为各种迭代使用的实际提示。每次之后，Boris 会：</p>
<ul>
<li>有时调整结果</li>
<li>尝试使用它</li>
<li>如果感觉良好，与同事分享以获得反馈</li>
<li>当感觉不对时，他用新的提示构建一个新原型</li>
</ul>
<h4 data-id="heading-16">原型 #1：显示完成的 todos</h4>
<p>想法：todo 列表是跟踪 Claude 进展的最简单方法之一，所以他们尝试将列表放在最近一次工具调用的正下方。</p>
<p>提示：</p>
<pre><code class="hljs language-rust" lang="rust">&gt; make it so instead of todos showing up <span class="hljs-keyword">as</span> they come <span class="hljs-keyword">in</span>, we hide the tool <span class="hljs-keyword">use</span> and result <span class="hljs-keyword">for</span> <span class="hljs-title class_">todos</span>, and render a fixed todo list above the input. title it <span class="hljs-string">"/todo (1 of 3)"</span> <span class="hljs-keyword">in</span> grey
</code></pre>
<p>看起来如何：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd446a74ef134c81add0f8715565d73a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=Yfp5Q9XMwbP8wpS15NmkU78V7bA%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-17">原型 #2：在底部显示进度</h4>
<p>另一个变体是内联显示每个 todo 更新。</p>
<p>提示：</p>
<pre><code class="hljs language-vbnet" lang="vbnet">&gt; actually don<span class="hljs-comment">'t show a todo list at all, and instead render the tool used inline, as bold headings when the model starts working on a todo. keep the "step 2 of 4" or whatever, and add middot /todo to see after in grey</span>
</code></pre>
<p>看起来如何：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/65ad0b72603a4d7c9ea47ba67ec1969d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=mAUXZ0F4xCn0qKUXIbq%2BuT5V9qY%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-18">原型 #3 和 #4：交互式药丸</h4>
<p>如果 todos 是一个交互式药丸（控制台底部的一个矩形），你可以拉起来查看进度，就像后台任务一样？</p>
<p>提示和输出：</p>
<pre><code class="hljs language-css" lang="css">&gt; also add <span class="hljs-selector-tag">a</span> todo pill under the text <span class="hljs-selector-tag">input</span>, similar <span class="hljs-selector-tag">to</span> bg tasks. it should render "todos: <span class="hljs-number">1</span> of <span class="hljs-number">3</span><span class="hljs-string">" or whatever
</span></code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d87087494c94dc1aa39cdbf2e38d053~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=PnS2Hpr8xL%2FPV1rXfJckJNjvDk0%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #3</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_">&gt; </span><span class="bash">make the pill interactive, like the <span class="hljs-built_in">bg</span> tasks pill</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/98bb7b0b63124c769da05da5fa59156c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=2hu%2FFcABJSxwV05FBGTTDcO3i%2B4%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #4</p>
<h4 data-id="heading-19">原型 #5 和 #6：使用抽屉</h4>
<p>如果我们有一个'抽屉'可以滑入并在旁边显示 todos 怎么样？</p>
<p>提示和输出：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-operator">&gt;</span> actually undo <span class="hljs-keyword">both</span> the pill <span class="hljs-keyword">and</span> headings. instead, make the todo list render <span class="hljs-keyword">to</span> the <span class="hljs-keyword">right</span> <span class="hljs-keyword">of</span> the input, vertically centered <span class="hljs-keyword">with</span> a grey divider. <span class="hljs-keyword">show</span> it <span class="hljs-keyword">when</span> todos <span class="hljs-keyword">are</span> active, hide it <span class="hljs-keyword">when</span> it<span class="hljs-string">'s done
</span></code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b33d9b316994e6fadd2da2f3df33f63~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=ROprZ%2FFVcnyIqPZbB1R102OfKyc%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #5，todos 作为右侧的"抽屉"。参见动画版本</p>
<pre><code class="hljs language-vbnet" lang="vbnet">&gt; it<span class="hljs-comment">'s a little jumpy, can you also animate it like a drawer</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/91f30daeffe641918fa48d17b9dffac7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=539TtgAXALaVXOnnNfC7Op9FSyY%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #6。参见<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.threads.com%2F%40boris_cherny%2Fpost%2FDOJ7j1yEinY%3Fxmt%3DAQF0ng_THawLvtKm-2ybaug10RNNwXP8l8I2TfS20BW2Vg" target="_blank" title="https://www.threads.com/@boris_cherny/post/DOJ7j1yEinY?xmt=AQF0ng_THawLvtKm-2ybaug10RNNwXP8l8I2TfS20BW2Vg" ref="nofollow noopener noreferrer">动画版本</a></p>
<h4 data-id="heading-20">原型 #7、8 和 9：可见性实验</h4>
<p>为了使 todo 列表尽可能可见，Boris 尝试让它始终显示在输入上方。</p>
<p>提示和输出：</p>
<pre><code class="hljs language-css" lang="css">&gt; actually what if you show the todo list above the <span class="hljs-selector-tag">input</span> instead
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c6602360b6f4f4db46405dd99c44902~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=joiCBqCpOWp0oLmPkB7SU5Zj%2BfA%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #7</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_">&gt; </span><span class="bash"><span class="hljs-built_in">truncate</span> at 5 and show <span class="hljs-string">"... and 4 more"</span> or whatever</span>
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/908a75c22a9d4b7aa468dff622d948e7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=d0LCUFxGxOLdWMCPAtf0ZRAqOfk%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #8</p>
<pre><code class="hljs language-arduino" lang="arduino">&gt; add a heading <span class="hljs-string">"Todo:"</span> in grey text
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b275add6fc442d09ac7e9e820a7353f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=2xElmzWFteWa7eogF2BK2odwhMA%3D" alt="image.png" loading="lazy"/></p>
<p>原型 #9</p>
<h4 data-id="heading-21">原型 #10-20：移动加载动画 UI 元素</h4>
<p>Boris 继续尝试 todo 列表可见性应该放在哪里，经过几个更多的原型后，最终将 todo 列表移到了加载动画，最大化了可见性，并开始感觉良好。经过几次迭代后，他们有了最终公开发布的版本。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8995909d1c604807af8c0a435fcf0054~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=P9N2ZWMzZ62IpyMwSA%2F7UXyU2uU%3D" alt="image.png" loading="lazy"/></p>
<p>在大约原型 #20 时，在尝试了可见性和加载动画后</p>
<h4 data-id="heading-22">再一次迭代</h4>
<p>团队从社区收到了很多反馈，他们希望能够看到所有的 todos。所以团队添加了用 CTRL + T 切换它们的能力。这就是现在实时运行的功能！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d42db374414140a5af5554ad6fe1ea38~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5piv6a2U5Li45ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974433&amp;x-signature=8fjnf%2FwcecwWUSjMDkuIFeMNAqE%3D" alt="image.png" loading="lazy"/></p>
<p>这个迭代（大约 #21 左右）目前正在生产中——按 Tab 键切换正在执行的步骤列表</p>
<h3 data-id="heading-23">快速原型制作</h3>
<p>每天构建和测试 5-10 个原型想法是可能的，使用 AI agents。原型制作过去非常耗时，如果有两天时间进行原型制作，到结束时能构建两个不同的原型就很幸运了。但现在，agents 可以非常快地构建原型，所以每天测试 5-10 个原型很容易做到，就像 Claude Code 团队所做的那样。</p>
<p>我不建议每个人都能这么快地构建那么多原型，但我认为忘记原型制作过去需要多长时间是明智的：这些工具改变了原型制作可以多快！</p>
<p>这些原型制作中的很多都是关于让 UI"感觉良好"：你可以在这个线程中看到动画原型。我建议观看原型步骤的视频，以了解功能是如何演变的，以及 Boris 如何不断尝试新想法，将其缩小到今天工具中 todo 列表的样子。</p>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【穿越Effective C++】条款20：宁以pass-by-reference-to-const替换pass-by-value——参数传递的效率与语义]]></title>    <link>https://juejin.cn/post/7573506713866076211</link>    <guid>https://juejin.cn/post/7573506713866076211</guid>    <pubDate>2025-11-17T09:02:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573506713866076211" data-draft-id="7573310642960138278" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【穿越Effective C++】条款20：宁以pass-by-reference-to-const替换pass-by-value——参数传递的效率与语义"/> <meta itemprop="keywords" content="C++,面试"/> <meta itemprop="datePublished" content="2025-11-17T09:02:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="沐怡旸"/> <meta itemprop="url" content="https://juejin.cn/user/2875978146656750"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【穿越Effective C++】条款20：宁以pass-by-reference-to-const替换pass-by-value——参数传递的效率与语义
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2875978146656750/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    沐怡旸
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T09:02:20.000Z" title="Mon Nov 17 2025 09:02:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这个条款揭示了C++函数参数传递的核心优化策略：通过const引用传递可以避免不必要的对象拷贝，同时保持语义的正确性。这是构建高性能C++系统的关键技巧，需要在效率、安全性和表达力之间找到平衡。</p>
<hr/>
<h3 data-id="heading-0"><strong>思维导图：参数传递策略的完整体系</strong></h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cc2c977c9e2d4c8b8a2a1a3fd8758f89~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5rKQ5oCh5pe4:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763974940&amp;x-signature=%2B207QpdK5z2kWIuWcOGUy191Xjk%3D" alt="image.png" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-1"><strong>关键洞见与行动指南</strong></h3>
<h4 data-id="heading-2"><strong>必须遵守的核心原则：</strong></h4>
<ol>
<li><strong>默认使用const引用</strong>：对于非内置类型，优先使用const引用传递</li>
<li><strong>避免对象切片</strong>：多态基类必须使用引用或指针传递</li>
<li><strong>考虑移动语义</strong>：对于可移动类型，评估传值与移动的权衡</li>
<li><strong>测量性能影响</strong>：基于实际性能数据做出传递策略决策</li>
</ol>
<h4 data-id="heading-3"><strong>现代C++开发建议：</strong></h4>
<ol>
<li><strong>移动语义利用</strong>：对于资源管理类，考虑传值+移动的优化模式</li>
<li><strong>完美转发应用</strong>：模板函数中使用通用引用保持值类别</li>
<li><strong>概念约束使用</strong>：通过概念在编译期选择最优传递策略</li>
<li><strong>拷贝省略依赖</strong>：利用RVO/NRVO优化返回值传递</li>
</ol>
<h4 data-id="heading-4"><strong>设计原则总结：</strong></h4>
<ol>
<li><strong>零开销抽象</strong>：在不牺牲性能的前提下提供高级抽象</li>
<li><strong>语义正确性</strong>：传递方式不应改变程序的逻辑行为</li>
<li><strong>接口清晰性</strong>：参数传递意图应该在接口中明确表达</li>
<li><strong>实践导向</strong>：基于实际性能特征而非理论假设做决策</li>
</ol>
<h4 data-id="heading-5"><strong>需要警惕的陷阱：</strong></h4>
<ol>
<li><strong>悬空引用</strong>：确保引用参数的生命周期覆盖使用范围</li>
<li><strong>意外修改</strong>：正确使用const避免接口契约违反</li>
<li><strong>重载困惑</strong>：避免传值与传引用的重载产生歧义</li>
<li><strong>模板陷阱</strong>：注意模板推导中引用折叠的意外结果</li>
</ol>
<p><strong>最终建议：</strong> 将参数传递策略视为性能优化与代码清晰度的平衡艺术。培养"传递语义思维"——在设计每个函数接口时都思考："这个参数会被修改吗？拷贝成本有多高？需要保持多态吗？" 这种思考方式是构建高效且正确C++代码的关键。</p>
<p>记住：<strong>在C++参数传递中，const引用通常是安全与效率的最佳平衡点，但了解例外情况同样重要。</strong> 条款20教会我们的不仅是一种技术选择，更是对C++对象模型深刻理解的体现。</p>
<hr/>
<h3 data-id="heading-6"><strong>深入解析：参数传递的核心机制</strong></h3>
<h4 data-id="heading-7"><strong>1. 问题根源：传值的隐藏代价</strong></h4>
<p><strong>昂贵的拷贝构造示例：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpensiveToCopy</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ExpensiveToCopy</span>() {
        data_.<span class="hljs-built_in">resize</span>(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 分配大量内存</span>
        std::cout &lt;&lt; <span class="hljs-string">"默认构造"</span> &lt;&lt; std::endl;
    }
    
    <span class="hljs-built_in">ExpensiveToCopy</span>(<span class="hljs-type">const</span> ExpensiveToCopy&amp; other) 
        : <span class="hljs-built_in">data_</span>(other.data_) {
        std::cout &lt;&lt; <span class="hljs-string">"拷贝构造 - 成本高昂!"</span> &lt;&lt; std::endl;
    }
    
    ExpensiveToCopy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ExpensiveToCopy&amp; other) {
        data_ = other.data_;
        std::cout &lt;&lt; <span class="hljs-string">"拷贝赋值 - 成本高昂!"</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    
    ~<span class="hljs-built_in">ExpensiveToCopy</span>() {
        std::cout &lt;&lt; <span class="hljs-string">"析构"</span> &lt;&lt; std::endl;
    }
    
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;
};

<span class="hljs-comment">// 糟糕的传值方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processByValue</span><span class="hljs-params">(ExpensiveToCopy obj)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"processByValue处理中..."</span> &lt;&lt; std::endl;
    <span class="hljs-comment">// 使用obj...</span>
}

<span class="hljs-comment">// 优秀的const引用方式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> ExpensiveToCopy&amp; obj)</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"processByConstRef处理中..."</span> &lt;&lt; std::endl;
    <span class="hljs-comment">// 使用obj，但不能修改</span>
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_copy_cost</span><span class="hljs-params">()</span> </span>{
    ExpensiveToCopy expensive_obj;
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 传值调用 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processByValue</span>(expensive_obj);  <span class="hljs-comment">// 触发拷贝构造 + 析构</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== const引用调用 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processByConstRef</span>(expensive_obj);  <span class="hljs-comment">// 零拷贝！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 临时对象传值 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processByValue</span>(<span class="hljs-built_in">ExpensiveToCopy</span>());  <span class="hljs-comment">// 默认构造 + 拷贝构造 + 析构×2!</span>
}
</code></pre>
<p><strong>对象切片问题示例：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">printType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Base"</span> &lt;&lt; std::endl;
    }
    
    <span class="hljs-comment">// 虚函数，需要多态行为</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::unique_ptr&lt;Base&gt; <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Base&gt;(*<span class="hljs-keyword">this</span>);
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Derived"</span> &lt;&lt; std::endl;
    }
    
    <span class="hljs-function">std::unique_ptr&lt;Base&gt; <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;Derived&gt;(*<span class="hljs-keyword">this</span>);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derivedOnlyMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"Derived特有方法"</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-comment">// 错误的传值方式 - 导致切片</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processBaseByValue</span><span class="hljs-params">(Base base)</span> </span>{
    base.<span class="hljs-built_in">printType</span>();  <span class="hljs-comment">// 总是输出"Base"，丢失多态！</span>
    
    <span class="hljs-comment">// 无法调用derivedOnlyMethod，即使传递的是Derived对象</span>
    <span class="hljs-comment">// base.derivedOnlyMethod();  // 编译错误！</span>
}

<span class="hljs-comment">// 正确的const引用方式 - 保持多态</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processBaseByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; base)</span> </span>{
    base.<span class="hljs-built_in">printType</span>();  <span class="hljs-comment">// 正确输出实际类型！</span>
    
    <span class="hljs-comment">// 可以安全地进行向下转型</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> derived = <span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> Derived*&gt;(&amp;base)) {
        derived-&gt;<span class="hljs-built_in">derivedOnlyMethod</span>();  <span class="hljs-comment">// 可以调用派生类方法</span>
    }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_slicing_problem</span><span class="hljs-params">()</span> </span>{
    Derived derived_obj;
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 传值导致切片 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processBaseByValue</span>(derived_obj);  <span class="hljs-comment">// 输出"Base" - 切片发生！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== const引用保持多态 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processBaseByConstRef</span>(derived_obj);  <span class="hljs-comment">// 输出"Derived" - 多态保持！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 临时对象多态测试 ==="</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">processBaseByConstRef</span>(<span class="hljs-built_in">Derived</span>());  <span class="hljs-comment">// 输出"Derived" - 仍然多态！</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-8"><strong>解决方案：const引用传递</strong></h3>
<h4 data-id="heading-9"><strong>1. 基本const引用模式</strong></h4>
<p><strong>高效的对象传递：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Customer</span>(std::string name, <span class="hljs-type">int</span> id) 
        : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(name)), <span class="hljs-built_in">id_</span>(id) {}
    
    <span class="hljs-comment">// const引用访问器</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> name_; }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> id_; }
    
    <span class="hljs-comment">// 修改方法 - 非const引用返回</span>
    <span class="hljs-function">std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> name_; }
    
<span class="hljs-keyword">private</span>:
    std::string name_;
    <span class="hljs-type">int</span> id_;
};

<span class="hljs-comment">// 优秀的const引用接口设计</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 只读访问 - const引用</span>
    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculateTotal</span><span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; customer, 
                         <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; items)</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-type">double</span> total = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; price : items) {  <span class="hljs-comment">// 容器也使用const引用</span>
            total += price;
        }
        
        <span class="hljs-comment">// 可以读取customer但不能修改</span>
        std::cout &lt;&lt; <span class="hljs-string">"为客户 "</span> &lt;&lt; customer.<span class="hljs-built_in">getName</span>() 
                  &lt;&lt; <span class="hljs-string">" 计算总额: "</span> &lt;&lt; total &lt;&lt; std::endl;
        
        <span class="hljs-keyword">return</span> total;
    }
    
    <span class="hljs-comment">// 需要修改对象 - 非const引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateCustomerName</span><span class="hljs-params">(Customer&amp; customer, <span class="hljs-type">const</span> std::string&amp; newName)</span> </span>{
        customer.<span class="hljs-built_in">getName</span>() = newName;  <span class="hljs-comment">// 调用非const版本</span>
    }
    
    <span class="hljs-comment">// 多个相关对象的const引用</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateOrder</span><span class="hljs-params">(<span class="hljs-type">const</span> Customer&amp; customer,
                      <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; items,
                      <span class="hljs-type">const</span> std::string&amp; paymentMethod)</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">if</span> (items.<span class="hljs-built_in">empty</span>()) {
            std::cout &lt;&lt; customer.<span class="hljs-built_in">getName</span>() &lt;&lt; <span class="hljs-string">" 的订单为空"</span> &lt;&lt; std::endl;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        
        <span class="hljs-keyword">if</span> (paymentMethod != <span class="hljs-string">"信用卡"</span> &amp;&amp; paymentMethod != <span class="hljs-string">"支付宝"</span>) {
            std::cout &lt;&lt; <span class="hljs-string">"不支持的支付方式: "</span> &lt;&lt; paymentMethod &lt;&lt; std::endl;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};

<span class="hljs-comment">// 标准库算法的const引用使用</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_std_algorithm</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Customer&gt;&amp; customers)</span> </span>{
    <span class="hljs-comment">// 查找特定客户 - 谓词使用const引用</span>
    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(customers.<span class="hljs-built_in">begin</span>(), customers.<span class="hljs-built_in">end</span>(),
        [](<span class="hljs-type">const</span> Customer&amp; cust) {  <span class="hljs-comment">// const引用捕获</span>
            <span class="hljs-keyword">return</span> cust.<span class="hljs-built_in">getName</span>() == <span class="hljs-string">"张三"</span>;
        });
    
    <span class="hljs-keyword">if</span> (it != customers.<span class="hljs-built_in">end</span>()) {
        std::cout &lt;&lt; <span class="hljs-string">"找到客户: "</span> &lt;&lt; it-&gt;<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;
    }
    
    <span class="hljs-comment">// 排序客户 - 比较器使用const引用</span>
    std::vector&lt;Customer&gt; sorted_customers = customers;
    std::<span class="hljs-built_in">sort</span>(sorted_customers.<span class="hljs-built_in">begin</span>(), sorted_customers.<span class="hljs-built_in">end</span>(),
        [](<span class="hljs-type">const</span> Customer&amp; a, <span class="hljs-type">const</span> Customer&amp; b) {
            <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">getId</span>() &lt; b.<span class="hljs-built_in">getId</span>();
        });
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_const_reference</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Customer <span class="hljs-title">customer</span><span class="hljs-params">(<span class="hljs-string">"李四"</span>, <span class="hljs-number">1001</span>)</span></span>;
    std::vector&lt;<span class="hljs-type">double</span>&gt; items = {<span class="hljs-number">19.99</span>, <span class="hljs-number">29.99</span>, <span class="hljs-number">9.99</span>};
    
    OrderProcessor processor;
    
    <span class="hljs-comment">// const引用调用 - 高效且安全</span>
    <span class="hljs-type">double</span> total = processor.<span class="hljs-built_in">calculateTotal</span>(customer, items);
    std::cout &lt;&lt; <span class="hljs-string">"订单总额: "</span> &lt;&lt; total &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 验证订单</span>
    <span class="hljs-type">bool</span> valid = processor.<span class="hljs-built_in">validateOrder</span>(customer, items, <span class="hljs-string">"支付宝"</span>);
    std::cout &lt;&lt; <span class="hljs-string">"订单验证: "</span> &lt;&lt; (valid ? <span class="hljs-string">"通过"</span> : <span class="hljs-string">"失败"</span>) &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 需要修改时使用非const引用</span>
    processor.<span class="hljs-built_in">updateCustomerName</span>(customer, <span class="hljs-string">"王五"</span>);
    std::cout &lt;&lt; <span class="hljs-string">"更新后姓名: "</span> &lt;&lt; customer.<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 容器操作演示</span>
    std::vector&lt;Customer&gt; customers = {
        <span class="hljs-built_in">Customer</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-number">1002</span>),
        <span class="hljs-built_in">Customer</span>(<span class="hljs-string">"李四"</span>, <span class="hljs-number">1001</span>),
        <span class="hljs-built_in">Customer</span>(<span class="hljs-string">"王五"</span>, <span class="hljs-number">1003</span>)
    };
    
    <span class="hljs-built_in">demonstrate_std_algorithm</span>(customers);
}
</code></pre>
<h4 data-id="heading-10"><strong>2. 移动语义的现代方法</strong></h4>
<p><strong>传值+移动的优化模式：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ModernStringProcessor</span> {
<span class="hljs-keyword">private</span>:
    std::string data_;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 传统方式：const引用 + 拷贝</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>{
        data_ = data;  <span class="hljs-comment">// 拷贝赋值</span>
    }
    
    <span class="hljs-comment">// 改进方式：重载const引用和右值引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataOverloaded</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>{
        data_ = data;  <span class="hljs-comment">// 拷贝</span>
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataOverloaded</span><span class="hljs-params">(std::string&amp;&amp; data)</span> </span>{
        data_ = std::<span class="hljs-built_in">move</span>(data);  <span class="hljs-comment">// 移动</span>
    }
    
    <span class="hljs-comment">// 现代方式：传值 + 移动（对于移动成本低的类型）</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataByValue</span><span class="hljs-params">(std::string data)</span> </span>{
        data_ = std::<span class="hljs-built_in">move</span>(data);  <span class="hljs-comment">// 移动赋值</span>
    }
    
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> data_; }
};

<span class="hljs-comment">// 资源管理类的移动优化</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceHolder</span> {
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; resources_;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 对于已知要存储的参数，传值可能更优</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addResource</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; new_resources)</span> </span>{
        <span class="hljs-keyword">if</span> (resources_.<span class="hljs-built_in">empty</span>()) {
            resources_ = std::<span class="hljs-built_in">move</span>(new_resources);  <span class="hljs-comment">// 移动</span>
        } <span class="hljs-keyword">else</span> {
            resources_.<span class="hljs-built_in">insert</span>(resources_.<span class="hljs-built_in">end</span>(),
                            new_resources.<span class="hljs-built_in">begin</span>(), new_resources.<span class="hljs-built_in">end</span>());
        }
    }
    
    <span class="hljs-comment">// 只读访问仍然使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsResource</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">find</span>(resources_.<span class="hljs-built_in">begin</span>(), resources_.<span class="hljs-built_in">end</span>(), value) 
               != resources_.<span class="hljs-built_in">end</span>();
    }
    
    <span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; <span class="hljs-title">getResources</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> resources_; }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_move_semantics</span><span class="hljs-params">()</span> </span>{
    ModernStringProcessor processor;
    std::string large_data = <span class="hljs-string">"这是一个很长的字符串..."</span>;
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 测试各种传递方式 ==="</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 左值传递测试</span>
    std::cout &lt;&lt; <span class="hljs-string">"左值传递:"</span> &lt;&lt; std::endl;
    processor.<span class="hljs-built_in">setDataByConstRef</span>(large_data);        <span class="hljs-comment">// 拷贝</span>
    processor.<span class="hljs-built_in">setDataOverloaded</span>(large_data);        <span class="hljs-comment">// 拷贝</span>
    processor.<span class="hljs-built_in">setDataByValue</span>(large_data);           <span class="hljs-comment">// 拷贝</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"数据: "</span> &lt;&lt; processor.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 右值传递测试</span>
    std::cout &lt;&lt; <span class="hljs-string">"右值传递:"</span> &lt;&lt; std::endl;
    processor.<span class="hljs-built_in">setDataByConstRef</span>(<span class="hljs-string">"临时字符串"</span>);      <span class="hljs-comment">// 构造 + 拷贝</span>
    processor.<span class="hljs-built_in">setDataOverloaded</span>(<span class="hljs-string">"临时字符串"</span>);      <span class="hljs-comment">// 构造 + 移动</span>
    processor.<span class="hljs-built_in">setDataByValue</span>(<span class="hljs-string">"临时字符串"</span>);         <span class="hljs-comment">// 构造 + 移动</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"数据: "</span> &lt;&lt; processor.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 显式移动测试</span>
    std::cout &lt;&lt; <span class="hljs-string">"显式移动:"</span> &lt;&lt; std::endl;
    std::string movable_data = <span class="hljs-string">"可移动数据"</span>;
    processor.<span class="hljs-built_in">setDataByValue</span>(std::<span class="hljs-built_in">move</span>(movable_data));  <span class="hljs-comment">// 移动</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"数据: "</span> &lt;&lt; processor.<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"移动后源数据: "</span> &lt;&lt; movable_data &lt;&lt; std::endl;  <span class="hljs-comment">// 有效但未指定状态</span>
    
    <span class="hljs-comment">// 资源持有者测试</span>
    ResourceHolder holder;
    std::vector&lt;<span class="hljs-type">int</span>&gt; resources = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    
    holder.<span class="hljs-built_in">addResource</span>(std::<span class="hljs-built_in">move</span>(resources));  <span class="hljs-comment">// 高效移动</span>
    std::cout &lt;&lt; <span class="hljs-string">"资源数量: "</span> &lt;&lt; holder.<span class="hljs-built_in">getResources</span>().<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;
}
</code></pre>
<hr/>
<h3 data-id="heading-11"><strong>适用场景与例外情况</strong></h3>
<h4 data-id="heading-12"><strong>1. 内置类型与小型对象</strong></h4>
<p><strong>传值更优的场景：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-comment">// 内置类型 - 传值更高效</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtils</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 内置类型直接传值</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">calculateDistance</span><span class="hljs-params">(<span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> y1, 
                                   <span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y2)</span> </span>{
        <span class="hljs-type">double</span> dx = x2 - x1;
        <span class="hljs-type">double</span> dy = y2 - y1;
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">sqrt</span>(dx * dx + dy * dy);
    }
    
    <span class="hljs-comment">// 小型的、拷贝成本低的结构体</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {
        <span class="hljs-type">double</span> x, y;
        
        <span class="hljs-comment">// 平凡拷贝构造，传值可能更好</span>
        <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) {}
    };
    
    <span class="hljs-comment">// 对于小型Point，传值可能比传引用更高效</span>
    <span class="hljs-function"><span class="hljs-type">static</span> Point <span class="hljs-title">midpoint</span><span class="hljs-params">(Point p1, Point p2)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>((p1.x + p2.x) / <span class="hljs-number">2</span>, (p1.y + p2.y) / <span class="hljs-number">2</span>);
    }
};

<span class="hljs-comment">// 编译期类型特性判断</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">smartPass</span><span class="hljs-params">(T&amp;&amp; param)</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_fundamental_v&lt;std::<span class="hljs-type">decay_t</span>&lt;T&gt;&gt;)</span> </span>{
        <span class="hljs-comment">// 内置类型：可以考虑传值</span>
        <span class="hljs-built_in">processFundamental</span>(std::forward&lt;T&gt;(param));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_trivially_copyable_v&lt;std::<span class="hljs-type">decay_t</span>&lt;T&gt;&gt; &amp;&amp; 
                        <span class="hljs-built_in">sizeof</span>(std::<span class="hljs-type">decay_t</span>&lt;T&gt;) &lt;= <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)) {
        <span class="hljs-comment">// 小型平凡类型：可以考虑传值</span>
        <span class="hljs-built_in">processSmallTrivial</span>(std::forward&lt;T&gt;(param));
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 其他类型：使用引用</span>
        <span class="hljs-built_in">processByReference</span>(std::forward&lt;T&gt;(param));
    }
}

<span class="hljs-comment">// 接口设计的最佳实践</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Configuration</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 内置类型传值</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTimeout</span><span class="hljs-params">(<span class="hljs-type">int</span> milliseconds)</span> </span>{
        timeout_ = milliseconds;
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPrecision</span><span class="hljs-params">(<span class="hljs-type">double</span> precision)</span> </span>{
        precision_ = precision;
    }
    
    <span class="hljs-comment">// 字符串使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>{
        name_ = name;
    }
    
    <span class="hljs-comment">// 或者使用传值+移动</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDescription</span><span class="hljs-params">(std::string description)</span> </span>{
        description_ = std::<span class="hljs-built_in">move</span>(description);
    }
    
    <span class="hljs-comment">// 返回const引用避免拷贝</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> name_; }
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> description_; }
    
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> timeout_ = <span class="hljs-number">1000</span>;
    <span class="hljs-type">double</span> precision_ = <span class="hljs-number">0.001</span>;
    std::string name_;
    std::string description_;
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_appropriate_usage</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">MathUtils::Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span></span>;
    <span class="hljs-function">MathUtils::Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>)</span></span>;
    
    <span class="hljs-comment">// 小型对象传值 - 可能更高效</span>
    <span class="hljs-keyword">auto</span> mid = MathUtils::<span class="hljs-built_in">midpoint</span>(p1, p2);
    std::cout &lt;&lt; <span class="hljs-string">"中点: ("</span> &lt;&lt; mid.x &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; mid.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 内置类型传值</span>
    <span class="hljs-type">double</span> dist = MathUtils::<span class="hljs-built_in">calculateDistance</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
    std::cout &lt;&lt; <span class="hljs-string">"距离: "</span> &lt;&lt; dist &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 配置对象使用</span>
    Configuration config;
    config.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-number">5000</span>);           <span class="hljs-comment">// 内置类型传值</span>
    config.<span class="hljs-built_in">setPrecision</span>(<span class="hljs-number">0.0001</span>);       <span class="hljs-comment">// 内置类型传值</span>
    config.<span class="hljs-built_in">setName</span>(<span class="hljs-string">"高性能服务器"</span>);     <span class="hljs-comment">// const引用</span>
    config.<span class="hljs-built_in">setDescription</span>(<span class="hljs-string">"这是服务器的详细配置描述"</span>); <span class="hljs-comment">// 传值+移动</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"配置名称: "</span> &lt;&lt; config.<span class="hljs-built_in">getName</span>() &lt;&lt; std::endl;
}
</code></pre>
<h4 data-id="heading-13"><strong>2. 标准库容器的传递策略</strong></h4>
<p><strong>容器参数的最佳实践：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 只读访问容器 - const引用</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">calculateAverage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data)</span> </span>{
        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;
        
        <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; value : data) {  <span class="hljs-comment">// const引用遍历</span>
            sum += value;
        }
        <span class="hljs-keyword">return</span> sum / data.<span class="hljs-built_in">size</span>();
    }
    
    <span class="hljs-comment">// 需要修改容器 - 非const引用</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">normalizeData</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data)</span> </span>{
        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;
        
        <span class="hljs-type">double</span> avg = <span class="hljs-built_in">calculateAverage</span>(data);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; value : data) {  <span class="hljs-comment">// 非const引用修改</span>
            value -= avg;
        }
    }
    
    <span class="hljs-comment">// 创建新容器 - 考虑返回值优化</span>
    <span class="hljs-function"><span class="hljs-type">static</span> std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">filterPositive</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data)</span> </span>{
        std::vector&lt;<span class="hljs-type">double</span>&gt; result;
        std::<span class="hljs-built_in">copy_if</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">back_inserter</span>(result),
                    [](<span class="hljs-type">double</span> value) { <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">0</span>; });
        <span class="hljs-keyword">return</span> result;  <span class="hljs-comment">// 依赖RVO</span>
    }
    
    <span class="hljs-comment">// 大型容器的只读处理 - 始终使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">concatenateAll</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; strings)</span> </span>{
        std::string result;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; str : strings) {
            result += str;
        }
        <span class="hljs-keyword">return</span> result;
    }
};

<span class="hljs-comment">// 模板容器算法</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">findMaxValue</span><span class="hljs-params">(<span class="hljs-type">const</span> Container&amp; container)</span> -&gt; <span class="hljs-keyword">typename</span> Container::value_type </span>{
    <span class="hljs-keyword">if</span> (container.<span class="hljs-built_in">empty</span>()) {
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">"容器为空"</span>);
    }
    
    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">max_element</span>(container.<span class="hljs-built_in">begin</span>(), container.<span class="hljs-built_in">end</span>());
    <span class="hljs-keyword">return</span> *it;  <span class="hljs-comment">// 返回值的拷贝（假设value_type较小）</span>
}

<span class="hljs-comment">// 对于可能很大的返回值，提供引用版本</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">findMaxElement</span><span class="hljs-params">(<span class="hljs-type">const</span> Container&amp; container)</span> -&gt; <span class="hljs-type">const</span> <span class="hljs-keyword">typename</span> Container::value_type&amp; </span>{
    <span class="hljs-keyword">if</span> (container.<span class="hljs-built_in">empty</span>()) {
        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">"容器为空"</span>);
    }
    
    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">max_element</span>(container.<span class="hljs-built_in">begin</span>(), container.<span class="hljs-built_in">end</span>());
    <span class="hljs-keyword">return</span> *it;  <span class="hljs-comment">// 返回const引用</span>
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_container_passing</span><span class="hljs-params">()</span> </span>{
    std::vector&lt;<span class="hljs-type">double</span>&gt; data = {<span class="hljs-number">1.5</span>, <span class="hljs-number">-2.3</span>, <span class="hljs-number">3.7</span>, <span class="hljs-number">-0.8</span>, <span class="hljs-number">4.1</span>};
    std::vector&lt;std::string&gt; strings = {<span class="hljs-string">"Hello"</span>, <span class="hljs-string">" "</span>, <span class="hljs-string">"World"</span>, <span class="hljs-string">"!"</span>};
    
    <span class="hljs-comment">// 只读处理 - const引用</span>
    <span class="hljs-type">double</span> avg = DataProcessor::<span class="hljs-built_in">calculateAverage</span>(data);
    std::cout &lt;&lt; <span class="hljs-string">"平均值: "</span> &lt;&lt; avg &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 修改处理 - 非const引用</span>
    DataProcessor::<span class="hljs-built_in">normalizeData</span>(data);
    std::cout &lt;&lt; <span class="hljs-string">"标准化后平均值: "</span> &lt;&lt; DataProcessor::<span class="hljs-built_in">calculateAverage</span>(data) &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 创建新容器 - 依赖RVO</span>
    <span class="hljs-keyword">auto</span> positive_data = DataProcessor::<span class="hljs-built_in">filterPositive</span>(data);
    std::cout &lt;&lt; <span class="hljs-string">"正数数量: "</span> &lt;&lt; positive_data.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 字符串拼接 - const引用避免拷贝</span>
    std::string concatenated = DataProcessor::<span class="hljs-built_in">concatenateAll</span>(strings);
    std::cout &lt;&lt; <span class="hljs-string">"拼接结果: "</span> &lt;&lt; concatenated &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 模板算法使用</span>
    <span class="hljs-type">double</span> max_val = <span class="hljs-built_in">findMaxValue</span>(data);
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; max_ref = <span class="hljs-built_in">findMaxElement</span>(data);  <span class="hljs-comment">// 避免拷贝</span>
    std::cout &lt;&lt; <span class="hljs-string">"最大值: "</span> &lt;&lt; max_val &lt;&lt; <span class="hljs-string">" (引用: "</span> &lt;&lt; max_ref &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; std::endl;
}
</code></pre>
<hr/>
<h3 data-id="heading-14"><strong>高级技巧与陷阱防范</strong></h3>
<h4 data-id="heading-15"><strong>1. 完美转发与通用引用</strong></h4>
<p><strong>现代C++的转发技术：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedProcessor</span> {
<span class="hljs-keyword">private</span>:
    std::string stored_value_;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 通用引用 + 完美转发</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T&amp;&amp; value)</span> </span>{
        stored_value_ = std::forward&lt;T&gt;(value);
        
        std::cout &lt;&lt; <span class="hljs-string">"设置值: "</span> &lt;&lt; stored_value_;
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_lvalue_reference_v&lt;T&amp;&amp;&gt;)</span> </span>{
            std::cout &lt;&lt; <span class="hljs-string">" (左值)"</span> &lt;&lt; std::endl;
        } <span class="hljs-keyword">else</span> {
            std::cout &lt;&lt; <span class="hljs-string">" (右值)"</span> &lt;&lt; std::endl;
        }
    }
    
    <span class="hljs-comment">// 带约束的通用引用</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    std::<span class="hljs-type">enable_if_t</span>&lt;std::is_constructible_v&lt;std::string, T&gt;&gt;
    <span class="hljs-built_in">setValueConstrained</span>(T&amp;&amp; value) {
        stored_value_ = std::forward&lt;T&gt;(value);
    }
    
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> stored_value_; }
};

<span class="hljs-comment">// 工厂函数中的完美转发</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;
std::unique_ptr&lt;T&gt; <span class="hljs-title">createObject</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;T&gt;(std::forward&lt;Args&gt;(args)...);
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ExampleClass</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> value) 
        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">value_</span>(value) {
        std::cout &lt;&lt; <span class="hljs-string">"ExampleClass构造: "</span> &lt;&lt; name_ &lt;&lt; std::endl;
    }
    
    <span class="hljs-built_in">ExampleClass</span>(std::string&amp;&amp; name, <span class="hljs-type">int</span> value) 
        : <span class="hljs-built_in">name_</span>(std::<span class="hljs-built_in">move</span>(name)), <span class="hljs-built_in">value_</span>(value) {
        std::cout &lt;&lt; <span class="hljs-string">"ExampleClass移动构造: "</span> &lt;&lt; name_ &lt;&lt; std::endl;
    }
    
<span class="hljs-keyword">private</span>:
    std::string name_;
    <span class="hljs-type">int</span> value_;
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_perfect_forwarding</span><span class="hljs-params">()</span> </span>{
    AdvancedProcessor processor;
    std::string name = <span class="hljs-string">"测试名称"</span>;
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 完美转发演示 ==="</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 左值传递</span>
    processor.<span class="hljs-built_in">setValue</span>(name);                    <span class="hljs-comment">// 拷贝</span>
    std::cout &lt;&lt; <span class="hljs-string">"原值: "</span> &lt;&lt; name &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 右值传递</span>
    processor.<span class="hljs-built_in">setValue</span>(<span class="hljs-string">"临时字符串"</span>);            <span class="hljs-comment">// 移动</span>
    processor.<span class="hljs-built_in">setValue</span>(std::<span class="hljs-built_in">move</span>(name));         <span class="hljs-comment">// 移动</span>
    std::cout &lt;&lt; <span class="hljs-string">"移动后原值: "</span> &lt;&lt; name &lt;&lt; std::endl;  <span class="hljs-comment">// 有效但未指定状态</span>
    
    <span class="hljs-comment">// 工厂函数使用</span>
    <span class="hljs-keyword">auto</span> obj1 = <span class="hljs-built_in">createObject</span>&lt;ExampleClass&gt;(<span class="hljs-string">"对象1"</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">// 可能移动构造</span>
    <span class="hljs-keyword">auto</span> obj2 = <span class="hljs-built_in">createObject</span>&lt;ExampleClass&gt;(name, <span class="hljs-number">200</span>);     <span class="hljs-comment">// 拷贝构造</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 带约束的转发 ==="</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 只有能构造std::string的类型才被接受</span>
    processor.<span class="hljs-built_in">setValueConstrained</span>(<span class="hljs-string">"字符串字面量"</span>);  <span class="hljs-comment">// OK</span>
    processor.<span class="hljs-built_in">setValueConstrained</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">"临时"</span>)); <span class="hljs-comment">// OK</span>
    <span class="hljs-comment">// processor.setValueConstrained(42);  // 编译错误！不能从int构造string</span>
}
</code></pre>
<h4 data-id="heading-16"><strong>2. 生命周期管理与陷阱防范</strong></h4>
<p><strong>悬空引用预防：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DangerousReferences</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 危险的接口：返回内部数据的引用</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> data_; }
    
    <span class="hljs-comment">// 更安全的接口：返回拷贝或共享指针</span>
    <span class="hljs-function">std::string <span class="hljs-title">getDataCopy</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> data_; }
    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">const</span> std::string&gt; <span class="hljs-title">getDataShared</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">const</span> std::string&gt;(data_);
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>{ data_ = data; }
    
<span class="hljs-keyword">private</span>:
    std::string data_ = <span class="hljs-string">"默认数据"</span>;
};

<span class="hljs-comment">// 悬空引用的典型场景</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CallbackManager</span> {
<span class="hljs-keyword">private</span>:
    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">const</span> std::string&amp;)&gt; callback_;
    
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">const</span> std::string&amp;)&gt;&amp; callback)</span> </span>{
        callback_ = callback;
    }
    
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>{
        <span class="hljs-keyword">if</span> (callback_) {
            <span class="hljs-built_in">callback_</span>(input);
        }
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_dangling_reference</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">"=== 悬空引用演示 ==="</span> &lt;&lt; std::endl;
    
    DangerousReferences obj;
    
    <span class="hljs-comment">// 安全的用法</span>
    std::string safe_copy = obj.<span class="hljs-built_in">getDataCopy</span>();
    <span class="hljs-keyword">auto</span> shared_data = obj.<span class="hljs-built_in">getDataShared</span>();
    
    <span class="hljs-comment">// 潜在的危险用法</span>
    <span class="hljs-type">const</span> std::string&amp; dangerous_ref = obj.<span class="hljs-built_in">getData</span>();
    obj.<span class="hljs-built_in">setData</span>(<span class="hljs-string">"新数据"</span>);  <span class="hljs-comment">// dangerous_ref可能悬空！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"安全拷贝: "</span> &lt;&lt; safe_copy &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"共享数据: "</span> &lt;&lt; *shared_data &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"危险引用: "</span> &lt;&lt; dangerous_ref &lt;&lt; std::endl;  <span class="hljs-comment">// 可能有问题！</span>
    
    <span class="hljs-comment">// 回调中的生命周期问题</span>
    CallbackManager manager;
    
    {
        std::string local_data = <span class="hljs-string">"局部数据"</span>;
        
        <span class="hljs-comment">// 捕获局部变量的引用 - 危险！</span>
        manager.<span class="hljs-built_in">setCallback</span>([&amp;](<span class="hljs-type">const</span> std::string&amp; input) {
            std::cout &lt;&lt; <span class="hljs-string">"回调处理: "</span> &lt;&lt; local_data &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; input &lt;&lt; std::endl;
        });
        
        manager.<span class="hljs-built_in">processData</span>(<span class="hljs-string">"输入数据"</span>);  <span class="hljs-comment">// 此时还安全</span>
    }  <span class="hljs-comment">// local_data离开作用域，被销毁</span>
    
    <span class="hljs-comment">// 此时回调中的local_data已经悬空！</span>
    <span class="hljs-comment">// manager.processData("再次输入");  // 未定义行为！</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"=== 安全的回调设计 ==="</span> &lt;&lt; std::endl;
    
    <span class="hljs-comment">// 安全的回调：通过值捕获或共享所有权</span>
    <span class="hljs-keyword">auto</span> safe_data = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">"安全数据"</span>);
    
    manager.<span class="hljs-built_in">setCallback</span>([safe_data](<span class="hljs-type">const</span> std::string&amp; input) {
        std::cout &lt;&lt; <span class="hljs-string">"安全回调: "</span> &lt;&lt; *safe_data &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; input &lt;&lt; std::endl;
    });
    
    manager.<span class="hljs-built_in">processData</span>(<span class="hljs-string">"安全输入"</span>);  <span class="hljs-comment">// 始终安全</span>
}

<span class="hljs-comment">// 返回局部对象引用的错误模式</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">WrongFactory</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 错误：返回局部对象的引用</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">createBadString</span><span class="hljs-params">()</span> </span>{
        std::string local = <span class="hljs-string">"局部字符串"</span>;
        <span class="hljs-keyword">return</span> local;  <span class="hljs-comment">// 返回悬空引用！</span>
    }
    
    <span class="hljs-comment">// 正确：返回值</span>
    <span class="hljs-function">std::string <span class="hljs-title">createGoodString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"安全字符串"</span>;  <span class="hljs-comment">// 返回值优化</span>
    }
    
    <span class="hljs-comment">// 正确：返回静态对象的引用</span>
    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getStaticString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">static</span> std::string static_str = <span class="hljs-string">"静态字符串"</span>;
        <span class="hljs-keyword">return</span> static_str;  <span class="hljs-comment">// 安全：静态对象生命周期到程序结束</span>
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_lifetime_management</span><span class="hljs-params">()</span> </span>{
    WrongFactory factory;
    
    <span class="hljs-comment">// 危险的调用</span>
    <span class="hljs-comment">// const auto&amp; bad_ref = factory.createBadString();  // 悬空引用！</span>
    <span class="hljs-comment">// std::cout &lt;&lt; bad_ref &lt;&lt; std::endl;  // 未定义行为</span>
    
    <span class="hljs-comment">// 安全的调用</span>
    <span class="hljs-keyword">auto</span> good_str = factory.<span class="hljs-built_in">createGoodString</span>();  <span class="hljs-comment">// 拷贝或移动</span>
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; static_ref = factory.<span class="hljs-built_in">getStaticString</span>();  <span class="hljs-comment">// 静态引用安全</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"好字符串: "</span> &lt;&lt; good_str &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"静态引用: "</span> &lt;&lt; static_ref &lt;&lt; std::endl;
}
</code></pre>
<hr/>
<h3 data-id="heading-17"><strong>性能测试与权衡决策</strong></h3>
<h4 data-id="heading-18"><strong>1. 实际性能测量</strong></h4>
<p><strong>基准测试示例：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceTest</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LargeData</span> {
        std::vector&lt;<span class="hljs-type">int</span>&gt; data;
        
        <span class="hljs-built_in">LargeData</span>() {
            data.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10000</span>, <span class="hljs-number">42</span>);  <span class="hljs-comment">// 大量数据</span>
        }
        
        <span class="hljs-comment">// 拷贝成本很高</span>
        <span class="hljs-built_in">LargeData</span>(<span class="hljs-type">const</span> LargeData&amp; other) : <span class="hljs-built_in">data</span>(other.data) {
            <span class="hljs-comment">// 模拟昂贵的拷贝</span>
        }
    };
    
    <span class="hljs-comment">// 传值版本</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">processByValue</span><span class="hljs-params">(LargeData data)</span> </span>{
        <span class="hljs-comment">// 一些处理...</span>
        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : data.data) {
            sum += val;
        }
    }
    
    <span class="hljs-comment">// const引用版本</span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">processByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> LargeData&amp; data)</span> </span>{
        <span class="hljs-comment">// 相同的处理...</span>
        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : data.data) {
            sum += val;
        }
    }
    
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">runBenchmark</span><span class="hljs-params">()</span> </span>{
        LargeData test_data;
        <span class="hljs-type">const</span> <span class="hljs-type">int</span> iterations = <span class="hljs-number">1000</span>;
        
        std::cout &lt;&lt; <span class="hljs-string">"=== 性能基准测试 ==="</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"数据大小: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(test_data) &lt;&lt; <span class="hljs-string">" 字节"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"迭代次数: "</span> &lt;&lt; iterations &lt;&lt; std::endl;
        
        <span class="hljs-comment">// 测试传值性能</span>
        <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; ++i) {
            <span class="hljs-built_in">processByValue</span>(test_data);
        }
        <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">auto</span> value_duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);
        
        <span class="hljs-comment">// 测试const引用性能</span>
        start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; ++i) {
            <span class="hljs-built_in">processByConstRef</span>(test_data);
        }
        end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">auto</span> ref_duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);
        
        std::cout &lt;&lt; <span class="hljs-string">"传值耗时: "</span> &lt;&lt; value_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" μs"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"引用耗时: "</span> &lt;&lt; ref_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" μs"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"性能提升: "</span> 
                  &lt;&lt; (value_duration.<span class="hljs-built_in">count</span>() - ref_duration.<span class="hljs-built_in">count</span>()) * <span class="hljs-number">100.0</span> / value_duration.<span class="hljs-built_in">count</span>()
                  &lt;&lt; <span class="hljs-string">"%"</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-comment">// 小型对象的性能测试</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallObjectTest</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SmallData</span> {
        <span class="hljs-type">int</span> x, y, z;
        <span class="hljs-comment">// 小型平凡类型</span>
    };
    
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">processSmallByValue</span><span class="hljs-params">(SmallData data)</span> </span>{
        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> result = data.x + data.y + data.z;
    }
    
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">processSmallByConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> SmallData&amp; data)</span> </span>{
        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> result = data.x + data.y + data.z;
    }
    
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">runBenchmark</span><span class="hljs-params">()</span> </span>{
        SmallData small_data{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
        <span class="hljs-type">const</span> <span class="hljs-type">int</span> iterations = <span class="hljs-number">1000000</span>;  <span class="hljs-comment">// 更多迭代以显示差异</span>
        
        std::cout &lt;&lt; <span class="hljs-string">"\n=== 小型对象性能测试 ==="</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"数据大小: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(small_data) &lt;&lt; <span class="hljs-string">" 字节"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"迭代次数: "</span> &lt;&lt; iterations &lt;&lt; std::endl;
        
        <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; ++i) {
            <span class="hljs-built_in">processSmallByValue</span>(small_data);
        }
        <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">auto</span> value_duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);
        
        start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; ++i) {
            <span class="hljs-built_in">processSmallByConstRef</span>(small_data);
        }
        end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();
        <span class="hljs-keyword">auto</span> ref_duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);
        
        std::cout &lt;&lt; <span class="hljs-string">"传值耗时: "</span> &lt;&lt; value_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" μs"</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="hljs-string">"引用耗时: "</span> &lt;&lt; ref_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">" μs"</span> &lt;&lt; std::endl;
        
        <span class="hljs-keyword">if</span> (value_duration.<span class="hljs-built_in">count</span>() &lt; ref_duration.<span class="hljs-built_in">count</span>()) {
            std::cout &lt;&lt; <span class="hljs-string">"传值更快，优势: "</span>
                      &lt;&lt; (ref_duration.<span class="hljs-built_in">count</span>() - value_duration.<span class="hljs-built_in">count</span>()) * <span class="hljs-number">100.0</span> / ref_duration.<span class="hljs-built_in">count</span>()
                      &lt;&lt; <span class="hljs-string">"%"</span> &lt;&lt; std::endl;
        } <span class="hljs-keyword">else</span> {
            std::cout &lt;&lt; <span class="hljs-string">"引用更快，优势: "</span>
                      &lt;&lt; (value_duration.<span class="hljs-built_in">count</span>() - ref_duration.<span class="hljs-built_in">count</span>()) * <span class="hljs-number">100.0</span> / value_duration.<span class="hljs-built_in">count</span>()
                      &lt;&lt; <span class="hljs-string">"%"</span> &lt;&lt; std::endl;
        }
    }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_performance_measurement</span><span class="hljs-params">()</span> </span>{
    PerformanceTest::<span class="hljs-built_in">runBenchmark</span>();
    SmallObjectTest::<span class="hljs-built_in">runBenchmark</span>();
}
</code></pre>
<h4 data-id="heading-19"><strong>2. 实际应用总结</strong></h4>
<p><strong>最终决策框架：</strong></p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-comment">// 编译期传递策略选择</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PassStrategy</span> {
    <span class="hljs-comment">// 默认策略：对于未知类型使用const引用</span>
    <span class="hljs-keyword">using</span> type = <span class="hljs-type">const</span> T&amp;;
};

<span class="hljs-comment">// 特化：内置类型使用传值</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PassStrategy</span>&lt;T, std::<span class="hljs-type">enable_if_t</span>&lt;std::is_fundamental_v&lt;T&gt;&gt;&gt; {
    <span class="hljs-keyword">using</span> type = T;
};

<span class="hljs-comment">// 特化：小型平凡类型使用传值</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PassStrategy</span>&lt;T, std::<span class="hljs-type">enable_if_t</span>&lt;
    <span class="hljs-function">std::is_trivially_copyable_v&lt;T&gt; &amp;&amp; 
    <span class="hljs-title">sizeof</span><span class="hljs-params">(T)</span> &lt;</span>= <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*) &amp;&amp; 
    !std::is_fundamental_v&lt;T&gt;&gt;&gt; {
    <span class="hljs-keyword">using</span> type = T;
};

<span class="hljs-comment">// 特化：移动成本低的类型考虑传值</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PassStrategy</span>&lt;T, std::<span class="hljs-type">enable_if_t</span>&lt;
    <span class="hljs-function">std::is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; 
    <span class="hljs-title">sizeof</span><span class="hljs-params">(T)</span> &lt;</span>= <span class="hljs-number">4</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">void</span>*)&gt;&gt; {
    <span class="hljs-keyword">using</span> type = T;  <span class="hljs-comment">// 或者保持const T&amp;，根据性能测试决定</span>
};

<span class="hljs-comment">// 使用策略的模板函数</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">processWithStrategy</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> PassStrategy&lt;T&gt;::type param)</span> </span>{
    <span class="hljs-comment">// 使用param...</span>
}

<span class="hljs-comment">// 实际工程中的经验法则</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PracticalGuidelines</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 经验法则1：内置类型传值</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setIntParam</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDoubleParam</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoolParam</span><span class="hljs-params">(<span class="hljs-type">bool</span> value)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
    <span class="hljs-comment">// 经验法则2：迭代器传值（通常很小）</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRange</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator begin, 
                     std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator end)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
    <span class="hljs-comment">// 经验法则3：STL容器使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processVector</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
    <span class="hljs-comment">// 经验法则4：自定义大对象使用const引用</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processLargeObject</span><span class="hljs-params">(<span class="hljs-type">const</span> LargeData&amp; obj)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
    <span class="hljs-comment">// 经验法则5：需要存储的参数考虑传值+移动</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">storeString</span><span class="hljs-params">(std::string str)</span> </span>{
        stored_string_ = std::<span class="hljs-built_in">move</span>(str);
    }
    
    <span class="hljs-comment">// 经验法则6：多态基类必须使用引用或指针</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processPolymorphic</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; obj)</span> </span>{ <span class="hljs-comment">/* ... */</span> }
    
<span class="hljs-keyword">private</span>:
    std::string stored_string_;
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonstrate_practical_decision</span><span class="hljs-params">()</span> </span>{
    PracticalGuidelines guidelines;
    
    <span class="hljs-comment">// 遵循经验法则的调用</span>
    guidelines.<span class="hljs-built_in">setIntParam</span>(<span class="hljs-number">42</span>);                    <span class="hljs-comment">// 内置类型传值</span>
    guidelines.<span class="hljs-built_in">setDoubleParam</span>(<span class="hljs-number">3.14</span>);               <span class="hljs-comment">// 内置类型传值</span>
    
    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    guidelines.<span class="hljs-built_in">processRange</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 迭代器传值</span>
    
    guidelines.<span class="hljs-built_in">processVector</span>(numbers);             <span class="hljs-comment">// 容器const引用</span>
    
    std::string name = <span class="hljs-string">"测试名称"</span>;
    guidelines.<span class="hljs-built_in">processString</span>(name);                <span class="hljs-comment">// 字符串const引用</span>
    guidelines.<span class="hljs-built_in">storeString</span>(<span class="hljs-string">"要存储的字符串"</span>);      <span class="hljs-comment">// 传值+移动</span>
    
    <span class="hljs-comment">// 多态使用</span>
    Derived derived_obj;
    guidelines.<span class="hljs-built_in">processPolymorphic</span>(derived_obj);    <span class="hljs-comment">// 基类const引用</span>
    
    std::cout &lt;&lt; <span class="hljs-string">"所有调用都遵循参数传递的最佳实践"</span> &lt;&lt; std::endl;
}

<span class="hljs-comment">// 最终建议的总结实现</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalRecommendation</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/*
     * 参数传递决策树：
     * 
     * 1. 参数会被修改吗？
     *    - 是：使用非const引用 (void modify(T&amp; param))
     *    - 否：继续判断
     *    
     * 2. 参数是内置类型或很小吗？(sizeof(T) &lt;= 2*sizeof(void*))
     *    - 是：考虑传值 (void process(T param))
     *    - 否：继续判断
     *    
     * 3. 需要多态行为吗？
     *    - 是：使用const引用 (void process(const Base&amp; param))
     *    - 否：继续判断
     *    
     * 4. 参数会被存储吗？
     *    - 是：考虑传值+移动 (void store(T param) { member_ = std::move(param); })
     *    - 否：使用const引用 (void process(const T&amp; param))
     *    
     * 5. 在性能关键路径上吗？
     *    - 是：进行基准测试，根据结果决定
     *    - 否：使用const引用（安全的默认选择）
     */</span>
    
    <span class="hljs-comment">// 安全的默认选择</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">safeDefault</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; param)</span> </span>{
        <span class="hljs-comment">// 大多数情况的正确选择</span>
    }
    
    <span class="hljs-comment">// 性能优化后的选择</span>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">optimizedChoice</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> PassStrategy&lt;T&gt;::type param)</span> </span>{
        <span class="hljs-comment">// 基于实际测量的优化选择</span>
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">demonstrate_copy_cost</span>();
    <span class="hljs-built_in">demonstrate_slicing_problem</span>();
    <span class="hljs-built_in">demonstrate_const_reference</span>();
    <span class="hljs-built_in">demonstrate_move_semantics</span>();
    <span class="hljs-built_in">demonstrate_appropriate_usage</span>();
    <span class="hljs-built_in">demonstrate_container_passing</span>();
    <span class="hljs-built_in">demonstrate_perfect_forwarding</span>();
    <span class="hljs-built_in">demonstrate_dangling_reference</span>();
    <span class="hljs-built_in">demonstrate_lifetime_management</span>();
    <span class="hljs-built_in">demonstrate_performance_measurement</span>();
    <span class="hljs-built_in">demonstrate_practical_decision</span>();
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[美团 LongCat 团队发布全模态一站式评测基准UNO-Bench]]></title>    <link>https://juejin.cn/post/7573299401046212654</link>    <guid>https://juejin.cn/post/7573299401046212654</guid>    <pubDate>2025-11-17T07:09:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573299401046212654" data-draft-id="7573242085609750579" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="美团 LongCat 团队发布全模态一站式评测基准UNO-Bench"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-17T07:09:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="美团技术团队"/> <meta itemprop="url" content="https://juejin.cn/user/3509296845313741"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            美团 LongCat 团队发布全模态一站式评测基准UNO-Bench
            <!----> <!----></h1> <div class="container team-follow" data-v-d326b38e="" data-v-61fb5e44=""><div class="left" data-v-d326b38e=""><a href="/team/6930512966122995712/posts" data-v-d326b38e=""><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47ccb42d726640a7889ba1e64ae203e6~tplv-k3u1fbpfcp-watermark.image" class="icon" data-v-d326b38e=""/></a> <div class="content" data-v-d326b38e=""><div style="display: flex" data-v-d326b38e=""><a href="/team/6930512966122995712/posts" data-v-d326b38e=""><p class="title-line" data-v-d326b38e=""><span title="美团技术团队" class="title" data-v-d326b38e="">美团技术团队</span> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/255e400027b783cbad76dc41527e7695.svg" alt="team icon" class="team-icon" data-v-d326b38e=""/></p></a></div> <div class="meta-box team" data-v-d326b38e="" data-v-61fb5e44=""><time datetime="2025-11-17T07:09:57.000Z" title="Mon Nov 17 2025 07:09:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-d326b38e="" data-v-61fb5e44="">
                2025-11-17
              </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-d326b38e="" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-d326b38e="" data-v-61fb5e44=""/></svg> <span class="views-count" style="display:none;" data-v-d326b38e="" data-v-61fb5e44="">
                0
              </span> <span class="read-time" data-v-d326b38e="" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-d326b38e="" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-d326b38e="" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-d326b38e="" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-d326b38e="" data-v-61fb5e44=""/></svg>
                阅读16分钟
              </span> <!----> <!----></div></div></div> <button class="jj-follow-button follow-btn" style="display:none;" data-v-b60b2868="" data-v-d326b38e=""><span data-v-b60b2868="" data-v-d326b38e=""><i class="byte-icon byte-icon--plus" data-v-d326b38e=""><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 48 48"><path fill="none" d="M0 0h48v48H0z"/><path d="M24.7 4c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8V22h16.7c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8v1.4c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1H26v16.7c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1h-1.4c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8V26H5.3c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8v-1.4c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1H22V5.3c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1h1.4z"/></svg></i>
        关注
      </span></button></div> <div class="team-user block-hidden" data-v-61fb5e44=""><div class="avatar jj-avatar avatar" data-v-03256cc6="" data-v-61fb5e44=""><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="avatar" class="lazy avatar-img" data-v-5244ef91="" data-v-03256cc6=""/> </div> <!----> <span class="position ellipsis" data-v-61fb5e44="">
              美团小编 @美团
            </span></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>多模态人工智能正从单一感知能力迈向视觉、音频与文本的统一融合，即全模态大模型（Omni-models）时代。然而，相应的评测体系却相对滞后。现有的评测工具不仅稀缺、各自为战，且几乎完全以英文为中心，缺乏对中文场景的有效支持。此外，一些现存的数据集在设计上存在局限性，例如部分问题的解答路径并非严格依赖于多模态信息的融合，这为科学评估模型真实的跨模态能力带来了一定的复杂性。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bff55b80244b4ba090e0141758d5fa7d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=VFamcUt9Xz8JdDsl1%2FkDl0cit2A%3D" alt="图1：UNO-Bench核心统计与发现概览" loading="lazy"/></p>
<p>针对这些痛点，美团LongCat团队提出了一套高质量、多样化的一站式全模态大模型评测基准——UNO-Bench。该基准通过一个统一的框架，不仅能同时精准衡量模型的单模态与全模态理解能力，更首次验证了全模态大模型的“组合定律”——该定律在能力较弱的模型上呈现为短板效应，而在能力较强的模型上则涌现出协同增益，为行业提供了一种全新的、跨越模型规模的分析范式。这一发现的背后，是其系统性的数据构建流程：通过完全人工标注确保高质量与丰富度，有效防止数据污染。此外，该团队还引入了创新的“多步开放式问题”，旨在突破传统选择题的局限，更具区分度地刻画模型在复杂链路上的推理能力。</p>
<p>接下来，我们将详细介绍UNO-Bench是如何构建的，以及它如何为推动下一代AI的智慧演进奠定基础。</p>
<h2 data-id="heading-0">01. 评测现状：从单模态繁荣到全模态挑战</h2>
<p>当前，面向单模态的评测基准已发展成熟且生态繁荣。无论是针对通用视觉理解的MMBench、检验复杂数理逻辑的MathVision，还是覆盖动态视频场景的MVBench，以及在音频领域进行探索的MMAU，这些高质量的评测资源极大地推动了AI在细分维度下的认知能力发展。然而，这些资源彼此独立，难以适应向全模态大模型演进的趋势。</p>
<p>当我们将目光投向新兴的全模态大模型评测领域，现状则面临挑战。尽管如Gemini、Qwen-3-Omni等兼容视听双模态的顶尖全模态大模型已崭露头角，但能够有效评估其综合能力的基准却稀缺且存在明显不足。例如，OmniBench的部分数据存在错误答案，而WorldSense中由于使用音视频同步数据，大部分题目无需跨模态信息即可解答，导致难以有效衡量全模态的整合能力。</p>
<p>正是在这样的背景下，UNO-Bench应运而生。LongCat团队通过1250条人工标注的全模态样本和2480个增强的单模态样本，构建了一个适用于中文场景、横跨44类任务的综合性评测体系。其中，高达98%的问题被严格设计为必须在跨模态条件下才能正确解答，这弥补了现有评测无法有效检验模型真实跨模态能力的痛点，为科学评估与推动全模态大模型的发展提供了坚实可靠的基石（详见表格1）。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d44f234d717f41329e093f7e3e033e03~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=layu8NS0PBWZlmQyWc2CULplDN4%3D" alt="表格1：多模态基准横向对比" loading="lazy"/></p>
<p><strong>说明</strong>：表格中，I、A、V、T分别代表图像、音频、视频和文本模态。Acc.代表问答对的准确率，Solvable代表需要全模态才能解决的问题比例。Source代表素材来源，分为可防止数据污染的私有数据集和公开数据集。QA Type代表问答类型，MC、MO分别代表选择题和多步开放式问答。EN和ZH分别代表英文和中文。</p>
<h2 data-id="heading-1">02. UNO-Bench构建：从顶层设计到创新实现</h2>
<p>一个卓越的评测基准始于一个科学的顶层设计。我们从定义模型核心能力体系出发，通过标准化的数据生产线确保高质量与多样性，并最终引入创新的评测方法与优化算法，共同构建了UNO-Bench的基石。</p>
<h3 data-id="heading-2">2.1 顶层设计：科学定义全模态大模型能力体系</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c824a4be30f146738ae68bad48464189~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=MPFhKvZ9DSkqCKLgHXt6qPajAgQ%3D" alt="图2：UNO-Bench统一能力体系图" loading="lazy"/></p>
<p>该团队首先将模型的综合智能系统性地解构为两大核心层面：感知层与推理层。</p>
<ul>
<li><strong>感知层</strong>：覆盖了从对象、属性、场景的基础识别，到空间关系判断、跨模态转换及语义理解等六大认知能力，并特别增设了跨模态对齐这一能力。</li>
<li><strong>推理层</strong>：在通用、STEM、代码等传统推理类别之上，着重加入了空间推理、时序推理、复杂推理等更能体现全模态大模型特色的高阶推理任务。其中通用推理细拆为常识推理和逻辑推理，空间推理细拆为静态推理和动态推理。</li>
</ul>
<p>这一双维能力框架不仅为后续的数据构建提供了清晰的蓝图，也使得对模型能力的细粒度剖析成为可能。</p>
<h3 data-id="heading-3">2.2 数据构建：标准化的高质量生产线</h3>
<p>为确保数据的顶尖品质，LongCat团队建立了一套包含精选数据素材、专家级问答标注、严苛的多轮质检三个关键环节的标准化生产流程。所有关键对话均由超过20位真人录制，以高度还原真实世界的声学特征（如普通话、四川话等）。其中最关键的质检环节是模态消融实验：通过移除任一模态的信息来检验问题是否依然可解，以此严格确保98%以上数据的“跨模态可解性”。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bc57d737ad845b58e6f1ce871a657cd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=jT7HackCr9Y3eTz7BeRsoN8DwLc%3D" alt="图3：跨模态可解性问题示例" loading="lazy"/></p>
<p><strong>说明</strong>：图(a)展示了必须结合视听信息才能解答的问题，而图(b)和图(c)则分别展示了仅凭音频或视频即可解答的问题。</p>
<p>通过三个小案例（a, b, c）对比，清晰地展示了什么是必须由多个模态结合才能解答的问题，以及什么是仅凭单模态就能解答的问题。</p>
<p>数据生产流程的核心在于：</p>
<ul>
<li>针对现有数据集中普遍存在的两大问题——数据污染（视频素材可能已被模型在训练阶段“见过”）和信息冗余（视频自带的音频与画面高度同步，降低了跨模态推理的难度），我们采取了独特的素材构建策略。</li>
<li>UNO-Bench中超过90%私有化原创 。其中，大部分视觉素材来源于广泛的众包实拍，多样性、真实性更好的同时，也有效避免了模型因训练集覆盖而产生的“穿越”问题。</li>
<li>更关键的是，为了打破信息冗余，所有关键的音频内容（尤其是对话）均独立设计并由真人录制，然后与视觉素材进行人工组合。这种“视听分离再组合”的方式，确保了音频和视频各自承载着不可替代的关键信息，迫使模型必须进行真正的跨模态信息融合，而不是简单的同步确认。</li>
</ul>
<h3 data-id="heading-4">2.3 数据优化：单模态补全与高效压缩</h3>
<p>为构建全面的评测体系，我们不仅自建数据，还针对性地从AV-Odyssey、WorldSense等公开数据集中筛选了高质量样本进行补全（在整体全模态数据中占比11%）。此外，为降低大规模评测带来的算力消耗，我们独创了聚类引导的分层抽样法。实验证明，该方法在保持模型排名高度一致性的前提下，成功将评测成本降低了超过90%。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e40bfaa36c464ca6a21ee0e0a60530ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=hL6mUy1yk3rZBOqwtS8QhUURoJY%3D" alt="图4：数据构建流程图（说明：左边为全模态数据构建流程与统计信息，右边为单模态数据压缩流程与统计信息）" loading="lazy"/></p>
<h3 data-id="heading-5">2.4 评测创新：多步开放式问题与通用评分模型</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa7242fe04d840368740a828454710a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=Q9jFVowFf3GgU7ttVHtCEvvTUDs%3D" alt="图5：多步开放式问题（MO）构建示例" loading="lazy"/></p>
<p>为了打破传统选择题无法有效评估复杂推理的局限，引入了创新的多步开放式问题（MO，Multi-step Open-ended question）。这种题型将一个复杂的长链条推理任务，拆解为多个相互依赖、层层递进的子问题，并要求模型对每一步都给出开放式的文本答案。</p>
<p>评分则由专家根据每一步的难度与重要性进行加权赋分（满分10分）。这种设计能够直观地揭示模型在多步推理中的能力衰减现象，从而精准地区分出模型的“浅层猜测”与“深度思考”，是衡量顶尖模型推理能力的关键指标，具体示例如图5所示。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d46f33553c994ed2900ad90653575693~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=dwNv4NzBFWPQfsEinnQS4Yjs%2B7A%3D" alt="图6：通用评分模型训练流程图" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2465e5447ea44929827af2a1dfd6e17f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=d4ApAT21Wp5h5HxRfq154ZrN0hk%3D" alt="图7：通用评分模型的问题类型定义（说明：该图表展示了为提高评分准确率而定义的六种细分问题类型及其判断标准。）" loading="lazy"/></p>
<p>为实现自动化评估，LongCat团队还提出了一个通用评分模型，通过对问题类型进行细分（如图7所示），并结合人工和自动标注多轮质量迭代的数据集（如图6所示），使其能够支持6种通用问题类型的自动评分，在分布外的模型和基准测试中达到了95%的准确率。</p>
<h2 data-id="heading-6">03. 实验与分析：揭示全模态大模型的真实能力与演进规律</h2>
<p>LongCat团队在UNO-Bench上对包括Qwen、Baichuan、MiniCPM以及Gemini系列在内的多款主流全模态大模型进行了全面评测。实验设计旨在回答三个核心问题：</p>
<ol>
<li>当前全模态大模型的智能水平及其短板何在？</li>
<li>单模态与全模态能力之间存在何种关系？</li>
<li>UNO-Bench作为一站式评估方案的有效性如何？</li>
</ol>
<h3 data-id="heading-7">3.1 模型性能的全面剖析</h3>
<p><strong>总体格局：闭源模型优势显著，开源模型仍在追赶</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1945c0c76ee045739a944902e3087240~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=UEDvCd%2FI1gcddtUdHakpNuo%2B8XA%3D" alt="表格2：各全模态大模型在UNO-Bench上的评测结果（说明：表格展示了各模型在单模态（音频、视觉）和全模态（选择题Omni-MC、多步开放式题Omni-MO）上的得分。）" loading="lazy"/></p>
<p>如表格2所示，在本次评测的开源模型中，LongCat-Flash-Omni表现出开源SOTA（State-of-the-Art）的成绩。该模型在音频（80.20）、视觉（67.06）、全模态选择题（49.90）以及全模态开放题（42.68）四大核心维度上，全面超越了本次评测中的其他开源模型。</p>
<p>与此同时，以Gemini系列为代表的闭源模型在所有评测维度上，特别是在顶尖性能层面，依然保持着领先优势，其中Gemini-2.5-Pro稳居行业标杆。当面对难度更高的“多步开放式问题”（Omni-MO）时，所有模型的性能普遍下滑，这清晰地反映出，长链条、跨模态的深度推理依然是整个AI领域亟待攻克的难题。</p>
<p><strong>能力拆解：推理是区隔强弱的核心维度</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f99e279673d2461fb6917148dbf3c2f3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=1NUambXSfqefIQQWw1Y%2Fl1D1Vxs%3D" alt="表格3： 基于能力体系的跨模态表现分析" loading="lazy"/></p>
<p>通过对感知与推理能力的细化分析（见表格3），我们发现：</p>
<ul>
<li>感知层面，跨模态同步对齐比单纯的跨模态识别更具挑战。</li>
<li>推理层面，空间推断是所有子任务中最难的一项，即使是表现最佳的Gemini-2.5-Pro得分也仅为45分。</li>
</ul>
<p>综合来看，模型的感知能力相对较强，而真正的性能差距主要体现在推理能力上。以Qwen-3-Omni-30B与Gemini-2.5-Pro为例，两者在感知能力上相差23分，但在推理能力上的差距则拉大到33分，这表明：推理能力是划分模型强弱的关键分水岭。</p>
<p><strong>顶尖梯队与人机对比剖析</strong></p>
<p>LongCat团队进一步对Gemini-2.5-Pro的卓越表现进行了剖析。一方面，这得益于其强大的单模态基础能力；另一方面，其内置的语音转写并自然融入推理链路的能力，是多数开源模型尚不具备的。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/37d800370f5b4490b078f2997b7fe192~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=ybpKKcB%2FmW93Ml6SntXTWBbqfb0%3D" alt="图8：Gemini-2.5-Pro评测过程示例（说明：该图展示了Gemini-2.5-Pro利用音频转录文本辅助解决问题的过程。）" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f758d012e03481488d60d8df5be7825~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=b8JiLAFl1ZXo7Jzu9Fb8OnnoFXc%3D" alt="图9：人类专家与Gemini-2.5-Pro性能对比图" loading="lazy"/></p>
<p>说明: Gemini-2.5-Pro在感知能力上与人类相当，但在推理能力上仍有差距。</p>
<p>如图9所示，观察到一个有趣的现象：</p>
<ol>
<li>感知能力媲美人类：在全模态的感知任务上，Gemini-2.5-Pro的表现已能与人类专家相当。</li>
<li>推理能力仍存差距：然而，在更复杂的推理任务上，人类专家（81.3%）的表现依然优于Gemini-2.5-Pro（74.3%）。这揭示了AI与人脑在抽象归纳和复杂逻辑处理能力上的本质区别。</li>
</ol>
<h3 data-id="heading-8">3.2 全模态与单模态的内在关联</h3>
<p>得益于UNO-Bench统一的能力体系与高质量数据，通过回归与消融实验，揭示了单、全模态能力间的深刻关系。</p>
<p><strong>“组合定律”成立，且遵循幂律协同</strong></p>
<p>我们对各模型的单、全模态得分进行了回归分析，发现了一个强关联性，并将其形式化为一个科学定律。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1837fbe77ce140fd938532c9b71281f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=cX0zfBOgYaHdaziIk0cWO9W%2Bi%2F8%3D" alt="图10：全模态能力的组合定律关系图" loading="lazy"/></p>
<p>如图10所示，全模态的性能并非单模态能力的简单线性叠加，而是遵循一种乘积规律。通过严谨的数学推导和非线性拟合，得到了一个拟合度高达**97.59%**的幂律公式：</p>
<blockquote>
<p>POmni ≈ 1.0332 · (PA × PV)^2.1918 + 0.2422</p>
</blockquote>
<p>该幂律公式的指数大于1，使得函数曲线呈现为一条加速上升的凸形。这完美地解释了两种现象的涌现：</p>
<ol>
<li>短板效应 (Bottleneck Effect)：对于能力较弱的模型，其全模态性能的增长相对平缓。</li>
<li>协同增益 (Synergistic Promotion)：对于顶尖模型，单模态能力的增强会带来全模态性能的爆发式增长，实现了真正意义上的“1+1 &gt;&gt; 2”的多模态协同增益。</li>
</ol>
<p><strong>更重要的是，这个“组合定律”提供了一种全新的、跨越模型规模的分析范式</strong>。它允许研究人员将不同参数规模、不同架构的模型放置在同一个坐标系下进行比较，不再仅仅关注各自的绝对得分，而是通过它们在幂律曲线上的相对位置，来统一度量其“模态融合效率”。一个模型如果显著高于拟合曲线，则意味着其模态融合机制更为高效；反之，则可能存在融合瓶颈。这为评估和优化全模态大模型的内在融合能力，提供了一个极具价值的分析工具。</p>
<p>从图10的具体模型分布来看，其中参与拟合的模型由圆点表示，新增的LongCat-Flash-Omni模型表现较为突出。虽然Gemini系列的具体参数规模未知，但可以观测到LongCat-Flash-Omni的表现已非常接近Gemini-2.5-Flash，并显著领先于Qwen3-Omni-30B。其位置正处于曲线加速上升的“协同增益区”，且与理论拟合曲线高度吻合，这表明该模型展现出了高效的多模态融合能力。</p>
<p><strong>消融实验验证</strong></p>
<p>这再次印证了多通道互补与融合是通往更高智能的必经之路。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1664addd39de43228d02a216ee417bb3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=HDWFJkrZeeB1F02oVFDW%2B%2BTvmeI%3D" alt="表格4：视觉理解能力消融实验结果" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1784ce86391b495b85e865717f361302~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=fQlxhRPHOILdZSh6Oyho8nu6cHY%3D" alt="表格5：音频理解能力消融实验结果" loading="lazy"/></p>
<p>LongCat团队通过详尽的视觉与音频消融实验（具体数据参见表格4、5）进一步验证了这些发现。实验表明，对于多数模型，提供文本描述（Caption/ASR）比直接处理原始视听信息能获得更好的效果，但顶尖模型如Gemini-2.5-Pro则能从原始信号中提取比文本更丰富的信息。</p>
<h3 data-id="heading-9">3.3 UNO-Bench基准的有效性验证</h3>
<p>除了核心的实验发现，UNO-Bench作为一个评测基准本身的科学性和有效性，也通过以下几个方面得到了验证。</p>
<p><strong>多步开放式问题的卓越区分度</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95707f05b6cb429099fe87c59b60035d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=Upevlj9cxD5kU9Lf1R7FQ3yxzlc%3D" alt="表格6：各模型在多步开放式问题（MO）上的表现" loading="lazy"/></p>
<p>如表格6所示，创新的MO题型能够真实地刻画模型在长链条推理中的能力衰减，有效放大了模型间的认知鸿沟。</p>
<p><strong>高效的数据集压缩算法</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9ec312163e7846b6adea77b19f2c237f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=k5fFZExhNj3b%2BTV2YZrmSNPJ04w%3D" alt="图11：数据集压缩性能评估图" loading="lazy"/></p>
<p>如图11所示，我们设计的聚类引导抽样法，能在保持模型排名一致性（SRCC/PLCC &gt; 0.98）的前提下，将评测算力消耗降低超过90%，实现了效率与准确性的平衡。</p>
<p><strong>卓越的数据质量与区分度</strong></p>
<p>一个评测基准的有效性，最终体现在其数据的质量和区分模型优劣的能力上。UNO-Bench在这两方面都表现出色。</p>
<ul>
<li>首先，在数据质量上，如前文表格1所示，UNO-Bench的全模态数据集问题准确率达到了100%，且有高达98%的问题被严格设计为必须跨模态才能解答，这确保了评测的公平性和对模型真实能力的有效检验。</li>
<li>其次，在区分度上，UNO-Bench的设计能够清晰地揭示不同模型间的性能梯度。</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6078c3b3d4a3440fb54e1c52b7f8455b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=nfGKSUupCyG7eztPKTWjeXa0lP8%3D" alt="图12：UNO-Bench与其他全模态基准对比图" loading="lazy"/></p>
<p>而在与其他全模态基准的直接对比中（如图12所示），UNO-Bench的有效性也得到了进一步验证。它不仅通过更高的得分标准差（19.5 vs. 12.75）展现了比OmniBench更强的区分能力，还通过合理的难度设置，避免了像AV-Odyssey那样所有模型得分被压缩在狭窄低分区间的窘境。这确保了UNO-Bench既能有效评估当前模型，也为未来更强模型的涌现预留了足够的成长空间，是一个更可靠和富有洞察力的评测工具。</p>
<h2 data-id="heading-10">04. 总结与展望</h2>
<p>本文提出了一站式全模态大模型评测基准——UNO-Bench。该基准通过科学的评测框架，首次揭示了多模态智能并非简单的线性叠加，而是遵循着一种乘积规律，这一规律在能力较弱的模型上体现为瓶颈限制，而在顶尖模型上则表现为协同增益的特性，这个全模态大模型的“组合定律”为行业提供了一种全新的、跨越模型规模的分析范式。LongCat团队的评测结果进一步表明，以Gemini为代表的闭源模型在单模态及跨模态理解上仍远超主流开源阵营，其顶配版本虽在感知能力上已逼近人类专家，但在复杂的推理层面仍存在亟待突破的空间。而这些发现，正是得益于UNO-Bench自身的较高的数据质量与创新的评价机制，它有效扩展了模型表现的区分度，为新一代智能体的持续成长奠定了坚实基础。</p>
<p>面向未来，LongCat团队将通过自动化人机共建流程持续扩充数据规模，引入STEM、Code等更具挑战性的场景，并深入探索模态间的互动关系，为下一代通用人工智能的发展开辟新路径。</p>
<p><strong>开源资源</strong></p>
<ul>
<li><strong>GitHub</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmeituan-longcat%2FUNO-Bench" target="_blank" title="https://github.com/meituan-longcat/UNO-Bench" ref="nofollow noopener noreferrer">github.com/meituan-lon…</a></li>
<li><strong>Hugging Face</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fdatasets%2Fmeituan-longcat%2FUNO-Bench" target="_blank" title="https://huggingface.co/datasets/meituan-longcat/UNO-Bench" ref="nofollow noopener noreferrer">huggingface.co/datasets/me…</a></li>
<li><strong>论文下载</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmeituan-longcat%2FUNO-Bench%2Fblob%2Fmain%2FUNO-Bench.pdf" target="_blank" title="https://github.com/meituan-longcat/UNO-Bench/blob/main/UNO-Bench.pdf" ref="nofollow noopener noreferrer">github.com/meituan-lon…</a></li>
</ul>
<p>| 关注「美团技术团队」微信公众号，在公众号菜单栏对话框回复【2024年货】、【2023年货】、【2022年货】、【2021年货】、【2020年货】、【2019年货】、【2018年货】、【2017年货】等关键词，可查看美团技术团队历年技术文章合集。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1324c3f8b2974fbdac45cd334e5e5e32~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg576O5Zui5oqA5pyv5Zui6Zif:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763968197&amp;x-signature=Ewjob7lFhjwvnDkvA7L6EFdky2E%3D" alt="" loading="lazy"/></p>
<p>| 本文系美团技术团队出品，著作权归属美团。欢迎出于分享和交流等非商业目的转载或使用本文内容，敬请注明“内容转载自美团技术团队”。本文未经许可，不得进行商业性转载或者使用。任何商用行为，请发送邮件至 <a href="https://link.juejin.cn?target=mailto%3Atech%40meituan.com" target="_blank" title="mailto:tech@meituan.com" ref="nofollow noopener noreferrer">tech@meituan.com</a> 申请授权。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Swift 应用加密工具的全面方案，从源码混淆到 IPA 成品加固的多层安全实践]]></title>    <link>https://juejin.cn/post/7573486671296102442</link>    <guid>https://juejin.cn/post/7573486671296102442</guid>    <pubDate>2025-11-17T07:12:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573486671296102442" data-draft-id="7573180788579401769" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Swift 应用加密工具的全面方案，从源码混淆到 IPA 成品加固的多层安全实践"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-17T07:12:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="iOS开发上架哦"/> <meta itemprop="url" content="https://juejin.cn/user/3336394949004844"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Swift 应用加密工具的全面方案，从源码混淆到 IPA 成品加固的多层安全实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3336394949004844/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    iOS开发上架哦
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T07:12:13.000Z" title="Mon Nov 17 2025 07:12:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Swift 项目的安全工作常被误解为“编译器已经做了优化，不会轻易被逆向”。
现实是：<strong>Swift 二进制仍然保留大量可读符号、类名、属性名以及可追踪的结构信息</strong>。
只要拿到 IPA，逆向人员仍能通过 Hopper / IDA / Frida 快速还原业务逻辑。</p>
<p>因此，对 Swift 应用进行加密/加固需要建立在“多工具组合、多层防护”的基础上，而非依赖单一方案。
本文以工程实践为核心，为开发者介绍 Swift 加固工具的职责划分、流程设计与可复制的命令级方案。</p>
<hr/>
<h2 data-id="heading-0">一、Swift 项目的三层安全架构（源码层 → 成品层 → 运行时层）</h2>
<h3 data-id="heading-1"><strong>1. 源码层（编译前）</strong></h3>
<p>主要解决 Swift 模块暴露的符号问题。
适用工具与方案：</p>
<ul>
<li><strong>Swift Shield</strong>：对 Swift 类/方法/属性进行符号重命名。</li>
<li><strong>obfuscator-llvm</strong>：在编译期进行控制流混淆、字符串加密（深度最高）。</li>
<li><strong>自定义脚本处理敏感字符串</strong>：对密钥、接口地址进行简单不可逆转换。</li>
</ul>
<p>源码混淆属于“深度保护”，在可控项目中效果最好，但并非所有团队都有源码权限。</p>
<hr/>
<h3 data-id="heading-2"><strong>2. 成品层（IPA 层）</strong></h3>
<p>用于无法修改源码、外包交付、二次加固或对上线包补充保护。</p>
<p>核心工具：</p>
<ul>
<li><strong>Ipa Guard（命令行版）</strong>
<ul>
<li>无需源码</li>
<li>可直接对 IPA 执行 Swift/ObjC 符号混淆</li>
<li>支持导出符号、编辑混淆策略、资源扰动（图片 MD5、JS 文件名等）</li>
<li>具备 CLI，可自动化纳入发布流水线</li>
</ul>
</li>
</ul>
<p>这种方式非常适合“Swift 项目 + 外包交付 + 要求简单稳定的商业混淆策略”的团队。</p>
<hr/>
<h3 data-id="heading-3"><strong>3. 运行时层（动态对抗）</strong></h3>
<p>Swift 项目在运行时同样需要保护，尤其是：</p>
<ul>
<li>Frida 注入</li>
<li>动态 Hook</li>
<li>调用替换</li>
<li>越狱环境运行</li>
</ul>
<p>常用的运行时工具：</p>
<ul>
<li><strong>Frida 自测脚本</strong>：用于验证防护是否有效</li>
<li><strong>轻量级反调试代码</strong></li>
<li><strong>二次启动校验（完整性校验）</strong></li>
</ul>
<p>运行时不属于“加密工具本体”，但属于 Swift 项目最常忽略的安全环节。</p>
<hr/>
<h2 data-id="heading-4">二、Swift 应用常用加固工具对比</h2>





















































<table><thead><tr><th>工具</th><th>层级</th><th>优势</th><th>限制</th></tr></thead><tbody><tr><td><strong>Swift Shield</strong></td><td>源码层</td><td>专为 Swift 设计，编译集成稳定</td><td>需源码，不能处理第三方产物</td></tr><tr><td><strong>obfuscator-llvm</strong></td><td>编译层</td><td>控制流混淆最深，逆向难度最高</td><td>改动大，需完整源码与构建链</td></tr><tr><td><strong>自定义字符串加密脚本</strong></td><td>源码层</td><td>保护敏感常量</td><td>防护强度有限</td></tr><tr><td><strong>Ipa Guard CLI</strong></td><td>成品层</td><td>无需源码即可混淆 Swift 符号和资源，可自动化</td><td>需谨慎配置符号策略</td></tr><tr><td><strong>MobSF / class-dump</strong></td><td>分析层</td><td>快速识别泄露符号、反编译点</td><td>不参与混淆，仅分析</td></tr><tr><td><strong>kxsign / Fastlane</strong></td><td>分发层</td><td>自动化重签与真机测试</td><td>不提供安全性本体</td></tr><tr><td><strong>Frida / Hopper</strong></td><td>动态层</td><td>安全验证与逆向测试</td><td>属于攻击工具，需要团队自测</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-5">三、Swift 项目的工程化加固流程（推荐）</h2>
<h3 data-id="heading-6"><strong>Step 1：静态分析，找出 Swift 可读符号</strong></h3>
<pre><code class="hljs language-bash" lang="bash">class-dump app.ipa &gt; symbols.txt
</code></pre>
<p>MobSF 也能扫描出敏感文件、Swift 模块结构、资源引用。</p>
<p>目的：
✔ 找出不能混淆的符号（桥接方法、Storyboard、协议回调）
✔ 提供编译或成品混淆策略依据</p>
<hr/>
<h3 data-id="heading-7"><strong>Step 2：若能修改源码，优先做 Swift 编译期混淆</strong></h3>
<p>示例（Swift Shield）：</p>
<ul>
<li>配置类名/属性名映射</li>
<li>在 Xcode 构建步骤中加入 Swift Shield</li>
<li>重新编译并全量回归</li>
</ul>
<blockquote>
<p>若无源码权限，直接进入 Step 3。</p>
</blockquote>
<hr/>
<h3 data-id="heading-8"><strong>Step 3：使用 Ipa Guard 执行 Swift 成品符号混淆</strong></h3>
<h4 data-id="heading-9">1. 导出可混淆符号清单</h4>
<pre><code class="hljs language-bash" lang="bash">ipaguard_cli parse App.ipa -o sym.json
</code></pre>
<p><code>sym.json</code> 会列出：</p>
<ul>
<li>Swift 类名</li>
<li>Swift 方法（含参数标识）</li>
<li>资源引用（如 js、bundle、asset）</li>
<li>需要谨慎处理的文件引用（fileReferences）</li>
</ul>
<h4 data-id="heading-10">2. 编辑策略（SYMBOL RULES）</h4>
<ul>
<li>禁止混淆的符号：</li>
</ul>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"confuse"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span>
</code></pre>
<ul>
<li>修改 Swift 符号映射：</li>
</ul>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"refactorName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"aBcD1234"</span>   <span class="hljs-comment">// 必须长度一致</span>
</code></pre>
<ul>
<li>若符号出现在 H5/JS 字符串中需同步替换</li>
</ul>
<h4 data-id="heading-11">3. 直接混淆 IPA</h4>
<pre><code class="hljs language-bash" lang="bash">ipaguard_cli protect App.ipa -c sym.json --email team@company.com --image --js -o App_protected.ipa
</code></pre>
<p>参数：</p>
<ul>
<li><code>--image</code> → 修改 Swift Bundle 和 App 资源的 MD5</li>
<li><code>--js</code> → 防止 WebView/混合应用资源泄露</li>
<li><code>-c</code> → 指定我们刚编辑的策略</li>
<li><code>--email</code> → CLI 登录验证</li>
</ul>
<hr/>
<h3 data-id="heading-12"><strong>Step 4：重签名与功能验证（关键）</strong></h3>
<pre><code class="hljs language-bash" lang="bash">kxsign sign App_protected.ipa \
  -c dev_cert.p12 \
  -p 123456 \
  -m dev.mobileprovision \
  -z App_signed.ipa \
  -i
</code></pre>
<p>测试重点：</p>
<ul>
<li>SwiftUI/Storyboard 是否正常</li>
<li>混淆后的模块是否仍能加载</li>
<li>支付、账号体系、SDK 初始化是否正常</li>
<li>真机冷启动速度是否保持稳定</li>
</ul>
<hr/>
<h3 data-id="heading-13"><strong>Step 5：动态验证（逆向成本评估）</strong></h3>
<p>使用 Frida：</p>
<pre><code class="hljs language-bash" lang="bash">frida -U -f com.company.app --no-pause -l hook.js
</code></pre>
<p>观察：</p>
<ul>
<li>混淆后的 Swift 符号是否可读？</li>
<li>Hook 关键函数是否困难？</li>
<li>Hopper 中的符号可视化是否显著下降？</li>
</ul>
<p>这部分用于验证加固效果。</p>
<hr/>
<h3 data-id="heading-14"><strong>Step 6：映射表治理（重要）</strong></h3>
<p>混淆映射必须：</p>
<ul>
<li>上传到 KMS 或 HSM（加密存储）</li>
<li>与版本号绑定</li>
<li>解密需要审批（开发/运维双人）</li>
<li>用于 Sentry/Bugly 崩溃符号化</li>
</ul>
<p>没有治理，就无法快速定位线上问题。</p>
<hr/>
<h2 data-id="heading-15">四、Swift 项目的常见加固风险点</h2>
<ul>
<li>Swift 模块名混淆错误 → App 无法启动</li>
<li>Storyboard id 被混淆 → 页面崩溃</li>
<li>Swift Protocol Selector 被误改 → 事件不触发</li>
<li>JS/H5 引用未同步修改 → WebView 白屏</li>
<li>混淆后 App 脱离签名 → 启动闪退</li>
<li>映射表丢失 → 崩溃分析无法恢复原始函数</li>
</ul>
<p>以上都是工程团队最常踩的坑。</p>
<hr/>
<h2 data-id="heading-16">Swift 安全加固不是“某个工具”，而是“体系”</h2>
<p>Swift 项目加固 =<strong>源码混淆 + 成品混淆 + 资源扰动 + 重签验证 + 动态对抗 + 映射治理</strong></p>
<p>推荐工具组合：</p>
<ul>
<li><strong>Swift Shield / obfuscator-llvm（深度）</strong></li>
<li><strong>Ipa Guard CLI（无源码 &amp; 成品层）</strong></li>
<li><strong>MobSF / class-dump（分析）</strong></li>
<li><strong>kxsign / Fastlane（发布链路）</strong></li>
<li><strong>Frida / Hopper（验证）</strong></li>
<li><strong>KMS + Sentry（治理）</strong></li>
</ul>
<p>落地后，无论是内部项目、外包交付还是闭源商业 App，都能建立稳定、可回滚、可审计的加固链路。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[国内也有 GPT 质感的 App 了，阿里做到了。]]></title>    <link>https://juejin.cn/post/7573310642959220774</link>    <guid>https://juejin.cn/post/7573310642959220774</guid>    <pubDate>2025-11-17T06:51:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573310642959220774" data-draft-id="7573234521364414490" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="国内也有 GPT 质感的 App 了，阿里做到了。"/> <meta itemprop="keywords" content="人工智能"/> <meta itemprop="datePublished" content="2025-11-17T06:51:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="苍何"/> <meta itemprop="url" content="https://juejin.cn/user/588993963763405"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            国内也有 GPT 质感的 App 了，阿里做到了。
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993963763405/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    苍何
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:51:23.000Z" title="Mon Nov 17 2025 06:51:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>这是苍何的第 450 篇原创！</p>
<p>大家好，我是苍何。</p>
<p>近日，阿里正式推出基于 Qwen 大模型的千问 APP，一款被视为可以与 GPT 正面竞争的国产个人 AI 应用。</p>
<p>这也代表着阿里全力进军 AI 原生应用市场。</p>
<p>我第一时间也去做了体验测试，你还别说，这次阿里一改往日什么都想要的风格，整个界面异常简洁，只聚焦在对话上。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8135febfada84fa48c811e1a17380c8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=VPmrmjheiVbTF7CNR8v05Kv9WMw%3D" alt="图片" loading="lazy"/></p>
<p>这很不阿里。</p>
<p>但也正因「极简」，它的核心体验才做的特别好，不仅主模型升级成了 Qwen 家族最强的旗舰模型，思维链、回答的结构化都做的非常棒，甚至还能直接生成可视化图表。</p>
<p>废话不多说，今天就来盘盘，这个被阿里寄予厚望的 APP，到底如何。</p>
<p>可以看到主对话模型为 Qwen3-千问和 Qwen3-Max，用户可自由选择。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ce5a12d90e54caa85184311183aa8c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=D0%2FJ3cf2IEDFE3kNwWdpOvJ7lCg%3D" alt="图片" loading="lazy"/></p>
<blockquote>
<p>但据说内部集成了 Qwen 3-VL、Qwen 3-Coder、Qwen-Image、Qwen 3-Omni 多款世界顶尖模型。</p>
</blockquote>
<p>先来一个需要深度思考的任务，在 Chat 上选择「深度思考」，输入以下问题：</p>
<pre><code class="hljs">在全球人口老龄化加剧、医疗资源分配不均且 AI 技术快速迭代的背景下，若要构建一套兼顾医疗公平性、数据隐私安全、伦理边界（如生命自主权、算法偏见）与经济可持续性的 AI 辅助养老医疗系统，你认为核心设计逻辑应如何搭建？
请结合技术可行性（如边缘计算、联邦学习的应用）、政策监管框架、不同地区的经济与文化差异，以及可能出现的社会矛盾（如人机信任危机、传统医疗从业者的职业转型），
说明关键决策点与妥协方案，并预判该系统落地后 5 年内可能引发的新社会问题及应对思路。
</code></pre>
<p>结果如下，整个回答的很全面，逻辑性很强。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e29be69478334fa48de940fd692f8878~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=JDuAt10azVK%2B8OKtp4HGpPceHNE%3D" alt="图片" loading="lazy"/></p>
<p>当我把周末橘子烧烤的图片丢进千问 APP，选择「AI 修图」，用嘴来修改图片中局部元素信息。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d4d09dc9193842d09501d9cd67821d1d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=7bC3xJSheUCQEGtk77n%2BZ2HDVVg%3D" alt="图片" loading="lazy"/></p>
<p>你还别说，一次就很好的给橘子带了个很 cute 的帽子。</p>
<p>还可以直接换个背景，来一场雪地烧烤，哈哈哈：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7f74a446ccc84e4c826a24b9602ea628~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=d3g5qb95pmf4sS73NYxApHMsXVE%3D" alt="图片" loading="lazy"/></p>
<p>在改完图片后，可以基于图片来创作视频，可以选择场景模板，也可以提示词描述场景。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/900be2984dd04cb1b05a8c688a171af2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=kD9R4YRj8or5v1SWuUEaAvbuBWI%3D" alt="图片" loading="lazy"/></p>
<p>然后出来了一个特别好玩的视频，声音和音效都完美配上了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/89936acb4f034433b0a1785db6bf2b01~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=JKv7jtKgw19bhtc%2FECkThj7dgjM%3D" alt="wxv_4256493013809348616" loading="lazy"/></p>
<p>我测试下来，都可以直接使用，不需要积分什么的，感觉在千问 APP 上制作 AI 视频，速度更快了。</p>
<p>我最喜欢的是上面的同传翻译功能，比如在和老外会议或者听外教时，这个功能是真的爽，她说她的英语，我看的我的中文。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9df386e1bacf46bc91f8c8cf8a8b96fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=SD8qPUOgepmPvgnWGJu3x3cyIfg%3D" alt="图片" loading="lazy"/></p>
<p>同传翻译的内容可以直接保存，非常方便。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9c24ee6ae52f4c1082af2d6896a0f319~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=UYhttTzm9XLVHVL6%2BDT%2FIAbTTy8%3D" alt="图片" loading="lazy"/></p>
<p>以前在开会的时候，经常会用到通义听悟的录音及转写能力，但很多时候，电脑并不在身边。</p>
<p>现在在千问 APP 中也能直接录音，支持现场录音和手机音频录音，还能边录边翻译，非常实用的能力了。</p>
<p>我录了个视频，你可以感受一下。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/16e84033058547369a58e49edf98e598~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=6IDVh1YYz%2FVD2vUBGMQT8l0MSxw%3D" alt="wxv_4256491537212637197" loading="lazy"/></p>
<p>这个功能特别是在听一些国外直播的时候，就非常有用，直播实时翻译还没做的非常丝滑的。千问 APP 的这个玩法，非常棒。</p>
<p>当我点击「PPT 制作」，会发现千问又化身 PPT 制作小能手，快速棒生成 PPT，还能指定选择模板，快速导出。</p>
<pre><code class="hljs">帮我生成PPT，主题及要求：关于ai agent的ppt 
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1c4c9f66e1a4026a4b9b203294e0f93~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=GCIhd8seuh6RseuaPXEKgb78CQI%3D" alt="图片" loading="lazy"/></p>
<p>看了下，效果还不错，内容完善。</p>
<p>在写作上，当我点击「智能写作」，能帮我自动写报告、发言稿、申请书、论文、小红书笔记、朋友圈文案等常用场景。</p>
<p>比如我让他写一篇小红书笔记，就很快出来效果：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c7ceba6b23214e34b0636ad0f169fc21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=xAJPHPzFWGcH0nevl%2FZ5fi3oTnM%3D" alt="图片" loading="lazy"/></p>
<p>最后，还测了千问 APP 的「文档解读」能力，可以上传本地文件，也可以上传微信聊天记录文件，生成想要格式的文档解读。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/83ad8ec308e540b2a56bc72c5d11d657~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=SyhWVuOf0lSg2gX%2BGHpH0Bs08uY%3D" alt="图片" loading="lazy"/></p>
<p>还蛮有意思的，千问 APP 虽然界面更简洁了，但可以说是 All in One 的存在，能想到的不能想到的实用功能，通通都满足了。</p>
<p>千问 App 这次确实给了我一个惊喜，它证明了国产也能做出一个专注、好用、有国际范儿的 AI 产品。 </p>
<p>也难怪千问 App 发布同一时期，英国《金融时报》突然爆料，说拿到了一份所谓的美国白宫“绝密”备忘录，指控阿里“为军方提供技术支持”。</p>
<p>好家伙，帽子扣得一个比一个大。但搞笑的是，连《金融时报》自己都承认，这些指控他们无法独立核实。</p>
<p>这让我觉得很感慨。</p>
<p>一方面，我们的企业在努力做出能与世界抗衡的好产品、好技术；另一方面，却要时刻提防着来自外界的明枪暗箭。 </p>
<p>技术上的追赶已经够难了，没想到在国际舆论场上，还有一场更硬的仗要打。国产 AI 的崛起之路，注定不会平坦。  </p>
<p>不过三年来，阿里深耕 AI 技术研发，将 Qwen 打造成全球第一开源模型。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/784ed29a1c2948a58a4543270213d485~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=1fQnBX5680UJwE9EdJEBLI6vboY%3D" alt="图片" loading="lazy"/></p>
<p>9 月的一个 Hugging Face 趋势榜，阿里旗下 7 款模型跻身全球前十开源模型榜单，几乎实现了“屠榜”。</p>
<p>也因此，千问一直被称为是 AI 界的源神，目前，通义千问 Qwen 全球下载量超 6 亿，衍生模型数量已突破 17 万，超越美国 Llama 模型，成为全球第一 AI 开源模型。</p>
<p>在首届 AI 模型交易大赛中，Qwen3 Max 排名第一，收益率为 22.3%，其余模型均大幅亏损。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cc71ba65cbf4768b5117844c1ff3aab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6IuN5L2V:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763967083&amp;x-signature=3Xz%2BjGTN67lXTBhbUjNoLMtGYg4%3D" alt="图片" loading="lazy"/></p>
<p>千问 APP 的发布代表着阿里正式进军 AI 原生应用市场，开始面向更多的 C 端用户，通过 C 端配合整个开源生态，去走 B 端市场。</p>
<p>这一步棋，我想阿里酝酿了很久。</p>
<p>体验下来，这一步确实走得很扎实。</p>
<p>好了，今天的文章就到这，感谢你的阅读，我们下一期见。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么我的页面布局总是乱糟糟？可能是浮动和BFC在作怪！]]></title>    <link>https://juejin.cn/post/7572481101711294518</link>    <guid>https://juejin.cn/post/7572481101711294518</guid>    <pubDate>2025-11-16T10:20:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572481101711294518" data-draft-id="7572493520004071458" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="为什么我的页面布局总是乱糟糟？可能是浮动和BFC在作怪！"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2025-11-16T10:20:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户28320967937"/> <meta itemprop="url" content="https://juejin.cn/user/1787121370143162"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            为什么我的页面布局总是乱糟糟？可能是浮动和BFC在作怪！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1787121370143162/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户28320967937
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T10:20:16.000Z" title="Sun Nov 16 2025 10:20:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在前端开发中，你是否曾经遇到过这样的困扰：明明代码写得很规范，但页面元素就是不听话，到处乱跑？今天我们就来聊聊这个让无数前端开发者头疼的问题——浮动布局和它的救星BFC。</p>
<h2 data-id="heading-0">什么是文档流？</h2>
<p>在深入探讨问题之前，我们需要先了解浏览器默认的布局方式——文档流。</p>
<p>想象一下浏览器渲染页面就像我们写字一样，遵循着<strong>从上往下，从左往右</strong>的排列规则，这就是普通文档流。在这种流式布局中，元素按照它们在HTML中出现的顺序依次排列。</p>
<h2 data-id="heading-1">浮动布局：天使与魔鬼的结合体</h2>
<h3 data-id="heading-2">浮动的设计初衷</h3>
<p>浮动最初被创造出来，其实是为了实现一个简单而实用的效果——<strong>文字环绕图片</strong>，就像杂志排版那样优雅。</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-tag">img</span> {
  <span class="hljs-attribute">float</span>: left;
  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">15px</span>;
}
</code></pre>
<p>但随着网页设计的发展，开发者们发现浮动还可以用来实现<strong>多栏布局</strong>和<strong>水平排列元素</strong>，于是它便成了CSS布局的重要工具。</p>
<h3 data-id="heading-3">浮动的黑暗面</h3>
<p>然而，浮动的美好背后隐藏着一个巨大的陷阱——<strong>脱离文档流</strong>！</p>
<p>当一个元素被浮动时，它会从正常的文档流中被"抽离"出来，导致父容器无法感知它的存在，从而引发经典的<strong>高度塌陷</strong>问题。</p>
<p>想象一下这样的场景：</p>
<p>html</p>
<pre><code class="hljs language-ini" lang="ini">&lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;
  &lt;div <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span> style=<span class="hljs-string">"float: left;"</span>&gt;我是浮动元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>此时，父容器的高度会变成0，因为里面的浮动元素已经"飘"出去了，不在父容器的管辖范围内！</p>
<h4 data-id="heading-4">清除浮动：拯救布局的五大法宝</h4>
<p>面对浮动带来的布局灾难，前端开发者们探索出了多种解决方案：</p>
<h3 data-id="heading-5">1. 硬编码父容器高度 ❌</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.parent</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; <span class="hljs-comment">/* 不推荐 */</span>
}
</code></pre>
<p><strong>缺点</strong>：缺乏灵活性，内容变化时需要手动调整高度。</p>
<h3 data-id="heading-6">2. 添加空元素清理 ❌</h3>
<p>html</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"float: left;"</span>&gt;</span>浮动元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"clear: both;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 不推荐 --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><strong>缺点</strong>：增加了无意义的HTML元素，污染了文档结构。</p>
<h3 data-id="heading-7">3. 伪元素清除法 ✅</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
  <span class="hljs-attribute">display</span>: block;
  <span class="hljs-attribute">clear</span>: both;
}
</code></pre>
<p><strong>优点</strong>：语义清晰，无需额外HTML元素。</p>
<h3 data-id="heading-8">4. 受影响元素清除法 ❌</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.next-element</span> {
  <span class="hljs-attribute">clear</span>: both; <span class="hljs-comment">/* 不推荐 */</span>
}
</code></pre>
<p><strong>缺点</strong>：治标不治本，每个受影响的元素都需要单独处理。</p>
<h3 data-id="heading-9">5. 触发BFC ✅</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.parent</span> {
  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 创建BFC */</span>
}
</code></pre>
<p><strong>优点</strong>：一劳永逸，同时解决了其他布局问题。</p>
<h2 data-id="heading-10">BFC：布局世界的守护者</h2>
<h3 data-id="heading-11">什么是BFC？</h3>
<p>BFC（Block Formatting Context，块级格式化上下文）就像是页面中的一个<strong>独立王国</strong>，拥有自己的一套渲染规则，内部元素不会影响到外部元素。</p>
<h3 data-id="heading-12">如何创建BFC？</h3>
<p>创建BFC的方法多种多样：</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-comment">/* 任意一种即可 */</span>
  <span class="hljs-attribute">overflow</span>: hidden | auto | scroll;
  <span class="hljs-attribute">position</span>: absolute | fixed;
  <span class="hljs-attribute">float</span>: left | right;
  <span class="hljs-attribute">display</span>: inline-block | flex | grid;
}
</code></pre>
<h3 data-id="heading-13">BFC的三大超能力</h3>
<ol>
<li>
<p><strong>正常流排列</strong>：BFC内的元素依然按照从上往下、从左往右的顺序排列</p>
</li>
<li>
<p><strong>Margin折叠防护</strong>：解决了父子元素margin重叠的经典问题
html</p>
</li>
</ol>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span> <span class="hljs-comment">&lt;!-- 如果没有BFC，两个margin会重叠 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin-top: 50px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<ol start="3">
<li><strong>浮动元素收纳</strong>：BFC会自动计算内部浮动元素的高度，彻底解决高度塌陷问题</li>
</ol>
<h2 data-id="heading-14">实战演练：选择最佳方案</h2>
<p>在实际开发中，我强烈推荐两种方案：</p>
<h3 data-id="heading-15">方案一：伪元素清除法（兼容性好）</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;
  <span class="hljs-attribute">display</span>: table;
  <span class="hljs-attribute">clear</span>: both;
}
</code></pre>
<h3 data-id="heading-16">方案二：BFC方案（现代推荐）</h3>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 或者使用display: flow-root */</span>
}
</code></pre>
<p>特别是<code>display: flow-root</code>，它是专门为创建BFC而设计的属性，不会产生任何副作用：</p>
<p>css</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">display</span>: flow-root; <span class="hljs-comment">/* 创建BFC的最佳实践 */</span>
}
</code></pre>
<h2 data-id="heading-17">总结</h2>
<p>浮动布局虽然逐渐被Flexbox和Grid等现代布局技术所取代，但理解它的工作原理和相关问题仍然是前端开发者的必备技能。BFC作为解决浮动问题的利器，其价值不仅仅体现在清除浮动上，更在于它提供了一种隔离的布局环境。</p>
<p>记住，当你下次遇到布局问题时，不妨思考一下：是不是浮动在作怪？要不要请BFC来帮忙？</p>
<p>希望这篇文章能帮助你彻底理解浮动和BFC，让你的页面布局不再"飘忽不定"！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 Spring Bean 生命周期：从实例化到销毁]]></title>    <link>https://juejin.cn/post/7572697146287308850</link>    <guid>https://juejin.cn/post/7572697146287308850</guid>    <pubDate>2025-11-16T07:34:42.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572697146287308850" data-draft-id="7572749797468782601" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 Spring Bean 生命周期：从实例化到销毁"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-16T07:34:42.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OlahOlah"/> <meta itemprop="url" content="https://juejin.cn/user/1576016232062667"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 Spring Bean 生命周期：从实例化到销毁
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1576016232062667/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OlahOlah
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T07:34:42.000Z" title="Sun Nov 16 2025 07:34:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Spring 框架中，Bean 的生命周期是理解容器管理机制的核心。本文将通过图示和代码示例，详细解析 Spring Bean 从创建到销毁的完整流程，并解答常见疑问：是否可以在初始化前跳过属性赋值？</p>
<h2 data-id="heading-0">Bean 生命周期概览</h2>
<p>Spring Bean 的生命周期大致分为以下几个阶段：</p>
<ol>
<li><strong>实例化</strong>：通过构造方法创建 Bean 对象。</li>
<li><strong>属性赋值</strong>：为 Bean 的依赖和属性注入值。</li>
<li><strong>BeanNameAware</strong>：设置 Bean 名称。</li>
<li><strong>BeanFactoryAware</strong>：设置 BeanFactory。</li>
<li><strong>ApplicationContextAware</strong>：设置 ApplicationContext。</li>
<li><strong>初始化前处理</strong>：<code>BeanPostProcessor.postProcessBeforeInitialization</code>。</li>
<li><strong>@PostConstruct 注解方法</strong>：初始化逻辑执行。</li>
<li><strong>InitializingBean.afterPropertiesSet</strong>：属性设置完成后的回调。</li>
<li><strong>自定义 init 方法</strong>：通过 <code>@Bean(initMethod)</code> 指定。</li>
<li><strong>初始化后处理</strong>：<code>BeanPostProcessor.postProcessAfterInitialization</code>。</li>
<li><strong>Bean 使用阶段</strong>：Bean 已准备就绪，可用于业务逻辑。</li>
<li><strong>@PreDestroy 注解方法</strong>：销毁前回调。</li>
<li><strong>DisposableBean.destroy</strong>：销毁方法执行。</li>
<li><strong>自定义 destroy 方法</strong>：通过 <code>@Bean(destroyMethod)</code> 指定。</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dc41a47faafd45a98f4e6ce59e248a18~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgT2xhaE9sYWg=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763883346&amp;x-signature=zfF3OCOGIPLLZEWzskWbB3e%2FKAA%3D" alt="Spring Bean 生命周期" loading="lazy"/></p>
<h2 data-id="heading-1">代码示例</h2>
<h3 data-id="heading-2">1. 主配置类</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-variable">@Configuration</span>
<span class="hljs-variable">@ComponentScan</span>(<span class="hljs-string">"com.example.lifecycle"</span>)
public class AppConfig {
    <span class="hljs-variable">@Bean</span>(initMethod = <span class="hljs-string">"customInit"</span>, destroyMethod = <span class="hljs-string">"customDestroy"</span>)
    public ExampleBean <span class="hljs-built_in">exampleBean</span>() {
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ExampleBean</span>();
    }
}
</code></pre>
<h3 data-id="heading-3">2. Bean 生命周期类</h3>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> <span class="hljs-title">implements</span>
        <span class="hljs-title">BeanNameAware</span>,
        <span class="hljs-title">BeanFactoryAware</span>,
        <span class="hljs-title">ApplicationContextAware</span>,
        <span class="hljs-title">InitializingBean</span>,
        <span class="hljs-title">DisposableBean</span> {

    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExampleBean</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"1. Bean 实例化 - 构造函数执行"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(<span class="hljs-params">String name</span>)</span> {
        <span class="hljs-keyword">this</span>.name = name;
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"2. 属性赋值 - 设置属性值: "</span> + name);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span>(<span class="hljs-params">String name</span>)</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"3. BeanNameAware - Bean 名称: "</span> + name);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span>(<span class="hljs-params">BeanFactory beanFactory</span>) throws BeansException</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"4. BeanFactoryAware - 设置 BeanFactory"</span>);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span>(<span class="hljs-params">ApplicationContext applicationContext</span>) throws BeansException</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"5. ApplicationContextAware - 设置 ApplicationContext"</span>);
    }

    @PostConstruct
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postConstruct</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"7. @PostConstruct - 初始化方法"</span>);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span>() throws Exception</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"8. InitializingBean.afterPropertiesSet - 属性设置完成后"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customInit</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"9. 自定义 init 方法 - @Bean(initMethod)"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"11. Bean 使用中 - 业务方法执行"</span>);
    }

    @PreDestroy
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preDestroy</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"12. @PreDestroy - 销毁前方法"</span>);
    }

    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>() throws Exception</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"13. DisposableBean.destroy - 销毁方法"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customDestroy</span>()</span> {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"14. 自定义 destroy 方法 - @Bean(destroyMethod)"</span>);
    }
}
</code></pre>
<h3 data-id="heading-4">3. BeanPostProcessor 实现</h3>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> {
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ExampleBean</span>) {
            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"6. BeanPostProcessor.postProcessBeforeInitialization - 初始化前处理"</span>);
        }
        <span class="hljs-keyword">return</span> bean;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> {
        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ExampleBean</span>) {
            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"10. BeanPostProcessor.postProcessAfterInitialization - 初始化后处理"</span>);
        }
        <span class="hljs-keyword">return</span> bean;
    }
}
</code></pre>
<h3 data-id="heading-5">4. 测试类</h3>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleTest</span> {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>{
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"=== Spring Bean 生命周期演示 ==="</span>);
        
        AnnotationConfigApplicationContext context = 
            <span class="hljs-keyword">new</span> <span class="hljs-built_in">AnnotationConfigApplicationContext</span>(AppConfig.<span class="hljs-keyword">class</span>);
        
        ExampleBean exampleBean = context.<span class="hljs-built_in">getBean</span>(ExampleBean.<span class="hljs-keyword">class</span>);
        exampleBean.<span class="hljs-built_in">doSomething</span>();
        
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"=== 关闭 Spring 容器 ==="</span>);
        context.<span class="hljs-built_in">close</span>();
    }
}
</code></pre>
<hr/>
<h2 data-id="heading-6">输出结果</h2>
<pre><code class="hljs language-markdown" lang="markdown">=== Spring Bean 生命周期演示 ===
<span class="hljs-bullet">1.</span> Bean 实例化 - 构造函数执行
<span class="hljs-bullet">2.</span> 属性赋值 - 设置属性值: null
<span class="hljs-bullet">3.</span> BeanNameAware - Bean 名称: exampleBean
<span class="hljs-bullet">4.</span> BeanFactoryAware - 设置 BeanFactory
<span class="hljs-bullet">5.</span> ApplicationContextAware - 设置 ApplicationContext
<span class="hljs-bullet">6.</span> BeanPostProcessor.postProcessBeforeInitialization - 初始化前处理
<span class="hljs-bullet">7.</span> @PostConstruct - 初始化方法
<span class="hljs-bullet">8.</span> InitializingBean.afterPropertiesSet - 属性设置完成后
<span class="hljs-bullet">9.</span> 自定义 init 方法 - @Bean(initMethod)
<span class="hljs-bullet">10.</span> BeanPostProcessor.postProcessAfterInitialization - 初始化后处理
<span class="hljs-bullet">11.</span> Bean 使用中 - 业务方法执行
=== 关闭 Spring 容器 ===
<span class="hljs-bullet">12.</span> @PreDestroy - 销毁前方法
<span class="hljs-bullet">13.</span> DisposableBean.destroy - 销毁方法
<span class="hljs-bullet">14.</span> 自定义 destroy 方法 - @Bean(destroyMethod)
</code></pre>
<h2 data-id="heading-7">初始化前是否可以跳过属性赋值？</h2>
<p>答案是否定的。Spring 的设计理念是：</p>
<blockquote>
<p><strong>属性赋值必须在初始化阶段之前完成</strong></p>
</blockquote>
<p>原因如下：</p>
<ol>
<li>初始化逻辑通常依赖 Bean 已经注入的属性。</li>
<li>如果初始化方法提前执行，未注入属性可能导致 <code>NullPointerException</code> 或状态不完整。</li>
<li>Bean 的生命周期有严格顺序，确保每个阶段都能安全执行。</li>
</ol>
<p>因此，即便在 <code>@PostConstruct</code>、<code>InitializingBean.afterPropertiesSet</code> 或自定义初始化方法中访问 Bean 属性，也可以放心使用，不会出现未赋值的情况。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[try...catch 核心与生态协作全解析]]></title>    <link>https://juejin.cn/post/7572757056438534153</link>    <guid>https://juejin.cn/post/7572757056438534153</guid>    <pubDate>2025-11-16T13:32:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572757056438534153" data-draft-id="7568425510793068544" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content=" try...catch 核心与生态协作全解析"/> <meta itemprop="keywords" content="JavaScript,前端,Vue.js"/> <meta itemprop="datePublished" content="2025-11-16T13:32:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="拉不动的猪"/> <meta itemprop="url" content="https://juejin.cn/user/1429793504759630"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
             try...catch 核心与生态协作全解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1429793504759630/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    拉不动的猪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T13:32:23.000Z" title="Sun Nov 16 2025 13:32:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    16
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="" data-highlight-key="arta">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#222}.hljs-subst,.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#aaa}.hljs-section{color:#fff}.hljs-comment,.hljs-meta,.hljs-quote{color:#444}.hljs-bullet,.hljs-regexp,.hljs-string,.hljs-symbol{color:#fc3}.hljs-addition,.hljs-number{color:#0c6}.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-template-variable,.hljs-type{color:#32aaee}.hljs-keyword,.hljs-name,.hljs-selector-class,.hljs-selector-id,.hljs-selector-tag{color:#64a}.hljs-deletion,.hljs-template-tag,.hljs-title,.hljs-variable{color:#b16}.hljs-doctag,.hljs-section,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}</style><h2 data-id="heading-0">一、try...catch 本质：为何需要它？（从程序失控到可控）</h2>
<p>在 JavaScript 执行过程中，代码常因变量未定义、类型错误、API 调用失败等问题中断。若缺乏异常处理，同步代码会直接崩溃，异步代码会陷入不可预知状态。<code>try...catch</code> 的核心价值是<strong>将 “不可控的错误中断” 转化为 “可控的逻辑处理”</strong> ，避免程序崩溃并提供补救机会，是保障代码健壮性的基础机制。</p>
<h3 data-id="heading-1">1.1 无 try...catch 时的问题</h3>
<p>代码报错后直接终止，后续逻辑无法执行，影响用户体验。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'invalid json'</span>); <span class="hljs-comment">// 报错：Unexpected token i in JSON at position 0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'程序继续执行'</span>); <span class="hljs-comment">// 不会执行，代码中断</span>
</code></pre>
<h3 data-id="heading-2">1.2 有 try...catch 时的优化</h3>
<p>错误被捕获后，可执行补救逻辑，程序正常流转。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'invalid json'</span>);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'解析失败，使用默认数据'</span>); <span class="hljs-comment">// 执行补救操作</span>
  <span class="hljs-keyword">const</span> data = { <span class="hljs-attr">default</span>: <span class="hljs-string">'value'</span> }; 
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'程序继续执行'</span>); <span class="hljs-comment">// 正常执行，无中断</span>
</code></pre>
<h2 data-id="heading-3">二、try...catch 与核心技术的关联：从基础到扩展</h2>
<p><code>try...catch</code> 并非仅与 <code>Promise</code>、<code>axios</code> 相关，而是贯穿 JavaScript 全场景的通用机制，以下从核心关联、跨界场景两方面详细解析。</p>
<h3 data-id="heading-4">2.1 与 Promise、async/await 的底层关联</h3>
<p><code>try...catch</code> 本质是<strong>同步错误捕获工具</strong>，而 <code>Promise</code> 处理异步操作，二者需配合实现 “同步 + 异步” 全场景错误处理。</p>
<h4 data-id="heading-5">2.1.1 Promise 为何需要独立错误处理？</h4>
<p>异步代码（如定时器、网络请求）的错误发生在 “当前事件循环之外”，<code>try...catch</code> 无法直接捕获。<code>Promise</code> 设计 <code>.catch()</code> 方法，专门捕获异步执行中的错误（包括 <code>reject</code> 和执行器内同步错误）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// try...catch 无法捕获 Promise 内部异步错误</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'异步错误'</span>); <span class="hljs-comment">// 错误发生在定时器回调，属异步</span>
    }, <span class="hljs-number">100</span>);
  });
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获不到'</span>, error); <span class="hljs-comment">// 不执行</span>
}

<span class="hljs-comment">// 需用 Promise 的 .catch() 捕获</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'异步错误'</span>);
  }, <span class="hljs-number">100</span>);
}).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获到'</span>, error); <span class="hljs-comment">// 正常执行</span>
});
</code></pre>
<h4 data-id="heading-6">2.1.2 async/await 如何让 try...catch 接管异步错误？</h4>
<p><code>async/await</code> 是 <code>Promise</code> 语法糖，能将异步代码 “伪装” 成同步执行顺序，使 <code>try...catch</code> 可同时捕获 “同步错误” 和 “await 后的 Promise 错误”（<code>await</code> 等待 Promise 状态变更时，异步错误转化为 “等待阶段错误”）。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> function <span class="hljs-title">fetchData</span>()</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 同步错误：未定义变量</span>
    <span class="hljs-keyword">const</span> invalid = undefinedVariable; 
    <span class="hljs-comment">// 异步错误：axios 请求失败（返回 rejected Promise）</span>
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/invalid-api'</span>); 
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 同步、异步错误均被捕获</span>
    console.log(<span class="hljs-string">'捕获到所有错误：'</span>, error); 
  }
}
</code></pre>
<h3 data-id="heading-7">2.2 与 axios 的协作逻辑</h3>
<p><code>axios</code> 是基于 <code>Promise</code> 的 HTTP 客户端，其错误分两类，需通过 <code>try...catch</code> 或 <code>.catch()</code> 统一处理：</p>
<ul>
<li>网络错误（如断网）：直接触发 <code>reject</code>；</li>
<li>HTTP 错误（如 404/500）：默认触发 <code>reject</code>，可通过 <code>validateStatus</code> 配置修改。</li>
</ul>
<h4 data-id="heading-8">2.2.1 用 .catch () 处理 axios 错误</h4>
<pre><code class="hljs language-lua" lang="lua">axios.get(<span class="hljs-string">'/api/data'</span>)
  .<span class="hljs-keyword">then</span>(response =&gt; {
    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'请求成功:'</span>, response.data);
  })
  .catch(<span class="hljs-built_in">error</span> =&gt; {
    // 捕获网络错误或 HTTP 错误
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">error</span>.response) {
      console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'HTTP 错误状态码:'</span>, <span class="hljs-built_in">error</span>.response.<span class="hljs-built_in">status</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">error</span>.request) {
      console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'网络错误，无响应:'</span>, <span class="hljs-built_in">error</span>.request);
    }
  });
</code></pre>
<h4 data-id="heading-9">2.2.2 用 try...catch 处理 axios 错误（async/await 场景）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserData</span>(<span class="hljs-params">userId</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>);
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 统一捕获并细化处理</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>?.<span class="hljs-property">status</span> === <span class="hljs-number">404</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'用户不存在'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'获取用户数据失败:'</span>, error);
    <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 需上层处理时重新抛出</span>
  }
}
</code></pre>
<h3 data-id="heading-10">2.3 跨界关联场景：不止于 Promise、axios</h3>
<p><code>try...catch</code> 可捕获 “当前执行上下文” 中所有同步错误，覆盖 DOM 操作、Node.js 核心模块、第三方库等场景。</p>
<h4 data-id="heading-11">2.3.1 与 DOM 操作的协作</h4>
<p>DOM 操作易因 “元素不存在”“修改只读属性” 出错，<code>try...catch</code> 可避免页面功能瘫痪。</p>
<pre><code class="hljs language-ini" lang="ini">function renderUserList(users) {
  try {
    const <span class="hljs-attr">list</span> = document.getElementById(<span class="hljs-string">'user-list'</span>)<span class="hljs-comment">;</span>
    // 若 list 不存在或 users 格式异常，直接报错
    users.forEach(<span class="hljs-attr">user</span> =&gt; {
      const <span class="hljs-attr">item</span> = document.createElement(<span class="hljs-string">'li'</span>)<span class="hljs-comment">;</span>
      <span class="hljs-attr">item.textContent</span> = user.name<span class="hljs-comment">; // 若 user 无 name 属性，触发错误</span>
      list.appendChild(item)<span class="hljs-comment">;</span>
    })<span class="hljs-comment">;</span>
  } catch (error) {
    console.error('渲染失败：', error)<span class="hljs-comment">;</span>
    // 降级处理：显示错误提示而非白屏
    <span class="hljs-attr">document.body.innerHTML</span> = <span class="hljs-string">'&lt;p&gt;加载用户列表失败，请刷新重试&lt;/p&gt;'</span><span class="hljs-comment">;</span>
  }
}
</code></pre>
<h4 data-id="heading-12">2.3.2 与 Node.js 核心模块的配合</h4>
<p>Node.js 中同步 API（如 <code>fs.readFileSync</code>）的错误需 <code>try...catch</code> 捕获，否则导致进程崩溃。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">readConfig</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 同步读取文件，文件不存在/权限不足时抛出错误</span>
    <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'./config.json'</span>, <span class="hljs-string">'utf8'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(content); <span class="hljs-comment">// 解析失败也被捕获</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'配置文件读取失败：'</span>, error);
    <span class="hljs-comment">// 返回默认配置，保证程序正常启动</span>
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">default</span>: <span class="hljs-string">'config'</span> }; 
  }
}
</code></pre>
<h4 data-id="heading-13">2.3.3 与第三方库的兼容</h4>
<p>第三方库（如 <code>moment</code>、<code>Redux</code>）的同步方法可能因无效参数抛出错误，<code>try...catch</code> 是通用防护手段。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">'moment'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">formatDate</span>(<span class="hljs-params">dateString</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 若 dateString 格式无效，moment 格式化会报错</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">moment</span>(dateString).<span class="hljs-title function_">format</span>(<span class="hljs-string">'YYYY-MM-DD'</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'日期格式化失败：'</span>, error);
    <span class="hljs-comment">// 友好提示，避免暴露技术错误</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">'无效日期'</span>; 
  }
}
</code></pre>
<h2 data-id="heading-14">三、复杂项目场景：try...catch 的实战应用</h2>
<p>在多任务依赖、并行执行等复杂场景中，<code>try...catch</code> 与 <code>Promise</code> 组合可实现 “错误隔离”“流程可控”，避免局部错误影响全局。</p>
<h3 data-id="heading-15">3.1 分步依赖任务：串联式任务队列</h3>
<p>场景：先获取 Token → 用 Token 拉取用户 ID → 提交表单，某一步出错需中断并提示。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 任务1：获取 Token</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getToken</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/auth'</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>)
    .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`获取 Token 失败：<span class="hljs-subst">${err.message}</span>`</span>); <span class="hljs-comment">// 包装错误上下文</span>
    });
}

<span class="hljs-comment">// 任务2：用 Token 获取用户 ID</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params">token</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/user'</span>, { <span class="hljs-attr">headers</span>: { token } });
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>.<span class="hljs-property">id</span>;
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`获取用户 ID 失败：<span class="hljs-subst">${err.message}</span>`</span>); <span class="hljs-comment">// 补充错误信息</span>
  }
}

<span class="hljs-comment">// 任务3：提交表单（依赖用户 ID）</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">submitForm</span>(<span class="hljs-params">userId, formData</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/submit'</span>, { ...formData, userId });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'提交成功'</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`提交表单失败：<span class="hljs-subst">${err.message}</span>`</span>);
  }
}

<span class="hljs-comment">// 主流程：统一控制，汇总错误</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">formData</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getToken</span>();
    <span class="hljs-keyword">const</span> userId = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserId</span>(token);
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">submitForm</span>(userId, formData);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 所有步骤错误汇总到此处，统一提示+上报</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'流程中断：'</span>, error.<span class="hljs-property">message</span>);
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`操作失败：<span class="hljs-subst">${error.message}</span>`</span>);
    <span class="hljs-comment">// 上报错误到监控系统（附带用户/时间等上下文）</span>
    <span class="hljs-title function_">logErrorToServer</span>({
      <span class="hljs-attr">message</span>: error.<span class="hljs-property">message</span>,
      <span class="hljs-attr">stack</span>: error.<span class="hljs-property">stack</span>,
      <span class="hljs-attr">context</span>: { <span class="hljs-attr">userId</span>: <span class="hljs-string">'xxx'</span>, <span class="hljs-attr">time</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() }
    });
  }
}
</code></pre>
<h3 data-id="heading-16">3.2 并行任务：错误隔离不中断整体</h3>
<p>场景：页面同时渲染 3 个独立组件（用户信息、订单列表、消息通知），一个组件出错不影响其他组件。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 组件1：渲染用户信息</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">renderUserInfo</span>(<span class="hljs-params">userId</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/user/<span class="hljs-subst">${userId}</span>`</span>);
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'user-info'</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`&lt;p&gt;<span class="hljs-subst">${user.data.name}</span>&lt;/p&gt;`</span>;
      <span class="hljs-title function_">resolve</span>();
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-title function_">reject</span>(<span class="hljs-string">`用户信息组件失败：<span class="hljs-subst">${err.message}</span>`</span>);
    }
  });
}

<span class="hljs-comment">// 组件2：渲染订单列表</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">renderOrderList</span>(<span class="hljs-params">userId</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> orders = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/orders/<span class="hljs-subst">${userId}</span>`</span>);
      <span class="hljs-comment">// 渲染逻辑...</span>
      <span class="hljs-title function_">resolve</span>();
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-title function_">reject</span>(<span class="hljs-string">`订单列表组件失败：<span class="hljs-subst">${err.message}</span>`</span>);
    }
  });
}

<span class="hljs-comment">// 主流程：并行渲染，错误隔离</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderAllComponents</span>(<span class="hljs-params">userId</span>) {
  <span class="hljs-comment">// 用 Promise.allSettled 捕获所有结果，成功/失败均不中断</span>
  <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([
    <span class="hljs-title function_">renderUserInfo</span>(userId),
    <span class="hljs-title function_">renderOrderList</span>(userId),
    <span class="hljs-title function_">renderMessageList</span>(userId) <span class="hljs-comment">// 组件3：渲染消息通知</span>
  ]);

  <span class="hljs-comment">// 处理失败结果，单独提示</span>
  results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result, index</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">'rejected'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`组件<span class="hljs-subst">${index+<span class="hljs-number">1</span>}</span>渲染失败：`</span>, result.<span class="hljs-property">reason</span>);
      <span class="hljs-comment">// 标记失败组件，不影响其他组件展示</span>
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.component'</span>)[index].<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'error'</span>);
    }
  });
}
</code></pre>
<h2 data-id="heading-17">四、try...catch 的局限性：并非万能</h2>
<p>尽管 <code>try...catch</code> 是基础机制，但存在明显短板，需结合其他方案规避。</p>
<h3 data-id="heading-18">4.1 无法捕获的错误类型</h3>
<ul>
<li>
<p><strong>语法错误与解析错误</strong>：代码存在语法问题（如括号不匹配）或解析阶段错误（如 <code>import</code> 不存在的模块），脚本加载时直接报错，<code>try...catch</code> 无法捕获。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 语法错误：缺少右括号</span>
  <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a; 
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-comment">// 不执行，脚本解析阶段已报错</span>
}
</code></pre>
</li>
<li>
<p><strong>非 Promise 异步错误</strong>：不基于 <code>Promise</code> 的异步操作（如回调函数），错误无法被 <code>try...catch</code> 捕获。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">try</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'定时器错误'</span>); <span class="hljs-comment">// 异步回调错误，无法捕获</span>
  }, <span class="hljs-number">100</span>);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'捕获不到'</span>, error); <span class="hljs-comment">// 不执行</span>
}
</code></pre>
</li>
</ul>
<h3 data-id="heading-19">4.2 功能上的不足</h3>
<ul>
<li>
<p><strong>过度捕获掩盖逻辑错误</strong>：包裹大段代码时，会捕获 “预期外错误”（如变量拼写错误），增加调试难度。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 逻辑错误：变量名拼写错误（应为 user.name）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uesr.<span class="hljs-property">name</span>); 
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'出错了，但无法定位是拼写错还是其他错'</span>); <span class="hljs-comment">// 掩盖真实问题</span>
}
</code></pre>
</li>
<li>
<p><strong>性能损耗</strong>：<code>try...catch</code> 会影响 JavaScript 引擎优化（如 V8 即时编译），高频执行场景（如循环）中过度使用会导致性能下降。</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 反例：循环中频繁使用 try...catch，性能损耗明显</span>
for (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
  try {
    <span class="hljs-built_in">processData</span>(i); <span class="hljs-comment">// 高频执行，不建议包裹</span>
  } catch (error) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
</li>
</ul>
<h2 data-id="heading-20">五、try...catch 与其他机制的生态协作</h2>
<p>现代开发中，<code>try...catch</code> 需与全局错误监听、框架错误边界等配合，形成多层防护体系。</p>
<h3 data-id="heading-21">5.1 与全局错误监听的配合</h3>
<p><code>window.onerror</code> 或 <code>window.addEventListener('error')</code> 可捕获 <code>try...catch</code> 未处理的 “漏网之鱼”（如未被捕获的 Promise 错误、跨域脚本错误），作为最后兜底。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 全局错误兜底，捕获未处理错误</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-comment">// 过滤资源加载错误（如图片加载失败），只处理脚本错误</span>
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">message</span> !== <span class="hljs-string">'Script error.'</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'全局未捕获错误：'</span>, event.<span class="hljs-property">error</span>);
    <span class="hljs-comment">// 上报到监控系统，避免错误静默</span>
    <span class="hljs-title function_">logErrorToServer</span>(event.<span class="hljs-property">error</span>);
  }
});

<span class="hljs-comment">// 捕获未处理的 Promise 错误</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'unhandledrejection'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'未处理的 Promise 错误：'</span>, event.<span class="hljs-property">reason</span>);
  event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 阻止浏览器默认提示</span>
  <span class="hljs-title function_">logErrorToServer</span>(event.<span class="hljs-property">reason</span>);
});
</code></pre>
<h3 data-id="heading-22">5.2 与框架错误边界的协作</h3>
<p>在 React、Vue 等框架中，组件渲染错误需用 “错误边界” 处理，<code>try...catch</code> 负责逻辑错误，错误边界负责渲染错误，分工明确。</p>
<h4 data-id="heading-23">5.2.1 React 错误边界示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  state = { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> };

  <span class="hljs-comment">// 捕获子组件渲染错误</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// 更新状态，显示降级 UI</span>
  }

  <span class="hljs-comment">// 日志上报</span>
  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'组件渲染错误：'</span>, error, errorInfo);
    <span class="hljs-title function_">logErrorToServer</span>({ error, errorInfo });
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>组件加载失败，请刷新重试<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>; <span class="hljs-comment">// 降级 UI</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;
  }
}

<span class="hljs-comment">// 使用：包裹可能出错的组件</span>
&lt;<span class="hljs-title class_">ErrorBoundary</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">{123}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">ErrorBoundary</span>&gt;
</code></pre>
<h2 data-id="heading-24">六、总结</h2>
<h3 data-id="heading-25">6.1 核心定位</h3>
<p><code>try...catch</code> 是 <strong>JavaScript 错误处理的 “基础设施”</strong> ，而非 “最优解”：</p>
<ul>
<li>基础作用：捕获同步错误，配合 <code>async/await</code> 捕获 Promise 异步错误；</li>
<li>生态角色：与 <code>Promise.catch()</code>、全局监听、框架错误边界配合，形成 “多层防护”；</li>
<li>价值核心：保障程序可控性，实现优雅降级与错误上报。</li>
</ul>
<h3 data-id="heading-26">6.2 最佳应用</h3>
<ol>
<li>
<p><strong>精准捕获，避免过度包裹</strong>：只包裹 “预期可能出错的代码段”（如网络请求、JSON 解析），不包裹大段逻辑；</p>
</li>
<li>
<p><strong>保留错误上下文</strong>：捕获错误后需 <code>throw error</code> 重新抛出（需上层处理时），避免丢失错误栈信息；</p>
</li>
<li>
<p><strong>结合场景选择处理方式</strong>：</p>
<ul>
<li>同步代码：直接用 <code>try...catch</code>；</li>
<li>纯 Promise 异步：用 <code>.catch()</code>；</li>
<li><code>async/await</code> 场景：用 <code>try...catch</code> 统一处理；</li>
<li>并行任务：用 <code>Promise.allSettled</code> 配合 <code>try...catch</code> 隔离错误；</li>
</ul>
</li>
<li>
<p><strong>补充错误上下文</strong>：抛出错误时添加业务信息（如用户 ID、订单号），便于排查；</p>
</li>
<li>
<p><strong>兜底机制不可少</strong>：全局错误监听 + 框架错误边界，覆盖 <code>try...catch</code> 未处理的场景。</p>
</li>
</ol>
<h2 data-id="heading-27">七、实际应用场景举例</h2>
<h3 data-id="heading-28">1. 同步代码场景（基础）</h3>
<p><strong>适用</strong>：JSON 解析、变量类型转换、同步函数调用等。<strong>模板</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">function syncOperation(<span class="hljs-keyword">data</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 可能出错的同步操作（如解析、类型转换）</span>
    <span class="hljs-keyword">const</span> parsed = JSON.parse(<span class="hljs-keyword">data</span>); <span class="hljs-comment">// 可能抛错</span>
    <span class="hljs-keyword">const</span> result = parsed.value.toUpperCase(); <span class="hljs-comment">// 可能抛错（若 parsed.value 不存在）</span>
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 1. 补充上下文（必做）</span>
    error.context = { <span class="hljs-keyword">data</span>, operation: <span class="hljs-string">'syncOperation'</span> };
    <span class="hljs-comment">// 2. 可处理则补救，否则抛出</span>
    <span class="hljs-keyword">if</span> (error.name === <span class="hljs-string">'SyntaxError'</span>) {
      console.warn(<span class="hljs-string">'数据格式错误，使用默认值'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-string">'default'</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 传递给上层处理</span>
    }
  }
}
</code></pre>
<h3 data-id="heading-29">2. DOM 操作场景</h3>
<p><strong>适用</strong>：动态创建元素、修改 DOM 属性、事件绑定等（易因元素不存在 / 权限问题出错）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDOM</span>(<span class="hljs-params">elementId, content</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(elementId);
    <span class="hljs-keyword">if</span> (!el) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`元素 <span class="hljs-subst">${elementId}</span> 不存在`</span>); <span class="hljs-comment">// 主动抛错，明确上下文</span>
    
    <span class="hljs-comment">// 可能出错的 DOM 操作</span>
    el.<span class="hljs-property">textContent</span> = content; 
    el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'active'</span>); <span class="hljs-comment">// 若 classList 不支持（极旧浏览器）会抛错</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'DOM 更新失败：'</span>, error.<span class="hljs-property">message</span>);
    <span class="hljs-comment">// 降级处理：显示错误提示，不影响页面其他功能</span>
    <span class="hljs-keyword">const</span> errorEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
    errorEl.<span class="hljs-property">className</span> = <span class="hljs-string">'error'</span>;
    errorEl.<span class="hljs-property">textContent</span> = <span class="hljs-string">`加载失败：<span class="hljs-subst">${error.message}</span>`</span>;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(errorEl);
  }
}
</code></pre>
<h3 data-id="heading-30">3. Node.js 同步 API 场景</h3>
<p><strong>适用</strong>：文件读写（<code>fs.readFileSync</code>）、路径处理（<code>path.resolve</code>）等同步操作（出错会导致进程崩溃）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">readLocalFile</span>(<span class="hljs-params">filePath</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">resolve</span>(filePath); <span class="hljs-comment">// 路径解析可能抛错</span>
    <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(fullPath, <span class="hljs-string">'utf8'</span>); <span class="hljs-comment">// 文件不存在/权限不足会抛错</span>
    <span class="hljs-keyword">return</span> content;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 区分错误类型，针对性处理</span>
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">code</span> === <span class="hljs-string">'ENOENT'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`文件不存在：<span class="hljs-subst">${filePath}</span>，返回空内容`</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">code</span> === <span class="hljs-string">'EACCES'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`权限不足，无法读取 <span class="hljs-subst">${filePath}</span>`</span>);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'文件访问权限不足，请检查配置'</span>); <span class="hljs-comment">// 上层需处理的严重错误</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> error;
    }
  }
}
</code></pre>
<h3 data-id="heading-31">4. 异步场景（<code>Promise</code> + <code>async/await</code>）</h3>
<h4 data-id="heading-32">4.1 单异步任务（<code>async/await</code>）</h4>
<p><strong>适用</strong>：单个网络请求、异步 API 调用（如 <code>axios</code> 请求）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchSingleData</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(url);
    <span class="hljs-comment">// 主动校验业务错误（如接口返回 code 非 0）</span>
    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> !== <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`业务错误：<span class="hljs-subst">${response.data.msg}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 区分网络错误和业务错误</span>
    <span class="hljs-keyword">let</span> errorMsg;
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>) {
      <span class="hljs-comment">// HTTP 错误（404/500 等）</span>
      errorMsg = <span class="hljs-string">`请求失败[<span class="hljs-subst">${error.response.status}</span>]：<span class="hljs-subst">${url}</span>`</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">request</span>) {
      <span class="hljs-comment">// 网络错误（无响应）</span>
      errorMsg = <span class="hljs-string">`网络错误，无法连接：<span class="hljs-subst">${url}</span>`</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 业务错误或其他</span>
      errorMsg = error.<span class="hljs-property">message</span>;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(errorMsg);
    <span class="hljs-comment">// 非致命错误可返回默认值，避免流程中断</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; 
  }
}
</code></pre>
<h4 data-id="heading-33">4.2 多依赖异步任务（串联）</h4>
<p><strong>适用</strong>：任务 A → 任务 B（依赖 A 的结果）→ 任务 C（依赖 B 的结果）。<strong>模板</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">taskA</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* ... */</span> } <span class="hljs-comment">// 返回 Promise</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">taskB</span>(<span class="hljs-params">resultA</span>) { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">taskC</span>(<span class="hljs-params">resultB</span>) { <span class="hljs-comment">/* ... */</span> }

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runTasks</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> resA = <span class="hljs-keyword">await</span> <span class="hljs-title function_">taskA</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'任务 A 完成'</span>);
    
    <span class="hljs-keyword">const</span> resB = <span class="hljs-keyword">await</span> <span class="hljs-title function_">taskB</span>(resA);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'任务 B 完成'</span>);
    
    <span class="hljs-keyword">const</span> resC = <span class="hljs-keyword">await</span> <span class="hljs-title function_">taskC</span>(resB);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'所有任务完成'</span>);
    <span class="hljs-keyword">return</span> resC;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 任何一步失败都会中断，统一处理</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`任务中断：<span class="hljs-subst">${error.message}</span>`</span>);
    <span class="hljs-comment">// 记录中断位置（通过 error 上下文）</span>
    error.<span class="hljs-property">task</span> = error.<span class="hljs-property">task</span> || <span class="hljs-string">'未知任务'</span>; <span class="hljs-comment">// 可在子任务中添加 task 字段</span>
    <span class="hljs-title function_">logToMonitor</span>(error); <span class="hljs-comment">// 上报监控</span>
    <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 允许上层重试</span>
  }
}
</code></pre>
<h4 data-id="heading-34">4.3 多独立异步任务（并行）</h4>
<p><strong>适用</strong>：多个无依赖的异步任务（如同时渲染多个组件），需隔离错误。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentA</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentB</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* ... */</span> }
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">componentC</span>(<span class="hljs-params"/>) { <span class="hljs-comment">/* ... */</span> }

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderAll</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 用 Promise.allSettled 确保所有任务执行完毕（无论成功失败）</span>
  <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([
    <span class="hljs-title function_">componentA</span>().<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> ({ <span class="hljs-attr">error</span>: err, <span class="hljs-attr">component</span>: <span class="hljs-string">'A'</span> })),
    <span class="hljs-title function_">componentB</span>().<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> ({ <span class="hljs-attr">error</span>: err, <span class="hljs-attr">component</span>: <span class="hljs-string">'B'</span> })),
    <span class="hljs-title function_">componentC</span>().<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> ({ <span class="hljs-attr">error</span>: err, <span class="hljs-attr">component</span>: <span class="hljs-string">'C'</span> }))
  ]);

  <span class="hljs-comment">// 处理失败结果</span>
  results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">value</span>?.<span class="hljs-property">error</span>) { <span class="hljs-comment">// 捕获到的错误</span>
      <span class="hljs-keyword">const</span> { error, component } = result.<span class="hljs-property">value</span>;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`组件 <span class="hljs-subst">${component}</span> 失败：`</span>, error.<span class="hljs-property">message</span>);
      <span class="hljs-comment">// 单独标记失败组件，不影响其他</span>
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">`comp-<span class="hljs-subst">${component}</span>`</span>).<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'failed'</span>);
    }
  });
}
</code></pre>
<h3 data-id="heading-35">5. 第三方库调用场景</h3>
<p><strong>适用</strong>：调用外部库（如 <code>moment</code>、<code>lodash</code>）的同步方法（可能因参数错误抛错）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">'moment'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">formatWithLibrary</span>(<span class="hljs-params">dateInput</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 第三方库可能对无效参数抛错（如 moment(null) 格式化）</span>
    <span class="hljs-keyword">const</span> formatted = <span class="hljs-title function_">moment</span>(dateInput).<span class="hljs-title function_">format</span>(<span class="hljs-string">'YYYY-MM-DD HH:mm'</span>);
    <span class="hljs-comment">// 主动校验库返回的异常结果（如 moment 无效日期返回 'Invalid date'）</span>
    <span class="hljs-keyword">if</span> (formatted === <span class="hljs-string">'Invalid date'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`无效日期：<span class="hljs-subst">${dateInput}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> formatted;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'格式化失败：'</span>, error.<span class="hljs-property">message</span>);
    <span class="hljs-comment">// 降级为原生方法</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(dateInput).<span class="hljs-title function_">toLocaleString</span>() || <span class="hljs-string">'无法解析的日期'</span>;
  }
}
</code></pre>
<h3 data-id="heading-36">6. 框架场景（以 React 为例）</h3>
<p><strong>适用</strong>：组件逻辑错误（<code>try...catch</code>）与渲染错误（错误边界）分工：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 组件内逻辑错误用 try...catch</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ userId }</span>) {
  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadUser</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/user/<span class="hljs-subst">${userId}</span>`</span>);
        <span class="hljs-title function_">setUser</span>(res.<span class="hljs-property">data</span>);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'加载用户失败：'</span>, error);
        <span class="hljs-title function_">setUser</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">'用户信息加载失败'</span> }); <span class="hljs-comment">// 状态降级</span>
      }
    }
    <span class="hljs-title function_">loadUser</span>();
  }, [userId]);

  <span class="hljs-comment">// 2. 渲染错误交给错误边界处理（不直接用 try...catch 包裹 JSX）</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {user?.error ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{user.error}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 错误边界组件（处理渲染错误）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> { <span class="hljs-comment">/* ... */</span> }

<span class="hljs-comment">// 使用：错误边界包裹可能渲染失败的组件</span>
&lt;<span class="hljs-title class_">ErrorBoundary</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">{123}</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">ErrorBoundary</span>&gt;
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[openGauss实战：Python开发与AI向量数据库应用]]></title>    <link>https://juejin.cn/post/7572714389943271476</link>    <guid>https://juejin.cn/post/7572714389943271476</guid>    <pubDate>2025-11-16T11:15:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572714389943271476" data-draft-id="7572534419880525859" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="openGauss实战：Python开发与AI向量数据库应用"/> <meta itemprop="keywords" content="数据库"/> <meta itemprop="datePublished" content="2025-11-16T11:15:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="倔强的石头_"/> <meta itemprop="url" content="https://juejin.cn/user/3168119757484368"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            openGauss实战：Python开发与AI向量数据库应用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3168119757484368/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    倔强的石头_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T11:15:34.000Z" title="Sun Nov 16 2025 11:15:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>经过前两篇文章的铺垫，我们已经掌握了openGauss的部署安装和使用Data Studio进行可视化管理。现在，我们来到了本系列文章的终章，将目光聚焦于开发者最关心的环节——如何在应用程序中与openGauss进行交互，并探索其在AI领域的应用潜力。</p>
<p>本文将以目前最流行的编程语言之一Python为例，详细演示如何连接openGauss数据库，并围绕两个典型的业务场景——“用户管理系统”和“订单支付流程”，构建完整的CRUD（创建、读取、更新、删除）与事务处理代码示例。更进一步，我们将结合业界热点，探讨如何利用openGauss的向量计算能力，构建一个简单的以文搜图RAG（检索增强生成）应用，充分展现openGauss作为一款AI原生数据库的魅力。
@[toc]
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7ecc742f65bf4188bba3c4639c39463e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=tVp0Zw4ALYTw94xR53Kq9KLvdLM%3D" alt="image.png" loading="lazy"/></p>
<p>本文的后端环境为“CentOS 7.9 + openGauss 极简版（simpleInstall，6.x）”，数据库运行在云服务器上，应用在本地开发机（Windows/macOS/Linux）运行并远程连接到数据库。若远程连接失败，请参考第二篇中关于<code>listen_addresses</code>与<code>pg_hba.conf</code>的配置说明。</p>
<h2 data-id="heading-1">Python连接openGauss：psycopg2驱动</h2>
<p>openGauss兼容PostgreSQL生态，因此，我们可以使用PostgreSQL最成熟的Python驱动<code>psycopg2</code>来连接和操作openGauss数据库。</p>
<h3 data-id="heading-2">1. 安装psycopg2</h3>
<p>首先，安装Python驱动。请根据环境选择以下命令：</p>
<ul>
<li>Python 3.8 及以上（推荐）：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">python3 -m pip install --user psycopg2-binary
</code></pre>
<ul>
<li>CentOS 7 + Python 3.6（需固定版本并使用国内镜像）：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">python3 -m pip install --upgrade <span class="hljs-string">"pip==21.3.1"</span> --user -i https://pypi.tuna.tsinghua.edu.cn/simple
python3 -m pip install --user -i https://mirrors.aliyun.com/pypi/simple <span class="hljs-string">"psycopg2-binary==2.8.6"</span>
<span class="hljs-comment"># 如网络较慢，可追加 --default-timeout=120</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31f000e4a5d84062a91348784cce2b50~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=Cxbor0a7bzzELL%2BEAvA58M9X0p8%3D" alt="e1821a45e4b7bcadd15800e7f81934cf.png" loading="lazy"/></p>
<p>提示：尽量使用 <code>python3 -m pip</code>（或 <code>pip3</code>），并在非虚拟环境下加 <code>--user</code> 以避免权限冲突；若需源码编译，可改为安装 <code>psycopg2==2.8.6</code>，并提前安装构建依赖（如 <code>gcc</code>、<code>python3-devel</code>、<code>postgresql-libs</code>/<code>postgresql-devel</code>）。</p>
<p>常见安装问题排障：</p>
<ul>
<li>下载超时：加入 <code>--default-timeout=120</code> 或切换镜像源（如清华、阿里）。</li>
<li>证书/代理：在公司网络需配置 HTTPS 代理或临时关闭 MITM 检查；也可离线下载 <code>.whl</code> 后本地安装。</li>
<li>权限警告：在 root 环境下建议使用 <code>--user</code> 或创建虚拟环境。</li>
<li>Windows 与多版本 Python 映射：在 PowerShell 执行 <code>python -V</code>、<code>pip -V</code>、<code>py -0p</code>，确保 <code>pip</code> 与 <code>python</code> 指向同一解释器；优先使用 <code>python -m pip install --user psycopg2-binary</code>。</li>
<li>路径检查：<code>where python</code>、<code>where pip</code> 查看可执行路径；必要时使用目标解释器绝对路径，例如 <code>C:\Python39\python.exe -m pip install psycopg2-binary</code>。</li>
<li>快速验证安装：<code>python -c "import psycopg2, sys; print(psycopg2.__version__, sys.executable)"</code>，确认驱动版本与解释器路径匹配。</li>
<li>源码编译提示：若报缺少 <code>pg_config</code> 或开发头文件，优先使用 <code>psycopg2-binary</code>；或先安装 <code>postgresql-libs</code>/<code>postgresql-devel</code> 与 <code>python3-devel</code> 后再编译 <code>psycopg2</code>。</li>
</ul>
<h3 data-id="heading-3">2. 建立数据库连接</h3>
<p>连接openGauss数据库非常简单，只需提供主机、端口、用户名、密码和数据库名即可。下面的示例与入门篇默认参数保持一致（请替换为实际的服务器IP与密码）</p>
<p>实操步骤（本地开发机）：</p>
<ul>
<li>在本地任意工作目录创建项目并新建连接测试脚本：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># Windows PowerShell</span>
<span class="hljs-built_in">mkdir</span> opengauss_demo
<span class="hljs-built_in">cd</span> opengauss_demo
<span class="hljs-comment"># Linux/macOS 可用：</span>
<span class="hljs-comment"># mkdir -p opengauss_demo</span>
<span class="hljs-comment"># 如尚未安装驱动，请先执行：</span>
python3 -m pip install --user psycopg2-binary
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a73c91a6b2046efa57f07c0755e335a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=loLG9NMvfbamgfIyenUsRAfTRpg%3D" alt="image.png" loading="lazy"/></p>
<p>在该目录中新建文件 <code>db_connect_test.py</code>，内容如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># db_connect_test.py</span>
<span class="hljs-keyword">import</span> psycopg2

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db_connection</span>():
    <span class="hljs-keyword">try</span>:
        conn = psycopg2.connect(
            host=<span class="hljs-string">"YOUR_SERVER_IP"</span>,   <span class="hljs-comment"># 替换为云服务器公网IP</span>
            port=<span class="hljs-number">5432</span>,
            user=<span class="hljs-string">"omm"</span>,
            password=<span class="hljs-string">"Gauss@123456"</span>, <span class="hljs-comment"># 替换为实际密码</span>
            database=<span class="hljs-string">"postgres"</span>,
            connect_timeout=<span class="hljs-number">5</span>
        )
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"数据库连接成功！"</span>)
        <span class="hljs-keyword">return</span> conn
    <span class="hljs-keyword">except</span> psycopg2.OperationalError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据库连接失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> conn:
        conn.close()
</code></pre>
<p>运行与验证（Windows/ macOS/ Linux）：</p>
<pre><code class="hljs language-bash" lang="bash">python3 db_connect_test.py
<span class="hljs-comment"># 若 Windows 上没有 python3 命令，可用：</span>
<span class="hljs-comment"># python db_connect_test.py</span>
</code></pre>
<p>预期输出：出现“数据库连接成功！”并退出；如报错，按下方“远程连接失败排查要点”逐项检查。</p>
<p>若出现连接超时或认证失败，请回到第二篇确认：</p>
<ul>
<li><code>postgresql.conf</code>的<code>listen_addresses</code>是否为<code>'*'</code>或对应IP；</li>
<li><code>pg_hba.conf</code>是否添加了允许远程访问的<code>host</code>条目（<code>md5</code>认证）；</li>
<li>云安全组是否开放<code>TCP 5432</code>入站规则到您的本地IP范围。</li>
</ul>
<p>连接失败快速排查：</p>
<ul>
<li>替换占位符：确认已将 <code>YOUR_SERVER_IP</code> 与 <code>Gauss@123456</code> 替换为真实值；若脚本报 <code>NoneType</code> 错误，通常是连接失败导致返回 <code>None</code>。</li>
<li>端口连通性：Windows 执行 <code>Test-NetConnection YOUR_SERVER_IP -Port 5432</code>；Linux/macOS 执行 <code>telnet YOUR_SERVER_IP 5432</code> 或 <code>nc -vz YOUR_SERVER_IP 5432</code>。</li>
<li>认证规则：在数据库侧 <code>pg_hba.conf</code> 添加合适的 <code>host</code> 条目（如 <code>md5</code>），修改后 <code>gs_ctl reload</code> 或重启实例。</li>
<li>初始用户远程连接说明：不建议用初始用户（如 <code>omm</code>）作为应用远程账号；推荐新建业务用户（如 <code>xsc</code>）并授予表/序列权限，见下文“用户管理”授权方案。</li>
<li>数据库/Schema：确认连接的 <code>database="postgres"</code> 与 <code>search_path</code> 包含 <code>public</code>；使用限定名 <code>public.t_user</code> 可避免路径问题。</li>
</ul>
<h2 data-id="heading-4">场景一：用户管理系统的CRUD实战</h2>
<p>用户管理是几乎所有应用的标配。下面，我们将实现一个简单的用户管理模块，包含增、删、改、查功能。</p>
<h3 data-id="heading-5">1. 创建用户表</h3>
<p>首先，在数据库中创建<code>t_user</code>表。</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_user (
    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,
    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">WITH</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
);
</code></pre>
<p>实操步骤（数据库侧）：</p>
<ul>
<li>使用 <code>gsql</code> 远程连接到 openGauss：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">gsql -d postgres -h YOUR_SERVER_IP -p 5432 -U omm -W
</code></pre>
<ul>
<li>执行上述 <code>CREATE TABLE</code> 语句创建表。</li>
<li>验证：</li>
</ul>
<pre><code class="hljs language-sql" lang="sql">\dt
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user;
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/333ff30978cd4d66a3fdcc7ab7569942~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=fUIaxUTfyMWvpt9F%2FFh%2FTDrNf1g%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-6">2. Python代码实现</h3>
<p>在本地开发机创建目录（例如 <code>opengauss_demo</code>），新增文件 <code>user_crud.py</code>，内容如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># user_crud.py</span>

<span class="hljs-keyword">import</span> psycopg2
<span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> closing


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db_connection</span>():
    <span class="hljs-keyword">try</span>:
        conn = psycopg2.connect(
            host=<span class="hljs-string">"YOUR_SERVER_IP"</span>,
            port=<span class="hljs-number">5432</span>,
            user=<span class="hljs-string">"omm"</span>,
            password=<span class="hljs-string">"Gauss@123456"</span>,
            database=<span class="hljs-string">"postgres"</span>,
            connect_timeout=<span class="hljs-number">5</span>,
        )
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"数据库连接成功！"</span>)
        <span class="hljs-keyword">return</span> conn
    <span class="hljs-keyword">except</span> psycopg2.OperationalError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据库连接失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">username, email</span>):
    <span class="hljs-keyword">with</span> closing(get_db_connection()) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"INSERT INTO t_user (username, email) VALUES (%s, %s)"</span>,
                (username, email),
            )
            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"用户 '<span class="hljs-subst">{username}</span>' 创建成功。"</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_username</span>(<span class="hljs-params">username</span>):
    <span class="hljs-keyword">with</span> closing(get_db_connection()) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"SELECT id, username, email FROM t_user WHERE username = %s"</span>,
                (username,),
            )
            <span class="hljs-keyword">return</span> cursor.fetchone()


<span class="hljs-keyword">def</span> <span class="hljs-title function_">update_user_email</span>(<span class="hljs-params">username, new_email</span>):
    <span class="hljs-keyword">with</span> closing(get_db_connection()) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"UPDATE t_user SET email = %s WHERE username = %s"</span>,
                (new_email, username),
            )
            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"用户 '<span class="hljs-subst">{username}</span>' 的邮箱更新成功。"</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(<span class="hljs-params">username</span>):
    <span class="hljs-keyword">with</span> closing(get_db_connection()) <span class="hljs-keyword">as</span> conn:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"DELETE FROM t_user WHERE username = %s"</span>,
                (username,),
            )
            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"用户 '<span class="hljs-subst">{username}</span>' 删除成功。"</span>)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    create_user(<span class="hljs-string">"john_doe"</span>, <span class="hljs-string">"john.doe@example.com"</span>)
    user = get_user_by_username(<span class="hljs-string">"john_doe"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"查询到用户: <span class="hljs-subst">{user}</span>"</span>)
    update_user_email(<span class="hljs-string">"john_doe"</span>, <span class="hljs-string">"john.doe.new@example.com"</span>)
    user = get_user_by_username(<span class="hljs-string">"john_doe"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"更新后用户: <span class="hljs-subst">{user}</span>"</span>)
    delete_user(<span class="hljs-string">"john_doe"</span>)
</code></pre>
<p>运行与验证（本地开发机）：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> opengauss_demo
python3 user_crud.py
</code></pre>
<p>预期输出：依次打印“数据库连接成功”、“创建成功”、“查询到用户”、“更新后用户”、“删除成功”。
如需数据库侧二次确认：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">'john_doe'</span>;
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e7233e7af11948aab7c769fb30c3055a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=XwAJe6arZphy41IKFnd5LNjUOCE%3D" alt="image.png" loading="lazy"/></p>
<p>常见报错与解决（用户管理）：</p>
<p>我用应用账号 xsc 远程连库，但表 t_user 是初始用户 omm 创建和拥有；默认权限下， xsc 没有对该表的操作权限，因此出现 “permission denied for relation t_user”。另外 openGauss 不建议用初始用户做远程应用连接，这是安全最佳实践。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c525931642614098abb3198fab856355~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=KRp%2FQsUywXFXOOt%2B%2BO1es73%2Fx%2Bw%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>
<p>报错 <code>psycopg2.errors.InsufficientPrivilege: permission denied for relation t_user</code>：业务用户（如 <code>xsc</code>）缺少权限。请在服务器上以所有者/管理员（通常为 <code>omm</code>）执行：</p>
<ul>
<li><code>GRANT USAGE ON SCHEMA public TO xsc;</code></li>
<li><code>GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.t_user TO xsc;</code></li>
<li><code>GRANT USAGE, SELECT ON SEQUENCE public.t_user_id_seq TO xsc;</code>
序列授权是因为 <code>SERIAL</code> 会创建隐式序列，插入时需读写序列。
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d9d87773a7a46438c9d9bb8592dc554~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YCU5by655qE55-z5aS0Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1763896534&amp;x-signature=XC2mEn4Zyoz7gtTm6mjmvIb1tn8%3D" alt="image.png" loading="lazy"/></li>
</ul>
</li>
<li>
<p>可选（需谨慎）：将所有者变更为业务用户以简化权限管理：</p>
<ul>
<li><code>ALTER TABLE public.t_user OWNER TO xsc;</code></li>
<li><code>ALTER SEQUENCE public.t_user_id_seq OWNER TO xsc;</code></li>
</ul>
</li>
<li>
<p>代码健壮性建议：在每个操作前判断连接是否成功，并使用表的限定名：</p>
</li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">username, email</span>):
    conn = get_db_connection()  <span class="hljs-comment"># 可将 user 改为业务账号，如 xsc</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"连接失败，已跳过 insert"</span>)
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cur:
            cur.execute(
                <span class="hljs-string">"INSERT INTO public.t_user (username, email) VALUES (%s, %s)"</span>,
                (username, email),
            )
        conn.commit()
    <span class="hljs-keyword">finally</span>:
        conn.close()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_username</span>(<span class="hljs-params">username</span>):
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cur:
            cur.execute(
                <span class="hljs-string">"SELECT id, username, email FROM public.t_user WHERE username = %s"</span>,
                (username,),
            )
            <span class="hljs-keyword">return</span> cur.fetchone()
    <span class="hljs-keyword">finally</span>:
        conn.close()
</code></pre>
<ul>
<li>授权快速验证：
<ul>
<li><code>gsql -d postgres -h YOUR_SERVER_IP -p 5432 -U xsc -W</code></li>
<li>依次执行：<code>INSERT/SELECT/UPDATE/DELETE</code> 到 <code>public.t_user</code>，确认无权限报错。</li>
</ul>
</li>
</ul>
<h2 data-id="heading-7">场景二：订单支付流程的事务处理</h2>
<p>在电商等金融敏感场景中，数据一致性至关重要。我们将模拟一个“用户下单扣减库存”的场景，来演示如何使用事务保证操作的原子性。</p>
<h3 data-id="heading-8">1. 创建商品表和订单表</h3>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_product (
    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,
    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    stock <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>
);

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_order (
    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,
    product_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    quantity <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">WITH</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
);

<span class="hljs-comment">-- 插入一个商品</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_product (name, stock) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'openGauss T-shirt'</span>, <span class="hljs-number">100</span>);
</code></pre>
<p>实操步骤（数据库侧）：</p>
<ul>
<li>连接数据库（同上）：</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">gsql -d postgres -h YOUR_SERVER_IP -p 5432 -U omm -W
</code></pre>
<ul>
<li>依次执行创建两张表与初始化数据的 SQL；可用下列查询验证：</li>
</ul>
<pre><code class="hljs language-sql" lang="sql">\dt
<span class="hljs-keyword">SELECT</span> id, name, stock <span class="hljs-keyword">FROM</span> t_product;  <span class="hljs-comment">-- 应看到一条库存为100的商品</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> t_order;           <span class="hljs-comment">-- 初始为0</span>
</code></pre>
<h3 data-id="heading-9">2. Python代码实现</h3>
<p>在本地开发机创建文件 <code>transaction_example.py</code>，内容如下：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># transaction_example.py</span>

<span class="hljs-keyword">import</span> psycopg2


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db_connection</span>():
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> psycopg2.connect(
            host=<span class="hljs-string">"YOUR_SERVER_IP"</span>,
            port=<span class="hljs-number">5432</span>,
            user=<span class="hljs-string">"omm"</span>,
            password=<span class="hljs-string">"Gauss@123456"</span>,
            database=<span class="hljs-string">"postgres"</span>,
            connect_timeout=<span class="hljs-number">5</span>,
        )
    <span class="hljs-keyword">except</span> psycopg2.OperationalError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据库连接失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">place_order</span>(<span class="hljs-params">product_id, quantity</span>):
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            <span class="hljs-comment"># 1. 检查库存并加行锁，避免并发下读到旧库存</span>
            cursor.execute(
                <span class="hljs-string">"SELECT stock FROM t_product WHERE id = %s FOR UPDATE"</span>,
                (product_id,),
            )
            row = cursor.fetchone()
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> row:
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"商品不存在！"</span>)
            stock = row[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> stock &lt; quantity:
                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"库存不足！"</span>)

            <span class="hljs-comment"># 2. 扣减库存</span>
            cursor.execute(
                <span class="hljs-string">"UPDATE t_product SET stock = stock - %s WHERE id = %s"</span>,
                (quantity, product_id),
            )

            <span class="hljs-comment"># 3. 创建订单</span>
            cursor.execute(
                <span class="hljs-string">"INSERT INTO t_order (product_id, quantity) VALUES (%s, %s)"</span>,
                (product_id, quantity),
            )

            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"下单成功！"</span>)

    <span class="hljs-keyword">except</span> (Exception, psycopg2.Error) <span class="hljs-keyword">as</span> error:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"下单失败: <span class="hljs-subst">{error}</span>"</span>)
        conn.rollback()
    <span class="hljs-keyword">finally</span>:
        conn.close()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    place_order(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)   <span class="hljs-comment"># 成功下单，库存从100减到95</span>
    place_order(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>) <span class="hljs-comment"># 超卖示例，将抛出“库存不足！”并回滚</span>
</code></pre>
<p>运行与验证：</p>
<pre><code class="hljs language-bash" lang="bash">python3 transaction_example.py
</code></pre>
<p>可在数据库侧验证：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">SELECT</span> id, stock <span class="hljs-keyword">FROM</span> t_product <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;   <span class="hljs-comment">-- 应为95</span>
<span class="hljs-keyword">SELECT</span> id, product_id, quantity <span class="hljs-keyword">FROM</span> t_order; <span class="hljs-comment">-- 应新增一条 quantity=5 的订单</span>
</code></pre>
<p>说明：<code>FOR UPDATE</code> 会在查询到的行上加排他锁，确保并发事务不会在你提交前修改该行，避免超卖；一旦发生异常，代码会执行 <code>rollback()</code> 保证库存与订单的一致性。</p>
<p>这段代码确保了“扣减库存”和“创建订单”这两个操作要么同时成功，要么同时失败，避免了数据不一致的问题。</p>
<p>常见报错与处理（事务）：</p>
<ul>
<li>权限问题：业务用户对 <code>t_product</code> 需至少 <code>SELECT, UPDATE</code>，对 <code>t_order</code> 需 <code>INSERT, SELECT</code>，并为隐式序列授予 <code>USAGE, SELECT</code>（例如 <code>t_product_id_seq</code>、<code>t_order_id_seq</code>）。</li>
<li>并发冲突：若遇到 <code>could not serialize access due to concurrent update</code>，说明并发更新冲突；保留 <code>FOR UPDATE</code>，在应用侧捕获并重试，或确认隔离级别为 <code>READ COMMITTED</code>。</li>
<li>异常处理：任何异常均应 <code>rollback()</code> 保证一致性，提交成功后再打印“下单成功”。</li>
</ul>
<h2 data-id="heading-10">场景三：AI赋能 - 基于向量的以文搜图（RAG）</h2>
<p>现在，让我们进入最激动人心的部分。openGauss 5.0版本后引入了对向量数据类型和向量计算的内置支持，使其成为构建AI应用的理想选择。我们将构建一个简单的RAG应用，通过文本描述来搜索相似的图片。</p>
<h3 data-id="heading-11">1. 开启向量插件并创建表</h3>
<p>首先，需要在数据库中开启<code>vectors</code>插件</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> EXTENSION vectors;
</code></pre>
<p>说明：部分发行版或构建中扩展名可能为 <code>vector</code>（pgvector），若上面的命令报未找到扩展，可尝试：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> EXTENSION vector;
</code></pre>
<p>然后，创建一个用于存储图片向量的表。本文使用<code>clip-ViT-B-32</code>模型，其默认输出维度为<code>512</code>，因此示例使用<code>VECTOR(512)</code>：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_image_vectors (
    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,
    image_path <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    image_vector VECTOR(<span class="hljs-number">512</span>)
);
</code></pre>
<p>验证与注意：</p>
<ul>
<li>使用 <code>\dx</code> 查看已启用的扩展；若显示 <code>vectors</code>/<code>vector</code> 即成功。</li>
<li><code>\d t_image_vectors</code> 可查看表结构；向量字段类型为 <code>vector(512)</code>。</li>
</ul>
<h3 data-id="heading-12">2. Python代码实现</h3>
<p>这个场景需要借助一个能够将文本和图片转换为向量的模型。这里我们使用<code>sentence-transformers</code>库作为示例。</p>
<pre><code class="hljs language-bash" lang="bash">python3 -m pip install --user -i https://mirrors.aliyun.com/pypi/simple sentence-transformers Pillow
</code></pre>
<p>前置说明：该步骤建议在本地开发机的 Python 3.8+ 环境执行（<code>sentence-transformers</code> 对 Py3.6 支持不佳）。首次运行会从 HuggingFace 下载模型，需联网。</p>
<p>在本地准备工程与图片：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">mkdir</span> -p opengauss_demo/assets/images
<span class="hljs-comment"># 将两张示例图片保存为：opengauss_demo/assets/images/cat.jpg、dog.jpg</span>
</code></pre>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># rag_example.py</span>

<span class="hljs-keyword">import</span> psycopg2
<span class="hljs-keyword">from</span> sentence_transformers <span class="hljs-keyword">import</span> SentenceTransformer
<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db_connection</span>():
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> psycopg2.connect(
            host=<span class="hljs-string">"YOUR_SERVER_IP"</span>,
            port=<span class="hljs-number">5432</span>,
            user=<span class="hljs-string">"omm"</span>,
            password=<span class="hljs-string">"Gauss@123456"</span>,
            database=<span class="hljs-string">"postgres"</span>,
            connect_timeout=<span class="hljs-number">5</span>,
        )
    <span class="hljs-keyword">except</span> psycopg2.OperationalError <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"数据库连接失败: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>


model = SentenceTransformer(<span class="hljs-string">"clip-ViT-B-32"</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_image_vector</span>(<span class="hljs-params">image_path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">try</span>:
        img_embedding = model.encode(Image.<span class="hljs-built_in">open</span>(image_path))  <span class="hljs-comment"># 512维</span>
        vector_str = <span class="hljs-string">"["</span> + <span class="hljs-string">","</span>.join(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">float</span>(x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> img_embedding.tolist()) + <span class="hljs-string">"]"</span>

        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"INSERT INTO t_image_vectors (image_path, image_vector) VALUES (%s, %s::vector)"</span>,
                (image_path, vector_str),
            )
            conn.commit()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"已入库向量：<span class="hljs-subst">{image_path}</span>"</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"处理图片失败: <span class="hljs-subst">{e}</span>"</span>)
        conn.rollback()
    <span class="hljs-keyword">finally</span>:
        conn.close()


<span class="hljs-keyword">def</span> <span class="hljs-title function_">search_images_by_text</span>(<span class="hljs-params">text_query: <span class="hljs-built_in">str</span>, top_k: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span></span>):
    conn = get_db_connection()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> conn:
        <span class="hljs-keyword">return</span> []

    <span class="hljs-keyword">try</span>:
        query_embedding = model.encode(text_query)
        vector_str = <span class="hljs-string">"["</span> + <span class="hljs-string">","</span>.join(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">float</span>(x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> query_embedding.tolist()) + <span class="hljs-string">"]"</span>

        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cursor:
            cursor.execute(
                <span class="hljs-string">"SELECT image_path, image_vector &lt;-&gt; %s::vector AS dist FROM t_image_vectors ORDER BY dist LIMIT %s"</span>,
                (vector_str, top_k),
            )
            <span class="hljs-keyword">return</span> cursor.fetchall()
    <span class="hljs-keyword">finally</span>:
        conn.close()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># 将两张图片向量化并入库</span>
    insert_image_vector(<span class="hljs-string">"assets/images/cat.jpg"</span>)
    insert_image_vector(<span class="hljs-string">"assets/images/dog.jpg"</span>)

    <span class="hljs-comment"># 文本检索</span>
    query = <span class="hljs-string">"A photo of a cute animal sitting on the grass"</span>
    results = search_images_by_text(query, top_k=<span class="hljs-number">3</span>)

    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n查询：<span class="hljs-subst">{query}</span>"</span>)
    <span class="hljs-keyword">for</span> path, dist <span class="hljs-keyword">in</span> results:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"- 图片: <span class="hljs-subst">{path}</span>，L2距离: <span class="hljs-subst">{dist:<span class="hljs-number">.4</span>f}</span>"</span>)
</code></pre>
<p>运行与验证：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> opengauss_demo
python3 rag_example.py
</code></pre>
<p>预期输出：打印两条“已入库向量：…”后，返回按距离排序的图片列表。距离越小表示越相似。</p>
<p>补充说明：</p>
<ul>
<li><code>&lt;-&gt;</code> 是向量相似度的距离操作符（L2距离）。若发行版提供 <code>l2_distance(v1,v2)</code>，也可替换为该函数。</li>
<li>如需加速检索，可建立向量索引（例如 <code>ivfflat</code>/<code>hnsw</code>），不同版本支持情况不一，配置前请确认。</li>
</ul>
<p>这个例子展示了openGauss如何无缝集成到AI工作流中。通过在数据库层面进行向量检索，可以简化RAG应用的架构，降低开发复杂度，并利用数据库的事务性和可靠性来管理AI数据。</p>
<p>小贴士：</p>
<ul>
<li>若您的版本提供<code>l2_distance(v1, v2)</code>函数，也可将示例中的<code>image_vector &lt;-&gt; %s::vector</code>替换为<code>l2_distance(image_vector, %s::vector)</code>；</li>
<li>向量索引（如<code>ivfflat</code>或<code>hnsw</code>）可显著提升检索性能，但不同版本支持情况可能不同，建议在功能确认后再配置索引。</li>
</ul>
<p>常见问题与解决（RAG 向量检索）：</p>
<ul>
<li>扩展不存在：<code>ERROR: extension "vectors" does not exist</code> 或 <code>type "vector" does not exist</code> → 执行 <code>CREATE EXTENSION vectors;</code>，若无则尝试 <code>CREATE EXTENSION vector;</code>，并用 <code>\dx</code> 检查扩展已启用。</li>
<li>操作符缺失：<code>operator does not exist: vector &lt;-&gt; vector</code> → 未启用向量扩展或版本不匹配；启用扩展或改用 <code>l2_distance(...)</code>。</li>
<li>向量文本格式错误：<code>invalid input syntax for type vector</code> → 确保是类似 <code>[0.1,0.2,...]</code> 的 JSON 风格列表，并在 SQL 中使用 <code>%s::vector</code> 显式类型转换。</li>
<li>模型下载失败：受公司网络限制可配置代理或离线下载模型；也可切换 pip 镜像安装依赖（示例已使用阿里镜像）。</li>
<li>Pillow 依赖：Linux 发行版可能需安装 <code>libjpeg</code>/<code>zlib</code> 等系统库；Windows/macOS 通常无需额外配置。</li>
</ul>
<p>常见错误速查表：</p>
<ul>
<li><code>ModuleNotFoundError: No module named psycopg2</code> → 用目标解释器执行 <code>python -m pip install --user psycopg2-binary</code>，并用 <code>python -c "import psycopg2"</code> 验证。</li>
<li>Windows <code>python3</code> 不识别 → 直接用 <code>python</code> 或 <code>py -3</code>，优先 <code>python -m pip</code>。</li>
<li><code>psycopg2.OperationalError: could not connect to server</code>/超时 → 检查 <code>listen_addresses</code>、<code>pg_hba.conf</code> 与安全组；本机用 <code>Test-NetConnection</code>/<code>telnet</code> 验证 5432 端口连通。</li>
<li><code>permission denied for relation/sequence ...</code> → 按上文为业务用户授予 <code>SCHEMA</code>、<code>TABLE</code> 与隐式序列权限。</li>
<li><code>relation "t_user" does not exist</code> → 确认已创建表、连接的数据库正确，或在 SQL 中使用 <code>public.t_user</code> 限定名。</li>
<li><code>extension "vectors" does not exist</code>/<code>type "vector" does not exist</code> → 安装并启用向量扩展，或使用兼容扩展名 <code>vector</code>。</li>
</ul>
<h2 data-id="heading-13">总结</h2>
<p>从基础的CRUD操作到复杂的事务管理，再到前沿的AI向量应用，openGauss通过其强大的功能和对主流开发生态的良好兼容性，证明了其在现代应用开发中的核心价值。特别是其原生的向量数据库能力，为企业在AI时代构建智能应用提供了坚实、高效且易于管理的数据底座。</p>
<p>希望这个系列的文章能帮助您对openGauss有一个全面而深入的了解。数据库的世界广阔无垠，而openGauss的探索之旅，才刚刚开始。欢迎您继续深入研究，发掘它更多的可能性！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[C++循环结构探微：深入理解while与do...while]]></title>    <link>https://juejin.cn/post/7572749797469519881</link>    <guid>https://juejin.cn/post/7572749797469519881</guid>    <pubDate>2025-11-16T14:45:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7572749797469519881" data-draft-id="7572793505900298291" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="C++循环结构探微：深入理解while与do...while"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-11-16T14:45:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码事漫谈"/> <meta itemprop="url" content="https://juejin.cn/user/1972974802965230"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            C++循环结构探微：深入理解while与do...while
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1972974802965230/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码事漫谈
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-16T14:45:46.000Z" title="Sun Nov 16 2025 14:45:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-16
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    19
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在C++编程中，循环是控制流程的基石，用于重复执行一段代码，直到满足特定条件。<code>while</code>和<code>do...while</code>是两种最基本的迭代结构，它们看似相似，但在语义和行为上存在关键差异。理解这些差异对于编写正确、高效和易于维护的代码至关重要。</p>
<hr/>
<h3 data-id="heading-0"><strong>第一章：<code>while</code>循环 - “先验”的迭代者</strong></h3>
<p><code>while</code>循环是一种<strong>前置条件</strong>循环。它首先评估条件，只有当条件为真时，才会执行循环体。</p>
<h4 data-id="heading-1"><strong>1.1 语法与执行流程</strong></h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">while</span> (condition) {
    <span class="hljs-comment">// 循环体：要重复执行的语句</span>
}
</code></pre>
<p><strong>执行流程：</strong></p>
<ol>
<li><strong>评估条件</strong>：计算<code>condition</code>表达式。如果结果为<code>true</code>（非零），继续步骤2；如果为<code>false</code>（零），循环终止，程序继续执行循环之后的代码。</li>
<li><strong>执行循环体</strong>：执行花括号<code>{}</code>内的所有语句。</li>
<li><strong>循环</strong>：完成循环体后，跳回步骤1，重新评估条件。</li>
</ol>
<p>这个流程形成了一个经典的“检查-执行”循环。</p>
<h4 data-id="heading-2"><strong>1.2 哲学与适用场景</strong></h4>
<p><code>while</code>循环的哲学是：<strong>“看不到绿灯，绝不前进”</strong>。它适用于那些<strong>可能一次都不需要执行</strong>的场景。</p>
<p><strong>经典用例：</strong></p>
<ul>
<li><strong>读取未知长度的输入</strong>：在读取文件或用户输入时，通常无法预先知道循环次数。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">int</span> value;
<span class="hljs-keyword">while</span> (std::cin &gt;&gt; value) { <span class="hljs-comment">// 当输入流有效时继续读取</span>
    <span class="hljs-comment">// 处理value</span>
}
</code></pre>
</li>
<li><strong>事件等待循环</strong>：等待某个外部条件成立（如硬件就绪、信号触发）。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isDataReady</span>()) {
    <span class="hljs-comment">// 等待，或者进行一些其他工作</span>
}
</code></pre>
</li>
<li><strong>遍历链表等动态数据结构</strong>：
<pre><code class="hljs language-cpp" lang="cpp">Node* current = head;
<span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-comment">// 处理当前节点</span>
    current = current-&gt;next;
}
</code></pre>
</li>
</ul>
<h4 data-id="heading-3"><strong>1.3 潜在陷阱：无限循环</strong></h4>
<p>如果循环条件永远不为<code>false</code>，<code>while</code>循环将无限执行下去。</p>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-comment">// 警告：无限循环！</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    std::cout &lt;&lt; <span class="hljs-string">"This will print forever!\n"</span>;
}

<span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;
<span class="hljs-comment">// 如果循环体内不修改count，这也将是无限循环</span>
<span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) {
    std::cout &lt;&lt; <span class="hljs-string">"Oops! Count is still "</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-comment">// 忘记写 count--;</span>
}
</code></pre>
<hr/>
<h3 data-id="heading-4"><strong>第二章：<code>do...while</code>循环 - “后验”的保证者</strong></h3>
<p><code>do...while</code>循环是一种<strong>后置条件</strong>循环。它首先无条件地执行一次循环体，然后再评估条件。</p>
<h4 data-id="heading-5"><strong>2.1 语法与执行流程</strong></h4>
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// 循环体：要重复执行的语句</span>
} <span class="hljs-keyword">while</span> (condition); <span class="hljs-comment">// 注意结尾的分号</span>
</code></pre>
<p><strong>执行流程：</strong></p>
<ol>
<li><strong>执行循环体</strong>：无条件地执行循环体内的语句。</li>
<li><strong>评估条件</strong>：计算<code>condition</code>表达式。如果结果为<code>true</code>，跳回步骤1；如果为<code>false</code>，循环终止。</li>
</ol>
<p>这个流程形成了一个“执行-检查”循环。</p>
<h4 data-id="heading-6"><strong>2.2 哲学与适用场景</strong></h4>
<p><code>do...while</code>循环的哲学是：<strong>“无论如何，先做一次再说”</strong>。它保证了<strong>循环体至少被执行一次</strong>。</p>
<p><strong>经典用例：</strong></p>
<ul>
<li><strong>菜单驱动程序</strong>：总是先向用户显示菜单，然后根据用户输入决定是否继续。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">int</span> choice;
<span class="hljs-keyword">do</span> {
    std::cout &lt;&lt; <span class="hljs-string">"1. Option A\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"2. Option B\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"3. Exit\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"Enter your choice: "</span>;
    std::cin &gt;&gt; choice;

    <span class="hljs-comment">// 处理choice...</span>
} <span class="hljs-keyword">while</span> (choice != <span class="hljs-number">3</span>); <span class="hljs-comment">// 如果用户不选择3，则再次显示菜单</span>
</code></pre>
</li>
<li><strong>输入验证</strong>：确保用户至少输入一次有效数据。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">int</span> number;
<span class="hljs-keyword">do</span> {
    std::cout &lt;&lt; <span class="hljs-string">"Please enter a positive number: "</span>;
    std::cin &gt;&gt; number;
} <span class="hljs-keyword">while</span> (number &lt;= <span class="hljs-number">0</span>); <span class="hljs-comment">// 如果输入无效，要求重新输入</span>
</code></pre>
</li>
</ul>
<hr/>
<h3 data-id="heading-7"><strong>第三章：核心差异与深度对比</strong></h3>






























<table><thead><tr><th align="left">特性</th><th align="left"><code>while</code> 循环</th><th align="left"><code>do...while</code> 循环</th></tr></thead><tbody><tr><td align="left"><strong>条件检查时机</strong></td><td align="left">循环<strong>开始前</strong></td><td align="left">循环<strong>结束后</strong></td></tr><tr><td align="left"><strong>最少执行次数</strong></td><td align="left"><strong>0次</strong></td><td align="left"><strong>1次</strong></td></tr><tr><td align="left"><strong>语法</strong></td><td align="left">不需要结尾分号</td><td align="left"><strong>必须</strong>有结尾分号</td></tr><tr><td align="left"><strong>适用性</strong></td><td align="left">条件可能初始为假的情况</td><td align="left">至少需执行一次，且依赖循环体结果的情况</td></tr></tbody></table>
<h4 data-id="heading-8"><strong>3.1 从代码到汇编：底层视角</strong></h4>
<p>在底层（汇编级别），编译器通常会将这两种循环转换为相似的条件跳转指令，但跳转的逻辑点不同。</p>
<ul>
<li><strong><code>while</code>循环的近似逻辑</strong>：
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">start:</span>
  <span class="hljs-keyword">if</span> (condition <span class="hljs-built_in">is</span> <span class="hljs-literal">false</span>) <span class="hljs-keyword">goto</span> <span class="hljs-keyword">end</span>;
  // 循环体代码
  <span class="hljs-keyword">goto</span> start;
<span class="hljs-symbol">end:</span>
</code></pre>
</li>
<li><strong><code>do...while</code>循环的近似逻辑</strong>：
<pre><code class="hljs language-csharp" lang="csharp">start:
  <span class="hljs-comment">// 循环体代码</span>
  <span class="hljs-keyword">if</span> (condition <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">goto</span> start;
</code></pre>
</li>
</ul>
<p>可以看到，<code>do...while</code>循环在结构上更紧凑，它少了一次初始的条件跳转。这在某些情况下可以带来微小的性能优势，因为减少了一次分支预测。</p>
<hr/>
<h3 data-id="heading-9"><strong>第四章：最佳实践与陷阱规避</strong></h3>
<h4 data-id="heading-10"><strong>4.1 选择循环的原则</strong></h4>
<ol>
<li><strong>首选<code>while</code></strong>：在大多数情况下，特别是当循环可能为零次时，<code>while</code>是更安全、更直观的选择。</li>
<li><strong>需要至少一次执行时，使用<code>do...while</code></strong>：当逻辑上要求代码块必须先运行一次时，<code>do...while</code>能准确表达你的意图，使代码更清晰。</li>
<li><strong>避免在<code>do...while</code>中声明变量</strong>：在<code>do</code>块中声明的变量在条件部分不可见，这可能导致错误。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">do</span> {
    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-comment">// ...</span>
} <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 错误！x的作用域仅限于do块内</span>
</code></pre>
正确的做法是在循环外声明变量。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">int</span> x;
<span class="hljs-keyword">do</span> {
    x = <span class="hljs-number">5</span>;
    <span class="hljs-comment">// ...</span>
} <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>);
</code></pre>
</li>
</ol>
<h4 data-id="heading-11"><strong>4.2 通用循环设计建议</strong></h4>
<ul>
<li><strong>确保循环终止</strong>：总是检查循环条件是否最终会变为<code>false</code>。</li>
<li><strong>警惕浮点数条件</strong>：由于精度问题，使用<code>float</code>或<code>double</code>作为循环条件可能导致意外结果。
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-type">double</span> d = <span class="hljs-number">0.0</span>;
<span class="hljs-keyword">while</span> (d != <span class="hljs-number">1.0</span>) { <span class="hljs-comment">// 危险的比较！</span>
    d += <span class="hljs-number">0.1</span>;
    <span class="hljs-comment">// 由于浮点误差，d可能永远不会精确等于1.0</span>
}
</code></pre>
应使用范围比较：
<pre><code class="hljs language-cpp" lang="cpp"><span class="hljs-keyword">while</span> (d &lt; <span class="hljs-number">1.0</span>) {
    d += <span class="hljs-number">0.1</span>;
}
</code></pre>
</li>
<li><strong>使用<code>{}</code>明确作用域</strong>：即使循环体只有一条语句，也使用花括号，这能增强可读性并避免悬垂else等问题。</li>
</ul>
<hr/>
<h3 data-id="heading-12"><strong>第五章：性能考量（现代编译器优化）</strong></h3>
<p>在现代C++编译器中，对于简单的循环，<code>while</code>和<code>do...while</code>的性能差异通常可以忽略不计。编译器强大的优化器（如尾调用优化、循环展开、代码移动等）会生成高度优化的机器码。</p>
<p>性能优化的关键通常不在于选择哪种循环，而在于：</p>
<ul>
<li><strong>减少循环内部的冗余计算</strong>。</li>
<li><strong>优化循环体内的算法和数据结构访问模式</strong>（如缓存友好性）。</li>
<li><strong>在适当的时候使用<code>++i</code>而非<code>i++</code></strong>（对于自定义类型）。</li>
</ul>
<p>因此，在绝大多数场景下，<strong>代码的正确性和可读性应优先于对循环类型进行的微观优化</strong>。</p>
<hr/>
<h3 data-id="heading-13"><strong>结论</strong></h3>
<p><code>while</code>和<code>do...while</code>是C++中相辅相成的两种循环工具。</p>
<ul>
<li><strong><code>while</code></strong> 是你谨慎的伙伴，它坚持“先检查，后行动”的原则，适用于那些需要前置验证的场景。</li>
<li><strong><code>do...while</code></strong> 是你果断的伙伴，它奉行“先行动，后反思”的策略，在保证至少一次执行的情况下非常有用。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue2 和 Vue3 中 watch 用法和原理详解]]></title>    <link>https://juejin.cn/post/7573225720697503796</link>    <guid>https://juejin.cn/post/7573225720697503796</guid>    <pubDate>2025-11-17T06:42:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7573225720697503796" data-draft-id="7573225720697487412" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue2 和 Vue3 中 watch 用法和原理详解"/> <meta itemprop="keywords" content="前端,Vue.js"/> <meta itemprop="datePublished" content="2025-11-17T06:42:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="木易士心"/> <meta itemprop="url" content="https://juejin.cn/user/588993963763751"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue2 和 Vue3 中 watch 用法和原理详解
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/588993963763751/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    木易士心
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-11-17T06:42:31.000Z" title="Mon Nov 17 2025 06:42:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-11-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>@<a href="https://link.juejin.cn?target=%25E7%259B%25AE%25E5%25BD%2595" target="_blank" title="%E7%9B%AE%E5%BD%95" ref="nofollow noopener noreferrer">TOC</a></p>
<h2 data-id="heading-0">1. Vue2 中的 watch</h2>
<h3 data-id="heading-1">1. 基本用法</h3>
<p>在 Vue2 中，watch 是一个对象，其键是要观察的表达式，值是对应的回调函数或包含选项的对象。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 对象写法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">user</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
      }
    }
  },
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-comment">// 监听基本数据类型</span>
    <span class="hljs-title function_">count</span>(<span class="hljs-params">newVal, oldVal</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
    },
    
    <span class="hljs-comment">// 深度监听对象</span>
    <span class="hljs-attr">user</span>: {
      <span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal, oldVal</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'user changed:'</span>, newVal)
      },
      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 深度监听</span>
      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 立即执行</span>
    },
    
    <span class="hljs-comment">// 监听对象特定属性</span>
    <span class="hljs-string">'user.name'</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal, oldVal</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`name changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
    }
  }
}
</code></pre>
<h3 data-id="heading-2">2. 程序式监听</h3>
<p>Vue2 也提供了 $watch API，可以在实例的任何地方监听数据变化。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 使用 $watch API</span>
    <span class="hljs-keyword">const</span> unwatch = <span class="hljs-variable language_">this</span>.$watch(
      <span class="hljs-string">'count'</span>,
      <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count changed: <span class="hljs-subst">${oldVal}</span> -&gt; <span class="hljs-subst">${newVal}</span>`</span>)
      },
      {
        <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">deep</span>: <span class="hljs-literal">false</span>
      }
    )
    
    <span class="hljs-comment">// 取消监听</span>
    <span class="hljs-comment">// unwatch()</span>
  }
}
</code></pre>
<h2 data-id="heading-3">2. Vue3 中的 watch</h2>
<h3 data-id="heading-4">1. 组合式 API 用法</h3>
<p>Vue3 的 watch 更加灵活，支持监听 ref、reactive 对象、getter 函数等多种数据源。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { ref, reactive, watch, watchEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">reactive</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>,
      <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
    })
    
    <span class="hljs-comment">// 监听 ref</span>
    <span class="hljs-title function_">watch</span>(count, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
    })
    
    <span class="hljs-comment">// 监听 reactive 对象</span>
    <span class="hljs-title function_">watch</span>(
      <span class="hljs-function">() =&gt;</span> user.<span class="hljs-property">name</span>, <span class="hljs-comment">// getter 函数</span>
      <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`name changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
      }
    )
    
    <span class="hljs-comment">// 深度监听对象</span>
    <span class="hljs-title function_">watch</span>(
      <span class="hljs-function">() =&gt;</span> user,
      <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'user changed:'</span>, newVal)
      },
      { <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> }
    )
    
    <span class="hljs-comment">// 监听多个源</span>
    <span class="hljs-title function_">watch</span>(
      [<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span>, <span class="hljs-function">() =&gt;</span> user.<span class="hljs-property">name</span>],
      <span class="hljs-function">(<span class="hljs-params">[newCount, newName], [oldCount, oldName]</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count: <span class="hljs-subst">${oldCount}</span>-&gt;<span class="hljs-subst">${newCount}</span>, name: <span class="hljs-subst">${oldName}</span>-&gt;<span class="hljs-subst">${newName}</span>`</span>)
      }
    )
    
    <span class="hljs-comment">// watchEffect - 自动追踪依赖</span>
    <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count is <span class="hljs-subst">${count.value}</span>, name is <span class="hljs-subst">${user.name}</span>`</span>)
    })
    
    <span class="hljs-keyword">return</span> {
      count,
      user
    }
  }
}
</code></pre>
<h3 data-id="heading-5">2. 选项式 API 用法</h3>
<p>Vue3 也支持在选项式 API 中使用 watch，与 Vue2 的用法类似。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { watch } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">user</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
      }
    }
  },
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-title function_">count</span>(<span class="hljs-params">newVal, oldVal</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
    }
  },
  <span class="hljs-title function_">created</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 使用 watch 函数</span>
    <span class="hljs-title function_">watch</span>(
      <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>,
      <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`name changed from <span class="hljs-subst">${oldVal}</span> to <span class="hljs-subst">${newVal}</span>`</span>)
      }
    )
  }
}
</code></pre>
<h2 data-id="heading-6">3.核心原理分析</h2>
<h3 data-id="heading-7">1. Vue2 的 Watch 原理</h3>
<p>Vue2 的 watch 基于响应式系统的依赖收集和派发更新机制。</p>
<ul>
<li>在组件实例初始化阶段，遍历 watch 对象的每一个属性，为每一个监听表达式创建一个 watcher 实例。</li>
<li>watcher 的创建过程：解析表达式，生成 getter 函数；执行 getter 函数，触发依赖收集；保存旧值，等待数据变化。</li>
<li>当被监听的数据发生变化时，触发 setter，通知对应的 watcher 更新；watcher 执行 getter 获取新值，比较新值和旧值，如果不同则执行回调函数。</li>
</ul>
<h3 data-id="heading-8">2. Vue3 的 Watch 原理</h3>
<p>Vue3 的 watch 基于 effect 机制实现。</p>
<ul>
<li>将回调函数包装成一个 effect，当被监听的数据发生变化时，effect 会重新执行。</li>
<li>通过 track 函数进行依赖收集，trigger 函数触发更新。</li>
<li>使用调度器 scheduler 控制 effect 的执行时机，实现异步更新和 flush 选项。</li>
</ul>
<h2 data-id="heading-9">4. 主要差异对比</h2>
<h3 data-id="heading-10">1. 差异总结</h3>
<ul>
<li>Vue2 的 watch 语法较为简单直观，适合选项式 API；Vue3 的 watch 更加灵活，适合组合式 API。</li>
<li>Vue3 的 watch 基于 effect 机制实现，提供了更好的性能和更丰富的配置选项。</li>
<li>两者都支持深度监听、立即执行、异步回调等特性，但在语法和使用方式上有所不同。</li>
</ul>
<h3 data-id="heading-11">2. 特性对比</h3>








































<table><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>API 形式</td><td>选项式</td><td>组合式 + 选项式</td></tr><tr><td>监听 reactive</td><td>不支持</td><td>原生支持</td></tr><tr><td>深度监听</td><td>需要显式配置</td><td>reactive 对象默认深度监听</td></tr><tr><td>多源监听</td><td>不支持</td><td>支持监听多个数据源</td></tr><tr><td>清理副作用</td><td>不支持</td><td>支持 cleanup 函数</td></tr><tr><td>性能</td><td>相对较低</td><td>基于 Proxy，性能更好</td></tr></tbody></table>
<h2 data-id="heading-12">5. 使用建议</h2>
<h3 data-id="heading-13">1. 性能优化</h3>
<p>避免不必要的深度监听，只监听需要的属性。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vue3 - 避免不必要的深度监听</span>
<span class="hljs-keyword">const</span> largeObject = <span class="hljs-title function_">reactive</span>({ <span class="hljs-comment">/* 大量数据 */</span> })

<span class="hljs-comment">// 不好的做法</span>
<span class="hljs-title function_">watch</span>(largeObject, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 任何属性变化都会触发</span>
})

<span class="hljs-comment">// 好的做法 - 只监听需要的属性</span>
<span class="hljs-title function_">watch</span>(
  <span class="hljs-function">() =&gt;</span> largeObject.<span class="hljs-property">importantProp</span>,
  <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 只有 importantProp 变化时触发</span>
  }
)
</code></pre>
<h3 data-id="heading-14">2. 清理副作用</h3>
<p>Vue3 支持在 watch 中清理副作用，避免内存泄漏。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vue3 - 清理副作用</span>
<span class="hljs-title function_">watch</span>(
  data,
  <span class="hljs-keyword">async</span> (newVal, oldVal, onCleanup) =&gt; {
    <span class="hljs-keyword">let</span> cancelled = <span class="hljs-literal">false</span>
    <span class="hljs-title function_">onCleanup</span>(<span class="hljs-function">() =&gt;</span> {
      cancelled = <span class="hljs-literal">true</span>
    })
    
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(newVal)
    <span class="hljs-keyword">if</span> (!cancelled) {
      <span class="hljs-comment">// 处理结果</span>
    }
  }
)
</code></pre>
<h3 data-id="heading-15">3. 防抖处理</h3>
<p>使用防抖函数避免频繁触发 watch 回调。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { debounce } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>

<span class="hljs-comment">// Vue3 防抖监听</span>
<span class="hljs-title function_">watch</span>(
  searchQuery,
  <span class="hljs-title function_">debounce</span>(<span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> {
    <span class="hljs-title function_">searchAPI</span>(newVal)
  }, <span class="hljs-number">300</span>)
)
</code></pre>
<h2 data-id="heading-16">6.常见问题解答</h2>
<h3 data-id="heading-17">1. Vue2 和 Vue3 的 watch 混用？</h3>
<p>在 Vue3 的选项式 API 中，可以继续使用 Vue2 风格的 watch 选项，但不建议混用。</p>
<h3 data-id="heading-18">2. 什么时候用 watch，什么时候用 computed？</h3>
<p>watch 用于执行副作用（如 API 调用、DOM 操作），computed 用于派生数据。</p>
<h3 data-id="heading-19">3. watchEffect 和 watch 的区别？</h3>
<p>watchEffect 自动追踪依赖，立即执行；watch 需要明确指定监听源，默认懒执行。</p>
<p>通过深入理解 Vue2 和 Vue3 中 watch 的用法和原理，可以更好地根据项目需求选择合适的监听方式，并编写出更高效、可维护的代码。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>